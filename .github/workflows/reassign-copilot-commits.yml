name: Reassign Commit Ownership from Copilot to Human Contributor

on:
  pull_request_target:
    types: [closed]

jobs:
  reassign-copilot-commits:
    name: 'Reassign Copilot Commits'
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    permissions:
      contents: write
      pull-requests: read
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0
          token: ${{ secrets.KIBANAMACHINE_TOKEN }}
          
      - name: Configure Git
        run: |
          git config --global user.name "kibanamachine"
          git config --global user.email "42973632+kibanamachine@users.noreply.github.com"
          
      - name: Reassign Copilot commits to human contributor
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          github-token: ${{ secrets.KIBANAMACHINE_TOKEN }}
          script: |
            const { execSync } = require('child_process');
            
            // Get PR details
            const prNumber = context.payload.pull_request.number;
            const prAuthor = context.payload.pull_request.user.login;
            const prAuthorEmail = `${prAuthor}@users.noreply.github.com`;
            const baseBranch = context.payload.pull_request.base.ref;
            const headBranch = context.payload.pull_request.head.ref;
            const headSha = context.payload.pull_request.head.sha;
            
            console.log(`Processing PR #${prNumber} by ${prAuthor}`);
            console.log(`Head branch: ${headBranch}, Base branch: ${baseBranch}`);
            console.log(`Head SHA: ${headSha}`);
            
            // Get commits from the PR
            const commits = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_request_number: prNumber
            });
            
            console.log(`Found ${commits.data.length} commits in PR`);
            
            // Check for Copilot/bot commits
            const copilotCommits = commits.data.filter(commit => {
              const authorLogin = commit.author?.login;
              const committerLogin = commit.committer?.login;
              const authorEmail = commit.commit.author?.email;
              
              return (
                authorLogin === 'github-actions[bot]' ||
                authorLogin === 'copilot' ||
                committerLogin === 'github-actions[bot]' ||
                committerLogin === 'copilot' ||
                authorEmail?.includes('github-actions') ||
                authorEmail?.includes('copilot')
              );
            });
            
            if (copilotCommits.length === 0) {
              console.log('No Copilot/bot commits found. Skipping reassignment.');
              return;
            }
            
            console.log(`Found ${copilotCommits.length} Copilot/bot commits to reassign`);
            
            // Validate that we have a human contributor to assign to
            if (!prAuthor || prAuthor.includes('[bot]')) {
              console.error('No valid human contributor found for reassignment');
              throw new Error('Cannot reassign commits: No human contributor identified');
            }
            
            // Get the actual user email from GitHub API
            let humanEmail = prAuthorEmail;
            try {
              const userData = await github.rest.users.getByUsername({
                username: prAuthor
              });
              if (userData.data.email && !userData.data.email.includes('noreply')) {
                humanEmail = userData.data.email;
              }
            } catch (error) {
              console.log(`Could not fetch user email, using default: ${prAuthorEmail}`);
            }
            
            console.log(`Will reassign commits to: ${prAuthor} <${humanEmail}>`);
            
            // Check if we're on the correct branch
            try {
              execSync(`git checkout ${headBranch}`, { stdio: 'inherit' });
            } catch (error) {
              console.log('Branch checkout failed, continuing with current branch');
            }
            
            // Create a backup branch
            const backupBranch = `backup-${headBranch}-${Date.now()}`;
            execSync(`git checkout -b ${backupBranch}`, { stdio: 'inherit' });
            execSync(`git checkout ${headBranch}`, { stdio: 'inherit' });
            
            // Rewrite commit history
            let hasRewritten = false;
            for (const commit of copilotCommits) {
              const commitSha = commit.sha;
              const originalMessage = commit.commit.message;
              
              console.log(`Rewriting commit ${commitSha}: ${originalMessage.split('\n')[0]}`);
              
              try {
                // Use git filter-repo or git filter-branch to rewrite the specific commit
                const filterCommand = `git filter-branch -f --env-filter '
                  if [ "$GIT_COMMIT" = "${commitSha}" ]; then
                    export GIT_AUTHOR_NAME="${prAuthor}"
                    export GIT_AUTHOR_EMAIL="${humanEmail}"
                    export GIT_COMMITTER_NAME="${prAuthor}"
                    export GIT_COMMITTER_EMAIL="${humanEmail}"
                  fi
                ' HEAD`;
                
                execSync(filterCommand, { stdio: 'inherit' });
                hasRewritten = true;
              } catch (error) {
                console.error(`Failed to rewrite commit ${commitSha}:`, error.message);
                // Continue with other commits
              }
            }
            
            if (hasRewritten) {
              console.log('Successfully rewrote commit history');
              
              // Force push the rewritten history
              try {
                execSync(`git push --force-with-lease origin ${headBranch}`, { stdio: 'inherit' });
                console.log('Successfully pushed rewritten commits');
                
                // Add a comment to the PR
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `âœ… **Copilot Commit Ownership Reassigned**\n\nSuccessfully reassigned ${copilotCommits.length} Copilot/bot commits to @${prAuthor} for CLA compliance.\n\n**Commits reassigned:**\n${copilotCommits.map(c => `- ${c.sha.substring(0, 7)}: ${c.commit.message.split('\n')[0]}`).join('\n')}`
                });
                
              } catch (pushError) {
                console.error('Failed to push rewritten commits:', pushError.message);
                
                // Restore backup branch
                execSync(`git checkout ${backupBranch}`, { stdio: 'inherit' });
                execSync(`git branch -D ${headBranch}`, { stdio: 'inherit' });
                execSync(`git checkout -b ${headBranch}`, { stdio: 'inherit' });
                execSync(`git push --force-with-lease origin ${headBranch}`, { stdio: 'inherit' });
                
                throw new Error('Failed to push rewritten commits, restored original state');
              }
            } else {
              console.log('No commits were successfully rewritten');
            }
            
            // Cleanup backup branch
            try {
              execSync(`git branch -D ${backupBranch}`, { stdio: 'inherit' });
            } catch (error) {
              console.log('Could not delete backup branch, this is okay');
            }