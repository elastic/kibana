/*
 * Timesheet syntax parser
 */

start
 = series+

arg_list
 = argument*

argument
 = arg_name:function_name '=' element:arg_type ','? space? {return {type: 'namedArg', name:arg_name, value:element}}
 / element:arg_type ','? space? {return element}

arg_type
 = number
 / function
 / series
 / string

series
 = series:series_type ','? space? { return series }

series_type
 = grouped_chain
 / chain
 / function
 / request
 / reference

chained_function
 = '.' func:function {
  return func
 }

group
 = '(' grouped:series+ ')'

chain 
 = func:function rest:chained_function* {
  return {type: 'chain', chain: [func].concat(rest)}
}

grouped_chain
 = '(' space? first:series+ space? ')' rest:chained_function* {
  first = {
    type: 'chainList',
    list: first
  }
  first.label = text();

  return {type: "chain", chain: [first].concat(rest)};
 }

function_name 
 = (first:[a-zA-Z]+ rest:[a-zA-Z0-9]* ) { return first.join('') + rest.join('') }

function "function"
 = (name:function_name '(' space? arguments:arg_list space? ')' space? ','? space?) {
  var result = {
    type: 'function',
    function: name
  }
  if (arguments) {result.arguments = arguments;}
  return result;
 }

reference
 = plot:integer ':' series:integer {
  return {
   type: 'reference',
   plot: plot,
   series: series
  }
 }

number
 = number:([-+]? integer '.'? integer?) {return parseFloat(number.join(''))}

integer
 = digits:DIGIT+ {return parseInt(digits.join(''))}

query
 = '`' q:[^`]* '`' {return q.join('')}

request_operator
 = space? operator:function_name '=' arguments:string space? {
  return {
   type: 'namedArg',
   name: operator,
   value: arguments
  }
 }

request_operator_argument
 = argument:([a-zA-Z0-9\-_\*.+:]+ / string) {
  return argument.join('');
 }

request
 = query:query arguments:(request_operator+)?
 {
  var obj = {
    type: 'function',
    function: 'es',
    arguments: [query]
  }
  if (arguments) {
   obj.arguments = obj.arguments.concat(arguments)
  }
  return obj;
 }

space
 = [\ \t]+

 /* ----- Strings, borrowed from the PEGJS JSON parser ----- */

string "string"
 = quotation_mark chars:char* quotation_mark { return chars.join(''); }
 / chars:unquoted_char+ { return chars.join(''); }

unquoted_char 
 = [-_*.+a-zA-Z0-9#\u00A0-\u10FFFF]

char
  = unescaped
  / escape
    sequence:(
        '"'
      / "\\"
      / "/"
      / "b" { return "\b"; }
      / "f" { return "\f"; }
      / "n" { return "\n"; }
      / "r" { return "\r"; }
      / "t" { return "\t"; }
      / "u" digits:$(HEXDIG HEXDIG HEXDIG HEXDIG) {
          return String.fromCharCode(parseInt(digits, 16));
        }
    )
    { return sequence; }

escape         = "\\"
quotation_mark = '"'
unescaped      = [\x20-\x21\x23-\x5B\x5D-\u10FFFF]

/* ----- Core ABNF Rules ----- */

/* See RFC 4234, Appendix B (http://tools.ietf.org/html/rfc4627). */
DIGIT  = [0-9]
HEXDIG = [0-9a-f]i