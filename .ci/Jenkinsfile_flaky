#!/bin/groovy

library 'kibana-pipeline-library@add-library-loader'
kibanaLibrary.load()

testLib.test()

// Looks like 'oss:ciGroup:1' or 'oss:firefoxSmoke'
def JOB_PARTS = params.CI_GROUP.split(':')
def IS_XPACK = JOB_PARTS[0] == 'xpack'
def JOB = JOB_PARTS[1]
def CI_GROUP = JOB_PARTS[2] ?: ''

def worker = getWorkerFromParams(IS_XPACK, JOB, CI_GROUP)

def workerFailures = []

currentBuild.displayName += trunc(" ${params.GITHUB_OWNER}:${params.branch_specifier}", 24)
currentBuild.description = "${params.CI_GROUP}<br />Executions: ${params.NUMBER_EXECUTIONS}"

stage("Kibana Pipeline") {
  timeout(time: 180, unit: 'MINUTES') {
    timestamps {
      ansiColor('xterm') {
        catchError {
          withWorkers('flaky-test-runner', {
            if (!IS_XPACK) {
              buildOss()
              if (CI_GROUP == '1') {
                runbld "./test/scripts/jenkins_build_kbn_tp_sample_panel_action.sh"
              }
            } else {
              buildXpack()
            }
          }, getWorkerMap(params.NUMBER_EXECUTIONS.toInteger(), worker, workerFailures))()
        }

        currentBuild.description += ", Failures: ${workerFailures.size()}"

        if (workerFailures.size() > 0) {
          print "There were ${workerFailures.size()} test suite failures."
          print "The executions that failed were:"
          print workerFailures.join("\n")
          print "Please check 'Test Result' and 'Pipeline Steps' pages for more info"
        }
      }
    }
  }
}

def withWorkers(name, preWorkerClosure = {}, workerClosures = [:]) {
  return {
    jobRunner('tests-xl') {
      try {
        doSetup()
        preWorkerClosure()

        def nextWorker = 1
        def worker = { workerClosure ->
          def workerNumber = nextWorker
          nextWorker++

          return {
            workerClosure(workerNumber)
          }
        }

        def workers = [:]
        workerClosures.each { workerName, workerClosure ->
          workers[workerName] = worker(workerClosure)
        }

        parallel(workers)
      } finally {
        catchError {
          uploadAllGcsArtifacts(name)
        }

        catchError {
          runbldJunit()
        }

        catchError {
          publishJunit()
        }
      }
    }
  }
}

def getPostBuildWorker(name, closure) {
  return { workerNumber ->
    def kibanaPort = "61${workerNumber}1"
    def esPort = "61${workerNumber}2"
    def esTransportPort = "61${workerNumber}3"

    withEnv([
      "CI_WORKER_NUMBER=${workerNumber}",
      "TEST_KIBANA_HOST=localhost",
      "TEST_KIBANA_PORT=${kibanaPort}",
      "TEST_KIBANA_URL=http://elastic:changeme@localhost:${kibanaPort}",
      "TEST_ES_URL=http://elastic:changeme@localhost:${esPort}",
      "TEST_ES_TRANSPORT_PORT=${esTransportPort}",
    ]) {
      closure()
    }
  }
}

def getOssCiGroupWorker(ciGroup) {
  return getPostBuildWorker("ciGroup" + ciGroup, {
    withEnv([
      "CI_GROUP=${ciGroup}",
      "JOB=" + env.JOB ?: "kibana-ciGroup${ciGroup}",
    ]) {
      runbld "./test/scripts/jenkins_ci_group.sh"
    }
  })
}

def getXpackCiGroupWorker(ciGroup) {
  return getPostBuildWorker("xpack-ciGroup" + ciGroup, {
    withEnv([
      "CI_GROUP=${ciGroup}",
      "JOB=" + env.job ?: "xpack-kibana-ciGroup${ciGroup}",
    ]) {
      runbld "./test/scripts/jenkins_xpack_ci_group.sh"
    }
  })
}

def jobRunner(label, closure) {
  node(label) {
    def scmVars = checkout scm

    withEnv([
      "CI=true",
      "IS_PIPELINE_JOB=1",
      "HOME=${env.JENKINS_HOME}",
      "PR_SOURCE_BRANCH=${env.ghprbSourceBranch ?: ''}",
      "PR_TARGET_BRANCH=${env.ghprbTargetBranch ?: ''}",
      "PR_AUTHOR=${env.ghprbPullAuthorLogin ?: ''}",
      "TEST_BROWSER_HEADLESS=1",
      "GIT_BRANCH=${scmVars.GIT_BRANCH}",
    ]) {
      withCredentials([
        string(credentialsId: 'vault-addr', variable: 'VAULT_ADDR'),
        string(credentialsId: 'vault-role-id', variable: 'VAULT_ROLE_ID'),
        string(credentialsId: 'vault-secret-id', variable: 'VAULT_SECRET_ID'),
      ]) {
        // scm is configured to check out to the ./kibana directory
        dir('kibana') {
          closure()
        }
      }
    }
  }
}

def uploadGcsArtifact(workerName, pattern) {
  def storageLocation = "gs://kibana-ci-artifacts/jobs/${env.JOB_NAME}/${BUILD_NUMBER}/${workerName}"

  googleStorageUpload(
    credentialsId: 'kibana-ci-gcs-plugin',
    bucket: storageLocation,
    pattern: pattern,
    sharedPublicly: true,
    showInline: true,
  )
}

def uploadAllGcsArtifacts(workerName) {
  def ARTIFACT_PATTERNS = [
    'target/kibana-*',
    'target/junit/**/*',
    'test/**/screenshots/**/*.png',
    'test/functional/failure_debug/html/*.html',
    'x-pack/test/**/screenshots/**/*.png',
    'x-pack/test/functional/failure_debug/html/*.html',
    'x-pack/test/functional/apps/reporting/reports/session/*.pdf',
  ]

  ARTIFACT_PATTERNS.each { pattern ->
    uploadGcsArtifact(workerName, pattern)
  }
}

def publishJunit() {
  junit(testResults: 'target/junit/**/*.xml', allowEmptyResults: true, keepLongStdio: true)
}

def runbld(script, enableJunitProcessing = false) {
  def extraConfig = enableJunitProcessing ? "" : "--config ${env.WORKSPACE}/kibana/.ci/runbld_no_junit.yml"

  sh "/usr/local/bin/runbld -d '${pwd()}' ${extraConfig} ${script}"
}

def runbldJunit() {
  sh "/usr/local/bin/runbld -d '${pwd()}' ${env.WORKSPACE}/kibana/test/scripts/jenkins_runbld_junit.sh"
}

def bash(script) {
  sh "#!/bin/bash\n${script}"
}

def doSetup() {
  runbld "./test/scripts/jenkins_setup.sh"
}

def buildOss() {
  runbld "./test/scripts/jenkins_build_kibana.sh"
}

def buildXpack() {
  runbld "./test/scripts/jenkins_xpack_build_kibana.sh"
}

def runErrorReporter() {
  bash """
    source src/dev/ci_setup/setup_env.sh
    node src/dev/failed_tests/cli
  """
}

def getWorkerFromParams(isXpack, job, ciGroup) {
  if (!isXpack) {
    if (job == 'firefoxSmoke') {
      return getPostBuildWorker('firefoxSmoke', { runbld './test/scripts/jenkins_firefox_smoke.sh' })
    } else if(job == 'visualRegression') {
      return getPostBuildWorker('visualRegression', { runbld './test/scripts/jenkins_visual_regression.sh' })
    } else {
      return getOssCiGroupWorker(ciGroup)
    }
  }

  if (job == 'firefoxSmoke') {
    return getPostBuildWorker('xpack-firefoxSmoke', { runbld './test/scripts/jenkins_xpack_firefox_smoke.sh' })
  } else if(job == 'visualRegression') {
    return getPostBuildWorker('xpack-visualRegression', { runbld './test/scripts/jenkins_xpack_visual_regression.sh' })
  } else {
    return getXpackCiGroupWorker(ciGroup)
  }
}

def getWorkerMap(numberOfExecutions, worker, workerFailures, maxWorkers = 14) {
  def workerMap = [:]
  def numberOfWorkers = Math.min(numberOfExecutions, maxWorkers)

  for(def i = 1; i <= numberOfWorkers; i++) {
    def workerExecutions = numberOfExecutions/numberOfWorkers + (i <= numberOfExecutions%numberOfWorkers ? 1 : 0)

    workerMap["worker-${i}"] = { workerNumber ->
      for(def j = 0; j < workerExecutions; j++) {
        print "Execute worker-${workerNumber}: ${j}"
        withEnv(["JOB=worker-${workerNumber}-${j}"]) {
          catchError {
            try {
              worker(workerNumber)
            } catch (ex) {
              workerFailures << "worker-${workerNumber}-${j}"
              throw ex
            }
          }
        }
      }
    }
  }

  return workerMap
}

def trunc(str, length) {
  if (str.size() >= length) {
    return str.take(length) + "..."
  }

  return str;
}
