# =============================================================================
# Workflow: Chess Game Demo
# Category: examples
#
# DESIGN: Use foreach with data.set to maintain state across iterations.
# The key insight is that `variables.board` contains the LATEST board state
# from the MOST RECENT data.set step execution.
#
# Turn structure:
# 1. AI reads current board from variables.board (or inputs.board for turn 1)
# 2. AI makes a move and stores new board in data.set
# 3. Human makes a move via waitForInput
# 4. Human's move is stored in data.set (updating variables.board)
# 5. Loop continues - AI reads variables.board which now has human's move
#
# Author: Elastic
# Created: 2025-01-22
# Tags: demo, human-in-the-loop, chess
# =============================================================================
version: "1"
name: Chess Game Demo
description: Play chess against an AI using workflow human-in-the-loop functionality
enabled: true
tags: ["demo", "human-in-the-loop", "chess"]

triggers:
  - type: manual

inputs:
  properties:
    board:
      type: string
      description: Initial board state in FEN notation
      default: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'

steps:
  # Initialize game state - this sets variables.board to the initial position
  - name: init_game
    type: data.set
    with:
      board: '{{ inputs.board }}'
      gameOver: false
      turnNumber: 0
      lastMove: ''
      lastMoveBy: ''

  # Main game loop - up to 50 turns (100 half-moves)
  - name: game_loop
    type: foreach
    foreach: '[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]'
    steps:
      # Check if game should continue
      - name: check_game_continues
        type: if
        condition: 'not variables.gameOver: true'
        steps:
          # AI's turn - read board from variables (which has the latest state)
          - name: ai_turn
            type: ai.prompt
            with:
              prompt: |
                You are a chess engine playing as WHITE. Analyze the board and make the best legal move.

                Current board state (FEN): {{ variables.board }}
                Turn number: {{ foreach.item }}

                RULES:
                1. You are WHITE - only move WHITE pieces (uppercase letters in FEN: R, N, B, Q, K, P)
                2. Output your move in coordinate notation: [from][to] (e.g., "e2e4", "g1f3", "e1g1" for kingside castle)
                3. For pawn promotion, add the piece letter: "e7e8q" for queen promotion
                4. Verify the move is legal according to chess rules

                CRITICAL FEN REQUIREMENTS:
                - FEN must have EXACTLY 8 ranks separated by "/"
                - Format: rank8/rank7/rank6/rank5/rank4/rank3/rank2/rank1 side castling en-passant halfmove fullmove
                - Each rank must have pieces and numbers that sum to exactly 8
                - DO NOT truncate the FEN - include ALL 8 ranks and ALL metadata
                - Example complete FEN: "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1"

                Respond with ONLY a JSON object:
                {
                  "move": "e2e4",
                  "newBoard": "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1",
                  "reasoning": "Control the center with king's pawn",
                  "isCheckmate": false,
                  "isStalemate": false
                }
              outputSchema:
                type: object
                properties:
                  move:
                    type: string
                    description: "Move in coordinate notation: [from][to], e.g., e2e4"
                  newBoard:
                    type: string
                    description: "Board state in FEN notation after the move"
                  reasoning:
                    type: string
                    description: "Brief explanation of why this move was chosen"
                  isCheckmate:
                    type: boolean
                    description: "True if this move results in checkmate"
                  isStalemate:
                    type: boolean
                    description: "True if this move results in stalemate"
                required: [move, newBoard]

          # Store AI's move - this updates variables.board for the next read
          - name: store_ai_move
            type: data.set
            with:
              board: '{{ steps.ai_turn.output.content.newBoard }}'
              lastMove: '{{ steps.ai_turn.output.content.move }}'
              lastMoveBy: 'AI'
              aiReasoning: '{{ steps.ai_turn.output.content.reasoning }}'
              turnNumber: '{{ foreach.item }}'
              gameOver: '{{ steps.ai_turn.output.content.isCheckmate | default: false }}'

          # Check if AI won
          - name: check_ai_win
            type: if
            condition: 'not steps.ai_turn.output.content.isCheckmate: true'
            steps:
              # Wait for human's move (or error report about AI's invalid move)
              - name: wait_for_human
                type: waitForInput
                with:
                  timeout: 30m
                  message: "Turn {{ foreach.item }}: Your move (you are Black)!"
                  inputSchema:
                    type: object
                    properties:
                      move:
                        type: string
                        description: "Move in coordinate notation: [from][to], e.g., e7e5"
                      newBoard:
                        type: string
                        description: "Board state in FEN notation after the move"
                      gameOver:
                        type: boolean
                        description: "True if the game has ended"
                      aiMoveInvalid:
                        type: boolean
                        description: "True if reporting an invalid AI move"
                      invalidMove:
                        type: string
                        description: "The invalid move that AI attempted (when aiMoveInvalid is true)"
                      errorMessage:
                        type: string
                        description: "Error message describing why the AI move was invalid"
                      currentBoard:
                        type: string
                        description: "The current valid board state (when reporting invalid AI move)"
                    required: [move, newBoard]

              # Store human's move - this step runs for ALL human responses
              # If aiMoveInvalid is true, the board field will be empty, which is fine
              # because we'll retry with AI and overwrite it
              - name: store_human_move
                type: data.set
                with:
                  board: '{{ steps.wait_for_human.output.input.newBoard | default: variables.board }}'
                  lastMove: '{{ steps.wait_for_human.output.input.move | default: "" }}'
                  lastMoveBy: 'Human'
                  turnNumber: '{{ foreach.item }}'
                  gameOver: '{{ steps.wait_for_human.output.input.gameOver | default: false }}'
                  aiMoveWasInvalid: '{{ steps.wait_for_human.output.input.aiMoveInvalid | default: false }}'

  # Game over summary
  - name: game_summary
    type: data.set
    with:
      finalBoard: '{{ variables.board }}'
      totalTurns: '{{ variables.turnNumber }}'
      gameStatus: 'completed'
      message: 'Game ended after {{ variables.turnNumber }} turns'
