[[development-using-visualizations]]
=== Using Visualizations

There are two ways to insert visualization in your page. Using `<visualize>` directive or using `<visualization>` directive.
The following assumes you are using AngularJS in your plugin.

==== `<visualize>` directive
`<visualize>` directive takes a savedVis object and it takes care of loading data, parsing data, 
rendering the editor (if in edit mode) and rendering the visualization. Its the easiest way to add visualization to your
page under the assumption that the visualization you are trying to display is saved in kibana. If that is not the case
take a look at using <visualization> directive. 

Once <visualize> is done rendering the element will emit `renderComplete` event.

`<visualize saved-obj='savedVis' app-state='appState' ui-state='uiState' editor-mode='false'></visualize>` where

`savedVis` is an instance of savedVisualization object, which can be retrieved using `savedVisualizations` service
which is explained later in this documentation.

`appState` is an instance of `AppState`. <visualize> is expecting two keys defined on AppState:

- `filters` which is an instance of searchSource filter object and
- `query` which is an instance of searchSource query object

if not provided <visualize> will still work, just without monitoring the AppState.

`uiState` should be an instance of `PersistedState`. if not provided visualize will generate one, 
but you will have no access to it. Its used to store viewer specific information (like is legend toggled or not)

`editor-mode` defines if <visualize> should render in editor or in view mode.

*code example: showing saved visualization, without linking to querybar or filterbar*
["source","html"]
-----------
<div ng-controller="KbnTestController" class="test_vis">
  <visualize saved-obj='savedVis'></visualize>
</div>
-----------
["source","js"]
-----------
import { uiModules } from 'ui/modules';

uiModules.get('kibana')
.controller('KbnTestController', function ($scope, AppState, savedVisualizations) {
  const visId = 'enter_your_vis_id';
  savedVisualizations.get(visId).then(savedVis => $scope.savedObj = savedVis);
});
-----------

When <visualize> is ready it will emit `ready:vis` event on the root scope.
When <visualize> is done rendering it will emit `renderComplete` event on the element.

==== `<visualization>` directive
`<visualization>` directive takes visualization config and data and renders the appropriate visualization.

`<visualization vis='vis' vis-data='visData' ui-state='uiState' ></visualization>` where

`vis` is an instance of `Vis` object. The constructor takes 3 parameters:

- indexPattern (string): the indexPattern you want to pass to the visualization
- visConfig (object): the configuration object
- uiState (object): uiState object you want to pass to Vis. If not provided Vis will create its own.

`visData` is the data object visualization expects. This is a bit tricky at the moment as visualizations still expect object which is tightly coupled to ES, but this should change (visualizations should probably take some sort of tabular data .... response_converters should be responsible for converting ES data in appropriate format.)

`uiState` is an instance of PersistedState. Visualization uses it to keep track of its current state. If not provided 
<visualization> will create its own (but you won't be able to check its values)

*code example: create single metric visualization*
["source","html"]
-----------
<div ng-controller="KbnTestController" class="test_vis">
  <visualization vis='vis' vis-data='visData'></visualize>
</div>
-----------
["source","js"]
-----------
import { uiModules } from 'ui/modules';

uiModules.get('kibana')
.controller('KbnTestController', function ($scope) {
  const visConfig = {
    type: 'metric'
  };
  $scope.vis = new Vis('.logstash*', visConfig);
  $scope.visData = [{ name: 'Count', value: '543534' }]; // this won't yet work as metric vis still accepts data as aggresponse object
});
-----------

<visualization> will trigger `renderComplete` event on the element once it's done rendering.