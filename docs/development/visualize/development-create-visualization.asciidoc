[[development-create-visualization]]
=== Developing Visualizations

This is a short description of functions and interfaces provided. For more information you should check the kibana
source code and the existing visualizations provided with it.

* <<development-react-visualization-type>>
* <<development-vislib-visualization-type>>
- <<development-vis-editors>>
* <<development-default-editor>>
* <<development-custom-editor>>
- <<development-visualization-request-handlers>>
* <<development-default-request-handler>>
* <<development-none-request-handler>>
* <<development-custom-request-handler>>
- <<development-visualization-response-handlers>>
* <<development-default-response-handler>>
* <<development-none-response-handler>>
* <<development-custom-response-handler>>
- <<development-vis-object>>
* <<development-vis-timefilter>>

[[development-visualization-factory]]
=== Visualization Factory

To create a new visualization you need to create new visualization type using the VisualizationFactory. 
The factory can create `Base`, `Angular`, `React` and `Vislib` visualization.

["source","html"]
-----------
import { VisFactoryProvider } from 'ui/vis/vis_factory';

export default function MyNewVisType(Private) {
  const VisFactory = Private(VisFactoryProvider);

  return  VisFactory.createBaseVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    ...
  });
}
-----------

The list of common parameters:

- *name*: unique visualization name, only lowercase letters and underscore
- *title*: title of your visualization as displayed in kibana
- *icon*: the icon class to use (font awesome)
- *image*: instead of icon you can provide svg image (imported)
- *description*: description of your visualization as shown in kibana
- *category*: the category your visualization falls into (one of `ui/vis/vis_category` values)
- *visConfig*: object holding visualization parameters
- *visConfig.defaults*: object holding default visualization configuration
- *visualization*: A constructor function for a Visualization.
- *requestHandler*: <string> one of the available request handlers or <function> for custom one
- *responseHandler*: <string> one of the available response handlers or <function> for custom one
- *editor*: <string> one of the available editors or Editor class for custom one
- *editorConfig*: object holding editor parameters
- *options.showTimePicker*: <bool> show or hide time picker (defaults to true)
- *options.showQueryBar*: <bool> show or hide query bar (defaults to true)
- *options.showFilterBar*: <bool> show or hide filter bar (defaults to true)
- *options.showIndexSelection*: <bool> show or hide index selection (defaults to true)
- *options.hierarchicalData*: <bool> use hierarchical data (defaults to false) [BWC]
- *isExperimental*: <bool> mark visualization as experimental (defaults to false)


Each of the factories have some of the custom parameters, which will be described below.

[[development-base-visualization-type]]
==== Base Visualization Type
The base visualization type does not make any assumptions about the rendering technology you are going to use and
works with pure javascript. Its the visualization type we recommend to use.

You need to provide an object with constructor, render function which will be called every time options 
or data change and destroy function which will be called to cleanup.
 
The render function receives the data object and status object which tells what actually changed.
Render function needs to return a promise, which should be resolved once the visualization is done rendering.

image::images/visualize-flow.png[Main Flow]


["source","js"]
-----------
import { VisFactoryProvider } from 'ui/vis/vis_factory';

class MyVisualization {
   constructor(vis, el) {
      this.el = el;
      this.vis = vis;
   }
   render(visData, status) {
      return new Promise(resolve => {
         ...
         resolve('done rendering');
      }),
   destroy() {
      console.log('destroying');
   }
}

export default function MyNewVisType(Private) {
  const VisFactory = Private(VisFactoryProvider);

  return VisFactory.createBaseVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    visualization: MyVisualization
  });
}
-----------

[[development-angular-visualization-type]]
==== Angular Visualization Type
Angular visualization type assumes you are using angular as your rendering technology. Instead of providing the
controller we need to provide the angular template to render. 

Visualization will receive vis, uiState and visData on the $scope and needs to call $scope.renderComplete() once 
its done rendering.

["source","js"]
-----------
export default function MyNewVisType(Private) {
  const VisFactory = Private(VisFactoryProvider);
  
  return VisFactory.createAngularVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    visConfig: {
       template: '<div ng-controller="MyAngularController"></div>`
    }
  });
}
-----------

[[development-react-visualization-type]]
==== React Visualization Type
React visualization type assumes you are using React as your rendering technology. Instead of passing it an angular
template you need to pass React component.

Visualization will receive vis, uiState and visData as props as well as the renderComplete which should be called once
done rendering.

["source","js"]
-----------
import { ReactComponent } from './my_react_component';

export default function MyNewVisType(Private) {
  const VisFactory = Private(VisFactoryProvider);
  
  return VisFactory.createReactVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    visConfig: {
       template: ReactComponent
    }
  });
}
-----------

[[development-vislib-visualization-type]]
==== Vislib Visualization Type
This visualization type should only be used for `vislib` visualizations. Vislib is kibana's D3 library which can produce
point series charts and pie charts.

[[development-vis-editors]]
=== Visualization Editors
By default visualization will use the `default` editor (which is the sidebar editor you see in current kibana charts) but can be changed. Currently no other editors are provided (`timelion` editor will probably be added in the near future). Plugin can register a new editor in registry to make it available to other visualizations, but is not necessary (if its a one-time thing which will not be reused)

[[development-default-editor]]
==== `default` editor controller
The default editor controller can receive `optionsTemplate` or `optionsTabs` parameter which can be either an angular template or react component. React component will receive two params: scope, which is an angular scope and stageEditorParams which will update the editor with parameters set in react component.

["source","js"]
-----------
{
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    editorController: 'default',
    editorConfig: {
       optionsTemplate: '<my-custom-options-directive></my-custom-options-directive>' // or
       optionsTabs: [
           { title: 'tab 1', template: '<div>....</div> },
           { title: 'tab 2', template: '<my-custom-options-directive></my-custom-options-directive>' }
       ]
    }
  }
-----------

[[development-custom-editor]]
==== custom editor controller
You can create a custom editor controller. To do so pass an Editor object (the same format as VisController class). 
You can make your controller take extra configuration which is passed to the editorConfig property.

["source","js"]
-----------
import { VisFactoryProvider } from 'ui/vis/vis_factory';

class MyEditorController {
    constructor(el, vis) {
      this.el = el;
      this.vis = vis;
   }
   render(visData) {
      return new Promise(resolve => {
         ...
         resolve('done rendering');
      }),
   destroy() {
      console.log('destroying');
   }
}

export default function MyNewVisType(Private) {
  const VisFactory = Private(VisFactoryProvider);

  return VisFactory.createAngularVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    editorController: MyEditorController,
    editorConfig: { my: 'custom config' }
  });
}
-----------

[[development-visualization-request-handlers]]
=== Visualization Request Handlers
By default visualizations will use courier request handler. They can also choose to use any of the other provided 
request handlers. Its also possible to define your own request handler 
(which you can then register to be used by other visualizations)

[[development-default-request-handler]]
==== courier request handler
'courier' is the default request handler which works with out 'default' side bar editor.

[[development-none-request-handler]]
==== `none` request handler
Using 'none' as your request handles means your visualization does not require search.

[[development-custom-request-handler]]
==== custom request handler
You can define your custom request handler by providing a function with the following definition:
`function (vis, appState, uiState, searchSource) { ... }`

[[development-visualization-response-handlers]]
=== Visualization Response Handlers
Response handler will receive the data from request handler and an instance of Vis object. Its job is to convert the data to a format visualization can use.
by default 'none' request handler is used which just passes the data it receives back, but can be changed to 'basic' (which VislibVisTypeFactory uses) or to a custom one.

[[development-default-response-handler]]
==== default response handler
Default response handler will convert pure elasticsearch response to tabular format.

[[development-none-response-handler]]
==== none response handler
None response handler is an identity function, which will return the pure elasticsearch response.

[[development-custom-response-handler]]
==== custom response handler
You can define your custom response handler by providing a function with the following definition:
'function (vis, response) { ... }'

[[development-vis-object]]
=== Vis object
Vis object holds the visualization state and is the window into kibana:

- *vis.params*: holds the visualization parameters
- *vis.indexPattern*: selected index pattern object
- *vis.getState()*: gets current visualization state 
- *vis.updateState()*: updates current state with values from `vis.params`
- *vis.resetState()*: resets `vis.params` to the values in the current state
- *vis.getUiState()*: gets UI state of visualization
- *vis.uiStateVal(name, val)*: updates a property in UI state
- *vis.isEditorMode()*: returns true if in editor mode
- *vis.API.timeFilter*: allows you to access time picker
- *vis.API.events.click*: default click handler
- *vis.API.events.brush*: default brush handler

Visualization gets all its parameters in `vis.params` (defaults merged with the current state). If it wants to update them it should update them in this object and then call `vis.updateState()` which will inform <visualize> about the change, which will call request and response handler and then your visualizations render method.

For the parameters that should not be saved with visualization you should use UI state (such as current state: popup open/closed, custom colors applied to the series etc)

You can access filter bar and time picker thru the objects defined on `vis.API`

[[development-vis-timefilter]]
==== timeFilter

Update the timefilter time values and call update() method on it to update time picker
["source","js"]
-----------
   timefilter.time.from = moment(ranges.xaxis.from);
   timefilter.time.to = moment(ranges.xaxis.to);
   timefilter.time.mode = 'absolute';
   timefilter.update();
-----------