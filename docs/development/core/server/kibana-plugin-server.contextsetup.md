<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [kibana-plugin-server](./kibana-plugin-server.md) &gt; [ContextSetup](./kibana-plugin-server.contextsetup.md)

## ContextSetup interface

<b>Signature:</b>

```typescript
export interface ContextSetup 
```

## Methods

|  Method | Description |
|  --- | --- |
|  [createContextContainer()](./kibana-plugin-server.contextsetup.createcontextcontainer.md) | Creates a new  for a service owner. |

## Example

Say we're creating a plugin for rendering visualizations that allows new rendering methods to be registered. If we want to offer context to these rendering methods, we can leverage the ContextService to manage these contexts.

```ts
export interface VizRenderContext {
  core: {
    i18n: I18nStart;
    uiSettings: UISettingsClientContract;
  }
  [contextName: string]: unknown;
}

export type VizRenderer = (context: VizRenderContext, domElement: HTMLElement) => () => void;

class VizRenderingPlugin {
  private readonly vizRenderers = new Map<string, ((domElement: HTMLElement) => () => void)>();

  constructor(private readonly initContext: PluginInitializerContext) {}

  setup(core) {
    this.contextContainer = core.context.createContextContainer<
      VizRenderContext,
      ReturnType<VizRenderer>,
      [HTMLElement]
    >();

    return {
      registerContext: this.contextContainer.registerContext,
      registerVizRenderer: (plugin: PluginOpaqueId, renderMethod: string, renderer: VizTypeRenderer) =>
        this.vizRenderers.set(renderMethod, this.contextContainer.createHandler(plugin, renderer)),
    };
  }

  start(core) {
    // Register the core context available to all renderers. Use the VizRendererContext's opaqueId as the first arg.
    this.contextContainer.registerContext(this.initContext.opaqueId, 'core', () => ({
      i18n: core.i18n,
      uiSettings: core.uiSettings
    }));

    return {
      registerContext: this.contextContainer.registerContext,

      renderVizualization: (renderMethod: string, domElement: HTMLElement) => {
        if (!this.vizRenderer.has(renderMethod)) {
          throw new Error(`Render method '${renderMethod}' has not been registered`);
        }

        // The handler can now be called directly with only an `HTMLElement` and will automatically
        // have a new `context` object created and populated by the context container.
        const handler = this.vizRenderers.get(renderMethod)
        return handler(domElement);
      }
    };
  }
}

```

