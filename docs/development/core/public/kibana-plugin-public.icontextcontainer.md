<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [kibana-plugin-public](./kibana-plugin-public.md) &gt; [IContextContainer](./kibana-plugin-public.icontextcontainer.md)

## IContextContainer interface

An object that handles registration of context providers and configuring handlers with context.

<b>Signature:</b>

```typescript
export interface IContextContainer<TContext extends {}, THandlerReturn, THandlerParameters extends any[] = []> 
```

## Methods

|  Method | Description |
|  --- | --- |
|  [createHandler(pluginId, handler)](./kibana-plugin-public.icontextcontainer.createhandler.md) | Create a new handler function pre-wired to context for the plugin. |
|  [registerContext(pluginId, contextName, provider)](./kibana-plugin-public.icontextcontainer.registercontext.md) | Register a new context provider. |

## Remarks

A [IContextContainer](./kibana-plugin-public.icontextcontainer.md) can be used by any Core service or plugin (known as the "service owner") which wishes to expose APIs in a handler function. The container object will manage registering context providers and configuring a handler with all of the contexts that should be exposed to the handler's plugin. This is dependent on the dependencies that the handler's plugin declares.

Contexts providers are executed in the order they were registered. Each provider gets access to context values provided by any plugins that it depends on.

In order to configure a handler with context, you must call the [IContextContainer.createHandler()](./kibana-plugin-public.icontextcontainer.createhandler.md) function and use the returned handler which will automatically build a context object when called.

When registering context or creating handlers, the \_calling plugin's id\_ must be provided. Note this should NOT be the context service owner, but the plugin that is actually registering the context or handler.

```ts
// GOOD
class MyPlugin {
  private readonly handlers = new Map();

  setup(core) {
    this.contextContainer = core.context.createContextContainer();
    return {
      registerContext(pluginId, contextName, provider) {
        this.contextContainer.registerContext(pluginId, contextName, provider);
      },
      registerRoute(pluginId, path, handler) {
        this.handlers.set(
          path,
          this.contextContainer.createHandler(pluginId, handler)
        );
      }
    }
  }
}

// BAD
class MyPlugin {
  private readonly handlers = new Map();

  setup(core) {
    this.contextContainer = core.context.createContextContainer();
    return {
      registerContext(pluginId, contextName, provider) {
        // This would leak this context to all handlers rather that only plugins that depend on the calling plugin.
        this.contextContainer.registerContext('my_plugin', contextName, provider);
      },
      registerRoute(pluginId, path, handler) {
        this.handlers.set(
          path,
          // This handler will not receive any contexts provided by other dependencies of the calling plugin.
          this.contextContainer.createHandler('my_plugin', handler)
        );
      }
    }
  }
}

```

