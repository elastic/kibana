<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [kibana-plugin-public](./kibana-plugin-public.md) &gt; [ContextSetup](./kibana-plugin-public.contextsetup.md)

## ContextSetup interface

An object that handles registration of context providers and configuring handlers with context.

<b>Signature:</b>

```typescript
export interface ContextSetup 
```

## Methods

|  Method | Description |
|  --- | --- |
|  [createContextContainer()](./kibana-plugin-public.contextsetup.createcontextcontainer.md) | Creates a new [ContextContainer](./kibana-plugin-public.contextcontainer.md) for a service owner. |

## Remarks

A [ContextContainer](./kibana-plugin-public.contextcontainer.md) can be used by any Core service or plugin (known as the "service owner") which wishes to expose APIs in a handler function. The container object will manage registering context providers and configuring a handler with all of the contexts that should be exposed to the handler's plugin. This is dependent on the dependencies that the handler's plugin declares.

Contexts providers are executed in the order they were registered. Each provider gets access to context values provided by any plugins that it depends on.

In order to configure a handler with context, you must call the [ContextContainer.createHandler()](./kibana-plugin-public.contextcontainer.createhandler.md) function and use the returned handler which will automatically build a context object when called.

When registering context or creating handlers, the \_calling plugin's id\_ must be provided. Note this should NOT be the context service owner, but the plugin that is actually registering the context or handler.

```ts
// GOOD
class MyPlugin {
  private readonly handlers = new Map();

  setup(core) {
    this.contextContainer = core.context.createContextContainer();
    return {
      registerContext(plugin, contextName, provider) {
        this.contextContainer.registerContext(plugin, contextName, provider);
      },
      registerRoute(plugin, path, handler) {
        this.handlers.set(
          path,
          this.contextContainer.createHandler(plugin, handler)
        );
      }
    }
  }
}

// BAD
class MyPlugin {
  private readonly handlers = new Map();

  setup(core) {
    this.contextContainer = core.context.createContextContainer();
    return {
      registerContext(plugin, contextName, provider) {
        // This would leak this context to all handlers rather tha only plugins that depend on the calling plugin.
        this.contextContainer.registerContext('my_plugin', contextName, provider);
      },
      registerRoute(plugin, path, handler) {
        this.handlers.set(
          path,
          // the handler will not receive any contexts provided by other dependencies of the calling plugin.
          this.contextContainer.createHandler('my_plugin', handler)
        );
      }
    }
  }
}

```

## Example

Say we're creating a plugin for rendering visualizations that allows new rendering methods to be registered. If we want to offer context to these rendering methods, we can leverage the ContextService to manage these contexts.

```ts
export interface VizRenderContext {
  core: {
    i18n: I18nStart;
    uiSettings: UISettingsClientContract;
  }
  [contextName: string]: unknown;
}

export type VizRenderer = (context: VizRenderContext, domElement: HTMLElement) => () => void;

class VizRenderingPlugin {
  private readonly vizRenderers = new Map<string, ((domElement: HTMLElement) => () => void)>();

  setup(core) {
    this.contextContainer = core.createContextContainer<
      VizRenderContext,
      ReturnType<VizRenderer>,
      [HTMLElement]
    >();

    return {
      registerContext: this.contextContainer.registerContext,
      registerVizRenderer: (plugin: string, renderMethod: string, renderer: VizTypeRenderer) =>
        this.vizRenderers.set(renderMethod, this.contextContainer.createHandler(plugin, renderer)),
    };
  }

  start(core) {
    // Register the core context available to all renderers. Use the VizRendererContext's pluginId as the first arg.
    this.contextContainer.registerContext('viz_rendering', 'core', () => ({
      i18n: core.i18n,
      uiSettings: core.uiSettings
    }));

    return {
      registerContext: this.contextContainer.registerContext,

      // The handler can now be called directly with only an `HTMLElement` and will automaticallly
      // have the `context` argument supplied.
      renderVizualization: (renderMethod: string, domElement: HTMLElement) => {
        if (!this.vizRenderer.has(renderMethod)) {
          throw new Error(`Render method '${renderMethod}' has not been registered`);
        }

        return this.vizRenderers.get(renderMethod)(domElement);
      }
    };
  }
}

```

