[[development-security]]
== Security

=== Overview

Feature development must consider user access permissions. A design may assume access to several APIs which may have independent availability but feature implementation must account for all possible combinations of API access.

=== Implementation

Kibana has generally been able to implement security transparently to core and plugin developers, and this largely remains the case. {kib} on two methods that the <<development-elasticsearch, elasticsearch plugin>>'s `Cluster` provides: `callWithRequest` and `callWithInternalUser`. 

`callWithRequest` executes requests against Elasticsearch using the authentication credentials of the Kibana end-user. So, if you log into Kibana with the user of `foo` when `callWithRequest` is used, {kib} execute the request against Elasticsearch as the user `foo`. Historically, `callWithRequest` has been used extensively to perform actions that are initiated at the request of Kibana end-users.

`callWithInternalUser` executes requests against Elasticsearch using the internal Kibana server user, and has historically been used for performing actions that aren't initiated by Kibana end users; for example, creating the initial `.kibana` index or performing health checks against Elasticsearch.

However, {kib} requires all access to the `.kibana` index go through the `SavedObjectsClient`. Its responsible for translating the documents stored in Elasticsearch to and from Saved Objects and determining when to use `callWithRequest` versus `callWithInternalUser`.

There are two methods of determining user access. X-Pack features can query user access permssions via `has-privileges`. Outside of X-Pack simply query the desired resource and handle 403 errors as appropriate.

A user with minimal permissions is useful for testing no-access cases - create a new user and add the `kibana_user` role. The user will be able to log into kibana but without access to any indices.

include::rbac.asciidoc[]
