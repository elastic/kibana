[role="xpack"]
[[canvas-expression-lifecycle]]
== Canvas expression lifecycle

[[canvas-function-can-take-arguments]]
=== Functions Can Take Arguments

Let’s look at another expression, which uses the same <<demodata_fn>> function but this time produces a pie chart instead.

image::images/canvas-functions-can-take-arguments-pie-chart.png[Pie Chart]
[source,text]
----
filters
| demodata
| pointseries color="state" size="max(price)"
| pie
| render
----

This one starts out just like before, using the <<filters_fn>> and <<demodata_fn>> functions to produce a filtered set of random data. This time, however, the output becomes the context for <<pointseries_fn>>, which is a way to "aggregate" or "roll up" your data, similar to how Elasticsearch works, but more generalized. In this case, the data is split up using the `color` and `size` dimensions, using arguments on the <<pointseries_fn>> function. Each unique value in the "state" column will have an associated "size" value, which in this case, will be the maximum value of the "price" column.

If the expression stopped there, it would produce a `pointseries` data type as the output of this expression. But instead of looking at the raw values, the result is piped to <<pie_fn>>, which will produce an output that will render a pie visualization. And just like before, this is piped to <<render_fn>>, which is useful for its arguments.

The end result is a simple pie chart that uses the default color palette. But <<pie_fn>> can take some additional arguments that control how it gets rendered. For example, you can provide a `hole` argument to turn your pie chart into a donut chart, one that has a "hole" in the middle of it, but changing the expression to this:


image::images/canvas-functions-can-take-arguments-donut-chart.png[Donut Chart]
[source,text]
----
filters
| demodata
| pointseries color="state" size="max(price)"
| pie hole=50
| render
----


[[canvas-aliases-and-unnamed-arguments]]
=== Aliases and Unnamed Arguments

Argument definitions have one canonical name, which is always provided in the underlying code, but when used in an expression they often times include aliases that make them easier or faster to type, usually both. 

Take, as one example, the <<mapColumn_fn>> function, which has 2 arguments: `expression`, the expression to use to produce a calculated value, and `name`, the name of column to place the resulting data in. The `expression` argument includes some aliases, namely `exp`, `fn`, and `function`. That means that you can use any of those four options to provide that argument’s value. So in your expression, if you use `mapColumn name=newColumn fn={string example}`, this produces the same output as if you wrote the more verbose `mapColumn name=newColumn expression={string example}`.

There’s also a special type of alias which allows you to leave off the argument’s name entirely. The alias for this is simply `+_+`, which indicates that the argument is an _unnamed_ argument, and can be provided without explicitly naming it in the expression. The `name` argument here uses the _unnamed_ alias, which means that you can further simplify our example to `mapColumn newColumn fn={string example}`.

NOTE: There can only be one _unnamed_ argument for each function.


[[canvas-change-your-expression-change-your-output]]
=== Change Your Expression, Change Your Output
In the previous section, you saw how you can add arguments to a function to change its output, but you can also substitute one function for another in many situations. For example, you could change the visualization by swapping out the <<pie_fn, pie>> function for another *renderer*, a function that returns a `render` data type. 

Let’s change that last pie visualization into a bubble chart by replacing the <<pie_fn, pie>> function with the <<plot_fn, plot>> function. This is possible because both functions can accept a `pointseries` data type as their _context_. Just switching the functions will work, but it won’t produce a useful visualization on its own, since you don’t have any axis dimensions, i.e. `x` or `y`, defined. You’ll also need to modify the <<pointseries_fn, pointseries>> function to change its output as well. In this case, you can change the `size` argument to `y`, so the maximum price values are plotted on the y-axis, and add an `x` argument using the `@timestamp` field in the data to plot those values over time. This leaves you with the following expression and produces a bubble chart showing the max price of each state over time:

image::images/canvas-change-your-expression-chart.png[Bubble Chart]
[source,text]
----
filters
| demodata
| pointseries color="state" y="max(price)" x="@timestamp"
| plot
| render
----

The <<plot_fn, plot>> function, like <<pie_fn, pie>>, also takes several arguments, which will again control what the final visualization looks like. As one example, passing a `legend` argument with a value of `false` to the function will hide the legend on the chart.

[source,text,subs=+quotes]
----
filters
| demodata
| pointseries color="state" y="max(price)" x="@timestamp"
| plot *legend=false*
| render
----


[[canvas-expressions-only-fetch-and-manipulate-data]]
=== Expressions Only Fetch and Manipulate Data
So far you’ve only seen expressions as a way to produce visualizations, but that’s not really what’s happening. Expressions only produce data which is then used to create something, which in the case of Canvas, means rendering an element. An element can be a visualization, driven by data, but it can also be something much simpler, like a static image. Either way, an expression is used to produce an output that is used to render the desired result. For example, here’s an expression that shows a placekitten image:

[source,text]
----
image dataurl=https://placekitten.com/160/160 mode="cover"
----

But as mentioned, this doesn’t actually _render that image_, but instead it _produces some output that can be used to render that image_. That’s an important distinction, and you can see the actual output by adding in the render function and telling it to produce debug output, like so:

[source,text]
----
image dataurl=https://placekitten.com/160/160 mode="cover"
| render as=debug
----

If you run that in Canvas, instead of seeing an image, you should see the following JSON output.

[source,JSON]
----
{
  "type": "image",
  "mode": "cover",
  "dataurl": "https://placekitten.com/160/160"
}
----

NOTE: You may need to expand the element’s size to see the whole output.

Canvas uses this output’s "data type" to map to a specific renderer and passes the entire output into it. It’s up to the image render function in this case to produce an image on the workpad’s page. In this case, the expression produces some JSON output, but expressions can also produce other, simpler data, like a string or a number. But usually more useful results tend to be JSON.

If this had been the output of the table, pie chart, or plot chart from the previous sections, it would have been much more complex, but the idea is the same; call some function, pass in the expression’s output, and render something on the page. As far as the expression, and the associated interpreter, is concerned, the expression produced an output and its job is done.

Canvas uses that output to render an element, but other applications can use expressions to do pretty much anything. As stated previously, expressions simply execute functions, and the functions are all written in Javascript. That means if you can do something in Javascript, you can do it with an expression. This can include, just to name a few things, sending emails or notifications, reading from or writing to a file, controlling devices with WebUSB or Web Bluetooth, consuming an external API, really just about anything. If your Javascript works in the environment where the code will run, such as in Node.js or in a browser, you can do it with an expression.

[[canvas-handling-context-and-argument-types]]
=== Handling context and argument types
If you look through the function docs, you may notice that all of them define what a function accepts and what it returns. Additionally, every argument includes a type property that specifies the kind of data that can be used. These two types of values are actually the same, and can be used as a guide for how to deal with piping to other functions and using subexpressions for argument values. 

To explain how this works, consider the following expression from the previous section:

[source,text]
----
image dataurl={asset 3cb3ec3a-84d7-48fa-8709-274ad5cc9e0b}
----

If you <<image_fn,look at the docs>> for the `image` function, you’ll see that it accepts the `null` data type and returns an `image` data type. Accepting `null` effectively means that it does not use context at all, so if you pipe anything to `image`, the value that was produced previously will be ignored. When the function executes, it will produce an `image` output, which is simply an object of type `image` that contains the information required to render an image. 

NOTE: It does not render an image itself.

As explained in "<<canvas-expressions-only-fetch-and-manipulate-data>>", the output of an expression is just data. So the `image` type here is just a specific shape of data, not an actual image.

Next, let’s take a look at the `asset` function. Like `image`, it accepts `null`, but it returns something different, a `string` in this case. Because `asset` will produce a string, its output can be used as the input for any function or argument that accepts a string. 

<<asset_fn,Looking at the docs>> for the `dataurl` argument, its type is `string`, meaning it will accept any kind of string. There are some rules about the value of the string that the function itself enforces, but as far as the interpreter is concerned, that expression is valid because the argument accepts a string and the output of `asset` is a string. 

The interpreter also attempts to cast some input types into others, which allows you to, use a string input even when the function or argument calls for a number. Keep in mind that it’s not able to convert any string value, but if the string is a number, it can easily be cast into a `number` type. Take the following expression for example:

[source,text]
----
string "0.4"
| revealImage image={asset asset-06511b39-ec44-408a-a5f3-abe2da44a426}
----

If you <<revealImage_fn,check the docs>> for the `revealImage` function, you’ll see that it accepts a `number` but the `string` function returns a `string` type. In this case, because the string value is a number, it can be converted into a `number` type and used without you having to do anything else. 

Most "primitive" types can be converted automatically, as you might expect. You just saw that a `string` can be cast into a `number`, but you can also pretty easily cast things into `boolean` too, and you can cast anything to `null`. 

There are other useful type casting options available. For example, something of type `datatable` can be cast to a type `pointseries` simply by only preserving specific columns from the data (namely x, y, size, color, and text). This allows you to treat your source data, which is generally of type `datatable`, like a `pointseries` type simply by convention. 

You can fetch data from Elasticsearch using `essql`, which allows you to aggregate the data, provide a custom name for the value, and pipe that data directly to another function that only accepts `pointseries` even though `essql` will output a `datatable` type. This makes the following example expression valid:

[source,text]
----
essql "SELECT user AS x, sum(cost) AS y FROM index GROUP BY user"
| plot
----

In the docs you can see that `essql` returns a `datatable` type, but `plot` expects a `pointseries` context. This works because the `datatable` output will have the columns `x` and `y` as a result of using `AS` in the sql statement to name them. Because the data follows the convention of the `pointseries` data type, casting it into `pointseries` is possible, and it can be passed directly to `plot` as a result. 
