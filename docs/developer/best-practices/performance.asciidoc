[[plugin-performance]]
== Keep Kibana fast

*tl;dr*: Load as much code lazily as possible. Everyone loves snappy
applications with responsive UI and hates spinners. Users deserve the
best user experiences regardless of whether they run Kibana locally or
in the cloud, regardless of their hardware & environment.

There are 2 main aspects of the perceived speed of an application: loading time
and responsiveness to user actions. Kibana Platform loads and bootstraps *all*
the plugins whenever a user lands on any page. It means that adding
every new application affects overall *loading performance*, as plugin code is
loaded *eagerly* to initialize the plugin and provide plugin API to dependent
plugins.

However, itâ€™s usually not necessary that the whole plugin code should be loaded
and initialized at once. The plugin could keep on loading code covering API functionality
on Kibana bootstrap but load UI related code lazily on-demand, when an
application page or management section is mounted. Always prefer to
require UI root components lazily when possible (such as in mount
handlers). Even if their size may seem negligible, they are likely using
some heavy-weight libraries that will also be removed from the initial
plugin bundle, therefore, reducing its size by a significant amount.

[source,typescript]
----
import { Plugin, CoreSetup, AppMountParameters } from 'src/core/public';
export class MyPlugin implements Plugin<MyPluginSetup> {
  setup(core: CoreSetup, plugins: SetupDeps) {
    core.application.register({
      id: 'app',
      title: 'My app',
      async mount(params: AppMountParameters) {
        const { mountApp } = await import('./app/mount_app');
        return mountApp(await core.getStartServices(), params);
      },
    });
    plugins.management.sections.section.kibana.registerApp({
      id: 'app',
      title: 'My app',
      order: 1,
      async mount(params) {
        const { mountManagementSection } = await import('./app/mount_management_section');
        return mountManagementSection(coreSetup, params);
      },
    });
    return {
      doSomething() {},
    };
  }
}
----

=== Understanding plugin bundle size

Kibana Platform plugins are distributed as a pre-built with
`@kbn/optimizer` package artifacts. It allows us to get rid of the
shipping of `optimizer` in the distributable version of Kibana. Every NP
plugin artifact contains all plugin dependencies required to run the
plugin, except some stateful dependencies shared across plugin bundles
via `@kbn/ui-shared-deps`. It means that NP plugin artifacts tend to
have a bigger size than the legacy platform version. To understand the
current size of your plugin artifact, run `@kbn/optimizer` as

[source,bash]
----
node scripts/build_kibana_platform_plugins.js --dist --no-examples
----

and check the output in the `target` sub-folder of your plugin folder

[source,bash]
----
ls -lh plugins/my_plugin/target/public/
# output
# an async chunk loaded on demand
... 262K 0.plugin.js
# eagerly loaded chunk
... 50K  my_plugin.plugin.js
----

you might see at least one js bundle - `my_plugin.plugin.js`. This is
the only artifact loaded by the platform during bootstrap in the
browser. The rule of thumb is to keep its size as small as possible.
Other lazily loaded parts of your plugin present in the same folder as
separate chunks under `{number}.plugin.js` names. If you want to
investigate what your plugin bundle consists of you need to run
`@kbn/optimizer` with `--profile` flag to get generated
https://webpack.js.org/api/stats/[webpack stats file].

[source,bash]
----
node scripts/build_kibana_platform_plugins.js --dist --no-examples --profile
----

Many OSS tools are allowing you to analyze generated stats file

* http://webpack.github.io/analyse/#modules[an official tool] from
webpack authors
* https://chrisbateman.github.io/webpack-visualizer/[webpack-visualizer]
