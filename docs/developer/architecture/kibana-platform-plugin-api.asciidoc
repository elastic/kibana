[[kibana-platform-plugin-api]]
== Kibana Platform Plugin API

experimental[]

Plugins in the Kibana Platform are not especially novel or complicated to
describe. Our intention wasn’t to build some clever system that
magically solved problems through abstractions and layers of obscurity,
and we wanted to make sure plugins could continue to use most of the
same technologies they use today, at least from a technical perspective.

=== Anatomy of a plugin

Plugins are defined as classes and exposed to the platform itself
through a simple wrapper function. A plugin can have browser side code,
server side code, or both. There is no architectural difference between
a plugin in the browser and a plugin on the server, which is to say that
in both places you describe your plugin similarly, and you interact with
Core and/or other plugins in the same way.

The basic file structure of a Kibana Platform plugin named ``demo'' that
had both client-side and server-side code would be:

[source,tree]
----
src/plugins
  demo
    kibana.json [1]
    public
      index.ts [2]
      plugin.ts [3]
    server
      index.ts [4]
      plugin.ts [5]
----

*[1] `kibana.json`* is a static manfiest file that is used to identify the
plugin and to determine what kind of code the platform should execute from the
plugin:

[source,json]
----
{
  "id": "demo",
  "version": "kibana",
  "server": true,
  "ui": true
}
----

More details
about {kib-repo}blob/{branch}/docs/development/core/server/kibana-plugin-core-server.pluginmanifest.md[manifest
file format]

Note that `package.json` files are irrelevant to and ignored by the new
platform.

*[2] `public/index.ts`* is the entry point into the client-side code of
this plugin. It must export a function named `plugin`, which will
receive a standard set of core capabilities as an argument
(e.g. logger). It should return an instance of its plugin definition for
the platform to register at load time.

[source,ts]
----
import { PluginInitializerContext } from 'kibana/server';
import { Plugin } from './plugin';

export function plugin(initializerContext: PluginInitializerContext) {
  return new Plugin(initializerContext);
}
----

*[3] `public/plugin.ts`* is the client-side plugin definition itself.
Technically speaking it does not need to be a class or even a separate
file from the entry point, but _all plugins at Elastic_ should be
consistent in this way. _See all {kib-repo}blob/{branch}/src/core/CONVENTIONS.md[conventions
for first-party Elastic plugins]_.

[source,ts]
----
import { PluginInitializerContext, CoreSetup, CoreStart } from 'kibana/server';

export class Plugin {
  constructor(initializerContext: PluginInitializerContext) {}

  public setup(core: CoreSetup) {
    // called when plugin is setting up
  }

  public start(core: CoreStart) {
    // called after all plugins are set up
  }

  public stop() {
    // called when plugin is torn down, aka window.onbeforeunload
  }
}
----

*[4] `server/index.ts`* is the entry-point into the server-side code of
this plugin. It is identical in almost every way to the client-side
entry-point:

[source,ts]
----
import { PluginInitializerContext } from 'kibana/server';
import { Plugin } from './plugin';

export function plugin(initializerContext: PluginInitializerContext) {
  return new Plugin(initializerContext);
}
----

*[5] `server/plugin.ts`* is the server-side plugin definition. The
_shape_ of this plugin is the same as it’s client-side counter-part:

[source,ts]
----
import { PluginInitializerContext, CoreSetup, CoreStart } from 'kibana/server';

export class Plugin {
  constructor(initializerContext: PluginInitializerContext) {}

  public setup(core: CoreSetup) {
    // called when plugin is setting up during Kibana's startup sequence
  }

  public start(core: CoreStart) {
    // called after all plugins are set up
  }

  public stop() {
    // called when plugin is torn down during Kibana's shutdown sequence
  }
}
----

The platform does not impose any technical restrictions on how the
internals of the plugin are architected, though there are certain
considerations related to how plugins interact with core and how plugins
interact with other plugins that may greatly impact how they are built.

=== Lifecycles & Core Services

The various independent domains that make up `core` are represented by a
series of services, and many of those services expose public interfaces
that are provided to _all_ plugins. Services expose different features
at different parts of their _lifecycle_. We describe the lifecycle of
core services and plugins with specifically-named functions on the
service definition.

In the Kibana Platform, there are three lifecycle functions today: `setup`,
`start`, and `stop`. The `setup` functions are invoked sequentially
while Kibana is setting up on the server or when it is being loaded in
the browser. The `start` functions are invoked sequentially after setup
has completed for all plugins. The `stop` functions are invoked
sequentially while Kibana is gracefully shutting down on the server or
when the browser tab or window is being closed.

The table below explains how each lifecycle event relates to the state
of Kibana.

[width="100%",cols="15%,38%,47%",options="header",]
|===
|lifecycle event |server |browser
|_setup_ |bootstrapping and configuring routes |loading plugin bundles
and configuring applications

|_start_ |server is now serving traffic |browser is now showing UI to
the user

|_stop_ |server has received a request to shutdown |user is navigating
away from Kibana
|===

There is no equivalent behavior to `start` or `stop` in legacy plugins.
Conversely, there is no equivalent to `uiExports` in Kibana Platform plugins.
As a general rule of thumb, features that were registerd via `uiExports` are
now registered during the `setup` phase. Most of everything else should move
to the `start` phase.

The lifecycle-specific contracts exposed by core services are always
passed as the first argument to the equivalent lifecycle function in a
plugin. For example, the core `UiSettings` service exposes a function
`get` to all plugin `start` functions. To use this function to retrieve
a specific UI setting, a plugin just accesses it off of the first
argument:

[source,ts]
----
import { CoreSeart } from 'kibana/server';

export class Plugin {
  public setup(core: CoreStart) {
    core.uiSettings.get('courier:maxShardsBeforeCryTime');
  }
}
----

Different service interfaces can and will be passed to `setup`, `start`, and
`stop` because certain functionality makes sense in the context of a
running plugin while other types of functionality may have restrictions
or may only make sense in the context of a plugin that is stopping.

For example, the `stop` function in the browser gets invoked as part of
the `window.onbeforeunload` event, which means you can’t necessarily
execute asynchronous code here in a reliable way. For that reason,
`core` likely wouldn’t provide any asynchronous functions to plugin
`stop` functions in the browser.

The current lifecycle function for all plugins will be executed before the next
lifecycle starts. That is to say that all `setup` functions are executed before
any `start` functions are executed. Core services that expose functionality to
plugins always have their lifecycle functions executed before any plugins.

These are the contracts exposed by the core services for each lifecycle
event:

[cols=",,",options="header",]
|===
|lifecycle event |server contract|browser contract
|_contructor_
|{kib-repo}blob/{branch}/docs/development/core/server/kibana-plugin-core-server.plugininitializercontext.md[PluginInitializerContext]
|{kib-repo}blob/{branch}/docs/development/core/public/kibana-plugin-core-public.plugininitializercontext.md[PluginInitializerContext]

|_setup_
|{kib-repo}blob/{branch}/docs/development/core/server/kibana-plugin-core-server.coresetup.md[CoreSetup]
|{kib-repo}blob/{branch}/docs/development/core/public/kibana-plugin-core-public.coresetup.md[CoreSetup]

|_start_
|{kib-repo}blob/{branch}/docs/development/core/server/kibana-plugin-core-server.corestart.md[CoreStart]
|{kib-repo}blob/{branch}/docs/development/core/public/kibana-plugin-core-public.corestart.md[CoreStart]

|_stop_ |
|===

=== Integrating with other plugins

Plugins can expose public interfaces for other plugins to consume. Like
`core`, those interfaces are bound to the lifecycle functions `setup`
and/or `start`.

Anything returned from `setup` or `start` will act as the interface, and
while not a technical requirement, all first-party Elastic plugins
will expose types for that interface as well. 3rd party plugins
wishing to allow other plugins to integrate with it are also highly
encouraged to expose types for their plugin interfaces.

*foobar plugin.ts:*

[source,ts]
----
export type FoobarPluginSetup = ReturnType<Plugin['setup']>;
export type FoobarPluginStart = ReturnType<Plugin['start']>;

export class Plugin {
  public setup() {
    return {
      getFoo() {
        return 'foo';
      },
    };
  }

  public start() {
    return {
      getBar() {
        return 'bar';
      },
    };
  }
}
----

Unlike core, capabilities exposed by plugins are _not_ automatically
injected into all plugins. Instead, if a plugin wishes to use the public
interface provided by another plugin, they must first declare that
plugin as a dependency in their `kibana.json`.

*demo kibana.json:*

[source,json]
----
{
  "id": "demo",
  "requiredPlugins": ["foobar"],
  "server": true,
  "ui": true
}
----

With that specified in the plugin manifest, the appropriate interfaces
are then available via the second argument of `setup` and/or `start`:

*demo plugin.ts:*

[source,ts]
----
import { CoreSetup, CoreStart } from 'src/core/server';
import { FoobarPluginSetup, FoobarPluginStop } from '../../foobar/server';

interface DemoSetupPlugins { <1>
  foobar: FoobarPluginSetup;
}

interface DemoStartPlugins {
  foobar: FoobarPluginStart;
}

export class Plugin {
  public setup(core: CoreSetup, plugins: DemoSetupPlugins) { <2>
    const { foobar } = plugins;
    foobar.getFoo(); // 'foo'
    foobar.getBar(); // throws because getBar does not exist
  }

  public start(core: CoreStart, plugins: DemoStartPlugins) { <3>
    const { foobar } = plugins;
    foobar.getFoo(); // throws because getFoo does not exist
    foobar.getBar(); // 'bar'
  }

  public stop() {},
}
----
<1> The interface for plugin's dependencies must be manually composed. You can
do this by importing the appopriate type from the plugin and constructing an
interface where the property name is the plugin's ID.
<2> These manually constructed typees should then be used to specify the type of
the second argument to the plugin.
<3> Notice that the type for setup and start are different. Plugin lifecycle
functions can only access the APIs that are exposed during that lifecycle.

=== Migrating legacy plugins to Kibana Platform

In Kibana 7.10, support for legacy plugins was removed. See
<<migrating-legacy-plugins>> for detailed information on how to convert existing
legacy plugins to this new API.

=== How to

==== Configure plugin

Kibana provides ConfigService if a plugin developer may want to support
adjustable runtime behavior for their plugins. Access to Kibana config
in Kibana Platform has been subject to significant refactoring.

Config service does not provide access to the whole config anymore. New
platform plugin cannot read configuration parameters of the core
services nor other plugins directly. Use plugin contract to provide
data.

[source,js]
----
// your-plugin.js
// in Legacy platform
const basePath = config.get('server.basePath');
// in Kibana Platform
const basePath = core.http.basePath.get(request);
----

In order to have access to your plugin config, you _should_:

* Declare plugin specific ``configPath'' (will fallback to plugin ``id''
if not specified) in `kibana.json` file.
* Export schema validation for config from plugin’s main file. Schema is
mandatory. If a plugin reads from the config without schema declaration,
ConfigService will throw an error.

[source,typescript]
----
// my_plugin/server/index.ts
import { schema, TypeOf } from '@kbn/config-schema';
export const plugin = ...
export const config = {
  schema: schema.object(...),
};
export type MyPluginConfigType = TypeOf<typeof config.schema>;
----

* Read config value exposed via initializerContext. No config path is
required.

[source,typescript]
----
class MyPlugin {
  constructor(initializerContext: PluginInitializerContext) {
    this.config$ = initializerContext.config.create<MyPluginConfigType>();
    // or if config is optional:
    this.config$ = initializerContext.config.createIfExists<MyPluginConfigType>();
  }
----

If your plugin also have a client-side part, you can also expose
configuration properties to it using the configuration `exposeToBrowser`
allow-list property.

[source,typescript]
----
// my_plugin/server/index.ts
import { schema, TypeOf } from '@kbn/config-schema';
import { PluginConfigDescriptor } from 'kibana/server';

const configSchema = schema.object({
  secret: schema.string({ defaultValue: 'Only on server' }),
  uiProp: schema.string({ defaultValue: 'Accessible from client' }),
});

type ConfigType = TypeOf<typeof configSchema>;

export const config: PluginConfigDescriptor<ConfigType> = {
  exposeToBrowser: {
    uiProp: true,
  },
  schema: configSchema,
};
----

Configuration containing only the exposed properties will be then
available on the client-side using the plugin’s `initializerContext`:

[source,typescript]
----
// my_plugin/public/index.ts
interface ClientConfigType {
  uiProp: string;
}

export class Plugin implements Plugin<PluginSetup, PluginStart> {
  constructor(private readonly initializerContext: PluginInitializerContext) {}

  public async setup(core: CoreSetup, deps: {}) {
    const config = this.initializerContext.config.get<ClientConfigType>();
    // ...
  }
----

All plugins are considered enabled by default. If you want to disable
your plugin by default, you could declare the `enabled` flag in plugin
config. This is a special Kibana platform key. The platform reads its
value and won’t create a plugin instance if `enabled: false`.

[source,js]
----
export const config = {
  schema: schema.object({ enabled: schema.boolean({ defaultValue: false }) }),
};
----

===== Handle plugin configuration deprecations

If your plugin have deprecated properties, you can describe them using
the `deprecations` config descriptor field.

The system is quite similar to the legacy plugin’s deprecation
management. The most important difference is that deprecations are
managed on a per-plugin basis, meaning that you don’t need to specify
the whole property path, but use the relative path from your plugin’s
configuration root.

[source,typescript]
----
// my_plugin/server/index.ts
import { schema, TypeOf } from '@kbn/config-schema';
import { PluginConfigDescriptor } from 'kibana/server';

const configSchema = schema.object({
  newProperty: schema.string({ defaultValue: 'Some string' }),
});

type ConfigType = TypeOf<typeof configSchema>;

export const config: PluginConfigDescriptor<ConfigType> = {
  schema: configSchema,
  deprecations: ({ rename, unused }) => [
    rename('oldProperty', 'newProperty'),
    unused('someUnusedProperty'),
  ],
};
----

In some cases, accessing the whole configuration for deprecations is
necessary. For these edge cases, `renameFromRoot` and `unusedFromRoot`
are also accessible when declaring deprecations.

[source,typescript]
----
// my_plugin/server/index.ts
export const config: PluginConfigDescriptor<ConfigType> = {
  schema: configSchema,
  deprecations: ({ renameFromRoot, unusedFromRoot }) => [
    renameFromRoot('oldplugin.property', 'myplugin.property'),
    unusedFromRoot('oldplugin.deprecated'),
  ],
};
----

Note that deprecations registered in Kibana Platform’s plugins are not
applied to the legacy configuration. During migration, if you still need
the deprecations to be effective in the legacy plugin, you need to
declare them in both plugin definitions.

==== Use scoped services

Whenever Kibana needs to get access to data saved in elasticsearch, it
should perform a check whether an end-user has access to the data. In
the legacy platform, Kibana requires to bind elasticsearch related API
with an incoming request to access elasticsearch service on behalf of a
user.

[source,js]
----
async function handler(req, res) {
  const dataCluster = server.plugins.elasticsearch.getCluster('data');
  const data = await dataCluster.callWithRequest(req, 'ping');
}
----

The Kibana Platform introduced link:/rfcs/text/0003_handler_interface.md[a
handler interface] on the server-side to perform that association
internally. Core services, that require impersonation with an incoming
request, are exposed via `context` argument of
{kib-repo}blob/{branch}/docs/development/core/server/kibana-plugin-core-server.requesthandler.md[the
request handler interface.] The above example looks in the Kibana Platform
as

[source,js]
----
async function handler(context, req, res) {
  const data = await context.core.elasticsearch.adminClient.callAsInternalUser('ping');
}
----

The
{kib-repo}blob/{branch}/docs/development/core/server/kibana-plugin-core-server.requesthandlercontext.md[request
handler context] exposed the next scoped *core* services:

[width="100%",cols="30%,70%",options="header",]
|===
|Legacy Platform |Kibana Platform
|`request.getSavedObjectsClient`
|{kib-repo}blob/{branch}/docs/development/core/server/kibana-plugin-core-server.savedobjectsclient.md[`context.savedObjects.client`]

|`server.plugins.elasticsearch.getCluster('admin')`
|{kib-repo}blob/{branch}/docs/development/core/server/kibana-plugin-core-server.iscopedclusterclient.md[`context.elasticsearch.adminClient`]

|`server.plugins.elasticsearch.getCluster('data')`
|{kib-repo}blob/{branch}/docs/development/core/server/kibana-plugin-core-server.iscopedclusterclient.md[`context.elasticsearch.dataClient`]

|`request.getUiSettingsService`
|{kib-repo}blob/{branch}/docs/development/core/server/kibana-plugin-core-server.iuisettingsclient.md[`context.uiSettings.client`]
|===

===== Declare a custom scoped service

Plugins can extend the handler context with custom API that will be
available to the plugin itself and all dependent plugins. For example,
the plugin creates a custom elasticsearch client and want to use it via
the request handler context:

[source,ts]
----
import { CoreSetup, IScopedClusterClient } from 'kibana/server';

export interface MyPluginContext {
  client: IScopedClusterClient;
}

// extend RequestHandlerContext when a dependent plugin imports MyPluginContext from the file
declare module 'src/core/server' {
  interface RequestHandlerContext {
    myPlugin?: MyPluginContext;
  }
}

class Plugin {
  setup(core: CoreSetup) {
    const client = core.elasticsearch.createClient('myClient');
    core.http.registerRouteHandlerContext('myPlugin', (context, req, res) => {
      return { client: client.asScoped(req) };
    });

    router.get(
      { path: '/api/my-plugin/', validate },
      async (context, req, res) => {
        const data = await context.myPlugin.client.callAsCurrentUser('endpoint');
        ...
      }
    );
  }
----

==== Mock Kibana Platform services in tests

===== Writing mocks for your plugin

Core services already provide mocks to simplify testing and make sure
plugins always rely on valid public contracts:

[source,typescript]
----
// my_plugin/server/plugin.test.ts
import { configServiceMock } from 'src/core/server/mocks';

const configService = configServiceMock.create();
configService.atPath.mockReturnValue(config$);
…
const plugin = new MyPlugin({ configService }, …);
----

Or if you need to get the whole core `setup` or `start` contracts:

[source,typescript]
----
// my_plugin/public/plugin.test.ts
import { coreMock } from 'src/core/public/mocks';

const coreSetup = coreMock.createSetup();
coreSetup.uiSettings.get.mockImplementation((key: string) => {
  …
});
…
const plugin = new MyPlugin(coreSetup, ...);
----

Although it isn’t mandatory, we strongly recommended you export your
plugin mocks as well, in order for dependent plugins to use them in
tests. Your plugin mocks should be exported from the root `/server` and
`/public` directories in your plugin:

[source,typescript]
----
// my_plugin/server/mocks.ts or my_plugin/public/mocks.ts
const createSetupContractMock = () => {
  const startContract: jest.Mocked<MyPluginStartContract>= {
    isValid: jest.fn();
  }
  // here we already type check as TS infers to the correct type declared above
  startContract.isValid.mockReturnValue(true);
  return startContract;
}

export const myPluginMocks = {
  createSetup: createSetupContractMock,
  createStart: …
}
----

Plugin mocks should consist of mocks for _public APIs only_:
setup/start/stop contracts. Mocks aren’t necessary for pure functions as
other plugins can call the original implementation in tests.

===== Using mocks in your tests

During the migration process, it is likely you are preparing your plugin
by shimming in Kibana Platform-ready dependencies via the legacy
`ui/new_platform` module:

[source,typescript]
----
import { npSetup, npStart } from 'ui/new_platform';
----

If you are using this approach, the easiest way to mock core and new
platform-ready plugins in your legacy tests is to mock the
`ui/new_platform` module:

[source,typescript]
----
jest.mock('ui/new_platform');
----

This will automatically mock the services in `ui/new_platform` thanks to
the
link:../../src/legacy/ui/public/new_platform/__mocks__/helpers.ts[helpers
that have been added] to that module.

If others are consuming your plugin’s Kibana Platform contracts via the
`ui/new_platform` module, you’ll want to update the helpers as well to
ensure your contracts are properly mocked.

____
Note: The `ui/new_platform` mock is only designed for use by old Jest
tests. If you are writing new tests, you should structure your code and
tests such that you don’t need this mock. Instead, you should import the
`core` mock directly and instantiate it.
____

==== Logging config migration

See the {kib-repo}blob/{branch}/src/core/server/logging/README.md#logging-config-migration[logging documentation].

==== Use HashRouter in migrated apps

Kibana applications are meant to be leveraging the `ScopedHistory`
provided in an app’s `mount` function to wire their router. For react,
this is done by using the `react-router-dom` `Router` component:

[source,typescript]
----
export const renderApp = async (element: HTMLElement, history: ScopedHistory) => {
  render(
    <I18nProvider>
      <Router history={history}>
        <Switch>
          <Route path="/some-route/:id" render={renderTutorial} />
          <Route path="/some-other-route/:tab?" render={renderTutorialDirectory} />
        </Switch>
      </Router>
    </I18nProvider>,
    element
  );

  return () => {
    unmountComponentAtNode(element);
    unlisten();
  };
};
----

Some legacy apps were using `react-router-dom`’s `HashRouter` instead.
Using `HashRouter` in a migrated application will cause some route
change events to not be catched by the router, as the `BrowserHistory`
used behind the provided scoped history does not emit the `hashevent`
that is required for the `HashRouter` to behave correctly.

It is strictly recommended to migrate your application’s routing to
browser history, which is the only routing officially supported by the
platform.

However, during the transition period, it is possible to make the two
histories cohabitate by manually emitting the required events from the
scoped to the hash history. You may use this workaround at your own
risk. While we are not aware of any problems it currently creates, there
may be edge cases that do not work properly.

[source,typescript]
----
export const renderApp = async (element: HTMLElement, history: ScopedHistory) => {
  render(
    <I18nProvider>
      <HashRouter>
        <Switch>
          <Route path="/some-route/:id" render={renderTutorial} />
          <Route path="/some-other-route/:tab?" render={renderTutorialDirectory} />
        </Switch>
      </Router>
    </I18nProvider>,
    element
  );

  // dispatch synthetic hash change event to update hash history objects
  // this is necessary because hash updates triggered by the scoped history will not emit them.
  const unlisten = history.listen(() => {
    window.dispatchEvent(new HashChangeEvent('hashchange'));
  });

  return () => {
    unmountComponentAtNode(element);
    // unsubscribe to `history.listen` when unmounting.
    unlisten();
  };
};
----
