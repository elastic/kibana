[[kuery-query]]
== Kibana Query Language

The Kibana Query Language (KQL) makes it easy to find
the right field and syntax for your {es} query. If you have the
https://www.elastic.co/subscriptions[Basic tier] or above,
simply place your cursor in the *Search* field. You’ll get suggestions for fields,
values, and query operators as you type.

This guide provides examples of common KQL searches, from a basic term
query to more complex queries with boolean operators and groupings. It
also provides examples of searching nested fields.

If you prefer Kibana’s legacy query language, based on the
{ref}/query-dsl-query-string-query.html#query-string-syntax[Lucene query syntax],
you can switch to it using the Options menu in the *Search* field.

[discrete]
=== Terms query

A terms query matches documents that contain one or more *exact* terms in a field.

Match documents where the `response` field is 200:

[source,yaml]
-------------------
response:200
-------------------

Match documents with the phrase "quick brown fox" in the `message` field.

[source,yaml]
-------------------
message:"Quick brown fox"
-------------------

Without the quotes,
the query matches documents regardless of the order in which
they appear. Documents with "quick brown fox" will match,
but so will "quick fox brown".

NOTE: Terms without fields are matched against the default field in your index settings.
If a default field is not
set, these terms will be matched against all fields. For example, a query
for `response:200` will search for the value 200
in the response field, but a query for just `200` will search for 200
across all fields in your index.


[discrete]
=== Boolean queries

KQL supports `or`, `and`, and `not`. By default, `and` has a higher precedence than `or`.
To override the default precedence, group operators in parenthesis.

Match documents where `response` is 200, `extension` is php, or both:

[source,yaml]
-------------------
response:200 or extension:php
-------------------

Match documents where `response` is 200 and `extension` is php:

[source,yaml]
-------------------
response:200 and extension:php
-------------------

Match documents where `response` is 200 or 404.

[source,yaml]
-------------------
response:(200 or 404)
-------------------

Match documents where `response` is 200 and `extension` is either php or css:

[source,yaml]
-------------------
response:200 and (extension:php or extension:css)
-------------------

Match documents where `response` is 200 and `extension` is
php OR `extension` is css and response is anything:

[source,yaml]
-------------------
response:200 and extension:php or extension:css
-------------------

Match documents where `response` is not 200:

[source,yaml]
-------------------
not response:200
-------------------

Match documents where `response` is 200 but `extension` is not php or css.

[source,yaml]
-------------------
response:200 and not (extension:php or extension:css)
-------------------

Match multi-value fields that contain a list of terms:

[source,yaml]
-------------------
tags:(success and info and security)
-------------------

[discrete]
=== Range queries

KQL supports `>`, `>=`, `<`, and `<=`. For example:

[source,yaml]
-------------------
account_number:>=`100` and age:<=200
-------------------

[discrete]
=== Exist queries

An exist query matches documents that contain a value for a field, in this case
`response`.

[source,yaml]
-------------------
response:*
-------------------

[discrete]
=== Wildcard queries

Match documents where `machine.os` starts with "win", such
as "windows 7" and "windows 10":

[source,yaml]
-------------------
machine.os:win*
-------------------

Match multiple fields:

[source,yaml]
-------------------
machine.os*:windows 10
-------------------

This sytax is handy when you have both `text` and `keyword`
versions of a field. This query checks both `machine.os` and `machine.os.keyword`
for the term
"windows 10".


[discrete]
=== Nested field queries

A main consideration for querying {ref}/nested.html[nested fields] is how to match parts of the nested query to the individual nested documents.
There are two main approaches:

* *Parts of the query can only match a single nested document.* This is what most users want when querying on a nested field.
* *Parts of the query can match different nested documents.* This is how a regular object field works.
 This query is generally less useful than the first approach.

In the following document, `items` is a nested field. Each document in the nested
field contains a name, stock, and category.

[source,json]
----------------------------------
{
  "grocery_name": "Elastic Eats",
  "items": [
    {
      "name": "banana",
      "stock": "12",
      "category": "fruit"
    },
    {
      "name": "peach",
      "stock": "10",
      "category": "fruit"
    },
    {
      "name": "carrot",
      "stock": "9",
      "category": "vegetable"
    },
    {
      "name": "broccoli",
      "stock": "5",
      "category": "vegetable"
    }
  ]
}
----------------------------------

[discrete]
==== Match a single document

To match stores that have more than 10 bananas in stock:

[source,yaml]
-------------------
items:{ name:banana and stock > 10 }
-------------------

`items` is the "nested path". Everything inside the curly braces (the "nested group")
must match a single nested document.

The following query does not return any matches because no single nested
document has bananas with a stock of 9.

[source,yaml]
-------------------
items:{ name:banana and stock:9 }
-------------------

[discrete]
==== Match different documents

The subqueries in this example are in separate nested groups
and can match different nested documents.

[source,yaml]
-------------------
items:{ name:banana } and items:{ stock:9 }
-------------------

`name:banana` matches the first document in the array and `stock:9`
matches the third document in the array.

[discrete]
==== Match single and different documents

To find a store with more than 10
bananas that *also* stocks vegetables:

[source,yaml]
-------------------
items:{ name:banana and stock > 10 } and items:{ category:vegetable }
-------------------

The first nested group (`name:banana and stock > 10`) must still match a single document, but the `category:vegetables`
subquery can match a different nested document because it is in a separate group.

[discrete]
==== Nested fields inside other nested fields

KQL supports nested fields inside of other nested fields&mdash;you simply have to
specify the full path. In this document,
`level1` and `level2` are nested fields:

[source,json]
----------------------------------
{
  "level1": [
    {
      "level2": [
        {
          "prop1": "foo",
          "prop2": "bar"
        },
        {
          "prop1": "baz",
          "prop2": "qux"
        }
      ]
    }
  ]
}
----------------------------------

To match on a single nested document:

[source,yaml]
-------------------
level1.level2:{ prop1:foo and prop2:bar }
-------------------
