<!DOCTYPE html>
<html lang="en-us">
  <head>
    
<meta charset="UTF-8">
<meta name="keywords" content="Kibana diagnostic, diagnostics">
<title>Saved Objects service | Kibana Guide | Elastic</title>
<meta class="elastic" name="content" content="Saved Objects service | Kibana Guide">

<link rel="home" href="index.html" title="Kibana Guide"/>
<link rel="up" href="kibana-architecture.html" title="Architecture"/>
<link rel="prev" href="logging-config-changes.html" title="Logging configuration changes"/>
<link rel="next" href="ui-settings-service.html" title="UI settings service"/>
<meta class="elastic" name="product_version" content=""/>
<meta class="elastic" name="product_name" content=""/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/"/>
<meta name="DC.subject" content=""/>
<meta name="DC.identifier" content=""/>

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.optimizely.com/js/18132920325.js"></script>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-title" content="Elastic">
    <meta name="application-name" content="Elastic">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="naver-site-verification" content="936882c1853b701b3cef3721758d80535413dbfd" />
    <meta name="yandex-verification" content="d8a47e95d0972434" />
    <meta name="localized" content="true" />
    <meta name="st:robots" content="follow,index" />
    <meta property="og:image" content="https://static-www.elastic.co/v3/assets/bltefdd0b53724fa2ce/blt280217a63b82a734/6202d3378b1f312528798412/elastic-logo.svg" />
    <meta property="og:image:width" content="500" />
    <meta property="og:image:height" content="172" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon-precomposed" sizes="64x64" href="/favicon_64x64_16bit.png">
    <link rel="apple-touch-icon-precomposed" sizes="32x32" href="/favicon_32x32.png">
    <link rel="apple-touch-icon-precomposed" sizes="16x16" href="/favicon_16x16.png">
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" type="text/css" href="/guide/static/styles-v1.css" />
  </head>

  <!--© 2015-2025 Elasticsearch B.V. -->
  <!-- All Elastic documentation is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. -->
  <!-- http://creativecommons.org/licenses/by-nc-nd/4.0/ -->

  <body>
    <!-- Google Tag Manager -->
    <script>dataLayer = [];</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-58RLH5" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-58RLH5');</script>
    <!-- End Google Tag Manager -->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12395217-16"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-12395217-16');
    </script>

    <!-- Google Tag Manager for GA4 -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-KNJMG2M');</script>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager for GA4-->

    <div id='elastic-nav' style="display:none;"></div>
    <script src='https://www.elastic.co/elastic-nav.js'></script>

    <div class="main-container">
      <section id="content" >
        <div class="content-wrapper">

          <section id="guide" lang="en">
            <div class="container-fluid">
              <div class="row pb-3">
                <div class="col-12 order-2 col-md-4 order-md-1 col-lg-3 h-almost-full-md sticky-top-md" id="left_col">
                  <!-- The TOC is appended here -->
                </div>

                <div class="col-12 order-1 col-md-8 order-md-2 col-lg-7 order-lg-2 guide-section" id="middle_col">
                  <!-- start body -->
                  
<div class="navheader">
<span class="prev">
<a href="logging-config-changes.html">« Logging configuration changes</a>
</span>
<span class="next">
<a href="ui-settings-service.html">UI settings service »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Kibana Guide</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="development.html">Developer guide</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="kibana-architecture.html">Architecture</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>Saved Objects service</h1><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h2 class="title"><a id="saved-objects-service"></a>Saved Objects service</h2><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The Saved Objects service is available both server and client side.</p>
</div>
</div>
<p><code class="literal">Saved Objects service</code> allows Kibana plugins to use Elasticsearch like a primary
database. Think of it as an Object Document Mapper for Elasticsearch. Once a
plugin has registered one or more Saved Object types, the Saved Objects client
can be used to query or perform create, read, update and delete operations on
each type.</p>
<p>By using Saved Objects your plugin can take advantage of the following
features:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Migrations can evolve your document&#8217;s schema by transforming documents and
ensuring that the field mappings on the index are always up to date.
</li>
<li class="listitem">
a <a class="xref" href="saved-objects-api.html" title="Saved objects APIs">HTTP API</a> is automatically exposed for each type (unless
<code class="literal">hidden=true</code> is specified).
</li>
<li class="listitem">
a Saved Objects client that can be used from both the server and the browser.
</li>
<li class="listitem">
Users can import or export Saved Objects using the Saved Objects management
UI or the Saved Objects import/export API.
</li>
<li class="listitem">
By declaring <code class="literal">references</code>, an object&#8217;s entire reference graph will be
exported. This makes it easy for users to export e.g. a <code class="literal">dashboard</code> object and
have all the <code class="literal">visualization</code> objects required to display the dashboard
included in the export.
</li>
<li class="listitem">
When the X-Pack security and spaces plugins are enabled these transparently
provide RBAC access control and the ability to organize Saved Objects into
spaces.
</li>
</ul>
</div>
<p>This document contains developer guidelines and best-practices for plugins
wanting to use Saved Objects.</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h3 class="title"><a id="_server_side_usage_2"></a>Server side usage</h3><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="saved-objects-type-registration"></a>Registering a Saved Object type</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>Saved object type definitions should be defined in their own <code class="literal">my_plugin/server/saved_objects</code> directory.</p>
<p>The folder should contain a file per type, named after the snake_case name of the type, and an <code class="literal">index.ts</code> file exporting all the types.</p>
<p><strong>src/plugins/my_plugin/server/saved_objects/dashboard_visualization.ts.</strong></p>
<div class="pre_wrapper lang-typescript">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-typescript">import { SavedObjectsType } from 'src/core/server';

export const dashboardVisualization: SavedObjectsType = {
  name: 'dashboard_visualization', <a id="CO85-1"></a><i class="conum" data-value="1"></i>
  hidden: true,
  namespaceType: 'multiple-isolated', <a id="CO85-2"></a><i class="conum" data-value="2"></i>
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    1: modelVersion1,
    2: modelVersion2,
  },
  mappings: {
    dynamic: false,
    properties: {
      description: {
        type: 'text',
      },
      hits: {
        type: 'integer',
      },
    },
  },
  // ...other mandatory properties
};</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO85-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Since the name of a Saved Object type may form part of the URL path for the
public Saved Objects HTTP API, these should follow our API URL path convention
and always be written in snake case.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO85-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>This field determines "space behavior"&#8201;&#8212;&#8201;whether these objects can exist in one space, multiple spaces, or all spaces. This value means
that objects of this type can only exist in a single space. See <a class="xref" href="sharing-saved-objects.html" title="Sharing saved objects">Sharing Saved Objects</a> for more information.</p>
</td>
</tr>
</table>
</div>
<p><strong>src/plugins/my_plugin/server/saved_objects/index.ts.</strong></p>
<div class="pre_wrapper lang-typescript">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-typescript">export { dashboardVisualization } from './dashboard_visualization';
export { dashboard } from './dashboard';</pre>
</div>
<p><strong>src/plugins/my_plugin/server/plugin.ts.</strong></p>
<div class="pre_wrapper lang-typescript">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-typescript">import { dashboard, dashboardVisualization } from './saved_objects';

export class MyPlugin implements Plugin {
  setup({ savedObjects }) {
    savedObjects.registerType(dashboard);
    savedObjects.registerType(dashboardVisualization);
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_mappings"></a>Mappings</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>Each Saved Object type can define it&#8217;s own Elasticsearch field mappings.
Because multiple Saved Object types can share the same index, mappings defined
by a type will be nested under a top-level field that matches the type name.</p>
<p>For example, the mappings defined by the <code class="literal">search</code> Saved
Object type:</p>
<p><a href="https://github.com/elastic/kibana/blob/main/src/plugins/saved_search/server/saved_objects/search.ts#L19-L70" class="ulink" target="_top">.src/plugins/saved_search/server/saved_objects/search.ts</a></p>
<div class="pre_wrapper lang-typescript">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-typescript">import { SavedObjectsType } from 'src/core/server';
// ... other imports
export function getSavedSearchObjectType: SavedObjectsType = { <a id="CO86-1"></a><i class="conum" data-value="1"></i>
  name: 'search',
  hidden: false,
  namespaceType: 'multiple-isolated',
  mappings: {
    dynamic: false,
    properties: {
      title: { type: 'text' },
      description: { type: 'text' },
    },
  },
  modelVersions: { ... },
  // ...other optional properties
};</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO86-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Simplification</p>
</td>
</tr>
</table>
</div>
<p>Will result in the following mappings being applied to the <code class="literal">.kibana_analytics</code> index:</p>
<div class="pre_wrapper lang-json">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-json">{
  "mappings": {
    "dynamic": "strict",
    "properties": {
      ...
      "search": {
        "dynamic": false,
        "properties": {
          "title": {
            "type": "text",
          },
          "description": {
            "type": "text",
          },
        },
      }
    }
  }
}</pre>
</div>
<p>Do not use field mappings like you would use data types for the columns of a
SQL database. Instead, field mappings are analogous to a SQL index. Only
specify field mappings for the fields you wish to search on or query. By
specifying <code class="literal">dynamic: false</code> in any level of your mappings, Elasticsearch will
accept and store any other fields even if they are not specified in your mappings.</p>
<p>Since Elasticsearch has a default limit of 1000 fields per index, plugins
should carefully consider the fields they add to the mappings. Similarly,
Saved Object types should never use <code class="literal">dynamic: true</code> as this can cause an
arbitrary amount of fields to be added to the <code class="literal">.kibana</code> index.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="saved-objects-service-writing-migrations"></a>Writing Migrations by defining model versions</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>Saved Objects support changes using <code class="literal">modelVersions`</code>. The modelVersion API is a new way to define transformations
(<em>`&#8216;migrations&#8217;'</em>) for your savedObject types, and will replace the
&#8220;legacy&#8221; migration API after Kibana version <code class="literal">8.10.0</code>. The legacy migration API has been deprecated, meaning it is no longer possible to register migrations using the legacy system.</p>
<p>Model versions are decoupled from the stack version and satisfy the requirements for zero downtime and backward-compatibility.</p>
<p>Each Saved Object type may define model versions for its schema and are bound to a given <a href="https://github.com/elastic/kibana/blob/9b330e493216e8dde3166451e4714966f63f5ab7/packages/core/saved-objects/core-saved-objects-server/src/saved_objects_type.ts#L22-L27" class="ulink" target="_top">savedObject type</a>. Changes to a saved object type are
specified by defining a new model.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h3 class="title"><a id="_defining_model_versions"></a>Defining model versions</h3><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>As for old migrations, model versions are bound to a given
<a href="https://github.com/elastic/kibana/blob/9b330e493216e8dde3166451e4714966f63f5ab7/packages/core/saved-objects/core-saved-objects-server/src/saved_objects_type.ts#L22-L27" class="ulink" target="_top">savedObject
type</a></p>
<p>When registering a SO type, a new
<a href="https://github.com/elastic/kibana/blob/9a6a2ccdff619f827b31c40dd9ed30cb27203da7/packages/core/saved-objects/core-saved-objects-server/src/saved_objects_type.ts#L138-L177" class="ulink" target="_top">modelVersions</a>
property is available. This attribute is a map of
<a href="https://github.com/elastic/kibana/blob/9a6a2ccdff619f827b31c40dd9ed30cb27203da7/packages/core/saved-objects/core-saved-objects-server/src/model_version/model_version.ts#L12-L20" class="ulink" target="_top">SavedObjectsModelVersion</a>
which is the top-level type/container to define model versions.</p>
<p>This map follows a similar <code class="literal">{ [version number] =&gt; version definition }</code>
format as the old migration map, however a given SO type’s model version
is now identified by a single integer.</p>
<p>The first version must be numbered as version 1, incrementing by one for
each new version.</p>
<p>That way: - SO type versions are decoupled from stack versioning - SO
type versions are independent between types</p>
<p><em>a <span class="strong strong"><strong>valid</strong></span> version numbering:</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const myType: SavedObjectsType = {
  name: 'test',
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    1: modelVersion1, // valid: start with version 1
    2: modelVersion2, // valid: no gap between versions
  },
  // ...other mandatory properties
};</pre>
</div>
<p><em>an <span class="strong strong"><strong>invalid</strong></span> version numbering:</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const myType: SavedObjectsType = {
  name: 'test',
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    2: modelVersion2, // invalid: first version must be 1
    4: modelVersion3, // invalid: skipped version 3
  },
  // ...other mandatory properties
};</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h3 class="title"><a id="_structure_of_a_model_version"></a>Structure of a model version</h3><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p><a href="https://github.com/elastic/kibana/blob/9b330e493216e8dde3166451e4714966f63f5ab7/packages/core/saved-objects/core-saved-objects-server/src/model_version/model_version.ts#L12-L20" class="ulink" target="_top">Model
versions</a> are not just functions as the previous migrations were, but
structured objects describing how the version behaves and what changed
since the last one.</p>
<p><em>A base example of what a model version can look like:</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const myType: SavedObjectsType = {
  name: 'test',
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    1: {
      changes: [
        {
          type: 'mappings_addition',
          addedMappings: {
            someNewField: { type: 'text' },
          },
        },
        {
          type: 'data_backfill',
          transform: someBackfillFunction,
        },
      ],
      schemas: {
        forwardCompatibility: fcSchema,
        create: createSchema,
      },
    },
  },
  // ...other mandatory properties
};</pre>
</div>
<p><span class="strong strong"><strong>Note:</strong></span> Having multiple changes of the same type for a given version is
supported by design to allow merging different sources (to prepare for
an eventual higher-level API)</p>
<p><em>This definition would be perfectly valid:</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const version1: SavedObjectsModelVersion = {
  changes: [
    {
      type: 'mappings_addition',
      addedMappings: {
        someNewField: { type: 'text' },
      },
    },
    {
      type: 'mappings_addition',
      addedMappings: {
        anotherNewField: { type: 'text' },
      },
    },
  ],
};</pre>
</div>
<p>It’s currently composed of two main properties:</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_changes"></a>changes</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p><a href="https://github.com/elastic/kibana/blob/9b330e493216e8dde3166451e4714966f63f5ab7/packages/core/saved-objects/core-saved-objects-server/src/model_version/model_version.ts#L21-L51" class="ulink" target="_top">link
to the TS doc for <code class="literal">changes</code></a></p>
<p>Describes the list of changes applied during this version.</p>
<p><span class="strong strong"><strong>Important:</strong></span> This is the part that replaces the old migration system,
and allows defining when a version adds new mapping, mutates the
documents, or other type-related changes.</p>
<p>The current types of changes are:</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_mappings_addition"></a>- mappings_addition</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>Used to define new mappings introduced in a given version.</p>
<p><em>Usage example:</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const change: SavedObjectsModelMappingsAdditionChange = {
  type: 'mappings_addition',
  addedMappings: {
    newField: { type: 'text' },
    existingNestedField: {
      properties: {
        newNestedProp: { type: 'keyword' },
      },
    },
  },
};</pre>
</div>
<p><span class="strong strong"><strong>note:</strong></span> <em>When adding mappings, the root <code class="literal">type.mappings</code> must also be
updated accordingly (as it was done previously).</em></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_mappings_deprecation"></a>- mappings_deprecation</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>Used to flag mappings as no longer being used and ready to be removed.</p>
<p><em>Usage example:</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">let change: SavedObjectsModelMappingsDeprecationChange = {
  type: 'mappings_deprecation',
  deprecatedMappings: ['someDeprecatedField', 'someNested.deprecatedField'],
};</pre>
</div>
<p><span class="strong strong"><strong>note:</strong></span> <em>It is currently not possible to remove fields from an existing
index’s mapping (without reindexing into another index), so the mappings
flagged with this change type won’t be deleted for now, but this should
still be used to allow our system to clean the mappings once upstream
(ES) unblock us.</em></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_data_backfill"></a>- data_backfill</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>Used to populate fields (indexed or not) added in the same version.</p>
<p><em>Usage example:</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">let change: SavedObjectsModelDataBackfillChange = {
  type: 'data_backfill',
  transform: (document) =&gt; {
    return { attributes: { someAddedField: 'defaultValue' } };
  },
};</pre>
</div>
<p><span class="strong strong"><strong>note:</strong></span> <em>Even if no check is performed to ensure it, this type of model
change should only be used to backfill newly introduced fields.</em></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_data_removal"></a>- data_removal</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>Used to remove data (unset fields) from all documents of the type.</p>
<p><em>Usage example:</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">let change: SavedObjectsModelDataRemovalChange = {
  type: 'data_removal',
  attributePaths: ['someRootAttributes', 'some.nested.attribute'],
};</pre>
</div>
<p><span class="strong strong"><strong>note:</strong></span> <em>Due to backward compatibility, field utilization must be
stopped in a prior release before actual data removal (in case of
rollback). Please refer to the field removal migration example below in
this document</em></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_unsafe_transform"></a>- unsafe_transform</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>Used to execute an arbitrary transformation function.</p>
<p><em>Usage example:</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">let change: SavedObjectsModelUnsafeTransformChange = {
  type: 'unsafe_transform',
  transformFn: (document) =&gt; {
    document.attributes.someAddedField = 'defaultValue';
    return { document };
  },
};</pre>
</div>
<p><span class="strong strong"><strong>note:</strong></span> <em>Using such transformations is potentially unsafe, given the
migration system will have no knowledge of which kind of operations will
effectively be executed against the documents. Those should only be used
when there’s no other way to cover one’s migration needs.</em> <span class="strong strong"><strong>Please reach
out to the development team if you think you need to use this, as you
theoretically shouldn’t.</strong></span></p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_schemas"></a>schemas</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p><a href="https://github.com/elastic/kibana/blob/9b330e493216e8dde3166451e4714966f63f5ab7/packages/core/saved-objects/core-saved-objects-server/src/model_version/schemas.ts#L11-L16" class="ulink" target="_top">link
to the TS doc for <code class="literal">schemas</code></a></p>
<p>The schemas associated with this version. Schemas are used to validate
or convert SO documents at various stages of their lifecycle.</p>
<p>The currently available schemas are:</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_forwardcompatibility"></a>forwardCompatibility</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>This is a new concept introduced by model versions. This schema is used
for inter-version compatibility.</p>
<p>When retrieving a savedObject document from an index, if the version of
the document is higher than the latest version known of the Kibana
instance, the document will go through the <code class="literal">forwardCompatibility</code> schema
of the associated model version.</p>
<p><span class="strong strong"><strong>Important:</strong></span> These conversion mechanism shouldn’t assert the data
itself, and only strip unknown fields to convert the document to the
<span class="strong strong"><strong>shape</strong></span> of the document at the given version.</p>
<p>Basically, this schema should keep all the known fields of a given
version, and remove all the unknown fields, without throwing.</p>
<p>Forward compatibility schema can be implemented in two different ways.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Using <code class="literal">config-schema</code>
</li>
</ol>
</div>
<p><em>Example of schema for a version having two fields: someField and
anotherField</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const versionSchema = schema.object(
  {
    someField: schema.maybe(schema.string()),
    anotherField: schema.maybe(schema.string()),
  },
  { unknowns: 'ignore' }
);</pre>
</div>
<p><span class="strong strong"><strong>Important:</strong></span> Note the <code class="literal">{ unknowns: 'ignore' }</code> in the schema’s options.
This is required when using <code class="literal">config-schema</code> based schemas, as this what
will evict the additional fields without throwing an error.</p>
<div class="olist orderedlist">
<ol class="orderedlist" start="2">
<li class="listitem">
Using a plain javascript function
</li>
</ol>
</div>
<p><em>Example of schema for a version having two fields: someField and
anotherField</em></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const versionSchema: SavedObjectModelVersionEvictionFn = (attributes) =&gt; {
  const knownFields = ['someField', 'anotherField'];
  return pick(attributes, knownFields);
}</pre>
</div>
<p><span class="strong strong"><strong>note:</strong></span> <em>Even if highly recommended, implementing this schema is not
strictly required. Type owners can manage unknown fields and
inter-version compatibility themselves in their service layer instead.</em></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_create"></a>create</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></div>
</div></div></div>
<p>This is a direct replacement for
<a href="https://github.com/elastic/kibana/blob/9b330e493216e8dde3166451e4714966f63f5ab7/packages/core/saved-objects/core-saved-objects-server/src/saved_objects_type.ts#L75-L82" class="ulink" target="_top">the
old SavedObjectType.schemas</a> definition, now directly included in the
model version definition.</p>
<p>As a refresher the <code class="literal">create</code> schema is a <code class="literal">@kbn/config-schema</code> object-type
schema, and is used to validate the properties of the document during
<code class="literal">create</code> and <code class="literal">bulkCreate</code> operations.</p>
<p><span class="strong strong"><strong>note:</strong></span> <em>Implementing this schema is optional, but still recommended, as
otherwise there will be no validating when importing objects</em></p>
<p>For implementation examples, refer to <a class="xref" href="saved-objects-service.html#saved-objects-service-use-case-examples" title="Use-case examples">Use case examples</a>.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="saved-objects-service-use-case-examples"></a>Use-case examples</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>These are example of the migration scenario currently supported (out of
the box) by the system.</p>
<p><span class="strong strong"><strong>note:</strong></span> <em>more complex scenarios (e.g field mutation by copy/sync) could
already be implemented, but without the proper tooling exposed from
Core, most of the work related to sync and compatibility would have to
be implemented in the domain layer of the type owners, which is why
we’re not documenting them yet.</em></p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_adding_a_non_indexed_field_without_default_value"></a>Adding a non-indexed field without default value</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>We are currently in model version 1, and our type has 2 indexed fields
defined: <code class="literal">foo</code> and <code class="literal">bar</code>.</p>
<p>The definition of the type at version 1 would look like:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const myType: SavedObjectsType = {
  name: 'test',
  namespaceType: 'single',
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    // initial (and current) model version
    1: {
      changes: [],
      schemas: {
        // FC schema defining the known fields (indexed or not) for this version
        forwardCompatibility: schema.object(
          { foo: schema.string(), bar: schema.string() },
          { unknowns: 'ignore' } // note the `unknown: ignore` which is how we're evicting the unknown fields
        ),
        // schema that will be used to validate input during `create` and `bulkCreate`
        create:  schema.object(
          { foo: schema.string(), bar: schema.string() },
        )
      },
    },
  },
  mappings: {
    properties: {
      foo: { type: 'text' },
      bar: { type: 'text' },
    },
  },
};</pre>
</div>
<p>From here, say we want to introduce a new <code class="literal">dolly</code> field that is not
indexed, and that we don’t need to populate with a default value.</p>
<p>To achieve that, we need to introduce a new model version, with the only
thing to do will be to define the associated schemas to include this new
field.</p>
<p>The added model version would look like:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">// the new model version adding the `dolly` field
let modelVersion2: SavedObjectsModelVersion = {
  // not an indexed field, no data backfill, so changes are actually empty
  changes: [],
  schemas: {
    // the only addition in this model version: taking the new field into account for the schemas
    forwardCompatibility: schema.object(
      { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
      { unknowns: 'ignore' } // note the `unknown: ignore` which is how we're evicting the unknown fields
    ),
    create:  schema.object(
      { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
    )
  },
};</pre>
</div>
<p>The full type definition after the addition of the new model version:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const myType: SavedObjectsType = {
  name: 'test',
  namespaceType: 'single',
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    1: {
      changes: [],
      schemas: {
        forwardCompatibility: schema.object(
          { foo: schema.string(), bar: schema.string() },
          { unknowns: 'ignore' }
        ),
        create:  schema.object(
          { foo: schema.string(), bar: schema.string() },
        )
      },
    },
    2: {
      changes: [],
      schemas: {
        forwardCompatibility: schema.object(
          { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
          { unknowns: 'ignore' }
        ),
        create:  schema.object(
          { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
        )
      },
    },
  },
  mappings: {
    properties: {
      foo: { type: 'text' },
      bar: { type: 'text' },
    },
  },
};</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_adding_an_indexed_field_without_default_value"></a>Adding an indexed field without default value</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>This scenario is fairly close to the previous one. The difference being
that working with an indexed field means adding a <code class="literal">mappings_addition</code>
change and to also update the root mappings accordingly.</p>
<p>To reuse the previous example, let’s say the <code class="literal">dolly</code> field we want to
add would need to be indexed instead.</p>
<p>In that case, the new version needs to do the following: - add a
<code class="literal">mappings_addition</code> type change to define the new mappings - update the
root <code class="literal">mappings</code> accordingly - add the updated schemas as we did for the
previous example</p>
<p>The new version definition would look like:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">let modelVersion2: SavedObjectsModelVersion = {
  // add a change defining the mapping for the new field
  changes: [
    {
      type: 'mappings_addition',
      addedMappings: {
        dolly: { type: 'text' },
      },
    },
  ],
  schemas: {
    // adding the new field to the forwardCompatibility schema
    forwardCompatibility: schema.object(
      { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
      { unknowns: 'ignore' }
    ),
    create:  schema.object(
      { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
    )
  },
};</pre>
</div>
<p>As said, we will also need to update the root mappings definition:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">mappings: {
  properties: {
    foo: { type: 'text' },
    bar: { type: 'text' },
    dolly: { type: 'text' },
  },
},</pre>
</div>
<p>the full type definition after the addition of the model version 2 would
be:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const myType: SavedObjectsType = {
  name: 'test',
  namespaceType: 'single',
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    1: {
      changes: [
        {
          type: 'mappings_addition',
          addedMappings: {
            foo: { type: 'text' },
            bar: { type: 'text' },
          },
        },
      ],
      schemas: {
        forwardCompatibility: schema.object(
          { foo: schema.string(), bar: schema.string() },
          { unknowns: 'ignore' }
        ),
        create:  schema.object(
          { foo: schema.string(), bar: schema.string() },
        )
      },
    },
    2: {
      changes: [
        {
          type: 'mappings_addition',
          addedMappings: {
            dolly: { type: 'text' },
          },
        },
      ],
      schemas: {
        forwardCompatibility: schema.object(
          { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
          { unknowns: 'ignore' }
        ),
        create:  schema.object(
          { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
        )
      },
    },
  },
  mappings: {
    properties: {
      foo: { type: 'text' },
      bar: { type: 'text' },
      dolly: { type: 'text' },
    },
  },
};</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_adding_an_indexed_field_with_a_default_value"></a>Adding an indexed field with a default value</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>Now a slightly different scenario where we’d like to populate the newly
introduced field with a default value.</p>
<p>In that case, we’d need to add an additional <code class="literal">data_backfill</code> change to
populate the new field’s value (in addition to the <code class="literal">mappings_addition</code>
one):</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">let modelVersion2: SavedObjectsModelVersion = {
  changes: [
    // setting the `dolly` field's default value.
    {
      type: 'data_backfill',
      transform: (document) =&gt; {
        return { attributes: { dolly: 'default_value' } };
      },
    },
    // define the mappings for the new field
    {
      type: 'mappings_addition',
      addedMappings: {
        dolly: { type: 'text' },
      },
    },
  ],
  schemas: {
    // define `dolly` as an know field in the schema
    forwardCompatibility: schema.object(
      { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
      { unknowns: 'ignore' }
    ),
    create:  schema.object(
      { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
    )
  },
};</pre>
</div>
<p>The full type definition would look like:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const myType: SavedObjectsType = {
  name: 'test',
  namespaceType: 'single',
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    1: {
      changes: [
        {
          type: 'mappings_addition',
          addedMappings: {
            foo: { type: 'text' },
            bar: { type: 'text' },
          },
        },
      ],
      schemas: {
        forwardCompatibility: schema.object(
          { foo: schema.string(), bar: schema.string() },
          { unknowns: 'ignore' }
        ),
        create:  schema.object(
          { foo: schema.string(), bar: schema.string() },
        )
      },
    },
    2: {
      changes: [
        {
          type: 'data_backfill',
          transform: (document) =&gt; {
            return { attributes: { dolly: 'default_value' } };
          },
        },
        {
          type: 'mappings_addition',
          addedMappings: {
            dolly: { type: 'text' },
          },
        },
      ],
      schemas: {
        forwardCompatibility: schema.object(
          { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
          { unknowns: 'ignore' }
        ),
        create:  schema.object(
          { foo: schema.string(), bar: schema.string(), dolly: schema.string() },
        )
      },
    },
  },
  mappings: {
    properties: {
      foo: { type: 'text' },
      bar: { type: 'text' },
      dolly: { type: 'text' },
    },
  },
};</pre>
</div>
<p><span class="strong strong"><strong>Note:</strong></span> <em>if the field was non-indexed, we would just not use the
<code class="literal">mappings_addition</code> change or update the mappings (as done in example
1)</em></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_removing_an_existing_field"></a>Removing an existing field</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>We are currently in model version 1, and our type has 2 indexed fields
defined: <code class="literal">kept</code> and <code class="literal">removed</code>.</p>
<p>The definition of the type at version 1 would look like:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const myType: SavedObjectsType = {
  name: 'test',
  namespaceType: 'single',
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    // initial (and current) model version
    1: {
      changes: [],
      schemas: {
        // FC schema defining the known fields (indexed or not) for this version
        forwardCompatibility: schema.object(
          { kept: schema.string(), removed: schema.string() },
          { unknowns: 'ignore' } // note the `unknown: ignore` which is how we're evicting the unknown fields
        ),
        // schema that will be used to validate input during `create` and `bulkCreate`
        create:  schema.object(
          { kept: schema.string(), removed: schema.string() },
        )
      },
    },
  },
  mappings: {
    properties: {
      kept: { type: 'text' },
      removed: { type: 'text' },
    },
  },
};</pre>
</div>
<p>From here, say we want to remove the <code class="literal">removed</code> field, as our application
doesn’t need it anymore since a recent change.</p>
<p>The first thing to understand here is the impact toward backward
compatibility: Say that Kibana version <code class="literal">X</code> was still using this field,
and that we stopped utilizing the field in version <code class="literal">X+1</code>.</p>
<p>We can’t remove the data in version <code class="literal">X+1</code>, as we need to be able to
rollback to the prior version at <span class="strong strong"><strong>any time</strong></span>. If we were to delete the
data of this <code class="literal">removed</code> field during the upgrade to version <code class="literal">X+1</code>, and if
then, for any reason, we’d need to rollback to version <code class="literal">X</code>, it would
cause a data loss, as version <code class="literal">X</code> was still using this field, but it
would no longer present in our document after the rollback.</p>
<p>Which is why we need to perform any field removal as a 2-step operation:
- release <code class="literal">X</code>: Kibana still utilize the field - release <code class="literal">X+1</code>: Kibana no
longer utilize the field, but the data is still present in the documents
- release <code class="literal">X+2</code>: The data is effectively deleted from the documents.</p>
<p>That way, any prior-version rollback (<code class="literal">X+2</code> to <code class="literal">X+1</code> <span class="strong strong"><strong>or</strong></span> <code class="literal">X+1</code> to <code class="literal">X</code>
is safe in term of data integrity)</p>
<p>The main question then, is what’s the best way of having our application
layer simply ignore this <code class="literal">removed</code> field during version <code class="literal">X+1</code>, as we
don’t want this field (now non-utilized) to be returned from the
persistence layer, as it could &#8220;pollute&#8221; the higher-layers where the
field is effectively no longer used or even known.</p>
<p>This can easily be done by introducing a new version and using the
<code class="literal">forwardCompatibility</code> schema to &#8220;shallow&#8221; the field.</p>
<p>The <code class="literal">X+1</code> model version would look like:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">// the new model version ignoring the `removed` field
let modelVersion2: SavedObjectsModelVersion = {
  changes: [],
  schemas: {
    forwardCompatibility: schema.object(
      { kept: schema.string() }, // `removed` is no longer defined here
      { unknowns: 'ignore' }
    ),
    create:  schema.object(
      { kept: schema.string() }, // `removed` is no longer defined here
    )
  },
};</pre>
</div>
<p>The full type definition after the addition of the new model version:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const myType: SavedObjectsType = {
  name: 'test',
  namespaceType: 'single',
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    // initial (and current) model version
    1: {
      changes: [],
      schemas: {
        // FC schema defining the known fields (indexed or not) for this version
        forwardCompatibility: schema.object(
          { kept: schema.string(), removed: schema.string() },
          { unknowns: 'ignore' } // note the `unknown: ignore` which is how we're evicting the unknown fields
        ),
        // schema that will be used to validate input during `create` and `bulkCreate`
        create:  schema.object(
          { kept: schema.string(), removed: schema.string() },
        )
      },
    },
    2: {
      changes: [],
      schemas: {
        forwardCompatibility: schema.object(
          { kept: schema.string() }, // `removed` is no longer defined here
          { unknowns: 'ignore' }
        ),
        create:  schema.object(
          { kept: schema.string() }, // `removed` is no longer defined here
        )
      },
    }
  },
  mappings: {
    properties: {
      kept: { type: 'text' },
      removed: { type: 'text' },
    },
  },
};</pre>
</div>
<p>then, in a <span class="strong strong"><strong>later</strong></span> release, we can then deploy the change that will
effectively remove the data from the documents:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">// the new model version ignoring the `removed` field
let modelVersion3: SavedObjectsModelVersion = {
  changes: [ // define a data_removal change to delete the field
    {
      type: 'data_removal',
      removedAttributePaths: ['removed']
    }
  ],
  schemas: {
    forwardCompatibility: schema.object(
      { kept: schema.string() },
      { unknowns: 'ignore' }
    ),
    create:  schema.object(
      { kept: schema.string() },
    )
  },
};</pre>
</div>
<p>The full type definition after the data removal would look like:</p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">const myType: SavedObjectsType = {
  name: 'test',
  namespaceType: 'single',
  switchToModelVersionAt: '8.10.0',
  modelVersions: {
    // initial (and current) model version
    1: {
      changes: [],
      schemas: {
        // FC schema defining the known fields (indexed or not) for this version
        forwardCompatibility: schema.object(
          { kept: schema.string(), removed: schema.string() },
          { unknowns: 'ignore' } // note the `unknown: ignore` which is how we're evicting the unknown fields
        ),
        // schema that will be used to validate input during `create` and `bulkCreate`
        create:  schema.object(
          { kept: schema.string(), removed: schema.string() },
        )
      },
    },
    2: {
      changes: [],
      schemas: {
        forwardCompatibility: schema.object(
          { kept: schema.string() }, // `removed` is no longer defined here
          { unknowns: 'ignore' }
        ),
        create:  schema.object(
          { kept: schema.string() }, // `removed` is no longer defined here
        )
      },
    },
    3: {
      changes: [ // define a data_removal change to delete the field
        {
          type: 'data_removal',
          removedAttributePaths: ['removed']
        }
      ],
      schemas: {
        forwardCompatibility: schema.object(
          { kept: schema.string() },
          { unknowns: 'ignore' }
        ),
        create:  schema.object(
          { kept: schema.string() },
        )
      },
    }
  },
  mappings: {
    properties: {
      kept: { type: 'text' },
      removed: { type: 'text' },
    },
  },
};</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_testing_model_versions"></a>Testing model versions</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>Model versions definitions are more structured than the legacy migration
functions, which makes them harder to test without the proper tooling.
This is why a set of testing tools and utilities are exposed from the
<code class="literal">@kbn/core-test-helpers-model-versions</code> package, to help properly test
the logic associated with model version and their associated
transformations.</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_tooling_for_unit_tests"></a>Tooling for unit tests</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>For unit tests, the package exposes utilities to easily test the impact
of transforming documents from a model version to another one, either
upward or backward.</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h6 class="title"><a id="_model_version_test_migrator"></a>Model version test migrator</h6><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>The <code class="literal">createModelVersionTestMigrator</code> helper allows to create a test
migrator that can be used to test model version changes between
versions, by transforming documents the same way the migration algorithm
would during an upgrade.</p>
<p><span class="strong strong"><strong>Example:</strong></span></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">import {
  createModelVersionTestMigrator,
  type ModelVersionTestMigrator
} from '@kbn/core-test-helpers-model-versions';

const mySoTypeDefinition = someSoType();

describe('mySoTypeDefinition model version transformations', () =&gt; {
  let migrator: ModelVersionTestMigrator;

  beforeEach(() =&gt; {
    migrator = createModelVersionTestMigrator({ type: mySoTypeDefinition });
  });

  describe('Model version 2', () =&gt; {
    it('properly backfill the expected fields when converting from v1 to v2', () =&gt; {
      const obj = createSomeSavedObject();

      const migrated = migrator.migrate({
        document: obj,
        fromVersion: 1,
        toVersion: 2,
      });

      expect(migrated.properties).toEqual(expectedV2Properties);
    });

    it('properly removes the expected fields when converting from v2 to v1', () =&gt; {
      const obj = createSomeSavedObject();

      const migrated = migrator.migrate({
        document: obj,
        fromVersion: 2,
        toVersion: 1,
      });

      expect(migrated.properties).toEqual(expectedV1Properties);
    });
  });
});</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_tooling_for_integration_tests"></a>Tooling for integration tests</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>During integration tests, we can boot a real Elasticsearch cluster,
allowing us to manipulate SO documents in a way almost similar to how it
would be done on production runtime. With integration tests, we can even
simulate the cohabitation of two Kibana instances with different model
versions to assert the behavior of their interactions.</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h6 class="title"><a id="_model_version_test_bed"></a>Model version test bed</h6><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>The package exposes a <code class="literal">createModelVersionTestBed</code> function that can be
used to fully setup a test bed for model version integration testing. It
can be used to start and stop the ES server, and to initiate the
migration between the two versions we’re testing.</p>
<p><span class="strong strong"><strong>Example:</strong></span></p>
<div class="pre_wrapper lang-ts">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ts">import {
  createModelVersionTestBed,
  type ModelVersionTestKit
} from '@kbn/core-test-helpers-model-versions';

describe('myIntegrationTest', () =&gt; {
  const testbed = createModelVersionTestBed();
  let testkit: ModelVersionTestKit;

  beforeAll(async () =&gt; {
    await testbed.startES();
  });

  afterAll(async () =&gt; {
    await testbed.stopES();
  });

  beforeEach(async () =&gt; {
    // prepare the test, preparing the index and performing the SO migration
    testkit = await testbed.prepareTestKit({
      savedObjectDefinitions: [{
        definition: mySoTypeDefinition,
        // the model version that will be used for the "before" version
        modelVersionBefore: 1,
        // the model version that will be used for the "after" version
        modelVersionAfter: 2,
      }]
    })
  });

  afterEach(async () =&gt; {
    if(testkit) {
      // delete the indices between each tests to perform a migration again
      await testkit.tearDown();
    }
  });

  it('can be used to test model version cohabitation', async () =&gt; {
    // last registered version is `1` (modelVersionBefore)
    const repositoryV1 = testkit.repositoryBefore;
    // last registered version is `2` (modelVersionAfter)
    const repositoryV2 = testkit.repositoryAfter;

    // do something with the two repositories, e.g
    await repositoryV1.create(someAttrs, { id });
    const v2docReadFromV1 = await repositoryV2.get('my-type', id);
    expect(v2docReadFromV1.attributes).toEqual(whatIExpect);
  });
});</pre>
</div>
<p><span class="strong strong"><strong>Limitations:</strong></span></p>
<p>Because the test bed is only creating the parts of Core required to
instantiate the two SO repositories, and because we’re not able to
properly load all plugins (for proper isolation), the integration test
bed currently has some limitations:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p>no extensions are enabled</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
no security
</li>
<li class="listitem">
no encryption
</li>
<li class="listitem">
no spaces
</li>
</ul>
</div>
</li>
<li class="listitem">
all SO types will be using the same SO index
</li>
</ul>
</div>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_limitations_and_edge_cases_in_serverless_environments"></a>Limitations and edge cases in serverless environments</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>The serverless environment, and the fact that upgrade in such
environments are performed in a way where, at some point, the old and
new version of the application are living in cohabitation, leads to some
particularities regarding the way the SO APIs works, and to some
limitations / edge case that we need to document</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_using_the_fields_option_of_the_find_savedobjects_api"></a>Using the <code class="literal">fields</code> option of the <code class="literal">find</code> savedObjects API</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>By default, the <code class="literal">find</code> API (as any other SO API returning documents)
will migrate all documents before returning them, to ensure that
documents can be used by both versions during a cohabitation (e.g an old
node searching for documents already migrated, or a new node searching
for documents not yet migrated).</p>
<p>However, when using the <code class="literal">fields</code> option of the <code class="literal">find</code> API, the documents
can’t be migrated, as some model version changes can’t be applied
against a partial set of attributes. For this reason, when the <code class="literal">fields</code>
option is provided, the documents returned from <code class="literal">find</code> will <span class="strong strong"><strong>not</strong></span> be
migrated.</p>
<p>Which is why, when using this option, the API consumer needs to make
sure that <em>all</em> the fields passed to the <code class="literal">fields</code> option <span class="strong strong"><strong>were already
present in the prior model version</strong></span>. Otherwise, it may lead to
inconsistencies during upgrades, where newly introduced or backfilled
fields may not necessarily appear in the documents returned from the
<code class="literal">search</code> API when the option is used.</p>
<p>(<em>note</em>: both the previous and next version of Kibana must follow this
rule then)</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_using_bulkupdate_for_fields_with_large_json_blobs"></a>Using <code class="literal">bulkUpdate</code> for fields with large <code class="literal">json</code> blobs</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/master/docs/developer/architecture/core/saved-objects-service-use-case-examples.asciidoc">edit</a></div>
</div></div></div>
<p>The savedObjects <code class="literal">bulkUpdate</code> API will update documents client-side and
then reindex the updated documents. These update operations are done
in-memory, and cause memory constraint issues when updating many objects
with large <code class="literal">json</code> blobs stored in some fields. As such, we recommend
against using <code class="literal">bulkUpdate</code> for savedObjects that: - use arrays (as these
tend to be large objects) - store large <code class="literal">json</code> blobs in some fields</p>
</div>

</div>

</div>

</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="logging-config-changes.html">« Logging configuration changes</a>
</span>
<span class="next">
<a href="ui-settings-service.html">UI settings service »</a>
</span>
</div>

                  <!-- end body -->
                </div>

                <div class="col-12 order-3 col-lg-2 order-lg-3 h-almost-full-lg sticky-top-lg" id="right_col">
                  <div id="sticky_content">
                    <!-- The OTP is appended here -->
                    <div class="row">
                      <div class="col-0 col-md-4 col-lg-0" id="bottom_left_col"></div>
                      <div class="col-12 col-md-8 col-lg-12">
                        <div id="rtpcontainer">
                          <div class="mktg-promo" id="most-popular">
                            <p class="aside-heading">Most Popular</p>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/getting-started-elasticsearch?page=docs&placement=top-video">
                                <p class="mb-0">Get Started with Elasticsearch</p>
                              </a>
                            </div>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/getting-started-kibana?page=docs&placement=top-video">
                                <p class="mb-0">Intro to Kibana</p>
                              </a>
                            </div>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/introduction-elk-stack?page=docs&placement=top-video">
                                <p class="mb-0">ELK for Logs & Metrics</p>
                              </a>
                            </div>
                          </div>
                        </div>

                        <!-- Feedback widget -->
                        <div id="feedbackWidgetContainer"></div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

        </div>


        <div id='elastic-footer'></div>
        <script src='https://www.elastic.co/elastic-footer.js'></script>
        <!-- Footer Section end-->

      </section>
    </div>

    <!-- Feedback modal -->
    <div id="feedbackModalContainer"></div>

    <script src="/guide/static/jquery.js"></script>
    <script type="text/javascript" src="/guide/static/docs-v1.js"></script>
    <script type="text/javascript">
  window.initial_state = {}</script>
  </body>
</html>
