/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { renderHook } from '@testing-library/react-hooks';
import { ALERT_STATUS, ValidFeatureId } from '@kbn/rule-data-utils';

import { createUseFieldsMetadataHook } from './use_fields_metadata';
import { KibanaReactContextValue, useKibana } from '@kbn/kibana-react-plugin/public';
import { coreMock } from '@kbn/core/public/mocks';
import { CoreStart } from '@kbn/core/public';
import { FIND_FIELDS_METADATA_URL } from '../../../common/fields_metadata';
import { createFieldsMetadataClientMock } from '../../services/fields_metadata/fields_metadata_client.mock';
import { FindFieldsMetadataResponsePayload } from '../../../common/latest';

const mockedFieldsMetadataResponse: FindFieldsMetadataResponsePayload = {
  fields: {
    '@timestamp': {
      dashed_name: 'timestamp',
      description:
        'Date/time when the event originated.\nThis is the date/time extracted from the event, typically representing when the event was generated by the source.\nIf the event source has no original timestamp, this value is typically populated by the first time the event was received by the pipeline.\nRequired field for all events.',
      example: '2016-05-23T08:05:34.853Z',
      flat_name: '@timestamp',
      level: 'core',
      name: '@timestamp',
      normalize: [],
      short: 'Date/time when the event originated.',
      type: 'date',
      source: 'ecs',
    },
  },
};

const expectedResult = {
  activeAlertCount: 2,
  recoveredAlertCount: 20,
};

jest.mock('@kbn/kibana-react-plugin/public');

const fieldsMetadataClient = createFieldsMetadataClientMock();
fieldsMetadataClient.find.mockResolvedValue(mockedFieldsMetadataResponse);

const useFieldsMetadata = createUseFieldsMetadataHook({ fieldsMetadataClient });

describe('useFieldsMetadata', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // it('should return the mocked data from API', async () => {
  //   mockedPostAPI.mockResolvedValue(mockedFieldsMetadataResponse);

  //   const { result, waitForNextUpdate } = renderHook(() => useFieldsMetadata({ featureIds }));

  //   expect(result.current.loading).toBe(true);
  //   expect(result.current.alertsCount).toEqual(undefined);

  //   await waitForNextUpdate();

  //   const { alertsCount, loading, error } = result.current;
  //   expect(alertsCount).toEqual(expectedResult);
  //   expect(loading).toBeFalsy();
  //   expect(error).toBeFalsy();
  // });

  // it('should call API with correct input', async () => {
  //   const ruleId = 'c95bc120-1d56-11ed-9cc7-e7214ada1128';
  //   const query = {
  //     term: {
  //       'kibana.alert.rule.uuid': ruleId,
  //     },
  //   };
  //   mockedPostAPI.mockResolvedValue(mockedFieldsMetadataResponse);

  //   const { waitForNextUpdate } = renderHook(() =>
  //     useFieldsMetadata({
  //       featureIds,
  //       query,
  //     })
  //   );

  //   await waitForNextUpdate();

  //   const body = JSON.stringify({
  //     aggs: {
  //       count: {
  //         terms: { field: ALERT_STATUS },
  //       },
  //     },
  //     feature_ids: featureIds,
  //     query,
  //     size: 0,
  //   });

  //   expect(mockedPostAPI).toHaveBeenCalledWith(
  //     FIND_FIELDS_METADATA_URL,
  //     expect.objectContaining({ body })
  //   );
  // });

  // it('should return error if API call fails', async () => {
  //   const error = new Error('Fetch Alerts Count Failed');
  //   mockedPostAPI.mockRejectedValueOnce(error);

  //   const { result, waitForNextUpdate } = renderHook(() => useFieldsMetadata({ featureIds }));

  //   await waitForNextUpdate();

  //   expect(result.current.error?.message).toMatch(error.message);
  // });
});
