/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
import { FieldMetadata, TEcsFields, TMetadataFields } from '../../../common';
import { loggerMock } from '@kbn/logging-mocks';
import { FieldsMetadataClient } from './fields_metadata_client';
import { EcsFieldsRepository } from './repositories/ecs_fields_repository';
import { IntegrationFieldsRepository } from './repositories/integration_fields_repository';
import { MetadataFieldsRepository } from './repositories/metadata_fields_repository';

const ecsFields = {
  '@timestamp': {
    dashed_name: 'timestamp',
    description:
      'Date/time when the event originated.\nThis is the date/time extracted from the event, typically representing when the event was generated by the source.\nIf the event source has no original timestamp, this value is typically populated by the first time the event was received by the pipeline.\nRequired field for all events.',
    example: '2016-05-23T08:05:34.853Z',
    flat_name: '@timestamp',
    level: 'core',
    name: '@timestamp',
    normalize: [],
    required: !0,
    short: 'Date/time when the event originated.',
    type: 'date',
  },
} as TEcsFields;

const metadataFields = {
  _index: {
    dashed_name: 'index',
    description:
      'The index to which the document belongs. This metadata field specifies the exact index name in which the document is stored.',
    example: 'index_1',
    flat_name: '_index',
    name: '_index',
    short: 'The index to which the document belongs.',
    type: 'keyword',
    documentation_url:
      'https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-index-field.html',
  },
} as TMetadataFields;

const integrationFields = {
  '1password.item_usages': {
    'onepassword.client.platform_version': {
      name: 'platform_version',
      type: 'keyword',
      description:
        'The version of the browser or computer where the 1Password app is installed, or the CPU of the machine where the 1Password command-line tool is installed',
      flat_name: 'onepassword.client.platform_version',
      source: 'integration',
      dashed_name: 'onepassword-client-platform_version',
      normalize: [],
      short:
        'The version of the browser or computer where the 1Password app is installed, or the CPU of the machine where the 1Password command-line tool is installed',
    },
  },
  'mysql.slowlog': {
    'mysql.slowlog.filesort': {
      name: 'filesort',
      type: 'boolean',
      description: 'Whether filesort optimization was used.',
      flat_name: 'mysql.slowlog.filesort',
      source: 'integration',
      dashed_name: 'mysql-slowlog-filesort',
      normalize: [],
      short: 'Whether filesort optimization was used.',
    },
  },
};

describe('FieldsMetadataClient class', () => {
  const logger = loggerMock.create();
  const ecsFieldsRepository = EcsFieldsRepository.create({ ecsFields });
  const metadataFieldsRepository = MetadataFieldsRepository.create({ metadataFields });
  const integrationFieldsExtractor = jest.fn();
  const integrationListExtractor = jest.fn();
  integrationFieldsExtractor.mockImplementation(() => Promise.resolve(integrationFields));
  integrationListExtractor.mockImplementation(() =>
    Promise.resolve([
      {
        id: '1password',
        name: '1password',
        version: '1.0.0',
      },
      {
        id: 'mysql',
        name: 'mysql',
        version: '1.0.0',
      },
    ])
  );

  let integrationFieldsRepository: IntegrationFieldsRepository;
  let fieldsMetadataClient: FieldsMetadataClient;

  beforeEach(() => {
    integrationFieldsExtractor.mockClear();
    integrationFieldsRepository = IntegrationFieldsRepository.create({
      integrationFieldsExtractor,
      integrationListExtractor,
    });
    fieldsMetadataClient = FieldsMetadataClient.create({
      ecsFieldsRepository,
      integrationFieldsRepository,
      metadataFieldsRepository,
      logger,
    });
  });

  describe('#getByName', () => {
    it('should resolve a single ECS/Metadata FieldMetadata instance by default', async () => {
      const timestampFieldInstance = await fieldsMetadataClient.getByName('@timestamp');

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();

      expectToBeDefined(timestampFieldInstance);
      expect(timestampFieldInstance).toBeInstanceOf(FieldMetadata);

      const timestampField = timestampFieldInstance.toPlain();

      expect(Object.hasOwn(timestampField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'description')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'example')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'level')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'required')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'short')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'type')).toBeTruthy();
    });

    it('should attempt resolving the field from an integration if it does not exist in ECS/Metadata by inferring the integration from the field name', async () => {
      const mysqlFieldInstance = await fieldsMetadataClient.getByName('mysql.slowlog.filesort');

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      expectToBeDefined(mysqlFieldInstance);
      expect(mysqlFieldInstance).toBeInstanceOf(FieldMetadata);

      const mysqlField = mysqlFieldInstance.toPlain();

      expect(Object.hasOwn(mysqlField, 'name')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'type')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'description')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'source')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'short')).toBeTruthy();
    });

    it('should attempt resolving the field from an integration if it does not exist in ECS/Metadata and the integration and dataset params are provided', async () => {
      const onePasswordFieldInstance = await fieldsMetadataClient.getByName(
        'onepassword.client.platform_version',
        { integration: '1password', dataset: '1password.item_usages' }
      );

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      expectToBeDefined(onePasswordFieldInstance);
      expect(onePasswordFieldInstance).toBeInstanceOf(FieldMetadata);

      const onePasswordField = onePasswordFieldInstance.toPlain();

      expect(Object.hasOwn(onePasswordField, 'name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'type')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'description')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'source')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'short')).toBeTruthy();
    });

    it('should not resolve the field from an integration if the integration name cannot be inferred from the field name and integration and dataset params are not provided', async () => {
      const unknownFieldInstance = await fieldsMetadataClient.getByName(
        'customField.duration.milliseconds'
      );

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();
      expect(unknownFieldInstance).toBeUndefined();
    });
  });

  describe('#find', () => {
    it('should resolve a FieldsMetadataDictionary of matching fields', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp'],
      });

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
    });

    it('should resolve a FieldsMetadataDictionary of matching fields, including integration fields when integration and dataset params are provided', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', 'onepassword.client.platform_version'],
        integration: '1password',
        dataset: '1password.item_usages',
      });

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
      expect(Object.hasOwn(fields, 'onepassword.client.platform_version')).toBeTruthy();
    });

    it('should resolve a FieldsMetadataDictionary of matching fields, skipping unmatched fields', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', 'onepassword.client.platform_version', 'not-existing-field'],
        integration: '1password',
        dataset: '1password.item_usages',
      });

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
      expect(Object.hasOwn(fields, 'onepassword.client.platform_version')).toBeTruthy();
      expect(Object.hasOwn(fields, 'not-existing-field')).toBeFalsy();
    });
  });
});

function expectToBeDefined<T>(value: T | undefined): asserts value is T {
  expect(value).toBeDefined();
}
