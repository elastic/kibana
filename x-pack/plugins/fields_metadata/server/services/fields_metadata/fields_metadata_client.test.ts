/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
import { FieldMetadata, TEcsFields, TMetadataFields } from '../../../common';
import { loggerMock } from '@kbn/logging-mocks';
import { FieldsMetadataClient } from './fields_metadata_client';
import { EcsFieldsRepository } from './repositories/ecs_fields_repository';
import { IntegrationFieldsRepository } from './repositories/integration_fields_repository';
import { MetadataFieldsRepository } from './repositories/metadata_fields_repository';

const ecsFields = {
  '@timestamp': {
    dashed_name: 'timestamp',
    description:
      'Date/time when the event originated.\nThis is the date/time extracted from the event, typically representing when the event was generated by the source.\nIf the event source has no original timestamp, this value is typically populated by the first time the event was received by the pipeline.\nRequired field for all events.',
    example: '2016-05-23T08:05:34.853Z',
    flat_name: '@timestamp',
    level: 'core',
    name: '@timestamp',
    normalize: [],
    required: !0,
    short: 'Date/time when the event originated.',
    type: 'date',
  },
} as TEcsFields;

const metadataFields = {
  _index: {
    dashed_name: 'index',
    description:
      'The index to which the document belongs. This metadata field specifies the exact index name in which the document is stored.',
    example: 'index_1',
    flat_name: '_index',
    name: '_index',
    short: 'The index to which the document belongs.',
    type: 'keyword',
    documentation_url:
      'https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-index-field.html',
  },
} as TMetadataFields;

const integrationFields = {
  '1password.item_usages': {
    'onepassword.client.platform_version': {
      name: 'platform_version',
      type: 'keyword',
      description:
        'The version of the browser or computer where the 1Password app is installed, or the CPU of the machine where the 1Password command-line tool is installed',
      flat_name: 'onepassword.client.platform_version',
      source: 'integration',
      dashed_name: 'onepassword-client-platform_version',
      normalize: [],
      short:
        'The version of the browser or computer where the 1Password app is installed, or the CPU of the machine where the 1Password command-line tool is installed',
    },
  },
};

describe('FieldsMetadataClient class', () => {
  const logger = loggerMock.create();
  const ecsFieldsRepository = EcsFieldsRepository.create({ ecsFields });
  const metadataFieldsRepository = MetadataFieldsRepository.create({ metadataFields });
  const integrationFieldsExtractor = jest.fn();
  integrationFieldsExtractor.mockImplementation(() => Promise.resolve(integrationFields));

  let integrationFieldsRepository: IntegrationFieldsRepository;
  let fieldsMetadataClient: FieldsMetadataClient;

  beforeEach(() => {
    integrationFieldsExtractor.mockClear();
    integrationFieldsRepository = IntegrationFieldsRepository.create({
      integrationFieldsExtractor,
    });
    fieldsMetadataClient = FieldsMetadataClient.create({
      ecsFieldsRepository,
      integrationFieldsRepository,
      metadataFieldsRepository,
      logger,
    });
  });

  describe('#getByName', () => {
    it('should resolve a single ECS/Metadata FieldMetadata instance by default', async () => {
      const timestampFieldInstance = await fieldsMetadataClient.getByName('@timestamp');

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();

      expectToBeDefined(timestampFieldInstance);
      expect(timestampFieldInstance).toBeInstanceOf(FieldMetadata);

      const timestampField = timestampFieldInstance.toPlain();

      expect(Object.hasOwn(timestampField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'description')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'example')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'level')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'required')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'short')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'type')).toBeTruthy();
    });

    it('should attempt resolving the field from an integration if it does not exist in ECS/Metadata and the integration and dataset params are provided', async () => {
      const onePasswordFieldInstance = await fieldsMetadataClient.getByName(
        'onepassword.client.platform_version',
        { integration: '1password', dataset: '1password.item_usages' }
      );

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      expectToBeDefined(onePasswordFieldInstance);
      expect(onePasswordFieldInstance).toBeInstanceOf(FieldMetadata);

      const onePasswordField = onePasswordFieldInstance.toPlain();

      expect(Object.hasOwn(onePasswordField, 'name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'type')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'description')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'source')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'short')).toBeTruthy();
    });

    it('should not resolve the field from an integration if the integration and dataset params are not provided', async () => {
      const onePasswordFieldInstance = await fieldsMetadataClient.getByName(
        'onepassword.client.platform_version'
      );

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();
      expect(onePasswordFieldInstance).toBeUndefined();
    });
  });

  describe('#find', () => {
    it('should resolve a FieldsMetadataDictionary of matching fields', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp'],
      });

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
    });

    it('should resolve a FieldsMetadataDictionary of matching fields, including integration fields when integration and dataset params are provided', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', 'onepassword.client.platform_version'],
        integration: '1password',
        dataset: '1password.item_usages',
      });

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
      expect(Object.hasOwn(fields, 'onepassword.client.platform_version')).toBeTruthy();
    });

    it('should resolve a FieldsMetadataDictionary of matching fields, skipping unmatched fields', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', 'onepassword.client.platform_version', 'not-existing-field'],
        integration: '1password',
        dataset: '1password.item_usages',
      });

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
      expect(Object.hasOwn(fields, 'onepassword.client.platform_version')).toBeTruthy();
      expect(Object.hasOwn(fields, 'not-existing-field')).toBeFalsy();
    });
  });
});

function expectToBeDefined<T>(value: T | undefined): asserts value is T {
  expect(value).toBeDefined();
}
