/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { HttpSetup } from '@kbn/core/public';
import { i18n } from '@kbn/i18n';
import {
  CspVulnerabilityFinding,
  LATEST_VULNERABILITIES_RETENTION_POLICY,
  VULNERABILITIES_SEVERITY,
} from '@kbn/cloud-security-posture-common';
import type { Vulnerability } from '@kbn/cloud-security-posture-common/schema/vulnerabilities/latest';
import { CSP_VULN_DATASET } from '../../../common/utils/get_vendor_name';
import { isNativeCspFinding } from '../../../common/utils/is_native_csp_finding';
import { VULNERABILITIES_INDEX_PATTERN } from '../../../../common/constants';
import { createDetectionRule } from '../../../common/api/create_detection_rule';

const DEFAULT_RULE_RISK_SCORE = 0;
const DEFAULT_RULE_SEVERITY = 'low';
const DEFAULT_RULE_ENABLED = true;
const DEFAULT_RULE_AUTHOR = 'Elastic';
const DEFAULT_RULE_LICENSE = 'Elastic License v2';
const DEFAULT_MAX_ALERTS_PER_RULE = 100;
const ALERT_SUPPRESSION_FIELD = 'resource.id';
const ALERT_TIMESTAMP_FIELD = 'event.ingested';
const ALERT_SEVERITY_MAP_FIELD = 'vulnerability.severity';
const DEFAULT_INVESTIGATION_FIELDS = {
  field_names: ['resource.name', 'resource.id'],
};

enum RuleSeverityMapping {
  Low = 'low',
  Medium = 'medium',
  High = 'high',
  Critical = 'critical',
}

enum AlertSuppressionMissingFieldsStrategy {
  // per each document a separate alert will be created
  DoNotSuppress = 'doNotSuppress',
  // only one alert will be created per suppress by bucket
  Suppress = 'suppress',
}

export const getVulnerabilityRuleName = (vulnerability: Vulnerability) => {
  return i18n.translate('xpack.csp.vulnerabilities.detectionRuleNamePrefix', {
    defaultMessage: 'Vulnerability: {vulnerabilityId}',
    values: {
      vulnerabilityId: vulnerability.id,
    },
  });
};

export const generateVulnerabilitiesRuleQuery = (
  vulnerability: Vulnerability,
  startTimestamp = new Date().toISOString()
) => {
  return `vulnerability.id: "${vulnerability.id}" AND event.ingested >= "${startTimestamp}"`;
};

const CSP_RULE_TAG = 'Cloud Security';
const CNVM_TAG = 'CNVM';
const CNVM_RULE_TAG_DATA_SOURCE = 'Data Source: Cloud Native Vulnerability Management';
const CNVM_RULE_TAG_USE_CASE = 'Use Case: Vulnerability';
const CNVM_RULE_TAG_OS = 'OS: Linux';

export const getVulnerabilityTags = (vulnerabilityFinding: CspVulnerabilityFinding) => {
  let tags = [vulnerabilityFinding.vulnerability.id];
  const vendor =
    vulnerabilityFinding.observer?.vendor || vulnerabilityFinding?.data_stream?.dataset;

  if (isNativeCspFinding(vulnerabilityFinding)) {
    tags = [CNVM_TAG, CNVM_RULE_TAG_DATA_SOURCE, CNVM_RULE_TAG_USE_CASE, CNVM_RULE_TAG_OS, ...tags];
  } else if (!!vendor) {
    tags.push(vendor);
  }

  return [CSP_RULE_TAG, ...tags];
};

/*
 * Creates a detection rule from a Vulnerability
 */
export const createDetectionRuleFromVulnerabilityFinding = async (
  http: HttpSetup,
  vulnerabilityFinding: CspVulnerabilityFinding
) => {
  if (vulnerabilityFinding.data_stream?.dataset !== CSP_VULN_DATASET) {
    throw new Error(
      i18n.translate(
        'xpack.csp.createDetectionRuleFromVulnerabilityFinding.createRuleErrorMessage',
        { defaultMessage: 'Rule creation is currently only available for Elastic findings' }
      )
    );
  }

  const tags = getVulnerabilityTags(vulnerabilityFinding);
  const vulnerability = vulnerabilityFinding.vulnerability;

  return await createDetectionRule({
    http,
    rule: {
      type: 'query',
      language: 'kuery',
      license: DEFAULT_RULE_LICENSE,
      author: [DEFAULT_RULE_AUTHOR],
      filters: [],
      false_positives: [],
      risk_score: DEFAULT_RULE_RISK_SCORE,
      risk_score_mapping: [],
      severity: DEFAULT_RULE_SEVERITY,
      severity_mapping: [
        {
          field: ALERT_SEVERITY_MAP_FIELD,
          value: VULNERABILITIES_SEVERITY.LOW,
          operator: 'equals',
          severity: RuleSeverityMapping.Low,
        },
        {
          field: ALERT_SEVERITY_MAP_FIELD,
          value: VULNERABILITIES_SEVERITY.MEDIUM,
          operator: 'equals',
          severity: RuleSeverityMapping.Medium,
        },
        {
          field: ALERT_SEVERITY_MAP_FIELD,
          value: VULNERABILITIES_SEVERITY.HIGH,
          operator: 'equals',
          severity: RuleSeverityMapping.High,
        },
        {
          field: ALERT_SEVERITY_MAP_FIELD,
          value: VULNERABILITIES_SEVERITY.CRITICAL,
          operator: 'equals',
          severity: RuleSeverityMapping.Critical,
        },
        {
          field: ALERT_SEVERITY_MAP_FIELD,
          value: VULNERABILITIES_SEVERITY.UNKNOWN,
          operator: 'equals',
          severity: RuleSeverityMapping.Low,
        },
      ],
      threat: [],
      interval: '1h',
      from: `now-${LATEST_VULNERABILITIES_RETENTION_POLICY}`,
      to: 'now',
      max_signals: DEFAULT_MAX_ALERTS_PER_RULE,
      timestamp_override: ALERT_TIMESTAMP_FIELD,
      timestamp_override_fallback_disabled: false,
      actions: [],
      enabled: DEFAULT_RULE_ENABLED,
      alert_suppression: {
        group_by: [ALERT_SUPPRESSION_FIELD],
        missing_fields_strategy: AlertSuppressionMissingFieldsStrategy.Suppress,
      },
      index: [VULNERABILITIES_INDEX_PATTERN],
      query: generateVulnerabilitiesRuleQuery(vulnerability),
      references: vulnerability.reference ? [vulnerability.reference] : [],
      name: getVulnerabilityRuleName(vulnerability),
      description: vulnerability.description,
      tags,
      investigation_fields: DEFAULT_INVESTIGATION_FIELDS,
    },
  });
};
