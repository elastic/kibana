/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import nodeCrypto from '@elastic/node-crypto';
import crypto from 'crypto';

import type { PublicMethodsOf } from '@kbn/utility-types';
import { httpServerMock, loggingSystemMock } from 'src/core/server/mocks';

import { mockAuthenticatedUser } from '../../common/model/authenticated_user.mock';
import { ConfigSchema, createConfig } from '../config';
import { sessionCookieMock, sessionIndexMock, sessionMock } from './index.mock';
import type { SessionValueContentToEncrypt } from './session';
import { Session } from './session';
import type { SessionCookie } from './session_cookie';
import type { SessionIndex } from './session_index';

describe('Session', () => {
  const now = 123456;
  const mockEncryptionKey = 'a'.repeat(32);
  const encryptContent = (contentToEncrypt: SessionValueContentToEncrypt, aad: string) =>
    nodeCrypto({ encryptionKey: mockEncryptionKey }).encrypt(JSON.stringify(contentToEncrypt), aad);

  let mockSessionIndex: jest.Mocked<PublicMethodsOf<SessionIndex>>;
  let mockSessionCookie: jest.Mocked<PublicMethodsOf<SessionCookie>>;
  let session: Session;
  beforeEach(() => {
    jest.spyOn(Date, 'now').mockImplementation(() => now);

    let callCount = 0;
    jest.spyOn(crypto, 'randomBytes').mockImplementation((num, callback) => {
      // We still need _some_ randomness here to distinguish generated bytes for SID and AAD.
      const buffer = Buffer.from([++callCount, ...Array(num - 1).keys()]);
      if (typeof callback !== 'function') {
        return buffer;
      }
      callback(null, buffer);
    });

    mockSessionCookie = sessionCookieMock.create();
    mockSessionIndex = sessionIndexMock.create();

    session = new Session({
      logger: loggingSystemMock.createLogger(),
      config: createConfig(
        ConfigSchema.validate({
          encryptionKey: mockEncryptionKey,
          session: { idleTimeout: 123, lifespan: 456 },
        }),
        loggingSystemMock.createLogger(),
        { isTLSEnabled: false }
      ),
      sessionCookie: mockSessionCookie,
      sessionIndex: mockSessionIndex,
    });
  });

  describe('#getSID', () => {
    const mockRequest = httpServerMock.createKibanaRequest();

    it('returns `undefined` if session cookie does not exist', async () => {
      mockSessionCookie.get.mockResolvedValue(null);
      await expect(session.getSID(mockRequest)).resolves.toBeUndefined();
    });

    it('returns session id', async () => {
      mockSessionCookie.get.mockResolvedValue(sessionCookieMock.createValue());
      await expect(session.getSID(mockRequest)).resolves.toEqual('some-long-sid');
    });
  });

  describe('#get', () => {
    const mockAAD = Buffer.from([2, ...Array(255).keys()]).toString('base64');

    it('returns `null` if session cookie does not exist', async () => {
      mockSessionCookie.get.mockResolvedValue(null);
      mockSessionIndex.get.mockResolvedValue(
        sessionIndexMock.createValue({
          content: await encryptContent({ username: 'some-user', state: 'some-state' }, mockAAD),
        })
      );

      await expect(session.get(httpServerMock.createKibanaRequest())).resolves.toBeNull();
    });

    it('clears session value if session is expired because of idle timeout', async () => {
      mockSessionCookie.get.mockResolvedValue(
        sessionCookieMock.createValue({
          aad: mockAAD,
          idleTimeoutExpiration: now - 1,
          lifespanExpiration: now + 1,
        })
      );
      mockSessionIndex.get.mockResolvedValue(
        sessionIndexMock.createValue({
          content: await encryptContent({ username: 'some-user', state: 'some-state' }, mockAAD),
        })
      );

      await expect(session.get(httpServerMock.createKibanaRequest())).resolves.toBeNull();
      expect(mockSessionCookie.clear).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.invalidate).toHaveBeenCalledTimes(1);
    });

    it('clears session value if session is expired because of lifespan', async () => {
      mockSessionCookie.get.mockResolvedValue(
        sessionCookieMock.createValue({
          aad: mockAAD,
          idleTimeoutExpiration: now + 1,
          lifespanExpiration: now - 1,
        })
      );
      mockSessionIndex.get.mockResolvedValue(
        sessionIndexMock.createValue({
          content: await encryptContent({ username: 'some-user', state: 'some-state' }, mockAAD),
        })
      );

      await expect(session.get(httpServerMock.createKibanaRequest())).resolves.toBeNull();
      expect(mockSessionCookie.clear).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.invalidate).toHaveBeenCalledTimes(1);
    });

    it('clears session value if session cookie does not have corresponding session index value', async () => {
      mockSessionCookie.get.mockResolvedValue(
        sessionCookieMock.createValue({
          aad: mockAAD,
          idleTimeoutExpiration: now + 1,
          lifespanExpiration: now + 1,
        })
      );
      mockSessionIndex.get.mockResolvedValue(null);

      await expect(session.get(httpServerMock.createKibanaRequest())).resolves.toBeNull();
      expect(mockSessionCookie.clear).toHaveBeenCalledTimes(1);
    });

    it('clears session value if session index value content cannot be decrypted', async () => {
      mockSessionCookie.get.mockResolvedValue(
        sessionCookieMock.createValue({
          aad: mockAAD,
          idleTimeoutExpiration: now + 1,
          lifespanExpiration: now + 1,
        })
      );
      mockSessionIndex.get.mockResolvedValue(sessionIndexMock.createValue({ content: 'Uh! Oh!' }));

      await expect(session.get(httpServerMock.createKibanaRequest())).resolves.toBeNull();
      expect(mockSessionCookie.clear).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.invalidate).toHaveBeenCalledTimes(1);
    });

    it('clears session value if session index value content cannot be decrypted because of wrong AAD', async () => {
      mockSessionCookie.get.mockResolvedValue(
        sessionCookieMock.createValue({
          aad: 'some-wrong-aad',
          idleTimeoutExpiration: now + 1,
          lifespanExpiration: now + 1,
        })
      );
      mockSessionIndex.get.mockResolvedValue(
        sessionIndexMock.createValue({
          content: await encryptContent({ username: 'some-user', state: 'some-state' }, mockAAD),
        })
      );

      await expect(session.get(httpServerMock.createKibanaRequest())).resolves.toBeNull();
      expect(mockSessionCookie.clear).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.invalidate).toHaveBeenCalledTimes(1);
    });

    it('returns session value with decrypted content', async () => {
      mockSessionCookie.get.mockResolvedValue(
        sessionCookieMock.createValue({
          aad: mockAAD,
          idleTimeoutExpiration: now + 1,
          lifespanExpiration: now + 1,
        })
      );

      const mockSessionIndexValue = sessionIndexMock.createValue({
        idleTimeoutExpiration: now - 1,
        lifespanExpiration: now + 1,
        content: await encryptContent({ username: 'some-user', state: 'some-state' }, mockAAD),
      });
      mockSessionIndex.get.mockResolvedValue(mockSessionIndexValue);

      await expect(session.get(httpServerMock.createKibanaRequest())).resolves.toEqual({
        idleTimeoutExpiration: now + 1,
        lifespanExpiration: now + 1,
        metadata: { index: mockSessionIndexValue },
        provider: { name: 'basic1', type: 'basic' },
        sid: 'some-long-sid',
        state: 'some-state',
        username: 'some-user',
      });
      expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
    });
  });

  describe('#create', () => {
    it('creates session value', async () => {
      const mockSID = Buffer.from([1, ...Array(31).keys()]).toString('base64');
      const mockAAD = Buffer.from([2, ...Array(31).keys()]).toString('base64');

      const mockSessionIndexValue = sessionIndexMock.createValue({
        sid: mockSID,
        idleTimeoutExpiration: now + 123,
        lifespanExpiration: now + 456,
      });
      mockSessionIndex.create.mockResolvedValue(mockSessionIndexValue);

      const mockRequest = httpServerMock.createKibanaRequest();
      await expect(
        session.create(mockRequest, {
          username: mockAuthenticatedUser().username,
          provider: { type: 'basic', name: 'basic1' },
          state: 'some-state',
        })
      ).resolves.toEqual({
        sid: mockSID,
        username: 'user',
        state: 'some-state',
        provider: { name: 'basic1', type: 'basic' },
        idleTimeoutExpiration: now + 123,
        lifespanExpiration: now + 456,
        metadata: { index: mockSessionIndexValue },
      });

      // Properly creates session index value.
      expect(mockSessionIndex.create).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.create).toHaveBeenCalledWith({
        sid: mockSID,
        content:
          'AwABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9PgQAAQIDBAUGBwgJCpgMitlj6jACf9fYYa66WkuUpJsdgbWevIEfo6mN827f0lGcKDNPzN+vDMMPFetOkRITDI+NMz7e3JcMofnDboRnvg==',
        provider: { name: 'basic1', type: 'basic' },
        usernameHash: '8ac76453d769d4fd14b3f41ad4933f9bd64321972cd002de9b847e117435b08b',
        idleTimeoutExpiration: now + 123,
        lifespanExpiration: now + 456,
      });

      // Properly creates session cookie value.
      expect(mockSessionCookie.set).toHaveBeenCalledTimes(1);
      expect(mockSessionCookie.set).toHaveBeenCalledWith(mockRequest, {
        sid: mockSID,
        aad: mockAAD,
        idleTimeoutExpiration: now + 123,
        lifespanExpiration: now + 456,
      });
    });
  });

  describe('#update', () => {
    const mockAAD = Buffer.from([2, ...Array(255).keys()]).toString('base64');

    it('returns `null` if there is no corresponding session cookie value', async () => {
      mockSessionCookie.get.mockResolvedValue(null);
      // To make sure we aren't even calling this method.
      mockSessionIndex.update.mockResolvedValue(
        sessionIndexMock.createValue({
          content: await encryptContent({ username: 'some-user', state: 'some-state' }, mockAAD),
        })
      );

      await expect(
        session.update(httpServerMock.createKibanaRequest(), sessionMock.createValue())
      ).resolves.toBeNull();
    });

    it('returns `null` and clears cookie if there is no corresponding session index value', async () => {
      mockSessionCookie.get.mockResolvedValue(sessionCookieMock.createValue());
      mockSessionIndex.update.mockResolvedValue(null);

      const mockRequest = httpServerMock.createKibanaRequest();
      await expect(session.update(mockRequest, sessionMock.createValue())).resolves.toBeNull();

      expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
      expect(mockSessionCookie.clear).toHaveBeenCalledTimes(1);
      expect(mockSessionCookie.clear).toHaveBeenCalledWith(mockRequest);
    });

    it('updates session value', async () => {
      mockSessionCookie.get.mockResolvedValue(
        sessionCookieMock.createValue({
          aad: mockAAD,
          idleTimeoutExpiration: now + 1,
          lifespanExpiration: now + 1,
        })
      );

      const mockSessionIndexValue = sessionIndexMock.createValue({
        idleTimeoutExpiration: now + 123,
        lifespanExpiration: now + 1,
        metadata: { primaryTerm: 2, sequenceNumber: 2 },
      });
      mockSessionIndex.update.mockResolvedValue(mockSessionIndexValue);

      const mockRequest = httpServerMock.createKibanaRequest();
      await expect(
        session.update(
          mockRequest,
          sessionMock.createValue({
            username: 'new-user',
            state: 'new-state',
            idleTimeoutExpiration: now + 1,
            lifespanExpiration: now + 1,
          })
        )
      ).resolves.toEqual({
        sid: 'some-long-sid',
        username: 'new-user',
        state: 'new-state',
        provider: { name: 'basic1', type: 'basic' },
        idleTimeoutExpiration: now + 123,
        lifespanExpiration: now + 1,
        metadata: { index: mockSessionIndexValue },
      });

      // Properly updates session index value.
      expect(mockSessionIndex.update).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.update).toHaveBeenCalledWith({
        sid: 'some-long-sid',
        content:
          'AQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9PgIAAQIDBAUGBwgJCt8yPPMsaNAxn7qtLtc57UN967e9FpjmJgEIipe6nD20F47TtNIZnAuzd75zc8TNWvPMgRTzpHnYz7cT9m5ouv2V8TZ+ow==',
        provider: { name: 'basic1', type: 'basic' },
        usernameHash: '35133597af273830c3f139c72501e676338f28a39dca8ff62d5c2b8bfba75f69',
        idleTimeoutExpiration: now + 123,
        lifespanExpiration: now + 1,
        metadata: { primaryTerm: 1, sequenceNumber: 1 },
      });

      // Properly updates session cookie value.
      expect(mockSessionCookie.set).toHaveBeenCalledTimes(1);
      expect(mockSessionCookie.set).toHaveBeenCalledWith(mockRequest, {
        sid: 'some-long-sid',
        aad: mockAAD,
        path: '/mock-base-path',
        idleTimeoutExpiration: now + 123,
        lifespanExpiration: now + 1,
      });
    });

    it('properly extends session expiration if idle timeout is defined.', async () => {
      mockSessionCookie.get.mockResolvedValue(
        sessionCookieMock.createValue({ aad: mockAAD, idleTimeoutExpiration: now + 1 })
      );
      mockSessionIndex.update.mockResolvedValue(
        sessionIndexMock.createValue({
          idleTimeoutExpiration: now + 123,
        })
      );

      session = new Session({
        logger: loggingSystemMock.createLogger(),
        config: createConfig(
          ConfigSchema.validate({ session: { idleTimeout: 123 } }),
          loggingSystemMock.createLogger(),
          { isTLSEnabled: false }
        ),
        sessionCookie: mockSessionCookie,
        sessionIndex: mockSessionIndex,
      });

      const mockRequest = httpServerMock.createKibanaRequest();
      await expect(
        session.update(mockRequest, sessionMock.createValue({ idleTimeoutExpiration: now + 1 }))
      ).resolves.toEqual(
        expect.objectContaining({ idleTimeoutExpiration: now + 123, lifespanExpiration: null })
      );
      expect(mockSessionIndex.update).toHaveBeenCalledWith(
        expect.objectContaining({ idleTimeoutExpiration: now + 123, lifespanExpiration: null })
      );
      expect(mockSessionCookie.set).toHaveBeenCalledWith(
        mockRequest,
        expect.objectContaining({ idleTimeoutExpiration: now + 123, lifespanExpiration: null })
      );
    });

    describe('conditionally updates the session lifespan expiration', () => {
      const hr = 1000 * 60 * 60;
      async function updateSession(
        lifespan: number | null,
        oldExpiration: number | null,
        newExpiration: number | null
      ) {
        mockSessionCookie.get.mockResolvedValue(
          sessionCookieMock.createValue({ aad: mockAAD, lifespanExpiration: oldExpiration })
        );
        mockSessionIndex.update.mockResolvedValue(
          sessionIndexMock.createValue({ lifespanExpiration: newExpiration })
        );

        session = new Session({
          logger: loggingSystemMock.createLogger(),
          config: createConfig(
            ConfigSchema.validate({ session: { lifespan } }),
            loggingSystemMock.createLogger(),
            { isTLSEnabled: false }
          ),
          sessionCookie: mockSessionCookie,
          sessionIndex: mockSessionIndex,
        });

        const mockRequest = httpServerMock.createKibanaRequest();
        await expect(
          session.update(
            mockRequest,
            sessionMock.createValue({ lifespanExpiration: oldExpiration })
          )
        ).resolves.toEqual(
          expect.objectContaining({
            idleTimeoutExpiration: null,
            lifespanExpiration: newExpiration,
          })
        );
        expect(mockSessionIndex.update).toHaveBeenCalledWith(
          expect.objectContaining({
            idleTimeoutExpiration: null,
            lifespanExpiration: newExpiration,
          })
        );
        expect(mockSessionCookie.set).toHaveBeenCalledWith(
          mockRequest,
          expect.objectContaining({
            idleTimeoutExpiration: null,
            lifespanExpiration: newExpiration,
          })
        );

        expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
        expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      }

      it('does not change a non-null lifespan expiration when configured to non-null value.', async () => {
        await updateSession(hr * 8, 1234, 1234);
      });

      it('does not change a null lifespan expiration when configured to null value.', async () => {
        await updateSession(null, null, null);
      });

      it('does change a non-null lifespan expiration when configured to null value.', async () => {
        await updateSession(null, 1234, null);
      });

      it('does change a null lifespan expiration when configured to non-null value', async () => {
        await updateSession(hr * 8, null, now + hr * 8);
      });
    });
  });

  describe('#extend', () => {
    it('returns `null` if there is no corresponding session cookie value', async () => {
      mockSessionCookie.get.mockResolvedValue(null);

      await expect(
        session.extend(httpServerMock.createKibanaRequest(), sessionMock.createValue())
      ).resolves.toBeNull();

      expect(mockSessionCookie.set).not.toHaveBeenCalled();
      expect(mockSessionIndex.update).not.toHaveBeenCalled();
    });

    it('returns specified session unmodified if neither idle timeout nor lifespan is specified', async () => {
      mockSessionCookie.get.mockResolvedValue(sessionCookieMock.createValue());
      mockSessionIndex.update.mockResolvedValue(sessionIndexMock.createValue());

      session = new Session({
        logger: loggingSystemMock.createLogger(),
        config: createConfig(ConfigSchema.validate({}), loggingSystemMock.createLogger(), {
          isTLSEnabled: false,
        }),
        sessionCookie: mockSessionCookie,
        sessionIndex: mockSessionIndex,
      });

      const mockRequest = httpServerMock.createKibanaRequest();
      await expect(session.extend(mockRequest, sessionMock.createValue())).resolves.toEqual(
        sessionMock.createValue()
      );
      expect(mockSessionIndex.update).not.toHaveBeenCalled();
      expect(mockSessionCookie.set).not.toHaveBeenCalled();
      expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
      expect(mockSessionCookie.clear).not.toHaveBeenCalled();
    });

    it('properly extends session expiration if both idle timeout and lifespan are defined.', async () => {
      mockSessionCookie.get.mockResolvedValue(
        sessionCookieMock.createValue({
          idleTimeoutExpiration: now + 1,
          lifespanExpiration: now + 2,
        })
      );

      const mockRequest = httpServerMock.createKibanaRequest();
      await expect(
        session.extend(
          mockRequest,
          sessionMock.createValue({
            idleTimeoutExpiration: now + 1,
            lifespanExpiration: now + 2,
            metadata: {
              index: sessionIndexMock.createValue({
                idleTimeoutExpiration: now - 123,
                lifespanExpiration: now + 2,
              }),
            },
          })
        )
      ).resolves.toEqual(
        expect.objectContaining({ idleTimeoutExpiration: now + 123, lifespanExpiration: now + 2 })
      );
      expect(mockSessionIndex.update).not.toHaveBeenCalled();
      expect(mockSessionCookie.set).toHaveBeenCalledWith(
        mockRequest,
        expect.objectContaining({ idleTimeoutExpiration: now + 123, lifespanExpiration: now + 2 })
      );
    });

    describe('updates the session idle timeout expiration', () => {
      beforeEach(() => {
        session = new Session({
          logger: loggingSystemMock.createLogger(),
          config: createConfig(
            ConfigSchema.validate({ session: { idleTimeout: 123 } }),
            loggingSystemMock.createLogger(),
            { isTLSEnabled: false }
          ),
          sessionCookie: mockSessionCookie,
          sessionIndex: mockSessionIndex,
        });
      });

      it('does not update session index value if idle timeout is below threshold.', async () => {
        const expectedNewExpiration = now + 123;
        mockSessionCookie.get.mockResolvedValue(
          sessionCookieMock.createValue({ idleTimeoutExpiration: now + 1 })
        );

        const mockRequest = httpServerMock.createKibanaRequest();
        await expect(
          session.extend(
            mockRequest,
            sessionMock.createValue({
              idleTimeoutExpiration: expectedNewExpiration - 123,
              metadata: {
                index: sessionIndexMock.createValue({
                  idleTimeoutExpiration: expectedNewExpiration - 2 * 123,
                }),
              },
            })
          )
        ).resolves.toEqual(
          expect.objectContaining({ idleTimeoutExpiration: expectedNewExpiration })
        );
        expect(mockSessionIndex.update).not.toHaveBeenCalled();
        expect(mockSessionCookie.set).toHaveBeenCalledWith(
          mockRequest,
          expect.objectContaining({ idleTimeoutExpiration: expectedNewExpiration })
        );
        expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
        expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      });

      it('returns `null` and clears cookie if session index value does not exist.', async () => {
        const expectedNewExpiration = now + 123;
        mockSessionCookie.get.mockResolvedValue(
          sessionCookieMock.createValue({ idleTimeoutExpiration: now + 1 })
        );
        mockSessionIndex.update.mockResolvedValue(null);

        const mockRequest = httpServerMock.createKibanaRequest();
        await expect(
          session.extend(
            mockRequest,
            sessionMock.createValue({ idleTimeoutExpiration: expectedNewExpiration - 2 * 123 - 1 })
          )
        ).resolves.toBeNull();

        expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
        expect(mockSessionCookie.clear).toHaveBeenCalledTimes(1);
        expect(mockSessionCookie.clear).toHaveBeenCalledWith(mockRequest);
      });

      it('updates session index value if idle timeout exceeds threshold.', async () => {
        const expectedNewExpiration = now + 123;
        mockSessionCookie.get.mockResolvedValue(
          sessionCookieMock.createValue({ idleTimeoutExpiration: now + 1 })
        );

        const mockSessionIndexValue = sessionIndexMock.createValue({
          idleTimeoutExpiration: expectedNewExpiration,
          metadata: { primaryTerm: 2, sequenceNumber: 2 },
        });
        mockSessionIndex.update.mockResolvedValue(mockSessionIndexValue);

        const mockRequest = httpServerMock.createKibanaRequest();
        await expect(
          session.extend(
            mockRequest,
            sessionMock.createValue({
              idleTimeoutExpiration: expectedNewExpiration - 123,
              metadata: {
                index: sessionIndexMock.createValue({
                  idleTimeoutExpiration: expectedNewExpiration - 2 * 123 - 1,
                }),
              },
            })
          )
        ).resolves.toEqual(
          expect.objectContaining({
            idleTimeoutExpiration: expectedNewExpiration,
            metadata: { index: mockSessionIndexValue },
          })
        );
        expect(mockSessionIndex.update).toHaveBeenCalledWith(
          expect.objectContaining({ idleTimeoutExpiration: expectedNewExpiration })
        );
        expect(mockSessionCookie.set).toHaveBeenCalledWith(
          mockRequest,
          expect.objectContaining({ idleTimeoutExpiration: expectedNewExpiration })
        );
        expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
        expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      });

      it('updates session index value if idle timeout was not configured before.', async () => {
        const expectedNewExpiration = now + 123;
        mockSessionCookie.get.mockResolvedValue(sessionCookieMock.createValue());

        const mockSessionIndexValue = sessionIndexMock.createValue({
          idleTimeoutExpiration: expectedNewExpiration,
          metadata: { primaryTerm: 2, sequenceNumber: 2 },
        });
        mockSessionIndex.update.mockResolvedValue(mockSessionIndexValue);

        const mockRequest = httpServerMock.createKibanaRequest();
        await expect(session.extend(mockRequest, sessionMock.createValue())).resolves.toEqual(
          expect.objectContaining({
            idleTimeoutExpiration: expectedNewExpiration,
            metadata: { index: mockSessionIndexValue },
          })
        );
        expect(mockSessionIndex.update).toHaveBeenCalledWith(
          expect.objectContaining({ idleTimeoutExpiration: expectedNewExpiration })
        );
        expect(mockSessionCookie.set).toHaveBeenCalledWith(
          mockRequest,
          expect.objectContaining({ idleTimeoutExpiration: expectedNewExpiration })
        );
        expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
        expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      });

      it('updates session index value if idle timeout is not configured anymore.', async () => {
        const expectedNewExpiration = null;
        mockSessionCookie.get.mockResolvedValue(
          sessionCookieMock.createValue({ idleTimeoutExpiration: now + 1 })
        );

        const mockSessionIndexValue = sessionIndexMock.createValue({
          idleTimeoutExpiration: expectedNewExpiration,
          metadata: { primaryTerm: 2, sequenceNumber: 2 },
        });
        mockSessionIndex.update.mockResolvedValue(mockSessionIndexValue);

        session = new Session({
          logger: loggingSystemMock.createLogger(),
          config: createConfig(
            ConfigSchema.validate({ session: { idleTimeout: null } }),
            loggingSystemMock.createLogger(),
            { isTLSEnabled: false }
          ),
          sessionCookie: mockSessionCookie,
          sessionIndex: mockSessionIndex,
        });

        const mockRequest = httpServerMock.createKibanaRequest();
        await expect(
          session.extend(mockRequest, sessionMock.createValue({ idleTimeoutExpiration: now + 1 }))
        ).resolves.toEqual(
          expect.objectContaining({
            idleTimeoutExpiration: expectedNewExpiration,
            metadata: { index: mockSessionIndexValue },
          })
        );
        expect(mockSessionIndex.update).toHaveBeenCalledWith(
          expect.objectContaining({ idleTimeoutExpiration: expectedNewExpiration })
        );
        expect(mockSessionCookie.set).toHaveBeenCalledWith(
          mockRequest,
          expect.objectContaining({ idleTimeoutExpiration: expectedNewExpiration })
        );
        expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
        expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      });
    });

    describe('conditionally updates the session lifespan expiration', () => {
      const hr = 1000 * 60 * 60;
      async function updateSession(
        lifespan: number | null,
        oldExpiration: number | null,
        newExpiration: number | null
      ) {
        mockSessionCookie.get.mockResolvedValue(
          sessionCookieMock.createValue({ lifespanExpiration: oldExpiration })
        );
        mockSessionIndex.update.mockResolvedValue(
          sessionIndexMock.createValue({ lifespanExpiration: newExpiration })
        );

        session = new Session({
          logger: loggingSystemMock.createLogger(),
          config: createConfig(
            ConfigSchema.validate({ session: { lifespan } }),
            loggingSystemMock.createLogger(),
            { isTLSEnabled: false }
          ),
          sessionCookie: mockSessionCookie,
          sessionIndex: mockSessionIndex,
        });

        const mockRequest = httpServerMock.createKibanaRequest();
        await expect(
          session.extend(
            mockRequest,
            sessionMock.createValue({ lifespanExpiration: oldExpiration })
          )
        ).resolves.toEqual(
          expect.objectContaining({
            idleTimeoutExpiration: null,
            lifespanExpiration: newExpiration,
          })
        );

        if (oldExpiration === newExpiration) {
          expect(mockSessionIndex.update).not.toHaveBeenCalled();
          expect(mockSessionCookie.set).not.toHaveBeenCalled();
        } else {
          // We update session index only when lifespan configuration changes.
          if (oldExpiration === null || newExpiration === null) {
            expect(mockSessionIndex.update).toHaveBeenCalledWith(
              expect.objectContaining({
                idleTimeoutExpiration: null,
                lifespanExpiration: newExpiration,
              })
            );
          } else {
            expect(mockSessionIndex.update).not.toHaveBeenCalled();
          }

          expect(mockSessionCookie.set).toHaveBeenCalledWith(
            mockRequest,
            expect.objectContaining({
              idleTimeoutExpiration: null,
              lifespanExpiration: newExpiration,
            })
          );
        }

        expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
        expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      }

      it('does not change a non-null lifespan expiration when configured to non-null value.', async () => {
        await updateSession(hr * 8, 1234, 1234);
      });

      it('does not change a null lifespan expiration when configured to null value.', async () => {
        await updateSession(null, null, null);
      });

      it('does change a non-null lifespan expiration when configured to null value.', async () => {
        await updateSession(null, 1234, null);
      });

      it('does change a null lifespan expiration when configured to non-null value', async () => {
        await updateSession(hr * 8, null, now + hr * 8);
      });
    });
  });

  describe('#invalidate', () => {
    beforeEach(() => {
      mockSessionCookie.get.mockResolvedValue(sessionCookieMock.createValue());
      mockSessionIndex.invalidate.mockResolvedValue(10);
    });

    it('[match=current] does not clear anything if session does not exist', async () => {
      mockSessionCookie.get.mockResolvedValue(null);

      await session.invalidate(httpServerMock.createKibanaRequest(), { match: 'current' });

      expect(mockSessionIndex.invalidate).not.toHaveBeenCalled();
      expect(mockSessionCookie.clear).not.toHaveBeenCalled();
    });

    it('[match=current] clears both session cookie and session index', async () => {
      mockSessionCookie.get.mockResolvedValue(sessionCookieMock.createValue());

      const mockRequest = httpServerMock.createKibanaRequest();
      await session.invalidate(mockRequest, { match: 'current' });

      expect(mockSessionIndex.invalidate).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.invalidate).toHaveBeenCalledWith({
        match: 'sid',
        sid: 'some-long-sid',
      });

      expect(mockSessionCookie.clear).toHaveBeenCalledTimes(1);
      expect(mockSessionCookie.clear).toHaveBeenCalledWith(mockRequest);
    });

    it('[match=all] clears all sessions even if current initiator request does not have a session', async () => {
      mockSessionCookie.get.mockResolvedValue(null);

      await expect(
        session.invalidate(httpServerMock.createKibanaRequest(), { match: 'all' })
      ).resolves.toBe(10);

      expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      expect(mockSessionIndex.invalidate).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.invalidate).toHaveBeenCalledWith({ match: 'all' });
    });

    it('[match=query] properly forwards filter with the provider type to the session index', async () => {
      await expect(
        session.invalidate(httpServerMock.createKibanaRequest(), {
          match: 'query',
          query: { provider: { type: 'basic' } },
        })
      ).resolves.toBe(10);

      expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      expect(mockSessionIndex.invalidate).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.invalidate).toHaveBeenCalledWith({
        match: 'query',
        query: { provider: { type: 'basic' } },
      });
    });

    it('[match=query] properly forwards filter with the provider type and provider name to the session index', async () => {
      await expect(
        session.invalidate(httpServerMock.createKibanaRequest(), {
          match: 'query',
          query: { provider: { type: 'basic', name: 'basic1' } },
        })
      ).resolves.toBe(10);

      expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      expect(mockSessionIndex.invalidate).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.invalidate).toHaveBeenCalledWith({
        match: 'query',
        query: { provider: { type: 'basic', name: 'basic1' } },
      });
    });

    it('[match=query] properly forwards filter with the provider type, provider name, and username hash to the session index', async () => {
      await expect(
        session.invalidate(httpServerMock.createKibanaRequest(), {
          match: 'query',
          query: { provider: { type: 'basic', name: 'basic1' }, username: 'elastic' },
        })
      ).resolves.toBe(10);

      expect(mockSessionCookie.clear).not.toHaveBeenCalled();
      expect(mockSessionIndex.invalidate).toHaveBeenCalledTimes(1);
      expect(mockSessionIndex.invalidate).toHaveBeenCalledWith({
        match: 'query',
        query: {
          provider: { type: 'basic', name: 'basic1' },
          usernameHash: 'eb28536c8ead72bf81a0a9226e38fc9bad81f5e07c2081bb801b2a5c8842924e',
        },
      });
    });
  });
});
