/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
import { ALERT_REASON } from '@kbn/rule-data-utils';
import {
  generateFilterDSL,
  hasFilters,
  statusCheckAlertFactory,
  getStatusMessage,
  getUniqueIdsByLoc,
  getInstanceId,
} from './status_check';
import { GetMonitorStatusResult } from '../requests/get_monitor_status';
import { makePing } from '../../../../common/runtime_types/ping';
import { GetMonitorAvailabilityResult } from '../requests/get_monitor_availability';
import { DefaultUptimeAlertInstance } from './types';
import { createRuleTypeMocks, bootstrapDependencies } from './test_utils';
import moment from 'moment';

const mockMonitors = [
  {
    monitorId: 'first',
    location: 'harrisburg',
    count: 234,
    status: 'down',
    monitorInfo: {
      ...makePing({
        id: 'first',
        name: 'First',
        location: 'harrisburg',
        url: 'localhost:8080',
      }),
      error: {
        message: 'error message 1',
      },
    },
  },
  {
    monitorId: 'first',
    location: 'fairbanks',
    count: 234,
    status: 'down',
    monitorInfo: {
      ...makePing({
        id: 'first',
        name: 'First',
        location: 'fairbanks',
        url: 'localhost:5601',
      }),
      error: {
        message: 'error message 2',
      },
    },
  },
];

const mockRecoveredAlerts = [
  {
    alertDetailsUrl: 'mockedAlertsLocator > getLocation',
    currentTriggerStarted: '2022-04-25T14:36:31.511Z',
    firstCheckedAt: '2022-04-25T14:10:30.785Z',
    firstTriggeredAt: '2022-04-25T14:10:30.785Z',
    lastCheckedAt: '2022-04-25T14:36:31.511Z',
    lastTriggeredAt: '2022-04-25T14:36:31.511Z',
    lastResolvedAt: '2022-04-25T14:23:43.007Z',
    isTriggered: true,
    monitorUrl: 'https://expired.badssl.com/',
    monitorId: 'expired-badssl',
    monitorName: 'BadSSL Expired',
    monitorType: 'http',
    latestErrorMessage:
      'Get "https://expired.badssl.com/": x509: certificate has expired or is not yet valid: current time 2022-04-25T10:36:27-04:00 is after 2015-04-12T23:59:59Z',
    observerLocation: 'Unnamed-location',
    observerHostname: 'Dominiques-MacBook-Pro-2.local',
    reason:
      'BadSSL Expired from Unnamed-location failed 2 times in the last 3 mins. Alert when > 1.',
    statusMessage: 'failed 2 times in the last 3 mins. Alert when > 1.',
    start: '2022-04-25T14:36:31.621Z',
    duration: 315110000000,
  },
  {
    alertDetailsUrl: 'mockedAlertsLocator > getLocation',
    currentTriggerStarted: '2022-04-25T14:36:31.511Z',
    firstCheckedAt: '2022-04-25T14:10:30.785Z',
    firstTriggeredAt: '2022-04-25T14:10:30.785Z',
    lastCheckedAt: '2022-04-25T14:36:31.511Z',
    lastTriggeredAt: '2022-04-25T14:36:31.511Z',
    lastResolvedAt: '2022-04-25T14:23:43.007Z',
    isTriggered: true,
    monitorUrl: 'https://invalid.badssl.com/',
    monitorId: 'expired-badssl',
    monitorName: 'BadSSL Expired',
    monitorType: 'http',
    latestErrorMessage:
      'Get "https://invalid.badssl.com/": x509: certificate has expired or is not yet valid: current time 2022-04-25T10:36:27-04:00 is after 2015-04-12T23:59:59Z',
    observerLocation: 'Unnamed-location',
    observerHostname: 'Dominiques-MacBook-Pro-2.local',
    reason:
      'BadSSL Expired from Unnamed-location failed 2 times in the last 3 mins. Alert when > 1.',
    statusMessage: 'failed 2 times in the last 3 mins. Alert when > 1.',
    start: '2022-04-25T14:36:31.621Z',
    duration: 315110000000,
  },
];

const mockCommonAlertDocumentFields = (monitorInfo: GetMonitorStatusResult['monitorInfo']) => ({
  'agent.name': monitorInfo.agent?.name,
  'error.message': monitorInfo.error?.message,
  'monitor.id': monitorInfo.monitor.id,
  'monitor.name': monitorInfo.monitor.name || monitorInfo.monitor.id,
  'monitor.type': monitorInfo.monitor.type,
  'url.full': monitorInfo.url?.full,
  'observer.geo.name': monitorInfo.observer?.geo?.name
    ? [monitorInfo.observer.geo.name]
    : undefined,
});

const mockStatusAlertDocument = (
  monitor: GetMonitorStatusResult,
  isAutoGenerated: boolean = false,
  count: number,
  interval: string,
  numTimes: number,
  actionGroup: string
) => {
  const { monitorInfo } = monitor;
  const checkedAt = moment(monitorInfo.timestamp).format('LLL');

  return {
    payload: {
      ...mockCommonAlertDocumentFields(monitor.monitorInfo),
      [ALERT_REASON]: `Monitor "First" from ${monitor.monitorInfo.observer?.geo?.name} failed ${count} times in the last ${interval}. Alert when >= ${numTimes}. Checked at ${checkedAt}.`,
    },
    actionGroup,
    id: getInstanceId(
      monitorInfo,
      `${isAutoGenerated ? '' : monitorInfo?.monitor.id + '-'}${monitorInfo.observer?.geo?.name}`
    ),
    state: expect.any(Object),
  };
};

const mockAvailabilityAlertDocument = (monitor: GetMonitorAvailabilityResult) => {
  const { monitorInfo } = monitor;

  const checkedAt = moment(monitorInfo.timestamp).format('LLL');

  return {
    actionGroup: 'xpack.uptime.alerts.actionGroups.monitorStatus',
    payload: {
      ...mockCommonAlertDocumentFields(monitor.monitorInfo),
      [ALERT_REASON]: `Monitor "${monitorInfo.monitor.name || monitorInfo.monitor.id}" from ${
        monitorInfo.observer?.geo?.name
      } 35 days availability is ${(monitor.availabilityRatio! * 100).toFixed(
        2
      )}%. Alert when < 99.34%. Checked at ${checkedAt}.`,
    },
    state: expect.any(Object),
    id: getInstanceId(monitorInfo, `${monitorInfo?.monitor.id}-${monitorInfo.observer?.geo?.name}`),
  };
};

/**
 * This function aims to provide an easy way to give mock props that will
 * reduce boilerplate for tests.
 * @param params the params received at alert creation time
 * @param state the state the alert maintains
 */
const mockOptions = (
  params: any = {
    numTimes: 5,
    locations: [],
    timerange: { from: 'now-15m', to: 'now' },
    shouldCheckStatus: true,
  },
  state = {},
  rule = {
    schedule: {
      interval: '5m',
    },
  },
  recoveredAlerts: typeof mockRecoveredAlerts = []
): any => {
  const { services, setContext } = createRuleTypeMocks(mockRecoveredAlerts);

  services.alertsClient.report.mockImplementation((param: any) => {
    return {
      uuid: `uuid-${param.id}`,
      start: new Date().toISOString(),
      alertDoc: {},
    };
  });

  services.alertsClient.getRecoveredAlerts.mockImplementation((param: any) => {
    return recoveredAlerts.map((alert) => ({
      alert: {
        getId: () => 'mock-id',
        getUuid: () => 'mock-uuid',
        getState: () => alert,
        getStart: () => new Date().toISOString(),
        setContext,
        context: {},
      },
    }));
  });

  return {
    params,
    state,
    services,
    rule,
    setContext,
    startedAt: new Date(),
  };
};

describe('status check alert', () => {
  let toISOStringSpy: jest.SpyInstance<string, []>;
  const mockDate = new Date('2021-05-13T12:33:37.000Z');
  beforeEach(() => {
    toISOStringSpy = jest.spyOn(Date.prototype, 'toISOString');
    Date.now = jest.fn().mockReturnValue(mockDate);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('executor', () => {
    it('does not trigger when there are no monitors down', async () => {
      expect.assertions(5);
      const mockGetter = jest.fn();
      mockGetter.mockReturnValue([]);
      const { server, libs, plugins } = bootstrapDependencies({ getMonitorStatus: mockGetter });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      // @ts-ignore the executor can return `void`, but ours never does
      const options = mockOptions();
      const executorResult: Record<string, any> | void = await alert.executor(options);
      const {
        services: { alertWithLifecycle },
      } = options;

      expect(executorResult?.state).not.toBeUndefined();
      expect(
        executorResult?.state instanceof Object ? executorResult.state.isTriggered : true
      ).toBe(false);
      expect(alertWithLifecycle).not.toHaveBeenCalled();
      expect(mockGetter).toHaveBeenCalledTimes(1);
      expect(mockGetter.mock.calls[0][0]).toEqual(
        expect.objectContaining({
          filters: undefined,
          locations: [],
          numTimes: 5,
          timespanRange: {
            from: 'now-15m',
            to: 'now',
          },
          timestampRange: {
            from: 1620821917000,
            to: 'now',
          },
        })
      );
    });

    it('triggers when monitors are down and provides expected state', async () => {
      toISOStringSpy.mockImplementation(() => 'foo date string');
      const mockGetter: jest.Mock<GetMonitorStatusResult[]> = jest.fn();

      mockGetter.mockReturnValue(mockMonitors);
      const { server, libs, plugins } = bootstrapDependencies({ getMonitorStatus: mockGetter });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      const options = mockOptions({
        numTimes: 5,
        count: 234,
        timerangeUnit: 'm',
        timerangeCount: 15,
      });
      const {
        services: { alertsClient },
      } = options;
      // @ts-ignore the executor can return `void`, but ours never does
      const state: Record<string, any> = await alert.executor(options);
      expect(mockGetter).toHaveBeenCalledTimes(1);
      expect(alertsClient.report).toHaveBeenCalledTimes(2);
      mockMonitors.forEach((monitor) => {
        expect(alertsClient.report).toBeCalledWith(
          mockStatusAlertDocument(
            monitor,
            false,
            234,
            '15 mins',
            5,
            'xpack.uptime.alerts.actionGroups.monitorStatus'
          )
        );
      });

      expect(alertsClient.report).toHaveBeenNthCalledWith(
        1,
        expect.objectContaining({
          state: {
            checkedAt: 'July 6, 2020 9:14 PM',
            currentTriggerStarted: 'foo date string',
            firstCheckedAt: 'foo date string',
            firstTriggeredAt: 'foo date string',
            isTriggered: true,
            lastCheckedAt: 'foo date string',
            lastResolvedAt: undefined,
            lastTriggeredAt: 'foo date string',
            latestErrorMessage: 'error message 1',
            monitorId: 'first',
            monitorName: 'First',
            monitorType: 'myType',
            monitorUrl: 'localhost:8080',
            observerHostname: undefined,
            observerLocation: 'harrisburg',
            reason: `Monitor "First" from harrisburg failed 234 times in the last 15 mins. Alert when >= 5. Checked at July 6, 2020 9:14 PM.`,
            statusMessage: 'failed 234 times in the last 15 mins. Alert when >= 5.',
          },
        })
      );

      expect(alertsClient.report).toHaveBeenNthCalledWith(
        2,
        expect.objectContaining({
          state: {
            checkedAt: 'July 6, 2020 9:14 PM',
            currentTriggerStarted: 'foo date string',
            firstCheckedAt: 'foo date string',
            firstTriggeredAt: 'foo date string',
            isTriggered: true,
            lastCheckedAt: 'foo date string',
            lastResolvedAt: undefined,
            lastTriggeredAt: 'foo date string',
            latestErrorMessage: 'error message 2',
            monitorId: 'first',
            monitorName: 'First',
            monitorType: 'myType',
            monitorUrl: 'localhost:5601',
            observerHostname: undefined,
            observerLocation: 'fairbanks',
            reason:
              'Monitor "First" from fairbanks failed 234 times in the last 15 mins. Alert when >= 5. Checked at July 6, 2020 9:14 PM.',
            statusMessage: 'failed 234 times in the last 15 mins. Alert when >= 5.',
          },
        })
      );

      expect(mockGetter.mock.calls[0][0]).toEqual(
        expect.objectContaining({
          filters: undefined,
          locations: [],
          numTimes: 5,
          timespanRange: {
            from: 'now-15m',
            to: 'now',
          },
        })
      );

      expect(alertsClient.setAlertData).toHaveBeenNthCalledWith(1, {
        id: 'first_localhost_8080_first-harrisburg',
        context: {
          alertDetailsUrl: 'mockedAlertsLocator > getLocation',
          checkedAt: 'July 6, 2020 9:14 PM',
          latestErrorMessage: 'error message 1',
          monitorId: 'first',
          monitorName: 'First',
          monitorType: 'myType',
          monitorUrl: 'localhost:8080',
          observerHostname: undefined,
          observerLocation: 'harrisburg',
          reason: `Monitor "First" from harrisburg failed 234 times in the last 15 mins. Alert when >= 5. Checked at July 6, 2020 9:14 PM.`,
          statusMessage: 'failed 234 times in the last 15 mins. Alert when >= 5.',
          viewInAppUrl:
            'http://localhost:5601/hfe/app/uptime/monitor/Zmlyc3Q=?dateRangeEnd=now&dateRangeStart=foo%20date%20string&filters=%5B%5B%22observer.geo.name%22%2C%5B%22harrisburg%22%5D%5D%5D',
        },
      });
    });

    it('supports auto generated monitor status alerts', async () => {
      toISOStringSpy.mockImplementation(() => 'foo date string');
      const mockGetter: jest.Mock<GetMonitorStatusResult[]> = jest.fn();

      mockGetter.mockReturnValue(mockMonitors);
      const { server, libs, plugins } = bootstrapDependencies({ getMonitorStatus: mockGetter });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      const options = mockOptions({
        isAutoGenerated: true,
        timerange: { from: 'now-15m', to: 'now' },
        numTimes: 5,
      });
      const {
        services: { alertsClient },
      } = options;
      // @ts-ignore the executor can return `void`, but ours never does
      const state: Record<string, any> = await alert.executor(options);
      expect(mockGetter).toHaveBeenCalledTimes(1);
      expect(alertsClient.report).toHaveBeenCalledTimes(2);
      mockMonitors.forEach((monitor) => {
        expect(alertsClient.report).toBeCalledWith(
          mockStatusAlertDocument(
            monitor,
            true,
            234,
            '15m',
            5,
            'xpack.uptime.alerts.actionGroups.monitorStatus'
          )
        );
      });
      expect(mockGetter.mock.calls[0][0]).toEqual(
        expect.objectContaining({
          filters: undefined,
          locations: [],
          numTimes: 5,
          timespanRange: {
            from: 'now-15m',
            to: 'now',
          },
        })
      );

      expect(alertsClient.report).toHaveBeenNthCalledWith(
        1,
        expect.objectContaining({
          state: {
            checkedAt: 'July 6, 2020 9:14 PM',
            currentTriggerStarted: 'foo date string',
            firstCheckedAt: 'foo date string',
            firstTriggeredAt: 'foo date string',
            isTriggered: true,
            lastCheckedAt: 'foo date string',
            lastResolvedAt: undefined,
            lastTriggeredAt: 'foo date string',
            latestErrorMessage: 'error message 1',
            monitorId: 'first',
            monitorName: 'First',
            monitorType: 'myType',
            monitorUrl: 'localhost:8080',
            observerHostname: undefined,
            observerLocation: 'harrisburg',
            reason: `Monitor "First" from harrisburg failed 234 times in the last 15m. Alert when >= 5. Checked at July 6, 2020 9:14 PM.`,
            statusMessage: 'failed 234 times in the last 15m. Alert when >= 5.',
          },
        })
      );

      expect(alertsClient.setAlertData).toHaveBeenNthCalledWith(1, {
        id: 'first_localhost_8080_harrisburg',
        context: {
          alertDetailsUrl: 'mockedAlertsLocator > getLocation',
          checkedAt: 'July 6, 2020 9:14 PM',
          latestErrorMessage: 'error message 1',
          monitorId: 'first',
          monitorName: 'First',
          monitorType: 'myType',
          monitorUrl: 'localhost:8080',
          observerHostname: undefined,
          observerLocation: 'harrisburg',
          reason: `Monitor "First" from harrisburg failed 234 times in the last 15m. Alert when >= 5. Checked at July 6, 2020 9:14 PM.`,
          statusMessage: 'failed 234 times in the last 15m. Alert when >= 5.',
          viewInAppUrl:
            'http://localhost:5601/hfe/app/uptime/monitor/Zmlyc3Q=?dateRangeEnd=now&dateRangeStart=foo%20date%20string&filters=%5B%5B%22observer.geo.name%22%2C%5B%22harrisburg%22%5D%5D%5D',
        },
      });
    });

    it('supports 7.7 alert format', async () => {
      toISOStringSpy.mockImplementation(() => '7.7 date');
      const mockGetter: jest.Mock<GetMonitorStatusResult[]> = jest.fn();

      mockGetter.mockReturnValue(mockMonitors);
      const { server, libs, plugins } = bootstrapDependencies({
        getMonitorStatus: mockGetter,
        getIndexPattern: jest.fn(),
      });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      const options = mockOptions({
        numTimes: 4,
        timerange: { from: 'now-14h', to: 'now' },
        locations: ['fairbanks'],
        filters: '',
      });
      const {
        services: { alertsClient },
      } = options;
      const executorResult = await alert.executor(options);

      expect(alertsClient.report).toHaveBeenCalledTimes(2);

      expect(alertsClient.report).toHaveBeenNthCalledWith(
        1,
        expect.objectContaining({
          state: {
            checkedAt: 'July 6, 2020 9:14 PM',
            currentTriggerStarted: '7.7 date',
            firstCheckedAt: '7.7 date',
            firstTriggeredAt: '7.7 date',
            isTriggered: true,
            lastCheckedAt: '7.7 date',
            lastTriggeredAt: '7.7 date',
            latestErrorMessage: 'error message 1',
            monitorId: 'first',
            monitorName: 'First',
            monitorType: 'myType',
            monitorUrl: 'localhost:8080',
            observerLocation: 'harrisburg',
            reason:
              'Monitor "First" from harrisburg failed 234 times in the last 14h. Alert when >= 4. Checked at July 6, 2020 9:14 PM.',
            statusMessage: 'failed 234 times in the last 14h. Alert when >= 4.',
          },
        })
      );

      mockMonitors.forEach((monitor) => {
        expect(alertsClient.report).toBeCalledWith(
          mockStatusAlertDocument(
            monitor,
            false,
            234,
            '14h',
            4,
            'xpack.uptime.alerts.actionGroups.monitorStatus'
          )
        );
      });
      expect(alertsClient.setAlertData).toHaveBeenCalledTimes(2);
      expect(alertsClient.setAlertData.mock.calls[0]).toMatchInlineSnapshot(`
        Array [
          Object {
            "context": Object {
              "alertDetailsUrl": "mockedAlertsLocator > getLocation",
              "checkedAt": "July 6, 2020 9:14 PM",
              "configId": undefined,
              "latestErrorMessage": "error message 1",
              "monitorId": "first",
              "monitorName": "First",
              "monitorTags": undefined,
              "monitorType": "myType",
              "monitorUrl": "localhost:8080",
              "observerHostname": undefined,
              "observerLocation": "harrisburg",
              "observerName": undefined,
              "reason": "Monitor \\"First\\" from harrisburg failed 234 times in the last 14h. Alert when >= 4. Checked at July 6, 2020 9:14 PM.",
              "statusMessage": "failed 234 times in the last 14h. Alert when >= 4.",
              "viewInAppUrl": "http://localhost:5601/hfe/app/uptime/monitor/Zmlyc3Q=?dateRangeEnd=now&dateRangeStart=7.7%20date&filters=%5B%5B%22observer.geo.name%22%2C%5B%22harrisburg%22%5D%5D%5D",
            },
            "id": "first_localhost_8080_first-harrisburg",
          },
        ]
      `);
      expect(executorResult?.state).toMatchInlineSnapshot(`
        Object {
          "currentTriggerStarted": "7.7 date",
          "firstCheckedAt": "7.7 date",
          "firstTriggeredAt": "7.7 date",
          "isTriggered": true,
          "lastCheckedAt": "7.7 date",
          "lastResolvedAt": undefined,
          "lastTriggeredAt": "7.7 date",
        }
      `);
    });

    it('supports 7.8 alert format', async () => {
      expect.assertions(8);
      toISOStringSpy.mockImplementation(() => 'foo date string');
      const mockGetter: jest.Mock<GetMonitorStatusResult[]> = jest.fn();

      mockGetter.mockReturnValueOnce(mockMonitors);
      const { server, libs, plugins } = bootstrapDependencies({
        getMonitorStatus: mockGetter,
        getIndexPattern: jest.fn(),
      });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      const options = mockOptions({
        numTimes: 3,
        timerangeUnit: 'm',
        timerangeCount: 15,
        search: 'monitor.ip : * ',
        filters: {
          'url.port': ['12349', '5601', '443'],
          'observer.geo.name': ['harrisburg'],
          'monitor.type': ['http'],
          tags: ['unsecured', 'containers', 'org:google'],
        },
      });
      const executorResult = await alert.executor(options);
      const {
        services: { alertsClient },
      } = options;

      mockMonitors.forEach((monitor) => {
        expect(alertsClient.report).toBeCalledWith(
          mockStatusAlertDocument(
            monitor,
            false,
            234,
            '15 mins',
            3,
            'xpack.uptime.alerts.actionGroups.monitorStatus'
          )
        );
      });
      expect(mockGetter).toHaveBeenCalledTimes(1);
      expect(mockGetter.mock.calls[0][0]).toEqual(
        expect.objectContaining({
          locations: [],
          numTimes: 3,
          timespanRange: {
            from: 'now-15m',
            to: 'now',
          },
        })
      );
      expect(mockGetter.mock.calls[0][0].filters).toMatchInlineSnapshot(`
        Object {
          "bool": Object {
            "filter": Array [
              Object {
                "bool": Object {
                  "filter": Array [
                    Object {
                      "bool": Object {
                        "minimum_should_match": 1,
                        "should": Array [
                          Object {
                            "bool": Object {
                              "minimum_should_match": 1,
                              "should": Array [
                                Object {
                                  "match": Object {
                                    "url.port": "12349",
                                  },
                                },
                              ],
                            },
                          },
                          Object {
                            "bool": Object {
                              "minimum_should_match": 1,
                              "should": Array [
                                Object {
                                  "match": Object {
                                    "url.port": "5601",
                                  },
                                },
                              ],
                            },
                          },
                          Object {
                            "bool": Object {
                              "minimum_should_match": 1,
                              "should": Array [
                                Object {
                                  "match": Object {
                                    "url.port": "443",
                                  },
                                },
                              ],
                            },
                          },
                        ],
                      },
                    },
                    Object {
                      "bool": Object {
                        "minimum_should_match": 1,
                        "should": Array [
                          Object {
                            "match": Object {
                              "observer.geo.name": "harrisburg",
                            },
                          },
                        ],
                      },
                    },
                    Object {
                      "bool": Object {
                        "minimum_should_match": 1,
                        "should": Array [
                          Object {
                            "match": Object {
                              "monitor.type": "http",
                            },
                          },
                        ],
                      },
                    },
                    Object {
                      "bool": Object {
                        "minimum_should_match": 1,
                        "should": Array [
                          Object {
                            "bool": Object {
                              "minimum_should_match": 1,
                              "should": Array [
                                Object {
                                  "match": Object {
                                    "tags": "unsecured",
                                  },
                                },
                              ],
                            },
                          },
                          Object {
                            "bool": Object {
                              "minimum_should_match": 1,
                              "should": Array [
                                Object {
                                  "match": Object {
                                    "tags": "containers",
                                  },
                                },
                              ],
                            },
                          },
                          Object {
                            "bool": Object {
                              "minimum_should_match": 1,
                              "should": Array [
                                Object {
                                  "match_phrase": Object {
                                    "tags": "org:google",
                                  },
                                },
                              ],
                            },
                          },
                        ],
                      },
                    },
                  ],
                },
              },
              Object {
                "bool": Object {
                  "minimum_should_match": 1,
                  "should": Array [
                    Object {
                      "exists": Object {
                        "field": "monitor.ip",
                      },
                    },
                  ],
                },
              },
            ],
          },
        }
      `);
      expect(alertsClient.setAlertData).toHaveBeenCalledTimes(2);
      expect(alertsClient.setAlertData.mock.calls[0]).toMatchInlineSnapshot(`
        Array [
          Object {
            "context": Object {
              "alertDetailsUrl": "mockedAlertsLocator > getLocation",
              "checkedAt": "July 6, 2020 9:14 PM",
              "configId": undefined,
              "latestErrorMessage": "error message 1",
              "monitorId": "first",
              "monitorName": "First",
              "monitorTags": undefined,
              "monitorType": "myType",
              "monitorUrl": "localhost:8080",
              "observerHostname": undefined,
              "observerLocation": "harrisburg",
              "observerName": undefined,
              "reason": "Monitor \\"First\\" from harrisburg failed 234 times in the last 15 mins. Alert when >= 3. Checked at July 6, 2020 9:14 PM.",
              "statusMessage": "failed 234 times in the last 15 mins. Alert when >= 3.",
              "viewInAppUrl": "http://localhost:5601/hfe/app/uptime/monitor/Zmlyc3Q=?dateRangeEnd=now&dateRangeStart=foo%20date%20string&filters=%5B%5B%22observer.geo.name%22%2C%5B%22harrisburg%22%5D%5D%5D",
            },
            "id": "first_localhost_8080_first-harrisburg",
          },
        ]
      `);
      expect(executorResult?.state).toMatchInlineSnapshot(`
        Object {
          "currentTriggerStarted": "foo date string",
          "firstCheckedAt": "foo date string",
          "firstTriggeredAt": "foo date string",
          "isTriggered": true,
          "lastCheckedAt": "foo date string",
          "lastResolvedAt": undefined,
          "lastTriggeredAt": "foo date string",
        }
      `);
    });

    it('supports searches', async () => {
      toISOStringSpy.mockImplementation(() => 'search test');
      const mockGetter = jest.fn();
      mockGetter.mockReturnValue([]);
      const { server, libs, plugins } = bootstrapDependencies({
        getIndexPattern: jest.fn(),
        getMonitorStatus: mockGetter,
      });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      const options = mockOptions({
        numTimes: 20,
        timerangeCount: 30,
        timerangeUnit: 'h',
        filters: {
          'monitor.type': ['http'],
          'observer.geo.name': [],
          tags: [],
          'url.port': [],
        },
        search: 'url.full: *',
      });
      await alert.executor(options);

      expect(mockGetter).toHaveBeenCalledTimes(1);
      expect(mockGetter.mock.calls[0][0].filters).toMatchInlineSnapshot(`
        Object {
          "bool": Object {
            "filter": Array [
              Object {
                "bool": Object {
                  "minimum_should_match": 1,
                  "should": Array [
                    Object {
                      "match": Object {
                        "monitor.type": "http",
                      },
                    },
                  ],
                },
              },
              Object {
                "bool": Object {
                  "minimum_should_match": 1,
                  "should": Array [
                    Object {
                      "exists": Object {
                        "field": "url.full",
                      },
                    },
                  ],
                },
              },
            ],
          },
        }
      `);
      expect(mockGetter.mock.calls[0][0]).toEqual(
        expect.objectContaining({
          locations: [],
          numTimes: 20,
          timespanRange: {
            from: 'now-30h',
            to: 'now',
          },
        })
      );
    });

    it('supports availability checks', async () => {
      // expect.assertions(13);
      toISOStringSpy.mockImplementation(() => 'availability test');
      const mockGetter: jest.Mock<GetMonitorStatusResult[]> = jest.fn();
      mockGetter.mockReturnValue([]);
      const mockAvailabilityMonitors = [
        {
          monitorId: 'foo',
          location: 'harrisburg',
          up: 2341,
          down: 17,
          availabilityRatio: 0.992790500424088,
          monitorInfo: makePing({
            id: 'foo',
            location: 'harrisburg',
            name: 'Foo',
            url: 'https://foo.com',
          }),
        },
        {
          monitorId: 'foo',
          location: 'fairbanks',
          up: 2343,
          down: 47,
          availabilityRatio: 0.980334728033473,
          monitorInfo: makePing({
            id: 'foo',
            location: 'fairbanks',
            name: 'Foo',
            url: 'https://foo.com',
          }),
        },
        {
          monitorId: 'unreliable',
          location: 'fairbanks',
          up: 2134,
          down: 213,
          availabilityRatio: 0.909245845760545,
          monitorInfo: makePing({
            id: 'unreliable',
            location: 'fairbanks',
            name: 'Unreliable',
            url: 'https://unreliable.co',
          }),
        },
        {
          monitorId: 'no-name',
          location: 'fairbanks',
          up: 2134,
          down: 213,
          availabilityRatio: 0.909245845760545,
          monitorInfo: makePing({
            id: 'no-name',
            location: 'fairbanks',
            url: 'https://no-name.co',
          }),
        },
      ];
      const mockAvailability: jest.Mock<GetMonitorAvailabilityResult[]> = jest.fn();
      mockAvailability.mockReturnValue(mockAvailabilityMonitors);
      const { server, libs, plugins } = bootstrapDependencies({
        getMonitorAvailability: mockAvailability,
        getMonitorStatus: mockGetter,
        getIndexPattern: jest.fn(),
      });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      const options = mockOptions({
        availability: {
          range: 35,
          rangeUnit: 'd',
          threshold: '99.34',
        },
        filters: {
          'url.port': ['12349', '5601', '443'],
          'observer.geo.name': ['harrisburg'],
          'monitor.type': ['http'],
          tags: ['unsecured', 'containers', 'org:google'],
        },
        shouldCheckAvailability: true,
        shouldCheckStatus: false,
      });
      const {
        services: { alertsClient },
      } = options;
      const executorResult = await alert.executor(options);
      mockAvailabilityMonitors.forEach((monitor) => {
        expect(alertsClient.report).toBeCalledWith(mockAvailabilityAlertDocument(monitor));
      });
      expect(alertsClient.report).toHaveBeenCalledTimes(4);
      expect(alertsClient.report).toHaveBeenNthCalledWith(
        1,
        expect.objectContaining({
          state: {
            checkedAt: 'July 6, 2020 9:14 PM',
            currentTriggerStarted: 'availability test',
            firstCheckedAt: 'availability test',
            firstTriggeredAt: 'availability test',
            isTriggered: true,
            lastCheckedAt: 'availability test',
            lastResolvedAt: undefined,
            lastTriggeredAt: 'availability test',
            latestErrorMessage: undefined,
            monitorId: 'foo',
            monitorName: 'Foo',
            monitorType: 'myType',
            monitorUrl: 'https://foo.com',
            observerHostname: undefined,
            observerLocation: 'harrisburg',
            reason:
              'Monitor "Foo" from harrisburg 35 days availability is 99.28%. Alert when < 99.34%. Checked at July 6, 2020 9:14 PM.',
            statusMessage: '35 days availability is 99.28%. Alert when < 99.34%.',
          },
        })
      );

      expect(alertsClient.setAlertData).toHaveBeenCalledTimes(4);
      expect(alertsClient.setAlertData.mock.calls).toMatchInlineSnapshot(`
        Array [
          Array [
            Object {
              "context": Object {
                "alertDetailsUrl": "mockedAlertsLocator > getLocation",
                "checkedAt": "July 6, 2020 9:14 PM",
                "configId": undefined,
                "latestErrorMessage": undefined,
                "monitorId": "foo",
                "monitorName": "Foo",
                "monitorTags": undefined,
                "monitorType": "myType",
                "monitorUrl": "https://foo.com",
                "observerHostname": undefined,
                "observerLocation": "harrisburg",
                "observerName": undefined,
                "reason": "Monitor \\"Foo\\" from harrisburg 35 days availability is 99.28%. Alert when < 99.34%. Checked at July 6, 2020 9:14 PM.",
                "statusMessage": "35 days availability is 99.28%. Alert when < 99.34%.",
                "viewInAppUrl": "http://localhost:5601/hfe/app/uptime/monitor/Zm9v?dateRangeEnd=now&dateRangeStart=availability%20test&filters=%5B%5B%22observer.geo.name%22%2C%5B%22harrisburg%22%5D%5D%5D",
              },
              "id": "foo_https_foo_com_foo-harrisburg",
            },
          ],
          Array [
            Object {
              "context": Object {
                "alertDetailsUrl": "mockedAlertsLocator > getLocation",
                "checkedAt": "July 6, 2020 9:14 PM",
                "configId": undefined,
                "latestErrorMessage": undefined,
                "monitorId": "foo",
                "monitorName": "Foo",
                "monitorTags": undefined,
                "monitorType": "myType",
                "monitorUrl": "https://foo.com",
                "observerHostname": undefined,
                "observerLocation": "fairbanks",
                "observerName": undefined,
                "reason": "Monitor \\"Foo\\" from fairbanks 35 days availability is 98.03%. Alert when < 99.34%. Checked at July 6, 2020 9:14 PM.",
                "statusMessage": "35 days availability is 98.03%. Alert when < 99.34%.",
                "viewInAppUrl": "http://localhost:5601/hfe/app/uptime/monitor/Zm9v?dateRangeEnd=now&dateRangeStart=availability%20test&filters=%5B%5B%22observer.geo.name%22%2C%5B%22fairbanks%22%5D%5D%5D",
              },
              "id": "foo_https_foo_com_foo-fairbanks",
            },
          ],
          Array [
            Object {
              "context": Object {
                "alertDetailsUrl": "mockedAlertsLocator > getLocation",
                "checkedAt": "July 6, 2020 9:14 PM",
                "configId": undefined,
                "latestErrorMessage": undefined,
                "monitorId": "unreliable",
                "monitorName": "Unreliable",
                "monitorTags": undefined,
                "monitorType": "myType",
                "monitorUrl": "https://unreliable.co",
                "observerHostname": undefined,
                "observerLocation": "fairbanks",
                "observerName": undefined,
                "reason": "Monitor \\"Unreliable\\" from fairbanks 35 days availability is 90.92%. Alert when < 99.34%. Checked at July 6, 2020 9:14 PM.",
                "statusMessage": "35 days availability is 90.92%. Alert when < 99.34%.",
                "viewInAppUrl": "http://localhost:5601/hfe/app/uptime/monitor/dW5yZWxpYWJsZQ==?dateRangeEnd=now&dateRangeStart=availability%20test&filters=%5B%5B%22observer.geo.name%22%2C%5B%22fairbanks%22%5D%5D%5D",
              },
              "id": "unreliable_https_unreliable_co_unreliable-fairbanks",
            },
          ],
          Array [
            Object {
              "context": Object {
                "alertDetailsUrl": "mockedAlertsLocator > getLocation",
                "checkedAt": "July 6, 2020 9:14 PM",
                "configId": undefined,
                "latestErrorMessage": undefined,
                "monitorId": "no-name",
                "monitorName": "no-name",
                "monitorTags": undefined,
                "monitorType": "myType",
                "monitorUrl": "https://no-name.co",
                "observerHostname": undefined,
                "observerLocation": "fairbanks",
                "observerName": undefined,
                "reason": "Monitor \\"no-name\\" from fairbanks 35 days availability is 90.92%. Alert when < 99.34%. Checked at July 6, 2020 9:14 PM.",
                "statusMessage": "35 days availability is 90.92%. Alert when < 99.34%.",
                "viewInAppUrl": "http://localhost:5601/hfe/app/uptime/monitor/bm8tbmFtZQ==?dateRangeEnd=now&dateRangeStart=availability%20test&filters=%5B%5B%22observer.geo.name%22%2C%5B%22fairbanks%22%5D%5D%5D",
              },
              "id": "https_no_name_co_no-name-fairbanks",
            },
          ],
        ]
      `);
      expect(mockGetter).not.toHaveBeenCalled();
      expect(mockAvailability).toHaveBeenCalledTimes(1);
      expect(mockAvailability.mock.calls[0][0].filters).toMatchInlineSnapshot(
        `"{\\"bool\\":{\\"filter\\":[{\\"bool\\":{\\"should\\":[{\\"bool\\":{\\"should\\":[{\\"match\\":{\\"url.port\\":\\"12349\\"}}],\\"minimum_should_match\\":1}},{\\"bool\\":{\\"should\\":[{\\"match\\":{\\"url.port\\":\\"5601\\"}}],\\"minimum_should_match\\":1}},{\\"bool\\":{\\"should\\":[{\\"match\\":{\\"url.port\\":\\"443\\"}}],\\"minimum_should_match\\":1}}],\\"minimum_should_match\\":1}},{\\"bool\\":{\\"should\\":[{\\"match\\":{\\"observer.geo.name\\":\\"harrisburg\\"}}],\\"minimum_should_match\\":1}},{\\"bool\\":{\\"should\\":[{\\"match\\":{\\"monitor.type\\":\\"http\\"}}],\\"minimum_should_match\\":1}},{\\"bool\\":{\\"should\\":[{\\"bool\\":{\\"should\\":[{\\"match\\":{\\"tags\\":\\"unsecured\\"}}],\\"minimum_should_match\\":1}},{\\"bool\\":{\\"should\\":[{\\"match\\":{\\"tags\\":\\"containers\\"}}],\\"minimum_should_match\\":1}},{\\"bool\\":{\\"should\\":[{\\"match_phrase\\":{\\"tags\\":\\"org:google\\"}}],\\"minimum_should_match\\":1}}],\\"minimum_should_match\\":1}}]}}"`
      );
      expect(mockAvailability.mock.calls[0][0]).toEqual(
        expect.objectContaining({
          range: 35,
          rangeUnit: 'd',
          threshold: '99.34',
        })
      );
      expect(executorResult?.state).toMatchInlineSnapshot(`
        Object {
          "currentTriggerStarted": undefined,
          "firstCheckedAt": "availability test",
          "firstTriggeredAt": undefined,
          "isTriggered": false,
          "lastCheckedAt": "availability test",
          "lastResolvedAt": undefined,
          "lastTriggeredAt": undefined,
        }
      `);
    });

    it('supports availability checks with search', async () => {
      expect.assertions(3);
      toISOStringSpy.mockImplementation(() => 'availability with search');
      const mockGetter = jest.fn();
      mockGetter.mockReturnValue([]);
      const mockAvailability = jest.fn();
      mockAvailability.mockReturnValue([]);
      const { server, libs, plugins } = bootstrapDependencies({
        getMonitorAvailability: mockAvailability,
        getIndexPattern: jest.fn(),
      });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      const options = mockOptions({
        availability: {
          range: 23,
          rangeUnit: 'w',
          threshold: '90',
        },
        search: 'ur.port: *',
        shouldCheckAvailability: true,
        shouldCheckStatus: false,
      });

      await alert.executor(options);
      expect(mockAvailability).toHaveBeenCalledTimes(1);
      expect(mockAvailability.mock.calls[0][0].filters).toMatchInlineSnapshot(
        `"{\\"bool\\":{\\"should\\":[{\\"exists\\":{\\"field\\":\\"ur.port\\"}}],\\"minimum_should_match\\":1}}"`
      );
      expect(mockAvailability.mock.calls[0][0]).toEqual(
        expect.objectContaining({
          range: 23,
          rangeUnit: 'w',
          threshold: '90',
        })
      );
    });

    it('supports availability checks with no filter or search', async () => {
      expect.assertions(2);
      toISOStringSpy.mockImplementation(() => 'availability with search');
      const mockGetter = jest.fn();
      mockGetter.mockReturnValue([]);
      const mockAvailability = jest.fn();
      mockAvailability.mockReturnValue([]);
      const { server, libs, plugins } = bootstrapDependencies({
        getMonitorAvailability: mockAvailability,
        getIndexPattern: jest.fn(),
      });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      const availability = {
        range: 23,
        rangeUnit: 'w',
        threshold: '90',
      };
      const options = mockOptions({
        availability,
        shouldCheckAvailability: true,
        shouldCheckStatus: false,
      });

      await alert.executor(options);

      expect(mockAvailability).toHaveBeenCalledTimes(1);
      expect(mockAvailability.mock.calls[0][0]).toEqual(
        expect.objectContaining({
          filters: undefined,
          range: availability.range,
          rangeUnit: availability.rangeUnit,
          threshold: availability.threshold,
        })
      );
    });

    it('sets alert recovery context for recovered alerts', async () => {
      toISOStringSpy.mockImplementation(() => 'foo date string');
      const mockGetter: jest.Mock<GetMonitorStatusResult[]> = jest.fn();

      mockGetter.mockReturnValue(mockMonitors);
      const { server, libs, plugins } = bootstrapDependencies({ getMonitorStatus: mockGetter });
      const alert = statusCheckAlertFactory(server, libs, plugins);
      const options = mockOptions(undefined, undefined, undefined, mockRecoveredAlerts);
      // @ts-ignore the executor can return `void`, but ours never does
      const state: Record<string, any> = await alert.executor(options);
      expect(options.services.alertsClient.setAlertData).toHaveBeenCalledTimes(4);

      expect(options.services.alertsClient.setAlertData).toHaveBeenNthCalledWith(3, {
        context: mockRecoveredAlerts[0],
        id: 'mock-id',
      });

      expect(options.services.alertsClient.setAlertData).toHaveBeenNthCalledWith(4, {
        context: mockRecoveredAlerts[1],
        id: 'mock-id',
      });
    });
  });

  describe('alert recovery', () => {
    it('sets context for alert recovery', () => {});
  });

  describe('alert factory', () => {
    // @ts-ignore
    let alert: DefaultUptimeAlertInstance;

    beforeEach(() => {
      const { server, libs, plugins } = bootstrapDependencies();
      alert = statusCheckAlertFactory(server, libs, plugins);
    });

    it('creates an alert with expected params', () => {
      // @ts-ignore the `props` key here isn't described
      expect(Object.keys(alert.validate?.params?.props ?? {})).toMatchInlineSnapshot(`
        Array [
          "stackVersion",
          "availability",
          "filters",
          "locations",
          "numTimes",
          "search",
          "shouldCheckStatus",
          "shouldCheckAvailability",
          "timerangeCount",
          "timerangeUnit",
          "timerange",
          "version",
          "isAutoGenerated",
        ]
      `);
    });

    it('contains the expected static fields like id, name, etc.', () => {
      expect(alert.id).toBe('xpack.uptime.alerts.monitorStatus');
      expect(alert.name).toBe('Uptime monitor status');
      expect(alert.defaultActionGroupId).toBe('xpack.uptime.alerts.actionGroups.monitorStatus');
      expect(alert.actionGroups).toMatchInlineSnapshot(`
        Array [
          Object {
            "id": "xpack.uptime.alerts.actionGroups.monitorStatus",
            "name": "Uptime Down Monitor",
          },
        ]
      `);
    });
  });

  it('generates timespan and @timestamp ranges appropriately', async () => {
    const mockGetter = jest.fn();
    mockGetter.mockReturnValue([]);
    const { server, libs, plugins } = bootstrapDependencies({
      getIndexPattern: jest.fn(),
      getMonitorStatus: mockGetter,
    });
    const alert = statusCheckAlertFactory(server, libs, plugins);
    const options = mockOptions({
      numTimes: 20,
      timerangeCount: 30,
      timerangeUnit: 'h',
      filters: {
        'monitor.type': ['http'],
        'observer.geo.name': [],
        tags: [],
        'url.port': [],
      },
      search: 'url.full: *',
    });
    await alert.executor(options);

    expect(mockGetter).toHaveBeenCalledTimes(1);
    expect(mockGetter.mock.calls[0][0]).toEqual(
      expect.objectContaining({
        timespanRange: {
          from: 'now-30h',
          to: 'now',
        },
        timestampRange: {
          from: mockDate.setHours(mockDate.getHours() - 54).valueOf(), // now minus the timerange (30h), plus an additional 24 hour buffer
          to: 'now',
        },
      })
    );
  });

  it('uses the larger of alert interval and timerange when defining timestampRange', async () => {
    const mockGetter = jest.fn();
    mockGetter.mockReturnValue([]);
    const { server, libs, plugins } = bootstrapDependencies({
      getIndexPattern: jest.fn(),
      getMonitorStatus: mockGetter,
    });
    const alert = statusCheckAlertFactory(server, libs, plugins);
    const options = mockOptions(
      {
        numTimes: 20,
        timerangeCount: 30,
        timerangeUnit: 'h',
        filters: {
          'monitor.type': ['http'],
          'observer.geo.name': [],
          tags: [],
          'url.port': [],
        },
        search: 'url.full: *',
      },
      undefined,
      { schedule: { interval: '60h' } }
    );
    await alert.executor(options);

    expect(mockGetter).toHaveBeenCalledTimes(1);
    expect(mockGetter.mock.calls[0][0]).toEqual(
      expect.objectContaining({
        timespanRange: {
          from: 'now-30h',
          to: 'now',
        },
        timestampRange: {
          from: mockDate.setHours(mockDate.getHours() - 60).valueOf(), // 60h rule schedule interval is larger than 30h timerange, so use now - 60h to define timestamp range
          to: 'now',
        },
      })
    );
  });

  describe('hasFilters', () => {
    it('returns false for undefined filters', () => {
      expect(hasFilters()).toBe(false);
    });

    it('returns false for empty filters', () => {
      expect(
        hasFilters({
          'monitor.type': [],
          'observer.geo.name': [],
          tags: [],
          'url.port': [],
        })
      ).toBe(false);
    });

    it('returns true for an object with a filter', () => {
      expect(
        hasFilters({
          'monitor.type': [],
          'observer.geo.name': ['us-east', 'us-west'],
          tags: [],
          'url.port': [],
        })
      ).toBe(true);
    });
  });

  describe('genFilterString', () => {
    const mockGetIndexPattern = jest.fn();
    mockGetIndexPattern.mockReturnValue(undefined);

    it('returns `undefined` for no filters or search', async () => {
      expect(
        await generateFilterDSL(
          mockGetIndexPattern,
          { 'monitor.type': [], 'observer.geo.name': [], tags: [], 'url.port': [] },
          ''
        )
      ).toBeUndefined();
    });

    it('creates a filter string for filters only', async () => {
      const res = await generateFilterDSL(
        mockGetIndexPattern,
        {
          'monitor.type': [],
          'observer.geo.name': ['us-east', 'us-west'],
          tags: [],
          'url.port': [],
        },
        ''
      );
      expect(res).toMatchInlineSnapshot(`
        Object {
          "bool": Object {
            "minimum_should_match": 1,
            "should": Array [
              Object {
                "bool": Object {
                  "minimum_should_match": 1,
                  "should": Array [
                    Object {
                      "match": Object {
                        "observer.geo.name": "us-east",
                      },
                    },
                  ],
                },
              },
              Object {
                "bool": Object {
                  "minimum_should_match": 1,
                  "should": Array [
                    Object {
                      "match": Object {
                        "observer.geo.name": "us-west",
                      },
                    },
                  ],
                },
              },
            ],
          },
        }
      `);
    });

    it('creates a filter string for search only', async () => {
      expect(
        await generateFilterDSL(
          mockGetIndexPattern,
          { 'monitor.type': [], 'observer.geo.name': [], tags: [], 'url.port': [] },
          'monitor.id: "kibana-dev"'
        )
      ).toMatchInlineSnapshot(`
        Object {
          "bool": Object {
            "minimum_should_match": 1,
            "should": Array [
              Object {
                "match_phrase": Object {
                  "monitor.id": "kibana-dev",
                },
              },
            ],
          },
        }
      `);
    });

    it('creates a filter string for filters and string', async () => {
      const res = await generateFilterDSL(
        mockGetIndexPattern,
        {
          'monitor.type': [],
          'observer.geo.name': ['us-east', 'apj', 'sydney', 'us-west'],
          tags: [],
          'url.port': [],
        },
        'monitor.id: "kibana-dev"'
      );
      expect(res).toMatchInlineSnapshot(`
        Object {
          "bool": Object {
            "filter": Array [
              Object {
                "bool": Object {
                  "minimum_should_match": 1,
                  "should": Array [
                    Object {
                      "bool": Object {
                        "minimum_should_match": 1,
                        "should": Array [
                          Object {
                            "match": Object {
                              "observer.geo.name": "us-east",
                            },
                          },
                        ],
                      },
                    },
                    Object {
                      "bool": Object {
                        "minimum_should_match": 1,
                        "should": Array [
                          Object {
                            "match": Object {
                              "observer.geo.name": "apj",
                            },
                          },
                        ],
                      },
                    },
                    Object {
                      "bool": Object {
                        "minimum_should_match": 1,
                        "should": Array [
                          Object {
                            "match": Object {
                              "observer.geo.name": "sydney",
                            },
                          },
                        ],
                      },
                    },
                    Object {
                      "bool": Object {
                        "minimum_should_match": 1,
                        "should": Array [
                          Object {
                            "match": Object {
                              "observer.geo.name": "us-west",
                            },
                          },
                        ],
                      },
                    },
                  ],
                },
              },
              Object {
                "bool": Object {
                  "minimum_should_match": 1,
                  "should": Array [
                    Object {
                      "match_phrase": Object {
                        "monitor.id": "kibana-dev",
                      },
                    },
                  ],
                },
              },
            ],
          },
        }
      `);
    });
  });

  describe('uniqueMonitorIds', () => {
    let downItems: GetMonitorStatusResult[];
    let availItems: GetMonitorAvailabilityResult[];
    beforeEach(() => {
      downItems = [
        {
          monitorId: 'first',
          location: 'harrisburg',
          count: 234,
          status: 'down',
          monitorInfo: makePing({}),
        },
        {
          monitorId: 'first',
          location: 'fairbanks',
          count: 312,
          status: 'down',
          monitorInfo: makePing({}),
        },
        {
          monitorId: 'second',
          location: 'harrisburg',
          count: 325,
          status: 'down',
          monitorInfo: makePing({}),
        },
        {
          monitorId: 'second',
          location: 'fairbanks',
          count: 331,
          status: 'down',
          monitorInfo: makePing({}),
        },
      ];

      availItems = [
        {
          monitorId: 'first',
          location: 'harrisburg',
          monitorInfo: makePing({}),
          up: 2134,
          down: 213,
          availabilityRatio: 0.909245845760545,
        },
        {
          monitorId: 'first',
          location: 'fairbanks',
          monitorInfo: makePing({}),
          up: 2134,
          down: 213,
          availabilityRatio: 0.909245845760545,
        },
        {
          monitorId: 'second',
          location: 'harrisburg',
          monitorInfo: makePing({}),
          up: 2134,
          down: 213,
          availabilityRatio: 0.909245845760545,
        },
        {
          monitorId: 'second',
          location: 'fairbanks',
          monitorInfo: makePing({}),
          up: 2134,
          down: 213,
          availabilityRatio: 0.909245845760545,
        },
      ];
    });

    it('creates a set of unique IDs from a list of composite unique objects', () => {
      expect(getUniqueIdsByLoc(downItems, availItems)).toEqual(
        new Set<string>([
          'first-harrisburg',
          'first-fairbanks',
          'second-harrisburg',
          'second-fairbanks',
        ])
      );
    });
  });

  describe('statusMessage', () => {
    it('creates message for down item', () => {
      expect(
        getStatusMessage({
          info: makePing({
            id: 'test-node-service',
            location: 'fairbanks',
            name: 'Test Node Service',
            url: 'http://localhost:12349',
          }),
          count: 235,
          numTimes: 10,
          interval: '30 days',
        })
      ).toMatchInlineSnapshot(`"failed 235 times in the last 30 days. Alert when >= 10."`);
    });

    it('creates message for availability item', () => {
      expect(
        getStatusMessage(
          undefined,
          {
            monitorId: 'test-node-service',
            location: 'harrisburg',
            up: 3389.0,
            down: 2450.0,
            availabilityRatio: 0.5804076040417879,
            monitorInfo: makePing({
              name: 'Test Node Service',
              url: 'http://localhost:12349',
              id: 'test-node-service',
              location: 'harrisburg',
            }),
          },
          {
            threshold: '90',
            range: 5,
            rangeUnit: 'm',
          }
        )
      ).toMatchInlineSnapshot(`"5 mins availability is 58.04%. Alert when < 90%."`);
    });

    it('creates message for down and availability item', () => {
      expect(
        getStatusMessage(
          {
            info: makePing({
              id: 'test-node-service',
              location: 'fairbanks',
              name: 'Test Node Service',
              url: 'http://localhost:12349',
            }),
            count: 235,
            numTimes: 10,
            interval: '30 days',
          },
          {
            monitorId: 'test-node-service',
            location: 'harrisburg',
            up: 3389.0,
            down: 2450.0,
            availabilityRatio: 0.5804076040417879,
            monitorInfo: makePing({
              name: 'Test Node Service',
              url: 'http://localhost:12349',
              id: 'test-node-service',
              location: 'harrisburg',
            }),
          },
          {
            threshold: '90',
            range: 5,
            rangeUnit: 'm',
          }
        )
      ).toMatchInlineSnapshot(
        `"failed 235 times in the last 30 days. Alert when >= 10. The 5 mins availability is 58.04%. Alert when < 90%."`
      );
    });
  });
});
