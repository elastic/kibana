/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */

import { BrowserFields } from '.';
import { sourceQuery } from './index.gql_query';

export const mocksSource = [
  {
    request: {
      query: sourceQuery,
      variables: {
        sourceId: 'default',
        defaultIndex: ['auditbeat-*', 'filebeat-*', 'packetbeat-*', 'winlogbeat-*'],
      },
    },
    result: {
      data: {
        source: {
          id: 'default',
          configuration: {},
          status: {
            indicesExist: true,
            winlogbeatIndices: [
              'winlogbeat-7.0.0-2019.02.17',
              'winlogbeat-7.0.0-2019.02.18',
              'winlogbeat-7.0.0-2019.02.19',
              'winlogbeat-7.0.0-2019.02.20',
              'winlogbeat-7.0.0-2019.02.21',
              'winlogbeat-7.0.0-2019.02.21-000001',
              'winlogbeat-7.0.0-2019.02.22',
              'winlogbeat-8.0.0-2019.02.19-000001',
            ],
            auditbeatIndices: [
              'auditbeat-7.0.0-2019.02.17',
              'auditbeat-7.0.0-2019.02.18',
              'auditbeat-7.0.0-2019.02.19',
              'auditbeat-7.0.0-2019.02.20',
              'auditbeat-7.0.0-2019.02.21',
              'auditbeat-7.0.0-2019.02.21-000001',
              'auditbeat-7.0.0-2019.02.22',
              'auditbeat-8.0.0-2019.02.19-000001',
            ],
            filebeatIndices: [
              'filebeat-7.0.0-iot-2019.06',
              'filebeat-7.0.0-iot-2019.07',
              'filebeat-7.0.0-iot-2019.08',
              'filebeat-7.0.0-iot-2019.09',
              'filebeat-7.0.0-iot-2019.10',
              'filebeat-8.0.0-2019.02.19-000001',
            ],
            indexFields: [
              {
                category: 'base',
                description:
                  'Date/time when the event originated. For log events this is the date/time when the event was generated, and not when it was read. Required field for all events.',
                example: '2016-05-23T08:05:34.853Z',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: '@timestamp',
                searchable: true,
                type: 'date',
                aggregatable: true,
              },
              {
                category: 'agent',
                description:
                  'Ephemeral identifier of this agent (if one exists). This id normally changes across restarts, but `agent.id` does not.',
                example: '8a4f500f',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'agent.ephemeral_id',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'agent',
                description: null,
                example: null,
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'agent.hostname',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'agent',
                description:
                  'Unique identifier of this agent (if one exists). Example: For Beats this would be beat.id.',
                example: '8a4f500d',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'agent.id',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'agent',
                description:
                  'Name of the agent. This is a name that can be given to an agent. This can be helpful if for example two Filebeat instances are running on the same host but a human readable separation is needed on which Filebeat instance data is coming from. If no name is given, the name is often left empty.',
                example: 'foo',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'agent.name',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'auditd',
                description: null,
                example: null,
                indexes: ['auditbeat'],
                name: 'auditd.data.a0',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'auditd',
                description: null,
                example: null,
                indexes: ['auditbeat'],
                name: 'auditd.data.a1',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'auditd',
                description: null,
                example: null,
                indexes: ['auditbeat'],
                name: 'auditd.data.a2',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'client',
                description:
                  'Some event client addresses are defined ambiguously. The event will sometimes list an IP, a domain or a unix socket.  You should always store the raw address in the `.address` field. Then it should be duplicated to `.ip` or `.domain`, depending on which one it is.',
                example: null,
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'client.address',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'client',
                description: 'Bytes sent from the client to the server.',
                example: '184',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'client.bytes',
                searchable: true,
                type: 'number',
                aggregatable: true,
              },
              {
                category: 'client',
                description: 'Client domain.',
                example: null,
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'client.domain',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'client',
                description: 'Country ISO code.',
                example: 'CA',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'client.geo.country_iso_code',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'cloud',
                description:
                  'The cloud account or organization id used to identify different entities in a multi-tenant environment. Examples: AWS account id, Google Cloud ORG Id, or other unique identifier.',
                example: '666777888999',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'cloud.account.id',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'cloud',
                description: 'Availability zone in which this host is running.',
                example: 'us-east-1c',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'cloud.availability_zone',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'container',
                description: 'Unique container id.',
                example: null,
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'container.id',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'container',
                description: 'Name of the image the container was built on.',
                example: null,
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'container.image.name',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'container',
                description: 'Container image tag.',
                example: null,
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'container.image.tag',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'destination',
                description:
                  'Some event destination addresses are defined ambiguously. The event will sometimes list an IP, a domain or a unix socket.  You should always store the raw address in the `.address` field. Then it should be duplicated to `.ip` or `.domain`, depending on which one it is.',
                example: null,
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'destination.address',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                category: 'destination',
                description: 'Bytes sent from the destination to the source.',
                example: '184',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'destination.bytes',
                searchable: true,
                type: 'number',
                aggregatable: true,
              },
              {
                category: 'destination',
                description: 'Destination domain.',
                example: null,
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'destination.domain',
                searchable: true,
                type: 'string',
                aggregatable: true,
              },
              {
                aggregatable: true,
                category: 'destination',
                description:
                  'IP address of the destination. Can be one or multiple IPv4 or IPv6 addresses.',
                example: '',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'destination.ip',
                searchable: true,
                type: 'ip',
              },
              {
                aggregatable: true,
                category: 'destination',
                description: 'Port of the destination.',
                example: '',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'destination.port',
                searchable: true,
                type: 'long',
              },
              {
                aggregatable: true,
                category: 'source',
                description:
                  'IP address of the source. Can be one or multiple IPv4 or IPv6 addresses.',
                example: '',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'source.ip',
                searchable: true,
                type: 'ip',
              },
              {
                aggregatable: true,
                category: 'source',
                description: 'Port of the source.',
                example: '',
                indexes: ['auditbeat', 'filebeat', 'packetbeat'],
                name: 'source.port',
                searchable: true,
                type: 'long',
              },
              {
                aggregatable: true,
                category: 'event',
                description:
                  'event.end contains the date when the event ended or when the activity was last observed.',
                example: null,
                indexes: ['auditbeat-*', 'filebeat-*', 'packetbeat-*', 'winlogbeat-*'],
                name: 'event.end',
                searchable: true,
                type: 'date',
              },
            ],
          },
        },
      },
    },
  },
];

export const mockIndexFields = [
  { aggregatable: true, name: '@timestamp', searchable: true, type: 'date' },
  { aggregatable: true, name: 'agent.ephemeral_id', searchable: true, type: 'string' },
  { aggregatable: true, name: 'agent.hostname', searchable: true, type: 'string' },
  { aggregatable: true, name: 'agent.id', searchable: true, type: 'string' },
  { aggregatable: true, name: 'agent.name', searchable: true, type: 'string' },
  { aggregatable: true, name: 'auditd.data.a0', searchable: true, type: 'string' },
  { aggregatable: true, name: 'auditd.data.a1', searchable: true, type: 'string' },
  { aggregatable: true, name: 'auditd.data.a2', searchable: true, type: 'string' },
  { aggregatable: true, name: 'client.address', searchable: true, type: 'string' },
  { aggregatable: true, name: 'client.bytes', searchable: true, type: 'number' },
  { aggregatable: true, name: 'client.domain', searchable: true, type: 'string' },
  { aggregatable: true, name: 'client.geo.country_iso_code', searchable: true, type: 'string' },
  { aggregatable: true, name: 'cloud.account.id', searchable: true, type: 'string' },
  { aggregatable: true, name: 'cloud.availability_zone', searchable: true, type: 'string' },
  { aggregatable: true, name: 'container.id', searchable: true, type: 'string' },
  { aggregatable: true, name: 'container.image.name', searchable: true, type: 'string' },
  { aggregatable: true, name: 'container.image.tag', searchable: true, type: 'string' },
  { aggregatable: true, name: 'destination.address', searchable: true, type: 'string' },
  { aggregatable: true, name: 'destination.bytes', searchable: true, type: 'number' },
  { aggregatable: true, name: 'destination.domain', searchable: true, type: 'string' },
  { aggregatable: true, name: 'destination.ip', searchable: true, type: 'ip' },
  { aggregatable: true, name: 'destination.port', searchable: true, type: 'long' },
  { aggregatable: true, name: 'source.ip', searchable: true, type: 'ip' },
  { aggregatable: true, name: 'source.port', searchable: true, type: 'long' },
  { aggregatable: true, name: 'event.end', searchable: true, type: 'date' },
];

export const mockBrowserFields: BrowserFields = {
  agent: {
    fields: {
      'agent.ephemeral_id': {
        aggregatable: true,
        category: 'agent',
        description:
          'Ephemeral identifier of this agent (if one exists). This id normally changes across restarts, but `agent.id` does not.',
        example: '8a4f500f',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'agent.ephemeral_id',
        searchable: true,
        type: 'string',
      },
      'agent.hostname': {
        aggregatable: true,
        category: 'agent',
        description: null,
        example: null,
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'agent.hostname',
        searchable: true,
        type: 'string',
      },
      'agent.id': {
        aggregatable: true,
        category: 'agent',
        description:
          'Unique identifier of this agent (if one exists). Example: For Beats this would be beat.id.',
        example: '8a4f500d',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'agent.id',
        searchable: true,
        type: 'string',
      },
      'agent.name': {
        aggregatable: true,
        category: 'agent',
        description:
          'Name of the agent. This is a name that can be given to an agent. This can be helpful if for example two Filebeat instances are running on the same host but a human readable separation is needed on which Filebeat instance data is coming from. If no name is given, the name is often left empty.',
        example: 'foo',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'agent.name',
        searchable: true,
        type: 'string',
      },
    },
  },
  auditd: {
    fields: {
      'auditd.data.a0': {
        aggregatable: true,
        category: 'auditd',
        description: null,
        example: null,
        indexes: ['auditbeat'],
        name: 'auditd.data.a0',
        searchable: true,
        type: 'string',
      },
      'auditd.data.a1': {
        aggregatable: true,
        category: 'auditd',
        description: null,
        example: null,
        indexes: ['auditbeat'],
        name: 'auditd.data.a1',
        searchable: true,
        type: 'string',
      },
      'auditd.data.a2': {
        aggregatable: true,
        category: 'auditd',
        description: null,
        example: null,
        indexes: ['auditbeat'],
        name: 'auditd.data.a2',
        searchable: true,
        type: 'string',
      },
    },
  },
  base: {
    fields: {
      '@timestamp': {
        aggregatable: true,
        category: 'base',
        description:
          'Date/time when the event originated. For log events this is the date/time when the event was generated, and not when it was read. Required field for all events.',
        example: '2016-05-23T08:05:34.853Z',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: '@timestamp',
        searchable: true,
        type: 'date',
      },
    },
  },
  client: {
    fields: {
      'client.address': {
        aggregatable: true,
        category: 'client',
        description:
          'Some event client addresses are defined ambiguously. The event will sometimes list an IP, a domain or a unix socket.  You should always store the raw address in the `.address` field. Then it should be duplicated to `.ip` or `.domain`, depending on which one it is.',
        example: null,
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'client.address',
        searchable: true,
        type: 'string',
      },
      'client.bytes': {
        aggregatable: true,
        category: 'client',
        description: 'Bytes sent from the client to the server.',
        example: '184',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'client.bytes',
        searchable: true,
        type: 'number',
      },
      'client.domain': {
        aggregatable: true,
        category: 'client',
        description: 'Client domain.',
        example: null,
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'client.domain',
        searchable: true,
        type: 'string',
      },
      'client.geo.country_iso_code': {
        aggregatable: true,
        category: 'client',
        description: 'Country ISO code.',
        example: 'CA',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'client.geo.country_iso_code',
        searchable: true,
        type: 'string',
      },
    },
  },
  cloud: {
    fields: {
      'cloud.account.id': {
        aggregatable: true,
        category: 'cloud',
        description:
          'The cloud account or organization id used to identify different entities in a multi-tenant environment. Examples: AWS account id, Google Cloud ORG Id, or other unique identifier.',
        example: '666777888999',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'cloud.account.id',
        searchable: true,
        type: 'string',
      },
      'cloud.availability_zone': {
        aggregatable: true,
        category: 'cloud',
        description: 'Availability zone in which this host is running.',
        example: 'us-east-1c',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'cloud.availability_zone',
        searchable: true,
        type: 'string',
      },
    },
  },
  container: {
    fields: {
      'container.id': {
        aggregatable: true,
        category: 'container',
        description: 'Unique container id.',
        example: null,
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'container.id',
        searchable: true,
        type: 'string',
      },
      'container.image.name': {
        aggregatable: true,
        category: 'container',
        description: 'Name of the image the container was built on.',
        example: null,
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'container.image.name',
        searchable: true,
        type: 'string',
      },
      'container.image.tag': {
        aggregatable: true,
        category: 'container',
        description: 'Container image tag.',
        example: null,
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'container.image.tag',
        searchable: true,
        type: 'string',
      },
    },
  },
  destination: {
    fields: {
      'destination.address': {
        aggregatable: true,
        category: 'destination',
        description:
          'Some event destination addresses are defined ambiguously. The event will sometimes list an IP, a domain or a unix socket.  You should always store the raw address in the `.address` field. Then it should be duplicated to `.ip` or `.domain`, depending on which one it is.',
        example: null,
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'destination.address',
        searchable: true,
        type: 'string',
      },
      'destination.bytes': {
        aggregatable: true,
        category: 'destination',
        description: 'Bytes sent from the destination to the source.',
        example: '184',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'destination.bytes',
        searchable: true,
        type: 'number',
      },
      'destination.domain': {
        aggregatable: true,
        category: 'destination',
        description: 'Destination domain.',
        example: null,
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'destination.domain',
        searchable: true,
        type: 'string',
      },
      'destination.ip': {
        aggregatable: true,
        category: 'destination',
        description:
          'IP address of the destination. Can be one or multiple IPv4 or IPv6 addresses.',
        example: '',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'destination.ip',
        searchable: true,
        type: 'ip',
      },
      'destination.port': {
        aggregatable: true,
        category: 'destination',
        description: 'Port of the destination.',
        example: '',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'destination.port',
        searchable: true,
        type: 'long',
      },
    },
  },
  event: {
    fields: {
      'event.end': {
        category: 'event',
        description:
          'event.end contains the date when the event ended or when the activity was last observed.',
        example: null,
        indexes: ['auditbeat-*', 'filebeat-*', 'packetbeat-*', 'winlogbeat-*'],
        name: 'event.end',
        searchable: true,
        type: 'date',
        aggregatable: true,
      },
    },
  },
  source: {
    fields: {
      'source.ip': {
        aggregatable: true,
        category: 'source',
        description: 'IP address of the source. Can be one or multiple IPv4 or IPv6 addresses.',
        example: '',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'source.ip',
        searchable: true,
        type: 'ip',
      },
      'source.port': {
        aggregatable: true,
        category: 'source',
        description: 'Port of the source.',
        example: '',
        indexes: ['auditbeat', 'filebeat', 'packetbeat'],
        name: 'source.port',
        searchable: true,
        type: 'long',
      },
    },
  },
};
