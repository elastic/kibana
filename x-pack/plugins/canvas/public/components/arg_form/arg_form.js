/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import React, { useRef, useEffect, useState } from 'react';
import PropTypes from 'prop-types';
import { ErrorBoundary } from '../enhance/error_boundary';
import { ArgSimpleForm } from './arg_simple_form';
import { ArgTemplateForm } from './arg_template_form';
import { SimpleFailure } from './simple_failure';
import { AdvancedFailure } from './advanced_failure';
import { ArgLabel } from './arg_label';
import { PendingArgValue } from './pending_arg_value';

const isPending = (argTypeInstance, resolvedArgValue) => {
  const { argType } = argTypeInstance;

  // arg does not need to be resolved, no need to branch
  if (!argType.resolveArgValue) {
    return false;
  }

  // arg needs to be resolved, render pending if the value is not defined
  return typeof resolvedArgValue === 'undefined';
};

// This is what is being generated by render() from the Arg class. It is called in FunctionForm
export const ArgForm = (props) => {
  const {
    argId,
    argTypeInstance,
    templateProps,
    valueMissing,
    label,
    setLabel,
    onValueRemove,
    workpad,
    assets,
    resolvedArgValue,
  } = props;
  const [renderError, setRenderError] = useState(false);
  const isMounted = useRef();

  useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);

  if (isPending(argTypeInstance, resolvedArgValue)) {
    return <PendingArgValue {...props} />;
  }

  return (
    <ErrorBoundary>
      {({ error, resetErrorState }) => {
        const { template, simpleTemplate } = argTypeInstance.argType;
        const hasError = Boolean(error) || renderError;
        const argumentProps = {
          ...templateProps,
          resolvedArgValue,
          defaultValue: argTypeInstance.default,

          renderError: () => {
            // Provide templates with a renderError method, and wrap the error in a known error type
            // to stop Kibana's window.error from being called
            isMounted.current && setRenderError(true);
          },
          error: hasError,
          setLabel: (label) => isMounted.current && setLabel(label),
          resetErrorState: () => {
            resetErrorState();
            isMounted.current && setRenderError(false);
          },
          label,
          workpad,
          argId,
          assets,
        };

        const expandableLabel = Boolean(hasError || template);

        const simpleArg = (
          <ArgSimpleForm
            required={argTypeInstance.required}
            valueMissing={valueMissing}
            onRemove={onValueRemove}
          >
            <ArgTemplateForm
              template={simpleTemplate}
              errorTemplate={SimpleFailure}
              error={hasError}
              argumentProps={argumentProps}
            />
          </ArgSimpleForm>
        );

        const extendedArg = (
          <div className="canvasArg--controls">
            <ArgTemplateForm
              template={template}
              errorTemplate={AdvancedFailure}
              error={hasError}
              argumentProps={argumentProps}
            />
          </div>
        );

        return (
          <div className={`canvasArg ${expandableLabel ? 'canvasSidebar__expandable' : null}`}>
            <ArgLabel
              className="resolved"
              argId={argId}
              label={label}
              help={argTypeInstance.help}
              expandable={expandableLabel}
              simpleArg={simpleArg}
              initialIsOpen={!simpleTemplate}
            >
              {extendedArg}
            </ArgLabel>
          </div>
        );
      }}
    </ErrorBoundary>
  );
};

ArgForm.propTypes = {
  argId: PropTypes.string.isRequired,
  workpad: PropTypes.object.isRequired,
  argTypeInstance: PropTypes.shape({
    argType: PropTypes.object.isRequired,
    help: PropTypes.string.isRequired,
    required: PropTypes.bool,
    default: PropTypes.any,
  }).isRequired,
  templateProps: PropTypes.object,
  valueMissing: PropTypes.bool,
  label: PropTypes.string,
  setLabel: PropTypes.func.isRequired,
  expand: PropTypes.bool,
  setExpand: PropTypes.func,
  onValueRemove: PropTypes.func,
  resolvedArgValue: PropTypes.any,
};
