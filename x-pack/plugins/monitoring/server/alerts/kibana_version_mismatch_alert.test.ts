/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { KibanaVersionMismatchAlert } from './kibana_version_mismatch_alert';
import { ALERT_KIBANA_VERSION_MISMATCH } from '../../common/constants';
import { fetchKibanaVersions } from '../lib/alerts/fetch_kibana_versions';
import { fetchClusters } from '../lib/alerts/fetch_clusters';
import { elasticsearchServiceMock } from 'src/core/server/mocks';

const RealDate = Date;

jest.mock('../lib/alerts/fetch_kibana_versions', () => ({
  fetchKibanaVersions: jest.fn(),
}));
jest.mock('../lib/alerts/fetch_clusters', () => ({
  fetchClusters: jest.fn(),
}));

jest.mock('../static_globals', () => ({
  Globals: {
    app: {
      url: 'UNIT_TEST_URL',
      getLogger: () => ({ debug: jest.fn() }),
      config: {
        ui: {
          ccs: { enabled: true },
          metricbeat: { index: 'metricbeat-*' },
          container: { elasticsearch: { enabled: false } },
        },
      },
    },
  },
}));

describe('KibanaVersionMismatchAlert', () => {
  it('should have defaults', () => {
    const alert = new KibanaVersionMismatchAlert();
    expect(alert.alertOptions.id).toBe(ALERT_KIBANA_VERSION_MISMATCH);
    expect(alert.alertOptions.name).toBe('Kibana version mismatch');
    expect(alert.alertOptions.throttle).toBe('1d');
    expect(alert.alertOptions.actionVariables).toStrictEqual([
      {
        name: 'versionList',
        description: 'The versions of Kibana running in this cluster.',
      },
      {
        name: 'clusterName',
        description: 'The cluster to which the instances belong.',
      },
      {
        name: 'internalShortMessage',
        description: 'The short internal message generated by Elastic.',
      },
      {
        name: 'internalFullMessage',
        description: 'The full internal message generated by Elastic.',
      },
      { name: 'state', description: 'The current state of the alert.' },
      { name: 'action', description: 'The recommended action for this alert.' },
      {
        name: 'actionPlain',
        description: 'The recommended action for this alert, without any markdown.',
      },
    ]);
  });

  describe('execute', () => {
    function FakeDate() {}
    FakeDate.prototype.valueOf = () => 1;

    const ccs = undefined;
    const clusterUuid = 'abc123';
    const clusterName = 'testCluster';
    const kibanaVersions = [
      {
        versions: ['8.0.0', '7.2.1'],
        clusterUuid,
        ccs,
      },
    ];

    const replaceState = jest.fn();
    const scheduleActions = jest.fn();
    const getState = jest.fn();
    const executorOptions = {
      services: {
        scopedClusterClient: elasticsearchServiceMock.createScopedClusterClient(),
        alertInstanceFactory: jest.fn().mockImplementation(() => {
          return {
            replaceState,
            scheduleActions,
            getState,
          };
        }),
      },
      state: {},
    };

    beforeEach(() => {
      // @ts-ignore
      Date = FakeDate;
      (fetchKibanaVersions as jest.Mock).mockImplementation(() => {
        return kibanaVersions;
      });
      (fetchClusters as jest.Mock).mockImplementation(() => {
        return [{ clusterUuid, clusterName }];
      });
    });

    afterEach(() => {
      Date = RealDate;
      replaceState.mockReset();
      scheduleActions.mockReset();
      getState.mockReset();
    });

    it('should fire actions', async () => {
      const alert = new KibanaVersionMismatchAlert();
      const type = alert.getAlertType();
      await type.executor({
        ...executorOptions,
        params: alert.alertOptions.defaultParams,
      } as any);
      expect(replaceState).toHaveBeenCalledWith({
        alertStates: [
          {
            cluster: { clusterUuid: 'abc123', clusterName: 'testCluster' },
            ccs,
            itemLabel: undefined,
            nodeId: undefined,
            nodeName: undefined,
            meta: {
              ccs,
              clusterUuid,
              versions: ['8.0.0', '7.2.1'],
            },
            ui: {
              isFiring: true,
              message: {
                text: 'Multiple versions of Kibana (8.0.0, 7.2.1) running in this cluster.',
              },
              severity: 'warning',
              triggeredMS: 1,
              lastCheckedMS: 0,
            },
          },
        ],
      });
      expect(scheduleActions).toHaveBeenCalledWith('default', {
        action: `[View instances](UNIT_TEST_URL/app/monitoring#/kibana/instances?_g=(cluster_uuid:${clusterUuid}))`,
        actionPlain: 'Verify you have the same version across all instances.',
        internalFullMessage: `Kibana version mismatch alert is firing for testCluster. Kibana is running 8.0.0, 7.2.1. [View instances](UNIT_TEST_URL/app/monitoring#/kibana/instances?_g=(cluster_uuid:${clusterUuid}))`,
        internalShortMessage:
          'Kibana version mismatch alert is firing for testCluster. Verify you have the same version across all instances.',
        versionList: ['8.0.0', '7.2.1'],
        clusterName,
        state: 'firing',
      });
    });

    it('should not fire actions if there is no mismatch', async () => {
      (fetchKibanaVersions as jest.Mock).mockImplementation(() => {
        return [
          {
            versions: ['8.0.0'],
            clusterUuid,
            ccs,
          },
        ];
      });
      const alert = new KibanaVersionMismatchAlert();
      const type = alert.getAlertType();
      await type.executor({
        ...executorOptions,
        params: alert.alertOptions.defaultParams,
      } as any);
      expect(replaceState).not.toHaveBeenCalledWith({});
      expect(scheduleActions).not.toHaveBeenCalled();
    });
  });
});
