/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { CpuUsageRule } from './cpu_usage_rule';
import { RULE_CPU_USAGE } from '../../common/constants';
import { fetchCpuUsageNodeStats } from '../lib/alerts/fetch_cpu_usage_node_stats';
import { fetchClusters } from '../lib/alerts/fetch_clusters';
import { elasticsearchServiceMock } from '@kbn/core/server/mocks';

const RealDate = Date;

jest.mock('../lib/alerts/fetch_cpu_usage_node_stats', () => ({
  fetchCpuUsageNodeStats: jest.fn(),
}));
jest.mock('../lib/alerts/fetch_clusters', () => ({
  fetchClusters: jest.fn(),
}));
jest.mock('../static_globals', () => ({
  Globals: {
    app: {
      getLogger: () => ({ debug: jest.fn() }),
      url: 'http://localhost:5601',
      config: {
        ui: {
          ccs: { enabled: true },
          container: { elasticsearch: { enabled: false } },
        },
      },
    },
  },
}));

describe('CpuUsageRule', () => {
  it('should have defaults', () => {
    const rule = new CpuUsageRule();
    expect(rule.ruleOptions.id).toBe(RULE_CPU_USAGE);
    expect(rule.ruleOptions.name).toBe('CPU Usage');
    expect(rule.ruleOptions.throttle).toBe('1d');
    expect(rule.ruleOptions.defaultParams).toStrictEqual({ threshold: 85, duration: '5m' });
    expect(rule.ruleOptions.actionVariables).toStrictEqual([
      { name: 'node', description: 'The node reporting high CPU usage.' },
      {
        name: 'internalShortMessage',
        description: 'The short internal message generated by Elastic.',
      },
      {
        name: 'internalFullMessage',
        description: 'The full internal message generated by Elastic.',
      },
      { name: 'state', description: 'The current state of the alert.' },
      { name: 'clusterName', description: 'The cluster to which the node(s) belongs.' },
      { name: 'action', description: 'The recommended action for this alert.' },
      {
        name: 'actionPlain',
        description: 'The recommended action for this alert, without any markdown.',
      },
    ]);
  });

  describe('execute', () => {
    function FakeDate() {}
    FakeDate.prototype.valueOf = () => 1;

    const clusterUuid = 'abc123';
    const clusterName = 'testCluster';
    const nodeId = 'myNodeId';
    const nodeName = 'myNodeName';
    const cpuUsage = 91;
    const stat = {
      clusterUuid,
      nodeId,
      nodeName,
      cpuUsage,
    };

    const replaceState = jest.fn();
    const scheduleActions = jest.fn();
    const getState = jest.fn();
    const executorOptions = {
      services: {
        scopedClusterClient: elasticsearchServiceMock.createScopedClusterClient(),
        alertFactory: {
          create: jest.fn().mockImplementation(() => {
            return {
              replaceState,
              scheduleActions,
              getState,
            };
          }),
        },
      },
      state: {},
    };

    beforeEach(() => {
      // @ts-ignore
      Date = FakeDate;
      (fetchCpuUsageNodeStats as jest.Mock).mockImplementation(() => {
        return [stat];
      });
      (fetchClusters as jest.Mock).mockImplementation(() => {
        return [{ clusterUuid, clusterName }];
      });
    });

    afterEach(() => {
      Date = RealDate;
      replaceState.mockReset();
      scheduleActions.mockReset();
      getState.mockReset();
    });

    it('should fire actions when threshold is exceeded', async () => {
      const rule = new CpuUsageRule();
      const type = rule.getRuleType();
      await type.executor({
        ...executorOptions,
        params: rule.ruleOptions.defaultParams,
      } as any);
      const count = 1;
      const threshold = rule.ruleOptions.defaultParams?.threshold;
      expect(replaceState).toHaveBeenCalledWith({
        alertStates: [
          {
            ccs: undefined,
            cluster: { clusterUuid, clusterName },
            cpuUsage,
            itemLabel: undefined,
            meta: {
              clusterUuid,
              cpuUsage,
              nodeId,
              nodeName,
              threshold,
            },
            nodeId,
            nodeName,
            ui: {
              isFiring: true,
              message: {
                text: `Node #start_link${nodeName}#end_link is reporting CPU usage of ${cpuUsage}% which is above the configured threshold of ${threshold}%. Last checked at #absolute`,
                nextSteps: [
                  {
                    text: '#start_linkCheck hot threads#end_link',
                    tokens: [
                      {
                        startToken: '#start_link',
                        endToken: '#end_link',
                        type: 'docLink',
                        partialUrl:
                          '{elasticWebsiteUrl}guide/en/elasticsearch/reference/{docLinkVersion}/cluster-nodes-hot-threads.html',
                      },
                    ],
                  },
                  {
                    text: '#start_linkCheck long running tasks#end_link',
                    tokens: [
                      {
                        startToken: '#start_link',
                        endToken: '#end_link',
                        type: 'docLink',
                        partialUrl:
                          '{elasticWebsiteUrl}guide/en/elasticsearch/reference/{docLinkVersion}/tasks.html',
                      },
                    ],
                  },
                ],
                tokens: [
                  {
                    startToken: '#start_link',
                    endToken: '#end_link',
                    type: 'link',
                    url: 'elasticsearch/nodes/myNodeId',
                  },
                  {
                    startToken: '#absolute',
                    type: 'time',
                    isAbsolute: true,
                    isRelative: false,
                    timestamp: 1,
                  },
                ],
              },
              severity: 'danger',
              triggeredMS: 1,
              lastCheckedMS: 0,
            },
          },
        ],
      });
      expect(scheduleActions).toHaveBeenCalledWith('default', {
        internalFullMessage: `CPU usage alert is firing for node ${nodeName} in cluster ${clusterName}. [View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid}))`,
        internalShortMessage: `CPU usage alert is firing for node ${nodeName} in cluster ${clusterName}. Verify CPU usage of node.`,
        action: `[View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid}))`,
        actionPlain: 'Verify CPU usage of node.',
        clusterName,
        count,
        nodes: `${nodeName}:${cpuUsage}`,
        node: `${nodeName}:${cpuUsage}`,
        state: 'firing',
      });
    });

    it('should not fire actions if under threshold', async () => {
      (fetchCpuUsageNodeStats as jest.Mock).mockImplementation(() => {
        return [
          {
            ...stat,
            cpuUsage: 1,
          },
        ];
      });
      const rule = new CpuUsageRule();
      const type = rule.getRuleType();
      await type.executor({
        ...executorOptions,
        params: rule.ruleOptions.defaultParams,
      } as any);
      expect(replaceState).toHaveBeenCalledWith({
        alertStates: [],
      });
      expect(scheduleActions).not.toHaveBeenCalled();
    });

    it('should handle ccs', async () => {
      const ccs = 'testCluster';
      (fetchCpuUsageNodeStats as jest.Mock).mockImplementation(() => {
        return [
          {
            ...stat,
            ccs,
          },
        ];
      });
      const rule = new CpuUsageRule();
      const type = rule.getRuleType();
      await type.executor({
        ...executorOptions,
        params: rule.ruleOptions.defaultParams,
      } as any);
      const count = 1;
      expect(scheduleActions).toHaveBeenCalledWith('default', {
        internalFullMessage: `CPU usage alert is firing for node ${nodeName} in cluster ${clusterName}. [View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid},ccs:${ccs}))`,
        internalShortMessage: `CPU usage alert is firing for node ${nodeName} in cluster ${clusterName}. Verify CPU usage of node.`,
        action: `[View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid},ccs:testCluster))`,
        actionPlain: 'Verify CPU usage of node.',
        clusterName,
        count,
        nodes: `${nodeName}:${cpuUsage}`,
        node: `${nodeName}:${cpuUsage}`,
        state: 'firing',
      });
    });

    it('should fire actions when resource limits are missing', async () => {
      (fetchCpuUsageNodeStats as jest.Mock).mockImplementation(() => {
        return [
          {
            ...stat,
            missingLimits: true,
          },
        ];
      });

      const rule = new CpuUsageRule();
      const type = rule.getRuleType();
      await type.executor({
        ...executorOptions,
        params: rule.ruleOptions.defaultParams,
      } as any);
      const count = 1;
      const threshold = rule.ruleOptions.defaultParams?.threshold;
      expect(replaceState).toHaveBeenCalledWith({
        alertStates: [
          {
            ccs: undefined,
            cluster: { clusterUuid, clusterName },
            cpuUsage,
            itemLabel: undefined,
            meta: {
              clusterUuid,
              cpuUsage,
              nodeId,
              nodeName,
              threshold,
              missingLimits: true,
            },
            nodeId,
            nodeName,
            ui: {
              isFiring: true,
              message: {
                text: `Kibana is configured for containerized workloads but node #start_linkmyNodeName#end_link does not have resource limits configured. Fallback metric reports usage of ${cpuUsage}%. Last checked at #absolute`,
                tokens: [
                  {
                    startToken: '#start_link',
                    endToken: '#end_link',
                    type: 'link',
                    url: 'elasticsearch/nodes/myNodeId',
                  },
                  {
                    startToken: '#absolute',
                    type: 'time',
                    isAbsolute: true,
                    isRelative: false,
                    timestamp: 1,
                  },
                ],
              },
              severity: 'danger',
              triggeredMS: 1,
              lastCheckedMS: 0,
            },
          },
        ],
      });
      expect(scheduleActions).toHaveBeenCalledWith('default', {
        internalFullMessage: `CPU usage alert for node ${nodeName} in cluster ${clusterName} faced issues while evaluating the usage. [View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid}))`,
        internalShortMessage: `CPU usage alert for node ${nodeName} in cluster ${clusterName} faced issues while evaluating the usage. Verify CPU usage of node.`,
        action: `[View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid}))`,
        actionPlain: 'Verify CPU usage of node.',
        clusterName,
        count,
        nodes: `${nodeName}:${cpuUsage}`,
        node: `${nodeName}:${cpuUsage}`,
        state: 'firing',
      });
    });

    it('should fire actions when resource limits have changed', async () => {
      (fetchCpuUsageNodeStats as jest.Mock).mockImplementation(() => {
        return [
          {
            ...stat,
            limitsChanged: true,
          },
        ];
      });

      const rule = new CpuUsageRule();
      const type = rule.getRuleType();
      await type.executor({
        ...executorOptions,
        params: rule.ruleOptions.defaultParams,
      } as any);
      const count = 1;
      const threshold = rule.ruleOptions.defaultParams?.threshold;
      expect(replaceState).toHaveBeenCalledWith({
        alertStates: [
          {
            ccs: undefined,
            cluster: { clusterUuid, clusterName },
            cpuUsage,
            itemLabel: undefined,
            meta: {
              clusterUuid,
              cpuUsage,
              nodeId,
              nodeName,
              threshold,
              limitsChanged: true,
            },
            nodeId,
            nodeName,
            ui: {
              isFiring: true,
              message: {
                text: 'Resource limits for node #start_linkmyNodeName#end_link has changed within the look back window, unable to confidently calculate CPU usage for alerting. Please monitor the usage until the window has moved. Last checked at #absolute',
                tokens: [
                  {
                    startToken: '#start_link',
                    endToken: '#end_link',
                    type: 'link',
                    url: 'elasticsearch/nodes/myNodeId',
                  },
                  {
                    startToken: '#absolute',
                    type: 'time',
                    isAbsolute: true,
                    isRelative: false,
                    timestamp: 1,
                  },
                ],
              },
              severity: 'danger',
              triggeredMS: 1,
              lastCheckedMS: 0,
            },
          },
        ],
      });
      expect(scheduleActions).toHaveBeenCalledWith('default', {
        internalFullMessage: `CPU usage alert for node ${nodeName} in cluster ${clusterName} faced issues while evaluating the usage. [View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid}))`,
        internalShortMessage: `CPU usage alert for node ${nodeName} in cluster ${clusterName} faced issues while evaluating the usage. Verify CPU usage of node.`,
        action: `[View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid}))`,
        actionPlain: 'Verify CPU usage of node.',
        clusterName,
        count,
        nodes: `${nodeName}:${cpuUsage}`,
        node: `${nodeName}:${cpuUsage}`,
        state: 'firing',
      });
    });

    it('should fire actions when resource limits are set but not expected', async () => {
      (fetchCpuUsageNodeStats as jest.Mock).mockImplementation(() => {
        return [
          {
            ...stat,
            unexpectedLimits: true,
          },
        ];
      });

      const rule = new CpuUsageRule();
      const type = rule.getRuleType();
      await type.executor({
        ...executorOptions,
        params: rule.ruleOptions.defaultParams,
      } as any);
      const count = 1;
      const threshold = rule.ruleOptions.defaultParams?.threshold;
      expect(replaceState).toHaveBeenCalledWith({
        alertStates: [
          {
            ccs: undefined,
            cluster: { clusterUuid, clusterName },
            cpuUsage,
            itemLabel: undefined,
            meta: {
              clusterUuid,
              cpuUsage,
              nodeId,
              nodeName,
              threshold,
              unexpectedLimits: true,
            },
            nodeId,
            nodeName,
            ui: {
              isFiring: true,
              message: {
                text: `Kibana is configured for non-containerized workloads but node #start_linkmyNodeName#end_link has resource limits configured. Node reports usage of ${cpuUsage}%. Last checked at #absolute`,
                tokens: [
                  {
                    startToken: '#start_link',
                    endToken: '#end_link',
                    type: 'link',
                    url: 'elasticsearch/nodes/myNodeId',
                  },
                  {
                    startToken: '#absolute',
                    type: 'time',
                    isAbsolute: true,
                    isRelative: false,
                    timestamp: 1,
                  },
                ],
              },
              severity: 'danger',
              triggeredMS: 1,
              lastCheckedMS: 0,
            },
          },
        ],
      });
      expect(scheduleActions).toHaveBeenCalledWith('default', {
        internalFullMessage: `CPU usage alert for node ${nodeName} in cluster ${clusterName} faced issues while evaluating the usage. [View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid}))`,
        internalShortMessage: `CPU usage alert for node ${nodeName} in cluster ${clusterName} faced issues while evaluating the usage. Verify CPU usage of node.`,
        action: `[View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid}))`,
        actionPlain: 'Verify CPU usage of node.',
        clusterName,
        count,
        nodes: `${nodeName}:${cpuUsage}`,
        node: `${nodeName}:${cpuUsage}`,
        state: 'firing',
      });
    });

    it('should fire actions when it fails to calculate CPU usage', async () => {
      (fetchCpuUsageNodeStats as jest.Mock).mockImplementation(() => {
        return [
          {
            ...stat,
            cpuUsage: undefined,
          },
        ];
      });

      const rule = new CpuUsageRule();
      const type = rule.getRuleType();
      await type.executor({
        ...executorOptions,
        params: rule.ruleOptions.defaultParams,
      } as any);
      const count = 1;
      const threshold = rule.ruleOptions.defaultParams?.threshold;
      expect(replaceState).toHaveBeenCalledWith({
        alertStates: [
          {
            ccs: undefined,
            cluster: { clusterUuid, clusterName },
            cpuUsage: undefined,
            itemLabel: undefined,
            meta: {
              clusterUuid,
              cpuUsage: undefined,
              nodeId,
              nodeName,
              threshold,
            },
            nodeId,
            nodeName,
            ui: {
              isFiring: true,
              message: {
                text: 'Failed to compute CPU usage for node #start_linkmyNodeName#end_link. Please check the Kibana logs for more details. Last checked at #absolute',
                tokens: [
                  {
                    startToken: '#start_link',
                    endToken: '#end_link',
                    type: 'link',
                    url: 'elasticsearch/nodes/myNodeId',
                  },
                  {
                    startToken: '#absolute',
                    type: 'time',
                    isAbsolute: true,
                    isRelative: false,
                    timestamp: 1,
                  },
                ],
              },
              severity: 'warning',
              triggeredMS: 1,
              lastCheckedMS: 0,
            },
          },
        ],
      });
      expect(scheduleActions).toHaveBeenCalledWith('default', {
        internalFullMessage: `CPU usage alert for node ${nodeName} in cluster ${clusterName} faced issues while evaluating the usage. [View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid}))`,
        internalShortMessage: `CPU usage alert for node ${nodeName} in cluster ${clusterName} faced issues while evaluating the usage. Verify CPU usage of node.`,
        action: `[View node](http://localhost:5601/app/monitoring#/elasticsearch/nodes/${nodeId}?_g=(cluster_uuid:${clusterUuid}))`,
        actionPlain: 'Verify CPU usage of node.',
        clusterName,
        count,
        nodes: `${nodeName}:undefined`,
        node: `${nodeName}:undefined`,
        state: 'firing',
      });
    });
  });
});
