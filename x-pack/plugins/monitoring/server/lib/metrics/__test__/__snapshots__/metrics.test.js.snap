// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Metrics should export metric objects that match a snapshot 1`] = `
Object {
  "apm_cpu_total": ApmCpuUtilizationMetric {
    "app": "apm",
    "calculation": [Function],
    "derivative": true,
    "description": "Percentage of CPU time spent executing (user+kernel mode) for the APM process",
    "field": "beats_stats.metrics.beat.cpu.total.value",
    "format": "0.[00]",
    "label": "Total",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "CPU Utilization",
    "units": "%",
    "uuidField": "beats_stats.beat.uuid",
  },
  "apm_mem_alloc": ApmMetric {
    "app": "apm",
    "derivative": false,
    "description": "Allocated memory",
    "field": "beats_stats.metrics.beat.memstats.memory_alloc",
    "format": "0,0.0 b",
    "label": "Allocated Memory",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Memory",
    "units": "B",
    "uuidField": "beats_stats.beat.uuid",
  },
  "apm_mem_gc_next": ApmMetric {
    "app": "apm",
    "derivative": false,
    "description": "Limit of allocated memory at which garbage collection will occur",
    "field": "beats_stats.metrics.beat.memstats.gc_next",
    "format": "0,0.0 b",
    "label": "GC Next",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Memory",
    "units": "B",
    "uuidField": "beats_stats.beat.uuid",
  },
  "apm_mem_rss": ApmMetric {
    "app": "apm",
    "derivative": false,
    "description": "Resident set size of memory reserved by the APM service from the OS",
    "field": "beats_stats.metrics.beat.memstats.rss",
    "format": "0,0.0 b",
    "label": "Process Total",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Memory",
    "units": "B",
    "uuidField": "beats_stats.beat.uuid",
  },
  "apm_output_events_acked": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.events.acked",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "Events processed by the output (including retries)",
    "field": "beats_stats.metrics.libbeat.output.events.acked",
    "format": "0,0.[00]",
    "label": "Acked",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Output Acked Events Rate",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_output_events_active": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.events.active",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "Events processed by the output (including retries)",
    "field": "beats_stats.metrics.libbeat.output.events.active",
    "format": "0,0.[00]",
    "label": "Active",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Output Active Events Rate",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_output_events_dropped": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.events.dropped",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "Events processed by the output (including retries)",
    "field": "beats_stats.metrics.libbeat.output.events.dropped",
    "format": "0,0.[00]",
    "label": "Dropped",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Output Dropped Events Rate",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_output_events_failed": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.events.failed",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "Events processed by the output (including retries)",
    "field": "beats_stats.metrics.libbeat.output.events.failed",
    "format": "0,0.[00]",
    "label": "Failed",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Output Failed Events Rate",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_output_events_total": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.events.total",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "Events processed by the output (including retries)",
    "field": "beats_stats.metrics.libbeat.output.events.total",
    "format": "0,0.[00]",
    "label": "Total",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Output Events Rate",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_processor_error_transformations": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.processor.error.transformations",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "Error events processed",
    "field": "beats_stats.metrics.apm-server.processor.error.transformations",
    "format": "0,0.[00]",
    "label": "Error",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Transformations",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_processor_metric_transformations": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.processor.metric.transformations",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "Metric events processed",
    "field": "beats_stats.metrics.apm-server.processor.metric.transformations",
    "format": "0,0.[00]",
    "label": "Metric",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Transformations",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_processor_span_transformations": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.processor.span.transformations",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "Span events processed",
    "field": "beats_stats.metrics.apm-server.processor.span.transformations",
    "format": "0,0.[00]",
    "label": "Span",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Transformations",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_processor_transaction_transformations": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.processor.transaction.transformations",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "Transaction events processed",
    "field": "beats_stats.metrics.apm-server.processor.transaction.transformations",
    "format": "0,0.[00]",
    "label": "Transaction",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Processed Events",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_requests": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.request.count",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests received by server",
    "field": "beats_stats.metrics.apm-server.server.request.count",
    "format": "0,0.[00]",
    "label": "Requested",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Request Count Intake API",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_count": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.count",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests responded to by server",
    "field": "beats_stats.metrics.apm-server.server.response.count",
    "format": "0,0.[00]",
    "label": "Total",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Response Count Intake API",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_closed": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.closed",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests rejected during server shutdown",
    "field": "beats_stats.metrics.apm-server.server.response.errors.closed",
    "format": "0,0.[00]",
    "label": "Closed",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Closed",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_concurrency": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.concurrency",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests rejected due to overall concurrency limit breach",
    "field": "beats_stats.metrics.apm-server.server.response.errors.concurrency",
    "format": "0,0.[00]",
    "label": "Concurrency",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Concurrency",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_decode": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.decode",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests rejected to due decoding errors - invalid json, incorrect data type for entity",
    "field": "beats_stats.metrics.apm-server.server.response.errors.decode",
    "format": "0,0.[00]",
    "label": "Decode",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Decode",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_forbidden": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.forbidden",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "Forbidden HTTP Requests rejected - CORS violation, disabled enpoint",
    "field": "beats_stats.metrics.apm-server.server.response.errors.forbidden",
    "format": "0,0.[00]",
    "label": "Forbidden",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Forbidden",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_internal": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.internal",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests rejected due to a miscellaneous internal error",
    "field": "beats_stats.metrics.apm-server.server.response.errors.internal",
    "format": "0,0.[00]",
    "label": "Internal",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Internal",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_method": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.method",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests rejected due to incorrect HTTP method",
    "field": "beats_stats.metrics.apm-server.server.response.errors.method",
    "format": "0,0.[00]",
    "label": "Method",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Method",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_queue": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.queue",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests rejected to due internal queue filling up",
    "field": "beats_stats.metrics.apm-server.server.response.errors.queue",
    "format": "0,0.[00]",
    "label": "Queue",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Queue",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_ratelimit": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.ratelimit",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests rejected to due excessive rate limit",
    "field": "beats_stats.metrics.apm-server.server.response.errors.ratelimit",
    "format": "0,0.[00]",
    "label": "Rate limit",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Rate limit",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_toolarge": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.toolarge",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests rejected due to excessive payload size",
    "field": "beats_stats.metrics.apm-server.server.response.errors.toolarge",
    "format": "0,0.[00]",
    "label": "Too large",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Response Errors Intake API",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_unauthorized": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.unauthorized",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests rejected due to invalid secret token",
    "field": "beats_stats.metrics.apm-server.server.response.errors.unauthorized",
    "format": "0,0.[00]",
    "label": "Unauthorized",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Unauthorized",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_errors_validate": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.errors.validate",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests rejected due to payload validation error",
    "field": "beats_stats.metrics.apm-server.server.response.errors.validate",
    "format": "0,0.[00]",
    "label": "Validate",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Validate",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_valid_accepted": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.valid.accepted",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "HTTP Requests successfully reporting new events",
    "field": "beats_stats.metrics.apm-server.server.response.valid.accepted",
    "format": "0,0.[00]",
    "label": "Accepted",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Accepted",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_responses_valid_ok": ApmEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.apm-server.server.response.valid.ok",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1m",
        },
      },
    },
    "app": "apm",
    "derivative": true,
    "description": "200 OK response count",
    "field": "beats_stats.metrics.apm-server.server.response.valid.ok",
    "format": "0,0.[00]",
    "label": "Ok",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Ok",
    "units": "/m",
    "uuidField": "cluster_uuid",
  },
  "apm_system_os_load_1": ApmMetric {
    "app": "apm",
    "derivative": false,
    "description": "Load average over the last 1 minute",
    "field": "beats_stats.metrics.system.load.1",
    "format": "0,0.[00]",
    "label": "1m",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "beats_stats.beat.uuid",
  },
  "apm_system_os_load_15": ApmMetric {
    "app": "apm",
    "derivative": false,
    "description": "Load average over the last 15 minutes",
    "field": "beats_stats.metrics.system.load.15",
    "format": "0,0.[00]",
    "label": "15m",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "beats_stats.beat.uuid",
  },
  "apm_system_os_load_5": ApmMetric {
    "app": "apm",
    "derivative": false,
    "description": "Load average over the last 5 minutes",
    "field": "beats_stats.metrics.system.load.5",
    "format": "0,0.[00]",
    "label": "5m",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_bytes_written": BeatsByteRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "Bytes written to the output (consists of size of network headers and compressed payload)",
    "field": "beats_stats.metrics.libbeat.output.write.bytes",
    "format": "0,0.0 b",
    "label": "Bytes Sent",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Throughput",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_cluster_output_events_ack_rate": BeatsEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.events.acked",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "Events acknowledged by the output (includes events dropped by the output)",
    "field": "beats_stats.metrics.libbeat.output.events.acked",
    "format": "0,0.[00]",
    "label": "Acknowledged",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Events Rate",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_output_events_dropped_rate": BeatsEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.events.dropped",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "(Fatal drop) Events dropped by the output as being \\"invalid.\\" The output still acknowledges the event for the Beat to remove it from the queue.",
    "field": "beats_stats.metrics.libbeat.output.events.dropped",
    "format": "0,0.[00]",
    "label": "Dropped in Output",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Fail Rates",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_output_events_total": BeatsEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.events.total",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "Events processed by the output (including retries)",
    "field": "beats_stats.metrics.libbeat.output.events.total",
    "format": "0,0.[00]",
    "label": "Emitted",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Events Rate",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_output_read_bytes_rate": BeatsByteRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.read.bytes",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "Bytes read in response from the output",
    "field": "beats_stats.metrics.libbeat.output.read.bytes",
    "format": "0,0.[00]",
    "label": "Bytes Received",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Throughput",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_output_receiving_errors": BeatsEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.read.errors",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "Errors in reading the response from the output",
    "field": "beats_stats.metrics.libbeat.output.read.errors",
    "format": "0,0.[00]",
    "label": "Receiving",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Output Errors",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_output_sending_errors": BeatsEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.write.errors",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "Errors in writing the response from the output",
    "field": "beats_stats.metrics.libbeat.output.write.errors",
    "format": "0,0.[00]",
    "label": "Sending",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Output Errors",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_output_write_bytes_rate": BeatsByteRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.output.write.bytes",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "Bytes written to the output (consists of size of network headers and compressed payload)",
    "field": "beats_stats.metrics.libbeat.output.write.bytes",
    "format": "0,0.[00]",
    "label": "Bytes Sent",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Throughput",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_pipeline_events_dropped_rate": BeatsEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.pipeline.events.dropped",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "Events that have been dropped after N retries (N = max_retries setting)",
    "field": "beats_stats.metrics.libbeat.pipeline.events.dropped",
    "format": "0,0.[00]",
    "label": "Dropped in Pipeline",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Fail Rates",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_pipeline_events_emitted_rate": BeatsEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.pipeline.events.published",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "Events added to the event pipeline queue",
    "field": "beats_stats.metrics.libbeat.pipeline.events.published",
    "format": "0,0.[00]",
    "label": "Queued",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Events Rate",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_pipeline_events_failed_rate": BeatsEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.pipeline.events.failed",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "Failures that happened before event was added to the publishing pipeline (output was disabled or publisher client closed)",
    "field": "beats_stats.metrics.libbeat.pipeline.events.failed",
    "format": "0,0.[00]",
    "label": "Failed in Pipeline",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Fail Rates",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_pipeline_events_retry_rate": BeatsEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.pipeline.events.retry",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "Events in the pipeline that are trying again to be sent to the output",
    "field": "beats_stats.metrics.libbeat.pipeline.events.retry",
    "format": "0,0.[00]",
    "label": "Retry in Pipeline",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Fail Rates",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cluster_pipeline_events_total_rate": BeatsEventsRateClusterMetric {
    "aggs": Object {
      "beats_uuids": Object {
        "aggs": Object {
          "event_rate_per_beat": Object {
            "max": Object {
              "field": "beats_stats.metrics.libbeat.pipeline.events.total",
            },
          },
        },
        "terms": Object {
          "field": "beats_stats.beat.uuid",
          "size": 10000,
        },
      },
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "beats_uuids>event_rate_per_beat",
          "gap_policy": "skip",
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "beats",
    "derivative": true,
    "description": "All events newly created in the publishing pipeline",
    "field": "beats_stats.metrics.libbeat.pipeline.events.total",
    "format": "0,0.[00]",
    "label": "Total",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Events Rate",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "beat_cpu_utilization": BeatsCpuUtilizationMetric {
    "app": "beats",
    "calculation": [Function],
    "derivative": true,
    "description": "Percentage of CPU time spent executing (user+kernel mode) for the Beat process",
    "field": "beats_stats.metrics.beat.cpu.total.value",
    "format": "0.[00]",
    "label": "Total",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "CPU Utilization",
    "units": "%",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_handles_open": BeatsMetric {
    "app": "beats",
    "derivative": false,
    "description": "Count of open file handlers",
    "field": "beats_stats.metrics.beat.handles.open",
    "format": "0.[00]",
    "label": "Open Handles",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Open Handles",
    "units": "",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_mem_alloc": BeatsMetric {
    "app": "beats",
    "derivative": false,
    "description": "Private memory in active use by the Beat",
    "field": "beats_stats.metrics.beat.memstats.memory_alloc",
    "format": "0,0.0 b",
    "label": "Active",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Memory",
    "units": "B",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_mem_gc_next": BeatsMetric {
    "app": "beats",
    "derivative": false,
    "description": "Limit of allocated memory at which garbage collection will occur",
    "field": "beats_stats.metrics.beat.memstats.gc_next",
    "format": "0,0.0 b",
    "label": "GC Next",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Memory",
    "units": "B",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_mem_rss": BeatsMetric {
    "app": "beats",
    "derivative": false,
    "description": "Resident set size of memory reserved by the Beat from the OS",
    "field": "beats_stats.metrics.beat.memstats.rss",
    "format": "0,0.0 b",
    "label": "Process Total",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Memory",
    "units": "B",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_output_events_ack_rate": BeatsEventsRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "Events acknowledged by the output (includes events dropped by the output)",
    "field": "beats_stats.metrics.libbeat.output.events.acked",
    "format": "0,0.[00]",
    "label": "Acknowledged",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Events Rate",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_output_events_dropped_rate": BeatsEventsRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "(Fatal drop) Events dropped by the output as being \\"invalid.\\" The output still acknowledges the event for the Beat to remove it from the queue.",
    "field": "beats_stats.metrics.libbeat.output.events.dropped",
    "format": "0,0.[00]",
    "label": "Dropped in Output",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Fail Rates",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_output_events_total": BeatsEventsRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "Events processed by the output (including retries)",
    "field": "beats_stats.metrics.libbeat.output.events.total",
    "format": "0,0.[00]",
    "label": "Emitted",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Events Rate",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_output_receiving_errors": BeatsEventsRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "Errors in reading the response from the output",
    "field": "beats_stats.metrics.libbeat.output.read.errors",
    "format": "0,0.[00]",
    "label": "Receiving",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Output Errors",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_output_sending_errors": BeatsEventsRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "Errors in writing the response from the output",
    "field": "beats_stats.metrics.libbeat.output.write.errors",
    "format": "0,0.[00]",
    "label": "Sending",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Output Errors",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_output_write_bytes_rate": BeatsByteRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "Bytes read in response from the output",
    "field": "beats_stats.metrics.libbeat.output.read.bytes",
    "format": "0,0.0 b",
    "label": "Bytes Received",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Throughput",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_pipeline_events_dropped_rate": BeatsEventsRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "Events that have been dropped after N retries (N = max_retries setting)",
    "field": "beats_stats.metrics.libbeat.pipeline.events.dropped",
    "format": "0,0.[00]",
    "label": "Dropped in Pipeline",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Fail Rates",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_pipeline_events_emitted_rate": BeatsEventsRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "Events added to the event pipeline queue",
    "field": "beats_stats.metrics.libbeat.pipeline.events.published",
    "format": "0,0.[00]",
    "label": "Queued",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Events Rate",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_pipeline_events_failed_rate": BeatsEventsRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "Failures that happened before event was added to the publishing pipeline (output was disabled or publisher client closed)",
    "field": "beats_stats.metrics.libbeat.pipeline.events.failed",
    "format": "0,0.[00]",
    "label": "Failed in Pipeline",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Fail Rates",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_pipeline_events_retry_rate": BeatsEventsRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "Events in the pipeline that are trying again to be sent to the output",
    "field": "beats_stats.metrics.libbeat.pipeline.events.retry",
    "format": "0,0.[00]",
    "label": "Retry in Pipeline",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Fail Rates",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_pipeline_events_total_rate": BeatsEventsRateMetric {
    "app": "beats",
    "derivative": true,
    "description": "New events sent to the publishing pipeline",
    "field": "beats_stats.metrics.libbeat.pipeline.events.total",
    "format": "0,0.[00]",
    "label": "New",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "Events Rate",
    "units": "/s",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_system_os_load_1": BeatsMetric {
    "app": "beats",
    "derivative": false,
    "description": "Load average over the last 1 minute",
    "field": "beats_stats.metrics.system.load.1",
    "format": "0,0.[00]",
    "label": "1m",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_system_os_load_15": BeatsMetric {
    "app": "beats",
    "derivative": false,
    "description": "Load average over the last 15 minutes",
    "field": "beats_stats.metrics.system.load.15",
    "format": "0,0.[00]",
    "label": "15m",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "beats_stats.beat.uuid",
  },
  "beat_system_os_load_5": BeatsMetric {
    "app": "beats",
    "derivative": false,
    "description": "Load average over the last 5 minutes",
    "field": "beats_stats.metrics.system.load.5",
    "format": "0,0.[00]",
    "label": "5m",
    "metricAgg": "max",
    "timestampField": "beats_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "beats_stats.beat.uuid",
  },
  "ccr_sync_lag_ops": DifferenceMetric {
    "aggs": Object {
      "metric2_max": Object {
        "max": Object {
          "field": "ccr_stats.follower_global_checkpoint",
        },
      },
      "metric_max": Object {
        "max": Object {
          "field": "ccr_stats.leader_max_seq_no",
        },
      },
    },
    "app": "elasticsearch",
    "calculation": [Function],
    "derivative": false,
    "description": "The number of operations the follower index is lagging behind the leader.",
    "field": "",
    "format": "0,0.[00]",
    "getFields": [Function],
    "label": "Ops delay",
    "metricAgg": "sum",
    "timestampField": "timestamp",
    "title": "Ops delay",
    "type": "ccr",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "ccr_sync_lag_time": MillisecondsToSecondsMetric {
    "app": "elasticsearch",
    "calculation": [Function],
    "derivative": false,
    "description": "The amount of time the follower index is lagging behind the leader.",
    "field": "ccr_stats.time_since_last_read_millis",
    "format": "0.[00]",
    "label": "Fetch delay",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Fetch delay",
    "type": "ccr",
    "units": "s",
    "uuidField": "source_node.uuid",
  },
  "cluster_index_latency": LatencyMetric {
    "aggs": Object {
      "event_time_in_millis": Object {
        "max": Object {
          "field": "indices_stats._all.primaries.indexing.index_time_in_millis",
        },
      },
      "event_time_in_millis_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_time_in_millis",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "event_total": Object {
        "max": Object {
          "field": "indices_stats._all.primaries.indexing.index_total",
        },
      },
      "event_total_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_total",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "elasticsearch",
    "calculation": [Function],
    "derivative": false,
    "description": "Average latency for indexing documents, which is time it takes to index documents divided by number that were indexed. This only considers primary shards.",
    "field": "indices_stats._all.primaries.indexing.index_total",
    "format": "0,0.[00]",
    "label": "Indexing Latency",
    "metricAgg": "sum",
    "timestampField": "timestamp",
    "type": "cluster",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "cluster_index_request_rate_primary": RequestRateMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of documents being indexed for primary shards.",
    "field": "indices_stats._all.primaries.indexing.index_total",
    "format": "0,0.[00]",
    "label": "Primary Shards",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Indexing Rate",
    "type": "index",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
  "cluster_index_request_rate_total": RequestRateMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of documents being indexed for primary and replica shards.",
    "field": "indices_stats._all.total.indexing.index_total",
    "format": "0,0.[00]",
    "label": "Total Shards",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Indexing Rate",
    "type": "index",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
  "cluster_query_latency": LatencyMetric {
    "aggs": Object {
      "event_time_in_millis": Object {
        "max": Object {
          "field": "indices_stats._all.total.search.query_time_in_millis",
        },
      },
      "event_time_in_millis_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_time_in_millis",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "event_total": Object {
        "max": Object {
          "field": "indices_stats._all.total.search.query_total",
        },
      },
      "event_total_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_total",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "elasticsearch",
    "calculation": [Function],
    "derivative": false,
    "description": "Average latency for searching, which is time it takes to execute searches divided by number of searches submitted. This considers primary and replica shards.",
    "field": "indices_stats._all.total.search.query_total",
    "format": "0,0.[00]",
    "label": "Search Latency",
    "metricAgg": "sum",
    "timestampField": "timestamp",
    "type": "cluster",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "cluster_search_request_rate": RequestRateMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of search requests being executed across primary and replica shards. A single search can run against multiple shards!",
    "field": "indices_stats._all.total.search.query_total",
    "format": "0,0.[00]",
    "label": "Total Shards",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Search Rate",
    "type": "cluster",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
  "index_document_count": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total number of documents, only including primary shards.",
    "field": "index_stats.primaries.docs.count",
    "format": "0,0.[0]a",
    "label": "Document Count",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "type": "index",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "index_index_latency": LatencyMetric {
    "aggs": Object {
      "event_time_in_millis": Object {
        "max": Object {
          "field": "index_stats.primaries.indexing.index_time_in_millis",
        },
      },
      "event_time_in_millis_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_time_in_millis",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "event_total": Object {
        "max": Object {
          "field": "index_stats.primaries.indexing.index_total",
        },
      },
      "event_total_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_total",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "elasticsearch",
    "calculation": [Function],
    "derivative": false,
    "description": "Average latency for indexing documents, which is time it takes to index documents divided by number that were indexed. This only considers primary shards.",
    "field": "index_stats.primaries.indexing.index_total",
    "format": "0,0.[00]",
    "label": "Indexing Latency",
    "metricAgg": "sum",
    "timestampField": "timestamp",
    "title": "Latency",
    "type": "cluster",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "index_indexing_primaries_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of time spent performing index operations on primary shards only.",
    "field": "index_stats.primaries.indexing.index_time_in_millis",
    "format": "0,0.[00]",
    "label": "Indexing (Primaries)",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Request Time",
    "type": "index",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "index_indexing_total": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of indexing operations.",
    "field": "index_stats.primaries.indexing.index_total",
    "format": "0,0.[00]",
    "label": "Index Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Request Rate",
    "type": "index",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "index_indexing_total_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of time spent performing index operations on primary and replica shards.",
    "field": "index_stats.total.indexing.index_time_in_millis",
    "format": "0,0.[00]",
    "label": "Indexing",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Request Time",
    "type": "index",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "index_mem_doc_values": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Doc Values. This is a part of Lucene Total.",
    "field": "index_stats.total.segments.doc_values_memory_in_bytes",
    "format": "0.0 b",
    "label": "Doc Values",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_fielddata": IndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Fielddata (e.g., global ordinals or explicitly enabled fielddata on text fields). This is for the same shards, but not a part of Lucene Total.",
    "field": "index_stats.total.fielddata.memory_size_in_bytes",
    "format": "0.0 b",
    "label": "Fielddata",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_fixed_bit_set": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Fixed Bit Sets (e.g., deeply nested documents). This is a part of Lucene Total.",
    "field": "index_stats.total.segments.fixed_bit_set_memory_in_bytes",
    "format": "0.0 b",
    "label": "Fixed Bitsets",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_norms": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Norms (normalization factors for query-time, text scoring). This is a part of Lucene Total.",
    "field": "index_stats.total.segments.norms_memory_in_bytes",
    "format": "0.0 b",
    "label": "Norms",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_overall": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap memory used by Lucene for current index. This is the sum of other fields for primary and replica shards.",
    "field": "index_stats.total.segments.memory_in_bytes",
    "format": "0.0 b",
    "label": "Lucene Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_overall_1": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap memory used by Lucene for current index. This is the sum of other fields for primary and replica shards.",
    "field": "index_stats.total.segments.memory_in_bytes",
    "format": "0.0 b",
    "label": "Lucene Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory - Lucene 1",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_overall_2": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap memory used by Lucene for current index. This is the sum of other fields for primary and replica shards.",
    "field": "index_stats.total.segments.memory_in_bytes",
    "format": "0.0 b",
    "label": "Lucene Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory - Lucene 2",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_overall_3": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap memory used by Lucene for current index. This is the sum of other fields for primary and replica shards.",
    "field": "index_stats.total.segments.memory_in_bytes",
    "format": "0.0 b",
    "label": "Lucene Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory - Lucene 3",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_points": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Points (e.g., numbers, IPs, and geo data). This is a part of Lucene Total.",
    "field": "index_stats.total.segments.points_memory_in_bytes",
    "format": "0.0 b",
    "label": "Points",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_query_cache": IndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Query Cache (e.g., cached filters). This is for the same shards, but not a part of Lucene Total.",
    "field": "index_stats.total.query_cache.memory_size_in_bytes",
    "format": "0.0 b",
    "label": "Query Cache",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory - Elasticsearch",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_request_cache": IndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Request Cache (e.g., instant aggregations). This is for the same shards, but not a part of Lucene Total.",
    "field": "index_stats.total.request_cache.memory_size_in_bytes",
    "format": "0.0 b",
    "label": "Request Cache",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_stored_fields": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Stored Fields (e.g., _source). This is a part of Lucene Total.",
    "field": "index_stats.total.segments.stored_fields_memory_in_bytes",
    "format": "0.0 b",
    "label": "Stored Fields",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_term_vectors": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Term Vectors. This is a part of Lucene Total.",
    "field": "index_stats.total.segments.term_vectors_memory_in_bytes",
    "format": "0.0 b",
    "label": "Term Vectors",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_terms": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Terms (e.g., text). This is a part of Lucene Total.",
    "field": "index_stats.total.segments.terms_memory_in_bytes",
    "format": "0.0 b",
    "label": "Terms",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_versions": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Versioning (e.g., updates and deletes). This is NOT a part of Lucene Total.",
    "field": "index_stats.total.segments.version_map_memory_in_bytes",
    "format": "0.0 b",
    "label": "Version Map",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_mem_writer": SingleIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by the Index Writer. This is NOT a part of Lucene Total.",
    "field": "index_stats.total.segments.index_writer_memory_in_bytes",
    "format": "0.0 b",
    "label": "Index Writer",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_merge_rate": RequestRateMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount in bytes of merged segments. Larger numbers indicate heavier disk activity.",
    "field": "index_stats.total.merges.total_size_in_bytes",
    "format": "0,0.[00]",
    "label": "Merge Rate",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "type": "index",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
  "index_query_latency": LatencyMetric {
    "aggs": Object {
      "event_time_in_millis": Object {
        "max": Object {
          "field": "index_stats.total.search.query_time_in_millis",
        },
      },
      "event_time_in_millis_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_time_in_millis",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "event_total": Object {
        "max": Object {
          "field": "index_stats.total.search.query_total",
        },
      },
      "event_total_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_total",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "elasticsearch",
    "calculation": [Function],
    "derivative": false,
    "description": "Average latency for searching, which is time it takes to execute searches divided by number of searches submitted. This considers primary and replica shards.",
    "field": "index_stats.total.search.query_total",
    "format": "0,0.[00]",
    "label": "Search Latency",
    "metricAgg": "sum",
    "timestampField": "timestamp",
    "type": "cluster",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "index_refresh_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Time spent on Elasticsearch refresh for primary and replica shards.",
    "field": "index_stats.total.refresh.total_time_in_millis",
    "format": "0,0.[00]",
    "label": "Total Refresh Time",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "type": "index",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "index_request_rate_primary": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of documents being indexed for primary shards.",
    "field": "index_stats.primaries.indexing.index_total",
    "format": "0,0.[00]",
    "label": "Primary Shards",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Indexing Rate",
    "type": "index",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
  "index_request_rate_total": RequestRateMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of documents being indexed for primary and replica shards.",
    "field": "index_stats.total.indexing.index_total",
    "format": "0,0.[00]",
    "label": "Total Shards",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Indexing Rate",
    "type": "index",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
  "index_search_request_rate": RequestRateMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of search requests being executed across primary and replica shards. A single search can run against multiple shards!",
    "field": "index_stats.total.search.query_total",
    "format": "0,0.[00]",
    "label": "Total Shards",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Search Rate",
    "type": "index",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
  "index_searching_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of time spent performing search operations (per shard).",
    "field": "index_stats.total.search.query_time_in_millis",
    "format": "0,0.[00]",
    "label": "Search",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Request Time",
    "type": "index",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "index_searching_total": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of search operations (per shard).",
    "field": "index_stats.total.search.query_total",
    "format": "0,0.[00]",
    "label": "Search Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Request Rate",
    "type": "index",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "index_segment_count_primaries": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Number of segments for primary shards.",
    "field": "index_stats.primaries.segments.count",
    "format": "0,0.[00]",
    "label": "Primaries",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Segment Count",
    "type": "index",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "index_segment_count_total": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Number of segments for primary and replica shards.",
    "field": "index_stats.total.segments.count",
    "format": "0,0.[00]",
    "label": "Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Segment Count",
    "type": "index",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "index_segment_merge_primaries_size": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Size of merges on primary shards.",
    "field": "index_stats.primaries.merges.total_size_in_bytes",
    "format": "0,0.0 b",
    "label": "Merges (Primaries)",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Disk",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_segment_merge_total_size": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Size of merges on primary and replica shards.",
    "field": "index_stats.total.merges.total_size_in_bytes",
    "format": "0,0.0 b",
    "label": "Merges",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Disk",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_segment_refresh_primaries_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of time spent to perform refresh operations on primary shards.",
    "field": "index_stats.primaries.refresh.total_time_in_millis",
    "format": "0,0.[00]",
    "label": "Primaries",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Refresh Time",
    "type": "index",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "index_segment_refresh_total_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of time spent to perform refresh operations on primary and replica shards.",
    "field": "index_stats.total.refresh.total_time_in_millis",
    "format": "0,0.[00]",
    "label": "Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Refresh Time",
    "type": "index",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "index_store_primaries_size": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Size of primary shards on disk.",
    "field": "index_stats.primaries.store.size_in_bytes",
    "format": "0,0.0 b",
    "label": "Store (Primaries)",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Disk",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_store_total_size": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Size of primary and replica shards on disk.",
    "field": "index_stats.total.store.size_in_bytes",
    "format": "0,0.0 b",
    "label": "Store",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Disk",
    "type": "index",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "index_throttle_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of time spent with index throttling, which indicates slow merging.",
    "field": "index_stats.primaries.indexing.throttle_time_in_millis",
    "format": "0,0.[00]",
    "label": "Index Throttling Time",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "type": "index",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "index_throttling_indexing_primaries_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of time spent throttling index operations on primary shards.",
    "field": "index_stats.primaries.indexing.throttle_time_in_millis",
    "format": "0,0.[00]",
    "label": "Indexing (Primaries)",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Throttle Time",
    "type": "index",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "index_throttling_indexing_total_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of time spent throttling index operations on primary and replica shards.",
    "field": "index_stats.total.indexing.throttle_time_in_millis",
    "format": "0,0.[00]",
    "label": "Indexing",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Throttle Time",
    "type": "index",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "kibana_average_concurrent_connections": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Total number of open socket connections to the Kibana instance.",
    "field": "kibana_stats.concurrent_connections",
    "format": "0.[00]",
    "label": "HTTP Connections",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "units": "",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "kibana_average_response_times": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Average response time for client requests to the Kibana instance.",
    "field": "kibana_stats.response_times.average",
    "format": "0.[00]",
    "label": "Average",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "title": "Client Response Time",
    "units": "ms",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "kibana_cluster_average_response_times": KibanaEventsRateClusterMetric {
    "aggs": Object {
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "kibana_uuids>event_rate_per_instance",
          "gap_policy": "skip",
        },
      },
      "kibana_uuids": Object {
        "aggs": Object {
          "event_rate_per_instance": Object {
            "max": Object {
              "field": "kibana_stats.response_times.average",
            },
          },
        },
        "terms": Object {
          "field": "kibana_stats.kibana.uuid",
          "size": 1000,
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "kibana",
    "derivative": false,
    "description": "Average response time for client requests to the Kibana instance.",
    "field": "kibana_stats.response_times.average",
    "format": "0.[00]",
    "label": "Average",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "title": "Client Response Time",
    "units": "ms",
    "uuidField": "cluster_uuid",
  },
  "kibana_cluster_max_response_times": KibanaEventsRateClusterMetric {
    "aggs": Object {
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "kibana_uuids>event_rate_per_instance",
          "gap_policy": "skip",
        },
      },
      "kibana_uuids": Object {
        "aggs": Object {
          "event_rate_per_instance": Object {
            "max": Object {
              "field": "kibana_stats.response_times.max",
            },
          },
        },
        "terms": Object {
          "field": "kibana_stats.kibana.uuid",
          "size": 1000,
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "kibana",
    "derivative": false,
    "description": "Maximum response time for client requests to the Kibana instance.",
    "field": "kibana_stats.response_times.max",
    "format": "0.[00]",
    "label": "Max",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "title": "Client Response Time",
    "units": "ms",
    "uuidField": "cluster_uuid",
  },
  "kibana_cluster_requests": KibanaEventsRateClusterMetric {
    "aggs": Object {
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "kibana_uuids>event_rate_per_instance",
          "gap_policy": "skip",
        },
      },
      "kibana_uuids": Object {
        "aggs": Object {
          "event_rate_per_instance": Object {
            "max": Object {
              "field": "kibana_stats.requests.total",
            },
          },
        },
        "terms": Object {
          "field": "kibana_stats.kibana.uuid",
          "size": 1000,
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "kibana",
    "derivative": false,
    "description": "Total number of client requests received by the Kibana instance.",
    "field": "kibana_stats.requests.total",
    "format": "0.[00]",
    "label": "Client Requests",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "units": "",
    "uuidField": "cluster_uuid",
  },
  "kibana_max_response_times": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Maximum response time for client requests to the Kibana instance.",
    "field": "kibana_stats.response_times.max",
    "format": "0.[00]",
    "label": "Max",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "title": "Client Response Time",
    "units": "ms",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "kibana_memory_heap_size_limit": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Limit of memory usage before garbage collection.",
    "field": "kibana_stats.process.memory.heap.size_limit",
    "format": "0,0.0 b",
    "label": "Heap Size Limit",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "title": "Memory Size",
    "units": "B",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "kibana_memory_size": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Total heap used by Kibana running in Node.js.",
    "field": "kibana_stats.process.memory.resident_set_size_in_bytes",
    "format": "0,0.0 b",
    "label": "Memory Size",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "title": "Memory Size",
    "units": "B",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "kibana_os_load_15m": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Load average over the last 15 minutes.",
    "field": "kibana_stats.os.load.15m",
    "format": "0,0.[00]",
    "label": "15m",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "kibana_os_load_1m": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Load average over the last minute.",
    "field": "kibana_stats.os.load.1m",
    "format": "0,0.[00]",
    "label": "1m",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "kibana_os_load_5m": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Load average over the last 5 minutes.",
    "field": "kibana_stats.os.load.5m",
    "format": "0,0.[00]",
    "label": "5m",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "kibana_process_delay": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Delay in Kibana server event loops. Longer delays may indicate blocking events in server thread, such as synchronous functions taking large amount of CPU time.",
    "field": "kibana_stats.process.event_loop_delay",
    "format": "0.[00]",
    "label": "Event Loop Delay",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "units": "ms",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "kibana_requests_disconnects": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Total number of client disconnects to the Kibana instance.",
    "field": "kibana_stats.requests.disconnects",
    "format": "0.[00]",
    "label": "Client Disconnects",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "units": "",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "kibana_requests_total": KibanaMetric {
    "app": "kibana",
    "derivative": false,
    "description": "Total number of client requests received by the Kibana instance.",
    "field": "kibana_stats.requests.total",
    "format": "0.[00]",
    "label": "Client Requests",
    "metricAgg": "max",
    "timestampField": "kibana_stats.timestamp",
    "units": "",
    "uuidField": "kibana_stats.kibana.uuid",
  },
  "logstash_cluster_events_input_rate": LogstashEventsRateClusterMetric {
    "aggs": Object {
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "logstash_uuids>event_rate_per_node",
          "gap_policy": "skip",
        },
      },
      "logstash_uuids": Object {
        "aggs": Object {
          "event_rate_per_node": Object {
            "max": Object {
              "field": "logstash_stats.events.in",
            },
          },
        },
        "terms": Object {
          "field": "logstash_stats.logstash.uuid",
          "size": 1000,
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "logstash",
    "derivative": true,
    "description": "Number of events received per second by all Logstash nodes at the inputs stage.",
    "field": "logstash_stats.events.in",
    "format": "0,0.[00]",
    "label": "Events Received Rate",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "logstash_cluster_events_latency": LogstashEventsLatencyClusterMetric {
    "aggs": Object {
      "events_time_in_millis": Object {
        "sum_bucket": Object {
          "buckets_path": "logstash_uuids>events_time_in_millis_per_node",
          "gap_policy": "skip",
        },
      },
      "events_time_in_millis_deriv": Object {
        "derivative": Object {
          "buckets_path": "events_time_in_millis",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "events_total": Object {
        "sum_bucket": Object {
          "buckets_path": "logstash_uuids>events_total_per_node",
          "gap_policy": "skip",
        },
      },
      "events_total_deriv": Object {
        "derivative": Object {
          "buckets_path": "events_total",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "logstash_uuids": Object {
        "aggs": Object {
          "events_time_in_millis_per_node": Object {
            "max": Object {
              "field": "logstash_stats.events.duration_in_millis",
            },
          },
          "events_total_per_node": Object {
            "max": Object {
              "field": "logstash_stats.events.out",
            },
          },
        },
        "terms": Object {
          "field": "logstash_stats.logstash.uuid",
          "size": 1000,
        },
      },
    },
    "app": "logstash",
    "calculation": [Function],
    "derivative": false,
    "description": "Average time spent by events in the filter and output stages, which is the total time it takes to process events divided by number of events emitted.",
    "field": "logstash_stats.events.out",
    "format": "0,0.[00]",
    "label": "Event Latency",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "units": "ms",
    "uuidField": "cluster_uuid",
  },
  "logstash_cluster_events_output_rate": LogstashEventsRateClusterMetric {
    "aggs": Object {
      "event_rate": Object {
        "sum_bucket": Object {
          "buckets_path": "logstash_uuids>event_rate_per_node",
          "gap_policy": "skip",
        },
      },
      "logstash_uuids": Object {
        "aggs": Object {
          "event_rate_per_node": Object {
            "max": Object {
              "field": "logstash_stats.events.out",
            },
          },
        },
        "terms": Object {
          "field": "logstash_stats.logstash.uuid",
          "size": 1000,
        },
      },
      "metric_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_rate",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "logstash",
    "derivative": true,
    "description": "Number of events emitted per second by all Logstash nodes at the outputs stage.",
    "field": "logstash_stats.events.out",
    "format": "0,0.[00]",
    "label": "Events Emitted Rate",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "units": "/s",
    "uuidField": "cluster_uuid",
  },
  "logstash_cluster_pipeline_nodes_count": LogstashPipelineNodeCountMetric {
    "app": "logstash",
    "calculation": [Function],
    "derivative": false,
    "description": "Number of nodes on which the Logstash pipeline is running.",
    "field": "logstash_stats.logstash.uuid",
    "format": "0,0.[00]",
    "getDateHistogramSubAggs": [Function],
    "label": "Pipeline Node Count",
    "timestampField": "logstash_stats.timestamp",
    "units": "",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_cluster_pipeline_throughput": LogstashPipelineThroughputMetric {
    "app": "logstash",
    "derivative": true,
    "description": "Number of events emitted per second by the Logstash pipeline at the outputs stage.",
    "field": "logstash_stats.pipelines.events.out",
    "format": "0,0.[00]",
    "getDateHistogramSubAggs": [Function],
    "label": "Pipeline Throughput",
    "timestampField": "logstash_stats.timestamp",
    "units": "e/s",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_events_input_rate": LogstashEventsRateMetric {
    "app": "logstash",
    "derivative": true,
    "description": "Number of events received per second by the Logstash node at the inputs stage.",
    "field": "logstash_stats.events.in",
    "format": "0,0.[00]",
    "label": "Events Received Rate",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "units": "/s",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_events_latency": LogstashEventsLatencyMetric {
    "aggs": Object {
      "events_time_in_millis": Object {
        "max": Object {
          "field": "logstash_stats.events.duration_in_millis",
        },
      },
      "events_time_in_millis_deriv": Object {
        "derivative": Object {
          "buckets_path": "events_time_in_millis",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "events_total": Object {
        "max": Object {
          "field": "logstash_stats.events.out",
        },
      },
      "events_total_deriv": Object {
        "derivative": Object {
          "buckets_path": "events_total",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "logstash",
    "calculation": [Function],
    "derivative": false,
    "description": "Average time spent by events in the filter and output stages, which is the total time it takes to process events divided by number of events emitted.",
    "field": "logstash_stats.events.out",
    "format": "0,0.[00]",
    "label": "Event Latency",
    "metricAgg": "sum",
    "timestampField": "logstash_stats.timestamp",
    "units": "ms",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_events_output_rate": LogstashEventsRateMetric {
    "app": "logstash",
    "derivative": true,
    "description": "Number of events emitted per second by the Logstash node at the outputs stage.",
    "field": "logstash_stats.events.out",
    "format": "0,0.[00]",
    "label": "Events Emitted Rate",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "units": "/s",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_cgroup_periods": LogstashMetric {
    "app": "logstash",
    "derivative": true,
    "description": "The number of sampling periods from the Completely Fair Scheduler (CFS). Compare against the number of times throttled.",
    "field": "logstash_stats.os.cgroup.cpu.stat.number_of_elapsed_periods",
    "format": "0,0.[00]",
    "label": "Cgroup Elapsed Periods",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "title": "Cgroup CFS Stats",
    "units": "",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_cgroup_quota": QuotaMetric {
    "aggs": Object {
      "periods": Object {
        "max": Object {
          "field": "logstash_stats.os.cgroup.cpu.stat.number_of_elapsed_periods",
        },
      },
      "periods_deriv": Object {
        "derivative": Object {
          "buckets_path": "periods",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "quota": Object {
        "min": Object {
          "field": "logstash_stats.os.cgroup.cpu.cfs_quota_micros",
        },
      },
      "usage": Object {
        "max": Object {
          "field": "logstash_stats.os.cgroup.cpuacct.usage_nanos",
        },
      },
      "usage_deriv": Object {
        "derivative": Object {
          "buckets_path": "usage",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "logstash",
    "calculation": [Function],
    "derivative": true,
    "description": "CPU Usage time compared to the CPU quota shown in percentage. If CPU quotas are not set, then no data will be shown.",
    "field": "logstash_stats.process.cpu.percent",
    "fieldSource": "logstash_stats.os.cgroup",
    "format": "0,0.[00]",
    "label": "Cgroup CPU Utilization",
    "metricAgg": "max",
    "periodsField": "cpu.stat.number_of_elapsed_periods",
    "quotaField": "cpu.cfs_quota_micros",
    "timestampField": "logstash_stats.timestamp",
    "title": "CPU Utilization",
    "units": "%",
    "usageField": "cpuacct.usage_nanos",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_cgroup_quota_as_cpu_utilization": QuotaMetric {
    "aggs": Object {
      "periods": Object {
        "max": Object {
          "field": "logstash_stats.os.cgroup.cpu.stat.number_of_elapsed_periods",
        },
      },
      "periods_deriv": Object {
        "derivative": Object {
          "buckets_path": "periods",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "quota": Object {
        "min": Object {
          "field": "logstash_stats.os.cgroup.cpu.cfs_quota_micros",
        },
      },
      "usage": Object {
        "max": Object {
          "field": "logstash_stats.os.cgroup.cpuacct.usage_nanos",
        },
      },
      "usage_deriv": Object {
        "derivative": Object {
          "buckets_path": "usage",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "logstash",
    "calculation": [Function],
    "derivative": true,
    "description": "CPU Usage time compared to the CPU quota shown in percentage. If CPU quotas are not set, then no data will be shown.",
    "field": "logstash_stats.process.cpu.percent",
    "fieldSource": "logstash_stats.os.cgroup",
    "format": "0,0.[00]",
    "label": "CPU Utilization",
    "metricAgg": "max",
    "periodsField": "cpu.stat.number_of_elapsed_periods",
    "quotaField": "cpu.cfs_quota_micros",
    "timestampField": "logstash_stats.timestamp",
    "units": "%",
    "usageField": "cpuacct.usage_nanos",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_cgroup_throttled": LogstashMetric {
    "app": "logstash",
    "derivative": true,
    "description": "The amount of throttled time, reported in nanoseconds, of the Cgroup.",
    "field": "logstash_stats.os.cgroup.cpu.stat.time_throttled_nanos",
    "format": "0,0.[0]a",
    "label": "Cgroup Throttling",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "title": "Cgroup CPU Performance",
    "units": "ns",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_cgroup_throttled_count": LogstashMetric {
    "app": "logstash",
    "derivative": true,
    "description": "The number of times that the CPU was throttled by the Cgroup.",
    "field": "logstash_stats.os.cgroup.cpu.stat.number_of_times_throttled",
    "format": "0,0.[00]",
    "label": "Cgroup Throttled Count",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "title": "Cgroup CFS Stats",
    "units": "",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_cgroup_usage": LogstashMetric {
    "app": "logstash",
    "derivative": true,
    "description": "The usage, reported in nanoseconds, of the Cgroup. Compare this with the throttling to discover issues.",
    "field": "logstash_stats.os.cgroup.cpuacct.usage_nanos",
    "format": "0,0.[0]a",
    "label": "Cgroup Usage",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "title": "Cgroup CPU Performance",
    "units": "ns",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_cpu_utilization": LogstashMetric {
    "app": "logstash",
    "derivative": false,
    "description": "Percentage of CPU usage reported by the OS (100% is the max).",
    "field": "logstash_stats.process.cpu.percent",
    "format": "0,0.[00]",
    "label": "CPU Utilization",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "units": "%",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_jvm_mem_max_in_bytes": LogstashMetric {
    "app": "logstash",
    "derivative": false,
    "description": "Total heap available to Logstash running in the JVM.",
    "field": "logstash_stats.jvm.mem.heap_max_in_bytes",
    "format": "0.0 b",
    "label": "Max Heap",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "title": "JVM Heap",
    "units": "B",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_jvm_mem_used_in_bytes": LogstashMetric {
    "app": "logstash",
    "derivative": false,
    "description": "Total heap used by Logstash running in the JVM.",
    "field": "logstash_stats.jvm.mem.heap_used_in_bytes",
    "format": "0.0 b",
    "label": "Used Heap",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "title": "JVM Heap",
    "units": "B",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_pipeline_nodes_count": LogstashPipelineNodeCountMetric {
    "app": "logstash",
    "calculation": [Function],
    "derivative": false,
    "description": "Number of nodes on which the Logstash pipeline is running.",
    "field": "logstash_stats.logstash.uuid",
    "format": "0,0.[00]",
    "getDateHistogramSubAggs": [Function],
    "label": "Pipeline Node Count",
    "timestampField": "logstash_stats.timestamp",
    "units": "",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_node_pipeline_throughput": LogstashPipelineThroughputMetric {
    "app": "logstash",
    "derivative": true,
    "description": "Number of events emitted per second by the Logstash pipeline at the outputs stage.",
    "field": "logstash_stats.pipelines.events.out",
    "format": "0,0.[00]",
    "getDateHistogramSubAggs": [Function],
    "label": "Pipeline Throughput",
    "timestampField": "logstash_stats.timestamp",
    "units": "e/s",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_os_load_15m": LogstashMetric {
    "app": "logstash",
    "derivative": false,
    "description": "Load average over the last 15 minutes.",
    "field": "logstash_stats.os.cpu.load_average.15m",
    "format": "0,0.[00]",
    "label": "15m",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_os_load_1m": LogstashMetric {
    "app": "logstash",
    "derivative": false,
    "description": "Load average over the last minute.",
    "field": "logstash_stats.os.cpu.load_average.1m",
    "format": "0,0.[00]",
    "label": "1m",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_os_load_5m": LogstashMetric {
    "app": "logstash",
    "derivative": false,
    "description": "Load average over the last 5 minutes.",
    "field": "logstash_stats.os.cpu.load_average.5m",
    "format": "0,0.[00]",
    "label": "5m",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "title": "System Load",
    "units": "",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_pipeline_max_queue_size": LogstashPipelineQueueSizeMetric {
    "app": "logstash",
    "calculation": [Function],
    "dateHistogramSubAggs": Object {
      "pipelines": Object {
        "aggs": Object {
          "pipeline_by_id": Object {
            "aggs": Object {
              "queue_size_field": Object {
                "max": Object {
                  "field": "logstash_stats.pipelines.queue.max_queue_size_in_bytes",
                },
              },
            },
            "terms": Object {
              "field": "logstash_stats.pipelines.id",
              "size": 1000,
            },
          },
          "total_queue_size_for_node": Object {
            "sum_bucket": Object {
              "buckets_path": "pipeline_by_id>queue_size_field",
            },
          },
        },
        "nested": Object {
          "path": "logstash_stats.pipelines",
        },
      },
    },
    "derivative": false,
    "description": "Maximum size set for the persistent queues on this node.",
    "field": "logstash_stats.pipelines.queue.max_queue_size_in_bytes",
    "format": "0,0.0 b",
    "label": "Max Queue Size",
    "timestampField": "logstash_stats.timestamp",
    "units": "B",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_pipeline_queue_size": LogstashPipelineQueueSizeMetric {
    "app": "logstash",
    "calculation": [Function],
    "dateHistogramSubAggs": Object {
      "pipelines": Object {
        "aggs": Object {
          "pipeline_by_id": Object {
            "aggs": Object {
              "queue_size_field": Object {
                "max": Object {
                  "field": "logstash_stats.pipelines.queue.queue_size_in_bytes",
                },
              },
            },
            "terms": Object {
              "field": "logstash_stats.pipelines.id",
              "size": 1000,
            },
          },
          "total_queue_size_for_node": Object {
            "sum_bucket": Object {
              "buckets_path": "pipeline_by_id>queue_size_field",
            },
          },
        },
        "nested": Object {
          "path": "logstash_stats.pipelines",
        },
      },
    },
    "derivative": false,
    "description": "Current size of all persistent queues in the Logstash pipelines on this node.",
    "field": "logstash_stats.pipelines.queue.queue_size_in_bytes",
    "format": "0,0.0 b",
    "label": "Queue Size",
    "timestampField": "logstash_stats.timestamp",
    "title": "Persistent Queue Size",
    "units": "B",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "logstash_queue_events_count": LogstashMetric {
    "app": "logstash",
    "derivative": false,
    "description": "Average number of events in the persistent queue waiting to be processed by the filter and output stages.",
    "field": "logstash_stats.queue.events_count",
    "format": "0,0.[00]",
    "label": "Events Queued",
    "metricAgg": "max",
    "timestampField": "logstash_stats.timestamp",
    "title": "Persistent Queue Events",
    "units": "",
    "uuidField": "logstash_stats.logstash.uuid",
  },
  "node_cgroup_periods": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "The number of sampling periods from the Completely Fair Scheduler (CFS). Compare against the number of times throttled.",
    "field": "node_stats.os.cgroup.cpu.stat.number_of_elapsed_periods",
    "format": "0,0.[00]",
    "label": "Cgroup Elapsed Periods",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Cgroup CFS Stats",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_cgroup_quota": QuotaMetric {
    "aggs": Object {
      "periods": Object {
        "max": Object {
          "field": "node_stats.os.cgroup.cpu.stat.number_of_elapsed_periods",
        },
      },
      "periods_deriv": Object {
        "derivative": Object {
          "buckets_path": "periods",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "quota": Object {
        "min": Object {
          "field": "node_stats.os.cgroup.cpu.cfs_quota_micros",
        },
      },
      "usage": Object {
        "max": Object {
          "field": "node_stats.os.cgroup.cpuacct.usage_nanos",
        },
      },
      "usage_deriv": Object {
        "derivative": Object {
          "buckets_path": "usage",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "elasticsearch",
    "calculation": [Function],
    "derivative": true,
    "description": "CPU Usage time compared to the CPU quota shown in percentage. If CPU quotas are not set, then no data will be shown.",
    "field": "node_stats.process.cpu.percent",
    "fieldSource": "node_stats.os.cgroup",
    "format": "0,0.[00]",
    "label": "Cgroup CPU Utilization",
    "metricAgg": "max",
    "periodsField": "cpu.stat.number_of_elapsed_periods",
    "quotaField": "cpu.cfs_quota_micros",
    "timestampField": "timestamp",
    "title": "CPU Utilization",
    "type": "node",
    "units": "%",
    "usageField": "cpuacct.usage_nanos",
    "uuidField": "source_node.uuid",
  },
  "node_cgroup_quota_as_cpu_utilization": QuotaMetric {
    "aggs": Object {
      "periods": Object {
        "max": Object {
          "field": "node_stats.os.cgroup.cpu.stat.number_of_elapsed_periods",
        },
      },
      "periods_deriv": Object {
        "derivative": Object {
          "buckets_path": "periods",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "quota": Object {
        "min": Object {
          "field": "node_stats.os.cgroup.cpu.cfs_quota_micros",
        },
      },
      "usage": Object {
        "max": Object {
          "field": "node_stats.os.cgroup.cpuacct.usage_nanos",
        },
      },
      "usage_deriv": Object {
        "derivative": Object {
          "buckets_path": "usage",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "elasticsearch",
    "calculation": [Function],
    "derivative": true,
    "description": "CPU Usage time compared to the CPU quota shown in percentage. If CPU quotas are not set, then no data will be shown.",
    "field": "node_stats.process.cpu.percent",
    "fieldSource": "node_stats.os.cgroup",
    "format": "0,0.[00]",
    "label": "CPU Utilization",
    "metricAgg": "max",
    "periodsField": "cpu.stat.number_of_elapsed_periods",
    "quotaField": "cpu.cfs_quota_micros",
    "timestampField": "timestamp",
    "type": "node",
    "units": "%",
    "usageField": "cpuacct.usage_nanos",
    "uuidField": "source_node.uuid",
  },
  "node_cgroup_throttled": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "The amount of throttled time, reported in nanoseconds, of the cgroup.",
    "field": "node_stats.os.cgroup.cpu.stat.time_throttled_nanos",
    "format": "0,0.[0]a",
    "label": "Cgroup Throttling",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Cgroup CPU Performance",
    "type": "node",
    "units": "ns",
    "uuidField": "source_node.uuid",
  },
  "node_cgroup_throttled_count": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "The number of times that the CPU was throttled by the cgroup.",
    "field": "node_stats.os.cgroup.cpu.stat.number_of_times_throttled",
    "format": "0,0.[00]",
    "label": "Cgroup Throttled Count",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Cgroup CFS Stats",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_cgroup_usage": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "The usage, reported in nanoseconds, of the cgroup. Compare this with the throttling to discover issues.",
    "field": "node_stats.os.cgroup.cpuacct.usage_nanos",
    "format": "0,0.[0]a",
    "label": "Cgroup Usage",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Cgroup CPU Performance",
    "type": "node",
    "units": "ns",
    "uuidField": "source_node.uuid",
  },
  "node_cpu_utilization": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Percentage of CPU usage for the Elasticsearch process.",
    "field": "node_stats.process.cpu.percent",
    "format": "0,0.[00]",
    "label": "CPU Utilization",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "type": "node",
    "units": "%",
    "uuidField": "source_node.uuid",
  },
  "node_free_space": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Free disk space available on the node.",
    "field": "node_stats.fs.total.available_in_bytes",
    "format": "0.0 b",
    "label": "Disk Free Space",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_index_latency": LatencyMetric {
    "aggs": Object {
      "event_time_in_millis": Object {
        "max": Object {
          "field": "node_stats.indices.indexing.index_time_in_millis",
        },
      },
      "event_time_in_millis_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_time_in_millis",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "event_total": Object {
        "max": Object {
          "field": "node_stats.indices.indexing.index_total",
        },
      },
      "event_total_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_total",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "elasticsearch",
    "calculation": [Function],
    "derivative": false,
    "description": "Average latency for indexing documents, which is time it takes to index documents divided by number that were indexed. This considers any shard located on this node, including replicas.",
    "field": "node_stats.indices.indexing.index_total",
    "format": "0,0.[00]",
    "label": "Indexing",
    "metricAgg": "sum",
    "timestampField": "timestamp",
    "title": "Latency",
    "type": "node",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_doc_values": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Doc Values. This is a part of Lucene Total.",
    "field": "node_stats.indices.segments.doc_values_memory_in_bytes",
    "format": "0.0 b",
    "label": "Doc Values",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_fielddata": IndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Fielddata (e.g., global ordinals or explicitly enabled fielddata on text fields). This is for the same shards, but not a part of Lucene Total.",
    "field": "node_stats.indices.fielddata.memory_size_in_bytes",
    "format": "0.0 b",
    "label": "Fielddata",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_fixed_bit_set": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Fixed Bit Sets (e.g., deeply nested documents). This is a part of Lucene Total.",
    "field": "node_stats.indices.segments.fixed_bit_set_memory_in_bytes",
    "format": "0.0 b",
    "label": "Fixed Bitsets",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_norms": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Norms (normalization factors for query-time, text scoring). This is a part of Lucene Total.",
    "field": "node_stats.indices.segments.norms_memory_in_bytes",
    "format": "0.0 b",
    "label": "Norms",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_overall": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap memory used by Lucene for current index. This is the sum of other fields for primary and replica shards on this node.",
    "field": "node_stats.indices.segments.memory_in_bytes",
    "format": "0.0 b",
    "label": "Lucene Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_overall_1": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap memory used by Lucene for current index. This is the sum of other fields for primary and replica shards on this node.",
    "field": "node_stats.indices.segments.memory_in_bytes",
    "format": "0.0 b",
    "label": "Lucene Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory - Lucene 1",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_overall_2": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap memory used by Lucene for current index. This is the sum of other fields for primary and replica shards on this node.",
    "field": "node_stats.indices.segments.memory_in_bytes",
    "format": "0.0 b",
    "label": "Lucene Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory - Lucene 2",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_overall_3": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap memory used by Lucene for current index. This is the sum of other fields for primary and replica shards on this node.",
    "field": "node_stats.indices.segments.memory_in_bytes",
    "format": "0.0 b",
    "label": "Lucene Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory - Lucene 3",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_points": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Points (e.g., numbers, IPs, and geo data). This is a part of Lucene Total.",
    "field": "node_stats.indices.segments.points_memory_in_bytes",
    "format": "0.0 b",
    "label": "Points",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_query_cache": IndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Query Cache (e.g., cached filters). This is for the same shards, but not a part of Lucene Total.",
    "field": "node_stats.indices.query_cache.memory_size_in_bytes",
    "format": "0.0 b",
    "label": "Query Cache",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory - Elasticsearch",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_request_cache": IndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Request Cache (e.g., instant aggregations). This is for the same shards, but not a part of Lucene Total.",
    "field": "node_stats.indices.request_cache.memory_size_in_bytes",
    "format": "0.0 b",
    "label": "Request Cache",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_stored_fields": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Stored Fields (e.g., _source). This is a part of Lucene Total.",
    "field": "node_stats.indices.segments.stored_fields_memory_in_bytes",
    "format": "0.0 b",
    "label": "Stored Fields",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_term_vectors": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Term Vectors. This is a part of Lucene Total.",
    "field": "node_stats.indices.segments.term_vectors_memory_in_bytes",
    "format": "0.0 b",
    "label": "Term Vectors",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_terms": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Terms (e.g., text). This is a part of Lucene Total.",
    "field": "node_stats.indices.segments.terms_memory_in_bytes",
    "format": "0.0 b",
    "label": "Terms",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_versions": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by Versioning (e.g., updates and deletes). This is NOT a part of Lucene Total.",
    "field": "node_stats.indices.segments.version_map_memory_in_bytes",
    "format": "0.0 b",
    "label": "Version Map",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_mem_writer": NodeIndexMemoryMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Heap memory used by the Index Writer. This is NOT a part of Lucene Total.",
    "field": "node_stats.indices.segments.index_writer_memory_in_bytes",
    "format": "0.0 b",
    "label": "Index Writer",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Index Memory",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_index_threads_get_queue": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of GET operations in the queue.",
    "field": "node_stats.thread_pool.get.queue",
    "format": "0,0.[00]",
    "label": "GET Queue",
    "metricAgg": "max",
    "min": 0,
    "timestampField": "timestamp",
    "title": "Read Threads",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_index_threads_get_rejected": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of GET operations that have been rejected, which occurs when the queue is full.",
    "field": "node_stats.thread_pool.get.rejected",
    "format": "0,0.[00]",
    "label": "GET Rejections",
    "metricAgg": "max",
    "min": 0,
    "timestampField": "timestamp",
    "title": "Read Threads",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_index_threads_search_queue": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of search operations in the queue (e.g., shard level searches).",
    "field": "node_stats.thread_pool.search.queue",
    "format": "0,0.[00]",
    "label": "Search Queue",
    "metricAgg": "max",
    "min": 0,
    "timestampField": "timestamp",
    "title": "Read Threads",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_index_threads_search_rejected": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of search operations that have been rejected, which occurs when the queue is full.",
    "field": "node_stats.thread_pool.search.rejected",
    "format": "0,0.[00]",
    "label": "Search Rejections",
    "metricAgg": "max",
    "min": 0,
    "timestampField": "timestamp",
    "title": "Read Threads",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_index_threads_write_queue": WriteThreadPoolQueueMetric {
    "app": "elasticsearch",
    "calculation": [Function],
    "dateHistogramSubAggs": Object {
      "bulk": Object {
        "max": Object {
          "field": "node_stats.thread_pool.bulk.queue",
        },
      },
      "index": Object {
        "max": Object {
          "field": "node_stats.thread_pool.index.queue",
        },
      },
      "write": Object {
        "max": Object {
          "field": "node_stats.thread_pool.write.queue",
        },
      },
    },
    "derivative": false,
    "description": "Number of index, bulk, and write operations in the queue. The bulk threadpool was renamed to write in 6.3, and the index threadpool is deprecated.",
    "field": "node_stats.thread_pool.write.queue",
    "format": "0.[00]",
    "label": "Write Queue",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Indexing Threads",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_index_threads_write_rejected": WriteThreadPoolRejectedMetric {
    "app": "elasticsearch",
    "calculation": [Function],
    "dateHistogramSubAggs": Object {
      "bulk_deriv": Object {
        "derivative": Object {
          "buckets_path": "bulk_rejections",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "bulk_rejections": Object {
        "max": Object {
          "field": "node_stats.thread_pool.bulk.rejected",
        },
      },
      "index_deriv": Object {
        "derivative": Object {
          "buckets_path": "index_rejections",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "index_rejections": Object {
        "max": Object {
          "field": "node_stats.thread_pool.index.rejected",
        },
      },
      "write_deriv": Object {
        "derivative": Object {
          "buckets_path": "write_rejections",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "write_rejections": Object {
        "max": Object {
          "field": "node_stats.thread_pool.write.rejected",
        },
      },
    },
    "derivative": false,
    "description": "Number of index, bulk, and write operations that have been rejected, which occurs when the queue is full. The bulk threadpool was renamed to write in 6.3, and the index threadpool is deprecated.",
    "field": "node_stats.thread_pool.write.rejected",
    "format": "0.[00]",
    "label": "Write Rejections",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Indexing Threads",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_index_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of time spent on indexing operations.",
    "field": "node_stats.indices.indexing.index_time_in_millis",
    "format": "0,0.[00]",
    "label": "Index Time",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Indexing Time",
    "type": "node",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "node_index_total": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of indexing operations.",
    "field": "node_stats.indices.indexing.index_total",
    "format": "0,0.[00]",
    "label": "Indexing Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Request Rate",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_jvm_gc_old_count": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of old Garbage Collections.",
    "field": "node_stats.jvm.gc.collectors.old.collection_count",
    "format": "0.[00]",
    "label": "Old",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "GC Rate",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_jvm_gc_old_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Time spent performing old Garbage Collections.",
    "field": "node_stats.jvm.gc.collectors.old.collection_time_in_millis",
    "format": "0,0.[00]",
    "label": "Old",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "GC Duration",
    "type": "node",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "node_jvm_gc_young_count": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of young Garbage Collections.",
    "field": "node_stats.jvm.gc.collectors.young.collection_count",
    "format": "0.[00]",
    "label": "Young",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "GC Rate",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_jvm_gc_young_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Time spent performing young Garbage Collections.",
    "field": "node_stats.jvm.gc.collectors.young.collection_time_in_millis",
    "format": "0,0.[00]",
    "label": "Young",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "GC Duration",
    "type": "node",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "node_jvm_mem_max_in_bytes": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap available to Elasticsearch running in the JVM.",
    "field": "node_stats.jvm.mem.heap_max_in_bytes",
    "format": "0.0 b",
    "label": "Max Heap",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "JVM Heap",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_jvm_mem_percent": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap used by Elasticsearch running in the JVM.",
    "field": "node_stats.jvm.mem.heap_used_percent",
    "format": "0,0.[00]",
    "label": "Used Heap",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "JVM Heap",
    "type": "node",
    "units": "%",
    "uuidField": "source_node.uuid",
  },
  "node_jvm_mem_used_in_bytes": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Total heap used by Elasticsearch running in the JVM.",
    "field": "node_stats.jvm.mem.heap_used_in_bytes",
    "format": "0.0 b",
    "label": "Used Heap",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "JVM Heap",
    "type": "node",
    "units": "B",
    "uuidField": "source_node.uuid",
  },
  "node_load_average": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Load average over the last minute.",
    "field": "node_stats.os.cpu.load_average.1m",
    "format": "0,0.[00]",
    "label": "1m",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "System Load",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_query_latency": LatencyMetric {
    "aggs": Object {
      "event_time_in_millis": Object {
        "max": Object {
          "field": "node_stats.indices.search.query_time_in_millis",
        },
      },
      "event_time_in_millis_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_time_in_millis",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
      "event_total": Object {
        "max": Object {
          "field": "node_stats.indices.search.query_total",
        },
      },
      "event_total_deriv": Object {
        "derivative": Object {
          "buckets_path": "event_total",
          "gap_policy": "skip",
          "unit": "1s",
        },
      },
    },
    "app": "elasticsearch",
    "calculation": [Function],
    "derivative": false,
    "description": "Average latency for searching, which is time it takes to execute searches divided by number of searches submitted. This considers primary and replica shards.",
    "field": "node_stats.indices.search.query_total",
    "format": "0,0.[00]",
    "label": "Search",
    "metricAgg": "sum",
    "timestampField": "timestamp",
    "title": "Latency",
    "type": "node",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "node_search_total": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of search operations (per shard).",
    "field": "node_stats.indices.search.query_total",
    "format": "0,0.[00]",
    "label": "Search Total",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Request Rate",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_segment_count": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Maximum segment count for primary and replica shards on this node.",
    "field": "node_stats.indices.segments.count",
    "format": "0,0.[00]",
    "label": "Segment Count",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_queued_bulk": ThreadPoolQueueMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Number of bulk indexing operations waiting to be processed on this node. A single bulk request can create multiple bulk operations.",
    "field": "node_stats.thread_pool.bulk.queue",
    "format": "0.[00]",
    "label": "Bulk",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Queue",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_queued_generic": ThreadPoolQueueMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Number of generic (internal) operations waiting to be processed on this node.",
    "field": "node_stats.thread_pool.generic.queue",
    "format": "0.[00]",
    "label": "Generic",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Queue",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_queued_get": ThreadPoolQueueMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Number of get operations waiting to be processed on this node.",
    "field": "node_stats.thread_pool.get.queue",
    "format": "0.[00]",
    "label": "Get",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Queue",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_queued_index": ThreadPoolQueueMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Number of non-bulk, index operations waiting to be processed on this node.",
    "field": "node_stats.thread_pool.index.queue",
    "format": "0.[00]",
    "label": "Index",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Queue",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_queued_management": ThreadPoolQueueMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Number of management (internal) operations waiting to be processed on this node.",
    "field": "node_stats.thread_pool.management.queue",
    "format": "0.[00]",
    "label": "Management",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Queue",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_queued_search": ThreadPoolQueueMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Number of search operations waiting to be processed on this node. A single search request can create multiple search operations.",
    "field": "node_stats.thread_pool.search.queue",
    "format": "0.[00]",
    "label": "Search",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Queue",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_queued_watcher": ThreadPoolQueueMetric {
    "app": "elasticsearch",
    "derivative": false,
    "description": "Number of Watcher operations waiting to be processed on this node.",
    "field": "node_stats.thread_pool.watcher.queue",
    "format": "0.[00]",
    "label": "Watcher",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Queue",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_rejected_bulk": ThreadPoolRejectedMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Bulk rejections. These occur when the queue is full.",
    "field": "node_stats.thread_pool.bulk.rejected",
    "format": "0.[00]",
    "label": "Bulk",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Rejections",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_rejected_generic": ThreadPoolRejectedMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Generic (internal) rejections. These occur when the queue is full.",
    "field": "node_stats.thread_pool.generic.rejected",
    "format": "0.[00]",
    "label": "Generic",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Rejections",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_rejected_get": ThreadPoolRejectedMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Get rejections. These occur when the queue is full.",
    "field": "node_stats.thread_pool.get.rejected",
    "format": "0.[00]",
    "label": "Get",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Rejections",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_rejected_index": ThreadPoolRejectedMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Index rejections. These occur when the queue is full. You should look at bulk indexing.",
    "field": "node_stats.thread_pool.index.rejected",
    "format": "0.[00]",
    "label": "Index",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Rejections",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_rejected_management": ThreadPoolRejectedMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Get (internal) rejections. These occur when the queue is full.",
    "field": "node_stats.thread_pool.management.rejected",
    "format": "0.[00]",
    "label": "Management",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Rejections",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_rejected_search": ThreadPoolRejectedMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Search rejections. These occur when the queue is full. This can indicate over-sharding.",
    "field": "node_stats.thread_pool.search.rejected",
    "format": "0.[00]",
    "label": "Search",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Rejections",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_threads_rejected_watcher": ThreadPoolRejectedMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Watch rejections. These occur when the queue is full. This can indicate stuck-Watches.",
    "field": "node_stats.thread_pool.watcher.rejected",
    "format": "0.[00]",
    "label": "Watcher",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Thread Rejections",
    "type": "node",
    "units": "",
    "uuidField": "source_node.uuid",
  },
  "node_throttle_index_time": ElasticsearchMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Amount of time spent with index throttling, which indicates slow disks on a node.",
    "field": "node_stats.indices.indexing.throttle_time_in_millis",
    "format": "0,0.[00]",
    "label": "Index Throttling Time",
    "metricAgg": "max",
    "min": 0,
    "timestampField": "timestamp",
    "title": "Indexing Time",
    "type": "node",
    "units": "ms",
    "uuidField": "source_node.uuid",
  },
  "node_total_cumul_io": RequestRateMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Total I/O. (This metric is not supported on all platforms and may display N/A if I/O data is unavailable.)",
    "field": "node_stats.fs.io_stats.total.operations",
    "format": "0,0.[00]",
    "label": "Total I/O",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "I/O Operations Rate",
    "type": "node",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
  "node_total_read_io": RequestRateMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Total Read I/O. (This metric is not supported on all platforms and may display N/A if I/O data is unavailable.)",
    "field": "node_stats.fs.io_stats.total.read_operations",
    "format": "0,0.[00]",
    "label": "Total Read I/O",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "I/O Operations Rate",
    "type": "node",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
  "node_total_write_io": RequestRateMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Total Write I/O. (This metric is not supported on all platforms and may display N/A if I/O data is unavailable.)",
    "field": "node_stats.fs.io_stats.total.write_operations",
    "format": "0,0.[00]",
    "label": "Total Write I/O",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "I/O Operations Rate",
    "type": "node",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
  "search_request_rate": RequestRateMetric {
    "app": "elasticsearch",
    "derivative": true,
    "description": "Number of search requests being executed across primary and replica shards. A single search can run against multiple shards!",
    "field": "index_stats.total.search.query_total",
    "format": "0,0.[00]",
    "label": "Total Shards",
    "metricAgg": "max",
    "timestampField": "timestamp",
    "title": "Search Rate",
    "type": "cluster",
    "units": "/s",
    "uuidField": "source_node.uuid",
  },
}
`;
