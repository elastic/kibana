# Conventions

This plugins adopts some conventions in addition to or in place of conventions in Kibana (at the time of the plugin's creation):

## Folder structure
```
common/
  constants/ // constants used across client and server
  lib/ // helpers used across client and server
  types/ // TS definitions
public/
  components/ // common React components
  constants/ // constants used on the client
  lib/ // helpers used on the client
  models/ // client models
  sections/ // Sections of the app with corresponding React components
    watch_edit
    watch_list
    watch_status
server/
  lib/
    screenshots/
      screenshots.js
      index.js // ONLY exposes screenshots service
      screenshot.js // helper service, not exposed in index.js
      __tests__/
        screenshots.js
        screenshot.js
    say_hello/
      index.js
      say_hello.js
```

## Data Flow

We have a layered architecture in the Watcher UI codebase, with each layer performing a specific function to the data as it flows through it.

**Elasticsearch APIs** <---> **Kibana server models** <---> **Kibana APIs** <---> **Kibana client services** <---> **Kibana client models** <---> **Kibana client code**

Each of these layers is described below.

### Elasticsearch APIs
This the ultimate source or destination of any persisted data: watches, watch history, etc.

### Kibana server models
These set of classes translate data coming from Elasticsearch into a shape required by the Watcher UI codebase. Conversely, they translate
data generated by the Watcher UI into a shape required by Elasticsearch APIs.

### Kibana APIs
This layer is responsible for transporting data between the Kibana server and Kibana client (browser).

### Kibana client services
This layer is responsible for calling Kibana APIs, using client models to parse responses from APIs or create requests for APIs.

Service methods should consume models as arguments and return models as much as possible. The exception to this might be services that
perform an initial load of a piece of data from the API; in this case the service method may consume a scalar ID as it argument.

### Kibana client models
Much like their server counterparts, these set of classes translate data coming from the Kibana APIs into in-memory representations
for use in the Kibana client-side code or vice-versa. Unlike their server counterparts they typically don't change the _shape_ of the
data (as that is typically done by the server models already).

They do, however, serve as a consistent place in the data path for translating wire representations of certain types of data into
more suitable in-memory representations, for example: converting an [ISO8601-formatted timestamp](https://en.wikipedia.org/wiki/ISO_8601)
into a [moment instance](https://momentjs.com/).

They are also the right place for establishing relationships between models — for example, a watch contains many actions — and for
encapsulating operations around such relationships — for example, updating the status of a watch's action.

### Kibana client code
This layer deals almost exclusively with data in the form of client models. The one exception to this rule is when the client code needs
to bootstrap a model instance from a bare JS object — for example, creating a new `Watch` model from the contents of the Add/Edit Watch Form.
