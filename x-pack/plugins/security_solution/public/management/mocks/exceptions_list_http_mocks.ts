/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import type { HttpFetchOptionsWithPath } from '@kbn/core/public';
import { EXCEPTION_LIST_ITEM_URL, EXCEPTION_LIST_URL } from '@kbn/securitysolution-list-constants';
import type {
  ExceptionListItemSchema,
  FoundExceptionListItemSchema,
  FindExceptionListItemSchema,
  UpdateExceptionListItemSchema,
  ReadExceptionListItemSchema,
  CreateExceptionListItemSchema,
  DeleteExceptionListItemSchema,
  ExceptionListSchema,
  ExceptionListSummarySchema,
} from '@kbn/securitysolution-io-ts-list-types';
import { getExceptionListSchemaMock } from '@kbn/lists-plugin/common/schemas/response/exception_list_schema.mock';
import type { ResponseProvidersInterface } from '../../common/mock/endpoint/http_handler_mock_factory';
import {
  composeHttpHandlerMocks,
  httpHandlerMockFactory,
} from '../../common/mock/endpoint/http_handler_mock_factory';
import { ExceptionsListItemGenerator } from '../../../common/endpoint/data_generators/exceptions_list_item_generator';
import {
  BY_POLICY_ARTIFACT_TAG_PREFIX,
  GLOBAL_ARTIFACT_TAG,
} from '../../../common/endpoint/service/artifacts';

interface FindExceptionListItemSchemaQueryParams
  extends Omit<FindExceptionListItemSchema, 'page' | 'per_page'> {
  page?: number;
  per_page?: number;
}

export type ExceptionsFindHttpMocksInterface = ResponseProvidersInterface<{
  exceptionsFind: (options: HttpFetchOptionsWithPath) => FoundExceptionListItemSchema;
}>;
/**
 * HTTP mock for retrieving list of Exception
 */
export const exceptionsFindHttpMocks = httpHandlerMockFactory<ExceptionsFindHttpMocksInterface>([
  {
    id: 'exceptionsFind',
    path: `${EXCEPTION_LIST_ITEM_URL}/_find`,
    method: 'get',
    handler: ({ query }): FoundExceptionListItemSchema => {
      const apiQueryParams = query as unknown as FindExceptionListItemSchemaQueryParams;
      const generator = new ExceptionsListItemGenerator('seed');
      const perPage = apiQueryParams.per_page ?? 10;
      const data = Array.from({ length: Math.min(perPage, 50) }, () =>
        generator.generate({ tags: [GLOBAL_ARTIFACT_TAG] })
      );

      // If we have more than 2 items, then set policy ids on the per-policy trusted app
      if (data.length > 2) {
        // FIXME: remove hard-coded IDs below adn get them from the new FleetPackagePolicyGenerator (#2262)

        // Change the 3rd entry (index 2) to be policy specific
        data[2].tags = [
          // IDs below are those generated by the `fleetGetEndpointPackagePolicyListHttpMock()` mock,
          // so if using in combination with that API mock, these should just "work"
          `${BY_POLICY_ARTIFACT_TAG_PREFIX}ddf6570b-9175-4a6d-b288-61a09771c647`,
          `${BY_POLICY_ARTIFACT_TAG_PREFIX}b8e616ae-44fc-4be7-846c-ce8fa5c082dd`,
        ];
      }

      return {
        page: apiQueryParams.page ?? 1,
        per_page: perPage,
        total: 20,
        data,
      };
    },
  },
]);

export type ExceptionsPutHttpMocksInterface = ResponseProvidersInterface<{
  exceptionUpdate: (options: HttpFetchOptionsWithPath) => ExceptionListItemSchema;
}>;
/**
 * HTTP mocks that support updating a single Exception
 */
export const exceptionPutHttpMocks = httpHandlerMockFactory<ExceptionsPutHttpMocksInterface>([
  {
    id: 'exceptionUpdate',
    path: EXCEPTION_LIST_ITEM_URL,
    method: 'put',
    handler: ({ body, path }): ExceptionListItemSchema => {
      const updatedExceptionItem = JSON.parse(
        body as string
      ) as Required<UpdateExceptionListItemSchema>;
      const response: ExceptionListItemSchema = {
        ...updatedExceptionItem,
        id: path.split('/').pop() ?? 'unknown-id',
        list_id: 'endpoint_list_id',
        comments: [],
        created_at: '2021-10-12T16:02:55.856Z',
        created_by: 'elastic',
        updated_at: '2021-10-13T16:02:55.856Z',
        updated_by: 'elastic',
        _version: 'abc',
        tie_breaker_id: '1111',
      };

      return response;
    },
  },
]);

export type ExceptionsGetOneHttpMocksInterface = ResponseProvidersInterface<{
  exceptionGetOne: (options: HttpFetchOptionsWithPath) => ExceptionListItemSchema;
}>;
/**
 * HTTP mock for retrieving one Exception
 */
export const exceptionsGetOneHttpMocks = httpHandlerMockFactory<ExceptionsGetOneHttpMocksInterface>(
  [
    {
      id: 'exceptionGetOne',
      path: EXCEPTION_LIST_ITEM_URL,
      method: 'get',
      handler: ({ query }): ExceptionListItemSchema => {
        const apiQueryParams = query as ReadExceptionListItemSchema;
        const exceptionItem = new ExceptionsListItemGenerator('seed').generate({
          os_types: ['windows'],
          tags: [GLOBAL_ARTIFACT_TAG],
        });

        exceptionItem.item_id = apiQueryParams.item_id ?? exceptionItem.item_id;
        exceptionItem.namespace_type =
          apiQueryParams.namespace_type ?? exceptionItem.namespace_type;

        return exceptionItem;
      },
    },
  ]
);

export type ExceptionsDeleteOneHttpMocksInterface = ResponseProvidersInterface<{
  exceptionDelete: (options: HttpFetchOptionsWithPath) => ExceptionListItemSchema;
}>;
/**
 * HTTP mock for deleting one Exception
 */
export const exceptionsDeleteOneHttpMocks =
  httpHandlerMockFactory<ExceptionsDeleteOneHttpMocksInterface>([
    {
      id: 'exceptionDelete',
      path: EXCEPTION_LIST_ITEM_URL,
      method: 'delete',
      handler: ({ query }): ExceptionListItemSchema => {
        const apiQueryParams = query as DeleteExceptionListItemSchema;
        const exceptionItem = new ExceptionsListItemGenerator('seed').generate({
          os_types: ['windows'],
          tags: [GLOBAL_ARTIFACT_TAG],
        });

        exceptionItem.item_id = apiQueryParams.item_id ?? exceptionItem.item_id;
        exceptionItem.id = apiQueryParams.id ?? exceptionItem.id;
        exceptionItem.namespace_type =
          apiQueryParams.namespace_type ?? exceptionItem.namespace_type;

        return exceptionItem;
      },
    },
  ]);

export type ExceptionsPostHttpMocksInterface = ResponseProvidersInterface<{
  exceptionCreate: (options: HttpFetchOptionsWithPath) => ExceptionListItemSchema;
}>;
/**
 * HTTP mocks that support creating a single Exception
 */
export const exceptionPostHttpMocks = httpHandlerMockFactory<ExceptionsPostHttpMocksInterface>([
  {
    id: 'exceptionCreate',
    path: EXCEPTION_LIST_ITEM_URL,
    method: 'post',
    handler: ({ body, path }): ExceptionListItemSchema => {
      const { comments, ...updatedExceptionItem } = JSON.parse(
        body as string
      ) as CreateExceptionListItemSchema;
      const response: ExceptionListItemSchema = {
        ...new ExceptionsListItemGenerator('seed').generate({
          os_types: ['windows'],
          tags: [GLOBAL_ARTIFACT_TAG],
        }),
        ...updatedExceptionItem,
      };
      response.id = path.split('/').pop() ?? response.id;

      return response;
    },
  },
]);

export type ExceptionsPostCreateListHttpMockInterface = ResponseProvidersInterface<{
  exceptionCreateList: (options: HttpFetchOptionsWithPath) => ExceptionListSchema;
}>;
/**
 * HTTP mock that support creating the list
 */
export const exceptionsPostCreateListHttpMock =
  httpHandlerMockFactory<ExceptionsPostCreateListHttpMockInterface>([
    {
      id: 'exceptionCreateList',
      path: EXCEPTION_LIST_URL,
      method: 'post',
      handler: (): ExceptionListSchema => {
        return getExceptionListSchemaMock();
      },
    },
  ]);

export type ExceptionsGetSummaryHttpMockInterface = ResponseProvidersInterface<{
  exceptionsSummary: (options: HttpFetchOptionsWithPath) => ExceptionListSummarySchema;
}>;
/**
 * HTTP mocks that support the Get Summary api
 */
export const exceptionsGetSummaryHttpMock =
  httpHandlerMockFactory<ExceptionsGetSummaryHttpMockInterface>([
    {
      id: 'exceptionsSummary',
      path: `${EXCEPTION_LIST_URL}/summary`,
      method: 'get',
      handler: (): ExceptionListSummarySchema => {
        return {
          total: 10,
          linux: 2,
          macos: 3,
          windows: 5,
        };
      },
    },
  ]);

export type ExceptionsListAllHttpMocksInterface = ExceptionsFindHttpMocksInterface &
  ExceptionsGetOneHttpMocksInterface &
  ExceptionsPutHttpMocksInterface &
  ExceptionsDeleteOneHttpMocksInterface &
  ExceptionsPostHttpMocksInterface &
  ExceptionsPostCreateListHttpMockInterface &
  ExceptionsGetSummaryHttpMockInterface;
/** Use this HTTP mock when wanting to mock the API calls done by the Exception Http service */
export const exceptionsListAllHttpMocks =
  composeHttpHandlerMocks<ExceptionsListAllHttpMocksInterface>([
    exceptionsFindHttpMocks,
    exceptionsGetOneHttpMocks,
    exceptionPutHttpMocks,
    exceptionPostHttpMocks,
    exceptionsPostCreateListHttpMock,
    exceptionsDeleteOneHttpMocks,
    exceptionsGetSummaryHttpMock,
  ]);
