/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */

import React, { useCallback, useMemo } from 'react';
import { useDispatch } from 'react-redux';
import styled from 'styled-components';
import {
  EuiRadio,
  EuiSwitch,
  EuiTitle,
  EuiSpacer,
  htmlIdGenerator,
  EuiCallOut,
} from '@elastic/eui';
import { i18n } from '@kbn/i18n';
import { FormattedMessage } from '@kbn/i18n/react';
import { APP_ID } from '../../../../../../../common/constants';
import { SecurityPageName } from '../../../../../../app/types';

import { Immutable, ProtectionModes } from '../../../../../../../common/endpoint/types';
import { OS, MalwareProtectionOSes } from '../../../types';
import { ConfigForm } from '../config_form';
import { policyConfig } from '../../../store/policy_details/selectors';
import { usePolicyDetailsSelector } from '../../policy_hooks';
import { clone } from '../../../models/policy_details_config';
import { LinkToApp } from '../../../../../../common/components/endpoint/link_to_app';

const ProtectionRadioGroup = styled.div`
  display: flex;
  .policyDetailsProtectionRadio {
    margin-right: ${(props) => props.theme.eui.euiSizeXXL};
  }
`;

const OSes: Immutable<MalwareProtectionOSes[]> = [OS.windows, OS.mac];
const protection = 'malware';

const ProtectionRadio = React.memo(({ id, label }: { id: ProtectionModes; label: string }) => {
  const policyDetailsConfig = usePolicyDetailsSelector(policyConfig);
  const dispatch = useDispatch();
  const radioButtonId = useMemo(() => htmlIdGenerator()(), []);
  // currently just taking windows.malware, but both windows.malware and mac.malware should be the same value
  const selected = policyDetailsConfig && policyDetailsConfig.windows.malware.mode;

  const handleRadioChange = useCallback(() => {
    if (policyDetailsConfig) {
      const newPayload = clone(policyDetailsConfig);
      for (const os of OSes) {
        newPayload[os][protection].mode = id;
      }
      dispatch({
        type: 'userChangedPolicyConfig',
        payload: { policyConfig: newPayload },
      });
    }
  }, [dispatch, id, policyDetailsConfig]);

  /**
   *  Passing an arbitrary id because EuiRadio
   *  requires an id if label is passed
   */

  return (
    <EuiRadio
      className="policyDetailsProtectionRadio"
      label={label}
      id={radioButtonId}
      checked={selected === id}
      onChange={handleRadioChange}
      disabled={selected === ProtectionModes.off}
    />
  );
});

ProtectionRadio.displayName = 'ProtectionRadio';

/** The Malware Protections form for policy details
 *  which will configure for all relevant OSes.
 */
export const MalwareProtections = React.memo(() => {
  const policyDetailsConfig = usePolicyDetailsSelector(policyConfig);
  const dispatch = useDispatch();
  // currently just taking windows.malware, but both windows.malware and mac.malware should be the same value
  const selected = policyDetailsConfig && policyDetailsConfig.windows.malware.mode;

  const radios: Immutable<Array<{
    id: ProtectionModes;
    label: string;
    protection: 'malware';
  }>> = useMemo(() => {
    return [
      {
        id: ProtectionModes.detect,
        label: i18n.translate('xpack.securitySolution.endpoint.policy.details.detect', {
          defaultMessage: 'Detect',
        }),
        protection: 'malware',
      },
      {
        id: ProtectionModes.prevent,
        label: i18n.translate('xpack.securitySolution.endpoint.policy.details.prevent', {
          defaultMessage: 'Prevent',
        }),
        protection: 'malware',
      },
    ];
  }, []);

  const handleSwitchChange = useCallback(
    (event) => {
      if (policyDetailsConfig) {
        const newPayload = clone(policyDetailsConfig);
        if (event.target.checked === false) {
          for (const os of OSes) {
            newPayload[os][protection].mode = ProtectionModes.off;
          }
        } else {
          for (const os of OSes) {
            newPayload[os][protection].mode = ProtectionModes.prevent;
          }
        }
        dispatch({
          type: 'userChangedPolicyConfig',
          payload: { policyConfig: newPayload },
        });
      }
    },
    [dispatch, policyDetailsConfig]
  );

  const radioButtons = useMemo(() => {
    return (
      <>
        <EuiTitle size="xxxs">
          <h6>
            <FormattedMessage
              id="xpack.securitySolution.endpoint.policyDetailsConfig.protectionLevel"
              defaultMessage="Protection Level"
            />
          </h6>
        </EuiTitle>
        <EuiSpacer size="xs" />
        <ProtectionRadioGroup>
          {radios.map((radio) => {
            return (
              <ProtectionRadio
                id={radio.id}
                key={radio.protection + radio.id}
                label={radio.label}
              />
            );
          })}
        </ProtectionRadioGroup>
      </>
    );
  }, [radios]);

  const protectionSwitch = useMemo(() => {
    return (
      <EuiSwitch
        label={i18n.translate(
          'xpack.securitySolution.endpoint.policy.details.malwareProtectionsEnabled',
          {
            defaultMessage: 'Malware Protections {mode, select, true {Enabled} false {Disabled}}',
            values: {
              mode: selected !== ProtectionModes.off,
            },
          }
        )}
        checked={selected !== ProtectionModes.off}
        onChange={handleSwitchChange}
      />
    );
  }, [handleSwitchChange, selected]);

  return (
    <ConfigForm
      type={i18n.translate('xpack.securitySolution.endpoint.policy.details.malware', {
        defaultMessage: 'Malware',
      })}
      supportedOss={i18n.translate('xpack.securitySolution.endpoint.policy.details.windowsAndMac', {
        defaultMessage: 'Windows, Mac',
      })}
      dataTestSubj="malwareProtectionsForm"
      rightCorner={protectionSwitch}
    >
      {radioButtons}
      <EuiSpacer size="m" />
      <EuiCallOut iconType="iInCircle">
        <FormattedMessage
          id="xpack.securitySolution.endpoint.policy.details.detectionRulesMessage"
          defaultMessage="View {detectionRulesLink}. Prebuilt rules are tagged “Elastic” on the Detection Rules page."
          values={{
            detectionRulesLink: (
              <LinkToApp appId={`${APP_ID}:${SecurityPageName.detections}`} appPath={`/rules`}>
                <FormattedMessage
                  id="xpack.securitySolution.endpoint.policy.details.detectionRulesLink"
                  defaultMessage="related detection rules"
                />
              </LinkToApp>
            ),
          }}
        />
      </EuiCallOut>
    </ConfigForm>
  );
});

MalwareProtections.displayName = 'MalwareProtections';
