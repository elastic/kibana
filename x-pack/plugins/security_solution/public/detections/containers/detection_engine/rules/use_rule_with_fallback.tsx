/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { useCallback, useEffect, useMemo } from 'react';
import { useAsync, withOptionalSignal } from '@kbn/securitysolution-hook-utils';
import { useAppToasts } from '../../../../common/hooks/use_app_toasts';
import { isNotFoundError } from '../../../../common/utils/api';
import { useQueryAlerts } from '../alerts/use_query';
import { fetchRuleById } from './api';
import { transformInput } from './transforms';
import * as i18n from './translations';
import { Rule } from './types';

interface UseRuleWithFallback {
  error: unknown;
  loading: boolean;
  isExistingRule: boolean;
  refresh: () => void;
  rule: Rule | null;
}

interface AlertHit {
  _id: string;
  _index: string;
  _source: {
    '@timestamp': string;
    signal: {
      rule: Rule;
    };
  };
}

const fetchWithOptionslSignal = withOptionalSignal(fetchRuleById);

const useFetchRule = () => useAsync(fetchWithOptionslSignal);

const buildLastAlertQuery = (ruleId: string) => ({
  query: {
    bool: {
      filter: [{ match: { 'signal.rule.id': ruleId } }],
    },
  },
  size: 1,
});

/**
 * We try to fetch the rule first. If the request fails with 404, that could mean that the rule was deleted.
 * In that case, try to fetch the latest alert generated by the rule and retrieve the rule data from the alert (fallback).
 */
export const useRuleWithFallback = (ruleId: string): UseRuleWithFallback => {
  const { start, loading: ruleLoading, result: ruleData, error } = useFetchRule();
  const { addError } = useAppToasts();

  const fetch = useCallback(() => {
    start({ id: ruleId });
  }, [ruleId, start]);

  useEffect(() => {
    fetch();
  }, [fetch]);

  const isExistingRule = !isNotFoundError(error);

  const { loading: alertsLoading, data: alertsData } = useQueryAlerts<AlertHit, undefined>({
    query: buildLastAlertQuery(ruleId),
    skip: isExistingRule,
  });

  useEffect(() => {
    if (error != null && !isNotFoundError(error)) {
      addError(error, { title: i18n.RULE_AND_TIMELINE_FETCH_FAILURE });
    }
  }, [addError, error]);

  const rule = useMemo<Rule | undefined>(() => {
    const result = isExistingRule ? ruleData : alertsData?.hits.hits[0]?._source.signal.rule;
    if (result) {
      return transformInput(result);
    }
  }, [isExistingRule, alertsData, ruleData]);

  return {
    error,
    loading: ruleLoading || alertsLoading,
    refresh: fetch,
    rule: rule ?? null,
    isExistingRule,
  };
};
