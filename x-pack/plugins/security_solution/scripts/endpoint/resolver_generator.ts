/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
/* eslint-disable no-console */
import * as path from 'path';
import yargs from 'yargs';
import * as url from 'url';
import fetch from 'node-fetch';
import seedrandom from 'seedrandom';
import { Client, ClientOptions } from '@elastic/elasticsearch';
import { ResponseError } from '@elastic/elasticsearch/lib/errors';
import { EndpointDocGenerator, Event } from '../../common/endpoint/generate_data';

main();

async function deleteIndices(indices: string[], client: Client) {
  const handleErr = (err: unknown) => {
    if (err instanceof ResponseError && err.statusCode !== 404) {
      console.log(JSON.stringify(err, null, 2));
      // eslint-disable-next-line no-process-exit
      process.exit(1);
    }
  };

  for (const index of indices) {
    try {
      // The index could be a data stream so let's try deleting that first
      // The ES client in Kibana doesn't support data streams yet so we need to make a raw request to the ES route
      await client.transport.request({ method: 'DELETE', path: `_data_stream/${index}` });
    } catch (err) {
      handleErr(err);
    }
  }
}

async function doIngestSetup(kibanaURL: string) {
  try {
    const kbURL = new url.URL(kibanaURL);
    // this includes the base path that is randomly generated by Kibana
    const pathname = path.posix.join(path.posix.sep, kbURL.pathname, 'api/ingest_manager/setup');
    const connectURL = new url.URL(pathname, kbURL);
    console.log('Calling ingest manager setup at ', connectURL.toString());
    const response = await fetch(
      // wrap base url in URL class because the kibana basepath will get removed otherwise
      connectURL.toString(),
      {
        method: 'POST',
        headers: {
          'kbn-xsrf': 'blah',
        },
      }
    );
    if (response.status !== 200) {
      console.log('POST response ', response);
      console.log(
        'Request failed please check that you have the correct base path and credentials for the kibana URL'
      );
      // eslint-disable-next-line no-process-exit
      process.exit(1);
    }
    const setupResponse = await response.json();
    console.log('Ingest setup response ', setupResponse);
    if (!setupResponse?.isInitialized) {
      console.log('Initializing the ingest manager failed, existing');
      // eslint-disable-next-line no-process-exit
      process.exit(1);
    }
  } catch (error) {
    console.log(JSON.stringify(error, null, 2));
    // eslint-disable-next-line no-process-exit
    process.exit(1);
  }
}

async function main() {
  const argv = yargs.help().options({
    seed: {
      alias: 's',
      describe: 'random seed to use for document generator',
      type: 'string',
    },
    node: {
      alias: 'n',
      describe: 'elasticsearch node url',
      default: 'http://elastic:changeme@localhost:9200',
      type: 'string',
    },
    kibana: {
      alias: 'k',
      describe: 'kibana url',
      default: 'http://elastic:changeme@localhost:5601',
      type: 'string',
    },
    eventIndex: {
      alias: 'ei',
      describe: 'index to store events in',
      default: 'events-endpoint-1',
      type: 'string',
    },
    metadataIndex: {
      alias: 'mi',
      describe: 'index to store host metadata in',
      default: 'metrics-endpoint.metadata-default-1',
      type: 'string',
    },
    policyIndex: {
      alias: 'pi',
      describe: 'index to store host policy in',
      default: 'metrics-endpoint.policy-default-1',
      type: 'string',
    },
    ancestors: {
      alias: 'anc',
      describe: 'number of ancestors of origin to create',
      type: 'number',
      default: 3,
    },
    generations: {
      alias: 'gen',
      describe: 'number of child generations to create',
      type: 'number',
      default: 3,
    },
    children: {
      alias: 'ch',
      describe: 'maximum number of children per node',
      type: 'number',
      default: 3,
    },
    relatedEvents: {
      alias: 'related',
      describe: 'number of related events to create for each process event',
      type: 'number',
      default: 5,
    },
    percentWithRelated: {
      alias: 'pr',
      describe: 'percent of process events to add related events to',
      type: 'number',
      default: 30,
    },
    percentTerminated: {
      alias: 'pt',
      describe: 'percent of process events to add termination event for',
      type: 'number',
      default: 30,
    },
    maxChildrenPerNode: {
      alias: 'maxCh',
      describe:
        'always generate the max number of children per node instead of it being random up to the max children',
      type: 'boolean',
      default: false,
    },
    numHosts: {
      alias: 'ne',
      describe: 'number of different hosts to generate alerts for',
      type: 'number',
      default: 1,
    },
    numDocs: {
      alias: 'nd',
      describe: 'number of metadata and policy response doc to generate per host',
      type: 'number',
      default: 5,
    },
    alertsPerHost: {
      alias: 'ape',
      describe: 'number of resolver trees to make for each host',
      type: 'number',
      default: 1,
    },
    delete: {
      alias: 'd',
      describe: 'delete indices and remake them',
      type: 'boolean',
      default: false,
    },
  }).argv;
  await doIngestSetup(argv.kibana);

  const clientOptions: ClientOptions = {
    node: argv.node,
  };

  const client = new Client(clientOptions);
  if (argv.delete) {
    await deleteIndices([argv.eventIndex, argv.metadataIndex, argv.policyIndex], client);
  }

  let seed = argv.seed;
  if (!seed) {
    seed = Math.random().toString();
    console.log(`No seed supplied, using random seed: ${seed}`);
  }
  const random = seedrandom(seed);
  const startTime = new Date().getTime();
  for (let i = 0; i < argv.numHosts; i++) {
    const generator = new EndpointDocGenerator(random);
    const timeBetweenDocs = 6 * 3600 * 1000; // 6 hours between metadata documents

    const timestamp = new Date().getTime();
    for (let j = 0; j < argv.numDocs; j++) {
      generator.updateHostData();
      generator.updatePolicyId();
      await client.index({
        index: argv.metadataIndex,
        body: generator.generateHostMetadata(timestamp - timeBetweenDocs * (argv.numDocs - j - 1)),
        op_type: 'create',
      });
      await client.index({
        index: argv.policyIndex,
        body: generator.generatePolicyResponse(
          timestamp - timeBetweenDocs * (argv.numDocs - j - 1)
        ),
        op_type: 'create',
      });
    }

    const alertGenerator = generator.alertsGenerator(
      argv.alertsPerHost,
      argv.ancestors,
      argv.generations,
      argv.children,
      argv.relatedEvents,
      argv.percentWithRelated,
      argv.percentTerminated,
      argv.maxChildrenPerNode
    );
    let result = alertGenerator.next();
    while (!result.done) {
      let k = 0;
      const resolverDocs: Event[] = [];
      while (k < 1000 && !result.done) {
        resolverDocs.push(result.value);
        result = alertGenerator.next();
        k++;
      }
      const body = resolverDocs.reduce(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (array: Array<Record<string, any>>, doc) => (
          array.push({ create: { _index: argv.eventIndex } }, doc), array
        ),
        []
      );
      await client.bulk({ body, refresh: 'true' });
    }
  }
  console.log(`Creating and indexing documents took: ${new Date().getTime() - startTime}ms`);
}
