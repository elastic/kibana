/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 *
 * info:
 *   title: Perform Rule Upgrade API endpoint
 *   version: 2023-10-31
 */

import { z } from 'zod';

import {
  RuleSignatureId,
  RuleVersion,
  RuleName,
  RuleTagArray,
  RuleDescription,
  Severity,
  SeverityMapping,
  RiskScore,
  RiskScoreMapping,
  RuleReferenceArray,
  RuleFalsePositiveArray,
  ThreatArray,
  InvestigationGuide,
  SetupGuide,
  RelatedIntegrationArray,
  RequiredFieldArray,
  MaxSignals,
  BuildingBlockType,
  RuleIntervalFrom,
  RuleInterval,
  RuleExceptionList,
  RuleNameOverride,
  TimestampOverride,
  TimestampOverrideFallbackDisabled,
  TimelineTemplateId,
  TimelineTemplateTitle,
  IndexPatternArray,
  DataViewId,
  RuleQuery,
  QueryLanguage,
  RuleFilterArray,
  SavedQueryId,
  KqlQueryLanguage,
} from '../../model/rule_schema/common_attributes.gen';
import {
  MachineLearningJobId,
  AnomalyThreshold,
} from '../../model/rule_schema/specific_attributes/ml_attributes.gen';
import {
  ThreatQuery,
  ThreatMapping,
  ThreatIndex,
  ThreatFilters,
  ThreatIndicatorPath,
} from '../../model/rule_schema/specific_attributes/threat_match_attributes.gen';
import {
  NewTermsFields,
  HistoryWindowStart,
} from '../../model/rule_schema/specific_attributes/new_terms_attributes.gen';
import { RuleResponse } from '../../model/rule_schema/rule_schemas.gen';
import { ErrorSchema } from '../../model/error_schema.gen';

export type PickVersionValues = z.infer<typeof PickVersionValues>;
export const PickVersionValues = z.enum(['BASE', 'CURRENT', 'TARGET', 'MERGED']);
export type PickVersionValuesEnum = typeof PickVersionValues.enum;
export const PickVersionValuesEnum = PickVersionValues.enum;

export type RuleUpgradeSpecifier = z.infer<typeof RuleUpgradeSpecifier>;
export const RuleUpgradeSpecifier = z.object({
  rule_id: RuleSignatureId,
  revision: z.number(),
  version: RuleVersion,
  pick_version: PickVersionValues.optional(),
  /** 
      * Fields that can be customized during the upgrade workflow
as decided in: https://github.com/elastic/kibana/issues/186544
Fields listed here, which are not specified in the request body,
will default to a `pick_version` of `MERGED`.
 
      */
  fields: z
    .object({
      name: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleName,
          }),
        ])
        .optional(),
      tags: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleTagArray,
          }),
        ])
        .optional(),
      description: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleDescription,
          }),
        ])
        .optional(),
      severity: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: Severity,
          }),
        ])
        .optional(),
      severity_mapping: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: SeverityMapping,
          }),
        ])
        .optional(),
      risk_score: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RiskScore,
          }),
        ])
        .optional(),
      risk_score_mapping: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RiskScoreMapping,
          }),
        ])
        .optional(),
      references: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleReferenceArray,
          }),
        ])
        .optional(),
      false_positives: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleFalsePositiveArray,
          }),
        ])
        .optional(),
      threat: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: ThreatArray,
          }),
        ])
        .optional(),
      note: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: InvestigationGuide,
          }),
        ])
        .optional(),
      setup: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: SetupGuide,
          }),
        ])
        .optional(),
      related_integrations: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RelatedIntegrationArray,
          }),
        ])
        .optional(),
      required_fields: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RequiredFieldArray,
          }),
        ])
        .optional(),
      max_signals: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: MaxSignals,
          }),
        ])
        .optional(),
      building_block_type: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: BuildingBlockType,
          }),
        ])
        .optional(),
      from: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleIntervalFrom,
          }),
        ])
        .optional(),
      interval: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleInterval,
          }),
        ])
        .optional(),
      exceptions_list: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleExceptionList,
          }),
        ])
        .optional(),
      rule_name_override: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleNameOverride,
          }),
        ])
        .optional(),
      timestamp_override: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: TimestampOverride,
          }),
        ])
        .optional(),
      timestamp_override_fallback_disabled: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: TimestampOverrideFallbackDisabled,
          }),
        ])
        .optional(),
      timeline_id: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: TimelineTemplateId,
          }),
        ])
        .optional(),
      timeline_title: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: TimelineTemplateTitle,
          }),
        ])
        .optional(),
      index: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: IndexPatternArray,
          }),
        ])
        .optional(),
      data_view_id: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: DataViewId,
          }),
        ])
        .optional(),
      query: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleQuery,
          }),
        ])
        .optional(),
      language: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: QueryLanguage,
          }),
        ])
        .optional(),
      filters: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: RuleFilterArray,
          }),
        ])
        .optional(),
      saved_id: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: SavedQueryId,
          }),
        ])
        .optional(),
      machine_learning_job_id: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: MachineLearningJobId,
          }),
        ])
        .optional(),
      anomaly_threshold: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: AnomalyThreshold,
          }),
        ])
        .optional(),
      threat_query: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: ThreatQuery,
          }),
        ])
        .optional(),
      threat_mapping: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: ThreatMapping,
          }),
        ])
        .optional(),
      threat_index: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: ThreatIndex,
          }),
        ])
        .optional(),
      threat_filters: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: ThreatFilters,
          }),
        ])
        .optional(),
      threat_indicator_path: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: ThreatIndicatorPath,
          }),
        ])
        .optional(),
      threat_language: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: KqlQueryLanguage,
          }),
        ])
        .optional(),
      new_terms_fields: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: NewTermsFields,
          }),
        ])
        .optional(),
      history_window_start: z
        .union([
          z.object({
            pick_version: PickVersionValues,
          }),
          z.object({
            pick_version: z.literal('RESOLVED'),
            resolved_value: HistoryWindowStart,
          }),
        ])
        .optional(),
    })
    .optional(),
});

export type UpgradeSpecificRulesRequest = z.infer<typeof UpgradeSpecificRulesRequest>;
export const UpgradeSpecificRulesRequest = z.object({
  mode: z.literal('SPECIFIC_RULES'),
  rules: z.array(RuleUpgradeSpecifier),
  pick_version: PickVersionValues.optional(),
});

export type UpgradeAllRulesRequest = z.infer<typeof UpgradeAllRulesRequest>;
export const UpgradeAllRulesRequest = z.object({
  mode: z.literal('ALL_RULES'),
  pick_version: PickVersionValues.optional(),
});

export type SkipRuleUpgradeReason = z.infer<typeof SkipRuleUpgradeReason>;
export const SkipRuleUpgradeReason = z.enum(['RULE_UP_TO_DATE', 'RULE_NOT_FOUND']);
export type SkipRuleUpgradeReasonEnum = typeof SkipRuleUpgradeReason.enum;
export const SkipRuleUpgradeReasonEnum = SkipRuleUpgradeReason.enum;

export type SkippedRuleUpgrade = z.infer<typeof SkippedRuleUpgrade>;
export const SkippedRuleUpgrade = z.object({
  rule_id: z.string(),
  reason: SkipRuleUpgradeReason,
});

export type PerformRuleUpgradeResponseBody = z.infer<typeof PerformRuleUpgradeResponseBody>;
export const PerformRuleUpgradeResponseBody = z.object({
  summary: z.object({
    total: z.number(),
    succeeded: z.number(),
    skipped: z.number(),
    failed: z.number(),
  }),
  results: z.object({
    updated: z.array(RuleResponse),
    skipped: z.array(SkippedRuleUpgrade),
  }),
  errors: z.array(ErrorSchema),
});

export type PerformRuleUpgradeRequestBody = z.infer<typeof PerformRuleUpgradeRequestBody>;
export const PerformRuleUpgradeRequestBody = z.union([
  UpgradeAllRulesRequest,
  UpgradeSpecificRulesRequest,
]);
export type PerformRuleUpgradeRequestBodyInput = z.input<typeof PerformRuleUpgradeRequestBody>;

export type PerformRuleUpgradeResponse = z.infer<typeof PerformRuleUpgradeResponse>;
export const PerformRuleUpgradeResponse = PerformRuleUpgradeResponseBody;
