/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { z } from 'zod';

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 */

export type Action = z.infer<typeof Action>;
export const Action = z.object({
  /**
   * The action type used for sending notifications.
   */
  action_type_id: z.string(),
  /**
   * Optionally groups actions by use cases. Use `default` for alert notifications.
   */
  group: z.string(),
  /**
   * The connector ID.
   */
  id: z.string(),
  /**
   * Object containing the allowed connector fields, which varies according to the connector type.
   */
  params: z.object({}),
  uuid: z.string().optional(),
  /**
   * TODO implement the schema type
   */
  alerts_filter: z.object({}).optional(),
  /**
   * TODO implement the schema type
   */
  frequency: z.object({}).optional(),
});

export type AlertSuppression = z.infer<typeof AlertSuppression>;
export const AlertSuppression = z.object({
  group_by: z.array(z.string()).min(1).max(3),
  duration: z
    .object({
      value: z.number().int().min(1),
      unit: z.enum(['s', 'm', 'h']),
    })
    .optional(),
  missing_fields_strategy: z.enum(['doNotSuppress', 'suppress']).optional(),
});

export type BaseRule = z.infer<typeof BaseRule>;
export const BaseRule = z.object({
  /**
   * Rule name
   */
  name: z.string(),
  /**
   * Rule description
   */
  description: z.string(),
  /**
   * Risk score (0 to 100)
   */
  risk_score: z.number().int().min(0).max(100),
  /**
   * Severity of the rule
   */
  severity: z.enum(['low', 'medium', 'high', 'critical']),
  /**
   * Sets the source field for the alert's signal.rule.name value
   */
  rule_name_override: z.string().optional(),
  /**
   * Sets the time field used to query indices (optional)
   */
  timestamp_override: z.string().optional(),
  /**
   * Timeline template ID
   */
  timeline_id: z.string().optional(),
  /**
   * Timeline template title
   */
  timeline_title: z.string().optional(),
  outcome: z.enum(['exactMatch', 'aliasMatch', 'conflict']).optional(),
  /**
   * TODO
   */
  alias_target_id: z.string().optional(),
  /**
   * TODO
   */
  alias_purpose: z.enum(['savedObjectConversion', 'savedObjectImport']).optional(),
  /**
   * The rule’s license.
   */
  license: z.string().optional(),
  /**
   * Notes to help investigate alerts produced by the rule.
   */
  note: z.string().optional(),
  /**
   * Determines if the rule acts as a building block. By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts. Its value must be default.
   */
  building_block_type: z.string().optional(),
  /**
   * (deprecated) Has no effect.
   */
  output_index: z.string().optional(),
  /**
   * Has no effect.
   */
  namespace: z.string().optional(),
  /**
   * Stores rule metadata.
   */
  meta: z.object({}).optional(),
  /**
   * Defines the interval on which a rule's actions are executed.
   */
  throttle: z.string().optional(),
  /**
   * The rule’s version number. Defaults to 1.
   */
  version: z.number().int().min(1).optional().default(1),
  /**
   * String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
   */
  tags: z.array(z.string()).optional().default([]),
  /**
   * Determines whether the rule is enabled. Defaults to true.
   */
  enabled: z.boolean().optional().default(true),
  /**
   * Overrides generated alerts' risk_score with a value from the source event
   */
  risk_score_mapping: z
    .array(
      z.object({
        field: z.string(),
        operator: z.enum(['equals']),
        value: z.string(),
        risk_score: z.number().int().min(0).max(100).optional(),
      })
    )
    .optional()
    .default([]),
  /**
   * Overrides generated alerts' severity with values from the source event
   */
  severity_mapping: z
    .array(
      z.object({
        field: z.string(),
        operator: z.enum(['equals']),
        severity: z.enum(['low', 'medium', 'high', 'critical']),
        value: z.string(),
      })
    )
    .optional()
    .default([]),
  /**
   * Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
   */
  interval: z.string().optional().default('5m'),
  /**
   * Time from which data is analyzed each time the rule executes, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
   */
  from: z.string().optional().default('now-6m'),
  /**
   * TODO
   */
  to: z.string().optional().default('now'),
  actions: z.array(Action).optional().default([]),
  exceptions_list: z
    .array(
      z.object({
        /**
         * ID of the exception container
         */
        id: z.string().min(1),
        /**
         * List ID of the exception container
         */
        list_id: z.string().min(1),
        /**
         * The exception type
         */
        type: z.enum([
          'detection',
          'rule_default',
          'endpoint',
          'endpoint_trusted_apps',
          'endpoint_events',
          'endpoint_host_isolation_exceptions',
          'endpoint_blocklists',
        ]),
        /**
         * Determines the exceptions validity in rule's Kibana space
         */
        namespace_type: z.enum(['agnostic', 'single']),
      })
    )
    .optional()
    .default([]),
  author: z.array(z.string()).optional().default([]),
  false_positives: z.array(z.string()).optional().default([]),
  references: z.array(z.string()).optional().default([]),
  max_signals: z.number().int().min(1).optional().default(100),
  threat: z
    .array(
      z.object({
        /**
         * Relevant attack framework
         */
        framework: z.string(),
        tactic: z.object({
          id: z.string(),
          name: z.string(),
          reference: z.string(),
        }),
        technique: z
          .array(
            z.object({
              id: z.string(),
              name: z.string(),
              reference: z.string(),
              subtechnique: z
                .array(
                  z.object({
                    id: z.string(),
                    name: z.string(),
                    reference: z.string(),
                  })
                )
                .optional(),
            })
          )
          .optional(),
      })
    )
    .optional(),
});

export type QueryRule = z.infer<typeof QueryRule>;
export const QueryRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['query']),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.unknown()).optional(),
    saved_id: z.string().optional(),
    /**
     * TODO
     */
    response_actions: z.array(z.object({})).optional(),
    alert_suppression: AlertSuppression.optional(),
    /**
     * Query to execute
     */
    query: z.string().optional().default(''),
    /**
     * Query language to use.
     */
    language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
  })
);

export type SavedQueryRule = z.infer<typeof SavedQueryRule>;
export const SavedQueryRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['saved_query']),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.unknown()).optional(),
    saved_id: z.string(),
    /**
     * TODO
     */
    response_actions: z.array(z.object({})).optional(),
    alert_suppression: AlertSuppression.optional(),
    /**
     * Query to execute
     */
    query: z.string().optional(),
    /**
     * Query language to use.
     */
    language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
  })
);

export type ThresholdRule = z.infer<typeof ThresholdRule>;
export const ThresholdRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['threshold']),
    query: z.string(),
    threshold: z.object({
      /**
       * Field to aggregate on
       */
      field: z.union([z.string(), z.array(z.string())]),
      /**
       * Threshold value
       */
      value: z.number().int().min(1).optional(),
      cardinality: z
        .array(
          z.object({
            field: z.string().optional(),
            value: z.number().int().min(0).optional(),
          })
        )
        .optional(),
    }),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.unknown()).optional(),
    saved_id: z.string().optional(),
    /**
     * Query language to use.
     */
    language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
  })
);

export type ThreatMatchRule = z.infer<typeof ThreatMatchRule>;
export const ThreatMatchRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['threat_match']),
    query: z.string(),
    /**
     * Query to execute
     */
    threat_query: z.string(),
    threat_mapping: z
      .array(
        z.object({
          entries: z
            .array(
              z.object({
                field: z.string().min(1).optional(),
                type: z.enum(['mapping']).optional(),
                value: z.string().min(1).optional(),
              })
            )
            .optional(),
        })
      )
      .min(1),
    threat_index: z.array(z.string()),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.unknown()).optional(),
    saved_id: z.string().optional(),
    threat_filters: z.array(z.unknown()).optional(),
    /**
     * Defines the path to the threat indicator in the indicator documents (optional)
     */
    threat_indicator_path: z.string().optional(),
    /**
     * Query language to use.
     */
    threat_language: z.enum(['kuery', 'lucene']).optional(),
    concurrent_searches: z.number().int().min(1).optional(),
    items_per_search: z.number().int().min(1).optional(),
    /**
     * Query language to use.
     */
    language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
  })
);

export type MlRule = z.infer<typeof MlRule>;
export const MlRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['machine_learning']),
    /**
     * Anomaly threshold
     */
    anomaly_threshold: z.number().int().min(0),
    /**
     * Machine learning job ID
     */
    machine_learning_job_id: z.union([z.string(), z.array(z.string()).min(1)]),
  })
);

export type EqlRule = z.infer<typeof EqlRule>;
export const EqlRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['eql']),
    language: z.enum(['eql']),
    /**
     * EQL query to execute
     */
    query: z.string(),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.unknown()).optional(),
    /**
     * Contains the event classification
     */
    event_category_field: z.string().optional(),
    /**
     * Sets a secondary field for sorting events
     */
    tiebreaker_field: z.string().optional(),
    /**
     * Contains the event timestamp used for sorting a sequence of events
     */
    timestamp_field: z.string().optional(),
  })
);

export type NewTermsRule = z.infer<typeof NewTermsRule>;
export const NewTermsRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['new_terms']),
    query: z.string(),
    new_terms_fields: z.array(z.string()).min(1).max(3),
    history_window_size: z.string().min(1).optional(),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.unknown()).optional(),
    language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
  })
);

export type Rule = z.infer<typeof Rule>;
export const Rule = z.union([
  QueryRule,
  SavedQueryRule,
  ThresholdRule,
  ThreatMatchRule,
  MlRule,
  EqlRule,
  NewTermsRule,
]);

/**
 * Defines the maximum interval in which a rule's actions are executed.
 */
export type Throttle = z.infer<typeof Throttle>;
export const Throttle = z.enum(['rule', '1h', '1d', '7d']);
export const ThrottleEnum = Throttle.enum;
export type ThrottleEnum = typeof Throttle.enum;

export type Subtechnique = z.infer<typeof Subtechnique>;
export const Subtechnique = z.object({
  /**
   * Subtechnique ID
   */
  id: z.string(),
  /**
   * Subtechnique name
   */
  name: z.string(),
  /**
   * Subtechnique reference
   */
  reference: z.string(),
});

export type Technique = z.infer<typeof Technique>;
export const Technique = z.object({
  /**
   * Technique ID
   */
  id: z.string(),
  /**
   * Technique name
   */
  name: z.string(),
  /**
   * Technique reference
   */
  reference: z.string(),
  /**
   * Array containing more specific information on the attack technique
   */
  subtechnique: z.array(Subtechnique).optional(),
});

export type Threat = z.infer<typeof Threat>;
export const Threat = z.object({
  /**
   * Relevant attack framework
   */
  framework: z.string(),
  tactic: z.object({
    /**
     * Tactic ID
     */
    id: z.string(),
    /**
     * Tactic name
     */
    name: z.string(),
    /**
     * Tactic reference
     */
    reference: z.string(),
  }),
  /**
   * Array containing information on the attack techniques (optional)
   */
  technique: z.array(Technique).optional(),
});

export type RuleResponse = z.infer<typeof RuleResponse>;
export const RuleResponse = z.object({});

export type RuleCreateProps = z.infer<typeof RuleCreateProps>;
export const RuleCreateProps = z.object({});

export type RuleUpdateProps = z.infer<typeof RuleUpdateProps>;
export const RuleUpdateProps = z.object({});

export type RulePatchProps = z.infer<typeof RulePatchProps>;
export const RulePatchProps = z.object({});
