/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { z } from 'zod';
import type { RequiredOptional } from '@kbn/zod-helpers';
import { requireOptional, isValidDateMath } from '@kbn/zod-helpers';

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 */

import {
  RuleName,
  RuleDescription,
  RuleLicense,
  RuleMetadata,
  InvestigationFields,
  RuleActionThrottle,
  RuleVersion,
  RuleTagArray,
  IsRuleEnabled,
  RuleAction,
  ThreatArray,
  RuleObjectId,
  RuleSignatureId,
  RelatedIntegrationArray,
  RequiredFieldArray,
  SetupGuide,
} from './common_attributes.gen';
import { RuleExecutionSummary } from '../../rule_monitoring/model/execution_summary.gen';
import {
  EventCategoryOverride,
  TiebreakerField,
  TimestampField,
} from './specific_attributes/eql_attributes.gen';
import { ResponseAction } from '../rule_response_actions/response_actions.gen';
import { AlertSuppression } from './specific_attributes/query_attributes.gen';
import { Threshold } from './specific_attributes/threshold_attributes.gen';
import { NewTermsFields, HistoryWindowStart } from './specific_attributes/new_terms_attributes.gen';

export interface BaseRequiredFields {
  name: RuleName;
  description: RuleDescription;
  /**
   * A numerical representation of the alert’s severity from 0 to 100.
   * @example
   * 0 - 21 represents low severity
   * 22 - 47 represents medium severity
   * 48 - 73 represents high severity
   * 74 - 100 represents critical severity
   */
  risk_score: number;
  /**
   * Severity level of alerts produced by the rule
   * @example
   * 'low' Alerts that are of interest but generally not considered to be security incidents
   * 'medium' Alerts that require investigation
   * 'high' Alerts that require immediate investigation
   * 'critical' Alerts that indicate it is highly likely a security incident has occurred
   */
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export const BaseRequiredFields = z.object({
  name: RuleName,
  description: RuleDescription,
  /**
   * A numerical representation of the alert’s severity from 0 to 100.
   */
  risk_score: z.number().int().min(0).max(100),
  /**
   * Severity level of alerts produced by the rule
   */
  severity: z.enum(['low', 'medium', 'high', 'critical']),
});

export interface BaseOptionalFields {
  /**
   * Sets the source field for the alert's signal.rule.name value
   */
  rule_name_override?: string;
  /**
   * Sets the time field used to query indices
   */
  timestamp_override?: string;
  /**
   * Disables the fallback to the event's @timestamp field
   */
  timestamp_override_fallback_disabled?: boolean;
  /**
   * Timeline template ID
   */
  timeline_id?: string;
  /**
   * Timeline template title
   */
  timeline_title?: string;
  /**
   * Outcome is a property of the saved object resolve API. It will provide information about the rule following the 8.0 migrations
   */
  outcome?: 'exactMatch' | 'aliasMatch' | 'conflict';
  alias_target_id?: string;
  alias_purpose?: 'savedObjectConversion' | 'savedObjectImport';
  license?: RuleLicense;
  /**
   * Notes to help investigate alerts produced by the rule.
   */
  note?: string;
  /**
   * Determines if the rule acts as a building block. By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts. Its value must be default. For more information, refer to https://www.elastic.co/guide/en/security/current/building-block-rule.html.
   */
  building_block_type?: string;
  /**
   * (deprecated) Has no effect.
   */
  output_index?: string;
  /**
   * Has no effect.
   */
  namespace?: string;
  meta?: RuleMetadata;
  investigation_fields?: InvestigationFields;
  throttle?: RuleActionThrottle;
}

export const BaseOptionalFields = z.object({
  /**
   * Sets the source field for the alert's signal.rule.name value
   */
  rule_name_override: z.string().optional(),
  /**
   * Sets the time field used to query indices
   */
  timestamp_override: z.string().optional(),
  /**
   * Disables the fallback to the event's @timestamp field
   */
  timestamp_override_fallback_disabled: z.boolean().optional(),
  /**
   * Timeline template ID
   */
  timeline_id: z.string().optional(),
  /**
   * Timeline template title
   */
  timeline_title: z.string().optional(),
  /**
   * Outcome is a property of the saved object resolve API. It will provide information about the rule following the 8.0 migrations
   */
  outcome: z.enum(['exactMatch', 'aliasMatch', 'conflict']).optional(),
  alias_target_id: z.string().optional(),
  alias_purpose: z.enum(['savedObjectConversion', 'savedObjectImport']).optional(),
  license: RuleLicense.optional(),
  /**
   * Notes to help investigate alerts produced by the rule.
   */
  note: z.string().optional(),
  /**
   * Determines if the rule acts as a building block. By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts. Its value must be default. For more information, refer to https://www.elastic.co/guide/en/security/current/building-block-rule.html.
   */
  building_block_type: z.string().optional(),
  /**
   * (deprecated) Has no effect.
   */
  output_index: z.string().optional(),
  /**
   * Has no effect.
   */
  namespace: z.string().optional(),
  meta: RuleMetadata.optional(),
  investigation_fields: InvestigationFields.optional(),
  throttle: RuleActionThrottle.optional(),
});

export interface BaseDefaultableFields {
  version?: RuleVersion;
  tags?: RuleTagArray;
  enabled?: IsRuleEnabled;
  /**
   * Overrides generated alerts' risk_score with a value from the source event
   */
  risk_score_mapping?: Array<
    RequiredOptional<{
      field: string;
      operator: 'equals';
      value: string;
      risk_score?: number;
    }>
  >;
  /**
   * Overrides generated alerts' severity with values from the source event
   */
  severity_mapping?: Array<{
    field: string;
    operator: 'equals';
    severity: 'low' | 'medium' | 'high' | 'critical';
    value: string;
  }>;
  /**
   * Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
   */
  interval?: string;
  /**
   * Time from which data is analyzed each time the rule executes, using a date math range. Defaults to now-6m (analyzes data from 6 minutes before the start time).
   * @example
   * 'now-4200s' - Means the rule analyzes data from 70 minutes before its start time
   */
  from?: string;
  to?: string;
  actions?: RuleAction[];
  exceptions_list?: Array<{
    /**
     * ID of the exception container
     */
    id: string;
    /**
     * List ID of the exception container
     */
    list_id: string;
    /**
     * The exception type
     */
    type:
      | 'detection'
      | 'rule_default'
      | 'endpoint'
      | 'endpoint_trusted_apps'
      | 'endpoint_events'
      | 'endpoint_host_isolation_exceptions'
      | 'endpoint_blocklists';
    /**
     * Determines the exceptions validity in rule's Kibana space
     */
    namespace_type: 'agnostic' | 'single';
  }>;
  author?: string[];
  false_positives?: string[];
  /**
   * Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
   */
  references?: string[];
  /**
   * Maximum number of alerts the rule can create during a single execution. Defaults to 100.
   */
  max_signals?: number;
  threat?: ThreatArray;
}

export const BaseDefaultableFields = z.object({
  version: RuleVersion.optional(),
  tags: RuleTagArray.optional(),
  enabled: IsRuleEnabled.optional(),
  /**
   * Overrides generated alerts' risk_score with a value from the source event
   */
  risk_score_mapping: z
    .array(
      z
        .object({
          field: z.string(),
          operator: z.literal('equals'),
          value: z.string(),
          risk_score: z.number().int().min(0).max(100).optional(),
        })
        .transform(requireOptional)
    )
    .optional(),
  /**
   * Overrides generated alerts' severity with values from the source event
   */
  severity_mapping: z
    .array(
      z.object({
        field: z.string(),
        operator: z.literal('equals'),
        severity: z.enum(['low', 'medium', 'high', 'critical']),
        value: z.string(),
      })
    )
    .optional(),
  /**
   * Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
   */
  interval: z.string().optional(),
  /**
   * Time from which data is analyzed each time the rule executes, using a date math range. Defaults to now-6m (analyzes data from 6 minutes before the start time).
   */
  from: z.string().superRefine(isValidDateMath).optional(),
  to: z.string().optional(),
  actions: z.array(RuleAction).optional(),
  exceptions_list: z
    .array(
      z.object({
        /**
         * ID of the exception container
         */
        id: z.string().min(1),
        /**
         * List ID of the exception container
         */
        list_id: z.string().min(1),
        /**
         * The exception type
         */
        type: z.enum([
          'detection',
          'rule_default',
          'endpoint',
          'endpoint_trusted_apps',
          'endpoint_events',
          'endpoint_host_isolation_exceptions',
          'endpoint_blocklists',
        ]),
        /**
         * Determines the exceptions validity in rule's Kibana space
         */
        namespace_type: z.enum(['agnostic', 'single']),
      })
    )
    .optional(),
  author: z.array(z.string()).optional(),
  false_positives: z.array(z.string()).optional(),
  /**
   * Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
   */
  references: z.array(z.string()).optional(),
  /**
   * Maximum number of alerts the rule can create during a single execution. Defaults to 100.
   */
  max_signals: z.number().int().min(1).optional(),
  threat: ThreatArray.optional(),
});

export type BaseCreateProps = BaseRequiredFields & BaseOptionalFields & BaseDefaultableFields;

export const BaseCreateProps =
  BaseRequiredFields.and(BaseOptionalFields).and(BaseDefaultableFields);

export type BasePatchProps = Partial<BaseRequiredFields> &
  BaseOptionalFields &
  BaseDefaultableFields;

export const BasePatchProps = BaseRequiredFields.partial()
  .and(BaseOptionalFields)
  .and(BaseDefaultableFields);

export type BaseResponseProps = BaseRequiredFields &
  RequiredOptional<BaseOptionalFields> &
  Required<BaseDefaultableFields>;

export const BaseResponseProps = BaseRequiredFields.and(
  BaseOptionalFields.transform(requireOptional)
).and(BaseDefaultableFields.required());

export interface ResponseRequiredFields {
  id: RuleObjectId;
  rule_id: RuleSignatureId;
  /**
   * Immutable rules are prebuilt Elastic rules that cannot be modified by users.
   */
  immutable: boolean;
  updated_at: string;
  updated_by: string;
  created_at: string;
  created_by: string;
  /**
   * Revision is a monotonic counter that is incremented each time the rule is updated. It is used to implement optimistic concurrency control.
   */
  revision: number;
  related_integrations: RelatedIntegrationArray;
  required_fields: RequiredFieldArray;
  setup: SetupGuide;
}

export const ResponseRequiredFields = z.object({
  id: RuleObjectId,
  rule_id: RuleSignatureId,
  /**
   * Immutable rules are prebuilt Elastic rules that cannot be modified by users.
   */
  immutable: z.boolean(),
  updated_at: z.string().datetime(),
  updated_by: z.string(),
  created_at: z.string().datetime(),
  created_by: z.string(),
  /**
   * Revision is a monotonic counter that is incremented each time the rule is updated. It is used to implement optimistic concurrency control.
   */
  revision: z.number().int().min(0),
  related_integrations: RelatedIntegrationArray,
  required_fields: RequiredFieldArray,
  setup: SetupGuide,
});

export interface ResponseOptionalFields {
  execution_summary?: RuleExecutionSummary;
}

export const ResponseOptionalFields = z.object({
  execution_summary: RuleExecutionSummary.optional(),
});

export type SharedCreateProps = BaseCreateProps & {
  rule_id?: RuleSignatureId;
};

export const SharedCreateProps = BaseCreateProps.and(
  z.object({
    rule_id: RuleSignatureId.optional(),
  })
);

export type SharedUpdateProps = BaseCreateProps & {
  id?: RuleObjectId;
  rule_id?: RuleSignatureId;
};

export const SharedUpdateProps = BaseCreateProps.and(
  z.object({
    id: RuleObjectId.optional(),
    rule_id: RuleSignatureId.optional(),
  })
);

export type SharedPatchProps = BasePatchProps & {
  id?: RuleObjectId;
  rule_id?: RuleSignatureId;
};

export const SharedPatchProps = BasePatchProps.and(
  z.object({
    id: RuleObjectId.optional(),
    rule_id: RuleSignatureId.optional(),
  })
);

export type SharedResponseProps = BaseResponseProps &
  ResponseRequiredFields &
  ResponseOptionalFields;

export const SharedResponseProps =
  BaseResponseProps.and(ResponseRequiredFields).and(ResponseOptionalFields);

export type QueryLanguage = 'kuery' | 'lucene' | 'eql' | 'esql';

export const QueryLanguage = z.enum(['kuery', 'lucene', 'eql', 'esql']);
export const QueryLanguageEnum = QueryLanguage.enum;
export type QueryLanguageEnum = typeof QueryLanguage.enum;

export type KqlQueryLanguage = 'kuery' | 'lucene';

export const KqlQueryLanguage = z.enum(['kuery', 'lucene']);
export const KqlQueryLanguageEnum = KqlQueryLanguage.enum;
export type KqlQueryLanguageEnum = typeof KqlQueryLanguage.enum;

export type EqlQueryLanguage = 'eql';

export const EqlQueryLanguage = z.literal('eql');

export interface EqlRequiredFields {
  /**
   * Rule type
   */
  type: 'eql';
  /**
   * EQL query to execute
   */
  query: string;
  /**
   * Query language to use
   */
  language: EqlQueryLanguage;
}

export const EqlRequiredFields = z.object({
  /**
   * Rule type
   */
  type: z.literal('eql'),
  /**
   * EQL query to execute
   */
  query: z.string(),
  /**
   * Query language to use
   */
  language: EqlQueryLanguage,
});

export interface EqlOptionalFields {
  index?: string[];
  data_view_id?: string;
  filters?: unknown[];
  event_category_override?: EventCategoryOverride;
  tiebreaker_field?: TiebreakerField;
  timestamp_field?: TimestampField;
}

export const EqlOptionalFields = z.object({
  index: z.array(z.string()).optional(),
  data_view_id: z.string().optional(),
  filters: z.array(z.unknown()).optional(),
  event_category_override: EventCategoryOverride.optional(),
  tiebreaker_field: TiebreakerField.optional(),
  timestamp_field: TimestampField.optional(),
});

export type EqlRuleCreateFields = EqlRequiredFields & EqlOptionalFields;

export const EqlRuleCreateFields = EqlRequiredFields.and(EqlOptionalFields);

export type EqlRuleResponseFields = EqlRequiredFields & RequiredOptional<EqlOptionalFields>;

export const EqlRuleResponseFields = EqlRequiredFields.and(
  EqlOptionalFields.transform(requireOptional)
);

export type EqlRulePatchFields = Partial<EqlRequiredFields> & EqlOptionalFields;

export const EqlRulePatchFields = EqlRequiredFields.partial().and(EqlOptionalFields);

export type EqlRule = SharedResponseProps & EqlRuleResponseFields;

export const EqlRule = SharedResponseProps.and(EqlRuleResponseFields);

export type EqlRuleCreateProps = SharedCreateProps & EqlRuleCreateFields;

export const EqlRuleCreateProps = SharedCreateProps.and(EqlRuleCreateFields);

export type EqlRuleUpdateProps = SharedUpdateProps & EqlRuleCreateFields;

export const EqlRuleUpdateProps = SharedUpdateProps.and(EqlRuleCreateFields);

export type EqlRulePatchProps = SharedPatchProps & EqlRulePatchFields;

export const EqlRulePatchProps = SharedPatchProps.and(EqlRulePatchFields);

export interface QueryRuleRequiredFields {
  /**
   * Rule type
   */
  type: 'query';
}

export const QueryRuleRequiredFields = z.object({
  /**
   * Rule type
   */
  type: z.literal('query'),
});

export interface QueryRuleOptionalFields {
  index?: string[];
  data_view_id?: string;
  filters?: unknown[];
  /**
   * Kibana saved search used by the rule to create alerts.
   */
  saved_id?: string;
  response_actions?: ResponseAction[];
  alert_suppression?: AlertSuppression;
}

export const QueryRuleOptionalFields = z.object({
  index: z.array(z.string()).optional(),
  data_view_id: z.string().optional(),
  filters: z.array(z.unknown()).optional(),
  /**
   * Kibana saved search used by the rule to create alerts.
   */
  saved_id: z.string().optional(),
  response_actions: z.array(ResponseAction).optional(),
  alert_suppression: AlertSuppression.optional(),
});

export interface QueryRuleDefaultableFields {
  /**
   * Query to execute
   */
  query?: string;
  language?: KqlQueryLanguage;
}

export const QueryRuleDefaultableFields = z.object({
  /**
   * Query to execute
   */
  query: z.string().optional(),
  language: KqlQueryLanguage.optional(),
});

export type QueryRuleCreateFields = QueryRuleRequiredFields &
  QueryRuleOptionalFields &
  QueryRuleDefaultableFields;

export const QueryRuleCreateFields = QueryRuleRequiredFields.and(QueryRuleOptionalFields).and(
  QueryRuleDefaultableFields
);

export type QueryRulePatchFields = Partial<QueryRuleRequiredFields> &
  QueryRuleOptionalFields &
  QueryRuleDefaultableFields;

export const QueryRulePatchFields = QueryRuleRequiredFields.partial()
  .and(QueryRuleOptionalFields)
  .and(QueryRuleDefaultableFields);

export type QueryRuleResponseFields = QueryRuleRequiredFields &
  RequiredOptional<QueryRuleOptionalFields> &
  Required<QueryRuleDefaultableFields>;

export const QueryRuleResponseFields = QueryRuleRequiredFields.and(
  QueryRuleOptionalFields.transform(requireOptional)
).and(QueryRuleDefaultableFields.required());

export type QueryRule = SharedResponseProps & QueryRuleResponseFields;

export const QueryRule = SharedResponseProps.and(QueryRuleResponseFields);

export type QueryRuleCreateProps = SharedCreateProps & QueryRuleCreateFields;

export const QueryRuleCreateProps = SharedCreateProps.and(QueryRuleCreateFields);

export type QueryRuleUpdateProps = SharedUpdateProps & QueryRuleCreateFields;

export const QueryRuleUpdateProps = SharedUpdateProps.and(QueryRuleCreateFields);

export type QueryRulePatchProps = SharedPatchProps & QueryRulePatchFields;

export const QueryRulePatchProps = SharedPatchProps.and(QueryRulePatchFields);

export interface SavedQueryRuleRequiredFields {
  /**
   * Rule type
   */
  type: 'saved_query';
  saved_id: string;
}

export const SavedQueryRuleRequiredFields = z.object({
  /**
   * Rule type
   */
  type: z.literal('saved_query'),
  saved_id: z.string(),
});

export interface SavedQueryRuleOptionalFields {
  index?: string[];
  data_view_id?: string;
  filters?: unknown[];
  response_actions?: ResponseAction[];
  alert_suppression?: AlertSuppression;
  /**
   * Query to execute
   */
  query?: string;
}

export const SavedQueryRuleOptionalFields = z.object({
  index: z.array(z.string()).optional(),
  data_view_id: z.string().optional(),
  filters: z.array(z.unknown()).optional(),
  response_actions: z.array(ResponseAction).optional(),
  alert_suppression: AlertSuppression.optional(),
  /**
   * Query to execute
   */
  query: z.string().optional(),
});

export interface SavedQueryRuleDefaultableFields {
  language?: KqlQueryLanguage;
}

export const SavedQueryRuleDefaultableFields = z.object({
  language: KqlQueryLanguage.optional(),
});

export type SavedQueryRuleCreateFields = SavedQueryRuleRequiredFields &
  SavedQueryRuleOptionalFields &
  SavedQueryRuleDefaultableFields;

export const SavedQueryRuleCreateFields = SavedQueryRuleRequiredFields.and(
  SavedQueryRuleOptionalFields
).and(SavedQueryRuleDefaultableFields);

export type SavedQueryRulePatchFields = Partial<SavedQueryRuleRequiredFields> &
  SavedQueryRuleOptionalFields &
  SavedQueryRuleDefaultableFields;

export const SavedQueryRulePatchFields = SavedQueryRuleRequiredFields.partial()
  .and(SavedQueryRuleOptionalFields)
  .and(SavedQueryRuleDefaultableFields);

export type SavedQueryRuleResponseFields = SavedQueryRuleRequiredFields &
  RequiredOptional<SavedQueryRuleOptionalFields> &
  Required<SavedQueryRuleDefaultableFields>;

export const SavedQueryRuleResponseFields = SavedQueryRuleRequiredFields.and(
  SavedQueryRuleOptionalFields.transform(requireOptional)
).and(SavedQueryRuleDefaultableFields.required());

export type SavedQueryRule = SharedResponseProps & SavedQueryRuleResponseFields;

export const SavedQueryRule = SharedResponseProps.and(SavedQueryRuleResponseFields);

export type SavedQueryRuleCreateProps = SharedCreateProps & SavedQueryRuleCreateFields;

export const SavedQueryRuleCreateProps = SharedCreateProps.and(SavedQueryRuleCreateFields);

export type SavedQueryRuleUpdateProps = SharedUpdateProps & SavedQueryRuleCreateFields;

export const SavedQueryRuleUpdateProps = SharedUpdateProps.and(SavedQueryRuleCreateFields);

export type SavedQueryRulePatchProps = SharedPatchProps & SavedQueryRulePatchFields;

export const SavedQueryRulePatchProps = SharedPatchProps.and(SavedQueryRulePatchFields);

export interface ThresholdRuleRequiredFields {
  /**
   * Rule type
   */
  type: 'threshold';
  query: string;
  threshold: Threshold;
}

export const ThresholdRuleRequiredFields = z.object({
  /**
   * Rule type
   */
  type: z.literal('threshold'),
  query: z.string(),
  threshold: Threshold,
});

export interface ThresholdRuleOptionalFields {
  index?: string[];
  data_view_id?: string;
  filters?: unknown[];
  saved_id?: string;
}

export const ThresholdRuleOptionalFields = z.object({
  index: z.array(z.string()).optional(),
  data_view_id: z.string().optional(),
  filters: z.array(z.unknown()).optional(),
  saved_id: z.string().optional(),
});

export interface ThresholdRuleDefaultableFields {
  language?: KqlQueryLanguage;
}

export const ThresholdRuleDefaultableFields = z.object({
  language: KqlQueryLanguage.optional(),
});

export type ThresholdRuleCreateFields = ThresholdRuleRequiredFields &
  ThresholdRuleOptionalFields &
  ThresholdRuleDefaultableFields;

export const ThresholdRuleCreateFields = ThresholdRuleRequiredFields.and(
  ThresholdRuleOptionalFields
).and(ThresholdRuleDefaultableFields);

export type ThresholdRulePatchFields = Partial<ThresholdRuleRequiredFields> &
  ThresholdRuleOptionalFields &
  ThresholdRuleDefaultableFields;

export const ThresholdRulePatchFields = ThresholdRuleRequiredFields.partial()
  .and(ThresholdRuleOptionalFields)
  .and(ThresholdRuleDefaultableFields);

export type ThresholdRuleResponseFields = ThresholdRuleRequiredFields &
  RequiredOptional<ThresholdRuleOptionalFields> &
  Required<ThresholdRuleDefaultableFields>;

export const ThresholdRuleResponseFields = ThresholdRuleRequiredFields.and(
  ThresholdRuleOptionalFields.transform(requireOptional)
).and(ThresholdRuleDefaultableFields.required());

export type ThresholdRule = SharedResponseProps & ThresholdRuleResponseFields;

export const ThresholdRule = SharedResponseProps.and(ThresholdRuleResponseFields);

export type ThresholdRuleCreateProps = SharedCreateProps & ThresholdRuleCreateFields;

export const ThresholdRuleCreateProps = SharedCreateProps.and(ThresholdRuleCreateFields);

export type ThresholdRuleUpdateProps = SharedUpdateProps & ThresholdRuleCreateFields;

export const ThresholdRuleUpdateProps = SharedUpdateProps.and(ThresholdRuleCreateFields);

export type ThresholdRulePatchProps = SharedPatchProps & ThresholdRulePatchFields;

export const ThresholdRulePatchProps = SharedPatchProps.and(ThresholdRulePatchFields);

export interface ThreatMatchRuleRequiredFields {
  /**
   * Rule type
   */
  type: 'threat_match';
  query: string;
  /**
   * Query used to determine which fields in the Elasticsearch index are used for generating alerts.
   */
  threat_query: string;
  /**
   * Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index.
   *
   * You can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See below for an example that uses both and and or logic.
   */
  threat_mapping: Array<{
    entries: Array<{
      /**
       * Field from the event indices on which the rule runs
       */
      field: string;
      type: 'mapping';
      /**
       * Field from the Elasticsearch threat index
       */
      value: string;
    }>;
  }>;
  /**
   * Elasticsearch indices used to check which field values generate alerts
   */
  threat_index: string[];
}

export const ThreatMatchRuleRequiredFields = z.object({
  /**
   * Rule type
   */
  type: z.literal('threat_match'),
  query: z.string(),
  /**
   * Query used to determine which fields in the Elasticsearch index are used for generating alerts.
   */
  threat_query: z.string(),
  /** 
      * Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index.

You can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See below for an example that uses both and and or logic. 
      */
  threat_mapping: z
    .array(
      z.object({
        entries: z.array(
          z.object({
            /**
             * Field from the event indices on which the rule runs
             */
            field: z.string().min(1),
            type: z.literal('mapping'),
            /**
             * Field from the Elasticsearch threat index
             */
            value: z.string().min(1),
          })
        ),
      })
    )
    .min(1),
  /**
   * Elasticsearch indices used to check which field values generate alerts
   */
  threat_index: z.array(z.string()),
});

export interface ThreatMatchRuleOptionalFields {
  index?: string[];
  data_view_id?: string;
  filters?: unknown[];
  saved_id?: string;
  threat_filters?: unknown[];
  /**
   * Defines the path to the threat indicator in the indicator documents (optional)
   */
  threat_indicator_path?: string;
  threat_language?: KqlQueryLanguage;
  concurrent_searches?: number;
  items_per_search?: number;
}

export const ThreatMatchRuleOptionalFields = z.object({
  index: z.array(z.string()).optional(),
  data_view_id: z.string().optional(),
  filters: z.array(z.unknown()).optional(),
  saved_id: z.string().optional(),
  threat_filters: z.array(z.unknown()).optional(),
  /**
   * Defines the path to the threat indicator in the indicator documents (optional)
   */
  threat_indicator_path: z.string().optional(),
  threat_language: KqlQueryLanguage.optional(),
  concurrent_searches: z.number().int().min(1).optional(),
  items_per_search: z.number().int().min(1).optional(),
});

export interface ThreatMatchRuleDefaultableFields {
  language?: KqlQueryLanguage;
}

export const ThreatMatchRuleDefaultableFields = z.object({
  language: KqlQueryLanguage.optional(),
});

export type ThreatMatchRuleCreateFields = ThreatMatchRuleRequiredFields &
  ThreatMatchRuleOptionalFields &
  ThreatMatchRuleDefaultableFields;

export const ThreatMatchRuleCreateFields = ThreatMatchRuleRequiredFields.and(
  ThreatMatchRuleOptionalFields
).and(ThreatMatchRuleDefaultableFields);

export type ThreatMatchRulePatchFields = Partial<ThreatMatchRuleRequiredFields> &
  ThreatMatchRuleOptionalFields &
  ThreatMatchRuleDefaultableFields;

export const ThreatMatchRulePatchFields = ThreatMatchRuleRequiredFields.partial()
  .and(ThreatMatchRuleOptionalFields)
  .and(ThreatMatchRuleDefaultableFields);

export type ThreatMatchRuleResponseFields = ThreatMatchRuleRequiredFields &
  RequiredOptional<ThreatMatchRuleOptionalFields> &
  Required<ThreatMatchRuleDefaultableFields>;

export const ThreatMatchRuleResponseFields = ThreatMatchRuleRequiredFields.and(
  ThreatMatchRuleOptionalFields.transform(requireOptional)
).and(ThreatMatchRuleDefaultableFields.required());

export type ThreatMatchRule = SharedResponseProps & ThreatMatchRuleResponseFields;

export const ThreatMatchRule = SharedResponseProps.and(ThreatMatchRuleResponseFields);

export type ThreatMatchRuleCreateProps = SharedCreateProps & ThreatMatchRuleCreateFields;

export const ThreatMatchRuleCreateProps = SharedCreateProps.and(ThreatMatchRuleCreateFields);

export type ThreatMatchRuleUpdateProps = SharedUpdateProps & ThreatMatchRuleCreateFields;

export const ThreatMatchRuleUpdateProps = SharedUpdateProps.and(ThreatMatchRuleCreateFields);

export type ThreatMatchRulePatchProps = SharedPatchProps & ThreatMatchRulePatchFields;

export const ThreatMatchRulePatchProps = SharedPatchProps.and(ThreatMatchRulePatchFields);

export interface MachineLearningRuleRequiredFields {
  /**
   * Rule type
   */
  type: 'machine_learning';
  /**
   * Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100
   */
  anomaly_threshold: number;
  /**
   * Machine learning job ID the rule monitors for anomaly scores.
   */
  machine_learning_job_id: string | string[];
}

export const MachineLearningRuleRequiredFields = z.object({
  /**
   * Rule type
   */
  type: z.literal('machine_learning'),
  /**
   * Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100
   */
  anomaly_threshold: z.number().int().min(0),
  /**
   * Machine learning job ID the rule monitors for anomaly scores.
   */
  machine_learning_job_id: z.union([z.string(), z.array(z.string()).min(1)]),
});

export type MachineLearningRulePatchFields = Partial<MachineLearningRuleRequiredFields>;

export const MachineLearningRulePatchFields = MachineLearningRuleRequiredFields.partial();

export type MachineLearningRuleResponseFields = MachineLearningRuleRequiredFields;

export const MachineLearningRuleResponseFields = MachineLearningRuleRequiredFields;

export type MachineLearningRuleCreateFields = MachineLearningRuleRequiredFields;

export const MachineLearningRuleCreateFields = MachineLearningRuleRequiredFields;

export type MachineLearningRule = SharedResponseProps & MachineLearningRuleResponseFields;

export const MachineLearningRule = SharedResponseProps.and(MachineLearningRuleResponseFields);

export type MachineLearningRuleCreateProps = SharedCreateProps & MachineLearningRuleCreateFields;

export const MachineLearningRuleCreateProps = SharedCreateProps.and(
  MachineLearningRuleCreateFields
);

export type MachineLearningRuleUpdateProps = SharedUpdateProps & MachineLearningRuleCreateFields;

export const MachineLearningRuleUpdateProps = SharedUpdateProps.and(
  MachineLearningRuleCreateFields
);

export type MachineLearningRulePatchProps = SharedPatchProps & MachineLearningRulePatchFields;

export const MachineLearningRulePatchProps = SharedPatchProps.and(MachineLearningRulePatchFields);

export interface NewTermsRuleRequiredFields {
  /**
   * Rule type
   */
  type: 'new_terms';
  query: string;
  new_terms_fields: NewTermsFields;
  history_window_start: HistoryWindowStart;
}

export const NewTermsRuleRequiredFields = z.object({
  /**
   * Rule type
   */
  type: z.literal('new_terms'),
  query: z.string(),
  new_terms_fields: NewTermsFields,
  history_window_start: HistoryWindowStart,
});

export interface NewTermsRuleOptionalFields {
  index?: string[];
  data_view_id?: string;
  filters?: unknown[];
}

export const NewTermsRuleOptionalFields = z.object({
  index: z.array(z.string()).optional(),
  data_view_id: z.string().optional(),
  filters: z.array(z.unknown()).optional(),
});

export interface NewTermsRuleDefaultableFields {
  language?: KqlQueryLanguage;
}

export const NewTermsRuleDefaultableFields = z.object({
  language: KqlQueryLanguage.optional(),
});

export type NewTermsRulePatchFields = Partial<NewTermsRuleRequiredFields> &
  NewTermsRuleOptionalFields &
  NewTermsRuleDefaultableFields;

export const NewTermsRulePatchFields = NewTermsRuleRequiredFields.partial()
  .and(NewTermsRuleOptionalFields)
  .and(NewTermsRuleDefaultableFields);

export type NewTermsRuleResponseFields = NewTermsRuleRequiredFields &
  RequiredOptional<NewTermsRuleOptionalFields> &
  Required<NewTermsRuleDefaultableFields>;

export const NewTermsRuleResponseFields = NewTermsRuleRequiredFields.and(
  NewTermsRuleOptionalFields.transform(requireOptional)
).and(NewTermsRuleDefaultableFields.required());

export type NewTermsRuleCreateFields = NewTermsRuleRequiredFields &
  NewTermsRuleOptionalFields &
  NewTermsRuleDefaultableFields;

export const NewTermsRuleCreateFields = NewTermsRuleRequiredFields.and(
  NewTermsRuleOptionalFields
).and(NewTermsRuleDefaultableFields);

export type NewTermsRule = SharedResponseProps & NewTermsRuleResponseFields;

export const NewTermsRule = SharedResponseProps.and(NewTermsRuleResponseFields);

export type NewTermsRuleCreateProps = SharedCreateProps & NewTermsRuleCreateFields;

export const NewTermsRuleCreateProps = SharedCreateProps.and(NewTermsRuleCreateFields);

export type NewTermsRuleUpdateProps = SharedUpdateProps & NewTermsRuleCreateFields;

export const NewTermsRuleUpdateProps = SharedUpdateProps.and(NewTermsRuleCreateFields);

export type NewTermsRulePatchProps = SharedPatchProps & NewTermsRulePatchFields;

export const NewTermsRulePatchProps = SharedPatchProps.and(NewTermsRulePatchFields);

export type EsqlQueryLanguage = 'esql';

export const EsqlQueryLanguage = z.literal('esql');

export interface EsqlRuleRequiredFields {
  /**
   * Rule type
   */
  type: 'esql';
  language: EsqlQueryLanguage;
  /**
   * ESQL query to execute
   */
  query: string;
}

export const EsqlRuleRequiredFields = z.object({
  /**
   * Rule type
   */
  type: z.literal('esql'),
  language: EsqlQueryLanguage,
  /**
   * ESQL query to execute
   */
  query: z.string(),
});

export type EsqlRulePatchFields = Partial<EsqlRuleRequiredFields>;

export const EsqlRulePatchFields = EsqlRuleRequiredFields.partial();

export type EsqlRuleResponseFields = EsqlRuleRequiredFields;

export const EsqlRuleResponseFields = EsqlRuleRequiredFields;

export type EsqlRuleCreateFields = EsqlRuleRequiredFields;

export const EsqlRuleCreateFields = EsqlRuleRequiredFields;

export type EsqlRule = SharedResponseProps & EsqlRuleResponseFields;

export const EsqlRule = SharedResponseProps.and(EsqlRuleResponseFields);

export type EsqlRuleCreateProps = SharedCreateProps & EsqlRuleCreateFields;

export const EsqlRuleCreateProps = SharedCreateProps.and(EsqlRuleCreateFields);

export type EsqlRuleUpdateProps = SharedUpdateProps & EsqlRuleCreateFields;

export const EsqlRuleUpdateProps = SharedUpdateProps.and(EsqlRuleCreateFields);

export type EsqlRulePatchProps = SharedPatchProps & Partial<EsqlRulePatchFields>;

export const EsqlRulePatchProps = SharedPatchProps.and(EsqlRulePatchFields.partial());

export type TypeSpecificCreateProps =
  | EqlRuleCreateFields
  | QueryRuleCreateFields
  | SavedQueryRuleCreateFields
  | ThresholdRuleCreateFields
  | ThreatMatchRuleCreateFields
  | MachineLearningRuleCreateFields
  | NewTermsRuleCreateFields
  | EsqlRuleCreateFields;

export const TypeSpecificCreateProps = z.union([
  EqlRuleCreateFields,
  QueryRuleCreateFields,
  SavedQueryRuleCreateFields,
  ThresholdRuleCreateFields,
  ThreatMatchRuleCreateFields,
  MachineLearningRuleCreateFields,
  NewTermsRuleCreateFields,
  EsqlRuleCreateFields,
]);

export type TypeSpecificPatchProps =
  | EqlRulePatchFields
  | QueryRulePatchFields
  | SavedQueryRulePatchFields
  | ThresholdRulePatchFields
  | ThreatMatchRulePatchFields
  | MachineLearningRulePatchFields
  | NewTermsRulePatchFields
  | EsqlRulePatchFields;

export const TypeSpecificPatchProps = z.union([
  EqlRulePatchFields,
  QueryRulePatchFields,
  SavedQueryRulePatchFields,
  ThresholdRulePatchFields,
  ThreatMatchRulePatchFields,
  MachineLearningRulePatchFields,
  NewTermsRulePatchFields,
  EsqlRulePatchFields,
]);

export type TypeSpecificResponse =
  | EqlRuleResponseFields
  | QueryRuleResponseFields
  | SavedQueryRuleResponseFields
  | ThresholdRuleResponseFields
  | ThreatMatchRuleResponseFields
  | MachineLearningRuleResponseFields
  | NewTermsRuleResponseFields
  | EsqlRuleResponseFields;

export const TypeSpecificResponse = z.union([
  EqlRuleResponseFields,
  QueryRuleResponseFields,
  SavedQueryRuleResponseFields,
  ThresholdRuleResponseFields,
  ThreatMatchRuleResponseFields,
  MachineLearningRuleResponseFields,
  NewTermsRuleResponseFields,
  EsqlRuleResponseFields,
]);

export type RuleCreateProps =
  | EqlRuleCreateProps
  | QueryRuleCreateProps
  | SavedQueryRuleCreateProps
  | ThresholdRuleCreateProps
  | ThreatMatchRuleCreateProps
  | MachineLearningRuleCreateProps
  | NewTermsRuleCreateProps
  | EsqlRuleCreateProps;

export const RuleCreateProps = z.union([
  EqlRuleCreateProps,
  QueryRuleCreateProps,
  SavedQueryRuleCreateProps,
  ThresholdRuleCreateProps,
  ThreatMatchRuleCreateProps,
  MachineLearningRuleCreateProps,
  NewTermsRuleCreateProps,
  EsqlRuleCreateProps,
]);

export type RuleUpdateProps =
  | EqlRuleUpdateProps
  | QueryRuleUpdateProps
  | SavedQueryRuleUpdateProps
  | ThresholdRuleUpdateProps
  | ThreatMatchRuleUpdateProps
  | MachineLearningRuleUpdateProps
  | NewTermsRuleUpdateProps
  | EsqlRuleUpdateProps;

export const RuleUpdateProps = z.union([
  EqlRuleUpdateProps,
  QueryRuleUpdateProps,
  SavedQueryRuleUpdateProps,
  ThresholdRuleUpdateProps,
  ThreatMatchRuleUpdateProps,
  MachineLearningRuleUpdateProps,
  NewTermsRuleUpdateProps,
  EsqlRuleUpdateProps,
]);

export type RulePatchProps =
  | EqlRulePatchProps
  | QueryRulePatchProps
  | SavedQueryRulePatchProps
  | ThresholdRulePatchProps
  | ThreatMatchRulePatchProps
  | MachineLearningRulePatchProps
  | NewTermsRulePatchProps
  | EsqlRulePatchProps;

export const RulePatchProps = z.union([
  EqlRulePatchProps,
  QueryRulePatchProps,
  SavedQueryRulePatchProps,
  ThresholdRulePatchProps,
  ThreatMatchRulePatchProps,
  MachineLearningRulePatchProps,
  NewTermsRulePatchProps,
  EsqlRulePatchProps,
]);

export type RuleResponse =
  | EqlRule
  | QueryRule
  | SavedQueryRule
  | ThresholdRule
  | ThreatMatchRule
  | MachineLearningRule
  | NewTermsRule
  | EsqlRule;

export const RuleResponse = z.union([
  EqlRule,
  QueryRule,
  SavedQueryRule,
  ThresholdRule,
  ThreatMatchRule,
  MachineLearningRule,
  NewTermsRule,
  EsqlRule,
]);
