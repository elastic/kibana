/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { z } from 'zod';

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 */

/**
 * A universally unique identifier
 */
export type UUID = string;

export const UUID = z.string().uuid();

/**
 * Rule saved object ID
 */
export type RuleObjectId = string;

export const RuleObjectId = z.string().uuid();

/**
 * Could be any string, not necessarily a UUID
 */
export type RuleSignatureId = string;

export const RuleSignatureId = z.string();

/**
 * The rule's name.
 */
export type RuleName = string;

export const RuleName = z.string().min(1);

/**
 * The rule's description.
 */
export type RuleDescription = string;

export const RuleDescription = z.string().min(1);

/**
 * The rule's version number.
 */
export type RuleVersion = number;

export const RuleVersion = z.number().int().min(1);

export type IsRuleImmutable = boolean;

export const IsRuleImmutable = z.boolean();

/**
 * Determines whether the rule is enabled.
 */
export type IsRuleEnabled = boolean;

export const IsRuleEnabled = z.boolean();

/**
 * String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
 */
export type RuleTagArray = string[];

export const RuleTagArray = z.array(z.string());

/**
 * Placeholder for metadata about the rule. NOTE: This field is overwritten when you save changes to the rule’s settings.
 */
export type RuleMetadata = {} & { [key: string]: unknown };

export const RuleMetadata = z.object({}).catchall(z.unknown());

/**
 * The rule's license.
 */
export type RuleLicense = string;

export const RuleLicense = z.string();

export type RuleAuthorArray = string[];

export const RuleAuthorArray = z.array(z.string());

/**
 * String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
 */
export type RuleFalsePositiveArray = string[];

export const RuleFalsePositiveArray = z.array(z.string());

export type RuleReferenceArray = string[];

export const RuleReferenceArray = z.array(z.string());

export type InvestigationGuide = string;

export const InvestigationGuide = z.string();

export type SetupGuide = string;

export const SetupGuide = z.string();

export type BuildingBlockType = string;

export const BuildingBlockType = z.string();

export type AlertsIndex = string;

export const AlertsIndex = z.string();

export type AlertsIndexNamespace = string;

export const AlertsIndexNamespace = z.string();

export type MaxSignals = number;

export const MaxSignals = z.number().int().min(1);

export interface Subtechnique {
  /**
   * Subtechnique ID
   */
  id: string;
  /**
   * Subtechnique name
   */
  name: string;
  /**
   * Subtechnique reference
   */
  reference: string;
}

export const Subtechnique = z.object({
  /**
   * Subtechnique ID
   */
  id: z.string(),
  /**
   * Subtechnique name
   */
  name: z.string(),
  /**
   * Subtechnique reference
   */
  reference: z.string(),
});

export interface Technique {
  /**
   * Technique ID
   */
  id: string;
  /**
   * Technique name
   */
  name: string;
  /**
   * Technique reference
   */
  reference: string;
  /**
   * Array containing more specific information on the attack technique
   */
  subtechnique?: Subtechnique[];
}

export const Technique = z.object({
  /**
   * Technique ID
   */
  id: z.string(),
  /**
   * Technique name
   */
  name: z.string(),
  /**
   * Technique reference
   */
  reference: z.string(),
  /**
   * Array containing more specific information on the attack technique
   */
  subtechnique: z.array(Subtechnique).optional(),
});

export interface Tactic {
  /**
   * Tactic ID
   */
  id: string;
  /**
   * Tactic name
   */
  name: string;
  /**
   * Tactic reference
   */
  reference: string;
}

export const Tactic = z.object({
  /**
   * Tactic ID
   */
  id: z.string(),
  /**
   * Tactic name
   */
  name: z.string(),
  /**
   * Tactic reference
   */
  reference: z.string(),
});

export interface Threat {
  /**
   * Relevant attack framework
   */
  framework: string;
  tactic: Tactic;
  /**
   * Array containing information on the attack techniques
   */
  technique?: Technique[];
}

export const Threat = z.object({
  /**
   * Relevant attack framework
   */
  framework: z.string(),
  tactic: Tactic,
  /**
   * Array containing information on the attack techniques
   */
  technique: z.array(Technique).optional(),
});

export type ThreatArray = Threat[];

export const ThreatArray = z.array(Threat);

export type IndexPatternArray = string[];

export const IndexPatternArray = z.array(z.string());

export type DataViewId = string;

export const DataViewId = z.string();

/**
 * Query used by the rule to create alerts. For threat-match rules, only the query’s results are used to determine whether an alert is generated.
 */
export type RuleQuery = string;

export const RuleQuery = z.string();

export type RuleFilterArray = unknown[];

export const RuleFilterArray = z.array(z.unknown());

export type RuleNameOverride = string;

export const RuleNameOverride = z.string();

export type TimestampOverride = string;

export const TimestampOverride = z.string();

export type TimestampOverrideFallbackDisabled = boolean;

export const TimestampOverrideFallbackDisabled = z.boolean();

/**
 * Almost all types of Security rules check source event documents for a match to some kind of query or filter. If a document has certain field with certain values, then it's a match and the rule will generate an alert.
 *
 * Required field is an event field that must be present in the source indices of a given rule.
 * @example
 * const standardEcsField: RequiredField = {
 *   name: 'event.action',
 *   type: 'keyword',
 *   ecs: true,
 * };
 *
 * const nonEcsField: RequiredField = {
 *   name: 'winlog.event_data.AttributeLDAPDisplayName',
 *   type: 'keyword',
 *   ecs: false,
 * };
 */
export interface RequiredField {
  name: string;
  type: string;
  ecs: boolean;
}

export const RequiredField = z.object({
  name: z.string().min(1),
  type: z.string().min(1),
  ecs: z.boolean(),
});

export type RequiredFieldArray = RequiredField[];

export const RequiredFieldArray = z.array(RequiredField);

export type TimelineTemplateId = string;

export const TimelineTemplateId = z.string();

export type TimelineTemplateTitle = string;

export const TimelineTemplateTitle = z.string();

export type SavedObjectResolveOutcome = 'exactMatch' | 'aliasMatch' | 'conflict';

export const SavedObjectResolveOutcome = z.enum(['exactMatch', 'aliasMatch', 'conflict']);
export const SavedObjectResolveOutcomeEnum = SavedObjectResolveOutcome.enum;
export type SavedObjectResolveOutcomeEnum = typeof SavedObjectResolveOutcome.enum;

export type SavedObjectResolveAliasTargetId = string;

export const SavedObjectResolveAliasTargetId = z.string();

export type SavedObjectResolveAliasPurpose = 'savedObjectConversion' | 'savedObjectImport';

export const SavedObjectResolveAliasPurpose = z.enum([
  'savedObjectConversion',
  'savedObjectImport',
]);
export const SavedObjectResolveAliasPurposeEnum = SavedObjectResolveAliasPurpose.enum;
export type SavedObjectResolveAliasPurposeEnum = typeof SavedObjectResolveAliasPurpose.enum;

export interface RelatedIntegration {
  package: string;
  version: string;
  integration?: string;
}

export const RelatedIntegration = z.object({
  package: z.string().min(1),
  version: z.string().min(1),
  integration: z.string().min(1).optional(),
});

export type RelatedIntegrationArray = RelatedIntegration[];

export const RelatedIntegrationArray = z.array(RelatedIntegration);

export interface InvestigationFields {
  field_names: string[];
}

export const InvestigationFields = z.object({
  field_names: z.array(z.string()).min(1),
});

/**
 * Defines the interval on which a rule's actions are executed.
 *
 * Note: The rule level throttle field is deprecated in Elastic Security 8.8 and will remain active for at least the next 12 months.
 *
 * In Elastic Security 8.8 and later, you can use the (frequency) field to define frequencies for individual actions. Actions without frequencies will acquire a converted version of the rule’s throttle field. In the response, the converted throttle setting appears in the individual actions' frequency field.
 */
export type RuleActionThrottle = 'no_actions' | 'rule' | string;

export const RuleActionThrottle = z.union([
  z.enum(['no_actions', 'rule']),
  z.string().regex(/^[1-9]\d*[smhd]$/),
]);

/**
 * The action frequency defines when the action runs (for example, only on rule execution or at specific time intervals).
 */
export interface RuleActionFrequency {
  summary: boolean;
  notifyWhen: 'onActionGroupChange' | 'onActiveAlert' | 'onThrottleInterval';
  throttle: RuleActionThrottle | null;
}

export const RuleActionFrequency = z.object({
  summary: z.boolean(),
  notifyWhen: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']),
  throttle: RuleActionThrottle.nullable(),
});

export interface RuleAction {
  /**
   * The action type used for sending notifications.
   */
  action_type_id: string;
  /**
   * Optionally groups actions by use cases. Use `default` for alert notifications.
   */
  group: string;
  /**
   * The connector ID.
   */
  id: string;
  /**
   * Object containing the allowed connector fields, which varies according to the connector type.
   */
  params: {} & { [key: string]: unknown };
  uuid?: string;
  /**
   * TODO implement the schema type
   */
  alerts_filter?: {};

  frequency?: RuleActionFrequency;
}

export const RuleAction = z.object({
  /**
   * The action type used for sending notifications.
   */
  action_type_id: z.string(),
  /**
   * Optionally groups actions by use cases. Use `default` for alert notifications.
   */
  group: z.string(),
  /**
   * The connector ID.
   */
  id: z.string(),
  /**
   * Object containing the allowed connector fields, which varies according to the connector type.
   */
  params: z.object({}).catchall(z.unknown()),
  uuid: z.string().optional(),
  /**
   * TODO implement the schema type
   */
  alerts_filter: z.object({}).optional(),
  frequency: RuleActionFrequency.optional(),
});
