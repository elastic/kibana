/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 *
 * info:
 *   title: Shared Timeline Components
 *   version: not applicable
 */

import { z } from '@kbn/zod';

/**
 * The type of timeline to create. Valid values are `default` and `template`.
 */
export type TimelineType = z.infer<typeof TimelineType>;
export const TimelineType = z.enum(['default', 'template']);
export type TimelineTypeEnum = typeof TimelineType.enum;
export const TimelineTypeEnum = TimelineType.enum;

/**
 * The type of data provider to create. Valid values are `default` and `template`.
 */
export type DataProviderType = z.infer<typeof DataProviderType>;
export const DataProviderType = z.enum(['default', 'template']);
export type DataProviderTypeEnum = typeof DataProviderType.enum;
export const DataProviderTypeEnum = DataProviderType.enum;

/**
 * The type of the timeline template.
 */
export type TemplateTimelineType = z.infer<typeof TemplateTimelineType>;
export const TemplateTimelineType = z.enum(['elastic', 'custom']);
export type TemplateTimelineTypeEnum = typeof TemplateTimelineType.enum;
export const TemplateTimelineTypeEnum = TemplateTimelineType.enum;

export type ColumnHeaderResult = z.infer<typeof ColumnHeaderResult>;
export const ColumnHeaderResult = z.object({
  aggregatable: z.boolean().nullable().optional(),
  category: z.string().nullable().optional(),
  columnHeaderType: z.string().nullable().optional(),
  description: z.string().nullable().optional(),
  example: z.string().nullable().optional(),
  indexes: z.array(z.string()).nullable().optional(),
  id: z.string().nullable().optional(),
  name: z.string().nullable().optional(),
  placeholder: z.string().nullable().optional(),
  searchable: z.boolean().nullable().optional(),
  type: z.string().nullable().optional(),
});

export type QueryMatchResult = z.infer<typeof QueryMatchResult>;
export const QueryMatchResult = z.object({
  field: z.string().nullable().optional(),
  displayField: z.string().nullable().optional(),
  value: z.union([z.string().nullable(), z.array(z.string()).nullable()]).optional(),
  displayValue: z.string().nullable().optional(),
  operator: z.string().nullable().optional(),
});

export type DataProviderQueryMatch = z.infer<typeof DataProviderQueryMatch>;
export const DataProviderQueryMatch = z.object({
  enabled: z.boolean().nullable().optional(),
  excluded: z.boolean().nullable().optional(),
  id: z.string().nullable().optional(),
  kqlQuery: z.string().nullable().optional(),
  name: z.string().nullable().optional(),
  queryMatch: QueryMatchResult.nullable().optional(),
  type: DataProviderType.nullable().optional(),
});

export type DataProviderResult = z.infer<typeof DataProviderResult>;
export const DataProviderResult = z.object({
  and: z.array(DataProviderQueryMatch).nullable().optional(),
  enabled: z.boolean().nullable().optional(),
  excluded: z.boolean().nullable().optional(),
  id: z.string().nullable().optional(),
  kqlQuery: z.string().nullable().optional(),
  name: z.string().nullable().optional(),
  queryMatch: QueryMatchResult.nullable().optional(),
  type: DataProviderType.nullable().optional(),
});

export type RowRendererId = z.infer<typeof RowRendererId>;
export const RowRendererId = z.enum([
  'alert',
  'alerts',
  'auditd',
  'auditd_file',
  'library',
  'netflow',
  'plain',
  'registry',
  'suricata',
  'system',
  'system_dns',
  'system_endgame_process',
  'system_file',
  'system_fim',
  'system_security_event',
  'system_socket',
  'threat_match',
  'zeek',
]);
export type RowRendererIdEnum = typeof RowRendererId.enum;
export const RowRendererIdEnum = RowRendererId.enum;

export type FavoriteTimelineResult = z.infer<typeof FavoriteTimelineResult>;
export const FavoriteTimelineResult = z.object({
  fullName: z.string().nullable().optional(),
  userName: z.string().nullable().optional(),
  favoriteDate: z.number().nullable().optional(),
});

export type FilterTimelineResult = z.infer<typeof FilterTimelineResult>;
export const FilterTimelineResult = z.object({
  exists: z.string().nullable().optional(),
  meta: z
    .object({
      alias: z.string().nullable().optional(),
      controlledBy: z.string().nullable().optional(),
      disabled: z.boolean().nullable().optional(),
      field: z.string().nullable().optional(),
      formattedValue: z.string().nullable().optional(),
      index: z.string().nullable().optional(),
      key: z.string().nullable().optional(),
      negate: z.boolean().nullable().optional(),
      params: z.string().nullable().optional(),
      type: z.string().nullable().optional(),
      value: z.string().nullable().optional(),
    })
    .nullable()
    .optional(),
  match_all: z.string().nullable().optional(),
  missing: z.string().nullable().optional(),
  query: z.string().nullable().optional(),
  range: z.string().nullable().optional(),
  script: z.string().nullable().optional(),
});

export type SerializedFilterQueryResult = z.infer<typeof SerializedFilterQueryResult>;
export const SerializedFilterQueryResult = z.object({
  filterQuery: z
    .object({
      kuery: z
        .object({
          kind: z.string().nullable().optional(),
          expression: z.string().nullable().optional(),
        })
        .nullable()
        .optional(),
      serializedQuery: z.string().nullable().optional(),
    })
    .nullable()
    .optional(),
});

export type SortObject = z.infer<typeof SortObject>;
export const SortObject = z.object({
  columnId: z.string().nullable().optional(),
  columnType: z.string().nullable().optional(),
  sortDirection: z.string().nullable().optional(),
});

export type Sort = z.infer<typeof Sort>;
export const Sort = z.union([SortObject, z.array(SortObject)]);

export type SavedTimeline = z.infer<typeof SavedTimeline>;
export const SavedTimeline = z.object({
  columns: z.array(ColumnHeaderResult).nullable().optional(),
  created: z.number().nullable().optional(),
  createdBy: z.string().nullable().optional(),
  dataProviders: z.array(DataProviderResult).nullable().optional(),
  dataViewId: z.string().nullable().optional(),
  dateRange: z
    .object({
      end: z.union([z.string().nullable(), z.number().nullable()]).optional(),
      start: z.union([z.string().nullable(), z.number().nullable()]).optional(),
    })
    .nullable()
    .optional(),
  description: z.string().nullable().optional(),
  eqlOptions: z
    .object({
      eventCategoryField: z.string().nullable().optional(),
      query: z.string().nullable().optional(),
      size: z.union([z.string().nullable(), z.number().nullable()]).optional(),
      tiebreakerField: z.string().nullable().optional(),
      timestampField: z.string().nullable().optional(),
    })
    .nullable()
    .optional(),
  eventType: z.string().nullable().optional(),
  excludedRowRendererIds: z.array(RowRendererId).nullable().optional(),
  favorite: z.array(FavoriteTimelineResult).nullable().optional(),
  filters: z.array(FilterTimelineResult).nullable().optional(),
  kqlMode: z.string().nullable().optional(),
  kqlQuery: SerializedFilterQueryResult.nullable().optional(),
  indexNames: z.array(z.string()).nullable().optional(),
  savedSearchId: z.string().nullable().optional(),
  savedQueryId: z.string().nullable().optional(),
  sort: Sort.nullable().optional(),
  status: z.enum(['active', 'draft', 'immutable']).nullable().optional(),
  title: z.string().nullable().optional(),
  templateTimelineId: z.string().nullable().optional(),
  templateTimelineVersion: z.number().nullable().optional(),
  timelineType: TimelineType.nullable().optional(),
  updated: z.number().nullable().optional(),
  updatedBy: z.string().nullable().optional(),
});

export type SavedTimelineWithSavedObjectId = z.infer<typeof SavedTimelineWithSavedObjectId>;
export const SavedTimelineWithSavedObjectId = SavedTimeline.merge(
  z.object({
    savedObjectId: z.string(),
    version: z.string(),
  })
);

export type BareNote = z.infer<typeof BareNote>;
export const BareNote = z.object({
  eventId: z.string().nullable().optional(),
  note: z.string().nullable().optional(),
  timelineId: z.string(),
  created: z.number().nullable().optional(),
  createdBy: z.string().nullable().optional(),
  updated: z.number().nullable().optional(),
  updatedBy: z.string().nullable().optional(),
});

export type Note = z.infer<typeof Note>;
export const Note = BareNote.merge(
  z.object({
    noteId: z.string(),
    version: z.string(),
  })
);

export type BarePinnedEvent = z.infer<typeof BarePinnedEvent>;
export const BarePinnedEvent = z.object({
  eventId: z.string(),
  timelineId: z.string(),
  created: z.number().nullable().optional(),
  createdBy: z.string().nullable().optional(),
  updated: z.number().nullable().optional(),
  updatedBy: z.string().nullable().optional(),
});

export type PinnedEvent = z.infer<typeof PinnedEvent>;
export const PinnedEvent = BarePinnedEvent.merge(
  z.object({
    pinnedEventId: z.string(),
    version: z.string(),
  })
);

export type TimelineResponse = z.infer<typeof TimelineResponse>;
export const TimelineResponse = SavedTimeline.merge(SavedTimelineWithSavedObjectId).merge(
  z.object({
    eventIdToNoteIds: z.array(Note).nullable().optional(),
    notes: z.array(Note).nullable().optional(),
    noteIds: z.array(z.string()).nullable().optional(),
    pinnedEventIds: z.array(z.string()).nullable().optional(),
    pinnedEventsSaveObject: z.array(PinnedEvent).nullable().optional(),
  })
);

export type TimelineSavedToReturnObject = z.infer<typeof TimelineSavedToReturnObject>;
export const TimelineSavedToReturnObject = SavedTimeline.merge(
  z.object({
    savedObjectId: z.string(),
    version: z.string(),
    eventIdToNoteIds: z.array(Note).nullable().optional(),
    notes: z.array(Note).nullable().optional(),
    noteIds: z.array(z.string()).nullable().optional(),
    pinnedEventIds: z.array(z.string()).nullable().optional(),
    pinnedEventsSaveObject: z.array(PinnedEvent).nullable().optional(),
  })
);

export type SavedObjectResolveOutcome = z.infer<typeof SavedObjectResolveOutcome>;
export const SavedObjectResolveOutcome = z.enum(['exactMatch', 'aliasMatch', 'conflict']);
export type SavedObjectResolveOutcomeEnum = typeof SavedObjectResolveOutcome.enum;
export const SavedObjectResolveOutcomeEnum = SavedObjectResolveOutcome.enum;

export type SavedObjectResolveAliasPurpose = z.infer<typeof SavedObjectResolveAliasPurpose>;
export const SavedObjectResolveAliasPurpose = z.enum([
  'savedObjectConversion',
  'savedObjectImport',
]);
export type SavedObjectResolveAliasPurposeEnum = typeof SavedObjectResolveAliasPurpose.enum;
export const SavedObjectResolveAliasPurposeEnum = SavedObjectResolveAliasPurpose.enum;

export type ResolvedTimeline = z.infer<typeof ResolvedTimeline>;
export const ResolvedTimeline = z.object({
  timeline: TimelineSavedToReturnObject,
  outcome: SavedObjectResolveOutcome,
  alias_target_id: z.string().optional(),
  alias_purpose: SavedObjectResolveAliasPurpose.optional(),
});

export type FavoriteTimelineResponse = z.infer<typeof FavoriteTimelineResponse>;
export const FavoriteTimelineResponse = z.object({
  savedObjectId: z.string(),
  version: z.string(),
  code: z.number().nullable().optional(),
  message: z.string().nullable().optional(),
  templateTimelineId: z.string().nullable().optional(),
  templateTimelineVersion: z.number().nullable().optional(),
  timelineType: TimelineType.optional(),
  favorite: z.array(FavoriteTimelineResult).optional(),
});

export type PersistTimelineResponse = z.infer<typeof PersistTimelineResponse>;
export const PersistTimelineResponse = z.object({
  data: z.object({
    persistTimeline: z.object({
      timeline: TimelineResponse,
    }),
  }),
});

export type BareNoteWithoutExternalRefs = z.infer<typeof BareNoteWithoutExternalRefs>;
export const BareNoteWithoutExternalRefs = z.object({
  eventId: z.string().nullable().optional(),
  note: z.string().nullable().optional(),
  timelineId: z.string().nullable().optional(),
  created: z.number().nullable().optional(),
  createdBy: z.string().nullable().optional(),
  updated: z.number().nullable().optional(),
  updatedBy: z.string().nullable().optional(),
});

export type GlobalNote = z.infer<typeof GlobalNote>;
export const GlobalNote = z.object({
  noteId: z.string().optional(),
  version: z.string().optional(),
  note: z.string().optional(),
  timelineId: z.string().optional(),
  created: z.number().optional(),
  createdBy: z.string().optional(),
  updated: z.number().optional(),
  updatedBy: z.string().optional(),
});

/**
 * The field to sort the timelines by.
 */
export type SortFieldTimeline = z.infer<typeof SortFieldTimeline>;
export const SortFieldTimeline = z.enum(['title', 'description', 'updated', 'created']);
export type SortFieldTimelineEnum = typeof SortFieldTimeline.enum;
export const SortFieldTimelineEnum = SortFieldTimeline.enum;

export type SortDirection = z.infer<typeof SortDirection>;
export const SortDirection = z.enum(['asc', 'desc']);
export type SortDirectionEnum = typeof SortDirection.enum;
export const SortDirectionEnum = SortDirection.enum;

/**
 * The status of the timeline. Valid values are `active`, `draft`, and `immutable`.
 */
export type TimelineStatus = z.infer<typeof TimelineStatus>;
export const TimelineStatus = z.enum(['active', 'draft', 'immutable']);
export type TimelineStatusEnum = typeof TimelineStatus.enum;
export const TimelineStatusEnum = TimelineStatus.enum;

export type ImportTimelines = z.infer<typeof ImportTimelines>;
export const ImportTimelines = SavedTimeline.merge(
  z.object({
    savedObjectId: z.string().nullable(),
    version: z.string().nullable(),
    pinnedEventIds: z.array(z.string()).nullable(),
    eventNotes: z.array(BareNote).nullable(),
    globalNotes: z.array(BareNote).nullable(),
  })
);

export type ImportTimelineResult = z.infer<typeof ImportTimelineResult>;
export const ImportTimelineResult = z.object({
  success: z.boolean().optional(),
  success_count: z.number().optional(),
  timelines_installed: z.number().optional(),
  timelines_updated: z.number().optional(),
  errors: z
    .array(
      z.object({
        id: z.string().optional(),
        error: z
          .object({
            message: z.string().optional(),
            status_code: z.number().optional(),
          })
          .optional(),
      })
    )
    .optional(),
});

export type TimelineErrorResponse = z.infer<typeof TimelineErrorResponse>;
export const TimelineErrorResponse = z.union([
  z.object({
    message: z.string(),
    status_code: z.number(),
  }),
  z.object({
    message: z.string(),
    statusCode: z.number(),
  }),
]);
