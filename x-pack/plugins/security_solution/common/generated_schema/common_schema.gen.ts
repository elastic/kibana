/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { z } from 'zod';

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator `yarn openapi:generate`.
 */

export const CsvToArray = (value: unknown) => {
  if (typeof value === 'string') {
    return value.split(',');
  }
  return value;
};

export const SortOrder = z.enum(['asc', 'desc']);
export type SortOrder = z.infer<typeof SortOrder>;

/**
   * Custom execution status of Security rules that is different from the status used in the Alerting Framework. We merge our custom status with the Framework's status to determine the resulting status of a rule.
- going to run - @deprecated Replaced by the 'running' status but left for backwards compatibility with rule execution events already written to Event Log in the prior versions of Kibana. Don't use when writing rule status changes.
- running - Rule execution started but not reached any intermediate or final status.
- partial failure - Rule can partially fail for various reasons either in the middle of an execution (in this case we update its status right away) or in the end of it. So currently this status can be both intermediate and final at the same time. A typical reason for a partial failure: not all the indices that the rule searches over actually exist.
- failed - Rule failed to execute due to unhandled exception or a reason defined in the business logic of its executor function.
- succeeded - Rule executed successfully without any issues. Note: this status is just an indication of a rule's "health". The rule might or might not generate any alerts despite of it.
   */
export const RuleExecutionStatus = z.enum([
  'going to run',
  'running',
  'partial failure',
  'failed',
  'succeeded',
]);
export type RuleExecutionStatus = z.infer<typeof RuleExecutionStatus>;

/**
   * Rule execution result is an aggregate that groups plain rule execution events by execution UUID.
It contains such information as execution UUID, date, status and metrics.
   */
export const RuleExecutionResult = z.object({
  execution_uuid: z.string(),
  timestamp: z.string().datetime(),
  duration_ms: z.number(),
  status: z.string(),
  message: z.string(),
  num_active_alerts: z.number(),
  num_new_alerts: z.number(),
  num_recovered_alerts: z.number(),
  num_triggered_actions: z.number(),
  num_succeeded_actions: z.number(),
  num_errored_actions: z.number(),
  total_search_duration_ms: z.number(),
  es_search_duration_ms: z.number(),
  schedule_delay_ms: z.number(),
  timed_out: z.boolean(),
  indexing_duration_ms: z.number(),
  search_duration_ms: z.number(),
  gap_duration_s: z.number(),
  security_status: z.string(),
  security_message: z.string(),
});
export type RuleExecutionResult = z.infer<typeof RuleExecutionResult>;

export const Actions = z.object({
  /**
   * The action type used for sending notifications.
   */
  action_type_id: z.string().optional(),
  /**
   * Optionally groups actions by use cases. Use `default` for alert notifications.
   */
  group: z.string().optional(),
  /**
   * The connector ID.
   */
  id: z.string().optional(),
  /**
   * Object containing the allowed connector fields, which varies according to the connector type.
   */
  params: z.object({}).optional(),
});
export type Actions = z.infer<typeof Actions>;

export const BaseRule = z.object({
  /**
   * Rule ID
   */
  id: z.string(),
  /**
   * Rule name
   */
  name: z.string(),
  /**
   * Rule description
   */
  description: z.string().optional(),
  /**
   * Timeline template ID
   */
  timeline_id: z.string().optional(),
  /**
   * Timeline template title
   */
  timeline_title: z.string().optional(),
  actions: z
    .array(
      z.object({
        /**
         * The action type used for sending notifications
         */
        action_type_id: z.string().optional(),
        /**
         * Optionally groups actions by use cases
         */
        group: z.string().optional(),
        /**
         * The connector ID
         */
        id: z.string().optional(),
        /**
         * Object containing the allowed connector fields
         */
        params: z.object({}).optional(),
      })
    )
    .optional(),
  threats: z
    .array(
      z.object({
        /**
         * Relevant attack framework
         */
        framework: z.string().optional(),
        tactic: z
          .object({
            id: z.string().optional(),
            name: z.string().optional(),
            reference: z.string().optional(),
          })
          .optional(),
        technique: z
          .object({
            id: z.string().optional(),
            name: z.string().optional(),
            reference: z.string().optional(),
          })
          .optional(),
      })
    )
    .optional(),
  exceptions_list: z
    .array(
      z.object({
        /**
         * ID of the exception container
         */
        id: z.string().optional(),
        /**
         * List ID of the exception container
         */
        list_id: z.string().optional(),
        /**
         * Determines the exceptions validity in rule's Kibana space
         */
        namespace_type: z.string().optional(),
        /**
         * The exception type
         */
        type: z.string().optional(),
      })
    )
    .optional(),
  /**
   * Determines the query language (optional)
   */
  language: z.enum(['kuery', 'lucene']).optional(),
  /**
   * The query and filter context array used to define the conditions for when alerts are created from events (optional)
   */
  filters: z.array(z.object({})).optional(),
  /**
   * Risk score (0 to 100)
   */
  risk_score: z.number().min(0).max(100).optional(),
  /**
   * Severity of the rule
   */
  severity: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  /**
   * Indices on which the rule functions (optional)
   */
  index: z.array(z.string()).optional(),
  /**
   * Overrides generated alerts' risk_score with a value from the source event
   */
  risk_score_mapping: z
    .array(
      z.object({
        field: z.string().optional(),
        operator: z.string().optional(),
        value: z.string().optional(),
      })
    )
    .optional(),
  /**
   * Sets the source field for the alert's signal.rule.name value
   */
  rule_name_override: z.string().optional(),
  /**
   * Overrides generated alerts' severity with values from the source event
   */
  severity_mapping: z
    .array(
      z.object({
        field: z.string().optional(),
        operator: z.string().optional(),
        severity: z.string().optional(),
        value: z.string().optional(),
      })
    )
    .optional(),
  /**
   * Sets the time field used to query indices (optional)
   */
  timestamp_override: z.string().optional(),
  /**
   * Contains the event classification (optional, only for EQL rules)
   */
  event_category_field: z.string().optional(),
  /**
   * Sets a secondary field for sorting events (optional, only for EQL rules)
   */
  tiebreaker_field: z.string().optional(),
  /**
   * Contains the event timestamp used for sorting a sequence of events (optional, only for EQL rules)
   */
  timestamp_field: z.string().optional(),
});
export type BaseRule = z.infer<typeof BaseRule>;

export const QueryRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['query']),
    /**
     * Query to execute
     */
    query: z.string(),
  })
);
export type QueryRule = z.infer<typeof QueryRule>;

export const SavedQueryRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['saved_query']),
    /**
     * Saved query ID
     */
    saved_id: z.string(),
  })
);
export type SavedQueryRule = z.infer<typeof SavedQueryRule>;

export const ThresholdRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['threshold']),
    threshold: z.object({
      /**
       * Field to aggregate on
       */
      field: z.string().optional(),
      /**
       * Threshold value
       */
      value: z.number().optional(),
    }),
  })
);
export type ThresholdRule = z.infer<typeof ThresholdRule>;

export const ThreatMatchRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['threat_match']),
    threat_filters: z.array(z.object({})),
    /**
     * Defines the path to the threat indicator in the indicator documents (optional)
     */
    threat_indicator_path: z.string().optional(),
    /**
     * Indices on which the rule functions (optional)
     */
    threat_index: z.array(z.string()).optional(),
    /**
     * Query to execute (optional)
     */
    threat_query: z.string().optional(),
    threat_mapping: z
      .array(
        z.object({
          entries: z
            .array(
              z.object({
                field: z.string().optional(),
                type: z.string().optional(),
                value: z.string().optional(),
              })
            )
            .optional(),
        })
      )
      .optional(),
  })
);
export type ThreatMatchRule = z.infer<typeof ThreatMatchRule>;

export const MlRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['machine_learning']),
    /**
     * Anomaly threshold
     */
    anomaly_threshold: z.number(),
    /**
     * Machine learning job ID
     */
    machine_learning_job_id: z.string(),
  })
);
export type MlRule = z.infer<typeof MlRule>;

export const EqlRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['eql']),
    /**
     * EQL query to execute
     */
    eql_query: z.string(),
  })
);
export type EqlRule = z.infer<typeof EqlRule>;

export const Rule = z.union([QueryRule, SavedQueryRule, MlRule, EqlRule]);
export type Rule = z.infer<typeof Rule>;

/**
 * Defines the maximum interval in which a rule's actions are executed.
 */
export const Throttle = z.enum(['rule', '1h', '1d', '7d']);
export type Throttle = z.infer<typeof Throttle>;

export const Subtechnique = z.object({
  /**
   * Subtechnique ID
   */
  id: z.string(),
  /**
   * Subtechnique name
   */
  name: z.string(),
  /**
   * Subtechnique reference
   */
  reference: z.string(),
});
export type Subtechnique = z.infer<typeof Subtechnique>;

export const Technique = z.object({
  /**
   * Technique ID
   */
  id: z.string(),
  /**
   * Technique name
   */
  name: z.string(),
  /**
   * Technique reference
   */
  reference: z.string(),
  /**
   * Array containing more specific information on the attack technique
   */
  subtechnique: z.array(Subtechnique).optional(),
});
export type Technique = z.infer<typeof Technique>;

export const Threat = z.object({
  /**
   * Relevant attack framework
   */
  framework: z.string(),
  tactic: z.object({
    /**
     * Tactic ID
     */
    id: z.string().optional(),
    /**
     * Tactic name
     */
    name: z.string().optional(),
    /**
     * Tactic reference
     */
    reference: z.string().optional(),
  }),
  /**
   * Array containing information on the attack techniques (optional)
   */
  technique: z.array(Technique).optional(),
});
export type Threat = z.infer<typeof Threat>;

export const BulkActionBase = z.union([
  z.object({
    /**
     * Query to filter rules
     */
    query: z.string(),
  }),
  z.object({
    /**
     * Array of rule IDs
     */
    ids: z.array(z.string()).min(1).optional(),
  }),
]);
export type BulkActionBase = z.infer<typeof BulkActionBase>;

export const BulkDeleteRules = BulkActionBase.and(
  z.object({
    action: z.enum(['delete']),
  })
);
export type BulkDeleteRules = z.infer<typeof BulkDeleteRules>;

export const BulkDisableRules = BulkActionBase.and(
  z.object({
    action: z.enum(['disable']),
  })
);
export type BulkDisableRules = z.infer<typeof BulkDisableRules>;

export const BulkEnableRules = BulkActionBase.and(
  z.object({
    action: z.enum(['enable']),
  })
);
export type BulkEnableRules = z.infer<typeof BulkEnableRules>;

export const BulkExportRules = BulkActionBase.and(
  z.object({
    action: z.enum(['export']),
  })
);
export type BulkExportRules = z.infer<typeof BulkExportRules>;

export const BulkDuplicateRules = BulkActionBase.and(
  z.object({
    action: z.enum(['duplicate']),
    duplicate: z
      .object({
        /**
         * Whether to copy exceptions from the original rule
         */
        include_exceptions: z.boolean().optional(),
        /**
         * Whether to copy expired exceptions from the original rule
         */
        include_expired_exceptions: z.boolean().optional(),
      })
      .optional(),
  })
);
export type BulkDuplicateRules = z.infer<typeof BulkDuplicateRules>;

/**
 * Action summary indicates whether we will send a summary notification about all the generate alerts or notification per individual alert
 */
export const RuleActionSummary = z.boolean();
export type RuleActionSummary = z.infer<typeof RuleActionSummary>;

/**
 * The condition for throttling the notification: 'onActionGroupChange', 'onActiveAlert',  or 'onThrottleInterval'
 */
export const RuleActionNotifyWhen = z.enum([
  'onActionGroupChange',
  'onActiveAlert',
  'onThrottleInterval',
]);
export type RuleActionNotifyWhen = z.infer<typeof RuleActionNotifyWhen>;

/**
 * The condition for throttling the notification: 'rule', 'no_actions', or time duration
 */
export const RuleActionThrottle = z.string();
export type RuleActionThrottle = z.infer<typeof RuleActionThrottle>;

export const RuleActionFrequency = z.object({
  summary: RuleActionSummary.optional(),
  notifyWhen: RuleActionNotifyWhen.optional(),
  throttle: RuleActionThrottle.nullable().optional(),
});
export type RuleActionFrequency = z.infer<typeof RuleActionFrequency>;

export const BulkActionEditPayloadRuleActions = z.object({
  type: z.enum(['add_rule_actions', 'set_rule_actions']),
  value: z.object({
    throttle: RuleActionThrottle.optional(),
    actions: z
      .array(
        z.object({
          /**
           * Action group
           */
          group: z.string(),
          /**
           * Action ID
           */
          id: z.string(),
          /**
           * Action parameters
           */
          params: z.object({}),
          /**
           * Action frequency
           */
          frequency: RuleActionFrequency.optional(),
        })
      )
      .optional(),
  }),
});
export type BulkActionEditPayloadRuleActions = z.infer<typeof BulkActionEditPayloadRuleActions>;

export const BulkActionEditPayloadSchedule = z.object({
  type: z.enum(['set_schedule']).optional(),
  value: z
    .object({
      /**
       * Interval in which the rule is executed
       */
      interval: z.string().optional(),
      /**
       * Lookback time for the rule
       */
      lookback: z.string().optional(),
    })
    .optional(),
});
export type BulkActionEditPayloadSchedule = z.infer<typeof BulkActionEditPayloadSchedule>;

export const BulkActionEditPayload = z.union([
  BulkActionEditPayloadRuleActions,
  BulkActionEditPayloadSchedule,
]);
export type BulkActionEditPayload = z.infer<typeof BulkActionEditPayload>;

export const BulkEditRules = BulkActionBase.and(
  z.object({
    action: z.enum(['edit']),
    /**
     * Array of objects containing the edit operations
     */
    edit: z.array(BulkActionEditPayload).optional(),
  })
);
export type BulkEditRules = z.infer<typeof BulkEditRules>;

export const PerformBulkActionRequest = z.union([
  BulkDeleteRules,
  BulkDisableRules,
  BulkEnableRules,
  BulkExportRules,
  BulkDuplicateRules,
  BulkEditRules,
]);
export type PerformBulkActionRequest = z.infer<typeof PerformBulkActionRequest>;
