/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
import type { Logger } from '@kbn/core/server';

import type {
  Agent,
  FullAgentPolicy,
  PackageInfo,
  NewPackagePolicy,
  RegistryDataStream,
  RegistryInput,
  RegistryVarsEntry,
  PackagePolicyConfigRecord,
  PackagePolicyConfigRecordEntry,
} from '../../types';

import type { ParsedAnnotations } from './types';

const SUPPORTED_DATA_STREAM_TYPES = ['metrics'];
export const generatePackagePolicy = (
  policyName: string,
  agent: Agent,
  agentPolicy: FullAgentPolicy,
  packageInfo: PackageInfo,
  annotations: ParsedAnnotations,
  logger?: Logger
): NewPackagePolicy | null => {
  const inputs = generatePackagePolicyInputs(packageInfo, annotations, logger);
  if (!inputs.some((input) => input.enabled)) {
    return null;
  }

  return {
    name: policyName,
    description: 'This agent policy was auto generated by Fleet',
    namespace: agentPolicy?.agent?.monitoring.namespace || 'default',
    policy_id: agentPolicy.id,
    enabled: true,
    output_id: '',
    package: { name: packageInfo.name, title: packageInfo.title, version: packageInfo.version },
    inputs,
  };
};

const generatePackagePolicyInputs = (
  packageInfo: PackageInfo,
  annotations: ParsedAnnotations,
  logger?: Logger
): NewPackagePolicy['inputs'] => {
  let inputs: NewPackagePolicy['inputs'] = [];
  packageInfo.policy_templates?.forEach((policyTemplate) => {
    const policyTemplateInputs = policyTemplate.inputs?.map((policyInput) => {
      const dataStreamsWithInputType =
        packageInfo.data_streams?.filter((ds) =>
          ds.streams?.filter((stream) => stream.input === policyInput.type)
        ) || [];

      const streams = generateStreamsForPolicyInput(
        policyInput,
        dataStreamsWithInputType,
        annotations,
        logger
      );

      let vars;
      if (policyInput.vars) {
        vars = generateVars(policyTemplate.title, policyInput.vars, annotations, logger);
      }

      const enabled = streams.some((stream) => stream.enabled);
      const input = {
        type: policyInput.type,
        policy_template: policyTemplate.name,
        enabled,
        streams,
        ...(vars ? { vars } : {}),
      } as NewPackagePolicy['inputs'][number];

      return input;
    });

    if (policyTemplateInputs && policyTemplateInputs.length) {
      inputs = inputs.concat(policyTemplateInputs);
    }
  });

  return inputs;
};

const generateStreamsForPolicyInput = (
  policyInput: RegistryInput,
  dataStreams: RegistryDataStream[],
  annotations: ParsedAnnotations,
  logger?: Logger
): NewPackagePolicy['inputs'][number]['streams'] => {
  const streams = dataStreams.flatMap((dataStream) => {
    if (!SUPPORTED_DATA_STREAM_TYPES.includes(dataStream.type)) {
      return [];
    }
    return (dataStream.streams || []).map((stream) => {
      if (stream.input !== policyInput.type) {
        return null;
      }
      const vars = generateVars(stream.title, stream.vars || [], annotations, logger);
      const enabled = vars !== null;

      return {
        enabled,
        data_stream: { type: dataStream.type, dataset: dataStream.dataset },
        ...(vars ? { vars } : {}),
      };
    });
  });

  const filteredStreams = streams.filter(
    (stream) => stream
  ) as NewPackagePolicy['inputs'][number]['streams'];
  return filteredStreams;
};

const generateVars = (
  title: string,
  configVars: RegistryVarsEntry[],
  annotations: ParsedAnnotations,
  logger?: Logger
): PackagePolicyConfigRecord | null => {
  const vars: PackagePolicyConfigRecord = {};

  configVars.forEach((varTemplate) => {
    const generatedVarEntry = generateConfigVar(varTemplate, annotations, logger);

    if (generatedVarEntry) {
      const generatedVar = generatedVarEntry;

      vars[varTemplate.name] = generatedVar;
    }
  });
  const varNames = Object.keys(vars);
  if (!varNames.length) return null;

  const requiredVars = configVars.filter(({ required }) => required).map(({ name }) => name);

  const missingRequiredVars = requiredVars.filter((requiredVar) => !varNames.includes(requiredVar));
  if (missingRequiredVars.length) {
    logger?.info(
      `Data stream '${title}' missing required vars ${missingRequiredVars} TODO: DELETEME: ${JSON.stringify(
        vars
      )}`
    );
    return null;
  }
  return vars;
};

const generateConfigVar = (
  variable: RegistryVarsEntry,
  annotations: ParsedAnnotations,
  logger?: Logger
): PackagePolicyConfigRecordEntry | null => {
  if (annotations.hosts && isHostVar(variable)) {
    return getHostVar(variable, annotations.hosts);
  }

  const defaultVar = getDefaultVar(variable);

  if (defaultVar) return defaultVar;

  return null;
};

const isHostVar = (variable: RegistryVarsEntry) => {
  return variable.name === 'host' || variable.name === 'hosts';
};

const getHostVar = (
  variable: RegistryVarsEntry,
  host: string | string[]
): PackagePolicyConfigRecordEntry => {
  const hosts = Array.isArray(host) ? host : [host];

  const value = variable.multi ? hosts : hosts[0];

  return { value, type: variable.type };
};

const getDefaultVar = (variable: RegistryVarsEntry): PackagePolicyConfigRecordEntry | null => {
  if (variable.default !== undefined) {
    return { type: variable.type, value: variable.default };
  }

  return null;
};
