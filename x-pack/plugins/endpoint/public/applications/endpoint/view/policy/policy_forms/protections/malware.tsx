/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */

import React, { useCallback } from 'react';
import { useDispatch } from 'react-redux';
import { EuiRadioGroup, EuiSwitch } from '@elastic/eui';
import { i18n } from '@kbn/i18n';
import { OS, ProtectionModes, MalwareProtectionOSes } from '../../../../types';
import { ConfigForm } from '../config_form';
import { policyConfig } from '../../../../store/policy_details/selectors';
import { usePolicyDetailsSelector } from '../../policy_hooks';
import { clone } from '../../../../models/policy_details_config';

export const MalwareProtections = React.memo(() => {
  const policyDetailsConfig = usePolicyDetailsSelector(policyConfig);
  const dispatch = useDispatch();
  const selected = policyDetailsConfig && policyDetailsConfig.windows.malware.mode;
  const OSes: MalwareProtectionOSes[] = [OS.windows, OS.mac];
  const protection = 'malware';

  const radios = [
    {
      id: 'detect',
      label: i18n.translate('xpack.endpoint.policy.details.detect', { defaultMessage: 'Detect' }),
    },
    {
      id: 'prevent',
      label: i18n.translate('xpack.endpoint.policy.details.prevent', { defaultMessage: 'Prevent' }),
    },
    {
      id: 'preventAndNotify',
      label: i18n.translate('xpack.endpoint.policy.details.preventAndNotify', {
        defaultMessage: 'Prevent and notify user',
      }),
    },
  ];

  const handleRadioChange = useCallback(
    optionId => {
      if (policyDetailsConfig) {
        const newPayload = clone(policyDetailsConfig);
        for (const os of OSes) {
          newPayload[os][protection].mode = optionId;
        }
        dispatch({
          type: 'userChangedPolicyConfig',
          payload: { policyConfig: newPayload },
        });
      }
    },
    [OSes, dispatch, policyDetailsConfig]
  );

  const handleSwitchChange = useCallback(
    event => {
      if (policyDetailsConfig) {
        const newPayload = clone(policyDetailsConfig);
        if (event.target.checked === false) {
          for (const os of OSes) {
            newPayload[os][protection].mode = ProtectionModes.off;
          }
        } else {
          for (const os of OSes) {
            newPayload[os][protection].mode = ProtectionModes.prevent;
          }
        }
        dispatch({
          type: 'userChangedPolicyConfig',
          payload: { policyConfig: newPayload },
        });
      }
    },
    [OSes, dispatch, policyDetailsConfig]
  );

  const radioButtons = () => {
    return (
      <EuiRadioGroup
        className="policyDetailsProtectionRadio"
        legend={{ children: <span>Protection Level</span> }}
        options={radios}
        idSelected={selected}
        onChange={handleRadioChange}
        disabled={selected === ProtectionModes.off}
      />
    );
  };

  const protectionSwitch = () => {
    return (
      <EuiSwitch
        label={i18n.translate('xpack.endpoint.policy.details.malwareProtectionsEnabled', {
          defaultMessage: 'Malware Protections Enabled',
        })}
        checked={selected !== ProtectionModes.off}
        onChange={handleSwitchChange}
      />
    );
  };

  return (
    <ConfigForm
      type={i18n.translate('xpack.endpoint.policy.details.malware', { defaultMessage: 'Malware' })}
      supportedOss={[
        i18n.translate('xpack.endpoint.policy.details.windows', { defaultMessage: 'Windows' }),
        i18n.translate('xpack.endpoint.policy.details.mac', { defaultMessage: 'Mac' }),
      ]}
      id="malwareProtectionsForm"
      rightCorner={protectionSwitch()}
      children={radioButtons()}
    />
  );
});
