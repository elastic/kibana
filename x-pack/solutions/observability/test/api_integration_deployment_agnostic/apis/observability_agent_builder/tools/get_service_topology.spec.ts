/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import expect from '@kbn/expect';
import { timerange } from '@kbn/synthtrace-client';
import {
  type ApmSynthtraceEsClient,
  API_GATEWAY_SERVICE,
  BATCH_WORKER_SERVICE,
  CHECKOUT_SERVICE,
  FRONTEND_SERVICE,
  generateTopologyData,
  generateTraceIsolationData,
  KAFKA_CONSUMER_SERVICE,
  KAFKA_DEPENDENCY,
  PAYMENT_SERVICE,
  POSTGRES_DEPENDENCY,
  RECOMMENDATION_SERVICE,
  REDIS_DEPENDENCY,
  POSTGRES_DB,
  REDIS_DB,
} from '@kbn/synthtrace';
import type { OtherResult } from '@kbn/agent-builder-common';
import { OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID } from '@kbn/observability-agent-builder-plugin/server/tools';
import type { DeploymentAgnosticFtrProviderContext } from '../../../ftr_provider_context';
import { createAgentBuilderApiClient } from '../utils/agent_builder_client';

const START = 'now-15m';
const END = 'now';

/**
 * Topology generated by synthtrace (generateTopologyData):
 *
 *   frontend (nodejs)
 *     → checkout-service (java) [destination: "checkout-proxy:5050"]
 *         → postgres (db)
 *         → redis (cache)
 *         → kafka (messaging)
 *     → recommendation-service (python) [destination: "recommendation-lb:8080"]
 *         → postgres (db)
 *
 * IMPORTANT: span.destination.service.resource values intentionally differ from service.name
 * (e.g., "checkout-proxy:5050" instead of "checkout-service") to prevent heuristic matching.
 */
interface ServiceTopologyConnection {
  source: { 'service.name': string };
  target:
    | { 'service.name': string }
    | { 'span.destination.service.resource': string; 'span.type': string };
  metrics: {
    errorRate: number | null;
    latencyMs: number | null;
    throughputPerMin: number | null;
  } | null;
}

interface GetServiceTopologyToolResult extends OtherResult {
  data: {
    connections: ServiceTopologyConnection[];
  };
}

const getTargetName = (c: ServiceTopologyConnection) =>
  'service.name' in c.target
    ? c.target['service.name']
    : c.target['span.destination.service.resource'];

const getSourceName = (c: ServiceTopologyConnection) => c.source['service.name'];

export default function ({ getService }: DeploymentAgnosticFtrProviderContext) {
  const roleScopedSupertest = getService('roleScopedSupertest');
  const synthtrace = getService('synthtrace');

  describe(`tool: ${OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID}`, function () {
    let agentBuilderApiClient: ReturnType<typeof createAgentBuilderApiClient>;
    let apmSynthtraceEsClient: ApmSynthtraceEsClient;

    before(async () => {
      const scoped = await roleScopedSupertest.getSupertestWithRoleScope('editor');
      agentBuilderApiClient = createAgentBuilderApiClient(scoped);

      apmSynthtraceEsClient = await synthtrace.createApmSynthtraceEsClient();
      await apmSynthtraceEsClient.clean();

      const { client, generator } = generateTopologyData({
        range: timerange(START, END),
        apmEsClient: apmSynthtraceEsClient,
      });

      await client.index(generator);
    });

    after(async () => {
      await apmSynthtraceEsClient.clean();
    });

    // Helper to execute the tool with given params
    const executeTopology = async (params: {
      serviceName: string;
      direction?: 'downstream' | 'upstream' | 'both';
    }) => {
      const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
        id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
        params: { start: START, end: END, ...params },
      });
      return results[0].data.connections;
    };

    describe('downstream from frontend', () => {
      it('returns checkout-service and recommendation-service as targets', async () => {
        const connections = await executeTopology({
          serviceName: FRONTEND_SERVICE.serviceName,
        });
        const targets = connections.map(getTargetName);

        expect(targets).to.contain(CHECKOUT_SERVICE.serviceName);
        expect(targets).to.contain(RECOMMENDATION_SERVICE.serviceName);
      });
    });

    describe('downstream from checkout-service', () => {
      it('returns postgres, redis, kafka — but not siblings or parents', async () => {
        const connections = await executeTopology({
          serviceName: CHECKOUT_SERVICE.serviceName,
          direction: 'downstream',
        });
        const targets = connections.map(getTargetName);
        const sources = connections.map(getSourceName);

        // Direct dependencies
        expect(targets).to.contain(POSTGRES_DEPENDENCY.resource);
        expect(targets).to.contain(REDIS_DEPENDENCY.resource);
        expect(targets).to.contain(KAFKA_DEPENDENCY.resource);

        // No sibling (recommendation-service) or parent (frontend) connections
        expect(sources).not.to.contain(RECOMMENDATION_SERVICE.serviceName);
        expect(sources).not.to.contain(FRONTEND_SERVICE.serviceName);
      });
    });

    describe('upstream from checkout-service', () => {
      it('returns frontend as caller', async () => {
        const connections = await executeTopology({
          serviceName: CHECKOUT_SERVICE.serviceName,
          direction: 'upstream',
        });
        const sources = connections.map(getSourceName);

        expect(sources).to.contain(FRONTEND_SERVICE.serviceName);
      });
    });

    describe('both directions from checkout-service', () => {
      it('returns frontend upstream and postgres downstream', async () => {
        const connections = await executeTopology({
          serviceName: CHECKOUT_SERVICE.serviceName,
          direction: 'both',
        });
        const sources = connections.map(getSourceName);
        const targets = connections.map(getTargetName);

        expect(sources).to.contain(FRONTEND_SERVICE.serviceName);
        expect(targets).to.contain(POSTGRES_DEPENDENCY.resource);
      });
    });

    describe('upstream from postgres (multi-hop + blast radius)', () => {
      it('includes direct callers, indirect callers, and excludes sibling deps', async () => {
        const connections = await executeTopology({
          serviceName: POSTGRES_DEPENDENCY.resource,
          direction: 'upstream',
        });
        const sources = connections.map(getSourceName);
        const targets = connections.map(getTargetName);

        // Direct callers of postgres
        expect(sources).to.contain(CHECKOUT_SERVICE.serviceName);
        expect(sources).to.contain(RECOMMENDATION_SERVICE.serviceName);

        // Multi-hop: frontend → checkout-service is in the same trace
        expect(sources).to.contain(FRONTEND_SERVICE.serviceName);

        // Sibling deps (redis, kafka) should not appear
        expect(targets).not.to.contain(REDIS_DEPENDENCY.resource);
        expect(targets).not.to.contain(KAFKA_DEPENDENCY.resource);
      });
    });

    describe('RED metrics', () => {
      it('returns latency in ms, throughput, and error rate', async () => {
        const connections = await executeTopology({
          serviceName: CHECKOUT_SERVICE.serviceName,
          direction: 'downstream',
        });
        const toPostgres = connections.find(
          (c) =>
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === POSTGRES_DEPENDENCY.resource
        );

        expect(toPostgres?.metrics?.latencyMs).to.be.a('number');
        expect(toPostgres?.metrics?.latencyMs).to.be.greaterThan(0);
        // Regression: must be ms not µs — synthtrace spans are 30-40ms
        expect(toPostgres?.metrics?.latencyMs).to.be.lessThan(1000);
        expect(toPostgres?.metrics?.throughputPerMin).to.be.greaterThan(0);
        expect(toPostgres?.metrics?.errorRate).to.be(0);
      });
    });

    /**
     * Trace isolation: shared intermediate services across traces
     *
     * When two different traces share an instrumented intermediate service,
     * the tool should only return connections from the queried service's traces.
     *
     * Topology:
     *   Trace 1: api-gateway → payment-service → kafka-consumer → postgres
     *   Trace 2: batch-worker → kafka-consumer → redis
     *
     * kafka-consumer appears in both traces but with different downstream deps.
     * Querying api-gateway downstream should show kafka-consumer → postgres
     * but NOT kafka-consumer → redis (which belongs to batch-worker's trace).
     */
    describe('trace isolation: shared intermediate services across traces', () => {
      before(async () => {
        await apmSynthtraceEsClient.clean();

        const { client, generator } = generateTraceIsolationData({
          range: timerange(START, END),
          apmEsClient: apmSynthtraceEsClient,
        });

        await client.index(generator);
      });

      after(async () => {
        await apmSynthtraceEsClient.clean();
      });

      it('downstream from api-gateway does not include redis from batch-worker trace', async () => {
        const connections = await executeTopology({
          serviceName: API_GATEWAY_SERVICE.serviceName,
          direction: 'downstream',
        });
        const targets = connections.map(getTargetName);

        expect(targets).to.contain(PAYMENT_SERVICE.serviceName);
        expect(targets).to.contain(KAFKA_CONSUMER_SERVICE.serviceName);
        expect(targets).to.contain(POSTGRES_DB.resource);
        expect(targets).not.to.contain(REDIS_DB.resource);
      });

      it('downstream from batch-worker does not include postgres from api-gateway trace', async () => {
        const connections = await executeTopology({
          serviceName: BATCH_WORKER_SERVICE.serviceName,
          direction: 'downstream',
        });
        const targets = connections.map(getTargetName);

        expect(targets).to.contain(KAFKA_CONSUMER_SERVICE.serviceName);
        expect(targets).to.contain(REDIS_DB.resource);
        expect(targets).not.to.contain(POSTGRES_DB.resource);
      });
    });
  });
}
