/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import expect from '@kbn/expect';
import { timerange } from '@kbn/synthtrace-client';
import { type ApmSynthtraceEsClient, generateTopologyData } from '@kbn/synthtrace';
import type { OtherResult } from '@kbn/agent-builder-common';
import { OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID } from '@kbn/observability-agent-builder-plugin/server/tools';
import type { DeploymentAgnosticFtrProviderContext } from '../../../ftr_provider_context';
import { createAgentBuilderApiClient } from '../utils/agent_builder_client';

const START = 'now-15m';
const END = 'now';

/**
 * These constants match the synthtrace scenario (generateTopologyData)
 *
 * SRE Use Case: Service Topology for Incident Investigation
 *
 * When investigating an incident, SREs need to understand:
 * 1. DOWNSTREAM: "What does my service depend on?" - to find failing dependencies
 * 2. UPSTREAM: "Who calls my service?" - to understand blast radius
 * 3. METRICS: "Which connections are unhealthy?" - latency, error rate, throughput
 *
 * Topology generated by synthtrace:
 *   frontend (nodejs)
 *     → checkout-service (java)
 *         → postgres (db)
 *         → redis (cache)
 *         → kafka (messaging)
 *     → recommendation-service (python)
 *         → postgres (db)
 */
const FRONTEND_SERVICE = {
  name: 'frontend',
  agent: 'nodejs',
};

const CHECKOUT_SERVICE = {
  name: 'checkout-service',
  agent: 'java',
};

const RECOMMENDATION_SERVICE = {
  name: 'recommendation-service',
  agent: 'python',
};

const CHECKOUT_SERVICE_DEPENDENCY = {
  resource: 'checkout-service',
  spanType: 'external',
  spanSubtype: 'http',
};

const RECOMMENDATION_SERVICE_DEPENDENCY = {
  resource: 'recommendation-service',
  spanType: 'external',
  spanSubtype: 'http',
};

const POSTGRES_DEPENDENCY = {
  resource: 'postgres',
  spanType: 'db',
  spanSubtype: 'postgresql',
};

interface ServiceTopologyConnection {
  source: {
    'service.name': string;
    'agent.name': string;
  };
  target:
    | { 'service.name': string }
    | { 'span.destination.service.resource': string; 'span.type': string };
  metrics: {
    errorRate: number | null;
    latencyMs: number | null;
    throughputPerMin: number | null;
  } | null;
}

interface GetServiceTopologyToolResult extends OtherResult {
  data: {
    tracesCount: number;
    connectionsCount: number;
    connections: ServiceTopologyConnection[];
  };
}

export default function ({ getService }: DeploymentAgnosticFtrProviderContext) {
  const roleScopedSupertest = getService('roleScopedSupertest');
  const synthtrace = getService('synthtrace');

  describe(`tool: ${OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID}`, function () {
    let agentBuilderApiClient: ReturnType<typeof createAgentBuilderApiClient>;
    let apmSynthtraceEsClient: ApmSynthtraceEsClient;

    before(async () => {
      const scoped = await roleScopedSupertest.getSupertestWithRoleScope('editor');
      agentBuilderApiClient = createAgentBuilderApiClient(scoped);

      apmSynthtraceEsClient = await synthtrace.createApmSynthtraceEsClient();
      await apmSynthtraceEsClient.clean();

      const { client, generator } = generateTopologyData({
        range: timerange(START, END),
        apmEsClient: apmSynthtraceEsClient,
      });

      await client.index(generator);
    });

    after(async () => {
      await apmSynthtraceEsClient.clean();
    });

    describe('when fetching service topology with metrics', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: FRONTEND_SERVICE.name,
            start: START,
            end: END,
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('returns tracesCount and connectionsCount', () => {
        expect(resultData.tracesCount).to.be.greaterThan(0);
        expect(resultData.connectionsCount).to.be(resultData.connections.length);
      });

      it('returns connections to multiple downstream services', () => {
        // Frontend should have connections to both checkout-service and recommendation-service
        const connectionToCheckout = resultData.connections.find(
          (c) =>
            c.source['service.name'] === FRONTEND_SERVICE.name &&
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === CHECKOUT_SERVICE_DEPENDENCY.resource
        );

        const connectionToRecommendation = resultData.connections.find(
          (c) =>
            c.source['service.name'] === FRONTEND_SERVICE.name &&
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] ===
              RECOMMENDATION_SERVICE_DEPENDENCY.resource
        );

        expect(connectionToCheckout).to.be.ok();
        expect(connectionToRecommendation).to.be.ok();
      });

      it('returns the correct source and target details', () => {
        const connectionToCheckout = resultData.connections.find(
          (c) =>
            c.source['service.name'] === FRONTEND_SERVICE.name &&
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === CHECKOUT_SERVICE_DEPENDENCY.resource
        );

        expect(connectionToCheckout).to.be.ok();

        // Verify source
        expect(connectionToCheckout?.source['service.name']).to.be(FRONTEND_SERVICE.name);
        expect(connectionToCheckout?.source['agent.name']).to.be(FRONTEND_SERVICE.agent);

        // Verify target
        const target = connectionToCheckout?.target as {
          'span.destination.service.resource': string;
          'span.type': string;
          'span.subtype': string;
        };
        expect(target['span.type']).to.be(CHECKOUT_SERVICE_DEPENDENCY.spanType);
        expect(target['span.subtype']).to.be(CHECKOUT_SERVICE_DEPENDENCY.spanSubtype);
      });

      it('includes health metrics for connections', () => {
        const connectionToCheckout = resultData.connections.find(
          (c) =>
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === CHECKOUT_SERVICE_DEPENDENCY.resource
        );

        expect(connectionToCheckout?.metrics).to.be.ok();
        expect(connectionToCheckout?.metrics?.latencyMs).to.be.a('number');
        expect(connectionToCheckout?.metrics?.throughputPerMin).to.be.a('number');
        expect(connectionToCheckout?.metrics?.errorRate).to.be(0); // All spans are successful
      });
    });

    describe('when fetching service topology without metrics', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: FRONTEND_SERVICE.name,
            start: START,
            end: END,
            includeMetrics: false,
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('returns connections without metrics', () => {
        expect(resultData.connections.length).to.be.greaterThan(0);

        const connectionToCheckout = resultData.connections.find(
          (c) =>
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === CHECKOUT_SERVICE_DEPENDENCY.resource
        );

        expect(connectionToCheckout).to.be.ok();
        expect(connectionToCheckout?.metrics).to.be(null);
      });
    });

    /**
     * Regression tests for upstream query bugs:
     * - Bug 1: Query only matched exact service name, not "serviceName:port" patterns
     * - Bug 2: Query didn't search service.target.name (OTel naming like "oteldemo.PaymentService")
     *
     * Note: The OTel naming bug (service.target.name) is NOT fully covered by these tests
     * because synthtrace generates standard APM data, not OTel-style naming. That bug
     * was caught through manual testing with real OTel demo data. A future enhancement
     * would be to add an OTel-specific synthtrace scenario.
     */
    describe('when fetching upstream topology (direction: upstream)', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: CHECKOUT_SERVICE.name,
            start: START,
            end: END,
            direction: 'upstream',
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('returns at least one upstream connection', () => {
        // Regression test: upstream query previously returned 0 results due to
        // span.destination.service.resource matching issues
        expect(resultData.connectionsCount).to.be.greaterThan(0);
        expect(resultData.connections.length).to.be.greaterThan(0);
      });

      it('returns upstream callers of the service', () => {
        // frontend calls checkout-service, so frontend should appear as a caller
        const upstreamFromFrontend = resultData.connections.find(
          (c) => c.source['service.name'] === FRONTEND_SERVICE.name
        );

        expect(upstreamFromFrontend).to.be.ok();
        expect(upstreamFromFrontend?.source['service.name']).to.be(FRONTEND_SERVICE.name);
        expect(upstreamFromFrontend?.source['agent.name']).to.be(FRONTEND_SERVICE.agent);
      });

      it('shows the queried service as the target', () => {
        const upstreamFromFrontend = resultData.connections.find(
          (c) => c.source['service.name'] === FRONTEND_SERVICE.name
        );

        expect(upstreamFromFrontend).to.be.ok();
        const target = upstreamFromFrontend?.target as {
          'span.destination.service.resource': string;
        };
        expect(target['span.destination.service.resource']).to.be(CHECKOUT_SERVICE.name);
      });

      it('includes metrics for upstream connections', () => {
        const upstreamFromFrontend = resultData.connections.find(
          (c) => c.source['service.name'] === FRONTEND_SERVICE.name
        );

        expect(upstreamFromFrontend?.metrics).to.be.ok();
        expect(upstreamFromFrontend?.metrics?.latencyMs).to.be.a('number');
        expect(upstreamFromFrontend?.metrics?.throughputPerMin).to.be.a('number');
      });
    });

    describe('when fetching topology in both directions (direction: both)', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: CHECKOUT_SERVICE.name,
            start: START,
            end: END,
            direction: 'both',
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('returns upstream callers', () => {
        // Upstream: frontend → checkout-service
        const upstreamFromFrontend = resultData.connections.find(
          (c) => c.source['service.name'] === FRONTEND_SERVICE.name
        );

        expect(upstreamFromFrontend).to.be.ok();
      });

      it('returns downstream dependencies', () => {
        // Downstream: checkout-service → postgres
        const downstreamToPostgres = resultData.connections.find(
          (c) =>
            c.source['service.name'] === CHECKOUT_SERVICE.name &&
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === POSTGRES_DEPENDENCY.resource
        );

        expect(downstreamToPostgres).to.be.ok();
      });
    });

    /**
     * SRE Use Case: Blast Radius Analysis
     *
     * When a shared dependency (postgres) fails, SREs need to know which services
     * are affected. Using upstream direction on postgres should reveal all callers.
     */
    describe('blast radius analysis for shared dependencies', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: POSTGRES_DEPENDENCY.resource,
            start: START,
            end: END,
            direction: 'upstream',
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('identifies all services that depend on the shared resource', () => {
        // Both checkout-service and recommendation-service call postgres
        const fromCheckout = resultData.connections.find(
          (c) => c.source['service.name'] === CHECKOUT_SERVICE.name
        );

        const fromRecommendation = resultData.connections.find(
          (c) => c.source['service.name'] === RECOMMENDATION_SERVICE.name
        );

        expect(fromCheckout).to.be.ok();
        expect(fromRecommendation).to.be.ok();
      });

      it('shows the dependency type for impact assessment', () => {
        const fromCheckout = resultData.connections.find(
          (c) => c.source['service.name'] === CHECKOUT_SERVICE.name
        );

        expect(fromCheckout).to.be.ok();

        const target = fromCheckout?.target as { 'span.destination.service.resource': string };
        expect(target['span.destination.service.resource']).to.be(POSTGRES_DEPENDENCY.resource);
      });
    });

    /**
     * SRE Use Case: Connection Health Assessment
     *
     * During incident investigation, SREs need metrics to identify unhealthy connections.
     * All synthtrace spans are successful, so we verify metrics are present and reasonable.
     */
    describe('connection health assessment', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: CHECKOUT_SERVICE.name,
            start: START,
            end: END,
            direction: 'downstream',
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('provides latency metrics to identify slow dependencies', () => {
        const toPostgres = resultData.connections.find(
          (c) =>
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === POSTGRES_DEPENDENCY.resource
        );

        expect(toPostgres?.metrics?.latencyMs).to.be.a('number');
        expect(toPostgres?.metrics?.latencyMs).to.be.greaterThan(0);
      });

      it('returns latency in milliseconds not microseconds', () => {
        // Regression test: latencyMs was previously returned in microseconds (e.g., 30000)
        // instead of milliseconds (e.g., 30). The synthtrace scenario generates spans
        // with durations of 30-40ms for postgres, so latency should be < 1000ms.
        const toPostgres = resultData.connections.find(
          (c) =>
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === POSTGRES_DEPENDENCY.resource
        );

        expect(toPostgres?.metrics?.latencyMs).to.be.a('number');
        // If latency were in microseconds, this would be ~30,000-40,000
        // In milliseconds, it should be ~30-40
        expect(toPostgres?.metrics?.latencyMs).to.be.lessThan(1000);
      });

      it('provides throughput metrics to gauge traffic volume', () => {
        const toPostgres = resultData.connections.find(
          (c) =>
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === POSTGRES_DEPENDENCY.resource
        );

        expect(toPostgres?.metrics?.throughputPerMin).to.be.a('number');
        expect(toPostgres?.metrics?.throughputPerMin).to.be.greaterThan(0);
      });

      it('provides error rate to identify failing connections', () => {
        const toPostgres = resultData.connections.find(
          (c) =>
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === POSTGRES_DEPENDENCY.resource
        );

        expect(toPostgres?.metrics?.errorRate).to.be.a('number');
        // All synthtrace spans are successful, so error rate should be 0
        expect(toPostgres?.metrics?.errorRate).to.be(0);
      });
    });
  });
}
