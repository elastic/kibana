/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import expect from '@kbn/expect';
import { timerange } from '@kbn/synthtrace-client';
import {
  type ApmSynthtraceEsClient,
  CHECKOUT_SERVICE,
  FRONTEND_SERVICE,
  generateTopologyData,
  KAFKA_DEPENDENCY,
  POSTGRES_DEPENDENCY,
  RECOMMENDATION_SERVICE,
  REDIS_DEPENDENCY,
} from '@kbn/synthtrace';
import type { OtherResult } from '@kbn/agent-builder-common';
import { OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID } from '@kbn/observability-agent-builder-plugin/server/tools';
import type { DeploymentAgnosticFtrProviderContext } from '../../../ftr_provider_context';
import { createAgentBuilderApiClient } from '../utils/agent_builder_client';

const START = 'now-15m';
const END = 'now';

/**
 * These constants match the synthtrace scenario (generateTopologyData)
 *
 * SRE Use Case: Service Topology for Incident Investigation
 *
 * When investigating an incident, SREs need to understand:
 * 1. DOWNSTREAM: "What does my service depend on?" - to find failing dependencies
 * 2. UPSTREAM: "Who calls my service?" - to understand blast radius
 * 3. RED METRICS: "Which connections are unhealthy?" - latency, error rate, throughput
 *
 * Topology generated by synthtrace:
 *
 *   frontend (nodejs)
 *     → checkout-service (java) [destination: "checkout-proxy:5050"]
 *         → postgres (db)
 *         → redis (cache)
 *         → kafka (messaging)
 *     → recommendation-service (python) [destination: "recommendation-lb:8080"]
 *         → postgres (db)
 *
 * IMPORTANT: The span.destination.service.resource values intentionally differ from
 * service.name (e.g., "checkout-proxy:5050" instead of "checkout-service"). This ensures
 * tests fail if heuristic matching on span.destination.service.resource is reintroduced.
 * The implementation must rely on resolved target['service.name'] from instrumented services.
 */
interface ServiceTopologyConnection {
  source: {
    'service.name': string;
  };
  target:
    | { 'service.name': string }
    | { 'span.destination.service.resource': string; 'span.type': string };
  metrics: {
    errorRate: number | null;
    latencyMs: number | null;
    throughputPerMin: number | null;
  } | null;
}

interface GetServiceTopologyToolResult extends OtherResult {
  data: {
    connections: ServiceTopologyConnection[];
  };
}

interface ServiceRef {
  serviceName: string;
}

interface TargetRef {
  serviceName?: string;
  resource?: string;
}

const matchesSource = (connection: ServiceTopologyConnection, source: ServiceRef) =>
  connection.source['service.name'] === source.serviceName;

const matchesTarget = (connection: ServiceTopologyConnection, target: TargetRef) =>
  (target.serviceName != null &&
    'service.name' in connection.target &&
    connection.target['service.name'] === target.serviceName) ||
  (target.resource != null &&
    'span.destination.service.resource' in connection.target &&
    connection.target['span.destination.service.resource'] === target.resource);

const findConnection = (
  connections: ServiceTopologyConnection[],
  { source, target }: { source?: ServiceRef; target?: TargetRef }
) =>
  connections.find(
    (connection) =>
      (source ? matchesSource(connection, source) : true) &&
      (target ? matchesTarget(connection, target) : true)
  );

export default function ({ getService }: DeploymentAgnosticFtrProviderContext) {
  const roleScopedSupertest = getService('roleScopedSupertest');
  const synthtrace = getService('synthtrace');

  describe(`tool: ${OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID}`, function () {
    let agentBuilderApiClient: ReturnType<typeof createAgentBuilderApiClient>;
    let apmSynthtraceEsClient: ApmSynthtraceEsClient;

    before(async () => {
      const scoped = await roleScopedSupertest.getSupertestWithRoleScope('editor');
      agentBuilderApiClient = createAgentBuilderApiClient(scoped);

      apmSynthtraceEsClient = await synthtrace.createApmSynthtraceEsClient();
      await apmSynthtraceEsClient.clean();

      const { client, generator } = generateTopologyData({
        range: timerange(START, END),
        apmEsClient: apmSynthtraceEsClient,
      });

      await client.index(generator);
    });

    after(async () => {
      await apmSynthtraceEsClient.clean();
    });

    describe('when fetching service topology', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: FRONTEND_SERVICE.serviceName,
            start: START,
            end: END,
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('returns connections to multiple downstream services', () => {
        // Frontend should have connections to both checkout-service and recommendation-service.
        // Both are instrumented, so they resolve as services.
        const connectionToCheckout = findConnection(resultData.connections, {
          source: FRONTEND_SERVICE,
          target: CHECKOUT_SERVICE,
        });

        const connectionToRecommendation = findConnection(resultData.connections, {
          source: FRONTEND_SERVICE,
          target: { serviceName: RECOMMENDATION_SERVICE.serviceName },
        });

        expect(connectionToCheckout).to.be.ok();
        expect(connectionToRecommendation).to.be.ok();
      });

      it('returns the correct source and target details', () => {
        // Find connection to checkout-service (resolved as service since it's instrumented)
        const connectionToCheckout = findConnection(resultData.connections, {
          source: FRONTEND_SERVICE,
          target: CHECKOUT_SERVICE,
        });

        expect(connectionToCheckout).to.be.ok();

        // Verify source
        expect(connectionToCheckout?.source['service.name']).to.be(FRONTEND_SERVICE.serviceName);

        // Verify target resolves to the service
        const target = connectionToCheckout?.target as { 'service.name': string };
        expect(target['service.name']).to.be(CHECKOUT_SERVICE.serviceName);
      });

      it('includes RED metrics for connections', () => {
        // Find connection to checkout-service (may be resolved as service or external)
        const connectionToCheckout = findConnection(resultData.connections, {
          source: FRONTEND_SERVICE,
          target: CHECKOUT_SERVICE,
        });

        expect(connectionToCheckout?.metrics).to.be.ok();
        expect(connectionToCheckout?.metrics?.latencyMs).to.be.a('number');
        expect(connectionToCheckout?.metrics?.throughputPerMin).to.be.a('number');
        expect(connectionToCheckout?.metrics?.errorRate).to.be(0); // All spans are successful
      });
    });

    /**
     * Upstream topology tests.
     *
     * The implementation finds traces via the service's own transactions (getTraceSampleIds),
     * NOT by matching span.destination.service.resource. This is verified by the test data
     * where destination names differ from service names (e.g., "checkout-proxy:5050" vs
     * "checkout-service"). If heuristic matching were reintroduced, these tests would fail.
     */
    describe('when fetching upstream topology (direction: upstream)', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: CHECKOUT_SERVICE.serviceName,
            start: START,
            end: END,
            direction: 'upstream',
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('returns at least one upstream connection', () => {
        // Regression test: upstream query previously returned 0 results due to
        // span.destination.service.resource matching issues
        expect(resultData.connections.length).to.be.greaterThan(0);
      });

      it('returns upstream callers of the service', () => {
        // frontend calls checkout-service, so frontend should appear as a caller
        const upstreamFromFrontend = findConnection(resultData.connections, {
          source: FRONTEND_SERVICE,
        });

        expect(upstreamFromFrontend).to.be.ok();
        expect(upstreamFromFrontend?.source['service.name']).to.be(FRONTEND_SERVICE.serviceName);
      });

      it('shows the queried service as the target', () => {
        const upstreamFromFrontend = findConnection(resultData.connections, {
          source: FRONTEND_SERVICE,
        });

        expect(upstreamFromFrontend).to.be.ok();

        // Target resolves to the service
        const target = upstreamFromFrontend?.target as { 'service.name': string };
        expect(target['service.name']).to.be(CHECKOUT_SERVICE.serviceName);
      });

      it('includes RED metrics for upstream connections', () => {
        const upstreamFromFrontend = findConnection(resultData.connections, {
          source: FRONTEND_SERVICE,
        });

        expect(upstreamFromFrontend?.metrics).to.be.ok();
        expect(upstreamFromFrontend?.metrics?.latencyMs).to.be.a('number');
        expect(upstreamFromFrontend?.metrics?.throughputPerMin).to.be.a('number');
        expect(upstreamFromFrontend?.metrics?.errorRate).to.be(0);
      });
    });

    describe('when fetching topology in both directions (direction: both)', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: CHECKOUT_SERVICE.serviceName,
            start: START,
            end: END,
            direction: 'both',
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('returns upstream callers', () => {
        // Upstream: frontend → checkout-service
        const upstreamFromFrontend = findConnection(resultData.connections, {
          source: FRONTEND_SERVICE,
        });

        expect(upstreamFromFrontend).to.be.ok();
      });

      it('returns downstream dependencies', () => {
        // Downstream: checkout-service → postgres
        const downstreamToPostgres = findConnection(resultData.connections, {
          source: CHECKOUT_SERVICE,
          target: POSTGRES_DEPENDENCY,
        });

        expect(downstreamToPostgres).to.be.ok();
      });
    });

    /**
     * Regression test: Downstream queries should only return descendants, not siblings.
     *
     * Given topology: frontend → checkout-service → postgres/redis/kafka
     *                         → recommendation-service → postgres
     *
     * When querying checkout-service downstream:
     * - SHOULD include: checkout-service → postgres/redis/kafka (direct deps)
     * - SHOULD NOT include: recommendation-service → postgres (sibling's dep)
     * - SHOULD NOT include: frontend → anything (parent's connections)
     */
    describe('downstream queries exclude sibling dependencies', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: CHECKOUT_SERVICE.serviceName,
            start: START,
            end: END,
            direction: 'downstream',
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('includes direct dependencies of the queried service', () => {
        // checkout-service directly calls postgres, redis, kafka
        const toPostgres = findConnection(resultData.connections, {
          source: CHECKOUT_SERVICE,
          target: POSTGRES_DEPENDENCY,
        });
        const toRedis = findConnection(resultData.connections, {
          source: CHECKOUT_SERVICE,
          target: REDIS_DEPENDENCY,
        });
        const toKafka = findConnection(resultData.connections, {
          source: CHECKOUT_SERVICE,
          target: KAFKA_DEPENDENCY,
        });

        expect(toPostgres).to.be.ok();
        expect(toRedis).to.be.ok();
        expect(toKafka).to.be.ok();
      });

      it('excludes sibling dependencies (recommendation-service calls)', () => {
        // recommendation-service also calls postgres, but it's a sibling, not a descendant
        const fromRecommendation = findConnection(resultData.connections, {
          source: RECOMMENDATION_SERVICE,
        });

        expect(fromRecommendation).to.be(undefined);
      });

      it('excludes parent connections (frontend calls)', () => {
        // frontend is the parent of checkout-service, its connections should not appear
        const fromFrontend = findConnection(resultData.connections, {
          source: FRONTEND_SERVICE,
        });

        expect(fromFrontend).to.be(undefined);
      });

      it('all connections have the queried service or its descendants as source', () => {
        // Every connection should originate from checkout-service (since it has no service descendants)
        const invalidConnections = resultData.connections.filter(
          (c) => c.source['service.name'] !== CHECKOUT_SERVICE.serviceName
        );

        expect(invalidConnections).to.have.length(0);
      });
    });

    /**
     * SRE Use Case: Blast Radius Analysis
     *
     * When a shared dependency (postgres) fails, SREs need to know which services
     * are affected. Using upstream direction on postgres should reveal all callers.
     */
    describe('blast radius analysis for shared dependencies', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: POSTGRES_DEPENDENCY.resource,
            start: START,
            end: END,
            direction: 'upstream',
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('identifies all services that depend on the shared resource', () => {
        // Both checkout-service and recommendation-service call postgres
        const fromCheckout = findConnection(resultData.connections, {
          source: CHECKOUT_SERVICE,
        });

        const fromRecommendation = findConnection(resultData.connections, {
          source: RECOMMENDATION_SERVICE,
        });

        expect(fromCheckout).to.be.ok();
        expect(fromRecommendation).to.be.ok();
      });

      it('shows the dependency type for impact assessment', () => {
        const fromCheckout = findConnection(resultData.connections, {
          source: CHECKOUT_SERVICE,
        });

        expect(fromCheckout).to.be.ok();

        const target = fromCheckout?.target as { 'span.destination.service.resource': string };
        expect(target['span.destination.service.resource']).to.be(POSTGRES_DEPENDENCY.resource);
      });
    });

    /**
     * SRE Use Case: Multi-hop Upstream Discovery
     *
     * When investigating a service issue, SREs need to understand the full upstream call path,
     * not just direct callers. For example, if postgres has issues, knowing that
     * frontend → checkout-service → postgres helps identify the end-to-end impact.
     *
     * The synthtrace scenario generates two trace chains:
     *   frontend → checkout-service → postgres
     *   frontend → recommendation-service → postgres
     */
    describe('upstream queries include full upstream chain (multi-hop)', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        // Query upstream from postgres - should include the full chain:
        // checkout-service → postgres (direct)
        // frontend → checkout-service (indirect, multi-hop)
        // recommendation-service → postgres (direct, separate trace)
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: POSTGRES_DEPENDENCY.resource,
            start: START,
            end: END,
            direction: 'upstream',
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('includes direct callers of the queried service', () => {
        // checkout-service directly calls postgres
        const checkoutToPostgres = findConnection(resultData.connections, {
          source: CHECKOUT_SERVICE,
          target: POSTGRES_DEPENDENCY,
        });

        expect(checkoutToPostgres).to.be.ok();
      });

      it('includes indirect upstream callers (multi-hop)', () => {
        // frontend → checkout-service is in the same trace as checkout-service → postgres
        // So frontend should appear in the upstream chain
        const frontendToCheckout = findConnection(resultData.connections, {
          source: FRONTEND_SERVICE,
          target: CHECKOUT_SERVICE,
        });

        expect(frontendToCheckout).to.be.ok();
      });

      it('includes callers from separate traces', () => {
        // recommendation-service also calls postgres (in a separate trace)
        const recommendationToPostgres = findConnection(resultData.connections, {
          source: RECOMMENDATION_SERVICE,
          target: POSTGRES_DEPENDENCY,
        });

        expect(recommendationToPostgres).to.be.ok();
      });

      it('traverses the entire upstream path', () => {
        // Verify we have connections from multiple levels of the call graph
        const sourceServices = new Set(resultData.connections.map((c) => c.source['service.name']));

        // Should have at least 3 different source services:
        // - checkout-service (direct caller of postgres)
        // - frontend (indirect caller via checkout-service)
        // - recommendation-service (direct caller of postgres, separate trace)
        expect(sourceServices.has(CHECKOUT_SERVICE.serviceName)).to.be(true);
        expect(sourceServices.has(FRONTEND_SERVICE.serviceName)).to.be(true);
        expect(sourceServices.has(RECOMMENDATION_SERVICE.serviceName)).to.be(true);
      });

      it('excludes sibling edges that do not lead to the queried service', () => {
        // checkout-service also calls redis and kafka, but those are sibling edges
        // that don't lead to postgres. They should NOT appear in upstream results.
        const toRedis = findConnection(resultData.connections, { target: REDIS_DEPENDENCY });
        const toKafka = findConnection(resultData.connections, { target: KAFKA_DEPENDENCY });

        expect(toRedis).to.be(undefined);
        expect(toKafka).to.be(undefined);
      });
    });

    /**
     * SRE Use Case: Connection RED Metrics Assessment
     *
     * During incident investigation, SREs need RED metrics to identify unhealthy connections.
     * All synthtrace spans are successful, so we verify metrics are present and reasonable.
     */
    describe('connection RED metrics assessment', () => {
      let resultData: GetServiceTopologyToolResult['data'];

      before(async () => {
        const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
          id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
          params: {
            serviceName: CHECKOUT_SERVICE.serviceName,
            start: START,
            end: END,
            direction: 'downstream',
          },
        });

        expect(results).to.have.length(1);
        resultData = results[0].data;
      });

      it('provides latency metrics to identify slow dependencies', () => {
        const toPostgres = findConnection(resultData.connections, { target: POSTGRES_DEPENDENCY });

        expect(toPostgres?.metrics?.latencyMs).to.be.a('number');
        expect(toPostgres?.metrics?.latencyMs).to.be.greaterThan(0);
      });

      it('returns latency in milliseconds not microseconds', () => {
        // Regression test: latencyMs was previously returned in microseconds (e.g., 30000)
        // instead of milliseconds (e.g., 30). The synthtrace scenario generates spans
        // with durations of 30-40ms for postgres, so latency should be < 1000ms.
        const toPostgres = findConnection(resultData.connections, { target: POSTGRES_DEPENDENCY });

        expect(toPostgres?.metrics?.latencyMs).to.be.a('number');
        // If latency were in microseconds, this would be ~30,000-40,000
        // In milliseconds, it should be ~30-40
        expect(toPostgres?.metrics?.latencyMs).to.be.lessThan(1000);
      });

      it('provides throughput metrics to gauge traffic volume', () => {
        const toPostgres = findConnection(resultData.connections, { target: POSTGRES_DEPENDENCY });

        expect(toPostgres?.metrics?.throughputPerMin).to.be.a('number');
        expect(toPostgres?.metrics?.throughputPerMin).to.be.greaterThan(0);
      });

      it('provides error rate to identify failing connections', () => {
        const toPostgres = findConnection(resultData.connections, { target: POSTGRES_DEPENDENCY });

        expect(toPostgres?.metrics?.errorRate).to.be.a('number');
        // All synthtrace spans are successful, so error rate should be 0
        expect(toPostgres?.metrics?.errorRate).to.be(0);
      });
    });
  });
}
