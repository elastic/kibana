/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { createHash } from 'crypto';
import { EcsVersion } from '@elastic/ecs';
import { Alert } from '@kbn/alerts-as-data-utils';
import { AuthenticatedUser } from '@kbn/core/server';
import {
  ATTACK_DISCOVERY_AD_HOC_RULE_ID,
  ATTACK_DISCOVERY_AD_HOC_RULE_TYPE_ID,
  type CreateAttackDiscoveryAlertsParams,
  replaceAnonymizedValuesWithOriginalValues,
  AttackDiscovery,
} from '@kbn/elastic-assistant-common';
import {
  ALERT_INSTANCE_ID,
  ALERT_RULE_CATEGORY,
  ALERT_RULE_CONSUMER,
  ALERT_RULE_EXECUTION_UUID,
  ALERT_RULE_NAME,
  ALERT_RULE_PRODUCER,
  ALERT_RULE_REVISION,
  ALERT_RULE_TYPE_ID,
  ALERT_RULE_UUID,
  ALERT_START,
  ALERT_STATUS,
  ALERT_URL,
  ALERT_UUID,
  ALERT_WORKFLOW_STATUS,
  ECS_VERSION,
  EVENT_KIND,
  SPACE_IDS,
} from '@kbn/rule-data-utils';
import { isEmpty } from 'lodash/fp';

import { getAlertRiskScore } from './get_alert_risk_score';
import {
  ALERT_ATTACK_DISCOVERY_ALERT_IDS,
  ALERT_ATTACK_DISCOVERY_ALERTS_CONTEXT_COUNT,
  ALERT_ATTACK_DISCOVERY_API_CONFIG,
  ALERT_ATTACK_DISCOVERY_DETAILS_MARKDOWN,
  ALERT_ATTACK_DISCOVERY_DETAILS_MARKDOWN_WITH_REPLACEMENTS,
  ALERT_ATTACK_DISCOVERY_ENTITY_SUMMARY_MARKDOWN,
  ALERT_ATTACK_DISCOVERY_ENTITY_SUMMARY_MARKDOWN_WITH_REPLACEMENTS,
  ALERT_ATTACK_DISCOVERY_MITRE_ATTACK_TACTICS,
  ALERT_ATTACK_DISCOVERY_REPLACEMENTS,
  ALERT_ATTACK_DISCOVERY_SUMMARY_MARKDOWN,
  ALERT_ATTACK_DISCOVERY_SUMMARY_MARKDOWN_WITH_REPLACEMENTS,
  ALERT_ATTACK_DISCOVERY_TITLE,
  ALERT_ATTACK_DISCOVERY_TITLE_WITH_REPLACEMENTS,
  ALERT_ATTACK_DISCOVERY_USER_ID,
  ALERT_ATTACK_DISCOVERY_USER_NAME,
  ALERT_ATTACK_DISCOVERY_USERS,
  ALERT_RISK_SCORE,
} from '../../../schedules/fields/field_names';
import { AttackDiscoveryAlertDocument } from '../../../schedules/types';
import { getAlertUrl } from './get_alert_url';

type AttackDiscoveryAlertDocumentBase = Omit<
  AttackDiscoveryAlertDocument,
  keyof Omit<Alert, typeof ALERT_URL | typeof ALERT_UUID | typeof ALERT_INSTANCE_ID>
>;

export const generateAttackDiscoveryAlertHash = ({
  attackDiscovery,
  connectorId,
  ownerId,
  spaceId,
}: {
  attackDiscovery: AttackDiscovery;
  connectorId: string;
  ownerId: string;
  spaceId: string;
}) => {
  /**
   * We generate an attack discovery alert hash to uniquely identify the attack.
   * The hash is a combination of:
   * - `alertsId` - the set of the detection alerts that led to the attack
   * - `connectorId` - to separate same attacks generated by different LLM connectors
   * - `ownerId` - to separate same attacks generated by different users (ad hoc alerts) or different schedules
   *               We store ad hoc attacks for all users within the same index and that is why we need this separation.
   * - `spaceId` - to separate attacks on a space basis
   */
  return createHash('sha256')
    .update([...attackDiscovery.alertIds].sort().join())
    .update(connectorId)
    .update(ownerId)
    .update(spaceId)
    .digest('hex');
};

export const transformToBaseAlertDocument = ({
  alertDocId,
  alertInstanceId,
  attackDiscovery,
  alertsParams,
  publicBaseUrl,
  spaceId,
}: {
  alertDocId: string;
  alertInstanceId: string;
  attackDiscovery: AttackDiscovery;
  alertsParams: Omit<CreateAttackDiscoveryAlertsParams, 'attackDiscoveries' | 'generationUuid'>;
  publicBaseUrl?: string;
  spaceId: string;
}): AttackDiscoveryAlertDocumentBase => {
  const { alertsContextCount, anonymizedAlerts, apiConfig, connectorName, replacements } =
    alertsParams;

  const {
    alertIds,
    entitySummaryMarkdown,
    detailsMarkdown,
    mitreAttackTactics,
    summaryMarkdown,
    title,
  } = attackDiscovery;

  const baseAlertDocument = {
    // Alert base fields
    [ECS_VERSION]: EcsVersion,
    [ALERT_INSTANCE_ID]: alertInstanceId,
    [ALERT_UUID]: alertDocId, // IMPORTANT: the document _id should be the same as this field when it's bulk inserted
    [ALERT_RISK_SCORE]: getAlertRiskScore({
      alertIds,
      anonymizedAlerts,
    }),
    [ALERT_URL]: getAlertUrl({ alertDocId, basePath: publicBaseUrl, spaceId }),

    // Attack discovery fields
    [ALERT_ATTACK_DISCOVERY_ALERT_IDS]: alertIds,
    [ALERT_ATTACK_DISCOVERY_ALERTS_CONTEXT_COUNT]: alertsContextCount,
    [ALERT_ATTACK_DISCOVERY_API_CONFIG]: {
      action_type_id: apiConfig.actionTypeId,
      connector_id: apiConfig.connectorId,
      model: apiConfig.model,
      name: connectorName,
      provider: apiConfig.provider,
    },
    [ALERT_ATTACK_DISCOVERY_DETAILS_MARKDOWN]: detailsMarkdown,
    [ALERT_ATTACK_DISCOVERY_DETAILS_MARKDOWN_WITH_REPLACEMENTS]:
      replaceAnonymizedValuesWithOriginalValues({
        messageContent: detailsMarkdown,
        replacements,
      }),
    [ALERT_ATTACK_DISCOVERY_ENTITY_SUMMARY_MARKDOWN]: entitySummaryMarkdown,
    [ALERT_ATTACK_DISCOVERY_ENTITY_SUMMARY_MARKDOWN_WITH_REPLACEMENTS]:
      entitySummaryMarkdown != null
        ? replaceAnonymizedValuesWithOriginalValues({
            messageContent: entitySummaryMarkdown,
            replacements,
          })
        : undefined,
    [ALERT_ATTACK_DISCOVERY_MITRE_ATTACK_TACTICS]: mitreAttackTactics,
    [ALERT_ATTACK_DISCOVERY_REPLACEMENTS]: !isEmpty(replacements)
      ? Object.entries(replacements).map(([uuid, value]) => ({
          uuid,
          value,
        }))
      : undefined,
    [ALERT_ATTACK_DISCOVERY_SUMMARY_MARKDOWN]: summaryMarkdown,
    [ALERT_ATTACK_DISCOVERY_SUMMARY_MARKDOWN_WITH_REPLACEMENTS]:
      replaceAnonymizedValuesWithOriginalValues({
        messageContent: summaryMarkdown,
        replacements,
      }),
    [ALERT_ATTACK_DISCOVERY_TITLE]: title,
    [ALERT_ATTACK_DISCOVERY_TITLE_WITH_REPLACEMENTS]: replaceAnonymizedValuesWithOriginalValues({
      messageContent: title,
      replacements,
    }),
  };

  return baseAlertDocument;
};

export const transformToAlertDocuments = ({
  authenticatedUser,
  createAttackDiscoveryAlertsParams,
  now,
  spaceId,
}: {
  authenticatedUser: AuthenticatedUser;
  createAttackDiscoveryAlertsParams: CreateAttackDiscoveryAlertsParams;
  now: Date;
  spaceId: string;
}): AttackDiscoveryAlertDocument[] => {
  const { attackDiscoveries, generationUuid, ...restParams } = createAttackDiscoveryAlertsParams;

  return attackDiscoveries.map((attackDiscovery) => {
    const alertHash = generateAttackDiscoveryAlertHash({
      attackDiscovery,
      connectorId: restParams.apiConfig.connectorId,
      ownerId: authenticatedUser.username ?? authenticatedUser.profile_uid,
      spaceId,
    });

    const baseAlertDocument = transformToBaseAlertDocument({
      alertDocId: alertHash,
      alertInstanceId: alertHash,
      attackDiscovery,
      alertsParams: restParams,
      spaceId,
    });

    return {
      ...baseAlertDocument,

      '@timestamp': now.toISOString(),
      [ALERT_START]: now.toISOString(),
      [ALERT_ATTACK_DISCOVERY_USER_ID]: authenticatedUser.profile_uid,
      [ALERT_ATTACK_DISCOVERY_USER_NAME]: authenticatedUser.username,
      [ALERT_ATTACK_DISCOVERY_USERS]: [
        {
          id: authenticatedUser.profile_uid,
          name: authenticatedUser.username,
        },
      ],
      [ALERT_RULE_EXECUTION_UUID]: generationUuid,
      [ALERT_RULE_CATEGORY]: 'Attack discovery ad hoc (placeholder rule category)',
      [ALERT_RULE_CONSUMER]: 'siem',
      [ALERT_RULE_NAME]: 'Attack discovery ad hoc (placeholder rule name)',
      [ALERT_RULE_PRODUCER]: 'siem',
      [ALERT_RULE_REVISION]: 1,
      [ALERT_RULE_TYPE_ID]: ATTACK_DISCOVERY_AD_HOC_RULE_TYPE_ID, // sentinel value
      [ALERT_RULE_UUID]: ATTACK_DISCOVERY_AD_HOC_RULE_ID, // sentinel value
      [ALERT_STATUS]: 'active',
      [ALERT_WORKFLOW_STATUS]: 'open',
      [EVENT_KIND]: 'signal',
      [SPACE_IDS]: [spaceId],
    };
  });
};
