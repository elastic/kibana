# RFC: Alert telemetry to track customized rule fields

**Author(s)**: @dplumlee
**Status**: Awaiting comments
**Created**: August 4 2025
**Reviewers**: @security-detection-rule-management, @security-detection-engine, @marshallmain

---

## Summary

This RFC is being written to gather comments about different approaches towards enhancing our alert telemetry data. Currently, we collect alert telemetry from prebuilt rules to gather metrics for rule tuning and global threat reports, but when certain rule fields are customized, this data can become skewed and less reliable. We're aiming to add this context to the existing alert telemetry snapshots so that we can filter alerts from rules with certain edited fields out of the overall metrics data.

---

## Background & Context

**Related tickets**: 
 - https://github.com/elastic/security-team/issues/12507 (primary ticket)
 - https://github.com/elastic/kibana/issues/140369

### Why this alert telemetry is needed

With the implementation of prebuilt rule customization, users are now able to edit almost every field in their prebuilt rules, including functionally dependent fields such as `query`, `filters`, etc. (see full list in the appendix below), which have the potential to change which alerts are generated by the rule. As it exists now, the alert telemetry we gather from users' environments contains limited information about the rule itself, and there is no way to see if the rule is customized at all, let alone which specific fields have been customized. 

We use this alert telemetry in a few different ways, the most notable of which is the TRaDE team's research on how best to tune the rules for threat coverage. We also use it to build the [global threat report](https://www.elastic.co/resources/security/report/global-threat-report) the company releases every year. The current lack of rule customization context in the alert telemetry makes it impossible to distinguish between alerts from unmodified rules and alerts from modified rules, which have the potential to skew this data, leading to less reliable insights gathered. 

For instance, if a rule's query was modified to better suit a user's need to find threats, it could generate vastly different results than the original query would have. With no way to reconcile these changes from a telemetry point of view, the alerts being generated by a different query are looped in with the rest of the unmodified rules' alerts and we are no longer able to trust the collected alerts are being written from the same logic.

### Why this alert telemetry needs to contain information about which fields are customized

The quick solution would be to add the existing `rule_source` field to the alert telemetry [included rule fields](https://github.com/elastic/kibana/blob/0ad59fab8835d67b476ffbdb82850649e70ab4d9/x-pack/solutions/security/plugins/security_solution/server/lib/telemetry/filterlists/prebuilt_rules_alerts.ts), create filters off that, and be done with it. This would unfortunately be too crude of a solution, and would filter out many valuable alerts that have no difference than those generated by an unmodified rules. 

Only customized functional fields - fields that have the ability to modify which alerts are written by a rule - are cause for concern when collecting this alert telemetry data. If a user were to customize a non-functional field such as `tags` or `note`, it would have no influence on the alerts generated by a rule; they're fields that users often change just for workflow management reasons. Changing a functional field, however, like `query` has ramifications on which events the rule creates alerts from. It could generate drastically different results than that of the original, unmodified prebuilt rule which, while probably beneficial to the user, would be entirely unhelpful for our telemetry data that's assuming the original `query` field is being used.

Because of this difference, we need to collect information from the rule that not only tells us that the rule is customized, but also *how* the rule is customized. From that, we can filter telemetry alerts at a more granular, per-field level, allowing us to still utilize data from customized prebuilt rules.

### What existing tools do we have at our disposal?

As mentioned earlier, we already collect prebuilt rule alert telemetry from real customers in the field. This telemetry is sanitized for performance and privacy reasons through an [allowlist](https://github.com/elastic/kibana/blob/0ad59fab8835d67b476ffbdb82850649e70ab4d9/x-pack/solutions/security/plugins/security_solution/server/lib/telemetry/filterlists/prebuilt_rules_alerts.ts) and collected every hour by [this task](https://github.com/elastic/kibana/blob/06f5a860b6a9fdf12352a9c5934ca36a4a3311ea/x-pack/solutions/security/plugins/security_solution/server/lib/telemetry/tasks/prebuilt_rule_alerts.ts). It's separate from the [daily snapshot telemetry](https://docs.elastic.dev/telemetry/collection/snapshot-telemetry) we also collect from clusters - that telemetry is mostly used for aggregation data.

We had previously looked into using daily snapshot telemetry for this problem, but given we'd need to collect all relevant alert documents over the 24 hour window it operates in, the method proved too costly and performance intensive.

### Calculating the rule diff for alert objects in snapshot telemetry

Since we already have existing alert telemetry in place, it makes sense to build on top of that without having to start from scratch. Given this, we can start to look at how best to include the customized rule fields into the telemetry data. An easy way to add it would be to [enrich the sanitized alerts](https://github.com/elastic/kibana/blob/06f5a860b6a9fdf12352a9c5934ca36a4a3311ea/x-pack/solutions/security/plugins/security_solution/server/lib/telemetry/tasks/prebuilt_rule_alerts.ts#L93) with a new object listing the customized fields that we can calculate for each alert as fetched. 

However, we immediately run into an issue: the rule diff calculation is an expensive one, already causing multiple performance issues in endpoints that use it. Calling it for each alert in a batch that could contain hundreds if not thousands of alerts would likely prove extremely taxing on performance, possibly even causing timeouts from the telemetry tasks.

The idea was considered to use an internal cache to store the rule assets themselves so that the most cost-intensive part of the rule diff calculation - fetching the rule assets - could be sped up, but it was determined that the size of this cache could also be prohibitively large. We would potentially have to store multiple versions for every prebuilt rule of a library that is growing every month and already contains 1300+ rules.

Given these constraints, the only likely option left is to have the rule diff information already be on the alert document when fetched. This way, we could simply pass it onto the alert telemetry data like the other fields in the allowlist and filter on the relevant fields in our analytics dashboards.

---

## Problem Statement

We need to establish a method to add which specific rule fields are customized to the alert documents so that the telemetry data is able to visualize which alerts are coming from prebuilt rules with functional fields that have been modified, and filter those alerts in a trivial manner.

---

## Goals

 - This solution should be efficient in performance
   - At some point we will need to do the rule diff calculation, that's unavoidable. Given how much performance trouble it's caused us in the past to do this calculation at scale, we need a way to make sure this doesn't cause performance issues elsewhere in the app or telemetry endpoints.
 - This solution needs to be extensible
   - We are inevitably going to add more fields, both functional and non-functional to our rule schema. These fields also need to be easily added to this telemetry calculation, ideally without any additional code being written on the telemetry side of things
 - This solution should be quick to implement
   - Given enough time and resources, we could probably create a whole new telemetry system specifically for customized rule fields with the greatest analytics data this company has ever seen. However we don't have all those things and should prioritize using existing tools and telemetry data wherever possible. 

---

## Non-Goals

Though we want any solution to be extensible, this RFC is not attempting to discuss any specific rule schema changes coming in the future that aren't related to this issue. 

---

## Rejected Solutions

### Calculating the rule diff during rule execution

This would be similar to the previously discussed idea to calculate rule diffs in the telemetry snapshot, but instead at rule execution time, right before we write the rule object to the alert document. It would be a lot less data to parse through (one rule execution vs 24 hours worth of alerts) but we'd still bump up against similar performance issues mentioned with the daily snapshot - particularly when thinking about this calculation being done for every time a customized rule executes across a whole instance. We'd also run into another performance issue - namely slowing down the rule execution process itself. While the rule diff calculation for a single rule execution wouldn't be too cost prohibitive - especially as we'd be able to use the same rule diff object for all alerts generated by that execution - it would still have performance ramifications for rule execution speed, something we try to maximize when possible. Again thinking about this performance hit, however minor, stretched across every rule execution by every rule customized rule starts to result in a bit larger performance impact than we were comfortable with. 

This was primarily another case of being weary of running the rule diff calculation at scale, something we have seen cause major performance issues in the past. Our solution, in order to be efficient, will only run this calculation when absolutely needed.

### Using a hash of functional fields to quickly compare changes

This solution would have compared a hash of functional fields (most notably query fields) to a hash of the unmodified rule's functional fields to quickly detect any changes in the object. The idea behind this was: instead of fetching whole rule objects to then run the diff calculation on, why not simply fetch a stored hash of unmodified functional fields, quickly hash the current rule's functional fields and compare the two to see if there was any divergence between the two rules? This solution would have been very quick and allowed us to likely run this calculation within the alert snapshot endpoint, but the lack of granularity and rigidness when calculating the stored hashes made us reject this path. The extensibility factor for if/when another functional field was added or changed combined with the need to keep another rule asset-like object stored somewhere was too much complexity to add.

---

## Proposed Solution: Adding a field to the rule schema to track specific customized fields

### Approach and technical details
At its core, this solution is pretty simple: adding a new field to the rule schema that would keep track of which field(s) were customized on the rule object. This would allow us to write the customized field list to the alert object at rule execution the same as we do any rule field, without any runtime calculations that'd slow down rule execution. The field would be updated in the same places `rule_source` is currently updated (basically any CRUD operation on the rule object), and would be either omitted or defaulted to an empty array if a rule's base version didn't exist as there'd be no way to accurately calculate the field list.

This field would be an array and it would contain a list of customized fields. It was considered to have this field be a key/value pair with the key being the field name and the value be the original, unmodified rule field but was rejected. Having the original values would no doubt be helpful in some cases but would also introduce a whole host of new edge cases and potentially double the size of the rule object if most fields were customized. Having the names of the fields customized is all we'd need for our use case and some of the previously linked telemetry tickets. Furthermore, the querying of an array within the alerts telemetry cluster would be far more straightforward than querying for keys on an object, as KQL doesn't support the direct querying of object keys and we'd have to rely on wildcard queries or some other syntax. Arrays also allow us to easily chain together multiple clauses in order to be extremely granular with our telemetry analysis. I've listed some example KQL queries below. 

This field would live on its own in the rule params object. Given the extensibility likelihood for `rule_source` with third party packages, it has the potential to get crowded quickly and doesn't need to be mixed with the customizations calculation itself.

I believe a good name for this field would be `rule_customizations` because of the existing language we have in `rule_source` with `is_customized`. It's also a fairly good descriptor of exactly what the field contains.

### Examples

**Example rule object with new field**

```js
{
    ...
    "rule_source": {
        "type": "external",
        "is_customized": true,
    },
    // New field
    "rule_customizations": [
        "kql_query",
        "note",
        "tags",
    ],
    ...
}
```

**Example KQL queries in the alerts telemetry cluster**

```
not kibana.alert.rule.params.rule_customizations : "kql_query"
```
A query we could use to filter out any alerts generated by prebuilt rules that have their query field customized. This could easily be expanded to every rule type to exclude all alerts from rules with modified query strings.


```
kibana.alert.rule.params.rule_customizations : "note" and kibana.alert.rule.params.rule_customizations : "tags" and not kibana.alert.rule.params.rule_customizations : "kql_query"
```
Still filtering out any rules with customized query fields, but this example shows we can be more granular with the fields we include and exclude.


### Pros  
- Lightweight and relatively easy to implement
  - Obviously adding a field to the rule schema isn't a one line PR, but there wouldn't be much overhead to add this field and not a lot of intersection with areas of the app that would actually break things
  - We're adding something new, not changing something
- Would have a negligible effect on performance
  - We already calculate the rule diff everywhere we'd modify this field, would just need to carry over the field names.
  - No need to run the rule diff calculation at rule execution time, just copy it to the alert object like we do any other field
- Easy to query on the telemetry side
  - Building aggregation visualizations and dashboards in the alert telemetry cluster would be fairly straightforward with this implementation. As shown in some of the examples above, we can be granular and specific with our queries.

### Cons 
- The field names stored would be diffable fields (grouped fields) which aren't a one-to-one match with the fields on the rest of the rule object
  - e.g. `query` would be on the rule object but represented as `kql_query` in the `rule_customizations` field
  - This means we'd be intersecting 2 schemas: the rule schema and the diffable rule schema
- Once we add it there's (basically) no going back
  - Not necessarily a con but something to consider in terms of longevity 

### Complexity & Cost

This effort would involve:
 -  adding a new field to our rule schemas
 -  updating all dependent schemas
 -  adding the logic to update this field all the same places we update `rule_source`
 -  writing the new field to the alert documents during rule execution
 -  writing tests to cover the new field and resulting logic additions

This is all in addition to the then-unblocked telemetry work that could take place once this was implemented.

---

## Appendix

### Defining functional rule fields

| Rule type        | Field name in UI          | Diffable rule field       | Functional field? |
| ---------------- | ------------------------- | ------------------------- | ----------------- |
| All rule types   | Rule name                 | `name`                    | No                |
| All rule types   | Rule description          | `description`             | No                |
| All rule types   | Rule type                 | `type`                    | Yes               |
| All rule types   | Rule version              | `version`                 | No                |
| All rule types   | Rule author               | `author`                  | No                |
| All rule types   | Rule license              | `license`                 | No                |
| All rule types   | Tags                      | `tags`                    | No                |
| All rule types   | Default severity          | `severity`                | No                |
| All rule types   | Severity Override         | `severity_mapping`        | No                |
| All rule types   | Default risk score        | `risk_score`              | No                |
| All rule types   | Risk score override       | `risk_score_mapping`      | No                |
| All rule types   | Reference URLs            | `references`              | No                |
| All rule types   | False positive examples   | `false_positives`         | No                |
| All rule types   | MITRE ATT&CKâ„¢ threats     | `threat`                  | No                |
| All rule types   | Setup guide               | `setup`                   | No                |
| All rule types   | Investigation guide       | `note`                    | No                |
| All rule types   | Related integrations      | `related_integrations`    | No                |
| All rule types   | Required fields           | `required_fields`         | No                |
| All rule types   | Rule schedule             | `rule_schedule`           | Yes               |
| All rule types   | Max alerts per run        | `max_signals`             | Yes               |
| All rule types   | Rule name override        | `rule_name_override`      | No                |
| All rule types   | Timestamp override        | `timestamp_override`      | No                |
| All rule types   | Timeline template         | `timeline_template`       | No                |
| All rule types   | Building block            | `building_block`          | No                |
| All rule types   | Investigation fields      | `investigation_fields`    | No                |
| All rule types   | Data source               | `data_source`             | Yes               |
| All rule types   | Suppress alerts           | `alert_suppression`       | Yes               |
| Custom Query     | Custom query              | `kql_query`               | Yes               |
| Saved Query      | Custom query              | `kql_query`               | Yes               |
| EQL              | EQL query                 | `eql_query`               | Yes               |
| ESQL             | ESQL query                | `esql_query`              | Yes               |
| Threat Match     | Custom query              | `kql_query`               | Yes               |
| Threat Match     | Indicator index patterns  | `threat_index`            | Yes               |
| Threat Match     | Indicator index query     | `threat_query`            | Yes               |
| Threat Match     | Indicator mapping         | `threat_mapping`          | Yes               |
| Threat Match     | Indicator prefix override | `threat_indicator_path`   | Yes               |
| Threshold        | Custom query              | `kql_query`               | Yes               |
| Threshold        | Threshold config          | `threshold`               | Yes               |
| Machine Learning | Machine Learning job      | `machine_learning_job_id` | Yes               |
| Machine Learning | Anomaly score threshold   | `anomaly_threshold`       | Yes               |
| New Terms        | Custom query              | `kql_query`               | Yes               |
| New Terms        | Fields                    | `new_terms_fields`        | Yes               |
| New Terms        | History Window Size       | `history_window_start`    | Yes               |
