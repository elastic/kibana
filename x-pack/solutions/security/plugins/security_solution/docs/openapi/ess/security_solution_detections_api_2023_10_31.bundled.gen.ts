/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 *
 * info:
 *   title: Security Detections API (Elastic Cloud and self-hosted)
 *   version: 2023-10-31
 */

import { z } from '@kbn/zod';
import { isValidDateMath, isNonEmptyString } from '@kbn/zod-helpers';

export type AlertAssignees = z.infer<typeof AlertAssignees>;
export const AlertAssignees = z.object({
  add: z.array(z.string().min(1).superRefine(isNonEmptyString)),
  remove: z.array(z.string().min(1).superRefine(isNonEmptyString)),
});

/**
 * A list of alerts `id`s.
 */
export type AlertIds = z.infer<typeof AlertIds>;
export const AlertIds = z.array(z.string().min(1).superRefine(isNonEmptyString)).min(1);

/**
 * (deprecated) Has no effect.
 * @deprecated
 */
export type AlertsIndex = z.infer<typeof AlertsIndex>;
export const AlertsIndex = z.string();

export type AlertsIndexMigrationError = z.infer<typeof AlertsIndexMigrationError>;
export const AlertsIndexMigrationError = z.object({
  error: z.object({
    message: z.string(),
    status_code: z.string(),
  }),
  index: z.string(),
});

export type AlertsIndexMigrationSuccess = z.infer<typeof AlertsIndexMigrationSuccess>;
export const AlertsIndexMigrationSuccess = z.object({
  index: z.string(),
  migration_id: z.string(),
  migration_index: z.string(),
});

/**
 * Has no effect.
 */
export type AlertsIndexNamespace = z.infer<typeof AlertsIndexNamespace>;
export const AlertsIndexNamespace = z.string();

export type AlertsReindexOptions = z.infer<typeof AlertsReindexOptions>;
export const AlertsReindexOptions = z.object({
  /**
   * The throttle for the migration task in sub-requests per second. Corresponds to requests_per_second on the Reindex API.
   */
  requests_per_second: z.number().int().min(1).optional(),
  /**
   * Number of alerts to migrate per batch. Corresponds to the source.size option on the Reindex API.
   */
  size: z.number().int().min(1).optional(),
  /**
   * The number of subtasks for the migration task. Corresponds to slices on the Reindex API.
   */
  slices: z.number().int().min(1).optional(),
});

export type AlertsSortCombinations = z.infer<typeof AlertsSortCombinations>;
export const AlertsSortCombinations = z.union([z.string(), z.object({}).catchall(z.unknown())]);

export type AlertsSort = z.infer<typeof AlertsSort>;
export const AlertsSort = z.union([AlertsSortCombinations, z.array(AlertsSortCombinations)]);

/**
 * The status of an alert, which can be `open`, `acknowledged`, `in-progress`, or `closed`.
 */
export type AlertStatus = z.infer<typeof AlertStatus>;
export const AlertStatus = z.enum(['open', 'closed', 'acknowledged', 'in-progress']);
export type AlertStatusEnum = typeof AlertStatus.enum;
export const AlertStatusEnum = AlertStatus.enum;

export type AlertSuppressionDurationUnit = z.infer<typeof AlertSuppressionDurationUnit>;
export const AlertSuppressionDurationUnit = z.enum(['s', 'm', 'h']);
export type AlertSuppressionDurationUnitEnum = typeof AlertSuppressionDurationUnit.enum;
export const AlertSuppressionDurationUnitEnum = AlertSuppressionDurationUnit.enum;

export type AlertSuppressionDuration = z.infer<typeof AlertSuppressionDuration>;
export const AlertSuppressionDuration = z.object({
  unit: AlertSuppressionDurationUnit,
  value: z.number().int().min(1),
});

export type AlertSuppressionGroupBy = z.infer<typeof AlertSuppressionGroupBy>;
export const AlertSuppressionGroupBy = z.array(z.string()).min(1).max(3);

/**
  * Describes how alerts will be generated for documents with missing suppress by fields:
doNotSuppress - per each document a separate alert will be created
suppress - only alert will be created per suppress by bucket
  */
export type AlertSuppressionMissingFieldsStrategy = z.infer<
  typeof AlertSuppressionMissingFieldsStrategy
>;
export const AlertSuppressionMissingFieldsStrategy = z.enum(['doNotSuppress', 'suppress']);
export type AlertSuppressionMissingFieldsStrategyEnum =
  typeof AlertSuppressionMissingFieldsStrategy.enum;
export const AlertSuppressionMissingFieldsStrategyEnum = AlertSuppressionMissingFieldsStrategy.enum;

export type AlertSuppression = z.infer<typeof AlertSuppression>;
export const AlertSuppression = z.object({
  duration: AlertSuppressionDuration.optional(),
  group_by: AlertSuppressionGroupBy,
  missing_fields_strategy: AlertSuppressionMissingFieldsStrategy.optional(),
});

/**
 * Use alert tags to organize related alerts into categories that you can filter and group.
 */
export type AlertTag = z.infer<typeof AlertTag>;
export const AlertTag = z.string().min(1).superRefine(isNonEmptyString);

/**
 * List of keywords to organize related alerts into categories that you can filter and group.
 */
export type AlertTags = z.infer<typeof AlertTags>;
export const AlertTags = z.array(AlertTag);

export type AlertVersion = z.infer<typeof AlertVersion>;
export const AlertVersion = z.object({
  count: z.number().int(),
  version: z.number().int(),
});

/**
 * Anomaly threshold
 */
export type AnomalyThreshold = z.infer<typeof AnomalyThreshold>;
export const AnomalyThreshold = z.number().int().min(0);

/**
 * Determines if the rule acts as a building block. By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts. Its value must be default.
 */
export type BuildingBlockType = z.infer<typeof BuildingBlockType>;
export const BuildingBlockType = z.string();

/**
 * String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
 */
export type RuleTagArray = z.infer<typeof RuleTagArray>;
export const RuleTagArray = z.array(z.string());

export type BulkActionEditPayloadTags = z.infer<typeof BulkActionEditPayloadTags>;
export const BulkActionEditPayloadTags = z.object({
  type: z.enum(['add_tags', 'delete_tags', 'set_tags']),
  value: RuleTagArray,
});

export type IndexPatternArray = z.infer<typeof IndexPatternArray>;
export const IndexPatternArray = z.array(z.string());

export type BulkActionEditPayloadIndexPatterns = z.infer<typeof BulkActionEditPayloadIndexPatterns>;
export const BulkActionEditPayloadIndexPatterns = z.object({
  overwrite_data_views: z.boolean().optional(),
  type: z.enum(['add_index_patterns', 'delete_index_patterns', 'set_index_patterns']),
  value: IndexPatternArray,
});

/**
 * A string that does not contain only whitespace characters
 */
export type NonEmptyString = z.infer<typeof NonEmptyString>;
export const NonEmptyString = z.string().min(1).superRefine(isNonEmptyString);

/**
  * Schema for fields relating to investigation fields. These are user defined fields we use to highlight
in various features in the UI such as alert details flyout and exceptions auto-population from alert.
Added in PR #163235
Right now we only have a single field but anticipate adding more related fields to store various
configuration states such as `override` - where a user might say if they want only these fields to
display, or if they want these fields + the fields we select. When expanding this field, it may look
something like:
```typescript
const investigationFields = z.object({
  field_names: NonEmptyArray(NonEmptyString),
  override: z.boolean().optional(),
});
```

  */
export type InvestigationFields = z.infer<typeof InvestigationFields>;
export const InvestigationFields = z.object({
  field_names: z.array(NonEmptyString).min(1),
});

export type BulkActionEditPayloadInvestigationFields = z.infer<
  typeof BulkActionEditPayloadInvestigationFields
>;
export const BulkActionEditPayloadInvestigationFields = z.object({
  type: z.enum([
    'add_investigation_fields',
    'delete_investigation_fields',
    'set_investigation_fields',
  ]),
  value: InvestigationFields,
});

/**
 * Timeline template ID
 */
export type TimelineTemplateId = z.infer<typeof TimelineTemplateId>;
export const TimelineTemplateId = z.string();

/**
 * Timeline template title
 */
export type TimelineTemplateTitle = z.infer<typeof TimelineTemplateTitle>;
export const TimelineTemplateTitle = z.string();

export type BulkActionEditPayloadTimeline = z.infer<typeof BulkActionEditPayloadTimeline>;
export const BulkActionEditPayloadTimeline = z.object({
  type: z.literal('set_timeline'),
  value: z.object({
    timeline_id: TimelineTemplateId,
    timeline_title: TimelineTemplateTitle,
  }),
});

export type RuleActionAlertsFilter = z.infer<typeof RuleActionAlertsFilter>;
export const RuleActionAlertsFilter = z.object({}).catchall(z.unknown());

/**
 * The condition for throttling the notification: `onActionGroupChange`, `onActiveAlert`,  or `onThrottleInterval`
 */
export type RuleActionNotifyWhen = z.infer<typeof RuleActionNotifyWhen>;
export const RuleActionNotifyWhen = z.enum([
  'onActiveAlert',
  'onThrottleInterval',
  'onActionGroupChange',
]);
export type RuleActionNotifyWhenEnum = typeof RuleActionNotifyWhen.enum;
export const RuleActionNotifyWhenEnum = RuleActionNotifyWhen.enum;

/**
 * Defines how often rule actions are taken.
 */
export type RuleActionThrottle = z.infer<typeof RuleActionThrottle>;
export const RuleActionThrottle = z.union([
  z.enum(['no_actions', 'rule']),
  z.string().regex(/^[1-9]\d*[smhd]$/),
]);

/**
 * The action frequency defines when the action runs (for example, only on rule execution or at specific time intervals).
 */
export type RuleActionFrequency = z.infer<typeof RuleActionFrequency>;
export const RuleActionFrequency = z.object({
  notifyWhen: RuleActionNotifyWhen,
  /**
   * Action summary indicates whether we will send a summary notification about all the generate alerts or notification per individual alert
   */
  summary: z.boolean(),
  throttle: RuleActionThrottle.nullable(),
});

/**
 * Optionally groups actions by use cases. Use `default` for alert notifications.
 */
export type RuleActionGroup = z.infer<typeof RuleActionGroup>;
export const RuleActionGroup = z.string();

/**
 * The connector ID.
 */
export type RuleActionId = z.infer<typeof RuleActionId>;
export const RuleActionId = z.string();

/**
 * Object containing the allowed connector fields, which varies according to the connector type.
 */
export type RuleActionParams = z.infer<typeof RuleActionParams>;
export const RuleActionParams = z.object({}).catchall(z.unknown());

export type NormalizedRuleAction = z.infer<typeof NormalizedRuleAction>;
export const NormalizedRuleAction = z
  .object({
    alerts_filter: RuleActionAlertsFilter.optional(),
    frequency: RuleActionFrequency.optional(),
    group: RuleActionGroup.optional(),
    id: RuleActionId,
    params: RuleActionParams,
  })
  .strict();

/**
 * The condition for throttling the notification: 'rule', 'no_actions', or time duration
 */
export type ThrottleForBulkActions = z.infer<typeof ThrottleForBulkActions>;
export const ThrottleForBulkActions = z.enum(['rule', '1h', '1d', '7d']);
export type ThrottleForBulkActionsEnum = typeof ThrottleForBulkActions.enum;
export const ThrottleForBulkActionsEnum = ThrottleForBulkActions.enum;

export type BulkActionEditPayloadRuleActions = z.infer<typeof BulkActionEditPayloadRuleActions>;
export const BulkActionEditPayloadRuleActions = z.object({
  type: z.enum(['add_rule_actions', 'set_rule_actions']),
  value: z.object({
    actions: z.array(NormalizedRuleAction),
    throttle: ThrottleForBulkActions.optional(),
  }),
});

export type BulkActionEditPayloadSchedule = z.infer<typeof BulkActionEditPayloadSchedule>;
export const BulkActionEditPayloadSchedule = z.object({
  type: z.literal('set_schedule'),
  value: z.object({
    /**
     * Interval in which the rule runs. For example, `"1h"` means the rule runs every hour.
     */
    interval: z.string().regex(/^[1-9]\d*[smh]$/),
    /**
     * Lookback time for the rule
     */
    lookback: z.string().regex(/^[1-9]\d*[smh]$/),
  }),
});

export const BulkActionEditPayloadInternal = z.union([
  BulkActionEditPayloadTags,
  BulkActionEditPayloadIndexPatterns,
  BulkActionEditPayloadInvestigationFields,
  BulkActionEditPayloadTimeline,
  BulkActionEditPayloadRuleActions,
  BulkActionEditPayloadSchedule,
]);

export type BulkActionEditPayload = z.infer<typeof BulkActionEditPayloadInternal>;
export const BulkActionEditPayload =
  BulkActionEditPayloadInternal as z.ZodType<BulkActionEditPayload>;

export type BulkActionsDryRunErrCode = z.infer<typeof BulkActionsDryRunErrCode>;
export const BulkActionsDryRunErrCode = z.enum([
  'IMMUTABLE',
  'PREBUILT_CUSTOMIZATION_LICENSE',
  'MACHINE_LEARNING_AUTH',
  'MACHINE_LEARNING_INDEX_PATTERN',
  'ESQL_INDEX_PATTERN',
  'MANUAL_RULE_RUN_FEATURE',
  'MANUAL_RULE_RUN_DISABLED_RULE',
]);
export type BulkActionsDryRunErrCodeEnum = typeof BulkActionsDryRunErrCode.enum;
export const BulkActionsDryRunErrCodeEnum = BulkActionsDryRunErrCode.enum;

export type BulkEditSkipReason = z.infer<typeof BulkEditSkipReason>;
export const BulkEditSkipReason = z.literal('RULE_NOT_MODIFIED');

export type BulkActionSkipResult = z.infer<typeof BulkActionSkipResult>;
export const BulkActionSkipResult = z.object({
  id: z.string(),
  name: z.string().optional(),
  skip_reason: BulkEditSkipReason,
});

export type RuleAction = z.infer<typeof RuleAction>;
export const RuleAction = z.object({
  /**
   * The action type used for sending notifications.
   */
  action_type_id: z.string(),
  alerts_filter: RuleActionAlertsFilter.optional(),
  frequency: RuleActionFrequency.optional(),
  group: RuleActionGroup.optional(),
  id: RuleActionId,
  params: RuleActionParams,
  uuid: NonEmptyString.optional(),
});

export type SavedObjectResolveAliasPurpose = z.infer<typeof SavedObjectResolveAliasPurpose>;
export const SavedObjectResolveAliasPurpose = z.enum([
  'savedObjectConversion',
  'savedObjectImport',
]);
export type SavedObjectResolveAliasPurposeEnum = typeof SavedObjectResolveAliasPurpose.enum;
export const SavedObjectResolveAliasPurposeEnum = SavedObjectResolveAliasPurpose.enum;

export type SavedObjectResolveAliasTargetId = z.infer<typeof SavedObjectResolveAliasTargetId>;
export const SavedObjectResolveAliasTargetId = z.string();

export type RuleAuthorArray = z.infer<typeof RuleAuthorArray>;
export const RuleAuthorArray = z.array(z.string());

export type RuleDescription = z.infer<typeof RuleDescription>;
export const RuleDescription = z.string().min(1);

/**
 * Determines whether the rule is enabled.
 */
export type IsRuleEnabled = z.infer<typeof IsRuleEnabled>;
export const IsRuleEnabled = z.boolean();

/**
 * The exception type
 */
export type ExceptionListType = z.infer<typeof ExceptionListType>;
export const ExceptionListType = z.enum([
  'detection',
  'rule_default',
  'endpoint',
  'endpoint_trusted_apps',
  'endpoint_events',
  'endpoint_host_isolation_exceptions',
  'endpoint_blocklists',
]);
export type ExceptionListTypeEnum = typeof ExceptionListType.enum;
export const ExceptionListTypeEnum = ExceptionListType.enum;

export type RuleExceptionList = z.infer<typeof RuleExceptionList>;
export const RuleExceptionList = z.object({
  /**
   * ID of the exception container
   */
  id: NonEmptyString,
  /**
   * List ID of the exception container
   */
  list_id: NonEmptyString,
  /**
   * Determines the exceptions validity in rule's Kibana space
   */
  namespace_type: z.enum(['agnostic', 'single']),
  type: ExceptionListType,
});

export type RuleFalsePositiveArray = z.infer<typeof RuleFalsePositiveArray>;
export const RuleFalsePositiveArray = z.array(z.string());

/**
 * Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
 */
export type RuleIntervalFrom = z.infer<typeof RuleIntervalFrom>;
export const RuleIntervalFrom = z.string().superRefine(isValidDateMath);

/**
 * Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
 */
export type RuleInterval = z.infer<typeof RuleInterval>;
export const RuleInterval = z.string();

/**
 * The rule's license.
 */
export type RuleLicense = z.infer<typeof RuleLicense>;
export const RuleLicense = z.string();

export type MaxSignals = z.infer<typeof MaxSignals>;
export const MaxSignals = z.number().int().min(1);

export type RuleMetadata = z.infer<typeof RuleMetadata>;
export const RuleMetadata = z.object({}).catchall(z.unknown());

export type RuleName = z.infer<typeof RuleName>;
export const RuleName = z.string().min(1);

/**
 * Notes to help investigate alerts produced by the rule.
 */
export type InvestigationGuide = z.infer<typeof InvestigationGuide>;
export const InvestigationGuide = z.string();

export type SavedObjectResolveOutcome = z.infer<typeof SavedObjectResolveOutcome>;
export const SavedObjectResolveOutcome = z.enum(['exactMatch', 'aliasMatch', 'conflict']);
export type SavedObjectResolveOutcomeEnum = typeof SavedObjectResolveOutcome.enum;
export const SavedObjectResolveOutcomeEnum = SavedObjectResolveOutcome.enum;

export type RuleReferenceArray = z.infer<typeof RuleReferenceArray>;
export const RuleReferenceArray = z.array(z.string());

/**
  * Related integration is a potential dependency of a rule. It's assumed that if the user installs
one of the related integrations of a rule, the rule might start to work properly because it will
have source events (generated by this integration) potentially matching the rule's query.

NOTE: Proper work is not guaranteed, because a related integration, if installed, can be
configured differently or generate data that is not necessarily relevant for this rule.

Related integration is a combination of a Fleet package and (optionally) one of the
package's "integrations" that this package contains. It is represented by 3 properties:

- `package`: name of the package (required, unique id)
- `version`: version of the package (required, semver-compatible)
- `integration`: name of the integration of this package (optional, id within the package)

There are Fleet packages like `windows` that contain only one integration; in this case,
`integration` should be unspecified. There are also packages like `aws` and `azure` that contain
several integrations; in this case, `integration` should be specified.

@example
const x: RelatedIntegration = {
  package: 'windows',
  version: '1.5.x',
};

@example
const x: RelatedIntegration = {
  package: 'azure',
  version: '~1.1.6',
  integration: 'activitylogs',
};

  */
export type RelatedIntegration = z.infer<typeof RelatedIntegration>;
export const RelatedIntegration = z.object({
  integration: NonEmptyString.optional(),
  package: NonEmptyString,
  version: NonEmptyString,
});

export type RelatedIntegrationArray = z.infer<typeof RelatedIntegrationArray>;
export const RelatedIntegrationArray = z.array(RelatedIntegration);

/**
 * Input parameters to create a RequiredField. Does not include the `ecs` field, because `ecs` is calculated on the backend based on the field name and type.
 */
export type RequiredFieldInput = z.infer<typeof RequiredFieldInput>;
export const RequiredFieldInput = z.object({
  /**
   * Name of an Elasticsearch field
   */
  name: NonEmptyString,
  /**
   * Type of an Elasticsearch field
   */
  type: NonEmptyString,
});

export type EcsMapping = z.infer<typeof EcsMapping>;
export const EcsMapping = z.object({}).catchall(
  z.object({
    field: z.string().optional(),
    value: z.union([z.string(), z.array(z.string())]).optional(),
  })
);

export type OsqueryQuery = z.infer<typeof OsqueryQuery>;
export const OsqueryQuery = z.object({
  ecs_mapping: EcsMapping.optional(),
  /**
   * Query ID
   */
  id: z.string(),
  platform: z.string().optional(),
  /**
   * Query to run
   */
  query: z.string(),
  removed: z.boolean().optional(),
  snapshot: z.boolean().optional(),
  /**
   * Query version
   */
  version: z.string().optional(),
});

export type OsqueryParams = z.infer<typeof OsqueryParams>;
export const OsqueryParams = z.object({
  ecs_mapping: EcsMapping.optional(),
  pack_id: z.string().optional(),
  queries: z.array(OsqueryQuery).optional(),
  query: z.string().optional(),
  saved_query_id: z.string().optional(),
  timeout: z.number().optional(),
});

export type OsqueryResponseAction = z.infer<typeof OsqueryResponseAction>;
export const OsqueryResponseAction = z.object({
  action_type_id: z.literal('.osquery'),
  params: OsqueryParams,
});

export type DefaultParams = z.infer<typeof DefaultParams>;
export const DefaultParams = z.object({
  command: z.literal('isolate'),
  comment: z.string().optional(),
});

export type ProcessesParams = z.infer<typeof ProcessesParams>;
export const ProcessesParams = z.object({
  command: z.enum(['kill-process', 'suspend-process']),
  comment: z.string().optional(),
  config: z.object({
    /**
     * Field to use instead of process.pid
     */
    field: z.string(),
    /**
     * Whether to overwrite field with process.pid
     */
    overwrite: z.boolean().optional().default(true),
  }),
});

export type EndpointResponseAction = z.infer<typeof EndpointResponseAction>;
export const EndpointResponseAction = z.object({
  action_type_id: z.literal('.endpoint'),
  params: z.union([DefaultParams, ProcessesParams]),
});

export type ResponseAction = z.infer<typeof ResponseAction>;
export const ResponseAction = z.union([OsqueryResponseAction, EndpointResponseAction]);

/**
 * Risk score (0 to 100)
 */
export type RiskScore = z.infer<typeof RiskScore>;
export const RiskScore = z.number().int().min(0).max(100);

/**
 * Overrides generated alerts' risk_score with a value from the source event
 */
export type RiskScoreMapping = z.infer<typeof RiskScoreMapping>;
export const RiskScoreMapping = z.array(
  z.object({
    field: z.string(),
    operator: z.literal('equals'),
    risk_score: RiskScore.optional(),
    value: z.string(),
  })
);

/**
 * Sets the source field for the alert's signal.rule.name value
 */
export type RuleNameOverride = z.infer<typeof RuleNameOverride>;
export const RuleNameOverride = z.string();

export type SetupGuide = z.infer<typeof SetupGuide>;
export const SetupGuide = z.string();

/**
 * Severity of the rule
 */
export type Severity = z.infer<typeof Severity>;
export const Severity = z.enum(['low', 'medium', 'high', 'critical']);
export type SeverityEnum = typeof Severity.enum;
export const SeverityEnum = Severity.enum;

/**
 * Overrides generated alerts' severity with values from the source event
 */
export type SeverityMapping = z.infer<typeof SeverityMapping>;
export const SeverityMapping = z.array(
  z.object({
    field: z.string(),
    operator: z.literal('equals'),
    severity: Severity,
    value: z.string(),
  })
);

export type ThreatTactic = z.infer<typeof ThreatTactic>;
export const ThreatTactic = z.object({
  /**
   * Tactic ID
   */
  id: z.string(),
  /**
   * Tactic name
   */
  name: z.string(),
  /**
   * Tactic reference
   */
  reference: z.string(),
});

export type ThreatSubtechnique = z.infer<typeof ThreatSubtechnique>;
export const ThreatSubtechnique = z.object({
  /**
   * Subtechnique ID
   */
  id: z.string(),
  /**
   * Subtechnique name
   */
  name: z.string(),
  /**
   * Subtechnique reference
   */
  reference: z.string(),
});

export type ThreatTechnique = z.infer<typeof ThreatTechnique>;
export const ThreatTechnique = z.object({
  /**
   * Technique ID
   */
  id: z.string(),
  /**
   * Technique name
   */
  name: z.string(),
  /**
   * Technique reference
   */
  reference: z.string(),
  /**
   * Array containing more specific information on the attack technique
   */
  subtechnique: z.array(ThreatSubtechnique).optional(),
});

export type Threat = z.infer<typeof Threat>;
export const Threat = z.object({
  /**
   * Relevant attack framework
   */
  framework: z.string(),
  tactic: ThreatTactic,
  /**
   * Array containing information on the attack techniques (optional)
   */
  technique: z.array(ThreatTechnique).optional(),
});

export type ThreatArray = z.infer<typeof ThreatArray>;
export const ThreatArray = z.array(Threat);

/**
 * Sets the time field used to query indices
 */
export type TimestampOverride = z.infer<typeof TimestampOverride>;
export const TimestampOverride = z.string();

/**
 * Disables the fallback to the event's @timestamp field
 */
export type TimestampOverrideFallbackDisabled = z.infer<typeof TimestampOverrideFallbackDisabled>;
export const TimestampOverrideFallbackDisabled = z.boolean();

export type RuleIntervalTo = z.infer<typeof RuleIntervalTo>;
export const RuleIntervalTo = z.string();

/**
 * The rule's version number.
 */
export type RuleVersion = z.infer<typeof RuleVersion>;
export const RuleVersion = z.number().int().min(1);

export type RuleExecutionMetrics = z.infer<typeof RuleExecutionMetrics>;
export const RuleExecutionMetrics = z.object({
  /**
   * Duration in seconds of execution gap
   */
  execution_gap_duration_s: z.number().int().min(0).optional(),
  /**
   * Range of the execution gap
   */
  gap_range: z
    .object({
      /**
       * Start date of the execution gap
       */
      gte: z.string(),
      /**
       * End date of the execution gap
       */
      lte: z.string(),
    })
    .optional(),
  /**
   * Total time spent enriching documents during current rule execution cycle
   */
  total_enrichment_duration_ms: z.number().int().min(0).optional(),
  /**
   * Total time spent indexing documents during current rule execution cycle
   */
  total_indexing_duration_ms: z.number().int().min(0).optional(),
  /**
   * Total time spent performing ES searches as measured by Kibana; includes network latency and time spent serializing/deserializing request/response
   */
  total_search_duration_ms: z.number().int().min(0).optional(),
});

/**
  * Custom execution status of Security rules that is different from the status used in the Alerting Framework. We merge our custom status with the Framework's status to determine the resulting status of a rule.
- going to run - @deprecated Replaced by the 'running' status but left for backwards compatibility with rule execution events already written to Event Log in the prior versions of Kibana. Don't use when writing rule status changes.
- running - Rule execution started but not reached any intermediate or final status.
- partial failure - Rule can partially fail for various reasons either in the middle of an execution (in this case we update its status right away) or in the end of it. So currently this status can be both intermediate and final at the same time. A typical reason for a partial failure: not all the indices that the rule searches over actually exist.
- failed - Rule failed to execute due to unhandled exception or a reason defined in the business logic of its executor function.
- succeeded - Rule executed successfully without any issues. Note: this status is just an indication of a rule's "health". The rule might or might not generate any alerts despite of it.
  */
export type RuleExecutionStatus = z.infer<typeof RuleExecutionStatus>;
export const RuleExecutionStatus = z.enum([
  'going to run',
  'running',
  'partial failure',
  'failed',
  'succeeded',
]);
export type RuleExecutionStatusEnum = typeof RuleExecutionStatus.enum;
export const RuleExecutionStatusEnum = RuleExecutionStatus.enum;

export type RuleExecutionStatusOrder = z.infer<typeof RuleExecutionStatusOrder>;
export const RuleExecutionStatusOrder = z.number().int();

export type RuleExecutionSummary = z.infer<typeof RuleExecutionSummary>;
export const RuleExecutionSummary = z.object({
  last_execution: z.object({
    /**
     * Date of the last execution
     */
    date: z.string().datetime(),
    message: z.string(),
    metrics: RuleExecutionMetrics,
    /**
     * Status of the last execution
     */
    status: RuleExecutionStatus,
    status_order: RuleExecutionStatusOrder,
  }),
});

/**
 * A universally unique identifier
 */
export type UUID = z.infer<typeof UUID>;
export const UUID = z.string().uuid();

export type RuleObjectId = z.infer<typeof RuleObjectId>;
export const RuleObjectId = UUID;

/**
 * This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
 * @deprecated
 */
export type IsRuleImmutable = z.infer<typeof IsRuleImmutable>;
export const IsRuleImmutable = z.boolean();

/**
  * Describes an Elasticsearch field that is needed for the rule to function.

Almost all types of Security rules check source event documents for a match to some kind of
query or filter. If a document has certain field with certain values, then it's a match and
the rule will generate an alert.

Required field is an event field that must be present in the source indices of a given rule.

@example
const standardEcsField: RequiredField = {
  name: 'event.action',
  type: 'keyword',
  ecs: true,
};

@example
const nonEcsField: RequiredField = {
  name: 'winlog.event_data.AttributeLDAPDisplayName',
  type: 'keyword',
  ecs: false,
};

  */
export type RequiredField = z.infer<typeof RequiredField>;
export const RequiredField = z.object({
  /**
   * Whether the field is an ECS field
   */
  ecs: z.boolean(),
  /**
   * Name of an Elasticsearch field
   */
  name: NonEmptyString,
  /**
   * Type of the Elasticsearch field
   */
  type: NonEmptyString,
});

export type RequiredFieldArray = z.infer<typeof RequiredFieldArray>;
export const RequiredFieldArray = z.array(RequiredField);

/**
 * Could be any string, not necessarily a UUID
 */
export type RuleSignatureId = z.infer<typeof RuleSignatureId>;
export const RuleSignatureId = z.string();

/**
 * Determines whether an external/prebuilt rule has been customized by the user (i.e. any of its fields have been modified and diverged from the base value).
 */
export type IsExternalRuleCustomized = z.infer<typeof IsExternalRuleCustomized>;
export const IsExternalRuleCustomized = z.boolean();

/**
 * Type of rule source for externally sourced rules, i.e. rules that have an external source, such as the Elastic Prebuilt rules repo.
 */
export type ExternalRuleSource = z.infer<typeof ExternalRuleSource>;
export const ExternalRuleSource = z.object({
  is_customized: IsExternalRuleCustomized,
  type: z.literal('external'),
});

/**
 * Type of rule source for internally sourced rules, i.e. created within the Kibana apps.
 */
export type InternalRuleSource = z.infer<typeof InternalRuleSource>;
export const InternalRuleSource = z.object({
  type: z.literal('internal'),
});

/**
 * Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
 */
export type RuleSource = z.infer<typeof RuleSource>;
export const RuleSource = z.discriminatedUnion('type', [ExternalRuleSource, InternalRuleSource]);

export type ResponseFields = z.infer<typeof ResponseFields>;
export const ResponseFields = z.object({
  created_at: z.string().datetime(),
  created_by: z.string(),
  execution_summary: RuleExecutionSummary.optional(),
  id: RuleObjectId,
  immutable: IsRuleImmutable,
  required_fields: RequiredFieldArray,
  revision: z.number().int().min(0),
  rule_id: RuleSignatureId,
  rule_source: RuleSource,
  updated_at: z.string().datetime(),
  updated_by: z.string(),
});

export type EqlQueryLanguage = z.infer<typeof EqlQueryLanguage>;
export const EqlQueryLanguage = z.literal('eql');

export type RuleQuery = z.infer<typeof RuleQuery>;
export const RuleQuery = z.string();

export type EqlRequiredFields = z.infer<typeof EqlRequiredFields>;
export const EqlRequiredFields = z.object({
  /**
   * Query language to use
   */
  language: EqlQueryLanguage,
  /**
   * EQL query to execute
   */
  query: RuleQuery,
  /**
   * Rule type
   */
  type: z.literal('eql'),
});

export type DataViewId = z.infer<typeof DataViewId>;
export const DataViewId = z.string();

export type EventCategoryOverride = z.infer<typeof EventCategoryOverride>;
export const EventCategoryOverride = z.string();

export type RuleFilterArray = z.infer<typeof RuleFilterArray>;
export const RuleFilterArray = z.array(z.unknown());

/**
 * Sets a secondary field for sorting events
 */
export type TiebreakerField = z.infer<typeof TiebreakerField>;
export const TiebreakerField = z.string();

/**
 * Contains the event timestamp used for sorting a sequence of events
 */
export type TimestampField = z.infer<typeof TimestampField>;
export const TimestampField = z.string();

export type EqlOptionalFields = z.infer<typeof EqlOptionalFields>;
export const EqlOptionalFields = z.object({
  alert_suppression: AlertSuppression.optional(),
  data_view_id: DataViewId.optional(),
  event_category_override: EventCategoryOverride.optional(),
  filters: RuleFilterArray.optional(),
  index: IndexPatternArray.optional(),
  tiebreaker_field: TiebreakerField.optional(),
  timestamp_field: TimestampField.optional(),
});

export type EqlRuleResponseFields = z.infer<typeof EqlRuleResponseFields>;
export const EqlRuleResponseFields = EqlRequiredFields.merge(EqlOptionalFields);

export type EqlRule = z.infer<typeof EqlRule>;
export const EqlRule = z
  .object({
    actions: z.array(RuleAction),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray,
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled,
    exceptions_list: z.array(RuleExceptionList),
    false_positives: RuleFalsePositiveArray,
    from: RuleIntervalFrom,
    interval: RuleInterval,
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals,
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray,
    related_integrations: RelatedIntegrationArray,
    required_fields: z.array(RequiredFieldInput),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping,
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide,
    severity: Severity,
    severity_mapping: SeverityMapping,
    tags: RuleTagArray,
    threat: ThreatArray,
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo,
    version: RuleVersion,
  })
  .merge(ResponseFields)
  .merge(EqlRuleResponseFields);

export type QueryRuleRequiredFields = z.infer<typeof QueryRuleRequiredFields>;
export const QueryRuleRequiredFields = z.object({
  /**
   * Rule type
   */
  type: z.literal('query'),
});

export type SavedQueryId = z.infer<typeof SavedQueryId>;
export const SavedQueryId = z.string();

export type QueryRuleOptionalFields = z.infer<typeof QueryRuleOptionalFields>;
export const QueryRuleOptionalFields = z.object({
  alert_suppression: AlertSuppression.optional(),
  data_view_id: DataViewId.optional(),
  filters: RuleFilterArray.optional(),
  index: IndexPatternArray.optional(),
  saved_id: SavedQueryId.optional(),
});

export type KqlQueryLanguage = z.infer<typeof KqlQueryLanguage>;
export const KqlQueryLanguage = z.enum(['kuery', 'lucene']);
export type KqlQueryLanguageEnum = typeof KqlQueryLanguage.enum;
export const KqlQueryLanguageEnum = KqlQueryLanguage.enum;

export type QueryRuleResponseFields = z.infer<typeof QueryRuleResponseFields>;
export const QueryRuleResponseFields = QueryRuleRequiredFields.merge(QueryRuleOptionalFields).merge(
  z.object({
    language: KqlQueryLanguage,
    query: RuleQuery,
  })
);

export type QueryRule = z.infer<typeof QueryRule>;
export const QueryRule = z
  .object({
    actions: z.array(RuleAction),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray,
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled,
    exceptions_list: z.array(RuleExceptionList),
    false_positives: RuleFalsePositiveArray,
    from: RuleIntervalFrom,
    interval: RuleInterval,
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals,
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray,
    related_integrations: RelatedIntegrationArray,
    required_fields: z.array(RequiredFieldInput),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping,
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide,
    severity: Severity,
    severity_mapping: SeverityMapping,
    tags: RuleTagArray,
    threat: ThreatArray,
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo,
    version: RuleVersion,
  })
  .merge(ResponseFields)
  .merge(QueryRuleResponseFields);

export type SavedQueryRuleRequiredFields = z.infer<typeof SavedQueryRuleRequiredFields>;
export const SavedQueryRuleRequiredFields = z.object({
  saved_id: SavedQueryId,
  /**
   * Rule type
   */
  type: z.literal('saved_query'),
});

export type SavedQueryRuleOptionalFields = z.infer<typeof SavedQueryRuleOptionalFields>;
export const SavedQueryRuleOptionalFields = z.object({
  alert_suppression: AlertSuppression.optional(),
  data_view_id: DataViewId.optional(),
  filters: RuleFilterArray.optional(),
  index: IndexPatternArray.optional(),
  query: RuleQuery.optional(),
});

export type SavedQueryRuleResponseFields = z.infer<typeof SavedQueryRuleResponseFields>;
export const SavedQueryRuleResponseFields = SavedQueryRuleRequiredFields.merge(
  SavedQueryRuleOptionalFields
).merge(
  z.object({
    language: KqlQueryLanguage,
  })
);

export type SavedQueryRule = z.infer<typeof SavedQueryRule>;
export const SavedQueryRule = z
  .object({
    actions: z.array(RuleAction),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray,
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled,
    exceptions_list: z.array(RuleExceptionList),
    false_positives: RuleFalsePositiveArray,
    from: RuleIntervalFrom,
    interval: RuleInterval,
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals,
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray,
    related_integrations: RelatedIntegrationArray,
    required_fields: z.array(RequiredFieldInput),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping,
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide,
    severity: Severity,
    severity_mapping: SeverityMapping,
    tags: RuleTagArray,
    threat: ThreatArray,
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo,
    version: RuleVersion,
  })
  .merge(ResponseFields)
  .merge(SavedQueryRuleResponseFields);

export type ThresholdCardinality = z.infer<typeof ThresholdCardinality>;
export const ThresholdCardinality = z.array(
  z.object({
    field: z.string(),
    value: z.number().int().min(0),
  })
);

/**
 * Field to aggregate on
 */
export type ThresholdField = z.infer<typeof ThresholdField>;
export const ThresholdField = z.union([z.string(), z.array(z.string())]);

/**
 * Threshold value
 */
export type ThresholdValue = z.infer<typeof ThresholdValue>;
export const ThresholdValue = z.number().int().min(1);

export type Threshold = z.infer<typeof Threshold>;
export const Threshold = z.object({
  cardinality: ThresholdCardinality.optional(),
  field: ThresholdField,
  value: ThresholdValue,
});

export type ThresholdRuleRequiredFields = z.infer<typeof ThresholdRuleRequiredFields>;
export const ThresholdRuleRequiredFields = z.object({
  query: RuleQuery,
  threshold: Threshold,
  /**
   * Rule type
   */
  type: z.literal('threshold'),
});

export type ThresholdAlertSuppression = z.infer<typeof ThresholdAlertSuppression>;
export const ThresholdAlertSuppression = z.object({
  duration: AlertSuppressionDuration,
});

export type ThresholdRuleOptionalFields = z.infer<typeof ThresholdRuleOptionalFields>;
export const ThresholdRuleOptionalFields = z.object({
  alert_suppression: ThresholdAlertSuppression.optional(),
  data_view_id: DataViewId.optional(),
  filters: RuleFilterArray.optional(),
  index: IndexPatternArray.optional(),
  saved_id: SavedQueryId.optional(),
});

export type ThresholdRuleResponseFields = z.infer<typeof ThresholdRuleResponseFields>;
export const ThresholdRuleResponseFields = ThresholdRuleRequiredFields.merge(
  ThresholdRuleOptionalFields
).merge(
  z.object({
    language: KqlQueryLanguage,
  })
);

export type ThresholdRule = z.infer<typeof ThresholdRule>;
export const ThresholdRule = z
  .object({
    actions: z.array(RuleAction),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray,
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled,
    exceptions_list: z.array(RuleExceptionList),
    false_positives: RuleFalsePositiveArray,
    from: RuleIntervalFrom,
    interval: RuleInterval,
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals,
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray,
    related_integrations: RelatedIntegrationArray,
    required_fields: z.array(RequiredFieldInput),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping,
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide,
    severity: Severity,
    severity_mapping: SeverityMapping,
    tags: RuleTagArray,
    threat: ThreatArray,
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo,
    version: RuleVersion,
  })
  .merge(ResponseFields)
  .merge(ThresholdRuleResponseFields);

export type ThreatIndex = z.infer<typeof ThreatIndex>;
export const ThreatIndex = z.array(z.string());

export type ThreatMapping = z.infer<typeof ThreatMapping>;
export const ThreatMapping = z
  .array(
    z.object({
      entries: z.array(
        z.object({
          field: NonEmptyString,
          type: z.literal('mapping'),
          value: NonEmptyString,
        })
      ),
    })
  )
  .min(1);

/**
 * Query to run
 */
export type ThreatQuery = z.infer<typeof ThreatQuery>;
export const ThreatQuery = z.string();

export type ThreatMatchRuleRequiredFields = z.infer<typeof ThreatMatchRuleRequiredFields>;
export const ThreatMatchRuleRequiredFields = z.object({
  query: RuleQuery,
  threat_index: ThreatIndex,
  threat_mapping: ThreatMapping,
  threat_query: ThreatQuery,
  /**
   * Rule type
   */
  type: z.literal('threat_match'),
});

export type ConcurrentSearches = z.infer<typeof ConcurrentSearches>;
export const ConcurrentSearches = z.number().int().min(1);

export type ItemsPerSearch = z.infer<typeof ItemsPerSearch>;
export const ItemsPerSearch = z.number().int().min(1);

export type ThreatFilters = z.infer<typeof ThreatFilters>;
export const ThreatFilters = z.array(z.unknown());

/**
 * Defines the path to the threat indicator in the indicator documents (optional)
 */
export type ThreatIndicatorPath = z.infer<typeof ThreatIndicatorPath>;
export const ThreatIndicatorPath = z.string();

export type ThreatMatchRuleOptionalFields = z.infer<typeof ThreatMatchRuleOptionalFields>;
export const ThreatMatchRuleOptionalFields = z.object({
  alert_suppression: AlertSuppression.optional(),
  concurrent_searches: ConcurrentSearches.optional(),
  data_view_id: DataViewId.optional(),
  filters: RuleFilterArray.optional(),
  index: IndexPatternArray.optional(),
  items_per_search: ItemsPerSearch.optional(),
  saved_id: SavedQueryId.optional(),
  threat_filters: ThreatFilters.optional(),
  threat_indicator_path: ThreatIndicatorPath.optional(),
  threat_language: KqlQueryLanguage.optional(),
});

export type ThreatMatchRuleResponseFields = z.infer<typeof ThreatMatchRuleResponseFields>;
export const ThreatMatchRuleResponseFields = ThreatMatchRuleRequiredFields.merge(
  ThreatMatchRuleOptionalFields
).merge(
  z.object({
    language: KqlQueryLanguage,
  })
);

export type ThreatMatchRule = z.infer<typeof ThreatMatchRule>;
export const ThreatMatchRule = z
  .object({
    actions: z.array(RuleAction),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray,
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled,
    exceptions_list: z.array(RuleExceptionList),
    false_positives: RuleFalsePositiveArray,
    from: RuleIntervalFrom,
    interval: RuleInterval,
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals,
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray,
    related_integrations: RelatedIntegrationArray,
    required_fields: z.array(RequiredFieldInput),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping,
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide,
    severity: Severity,
    severity_mapping: SeverityMapping,
    tags: RuleTagArray,
    threat: ThreatArray,
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo,
    version: RuleVersion,
  })
  .merge(ResponseFields)
  .merge(ThreatMatchRuleResponseFields);

/**
 * Machine learning job ID
 */
export type MachineLearningJobId = z.infer<typeof MachineLearningJobId>;
export const MachineLearningJobId = z.union([z.string(), z.array(z.string()).min(1)]);

export type MachineLearningRuleRequiredFields = z.infer<typeof MachineLearningRuleRequiredFields>;
export const MachineLearningRuleRequiredFields = z.object({
  anomaly_threshold: AnomalyThreshold,
  machine_learning_job_id: MachineLearningJobId,
  /**
   * Rule type
   */
  type: z.literal('machine_learning'),
});

export type MachineLearningRuleOptionalFields = z.infer<typeof MachineLearningRuleOptionalFields>;
export const MachineLearningRuleOptionalFields = z.object({
  alert_suppression: AlertSuppression.optional(),
});

export type MachineLearningRuleResponseFields = z.infer<typeof MachineLearningRuleResponseFields>;
export const MachineLearningRuleResponseFields = MachineLearningRuleRequiredFields.merge(
  MachineLearningRuleOptionalFields
);

export type MachineLearningRule = z.infer<typeof MachineLearningRule>;
export const MachineLearningRule = z
  .object({
    actions: z.array(RuleAction),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray,
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled,
    exceptions_list: z.array(RuleExceptionList),
    false_positives: RuleFalsePositiveArray,
    from: RuleIntervalFrom,
    interval: RuleInterval,
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals,
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray,
    related_integrations: RelatedIntegrationArray,
    required_fields: z.array(RequiredFieldInput),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping,
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide,
    severity: Severity,
    severity_mapping: SeverityMapping,
    tags: RuleTagArray,
    threat: ThreatArray,
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo,
    version: RuleVersion,
  })
  .merge(ResponseFields)
  .merge(MachineLearningRuleResponseFields);

export type HistoryWindowStart = z.infer<typeof HistoryWindowStart>;
export const HistoryWindowStart = NonEmptyString;

export type NewTermsFields = z.infer<typeof NewTermsFields>;
export const NewTermsFields = z.array(z.string()).min(1).max(3);

export type NewTermsRuleRequiredFields = z.infer<typeof NewTermsRuleRequiredFields>;
export const NewTermsRuleRequiredFields = z.object({
  history_window_start: HistoryWindowStart,
  new_terms_fields: NewTermsFields,
  query: RuleQuery,
  /**
   * Rule type
   */
  type: z.literal('new_terms'),
});

export type NewTermsRuleOptionalFields = z.infer<typeof NewTermsRuleOptionalFields>;
export const NewTermsRuleOptionalFields = z.object({
  alert_suppression: AlertSuppression.optional(),
  data_view_id: DataViewId.optional(),
  filters: RuleFilterArray.optional(),
  index: IndexPatternArray.optional(),
});

export type NewTermsRuleResponseFields = z.infer<typeof NewTermsRuleResponseFields>;
export const NewTermsRuleResponseFields = NewTermsRuleRequiredFields.merge(
  NewTermsRuleOptionalFields
).merge(
  z.object({
    language: KqlQueryLanguage,
  })
);

export type NewTermsRule = z.infer<typeof NewTermsRule>;
export const NewTermsRule = z
  .object({
    actions: z.array(RuleAction),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray,
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled,
    exceptions_list: z.array(RuleExceptionList),
    false_positives: RuleFalsePositiveArray,
    from: RuleIntervalFrom,
    interval: RuleInterval,
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals,
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray,
    related_integrations: RelatedIntegrationArray,
    required_fields: z.array(RequiredFieldInput),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping,
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide,
    severity: Severity,
    severity_mapping: SeverityMapping,
    tags: RuleTagArray,
    threat: ThreatArray,
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo,
    version: RuleVersion,
  })
  .merge(ResponseFields)
  .merge(NewTermsRuleResponseFields);

export type EsqlRuleOptionalFields = z.infer<typeof EsqlRuleOptionalFields>;
export const EsqlRuleOptionalFields = z.object({
  alert_suppression: AlertSuppression.optional(),
});

export type EsqlQueryLanguage = z.infer<typeof EsqlQueryLanguage>;
export const EsqlQueryLanguage = z.literal('esql');

export type EsqlRuleRequiredFields = z.infer<typeof EsqlRuleRequiredFields>;
export const EsqlRuleRequiredFields = z.object({
  language: EsqlQueryLanguage,
  /**
   * ESQL query to execute
   */
  query: RuleQuery,
  /**
   * Rule type
   */
  type: z.literal('esql'),
});

export type EsqlRuleResponseFields = z.infer<typeof EsqlRuleResponseFields>;
export const EsqlRuleResponseFields = EsqlRuleOptionalFields.merge(EsqlRuleRequiredFields);

export type EsqlRule = z.infer<typeof EsqlRule>;
export const EsqlRule = z
  .object({
    actions: z.array(RuleAction),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray,
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled,
    exceptions_list: z.array(RuleExceptionList),
    false_positives: RuleFalsePositiveArray,
    from: RuleIntervalFrom,
    interval: RuleInterval,
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals,
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray,
    related_integrations: RelatedIntegrationArray,
    required_fields: z.array(RequiredFieldInput),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping,
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide,
    severity: Severity,
    severity_mapping: SeverityMapping,
    tags: RuleTagArray,
    threat: ThreatArray,
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo,
    version: RuleVersion,
  })
  .merge(ResponseFields)
  .merge(EsqlRuleResponseFields);

export const RuleResponseInternal = z.discriminatedUnion('type', [
  EqlRule,
  QueryRule,
  SavedQueryRule,
  ThresholdRule,
  ThreatMatchRule,
  MachineLearningRule,
  NewTermsRule,
  EsqlRule,
]);

export type RuleResponse = z.infer<typeof RuleResponseInternal>;
export const RuleResponse = RuleResponseInternal as z.ZodType<RuleResponse>;

export type ErrorSchema = z.infer<typeof ErrorSchema>;
export const ErrorSchema = z
  .object({
    error: z.object({
      message: z.string(),
      status_code: z.number().int().min(400),
    }),
    id: z.string().optional(),
    item_id: z.string().min(1).optional(),
    list_id: z.string().min(1).optional(),
    rule_id: RuleSignatureId.optional(),
  })
  .strict();

export type BulkCrudRulesResponse = z.infer<typeof BulkCrudRulesResponse>;
export const BulkCrudRulesResponse = z.array(z.union([RuleResponse, ErrorSchema]));

export type BulkDeleteRules = z.infer<typeof BulkDeleteRules>;
export const BulkDeleteRules = z.object({
  action: z.literal('delete'),
  /**
   * Array of rule IDs
   */
  ids: z.array(z.string()).min(1).optional(),
  /**
   * Query to filter rules
   */
  query: z.string().optional(),
});

export type BulkDisableRules = z.infer<typeof BulkDisableRules>;
export const BulkDisableRules = z.object({
  action: z.literal('disable'),
  /**
   * Array of rule IDs
   */
  ids: z.array(z.string()).min(1).optional(),
  /**
   * Query to filter rules
   */
  query: z.string().optional(),
});

export type BulkDuplicateRules = z.infer<typeof BulkDuplicateRules>;
export const BulkDuplicateRules = z.object({
  action: z.literal('duplicate'),
  duplicate: z
    .object({
      /**
       * Whether to copy exceptions from the original rule
       */
      include_exceptions: z.boolean(),
      /**
       * Whether to copy expired exceptions from the original rule
       */
      include_expired_exceptions: z.boolean(),
    })
    .optional(),
  /**
   * Array of rule IDs
   */
  ids: z.array(z.string()).min(1).optional(),
  /**
   * Query to filter rules
   */
  query: z.string().optional(),
});

export type RuleDetailsInError = z.infer<typeof RuleDetailsInError>;
export const RuleDetailsInError = z.object({
  id: z.string(),
  name: z.string().optional(),
});

export type NormalizedRuleError = z.infer<typeof NormalizedRuleError>;
export const NormalizedRuleError = z.object({
  err_code: BulkActionsDryRunErrCode.optional(),
  message: z.string(),
  rules: z.array(RuleDetailsInError),
  status_code: z.number().int(),
});

export type BulkEditActionResults = z.infer<typeof BulkEditActionResults>;
export const BulkEditActionResults = z.object({
  created: z.array(RuleResponse),
  deleted: z.array(RuleResponse),
  skipped: z.array(BulkActionSkipResult),
  updated: z.array(RuleResponse),
});

export type BulkEditActionSummary = z.infer<typeof BulkEditActionSummary>;
export const BulkEditActionSummary = z.object({
  failed: z.number().int(),
  skipped: z.number().int(),
  succeeded: z.number().int(),
  total: z.number().int(),
});

export type BulkEditActionResponse = z.infer<typeof BulkEditActionResponse>;
export const BulkEditActionResponse = z.object({
  attributes: z.object({
    errors: z.array(NormalizedRuleError).optional(),
    results: BulkEditActionResults,
    summary: BulkEditActionSummary,
  }),
  message: z.string().optional(),
  rules_count: z.number().int().optional(),
  status_code: z.number().int().optional(),
  success: z.boolean().optional(),
});

export type BulkEditRules = z.infer<typeof BulkEditRules>;
export const BulkEditRules = z.object({
  action: z.literal('edit'),
  /**
   * Array of objects containing the edit operations
   */
  edit: z.array(BulkActionEditPayload).min(1),
  /**
   * Array of rule IDs
   */
  ids: z.array(z.string()).min(1).optional(),
  /**
   * Query to filter rules
   */
  query: z.string().optional(),
});

export type BulkEnableRules = z.infer<typeof BulkEnableRules>;
export const BulkEnableRules = z.object({
  action: z.literal('enable'),
  /**
   * Array of rule IDs
   */
  ids: z.array(z.string()).min(1).optional(),
  /**
   * Query to filter rules
   */
  query: z.string().optional(),
});

export type BulkExportActionResponse = z.infer<typeof BulkExportActionResponse>;
export const BulkExportActionResponse = z.string();

export type BulkExportRules = z.infer<typeof BulkExportRules>;
export const BulkExportRules = z.object({
  action: z.literal('export'),
  /**
   * Array of rule IDs
   */
  ids: z.array(z.string()).min(1).optional(),
  /**
   * Query to filter rules
   */
  query: z.string().optional(),
});

export type BulkManualRuleRun = z.infer<typeof BulkManualRuleRun>;
export const BulkManualRuleRun = z.object({
  action: z.literal('run'),
  /**
   * Array of rule IDs
   */
  ids: z.array(z.string()).min(1).optional(),
  /**
   * Query to filter rules
   */
  query: z.string().optional(),
  run: z.object({
    /**
     * End date of the manual rule run
     */
    end_date: z.string().optional(),
    /**
     * Start date of the manual rule run
     */
    start_date: z.string(),
  }),
});

export type EqlRuleCreateFields = z.infer<typeof EqlRuleCreateFields>;
export const EqlRuleCreateFields = EqlRequiredFields.merge(EqlOptionalFields);

export type EqlRuleCreateProps = z.infer<typeof EqlRuleCreateProps>;
export const EqlRuleCreateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(EqlRuleCreateFields);

export type EqlRulePatchFields = z.infer<typeof EqlRulePatchFields>;
export const EqlRulePatchFields = z
  .object({
    /**
     * Query language to use
     */
    language: EqlQueryLanguage.optional(),
    /**
     * EQL query to execute
     */
    query: RuleQuery.optional(),
    /**
     * Rule type
     */
    type: z.literal('eql').optional(),
  })
  .merge(EqlOptionalFields);

export type EqlRulePatchProps = z.infer<typeof EqlRulePatchProps>;
export const EqlRulePatchProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription.optional(),
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName.optional(),
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore.optional(),
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity.optional(),
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(EqlRulePatchFields);

export type EqlRuleUpdateProps = z.infer<typeof EqlRuleUpdateProps>;
export const EqlRuleUpdateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(EqlRuleCreateFields);

export type EsqlRuleCreateFields = z.infer<typeof EsqlRuleCreateFields>;
export const EsqlRuleCreateFields = EsqlRuleOptionalFields.merge(EsqlRuleRequiredFields);

export type EsqlRuleCreateProps = z.infer<typeof EsqlRuleCreateProps>;
export const EsqlRuleCreateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(EsqlRuleCreateFields);

export type EsqlRulePatchProps = z.infer<typeof EsqlRulePatchProps>;
export const EsqlRulePatchProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription.optional(),
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    language: EsqlQueryLanguage.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName.optional(),
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    /**
     * ESQL query to execute
     */
    query: RuleQuery.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore.optional(),
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity.optional(),
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    /**
     * Rule type
     */
    type: z.literal('esql').optional(),
    version: RuleVersion.optional(),
  })
  .merge(EsqlRuleOptionalFields);

export type EsqlRuleUpdateProps = z.infer<typeof EsqlRuleUpdateProps>;
export const EsqlRuleUpdateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(EsqlRuleCreateFields);

export type FindRulesSortField = z.infer<typeof FindRulesSortField>;
export const FindRulesSortField = z.enum([
  'created_at',
  'createdAt',
  'enabled',
  'execution_summary.last_execution.date',
  'execution_summary.last_execution.metrics.execution_gap_duration_s',
  'execution_summary.last_execution.metrics.total_indexing_duration_ms',
  'execution_summary.last_execution.metrics.total_search_duration_ms',
  'execution_summary.last_execution.status',
  'name',
  'risk_score',
  'riskScore',
  'severity',
  'updated_at',
  'updatedAt',
]);
export type FindRulesSortFieldEnum = typeof FindRulesSortField.enum;
export const FindRulesSortFieldEnum = FindRulesSortField.enum;

export type MigrationStatus = z.infer<typeof MigrationStatus>;
export const MigrationStatus = z.object({
  id: NonEmptyString,
  status: z.enum(['success', 'failure', 'pending']),
  updated: z.string().datetime(),
  version: z.number().int(),
});

export type IndexMigrationStatus = z.infer<typeof IndexMigrationStatus>;
export const IndexMigrationStatus = z.object({
  index: NonEmptyString,
  is_outdated: z.boolean(),
  migrations: z.array(MigrationStatus),
  signal_versions: z.array(AlertVersion),
  version: z.number().int(),
});

export type MachineLearningRuleCreateFields = z.infer<typeof MachineLearningRuleCreateFields>;
export const MachineLearningRuleCreateFields = MachineLearningRuleRequiredFields.merge(
  MachineLearningRuleOptionalFields
);

export type MachineLearningRuleCreateProps = z.infer<typeof MachineLearningRuleCreateProps>;
export const MachineLearningRuleCreateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(MachineLearningRuleCreateFields);

export type MachineLearningRulePatchFields = z.infer<typeof MachineLearningRulePatchFields>;
export const MachineLearningRulePatchFields = z
  .object({
    anomaly_threshold: AnomalyThreshold.optional(),
    machine_learning_job_id: MachineLearningJobId.optional(),
    /**
     * Rule type
     */
    type: z.literal('machine_learning').optional(),
  })
  .merge(MachineLearningRuleOptionalFields);

export type MachineLearningRulePatchProps = z.infer<typeof MachineLearningRulePatchProps>;
export const MachineLearningRulePatchProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription.optional(),
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName.optional(),
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore.optional(),
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity.optional(),
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(MachineLearningRulePatchFields);

export type MachineLearningRuleUpdateProps = z.infer<typeof MachineLearningRuleUpdateProps>;
export const MachineLearningRuleUpdateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(MachineLearningRuleCreateFields);

export type MigrationCleanupResult = z.infer<typeof MigrationCleanupResult>;
export const MigrationCleanupResult = z.object({
  destinationIndex: z.string(),
  error: z
    .object({
      message: z.string(),
      status_code: z.number().int(),
    })
    .optional(),
  id: z.string(),
  sourceIndex: z.string(),
  status: z.enum(['success', 'failure', 'pending']),
  updated: z.string().datetime(),
  version: z.string(),
});

export type MigrationFinalizationResult = z.infer<typeof MigrationFinalizationResult>;
export const MigrationFinalizationResult = z.object({
  completed: z.boolean(),
  destinationIndex: z.string(),
  error: z
    .object({
      message: z.string(),
      status_code: z.number().int(),
    })
    .optional(),
  id: z.string(),
  sourceIndex: z.string(),
  status: z.enum(['success', 'failure', 'pending']),
  updated: z.string().datetime(),
  version: z.string(),
});

export type NewTermsRuleDefaultableFields = z.infer<typeof NewTermsRuleDefaultableFields>;
export const NewTermsRuleDefaultableFields = z.object({
  language: KqlQueryLanguage.optional(),
});

export type NewTermsRuleCreateFields = z.infer<typeof NewTermsRuleCreateFields>;
export const NewTermsRuleCreateFields = NewTermsRuleRequiredFields.merge(
  NewTermsRuleOptionalFields
).merge(NewTermsRuleDefaultableFields);

export type NewTermsRuleCreateProps = z.infer<typeof NewTermsRuleCreateProps>;
export const NewTermsRuleCreateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(NewTermsRuleCreateFields);

export type NewTermsRulePatchFields = z.infer<typeof NewTermsRulePatchFields>;
export const NewTermsRulePatchFields = z
  .object({
    history_window_start: HistoryWindowStart.optional(),
    new_terms_fields: NewTermsFields.optional(),
    query: RuleQuery.optional(),
    /**
     * Rule type
     */
    type: z.literal('new_terms').optional(),
  })
  .merge(NewTermsRuleOptionalFields)
  .merge(NewTermsRuleDefaultableFields);

export type NewTermsRulePatchProps = z.infer<typeof NewTermsRulePatchProps>;
export const NewTermsRulePatchProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription.optional(),
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName.optional(),
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore.optional(),
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity.optional(),
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(NewTermsRulePatchFields);

export type NewTermsRuleUpdateProps = z.infer<typeof NewTermsRuleUpdateProps>;
export const NewTermsRuleUpdateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(NewTermsRuleCreateFields);

export type PlatformErrorResponse = z.infer<typeof PlatformErrorResponse>;
export const PlatformErrorResponse = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.number().int(),
});

export type QueryRuleDefaultableFields = z.infer<typeof QueryRuleDefaultableFields>;
export const QueryRuleDefaultableFields = z.object({
  language: KqlQueryLanguage.optional(),
  query: RuleQuery.optional(),
});

export type QueryRuleCreateFields = z.infer<typeof QueryRuleCreateFields>;
export const QueryRuleCreateFields = QueryRuleRequiredFields.merge(QueryRuleOptionalFields).merge(
  QueryRuleDefaultableFields
);

export type QueryRuleCreateProps = z.infer<typeof QueryRuleCreateProps>;
export const QueryRuleCreateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(QueryRuleCreateFields);

export type QueryRulePatchFields = z.infer<typeof QueryRulePatchFields>;
export const QueryRulePatchFields = z
  .object({
    /**
     * Rule type
     */
    type: z.literal('query').optional(),
  })
  .merge(QueryRuleOptionalFields)
  .merge(QueryRuleDefaultableFields);

export type QueryRulePatchProps = z.infer<typeof QueryRulePatchProps>;
export const QueryRulePatchProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription.optional(),
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName.optional(),
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore.optional(),
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity.optional(),
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(QueryRulePatchFields);

export type QueryRuleUpdateProps = z.infer<typeof QueryRuleUpdateProps>;
export const QueryRuleUpdateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(QueryRuleCreateFields);

export type SavedQueryRuleDefaultableFields = z.infer<typeof SavedQueryRuleDefaultableFields>;
export const SavedQueryRuleDefaultableFields = z.object({
  language: KqlQueryLanguage.optional(),
});

export type SavedQueryRuleCreateFields = z.infer<typeof SavedQueryRuleCreateFields>;
export const SavedQueryRuleCreateFields = SavedQueryRuleRequiredFields.merge(
  SavedQueryRuleOptionalFields
).merge(SavedQueryRuleDefaultableFields);

export type SavedQueryRuleCreateProps = z.infer<typeof SavedQueryRuleCreateProps>;
export const SavedQueryRuleCreateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(SavedQueryRuleCreateFields);

export type ThresholdRuleDefaultableFields = z.infer<typeof ThresholdRuleDefaultableFields>;
export const ThresholdRuleDefaultableFields = z.object({
  language: KqlQueryLanguage.optional(),
});

export type ThresholdRuleCreateFields = z.infer<typeof ThresholdRuleCreateFields>;
export const ThresholdRuleCreateFields = ThresholdRuleRequiredFields.merge(
  ThresholdRuleOptionalFields
).merge(ThresholdRuleDefaultableFields);

export type ThresholdRuleCreateProps = z.infer<typeof ThresholdRuleCreateProps>;
export const ThresholdRuleCreateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(ThresholdRuleCreateFields);

export type ThreatMatchRuleDefaultableFields = z.infer<typeof ThreatMatchRuleDefaultableFields>;
export const ThreatMatchRuleDefaultableFields = z.object({
  language: KqlQueryLanguage.optional(),
});

export type ThreatMatchRuleCreateFields = z.infer<typeof ThreatMatchRuleCreateFields>;
export const ThreatMatchRuleCreateFields = ThreatMatchRuleRequiredFields.merge(
  ThreatMatchRuleOptionalFields
).merge(ThreatMatchRuleDefaultableFields);

export type ThreatMatchRuleCreateProps = z.infer<typeof ThreatMatchRuleCreateProps>;
export const ThreatMatchRuleCreateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(ThreatMatchRuleCreateFields);

export const RuleCreatePropsInternal = z.discriminatedUnion('type', [
  EqlRuleCreateProps,
  QueryRuleCreateProps,
  SavedQueryRuleCreateProps,
  ThresholdRuleCreateProps,
  ThreatMatchRuleCreateProps,
  MachineLearningRuleCreateProps,
  NewTermsRuleCreateProps,
  EsqlRuleCreateProps,
]);

export type RuleCreateProps = z.infer<typeof RuleCreatePropsInternal>;
export const RuleCreateProps = RuleCreatePropsInternal as z.ZodType<RuleCreateProps>;

export type SavedQueryRulePatchFields = z.infer<typeof SavedQueryRulePatchFields>;
export const SavedQueryRulePatchFields = z
  .object({
    saved_id: SavedQueryId.optional(),
    /**
     * Rule type
     */
    type: z.literal('saved_query').optional(),
  })
  .merge(SavedQueryRuleOptionalFields)
  .merge(SavedQueryRuleDefaultableFields);

export type SavedQueryRulePatchProps = z.infer<typeof SavedQueryRulePatchProps>;
export const SavedQueryRulePatchProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription.optional(),
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName.optional(),
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore.optional(),
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity.optional(),
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(SavedQueryRulePatchFields);

export type ThresholdRulePatchFields = z.infer<typeof ThresholdRulePatchFields>;
export const ThresholdRulePatchFields = z
  .object({
    query: RuleQuery.optional(),
    threshold: Threshold.optional(),
    /**
     * Rule type
     */
    type: z.literal('threshold').optional(),
  })
  .merge(ThresholdRuleOptionalFields)
  .merge(ThresholdRuleDefaultableFields);

export type ThresholdRulePatchProps = z.infer<typeof ThresholdRulePatchProps>;
export const ThresholdRulePatchProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription.optional(),
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName.optional(),
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore.optional(),
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity.optional(),
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(ThresholdRulePatchFields);

export type ThreatMatchRulePatchFields = z.infer<typeof ThreatMatchRulePatchFields>;
export const ThreatMatchRulePatchFields = z
  .object({
    query: RuleQuery.optional(),
    threat_index: ThreatIndex.optional(),
    threat_mapping: ThreatMapping.optional(),
    threat_query: ThreatQuery.optional(),
    /**
     * Rule type
     */
    type: z.literal('threat_match').optional(),
  })
  .merge(ThreatMatchRuleOptionalFields)
  .merge(ThreatMatchRuleDefaultableFields);

export type ThreatMatchRulePatchProps = z.infer<typeof ThreatMatchRulePatchProps>;
export const ThreatMatchRulePatchProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription.optional(),
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName.optional(),
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore.optional(),
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity.optional(),
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(ThreatMatchRulePatchFields);

export const RulePatchPropsInternal = z.union([
  EqlRulePatchProps,
  QueryRulePatchProps,
  SavedQueryRulePatchProps,
  ThresholdRulePatchProps,
  ThreatMatchRulePatchProps,
  MachineLearningRulePatchProps,
  NewTermsRulePatchProps,
  EsqlRulePatchProps,
]);

export type RulePatchProps = z.infer<typeof RulePatchPropsInternal>;
export const RulePatchProps = RulePatchPropsInternal as z.ZodType<RulePatchProps>;

export type RulePreviewLoggedRequest = z.infer<typeof RulePreviewLoggedRequest>;
export const RulePreviewLoggedRequest = z.object({
  description: NonEmptyString.optional(),
  duration: z.number().int().optional(),
  request: NonEmptyString.optional(),
  request_type: NonEmptyString.optional(),
});

export type RulePreviewLogs = z.infer<typeof RulePreviewLogs>;
export const RulePreviewLogs = z.object({
  /**
   * Execution duration in milliseconds
   */
  duration: z.number().int(),
  errors: z.array(NonEmptyString),
  requests: z.array(RulePreviewLoggedRequest).optional(),
  startedAt: NonEmptyString.optional(),
  warnings: z.array(NonEmptyString),
});

export type RulePreviewParams = z.infer<typeof RulePreviewParams>;
export const RulePreviewParams = z.object({
  invocationCount: z.number().int(),
  timeframeEnd: z.string().datetime(),
});

export type SavedQueryRuleUpdateProps = z.infer<typeof SavedQueryRuleUpdateProps>;
export const SavedQueryRuleUpdateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(SavedQueryRuleCreateFields);

export type ThresholdRuleUpdateProps = z.infer<typeof ThresholdRuleUpdateProps>;
export const ThresholdRuleUpdateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(ThresholdRuleCreateFields);

export type ThreatMatchRuleUpdateProps = z.infer<typeof ThreatMatchRuleUpdateProps>;
export const ThreatMatchRuleUpdateProps = z
  .object({
    actions: z.array(RuleAction).optional(),
    alias_purpose: SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: SavedObjectResolveAliasTargetId.optional(),
    author: RuleAuthorArray.optional(),
    building_block_type: BuildingBlockType.optional(),
    description: RuleDescription,
    enabled: IsRuleEnabled.optional(),
    exceptions_list: z.array(RuleExceptionList).optional(),
    false_positives: RuleFalsePositiveArray.optional(),
    from: RuleIntervalFrom.optional(),
    id: RuleObjectId.optional(),
    interval: RuleInterval.optional(),
    investigation_fields: InvestigationFields.optional(),
    license: RuleLicense.optional(),
    max_signals: MaxSignals.optional(),
    meta: RuleMetadata.optional(),
    name: RuleName,
    namespace: AlertsIndexNamespace.optional(),
    note: InvestigationGuide.optional(),
    outcome: SavedObjectResolveOutcome.optional(),
    output_index: AlertsIndex.optional(),
    references: RuleReferenceArray.optional(),
    related_integrations: RelatedIntegrationArray.optional(),
    required_fields: z.array(RequiredFieldInput).optional(),
    response_actions: z.array(ResponseAction).optional(),
    risk_score: RiskScore,
    risk_score_mapping: RiskScoreMapping.optional(),
    rule_id: RuleSignatureId.optional(),
    rule_name_override: RuleNameOverride.optional(),
    setup: SetupGuide.optional(),
    severity: Severity,
    severity_mapping: SeverityMapping.optional(),
    tags: RuleTagArray.optional(),
    threat: ThreatArray.optional(),
    throttle: RuleActionThrottle.optional(),
    timeline_id: TimelineTemplateId.optional(),
    timeline_title: TimelineTemplateTitle.optional(),
    timestamp_override: TimestampOverride.optional(),
    timestamp_override_fallback_disabled: TimestampOverrideFallbackDisabled.optional(),
    to: RuleIntervalTo.optional(),
    version: RuleVersion.optional(),
  })
  .merge(ThreatMatchRuleCreateFields);

export const RuleUpdatePropsInternal = z.discriminatedUnion('type', [
  EqlRuleUpdateProps,
  QueryRuleUpdateProps,
  SavedQueryRuleUpdateProps,
  ThresholdRuleUpdateProps,
  ThreatMatchRuleUpdateProps,
  MachineLearningRuleUpdateProps,
  NewTermsRuleUpdateProps,
  EsqlRuleUpdateProps,
]);

export type RuleUpdateProps = z.infer<typeof RuleUpdatePropsInternal>;
export const RuleUpdateProps = RuleUpdatePropsInternal as z.ZodType<RuleUpdateProps>;

export type SetAlertsStatusByIds = z.infer<typeof SetAlertsStatusByIds>;
export const SetAlertsStatusByIds = z.object({
  /**
   * List of alert `id`s.
   */
  signal_ids: z.array(z.string().min(1).superRefine(isNonEmptyString)).min(1),
  status: AlertStatus,
});

export type SetAlertsStatusByQuery = z.infer<typeof SetAlertsStatusByQuery>;
export const SetAlertsStatusByQuery = z.object({
  conflicts: z.enum(['abort', 'proceed']).optional().default('abort'),
  query: z.object({}).catchall(z.unknown()),
  status: AlertStatus,
});

/**
 * Object with list of tags to add and remove.
 */
export type SetAlertTags = z.infer<typeof SetAlertTags>;
export const SetAlertTags = z.object({
  tags_to_add: AlertTags,
  tags_to_remove: AlertTags,
});

export type SiemErrorResponse = z.infer<typeof SiemErrorResponse>;
export const SiemErrorResponse = z.object({
  message: z.string(),
  status_code: z.number().int(),
});

export type SkippedAlertsIndexMigration = z.infer<typeof SkippedAlertsIndexMigration>;
export const SkippedAlertsIndexMigration = z.object({
  index: z.string(),
});

export type SortOrder = z.infer<typeof SortOrder>;
export const SortOrder = z.enum(['asc', 'desc']);
export type SortOrderEnum = typeof SortOrder.enum;
export const SortOrderEnum = SortOrder.enum;

export type WarningSchema = z.infer<typeof WarningSchema>;
export const WarningSchema = z.object({
  actionPath: z.string(),
  buttonLabel: z.string().optional(),
  message: z.string(),
  type: z.string(),
});
