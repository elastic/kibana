/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { useCallback, useRef } from 'react';
import { useKibana } from '../../../../common/lib/kibana';
import type { MalwareAnalysisResult } from './use_malware_re_analysis';

const MALWARE_ANALYSIS_CACHE_ROUTE = '/api/security_solution/malware_analysis/cache';

interface SaveCacheParams {
  alertId: string;
  result: MalwareAnalysisResult;
}

interface UseSaveMalwareAnalysisCacheResult {
  /**
   * Save or update a malware analysis result to the cache
   */
  saveToCache: (params: SaveCacheParams) => Promise<void>;
  /**
   * Whether a save operation is in progress
   */
  isSaving: boolean;
}

/**
 * Hook to save malware analysis results to the server-side cache.
 * This persists results as saved objects so they survive across sessions
 * and don't need to be regenerated.
 */
export const useSaveMalwareAnalysisCache = (): UseSaveMalwareAnalysisCacheResult => {
  const { http } = useKibana().services;
  const isSavingRef = useRef(false);

  const saveToCache = useCallback(
    async ({ alertId, result }: SaveCacheParams) => {
      isSavingRef.current = true;

      try {
        await http.post(MALWARE_ANALYSIS_CACHE_ROUTE, {
          version: '1',
          body: JSON.stringify({
            alert_id: alertId,
            sha256: result.sha256,
            task_id: result.taskId,
            status: result.status,
            analysis: result.analysis,
            error: result.error,
            stats: result.stats
              ? {
                  cost_usd: result.stats.costUsd,
                  input_tokens: result.stats.inputTokens,
                  output_tokens: result.stats.outputTokens,
                }
              : undefined,
          }),
        });
      } catch {
        // Cache save failures are non-critical; silently ignore
      } finally {
        isSavingRef.current = false;
      }
    },
    [http]
  );

  return {
    saveToCache,
    isSaving: isSavingRef.current,
  };
};
