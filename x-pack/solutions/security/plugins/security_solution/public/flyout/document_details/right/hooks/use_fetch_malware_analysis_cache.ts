/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { useQuery, useQueryClient } from '@kbn/react-query';
import { useCallback, useMemo } from 'react';
import { useKibana } from '../../../../common/lib/kibana';
import type { MalwareAnalysisResult } from './use_malware_re_analysis';

const MALWARE_ANALYSIS_CACHE_ROUTE = '/api/security_solution/malware_analysis/cache';

interface CachedMalwareAnalysisResponse {
  found: boolean;
  id?: string;
  alert_id?: string;
  sha256?: string;
  task_id?: string;
  status?: string;
  analysis?: string;
  error?: string;
  stats?: {
    cost_usd?: number;
    input_tokens?: number;
    output_tokens?: number;
  };
  created_at?: string;
  updated_at?: string;
}

interface UseFetchMalwareAnalysisCacheResult {
  /**
   * The cached analysis result, or undefined if not found
   */
  cachedResult: MalwareAnalysisResult | undefined;
  /**
   * Whether the cache is still loading
   */
  isLoading: boolean;
  /**
   * Whether the cache fetch has completed
   */
  isFetched: boolean;
  /**
   * Whether a cached result was found
   */
  hasCachedResult: boolean;
  /**
   * Refetch the cached result (e.g., after saving a new one)
   */
  refetch: () => void;
  /**
   * Invalidate the cache to trigger a refetch
   */
  invalidateCache: () => void;
}

/**
 * Hook to fetch a cached malware analysis result for a specific alert.
 * This allows displaying previously generated analysis results immediately
 * without requiring the user to re-run the analysis each time.
 */
export const useFetchMalwareAnalysisCache = (
  alertId: string
): UseFetchMalwareAnalysisCacheResult => {
  const { http } = useKibana().services;
  const queryClient = useQueryClient();

  const cacheKey = useMemo(() => [MALWARE_ANALYSIS_CACHE_ROUTE, alertId], [alertId]);

  const { data, isLoading, isFetched, refetch } = useQuery<
    CachedMalwareAnalysisResponse,
    unknown,
    CachedMalwareAnalysisResponse
  >(
    cacheKey,
    async () =>
      http.get<CachedMalwareAnalysisResponse>(`${MALWARE_ANALYSIS_CACHE_ROUTE}/${alertId}`, {
        version: '1',
      }),
    {
      enabled: !!alertId,
      staleTime: 5 * 60 * 1000, // Cache is fresh for 5 minutes
      retry: false,
    }
  );

  const hasCachedResult = !!data?.found;

  const cachedResult: MalwareAnalysisResult | undefined = data?.found
    ? {
        taskId: data.task_id ?? '',
        sha256: data.sha256 ?? '',
        status: (data.status as MalwareAnalysisResult['status']) ?? 'completed',
        analysis: data.analysis,
        error: data.error,
        stats: data.stats
          ? {
              costUsd: data.stats.cost_usd,
              inputTokens: data.stats.input_tokens,
              outputTokens: data.stats.output_tokens,
            }
          : undefined,
      }
    : undefined;

  const invalidateCache = useCallback(() => {
    queryClient.invalidateQueries(cacheKey);
  }, [queryClient, cacheKey]);

  return {
    cachedResult,
    isLoading,
    isFetched,
    hasCachedResult,
    refetch,
    invalidateCache,
  };
};
