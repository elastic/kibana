/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import React, { memo, useMemo, useCallback } from 'react';
import { FormattedMessage } from '@kbn/i18n-react';
import {
  EuiButton,
  EuiButtonEmpty,
  EuiCallOut,
  EuiFlexGroup,
  EuiFlexItem,
  EuiLoadingSpinner,
  EuiPanel,
  EuiProgress,
  EuiSpacer,
  EuiText,
  EuiBadge,
  EuiMarkdownFormat,
  EuiCode,
  EuiSkeletonText,
  EuiToolTip,
} from '@elastic/eui';
import { css } from '@emotion/react';
import { i18n } from '@kbn/i18n';
import { getOr } from 'lodash/fp';
import { useExpandSection } from '../../../shared/hooks/use_expand_section';
import { ExpandableSection } from '../../../shared/components/expandable_section';
import { useDocumentDetailsContext } from '../../shared/context';
import { FLYOUT_STORAGE_KEYS } from '../../shared/constants/local_storage';
import { getField } from '../../shared/utils';
import {
  MALWARE_RE_ANALYSIS_SECTION_TEST_ID,
  MALWARE_RE_ANALYSIS_BUTTON_TEST_ID,
  MALWARE_RE_ANALYSIS_LOADING_TEST_ID,
  MALWARE_RE_ANALYSIS_RESULTS_TEST_ID,
  MALWARE_RE_ANALYSIS_ERROR_TEST_ID,
} from './test_ids';
import { useMalwareReAnalysis, type TaskStatus } from '../hooks/use_malware_re_analysis';

const KEY = 'malware-re-analysis';

/**
 * Fields that may contain file hashes in endpoint alerts (in order of preference)
 */
const FILE_HASH_FIELDS = [
  'file.hash.sha256',
  'process.hash.sha256',
  'file.hash.sha1',
  'process.hash.sha1',
  'file.hash.md5',
  'process.hash.md5',
];

/**
 * Checks if the alert is from Endpoint (event.module === 'endpoint')
 */
const useIsEndpointAlert = (): boolean => {
  const { dataAsNestedObject } = useDocumentDetailsContext();

  return useMemo(() => {
    const eventModules = getOr([], 'kibana.alert.original_event.module', dataAsNestedObject);
    const kinds = getOr([], 'kibana.alert.original_event.kind', dataAsNestedObject);

    return eventModules.includes('endpoint') && kinds.includes('alert');
  }, [dataAsNestedObject]);
};

/**
 * Extracts a file hash from the alert data
 */
const useFileHash = (): string | null => {
  const { getFieldsData } = useDocumentDetailsContext();

  return useMemo(() => {
    for (const field of FILE_HASH_FIELDS) {
      const hash = getField(getFieldsData(field));
      if (hash) {
        return hash;
      }
    }
    return null;
  }, [getFieldsData]);
};

/**
 * Builds context string from alert data for the LLM
 */
const useAlertContext = (): string => {
  const { getFieldsData } = useDocumentDetailsContext();

  return useMemo(() => {
    const contextParts: string[] = [];

    const ruleName = getField(getFieldsData('kibana.alert.rule.name'));
    if (ruleName) {
      contextParts.push(`Alert: ${ruleName}`);
    }

    const fileName = getField(getFieldsData('file.name'));
    if (fileName) {
      contextParts.push(`File name: ${fileName}`);
    }

    const filePath = getField(getFieldsData('file.path'));
    if (filePath) {
      contextParts.push(`File path: ${filePath}`);
    }

    const processName = getField(getFieldsData('process.name'));
    if (processName) {
      contextParts.push(`Process: ${processName}`);
    }

    const processArgs = getField(getFieldsData('process.args'));
    if (processArgs) {
      contextParts.push(`Process args: ${processArgs}`);
    }

    const hostName = getField(getFieldsData('host.name'));
    if (hostName) {
      contextParts.push(`Host: ${hostName}`);
    }

    const hostOs = getField(getFieldsData('host.os.name'));
    if (hostOs) {
      contextParts.push(`OS: ${hostOs}`);
    }

    return contextParts.join('\n');
  }, [getFieldsData]);
};

/**
 * Maps task status to a user-friendly message
 */
const getStatusMessage = (status: TaskStatus): string => {
  switch (status) {
    case 'queued':
      return i18n.translate('xpack.securitySolution.flyout.right.malwareReAnalysis.statusQueued', {
        defaultMessage: 'Analysis queued...',
      });
    case 'downloading':
      return i18n.translate(
        'xpack.securitySolution.flyout.right.malwareReAnalysis.statusDownloading',
        { defaultMessage: 'Downloading sample...' }
      );
    case 'running':
      return i18n.translate('xpack.securitySolution.flyout.right.malwareReAnalysis.statusRunning', {
        defaultMessage: 'AI analysis in progress...',
      });
    case 'cancelled':
      return i18n.translate(
        'xpack.securitySolution.flyout.right.malwareReAnalysis.statusCancelled',
        { defaultMessage: 'Analysis was cancelled.' }
      );
    default:
      return i18n.translate(
        'xpack.securitySolution.flyout.right.malwareReAnalysis.statusProcessing',
        { defaultMessage: 'Processing...' }
      );
  }
};

/**
 * Component to display the loading state while analysis is running,
 * including a percent-complete progress bar when iteration data is available.
 * This mirrors the ProgressBar UI from the malware_agent frontend.
 */
const AnalysisLoading: React.FC<{
  taskStatus: TaskStatus | null;
  currentIteration: number | null;
  maxIterations: number | null;
}> = ({ taskStatus, currentIteration, maxIterations }) => {
  const showProgress =
    taskStatus === 'running' &&
    currentIteration != null &&
    maxIterations != null &&
    maxIterations > 0;

  const percentage = showProgress
    ? Math.min(Math.round(((currentIteration ?? 0) / (maxIterations ?? 1)) * 100), 100)
    : 0;

  return (
    <EuiFlexGroup
      alignItems="center"
      justifyContent="center"
      direction="column"
      gutterSize="m"
      data-test-subj={MALWARE_RE_ANALYSIS_LOADING_TEST_ID}
      css={css`
        padding: 24px;
      `}
    >
      <EuiFlexItem grow={false}>
        <EuiLoadingSpinner size="l" />
      </EuiFlexItem>
      <EuiFlexItem grow={false}>
        <EuiText size="s" color="subdued" textAlign="center">
          {taskStatus ? (
            getStatusMessage(taskStatus)
          ) : (
            <FormattedMessage
              id="xpack.securitySolution.flyout.right.malwareReAnalysis.loadingMessage"
              defaultMessage="Analyzing malware sample with AI. This may take a moment..."
            />
          )}
        </EuiText>
      </EuiFlexItem>

      {showProgress && (
        <EuiFlexItem
          grow={false}
          css={css`
            width: 100%;
            max-width: 320px;
          `}
        >
          <EuiFlexGroup justifyContent="spaceBetween" alignItems="center" gutterSize="none">
            <EuiFlexItem grow={false}>
              <EuiText size="xs" color="subdued">
                <FormattedMessage
                  id="xpack.securitySolution.flyout.right.malwareReAnalysis.iterationLabel"
                  defaultMessage="Iteration {current} / {max}"
                  values={{ current: currentIteration, max: maxIterations }}
                />
              </EuiText>
            </EuiFlexItem>
            <EuiFlexItem grow={false}>
              <EuiText size="xs" color="subdued">
                <FormattedMessage
                  id="xpack.securitySolution.flyout.right.malwareReAnalysis.percentLabel"
                  defaultMessage="{percentage}%"
                  values={{ percentage }}
                />
              </EuiText>
            </EuiFlexItem>
          </EuiFlexGroup>
          <EuiSpacer size="xs" />
          <EuiProgress
            value={percentage}
            max={100}
            size="m"
            color="primary"
            label=""
            valueText=""
          />
        </EuiFlexItem>
      )}
    </EuiFlexGroup>
  );
};

/**
 * Component to display when no file hash is available
 */
const NoHashAvailable: React.FC = () => (
  <EuiCallOut
    size="s"
    color="warning"
    iconType="warning"
    title={
      <FormattedMessage
        id="xpack.securitySolution.flyout.right.malwareReAnalysis.noHashTitle"
        defaultMessage="File hash not available"
      />
    }
  >
    <FormattedMessage
      id="xpack.securitySolution.flyout.right.malwareReAnalysis.noHashMessage"
      defaultMessage="This alert does not contain a file hash (SHA256, SHA1, or MD5) required for malware analysis."
    />
  </EuiCallOut>
);

/**
 * Component to display the initial state with the run analysis button
 */
const AnalysisPrompt: React.FC<{
  onRunAnalysis: () => void;
  isRulePreview: boolean;
  fileHash: string;
}> = ({ onRunAnalysis, isRulePreview, fileHash }) => {
  if (isRulePreview) {
    return (
      <EuiCallOut
        announceOnMount
        iconType="documentation"
        size="s"
        title={
          <FormattedMessage
            id="xpack.securitySolution.flyout.right.malwareReAnalysis.previewTitle"
            defaultMessage="Malware RE Analysis"
          />
        }
        aria-label={i18n.translate(
          'xpack.securitySolution.flyout.right.malwareReAnalysis.previewAriaLabel',
          { defaultMessage: 'Malware RE Analysis' }
        )}
      >
        <FormattedMessage
          id="xpack.securitySolution.flyout.right.malwareReAnalysis.previewMessage"
          defaultMessage="Malware RE Analysis is not available in alert preview."
        />
      </EuiCallOut>
    );
  }

  return (
    <EuiFlexGroup direction="column" gutterSize="m">
      <EuiFlexItem>
        <EuiText size="s" color="subdued">
          <FormattedMessage
            id="xpack.securitySolution.flyout.right.malwareReAnalysis.promptDescription"
            defaultMessage="Run an AI-powered reverse engineering analysis on this malware sample to get detailed insights about its behavior, classification, and recommended actions."
          />
        </EuiText>
      </EuiFlexItem>
      <EuiFlexItem>
        <EuiText size="xs" color="subdued">
          <FormattedMessage
            id="xpack.securitySolution.flyout.right.malwareReAnalysis.hashLabel"
            defaultMessage="Sample hash: "
          />
          <EuiCode
            css={css`
              word-break: break-all;
            `}
          >
            {fileHash}
          </EuiCode>
        </EuiText>
      </EuiFlexItem>
      <EuiFlexItem grow={false}>
        <EuiButton
          data-test-subj={MALWARE_RE_ANALYSIS_BUTTON_TEST_ID}
          onClick={onRunAnalysis}
          iconType="sparkles"
          size="s"
        >
          <FormattedMessage
            id="xpack.securitySolution.flyout.right.malwareReAnalysis.runAnalysisButton"
            defaultMessage="Run AI Analysis"
          />
        </EuiButton>
      </EuiFlexItem>
    </EuiFlexGroup>
  );
};

/**
 * Component to display the error state
 */
const AnalysisError: React.FC<{ errorMessage?: string | null; onRetry: () => void }> = ({
  errorMessage,
  onRetry,
}) => (
  <EuiCallOut
    data-test-subj={MALWARE_RE_ANALYSIS_ERROR_TEST_ID}
    title={
      <FormattedMessage
        id="xpack.securitySolution.flyout.right.malwareReAnalysis.errorTitle"
        defaultMessage="Analysis failed"
      />
    }
    color="danger"
    iconType="error"
    size="s"
  >
    <EuiText size="s">
      {errorMessage || (
        <FormattedMessage
          id="xpack.securitySolution.flyout.right.malwareReAnalysis.errorMessage"
          defaultMessage="Unable to complete the malware analysis. Please try again."
        />
      )}
    </EuiText>
    <EuiSpacer size="s" />
    <EuiButton
      data-test-subj={`${MALWARE_RE_ANALYSIS_ERROR_TEST_ID}RetryButton`}
      onClick={onRetry}
      size="s"
      color="danger"
    >
      <FormattedMessage
        id="xpack.securitySolution.flyout.right.malwareReAnalysis.retryButton"
        defaultMessage="Retry Analysis"
      />
    </EuiButton>
  </EuiCallOut>
);

/**
 * Component to display the analysis results with a "Regenerate" button
 */
const AnalysisResults: React.FC<{
  analysis: string;
  sha256: string;
  stats?: {
    costUsd?: number;
    inputTokens?: number;
    outputTokens?: number;
  };
  onRegenerate: () => void;
  isRegenerating: boolean;
}> = ({ analysis, sha256, stats, onRegenerate, isRegenerating }) => (
  <EuiFlexGroup
    direction="column"
    gutterSize="m"
    data-test-subj={MALWARE_RE_ANALYSIS_RESULTS_TEST_ID}
  >
    <EuiFlexItem>
      <EuiFlexGroup justifyContent="spaceBetween" alignItems="center">
        <EuiFlexItem grow={false}>
          <EuiFlexGroup gutterSize="s" alignItems="center">
            <EuiFlexItem grow={false}>
              <EuiBadge color="success" iconType="check">
                <FormattedMessage
                  id="xpack.securitySolution.flyout.right.malwareReAnalysis.completedBadge"
                  defaultMessage="Analysis Complete"
                />
              </EuiBadge>
            </EuiFlexItem>
            {stats?.costUsd !== undefined && (
              <EuiFlexItem grow={false}>
                <EuiText size="xs" color="subdued">
                  <FormattedMessage
                    id="xpack.securitySolution.flyout.right.malwareReAnalysis.costLabel"
                    defaultMessage="Cost: ${cost} ({inputTokens} in / {outputTokens} out)"
                    values={{
                      cost: stats.costUsd.toFixed(4),
                      inputTokens: stats.inputTokens?.toLocaleString() ?? 0,
                      outputTokens: stats.outputTokens?.toLocaleString() ?? 0,
                    }}
                  />
                </EuiText>
              </EuiFlexItem>
            )}
          </EuiFlexGroup>
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiToolTip
            content={i18n.translate(
              'xpack.securitySolution.flyout.right.malwareReAnalysis.regenerateTooltip',
              {
                defaultMessage:
                  'Re-run the AI analysis on this sample. This will replace the existing results.',
              }
            )}
          >
            <EuiButtonEmpty
              data-test-subj={`${MALWARE_RE_ANALYSIS_RESULTS_TEST_ID}RegenerateButton`}
              onClick={onRegenerate}
              iconType="refresh"
              size="s"
              isLoading={isRegenerating}
              disabled={isRegenerating}
            >
              <FormattedMessage
                id="xpack.securitySolution.flyout.right.malwareReAnalysis.regenerateButton"
                defaultMessage="Regenerate"
              />
            </EuiButtonEmpty>
          </EuiToolTip>
        </EuiFlexItem>
      </EuiFlexGroup>
    </EuiFlexItem>

    <EuiFlexItem>
      <EuiText size="xs" color="subdued">
        <FormattedMessage
          id="xpack.securitySolution.flyout.right.malwareReAnalysis.analyzedHashLabel"
          defaultMessage="Analyzed sample: "
        />
        <EuiCode
          css={css`
            word-break: break-all;
          `}
        >
          {sha256}
        </EuiCode>
      </EuiText>
    </EuiFlexItem>

    <EuiFlexItem>
      <EuiPanel paddingSize="m" hasBorder>
        <EuiMarkdownFormat
          textSize="s"
          css={css`
            & h1,
            & h2,
            & h3,
            & h4,
            & h5,
            & h6 {
              margin-top: 16px;
              margin-bottom: 8px;
            }
            & h1:first-child,
            & h2:first-child,
            & h3:first-child {
              margin-top: 0;
            }
            & pre {
              white-space: pre-wrap;
              word-break: break-word;
            }
            & code {
              word-break: break-all;
            }
          `}
        >
          {analysis}
        </EuiMarkdownFormat>
      </EuiPanel>
    </EuiFlexItem>
  </EuiFlexGroup>
);

/**
 * Malware Reverse Engineering Analysis section for the alert details flyout.
 * This section is only visible for Endpoint alerts (event.module === 'endpoint').
 * It provides AI-powered analysis of malware samples using the Arbiter service.
 *
 * Results are cached server-side and displayed immediately on subsequent visits.
 * Users can regenerate the analysis on demand via the "Regenerate" button.
 */
export const MalwareReAnalysisSection = memo(() => {
  const { isRulePreview, eventId } = useDocumentDetailsContext();
  const isEndpointAlert = useIsEndpointAlert();
  const fileHash = useFileHash();
  const alertContext = useAlertContext();

  const expanded = useExpandSection({
    storageKey: FLYOUT_STORAGE_KEYS.OVERVIEW_TAB_EXPANDED_SECTIONS,
    title: KEY,
    defaultValue: false,
  });

  const {
    runAnalysis,
    data,
    isLoading,
    isError,
    error,
    reset,
    taskStatus,
    currentIteration,
    maxIterations,
    hasCachedResult,
    isCacheLoading,
  } = useMalwareReAnalysis(eventId, fileHash ?? '', alertContext);

  const handleRegenerate = useCallback(() => {
    reset();
    runAnalysis();
  }, [reset, runAnalysis]);

  const content = useMemo(() => {
    // No file hash available
    if (!fileHash) {
      return <NoHashAvailable />;
    }

    // Cache is still loading - show skeleton
    if (isCacheLoading) {
      return <EuiSkeletonText lines={3} size="s" />;
    }

    // Active analysis is running
    if (isLoading) {
      return (
        <AnalysisLoading
          taskStatus={taskStatus}
          currentIteration={currentIteration}
          maxIterations={maxIterations}
        />
      );
    }

    // Error state
    if (isError) {
      return <AnalysisError errorMessage={error || data?.error} onRetry={handleRegenerate} />;
    }

    // Results state (from cache or fresh analysis)
    if (data?.status === 'completed' && data.analysis) {
      return (
        <AnalysisResults
          analysis={data.analysis}
          sha256={data.sha256}
          stats={data.stats}
          onRegenerate={handleRegenerate}
          isRegenerating={isLoading}
        />
      );
    }

    // Initial state - no cached result, show prompt
    return (
      <AnalysisPrompt
        onRunAnalysis={runAnalysis}
        isRulePreview={isRulePreview}
        fileHash={fileHash}
      />
    );
  }, [
    fileHash,
    isCacheLoading,
    isLoading,
    taskStatus,
    currentIteration,
    maxIterations,
    isError,
    error,
    data,
    handleRegenerate,
    runAnalysis,
    isRulePreview,
  ]);

  // Only render for Endpoint alerts
  if (!isEndpointAlert) {
    return null;
  }

  return (
    <ExpandableSection
      expanded={expanded}
      title={
        <FormattedMessage
          id="xpack.securitySolution.flyout.right.malwareReAnalysis.sectionTitle"
          defaultMessage="Malware RE Analysis"
        />
      }
      localStorageKey={FLYOUT_STORAGE_KEYS.OVERVIEW_TAB_EXPANDED_SECTIONS}
      sectionId={KEY}
      data-test-subj={MALWARE_RE_ANALYSIS_SECTION_TEST_ID}
    >
      {content}
    </ExpandableSection>
  );
});

MalwareReAnalysisSection.displayName = 'MalwareReAnalysisSection';
