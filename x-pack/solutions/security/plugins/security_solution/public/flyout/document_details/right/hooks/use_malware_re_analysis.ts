/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { useCallback, useState, useRef, useEffect } from 'react';
import { useKibana } from '../../../../common/lib/kibana';
import { useFetchMalwareAnalysisCache } from './use_fetch_malware_analysis_cache';
import { useSaveMalwareAnalysisCache } from './use_save_malware_analysis_cache';

/**
 * Proxy route for the malware analysis orchestrator.
 * The Kibana server proxies requests to the malware_agent orchestrator service.
 */
const MALWARE_ANALYSIS_PROXY_ROUTE = '/api/security_solution/malware_analysis';

/**
 * Polling interval in milliseconds for checking task status
 */
const POLL_INTERVAL_MS = 5000;

/**
 * Maximum polling duration in milliseconds (30 minutes)
 */
const MAX_POLL_DURATION_MS = 30 * 60 * 1000;

/**
 * Status of a malware analysis task from the orchestrator
 */
export type TaskStatus =
  | 'queued'
  | 'downloading'
  | 'running'
  | 'completed'
  | 'failed'
  | 'cancelled';

/**
 * Request to submit a sample for malware analysis
 */
export interface MalwareAnalysisSubmitRequest {
  /**
   * SHA256 hash of the malware sample
   */
  sha256: string;
  /**
   * Base64-encoded binary data (optional, if not provided the orchestrator downloads from VirusTotal)
   */
  data?: string;
  /**
   * Max agent iterations (optional, default: 100)
   */
  iterations?: number;
  /**
   * Additional context for the LLM analysis (optional)
   */
  context?: string;
}

/**
 * Response from submitting a sample or checking status
 */
export interface MalwareAnalysisTaskInfo {
  /**
   * Unique task identifier
   */
  taskId: string;
  /**
   * SHA256 hash of the sample
   */
  sha256: string;
  /**
   * Current status of the analysis task
   */
  status: TaskStatus;
  /**
   * Timestamp when the task was created
   */
  createdAt?: string;
  /**
   * Timestamp when the task started processing
   */
  startedAt?: string;
  /**
   * Timestamp when the task completed
   */
  completedAt?: string;
  /**
   * Error message if status is 'failed'
   */
  error?: string;
}

/**
 * Response containing the analysis results
 */
export interface MalwareAnalysisResult {
  /**
   * Unique task identifier
   */
  taskId: string;
  /**
   * SHA256 hash of the sample
   */
  sha256: string;
  /**
   * Status of the analysis
   */
  status: TaskStatus;
  /**
   * The AI-generated analysis report (markdown formatted)
   */
  analysis?: string;
  /**
   * Error message if status is 'failed'
   */
  error?: string;
  /**
   * Token usage and cost statistics
   */
  stats?: {
    /**
     * Estimated cost in USD
     */
    costUsd?: number;
    /**
     * Number of input tokens used
     */
    inputTokens?: number;
    /**
     * Number of output tokens generated
     */
    outputTokens?: number;
  };
}

export interface UseMalwareReAnalysisResult {
  /**
   * Triggers the malware RE analysis (first run or regeneration)
   */
  runAnalysis: () => void;
  /**
   * The analysis results (from cache or fresh analysis)
   */
  data: MalwareAnalysisResult | undefined;
  /**
   * Whether the analysis is currently running (submitting or polling)
   */
  isLoading: boolean;
  /**
   * Whether the analysis has completed successfully
   */
  isSuccess: boolean;
  /**
   * Whether the analysis has failed
   */
  isError: boolean;
  /**
   * The error message if the analysis failed
   */
  error: string | null;
  /**
   * Resets the analysis state
   */
  reset: () => void;
  /**
   * Current task status while polling
   */
  taskStatus: TaskStatus | null;
  /**
   * Current iteration number from the orchestrator (for progress tracking)
   */
  currentIteration: number | null;
  /**
   * Max iterations configured for this task (for progress tracking)
   */
  maxIterations: number | null;
  /**
   * Whether a cached result was loaded from the server
   */
  hasCachedResult: boolean;
  /**
   * Whether the cache is still loading
   */
  isCacheLoading: boolean;
}

/**
 * Hook to trigger and retrieve malware reverse engineering analysis powered by Generative AI.
 * This hook integrates with the malware_agent orchestrator service (Arbiter).
 *
 * Results are cached in Kibana saved objects. On subsequent visits, cached results
 * are displayed immediately. Users can regenerate the analysis on demand.
 *
 * The workflow is:
 * 1. Check for cached results via the server-side cache route
 * 2. If cached, display them immediately
 * 3. If not cached (or regenerating), submit the sample SHA256 via POST /submit
 * 4. Poll the status via GET /status/<task_id> until completed or failed
 * 5. Retrieve results via GET /results/<task_id>
 * 6. Save results to the cache for future visits
 *
 * This hook is designed for Endpoint alerts only (event.module === 'endpoint').
 */
export const useMalwareReAnalysis = (
  alertId: string,
  fileHash: string,
  alertContext?: string
): UseMalwareReAnalysisResult => {
  const { http } = useKibana().services;

  const [data, setData] = useState<MalwareAnalysisResult | undefined>(undefined);
  const [isLoading, setIsLoading] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [isError, setIsError] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [taskStatus, setTaskStatus] = useState<TaskStatus | null>(null);
  const [currentIteration, setCurrentIteration] = useState<number | null>(null);
  const [maxIterations, setMaxIterations] = useState<number | null>(null);

  const pollingRef = useRef<NodeJS.Timeout | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);
  const startTimeRef = useRef<number | null>(null);

  // Cache hooks
  const {
    cachedResult,
    isLoading: isCacheLoading,
    isFetched: isCacheFetched,
    hasCachedResult,
    invalidateCache,
  } = useFetchMalwareAnalysisCache(alertId);

  const { saveToCache } = useSaveMalwareAnalysisCache();

  // When cached result is loaded, set it as the current data
  useEffect(() => {
    if (isCacheFetched && hasCachedResult && cachedResult && !data && !isLoading) {
      setData(cachedResult);
      setIsSuccess(cachedResult.status === 'completed');
      setIsError(cachedResult.status === 'failed');
      if (cachedResult.error) {
        setError(cachedResult.error);
      }
    }
  }, [isCacheFetched, hasCachedResult, cachedResult, data, isLoading]);

  /**
   * Clean up polling interval and abort controller
   */
  const cleanup = useCallback(() => {
    if (pollingRef.current) {
      clearInterval(pollingRef.current);
      pollingRef.current = null;
    }
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
    startTimeRef.current = null;
  }, []);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return cleanup;
  }, [cleanup]);

  /**
   * Poll for task status and results
   */
  const pollStatus = useCallback(
    async (taskId: string): Promise<void> => {
      // Check if we've exceeded max polling duration
      if (startTimeRef.current && Date.now() - startTimeRef.current > MAX_POLL_DURATION_MS) {
        cleanup();
        setIsLoading(false);
        setIsError(true);
        setError('Analysis timed out. Please try again.');
        return;
      }

      try {
        // Check task status
        const statusResponse = await http.get<{
          task_id: string;
          sha256: string;
          status: TaskStatus;
          created_at?: string;
          started_at?: string;
          completed_at?: string;
          error?: string;
          current_iteration?: number | null;
          max_iterations?: number | null;
        }>(`${MALWARE_ANALYSIS_PROXY_ROUTE}/status/${taskId}`, {
          version: '1',
          signal: abortControllerRef.current?.signal,
        });

        setTaskStatus(statusResponse.status);
        if (statusResponse.current_iteration != null) {
          setCurrentIteration(statusResponse.current_iteration);
        }
        if (statusResponse.max_iterations != null) {
          setMaxIterations(statusResponse.max_iterations);
        }

        if (
          statusResponse.status === 'completed' ||
          statusResponse.status === 'failed' ||
          statusResponse.status === 'cancelled'
        ) {
          cleanup();

          // Cancelled tasks may not have results â€” handle gracefully
          if (statusResponse.status === 'cancelled') {
            setData({
              taskId,
              sha256: statusResponse.sha256,
              status: 'cancelled',
              error: 'Analysis was cancelled.',
            });
            setIsLoading(false);
            setIsError(true);
            setError('Analysis was cancelled.');
            return;
          }

          // Get the results
          const resultsResponse = await http.get<{
            task_id: string;
            sha256: string;
            status: TaskStatus;
            analysis?: string;
            error?: string;
            stats?: {
              cost_usd?: number;
              input_tokens?: number;
              output_tokens?: number;
            };
          }>(`${MALWARE_ANALYSIS_PROXY_ROUTE}/results/${taskId}`, {
            version: '1',
          });

          const result: MalwareAnalysisResult = {
            taskId: resultsResponse.task_id,
            sha256: resultsResponse.sha256,
            status: resultsResponse.status,
            analysis: resultsResponse.analysis,
            error: resultsResponse.error,
            stats: resultsResponse.stats
              ? {
                  costUsd: resultsResponse.stats.cost_usd,
                  inputTokens: resultsResponse.stats.input_tokens,
                  outputTokens: resultsResponse.stats.output_tokens,
                }
              : undefined,
          };

          setData(result);
          setIsLoading(false);

          if (resultsResponse.status === 'completed') {
            setIsSuccess(true);

            // Save to cache for future visits
            await saveToCache({ alertId, result });
            invalidateCache();
          } else {
            setIsError(true);
            setError(resultsResponse.error || 'Analysis failed');
          }
        }
      } catch (err) {
        // Ignore abort errors
        if (err instanceof Error && err.name === 'AbortError') {
          return;
        }
        cleanup();
        setIsLoading(false);
        setIsError(true);
        setError(err instanceof Error ? err.message : 'Failed to check analysis status');
      }
    },
    [http, cleanup, alertId, saveToCache, invalidateCache]
  );

  /**
   * Submit a sample and start polling for results.
   * This is used for both first-time analysis and regeneration.
   */
  const runAnalysis = useCallback(async () => {
    // Reset state
    setData(undefined);
    setIsLoading(true);
    setIsSuccess(false);
    setIsError(false);
    setError(null);
    setTaskStatus(null);
    setCurrentIteration(null);
    setMaxIterations(null);
    cleanup();

    // Create new abort controller
    abortControllerRef.current = new AbortController();
    startTimeRef.current = Date.now();

    try {
      // Submit the sample for analysis
      const submitResponse = await http.post<{
        task_id: string;
        sha256: string;
        status: TaskStatus;
        created_at?: string;
        error?: string;
      }>(`${MALWARE_ANALYSIS_PROXY_ROUTE}/submit`, {
        version: '1',
        body: JSON.stringify({
          sha256: fileHash,
          context: alertContext,
        }),
        signal: abortControllerRef.current.signal,
      });

      const taskId = submitResponse.task_id;
      setTaskStatus(submitResponse.status);

      // If already in a terminal state (unlikely but possible), handle immediately
      if (
        submitResponse.status === 'completed' ||
        submitResponse.status === 'failed' ||
        submitResponse.status === 'cancelled'
      ) {
        await pollStatus(taskId);
        return;
      }

      // Start polling for status
      pollingRef.current = setInterval(() => {
        pollStatus(taskId);
      }, POLL_INTERVAL_MS);

      // Also poll immediately
      await pollStatus(taskId);
    } catch (err) {
      // Ignore abort errors
      if (err instanceof Error && err.name === 'AbortError') {
        return;
      }
      cleanup();
      setIsLoading(false);
      setIsError(true);
      setError(err instanceof Error ? err.message : 'Failed to submit sample for analysis');
    }
  }, [http, fileHash, alertContext, cleanup, pollStatus]);

  /**
   * Reset all state
   */
  const reset = useCallback(() => {
    cleanup();
    setData(undefined);
    setIsLoading(false);
    setIsSuccess(false);
    setIsError(false);
    setError(null);
    setTaskStatus(null);
    setCurrentIteration(null);
    setMaxIterations(null);
  }, [cleanup]);

  return {
    runAnalysis,
    data,
    isLoading,
    isSuccess,
    isError,
    error,
    reset,
    taskStatus,
    currentIteration,
    maxIterations,
    hasCachedResult,
    isCacheLoading,
  };
};
