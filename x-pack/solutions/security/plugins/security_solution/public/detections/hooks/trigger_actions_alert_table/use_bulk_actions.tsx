/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import type { QueryDslQueryContainer } from '@elastic/elasticsearch/lib/api/types';
import type { SerializableRecord } from '@kbn/utility-types';
import { isEqual } from 'lodash';
import type { Filter } from '@kbn/es-query';
import { useCallback, useMemo } from 'react';
import type { TableId } from '@kbn/securitysolution-data-table';
import type {
  AlertsTableProps,
  BulkActionsPanelConfig,
  ItemsPanelConfig,
} from '@kbn/response-ops-alerts-table/types';
import { PageScope } from '../../../data_view_manager/constants';
import { useBulkAlertAssigneesItems } from '../../../common/components/toolbar/bulk_actions/use_bulk_alert_assignees_items';
import { useBulkAlertTagsItems } from '../../../common/components/toolbar/bulk_actions/use_bulk_alert_tags_items';
import { useUserPrivileges } from '../../../common/components/user_privileges';
import { useGlobalTime } from '../../../common/containers/use_global_time';
import { useAddBulkToTimelineAction } from '../../components/alerts_table/timeline_actions/use_add_bulk_to_timeline';
import { useBulkAlertActionItems } from './use_alert_actions';
import { useDeepEqualSelector } from '../../../common/hooks/use_selector';
import type { inputsModel } from '../../../common/store';
import { inputsSelectors } from '../../../common/store';

// check to see if the query is a known "empty" shape
export function isKnownEmptyQuery(query: QueryDslQueryContainer) {
  const queries = [
    // the default query used by the job wizards
    { bool: { must: [{ match_all: {} }] } },
    // the default query used created by lens created jobs
    { bool: { filter: [], must: [{ match_all: {} }], must_not: [] } },
    // variations on the two previous queries
    { bool: { filter: [], must: [{ match_all: {} }] } },
    { bool: { must: [{ match_all: {} }], must_not: [] } },
    // the query generated by QA Framework created jobs
    { match_all: {} },
  ];
  if (queries.some((q) => isEqual(q, query))) {
    return true;
  }

  return false;
}

function getFiltersForDSLQuery(datafeedQuery: QueryDslQueryContainer): Filter[] {
  if (isKnownEmptyQuery(datafeedQuery)) {
    return [];
  }

  return [
    {
      meta: {
        negate: false,
        disabled: false,
        type: 'custom',
        value: JSON.stringify(datafeedQuery),
      },
      query: datafeedQuery as SerializableRecord,
    },
  ];
}

export const useBulkActionsByTableType = (
  tableId: TableId,
  query: AlertsTableProps['query'],
  refresh: () => void
): [ItemsPanelConfig, ...BulkActionsPanelConfig[]] => {
  const { from, to } = useGlobalTime();
  const filters = useMemo(() => {
    return getFiltersForDSLQuery(query);
  }, [query]);
  const assigneeProps = useMemo(() => {
    return {
      onAssigneesUpdate: refresh,
    };
  }, [refresh]);

  const { alertAssigneesItems, alertAssigneesPanels } = useBulkAlertAssigneesItems(assigneeProps);

  const timelineActionParams = useMemo(() => {
    return {
      localFilters: filters,
      from,
      to,
      scopeId: PageScope.alerts,
      tableId,
    };
  }, [filters, from, to, tableId]);

  const getGlobalQueriesSelector = useMemo(() => inputsSelectors.globalQuery(), []);
  const globalQueries = useDeepEqualSelector(getGlobalQueriesSelector);

  const refetch = useCallback(() => {
    refresh();
    globalQueries.forEach((q) => q.refetch && (q.refetch as inputsModel.Refetch)());
  }, [globalQueries, refresh]);

  const alertActionParams = useMemo(() => {
    return {
      scopeId: PageScope.alerts,
      filters,
      from,
      to,
      tableId,
      refetch,
    };
  }, [from, to, filters, refetch, tableId]);

  const bulkAlertTagParams = useMemo(() => {
    return {
      refetch: refresh,
    };
  }, [refresh]);

  const {
    timelinePrivileges: { read: hasTimelineReadPrivilege },
  } = useUserPrivileges();
  const addBulkToTimelineAction = useAddBulkToTimelineAction(timelineActionParams);

  const timelineActions = useMemo(
    () => (hasTimelineReadPrivilege ? [addBulkToTimelineAction] : []),
    [hasTimelineReadPrivilege, addBulkToTimelineAction]
  );

  const { items: alertActions, panels: alertActionsPanels } =
    useBulkAlertActionItems(alertActionParams);

  const { alertTagsItems, alertTagsPanels } = useBulkAlertTagsItems(bulkAlertTagParams);

  const items = useMemo(() => {
    return [...alertActions, ...timelineActions, ...alertTagsItems, ...alertAssigneesItems];
  }, [alertActions, alertTagsItems, timelineActions, alertAssigneesItems]);
  return useMemo(() => {
    return [{ id: 0, items }, ...alertActionsPanels, ...alertTagsPanels, ...alertAssigneesPanels];
  }, [alertActionsPanels, alertTagsPanels, items, alertAssigneesPanels]);
};
