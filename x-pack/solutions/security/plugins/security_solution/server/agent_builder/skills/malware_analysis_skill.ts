/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { ToolResultType, ToolType } from '@kbn/agent-builder-common/tools';
import { defineSkillType } from '@kbn/agent-builder-server/skills/type_definition';
import { z } from '@kbn/zod';
import axios from 'axios';
import type { MalwareAnalysisConfig } from '../../lib/malware_analysis';

/**
 * Creates the malware analysis skill for the Agent Builder.
 *
 * This skill allows the AI agent to submit malware samples for reverse-engineering
 * analysis via the Arbiter orchestrator, poll for completion, and return the
 * AI-generated analysis report back to the conversation.
 *
 * @param config - The malware analysis orchestrator configuration (URL, token, timeout)
 */
export const createMalwareAnalysisSkill = (config: MalwareAnalysisConfig) => {
  const orchestratorHeaders: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  if (config.apiToken) {
    orchestratorHeaders.Authorization = `Bearer ${config.apiToken}`;
  }

  const orchestratorBaseUrl = config.orchestratorUrl.replace(/\/$/, '');
  const orchestratorTimeout = config.timeout ?? 30000;

  return defineSkillType({
    id: 'malware-analysis',
    name: 'malware-analysis',
    basePath: 'skills/security/alerts',
    description:
      'Submit a malware sample (by SHA256 hash) for AI-powered reverse engineering analysis using the Arbiter service. Use this skill when a user asks to analyze a suspicious file, executable, or malware sample associated with a security alert.',
    content: `# Malware Reverse Engineering Analysis

## When to Use This Skill
Use this skill when the user asks you to:
- Analyze a suspicious executable or binary associated with an alert
- Run malware analysis or reverse engineering on a file hash
- Get detailed information about what a malicious file does
- Investigate a file's behavior, capabilities, or classification

## How It Works
1. Extract the file hash (SHA256) from the alert data. Look in fields like \`file.hash.sha256\`, \`process.hash.sha256\`, or other hash fields.
2. Optionally gather context from the alert (rule name, file name, file path, host, OS) to provide to the analysis engine.
3. Use the \`security.malware-analysis.submit-sample\` tool to submit the hash for analysis.
4. The tool will submit the sample, poll until analysis completes, and return the full analysis report.
5. Present the analysis report to the user. The report is in Markdown format and includes detailed reverse engineering findings.

## Important Notes
- Only SHA256 hashes are supported for submission.
- Analysis typically takes 5-15 minutes depending on sample complexity.
- The analysis is performed by an AI agent that runs the sample in an isolated sandbox.
- If context is available (alert name, file name, host info), always include it â€” it helps the analysis engine produce better results.
- If the sample has already been analyzed before, results may be returned faster.`,
    getAllowedTools: () => ['security.alerts'],
    getInlineTools: () => [
      {
        id: 'security.malware-analysis.submit-sample',
        type: ToolType.builtin,
        description:
          'Submit a malware sample by SHA256 hash for AI-powered reverse engineering analysis. Returns the full analysis report once complete. The analysis includes file classification, behavior analysis, capabilities, indicators of compromise, and remediation recommendations.',
        schema: z.object({
          sha256: z.string().min(64).max(64).describe('The SHA256 hash of the file to analyze.'),
          context: z
            .string()
            .optional()
            .describe(
              'Optional additional context for the analysis engine, such as the alert rule name, file name, file path, host name, or operating system. Helps produce a more relevant analysis.'
            ),
        }),
        handler: async (args, _context) => {
          const { sha256, context } = args;
          const pollIntervalMs = 5000;
          const maxPollDurationMs = 30 * 60 * 1000; // 30 minutes

          try {
            // Step 1: Submit the sample
            const submitResponse = await axios.post(
              `${orchestratorBaseUrl}/api/submit`,
              { sha256, context },
              { headers: orchestratorHeaders, timeout: orchestratorTimeout }
            );

            const taskId: string = submitResponse.data.task_id;
            const initialStatus: string = submitResponse.data.status;

            if (!taskId) {
              return {
                results: [
                  {
                    type: ToolResultType.error,
                    data: {
                      message: 'Failed to submit sample: no task ID returned from orchestrator.',
                    },
                  },
                ],
              };
            }

            // Step 2: Poll until terminal state
            const startTime = Date.now();
            let currentStatus = initialStatus;

            while (
              currentStatus !== 'completed' &&
              currentStatus !== 'failed' &&
              currentStatus !== 'cancelled'
            ) {
              if (Date.now() - startTime > maxPollDurationMs) {
                return {
                  results: [
                    {
                      type: ToolResultType.error,
                      data: {
                        message: `Analysis timed out after 30 minutes. Task ID: ${taskId}. You can check the status later.`,
                      },
                    },
                  ],
                };
              }

              await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));

              const statusResponse = await axios.get(
                `${orchestratorBaseUrl}/api/status/${taskId}`,
                { headers: orchestratorHeaders, timeout: orchestratorTimeout }
              );

              currentStatus = statusResponse.data.status;
            }

            // Step 3: Handle cancelled
            if (currentStatus === 'cancelled') {
              return {
                results: [
                  {
                    type: ToolResultType.error,
                    data: {
                      message: `Analysis was cancelled. Task ID: ${taskId}`,
                    },
                  },
                ],
              };
            }

            // Step 4: Fetch results
            const resultsResponse = await axios.get(
              `${orchestratorBaseUrl}/api/results/${taskId}`,
              { headers: orchestratorHeaders, timeout: orchestratorTimeout }
            );

            const {
              status: finalStatus,
              analysis,
              error: analysisError,
              stats,
            } = resultsResponse.data;

            if (finalStatus === 'failed') {
              return {
                results: [
                  {
                    type: ToolResultType.error,
                    data: {
                      message: `Malware analysis failed: ${
                        analysisError ?? 'Unknown error'
                      }. Task ID: ${taskId}`,
                    },
                  },
                ],
              };
            }

            // Step 5: Return the analysis
            const statsLine = stats
              ? `\n\n---\n_Cost: $${stats.cost_usd?.toFixed(4) ?? '?'} | Tokens: ${
                  stats.input_tokens?.toLocaleString() ?? '?'
                } in / ${stats.output_tokens?.toLocaleString() ?? '?'} out_`
              : '';

            return {
              results: [
                {
                  type: ToolResultType.other,
                  data: {
                    message: `## Malware Analysis Report\n\n**SHA256:** \`${sha256}\`\n**Task ID:** ${taskId}\n\n${
                      analysis ?? 'No analysis content returned.'
                    }${statsLine}`,
                  },
                },
              ],
            };
          } catch (err) {
            const errorMessage = axios.isAxiosError(err)
              ? err.response?.data?.error ?? err.message
              : err instanceof Error
              ? err.message
              : 'Unknown error';
            return {
              results: [
                {
                  type: ToolResultType.error,
                  data: {
                    message: `Failed to run malware analysis: ${errorMessage}`,
                  },
                },
              ],
            };
          }
        },
      },
    ],
  });
};
