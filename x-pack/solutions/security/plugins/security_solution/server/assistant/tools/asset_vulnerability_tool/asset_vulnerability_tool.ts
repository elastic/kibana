/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import type { AssistantTool, AssistantToolParams } from '@kbn/elastic-assistant-plugin/server';
import { tool } from '@langchain/core/tools';
import { z } from '@kbn/zod';
import { requestHasRequiredAnonymizationParams } from '@kbn/elastic-assistant-plugin/server/lib/langchain/helpers';
import type { Require } from '@kbn/elastic-assistant-plugin/server/types';
import { naturalLanguageSearch } from '@kbn/onechat-genai-utils';
import type { EsqlResponse } from '@kbn/onechat-genai-utils/tools/steps/execute_esql';
import { esqlResponseToJson } from '@kbn/onechat-genai-utils/tools/utils/esql';
import { APP_UI_ID } from '../../../../common/constants';

export type VulnerabilityToolParams = Require<AssistantToolParams, 'inference' | 'connectorId'>;

interface VulnerabilityFinding {
  cve_id: string;
  severity: string;
  score?: number;
  package_name?: string;
  package_version?: string;
  fix_version?: string;
  resource_name: string;
  description?: string;
  last_seen: string;
}

interface VulnerabilityData {
  total_findings: number;
  critical_count: number;
  high_count: number;
  medium_count: number;
  low_count: number;
  findings: VulnerabilityFinding[];
}

const extractInstanceIdFromArn = (identifier: string): string => {
  // Handle ARN format: arn:aws:ec2:region:account:ec2/i-instanceid
  if (identifier.startsWith('arn:aws:ec2:') && identifier.includes('/i-')) {
    const parts = identifier.split('/');
    const instancePart = parts.find((part) => part.startsWith('i-'));
    if (instancePart) {
      return instancePart;
    }
  }
  // If not ARN format, return as-is
  return identifier;
};

const buildVulnerabilityQuery = (
  entityIdentifier: string,
  entityType: 'host' | 'user' | 'service' | 'generic' = 'host'
): string => {
  // Extract instance ID from ARN format if needed
  const searchIdentifier = extractInstanceIdFromArn(entityIdentifier);
  const baseContext = `Find vulnerability findings for ${entityType} "${searchIdentifier}". Look for CVE records, severity levels, and package information.`;

  switch (entityType) {
    case 'host':
      return `${baseContext} Search by host.name, host.hostname, resource.name, or resource.id matching "${searchIdentifier}".`;
    case 'user':
      return `${baseContext} Search by resource.name or resource.id matching "${searchIdentifier}".`;
    case 'service':
      return `${baseContext} Search by resource.name or resource.id matching "${searchIdentifier}".`;
    default:
      return `${baseContext} Search by resource.name or resource.id matching "${searchIdentifier}".`;
  }
};

const extractVulnerabilitiesFromResponse = (response: EsqlResponse): VulnerabilityFinding[] => {
  const jsonData = esqlResponseToJson(response);
  const findings: VulnerabilityFinding[] = [];

  for (const item of jsonData) {
    try {
      const finding: VulnerabilityFinding = {
        cve_id: item['vulnerability.id'] || item.cve_id || item.id || 'Unknown CVE',
        severity: item['vulnerability.severity'] || item.severity || 'Unknown',
        score: item['vulnerability.score.base'] || item.score || item.cvss_score,
        package_name: item['package.name'] || item.package_name,
        package_version: item['package.version'] || item.package_version,
        fix_version: item['package.fix_version'] || item.fix_version,
        resource_name:
          item['resource.name'] || item['host.name'] || item['service.name'] || 'Unknown',
        description: item['vulnerability.description'] || item.description,
        last_seen: item['@timestamp'] || item.timestamp || 'Unknown',
      };
      findings.push(finding);
    } catch (error) {
      // Skip malformed entries but continue processing
      // eslint-disable-next-line no-continue
      continue;
    }
  }

  return findings;
};

const formatVulnerabilityData = (findings: VulnerabilityFinding[]): VulnerabilityData => {
  let criticalCount = 0;
  let highCount = 0;
  let mediumCount = 0;
  let lowCount = 0;

  findings.forEach((finding) => {
    const severity = finding.severity?.toLowerCase();
    if (severity === 'critical') {
      criticalCount++;
    } else if (severity === 'high') {
      highCount++;
    } else if (severity === 'medium') {
      mediumCount++;
    } else if (severity === 'low') {
      lowCount++;
    }
  });

  return {
    total_findings: findings.length,
    critical_count: criticalCount,
    high_count: highCount,
    medium_count: mediumCount,
    low_count: lowCount,
    findings,
  };
};

const formatVulnerabilityMessage = (data: VulnerabilityData, entityIdentifier: string): string => {
  if (data.total_findings === 0) {
    return `No vulnerability findings found for ${entityIdentifier}. This could mean:
- The asset has no known vulnerabilities
- Vulnerability scanning is not enabled for this asset
- The asset identifier may not match records in the vulnerability database`;
  }

  let message = `# Vulnerability Assessment for ${entityIdentifier}\n\n`;
  message += `## Summary\n`;
  message += `- **Total Vulnerabilities**: ${data.total_findings}\n`;
  message += `- **Critical**: ${data.critical_count} vulnerabilities\n`;
  message += `- **High**: ${data.high_count} vulnerabilities\n`;
  message += `- **Medium**: ${data.medium_count} vulnerabilities\n`;
  message += `- **Low**: ${data.low_count} vulnerabilities\n\n`;

  if (data.critical_count > 0) {
    message += `## ðŸš¨ Critical Vulnerabilities (${data.critical_count})\n\n`;
    const criticalFindings = data.findings.filter((f) => f.severity?.toLowerCase() === 'critical');

    criticalFindings.slice(0, 5).forEach((finding) => {
      message += `### ${finding.cve_id}\n`;
      message += `- **Package**: ${finding.package_name || 'N/A'} ${
        finding.package_version || ''
      }\n`;
      if (finding.fix_version) {
        message += `- **Fix Available**: Version ${finding.fix_version}\n`;
      }
      if (finding.score) {
        message += `- **CVSS Score**: ${finding.score}\n`;
      }
      message += `- **Resource**: ${finding.resource_name}\n`;
      if (finding.description) {
        message += `- **Description**: ${finding.description.substring(0, 200)}${
          finding.description.length > 200 ? '...' : ''
        }\n`;
      }
      message += `- **Last Seen**: ${finding.last_seen}\n\n`;
    });

    if (criticalFindings.length > 5) {
      message += `... and ${criticalFindings.length - 5} more critical vulnerabilities.\n\n`;
    }
  }

  if (data.high_count > 0) {
    message += `## âš ï¸ High Severity Vulnerabilities (${data.high_count})\n\n`;
    const highFindings = data.findings.filter((f) => f.severity?.toLowerCase() === 'high');

    highFindings.slice(0, 3).forEach((finding) => {
      message += `### ${finding.cve_id}\n`;
      message += `- **Package**: ${finding.package_name || 'N/A'} ${
        finding.package_version || ''
      }\n`;
      if (finding.fix_version) {
        message += `- **Fix Available**: Version ${finding.fix_version}\n`;
      }
      if (finding.score) {
        message += `- **CVSS Score**: ${finding.score}\n`;
      }
      message += `- **Resource**: ${finding.resource_name}\n\n`;
    });

    if (highFindings.length > 3) {
      message += `... and ${highFindings.length - 3} more high severity vulnerabilities.\n\n`;
    }
  }

  if (data.medium_count > 0 || data.low_count > 0) {
    message += `## ðŸ“Š Additional Vulnerabilities\n`;
    if (data.medium_count > 0) {
      message += `- **Medium Severity**: ${data.medium_count} vulnerabilities\n`;
    }
    if (data.low_count > 0) {
      message += `- **Low Severity**: ${data.low_count} vulnerabilities\n`;
    }
  }

  // Add package summary
  const packageCounts = data.findings.reduce((acc, finding) => {
    if (finding.package_name) {
      acc[finding.package_name] = (acc[finding.package_name] || 0) + 1;
    }
    return acc;
  }, {} as Record<string, number>);

  if (Object.keys(packageCounts).length > 0) {
    message += `\n## ðŸ“¦ Affected Packages\n`;
    Object.entries(packageCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10)
      .forEach(([pkg, count]) => {
        message += `- **${pkg}**: ${count} vulnerabilities\n`;
      });
  }

  return message;
};

const vulnerabilitySchema = z.object({
  entityIdentifier: z
    .string()
    .describe('The identifier for the asset (hostname, IP address, service name, etc.)'),
  entityType: z
    .enum(['host', 'user', 'service', 'generic'])
    .default('host')
    .describe('The type of entity to search for vulnerabilities'),
  maxResults: z
    .number()
    .min(1)
    .max(100)
    .default(50)
    .describe('Maximum number of vulnerability findings to return'),
});

const DESCRIPTION = `Call this tool to get detailed vulnerability assessment information about a specific asset. This includes CVE details, severity levels, affected packages, and available fixes.

Use this tool when users ask about:
- Asset vulnerability status
- CVE information for an asset  
- Security vulnerabilities and patches
- Package vulnerabilities and fix versions
- Risk assessment based on vulnerability severity
- CVSS scores for asset vulnerabilities

The tool searches across vulnerability management data to provide comprehensive security insights.`;

export const ASSET_VULNERABILITY_TOOL: AssistantTool = {
  id: 'asset-vulnerability-tool',
  name: 'AssetVulnerabilityTool',
  description: DESCRIPTION,
  sourceRegister: APP_UI_ID,
  isSupported: (params: AssistantToolParams): params is VulnerabilityToolParams => {
    const { request, inference, connectorId } = params;
    return (
      requestHasRequiredAnonymizationParams(request) && inference != null && connectorId != null
    );
  },
  async getTool(params: AssistantToolParams) {
    if (!this.isSupported(params)) return null;

    const { esClient, logger, request, inference, connectorId } = params as VulnerabilityToolParams;
    if (inference == null || connectorId == null) return null;

    return tool(
      async ({ entityIdentifier, entityType = 'host', maxResults = 50 }) => {
        try {
          const extractedIdentifier = extractInstanceIdFromArn(entityIdentifier);
          logger?.info(
            `AssetVulnerabilityTool: Searching vulnerability findings for ${entityIdentifier} (type: ${entityType})${
              extractedIdentifier !== entityIdentifier
                ? ` -> extracted: ${extractedIdentifier}`
                : ''
            }`
          );

          // Use One Chat's naturalLanguageSearch with vulnerability-specific context
          const nlQuery = buildVulnerabilityQuery(entityIdentifier, entityType);

          // Use the user's selected connector from AI Assistant
          const inferenceClient = inference.getClient({ request, bindTo: { connectorId } });
          const chatModel = await inference.getChatModel({
            request,
            connectorId, // Use the connector the user selected
            chatModelOptions: {},
          });

          // Get connector details using the user's connector
          const connector = await inferenceClient.getConnectorById(connectorId);

          // Create properly typed ScopedModel
          const model = {
            connector,
            chatModel,
            inferenceClient,
          };

          const searchResults = await naturalLanguageSearch({
            nlQuery,
            context:
              'vulnerability management data with CVE information, CVSS scores, and package details',
            index: 'logs-cloud_security_posture.vulnerabilities_latest-default',
            model,
            esClient,
          });

          logger?.debug(
            `AssetVulnerabilityTool: Search completed with ${
              searchResults.values?.length || 0
            } results`
          );

          const vulnerabilityFindings = extractVulnerabilitiesFromResponse(searchResults);
          const vulnerabilityData = formatVulnerabilityData(
            vulnerabilityFindings.slice(0, maxResults)
          );

          logger?.info(
            `AssetVulnerabilityTool: Found ${vulnerabilityData.total_findings} vulnerability findings for ${entityIdentifier} (critical: ${vulnerabilityData.critical_count}, high: ${vulnerabilityData.high_count})`
          );

          const responseMessage = formatVulnerabilityMessage(vulnerabilityData, entityIdentifier);
          return responseMessage;
        } catch (error) {
          logger?.error(`AssetVulnerabilityTool error: ${error.message}`);
          logger?.error(`AssetVulnerabilityTool error stack: ${error.stack}`);
          return `Error retrieving vulnerability information for ${entityIdentifier}: ${error.message}`;
        }
      },
      {
        name: 'AssetVulnerabilityTool',
        description: DESCRIPTION,
        schema: vulnerabilitySchema,
      }
    );
  },
};
