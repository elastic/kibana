/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import type { Logger } from '@kbn/core/server';
import { schema } from '@kbn/config-schema';
import axios from 'axios';
import { transformError } from '@kbn/securitysolution-es-utils';
import { buildSiemResponse } from '@kbn/lists-plugin/server/routes/utils';
import type { SecuritySolutionPluginRouter } from '../../../types';
import { APP_ID } from '../../../../common/constants';
import { malwareAnalysisResultSavedObjectType } from '../saved_object_mappings';

const MALWARE_ANALYSIS_BASE_ROUTE = '/api/security_solution/malware_analysis';

/**
 * Configuration for the malware analysis orchestrator (Arbiter)
 */
export interface MalwareAnalysisConfig {
  /**
   * URL of the malware analysis orchestrator service (e.g., 'http://localhost:8080')
   */
  orchestratorUrl: string;
  /**
   * API token for authenticating with the orchestrator
   */
  apiToken?: string;
  /**
   * Request timeout in milliseconds
   */
  timeout?: number;
}

/**
 * Creates an axios client configured for the malware analysis orchestrator
 */
const createOrchestratorClient = (config: MalwareAnalysisConfig) => {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  if (config.apiToken) {
    headers.Authorization = `Bearer ${config.apiToken}`;
  }

  return axios.create({
    baseURL: config.orchestratorUrl,
    timeout: config.timeout ?? 30000,
    headers,
  });
};

/**
 * Registers routes for proxying requests to the malware analysis orchestrator (Arbiter).
 *
 * The orchestrator provides AI-powered reverse engineering and malware analysis.
 * See: https://github.com/elastic/malware_agent
 *
 * @param router - The Kibana router
 * @param logger - Logger instance
 * @param config - Malware analysis configuration
 */
export const registerMalwareAnalysisRoutes = (
  router: SecuritySolutionPluginRouter,
  logger: Logger,
  config: MalwareAnalysisConfig
) => {
  const orchestratorClient = createOrchestratorClient(config);

  /**
   * POST /api/security_solution/malware_analysis/submit
   *
   * Submits a sample for malware analysis.
   *
   * Request body:
   * - sha256: SHA256 hash of the sample (required)
   * - data: Base64-encoded binary data (optional, if not provided downloads from VirusTotal)
   * - iterations: Max agent iterations (optional, default: 100)
   * - context: Additional context for the LLM analysis (optional)
   *
   * Response:
   * - task_id: Unique task identifier
   * - sha256: SHA256 of the sample
   * - status: 'queued' | 'downloading' | 'running' | 'completed' | 'failed'
   * - created_at: Timestamp
   * - error: Error message if failed
   */
  router.versioned
    .post({
      access: 'internal',
      path: `${MALWARE_ANALYSIS_BASE_ROUTE}/submit`,
      security: {
        authz: {
          requiredPrivileges: ['securitySolution', `${APP_ID}-entity-analytics`],
        },
      },
      options: { authRequired: true },
    })
    .addVersion(
      {
        version: '1',
        validate: {
          request: {
            body: schema.object({
              sha256: schema.string({ minLength: 64, maxLength: 64 }),
              data: schema.maybe(schema.string()), // Base64-encoded binary
              iterations: schema.maybe(schema.number({ min: 1, max: 500 })),
              context: schema.maybe(schema.string({ maxLength: 10000 })),
            }),
          },
        },
      },
      async (context, request, response) => {
        const siemResponse = buildSiemResponse(response);

        try {
          logger.debug(
            `Submitting sample for malware analysis: ${request.body.sha256.substring(0, 16)}...`
          );

          const orchestratorResponse = await orchestratorClient.post('/api/submit', request.body);

          return response.ok({
            body: {
              task_id: orchestratorResponse.data.task_id,
              sha256: orchestratorResponse.data.sha256,
              status: orchestratorResponse.data.status,
              created_at: orchestratorResponse.data.created_at,
              error: orchestratorResponse.data.error,
            },
          });
        } catch (err) {
          const error = transformError(err);
          logger.error(`Failed to submit sample for malware analysis: ${error.message}`);

          // Handle specific orchestrator errors
          if (axios.isAxiosError(err)) {
            const statusCode = err.response?.status ?? 500;
            const message =
              typeof err.response?.data?.error === 'string' ? err.response.data.error : err.message;
            return siemResponse.error({ statusCode, body: message });
          }

          return siemResponse.error({
            statusCode: error.statusCode,
            body: error.message,
          });
        }
      }
    );

  /**
   * GET /api/security_solution/malware_analysis/status/{taskId}
   *
   * Gets the status of a malware analysis task.
   *
   * Response:
   * - task_id: Unique task identifier
   * - sha256: SHA256 of the sample
   * - status: 'queued' | 'downloading' | 'running' | 'completed' | 'failed'
   * - created_at: Timestamp when created
   * - started_at: Timestamp when started
   * - completed_at: Timestamp when completed
   * - error: Error message if failed
   */
  router.versioned
    .get({
      access: 'internal',
      path: `${MALWARE_ANALYSIS_BASE_ROUTE}/status/{taskId}`,
      security: {
        authz: {
          requiredPrivileges: ['securitySolution'],
        },
      },
      options: { authRequired: true },
    })
    .addVersion(
      {
        version: '1',
        validate: {
          request: {
            params: schema.object({
              taskId: schema.string({ minLength: 1 }),
            }),
          },
        },
      },
      async (context, request, response) => {
        const siemResponse = buildSiemResponse(response);
        const { taskId } = request.params;

        try {
          logger.debug(`Checking malware analysis status for task: ${taskId}`);

          const orchestratorResponse = await orchestratorClient.get(`/api/status/${taskId}`);

          return response.ok({
            body: {
              task_id: orchestratorResponse.data.task_id,
              sha256: orchestratorResponse.data.sha256,
              status: orchestratorResponse.data.status,
              created_at: orchestratorResponse.data.created_at,
              started_at: orchestratorResponse.data.started_at,
              completed_at: orchestratorResponse.data.completed_at,
              error: orchestratorResponse.data.error,
              current_iteration: orchestratorResponse.data.current_iteration ?? null,
              max_iterations: orchestratorResponse.data.max_iterations ?? null,
            },
          });
        } catch (err) {
          const error = transformError(err);
          logger.error(`Failed to get malware analysis status: ${error.message}`);

          if (axios.isAxiosError(err) && err.response?.status === 404) {
            return siemResponse.error({ statusCode: 404, body: 'Task not found' });
          }

          if (axios.isAxiosError(err)) {
            const statusCode = err.response?.status ?? 500;
            const message =
              typeof err.response?.data?.error === 'string' ? err.response.data.error : err.message;
            return siemResponse.error({ statusCode, body: message });
          }

          return siemResponse.error({
            statusCode: error.statusCode,
            body: error.message,
          });
        }
      }
    );

  /**
   * GET /api/security_solution/malware_analysis/results/{taskId}
   *
   * Gets the results of a completed malware analysis task.
   *
   * Response:
   * - task_id: Unique task identifier
   * - sha256: SHA256 of the sample
   * - status: 'queued' | 'downloading' | 'running' | 'completed' | 'failed'
   * - analysis: The AI-generated analysis report (markdown formatted)
   * - error: Error message if failed
   * - stats: Token usage and cost statistics
   *   - cost_usd: Estimated cost in USD
   *   - input_tokens: Number of input tokens used
   *   - output_tokens: Number of output tokens generated
   */
  router.versioned
    .get({
      access: 'internal',
      path: `${MALWARE_ANALYSIS_BASE_ROUTE}/results/{taskId}`,
      security: {
        authz: {
          requiredPrivileges: ['securitySolution'],
        },
      },
      options: { authRequired: true },
    })
    .addVersion(
      {
        version: '1',
        validate: {
          request: {
            params: schema.object({
              taskId: schema.string({ minLength: 1 }),
            }),
          },
        },
      },
      async (context, request, response) => {
        const siemResponse = buildSiemResponse(response);
        const { taskId } = request.params;

        try {
          logger.debug(`Getting malware analysis results for task: ${taskId}`);

          const orchestratorResponse = await orchestratorClient.get(`/api/results/${taskId}`);

          return response.ok({
            body: {
              task_id: orchestratorResponse.data.task_id,
              sha256: orchestratorResponse.data.sha256,
              status: orchestratorResponse.data.status,
              analysis: orchestratorResponse.data.analysis,
              error: orchestratorResponse.data.error,
              stats: orchestratorResponse.data.stats
                ? {
                    cost_usd: orchestratorResponse.data.stats.cost_usd,
                    input_tokens: orchestratorResponse.data.stats.input_tokens,
                    output_tokens: orchestratorResponse.data.stats.output_tokens,
                  }
                : undefined,
            },
          });
        } catch (err) {
          const error = transformError(err);
          logger.error(`Failed to get malware analysis results: ${error.message}`);

          if (axios.isAxiosError(err) && err.response?.status === 404) {
            return siemResponse.error({ statusCode: 404, body: 'Task not found' });
          }

          if (axios.isAxiosError(err)) {
            const statusCode = err.response?.status ?? 500;
            const message =
              typeof err.response?.data?.error === 'string' ? err.response.data.error : err.message;
            return siemResponse.error({ statusCode, body: message });
          }

          return siemResponse.error({
            statusCode: error.statusCode,
            body: error.message,
          });
        }
      }
    );

  // ─── Cache routes ───────────────────────────────────────────────────────────
  // These routes persist analysis results in Kibana saved objects so that
  // results are displayed immediately on subsequent visits without needing
  // to re-run the analysis. Users can still regenerate on demand.

  /**
   * GET /api/security_solution/malware_analysis/cache/{alertId}
   *
   * Finds a cached malware analysis result for the given alert ID.
   */
  router.versioned
    .get({
      access: 'internal',
      path: `${MALWARE_ANALYSIS_BASE_ROUTE}/cache/{alertId}`,
      security: {
        authz: {
          requiredPrivileges: ['securitySolution'],
        },
      },
      options: { authRequired: true },
    })
    .addVersion(
      {
        version: '1',
        validate: {
          request: {
            params: schema.object({
              alertId: schema.string({ minLength: 1 }),
            }),
          },
        },
      },
      async (context, request, response) => {
        const siemResponse = buildSiemResponse(response);
        const { alertId } = request.params;

        try {
          const coreContext = await context.core;
          const soClient = coreContext.savedObjects.client;

          const result = await soClient.find({
            type: malwareAnalysisResultSavedObjectType,
            filter: `${malwareAnalysisResultSavedObjectType}.attributes.alert_id: "${alertId}"`,
            perPage: 1,
            sortField: 'updated_at',
            sortOrder: 'desc',
          });

          if (result.total === 0) {
            return response.ok({
              body: { found: false },
            });
          }

          const attrs = result.saved_objects[0].attributes as Record<string, unknown>;
          return response.ok({
            body: {
              found: true,
              id: result.saved_objects[0].id,
              alert_id: attrs.alert_id,
              sha256: attrs.sha256,
              task_id: attrs.task_id,
              status: attrs.status,
              analysis: attrs.analysis,
              error: attrs.error,
              stats: {
                cost_usd: attrs.cost_usd,
                input_tokens: attrs.input_tokens,
                output_tokens: attrs.output_tokens,
              },
              created_at: attrs.created_at,
              updated_at: attrs.updated_at,
            },
          });
        } catch (err) {
          const error = transformError(err);
          logger.error(`Failed to fetch cached malware analysis result: ${error.message}`);
          return siemResponse.error({
            statusCode: error.statusCode,
            body: error.message,
          });
        }
      }
    );

  /**
   * POST /api/security_solution/malware_analysis/cache
   *
   * Saves or updates a cached malware analysis result.
   * If a result already exists for the alert ID, it is updated.
   */
  router.versioned
    .post({
      access: 'internal',
      path: `${MALWARE_ANALYSIS_BASE_ROUTE}/cache`,
      security: {
        authz: {
          requiredPrivileges: ['securitySolution'],
        },
      },
      options: { authRequired: true },
    })
    .addVersion(
      {
        version: '1',
        validate: {
          request: {
            body: schema.object({
              alert_id: schema.string({ minLength: 1 }),
              sha256: schema.string({ minLength: 1 }),
              task_id: schema.string({ minLength: 1 }),
              status: schema.string(),
              analysis: schema.maybe(schema.string()),
              error: schema.maybe(schema.string()),
              stats: schema.maybe(
                schema.object({
                  cost_usd: schema.maybe(schema.number()),
                  input_tokens: schema.maybe(schema.number()),
                  output_tokens: schema.maybe(schema.number()),
                })
              ),
            }),
          },
        },
      },
      async (context, request, response) => {
        const siemResponse = buildSiemResponse(response);

        try {
          const coreContext = await context.core;
          const soClient = coreContext.savedObjects.client;
          const {
            alert_id: alertId,
            sha256,
            task_id: taskId,
            status,
            analysis,
            error: analysisError,
            stats,
          } = request.body;
          const now = new Date().toISOString();

          // Check if a cached result already exists for this alert
          const existing = await soClient.find({
            type: malwareAnalysisResultSavedObjectType,
            filter: `${malwareAnalysisResultSavedObjectType}.attributes.alert_id: "${alertId}"`,
            perPage: 1,
          });

          const attributes = {
            alert_id: alertId,
            sha256,
            task_id: taskId,
            status,
            analysis: analysis ?? '',
            error: analysisError ?? '',
            cost_usd: stats?.cost_usd ?? 0,
            input_tokens: stats?.input_tokens ?? 0,
            output_tokens: stats?.output_tokens ?? 0,
            updated_at: now,
          };

          if (existing.total > 0) {
            // Update existing cached result
            const existingId = existing.saved_objects[0].id;
            await soClient.update(malwareAnalysisResultSavedObjectType, existingId, attributes);

            return response.ok({
              body: { id: existingId, created: false },
            });
          }

          // Create new cached result
          const created = await soClient.create(malwareAnalysisResultSavedObjectType, {
            ...attributes,
            created_at: now,
          });

          return response.ok({
            body: { id: created.id, created: true },
          });
        } catch (err) {
          const error = transformError(err);
          logger.error(`Failed to save cached malware analysis result: ${error.message}`);
          return siemResponse.error({
            statusCode: error.statusCode,
            body: error.message,
          });
        }
      }
    );

  logger.info(`Malware analysis routes registered. Orchestrator URL: ${config.orchestratorUrl}`);
};
