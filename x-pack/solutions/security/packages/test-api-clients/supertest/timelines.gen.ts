/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 *
 * info:
 *   title: Timelines API client for tests
 *   version: Bundle (no version)
 */

import {
  ELASTIC_HTTP_VERSION_HEADER,
  X_ELASTIC_INTERNAL_ORIGIN_REQUEST,
} from '@kbn/core-http-common';

import type { CleanDraftTimelinesRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/clean_draft_timelines/clean_draft_timelines_route.gen';
import type { CopyTimelineRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/copy_timeline/copy_timeline_route.gen';
import type { CreateTimelinesRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/create_timelines/create_timelines_route.gen';
import type { DeleteNoteRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/delete_note/delete_note_route.gen';
import type { DeleteTimelinesRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/delete_timelines/delete_timelines_route.gen';
import type {
  ExportTimelinesRequestQueryInput,
  ExportTimelinesRequestBodyInput,
} from '@kbn/security-solution-plugin/common/api/timeline/export_timelines/export_timelines_route.gen';
import type { GetDraftTimelinesRequestQueryInput } from '@kbn/security-solution-plugin/common/api/timeline/get_draft_timelines/get_draft_timelines_route.gen';
import type { GetNotesRequestQueryInput } from '@kbn/security-solution-plugin/common/api/timeline/get_notes/get_notes_route.gen';
import type { GetTimelineRequestQueryInput } from '@kbn/security-solution-plugin/common/api/timeline/get_timeline/get_timeline_route.gen';
import type { GetTimelinesRequestQueryInput } from '@kbn/security-solution-plugin/common/api/timeline/get_timelines/get_timelines_route.gen';
import type { ImportTimelinesRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/import_timelines/import_timelines_route.gen';
import type { InstallPrepackedTimelinesRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/install_prepackaged_timelines/install_prepackaged_timelines_route.gen';
import type { PatchTimelineRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/patch_timelines/patch_timeline_route.gen';
import type { PersistFavoriteRouteRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/persist_favorite/persist_favorite_route.gen';
import type { PersistNoteRouteRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/persist_note/persist_note_route.gen';
import type { PersistPinnedEventRouteRequestBodyInput } from '@kbn/security-solution-plugin/common/api/timeline/pinned_events/pinned_events_route.gen';
import type { ResolveTimelineRequestQueryInput } from '@kbn/security-solution-plugin/common/api/timeline/resolve_timeline/resolve_timeline_route.gen';

import type { FtrProviderContext } from '@kbn/ftr-common-functional-services';
import { getRouteUrlForSpace } from '@kbn/spaces-plugin/common';

export function SecuritySolutionApiProvider({ getService }: FtrProviderContext) {
  const supertest = getService('supertest');

  return {
    /**
      * Create a clean draft Timeline or Timeline template for the current user.
> info
> If the user already has a draft Timeline, the existing draft Timeline is cleared and returned.

      */
    cleanDraftTimelines(props: CleanDraftTimelinesProps, kibanaSpace: string = 'default') {
      return supertest
        .post(getRouteUrlForSpace('/api/timeline/_draft', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    /**
      * Copies and returns a timeline or timeline template.

      */
    copyTimeline(props: CopyTimelineProps, kibanaSpace: string = 'default') {
      return supertest
        .get(getRouteUrlForSpace('/api/timeline/_copy', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    /**
     * Create a new Timeline or Timeline template.
     */
    createTimelines(props: CreateTimelinesProps, kibanaSpace: string = 'default') {
      return supertest
        .post(getRouteUrlForSpace('/api/timeline', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    /**
     * Delete a note from a Timeline using the note ID.
     */
    deleteNote(props: DeleteNoteProps, kibanaSpace: string = 'default') {
      return supertest
        .delete(getRouteUrlForSpace('/api/note', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    /**
     * Delete one or more Timelines or Timeline templates.
     */
    deleteTimelines(props: DeleteTimelinesProps, kibanaSpace: string = 'default') {
      return supertest
        .delete(getRouteUrlForSpace('/api/timeline', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    /**
     * Export Timelines as an NDJSON file.
     */
    exportTimelines(props: ExportTimelinesProps, kibanaSpace: string = 'default') {
      return supertest
        .post(getRouteUrlForSpace('/api/timeline/_export', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object)
        .query(props.query);
    },
    /**
     * Get the details of the draft Timeline  or Timeline template for the current user. If the user doesn't have a draft Timeline, an empty Timeline is returned.
     */
    getDraftTimelines(props: GetDraftTimelinesProps, kibanaSpace: string = 'default') {
      return supertest
        .get(getRouteUrlForSpace('/api/timeline/_draft', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .query(props.query);
    },
    /**
     * Get all notes for a given document.
     */
    getNotes(props: GetNotesProps, kibanaSpace: string = 'default') {
      return supertest
        .get(getRouteUrlForSpace('/api/note', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .query(props.query);
    },
    /**
     * Get the details of an existing saved Timeline or Timeline template.
     */
    getTimeline(props: GetTimelineProps, kibanaSpace: string = 'default') {
      return supertest
        .get(getRouteUrlForSpace('/api/timeline', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .query(props.query);
    },
    /**
     * Get a list of all saved Timelines or Timeline templates.
     */
    getTimelines(props: GetTimelinesProps, kibanaSpace: string = 'default') {
      return supertest
        .get(getRouteUrlForSpace('/api/timelines', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .query(props.query);
    },
    /**
     * Import Timelines.
     */
    importTimelines(props: ImportTimelinesProps, kibanaSpace: string = 'default') {
      return supertest
        .post(getRouteUrlForSpace('/api/timeline/_import', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    /**
     * Install or update prepackaged Timelines.
     */
    installPrepackedTimelines(
      props: InstallPrepackedTimelinesProps,
      kibanaSpace: string = 'default'
    ) {
      return supertest
        .post(getRouteUrlForSpace('/api/timeline/_prepackaged', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    /**
     * Update an existing Timeline. You can update the title, description, date range, pinned events, pinned queries, and/or pinned saved queries of an existing Timeline.
     */
    patchTimeline(props: PatchTimelineProps, kibanaSpace: string = 'default') {
      return supertest
        .patch(getRouteUrlForSpace('/api/timeline', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    /**
     * Favorite a Timeline or Timeline template for the current user.
     */
    persistFavoriteRoute(props: PersistFavoriteRouteProps, kibanaSpace: string = 'default') {
      return supertest
        .patch(getRouteUrlForSpace('/api/timeline/_favorite', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    /**
     * Add a note to a Timeline or update an existing note.
     */
    persistNoteRoute(props: PersistNoteRouteProps, kibanaSpace: string = 'default') {
      return supertest
        .patch(getRouteUrlForSpace('/api/note', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    /**
     * Pin/unpin an event to/from an existing Timeline.
     */
    persistPinnedEventRoute(props: PersistPinnedEventRouteProps, kibanaSpace: string = 'default') {
      return supertest
        .patch(getRouteUrlForSpace('/api/pinned_event', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .send(props.body as object);
    },
    resolveTimeline(props: ResolveTimelineProps, kibanaSpace: string = 'default') {
      return supertest
        .get(getRouteUrlForSpace('/api/timeline/resolve', kibanaSpace))
        .set('kbn-xsrf', 'true')
        .set(ELASTIC_HTTP_VERSION_HEADER, '2023-10-31')
        .set(X_ELASTIC_INTERNAL_ORIGIN_REQUEST, 'kibana')
        .query(props.query);
    },
  };
}

export interface CleanDraftTimelinesProps {
  body: CleanDraftTimelinesRequestBodyInput;
}
export interface CopyTimelineProps {
  body: CopyTimelineRequestBodyInput;
}
export interface CreateTimelinesProps {
  body: CreateTimelinesRequestBodyInput;
}
export interface DeleteNoteProps {
  body: DeleteNoteRequestBodyInput;
}
export interface DeleteTimelinesProps {
  body: DeleteTimelinesRequestBodyInput;
}
export interface ExportTimelinesProps {
  query: ExportTimelinesRequestQueryInput;
  body: ExportTimelinesRequestBodyInput;
}
export interface GetDraftTimelinesProps {
  query: GetDraftTimelinesRequestQueryInput;
}
export interface GetNotesProps {
  query: GetNotesRequestQueryInput;
}
export interface GetTimelineProps {
  query: GetTimelineRequestQueryInput;
}
export interface GetTimelinesProps {
  query: GetTimelinesRequestQueryInput;
}
export interface ImportTimelinesProps {
  body: ImportTimelinesRequestBodyInput;
}
export interface InstallPrepackedTimelinesProps {
  body: InstallPrepackedTimelinesRequestBodyInput;
}
export interface PatchTimelineProps {
  body: PatchTimelineRequestBodyInput;
}
export interface PersistFavoriteRouteProps {
  body: PersistFavoriteRouteRequestBodyInput;
}
export interface PersistNoteRouteProps {
  body: PersistNoteRouteRequestBodyInput;
}
export interface PersistPinnedEventRouteProps {
  body: PersistPinnedEventRouteRequestBodyInput;
}
export interface ResolveTimelineProps {
  query: ResolveTimelineRequestQueryInput;
}
