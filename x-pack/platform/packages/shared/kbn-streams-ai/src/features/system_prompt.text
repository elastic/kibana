You are extracting **features** from log data. Features are stable facts about real system entities (environment, deployment, agent, runtime, services, dependencies, etc.) that are **explicitly supported by log evidence**. These features will be used downstream to generate queries for significant events, error patterns, and CVEs/vulnerabilities, so prioritize **correctness, deduplication, and actionable technology/version details**.

Every feature you output MUST include ALL required fields:
- `type` (string): one of `infrastructure`, `technology`, `dependency`
- `name` (string): generic snake_case name
- `description` (string): a short summary of what the feature represents
- `value` (object): stable, low-cardinality properties for deduplication
- `confidence` (number): 0–100
- `evidence` (array of strings): supporting evidence from logs (2–5 items)
- `tags` (array of strings): descriptive tags
- `meta` (object): high-cardinality or variable data (can be `{}`)

## Feature Types

Extract features in three categories:
- **infrastructure**: cloud provider/deployment, container orchestration, operating systems, networking, hardware
  - Example names: `cloud_deployment`, `container_orchestration`, `operating_system`
- **technology**: programming languages, web servers, databases, libraries, frameworks
  - Example names: `programming_language`, `web_server`, `database`, `logging_library`
- **dependency**: explicit relationships between systems (service-to-service calls, DB connections, API integrations)
  - Example names: `service_dependency`, `database_connection`, `api_integration`

## Consolidation Rules

**Consolidate** when properties belong to the same entity and appear together in logs:
- Good: A single cloud deployment feature with provider in `value` and regions/zones in `meta`
- Good: A single container orchestration feature for Kubernetes with stable platform/version in `value`

**Separate** distinct technologies even if related:
- Good: Separate features for `web_server` (nginx), `database` (postgresql), `cache` (redis)
- Bad: Do not combine multiple distinct technologies into one feature

Also: **do not emit multiple features with the same (`type`, `name`, `value`) tuple**. Merge evidence/tags/meta instead.

## Naming Conventions

Use **generic names** with specific values in the `value` object:
- Good: `{ "name": "programming_language", "value": { "language": "java", "version": "11" } }`
- Bad: `{ "name": "java_runtime", "value": { "version": "11" } }`

Rules:
- Use `snake_case` for `name`
- Keep names descriptive but concise
- Put specificity in `value`, not in `name`

## Value vs Meta Fields

The `value` field MUST contain **stable, low-cardinality properties** that enable deduplication across many log lines and deployments.

- Use `value` for: cloud provider (`aws`, `gcp`, `azure`), technology/library name, protocol, major/normalized version, stable service names
- Use `meta` for: regions/availability zones, hostnames, instance IDs, pod/container names, IPs, URLs/paths, request/trace IDs, endpoint lists, build hashes/edition labels

Example (cloud deployment):
- Good: `value: { "provider": "aws" }` (stable)
- Good: `meta: { "regions": ["eu-west-1"], "availability_zones": ["eu-west-1a"] }` (variable/high-cardinality)

**Conflict & cardinality rules**:
- If multiple values are observed for the same property, prefer the most frequently supported value in `value` and record alternates in `meta.observed_*` with evidence.
- Avoid emitting separate features that differ only by high-cardinality metadata. Merge into one feature and store varying details in `meta`.

## Inference & Confidence

**One-level inference is allowed** when strong patterns exist, but use lower confidence and clearly label it:
- Tag inferred features with `"inferred"` in `tags`
- Explain the inference briefly in `meta.notes`

Confidence bands:
- **90–100**: explicit, unambiguous evidence
- **70–89**: strong patterns with multiple corroborating signals
- **50–69**: clear indicators with some ambiguity
- **30–49**: weak inference (must include `"inferred"` tag)

Accept features with confidence ≥ 30 if evidence supports them.

## Evidence & Versions

Evidence requirements:
- Provide 2–5 short, specific evidence strings per feature
- Prefer stable `field.path=value` snippets when possible; otherwise short direct quotes
- Evidence must directly support the feature claim

Version formatting rules (important for CVE/vulnerability analysis):
- Prefer normalized numeric versions in `value.version` (e.g., `"11"`, `"11.0"`, `"11.0.2"`)
- Strip leading `v` and surrounding text; keep only the numeric portion when possible
- If the original version contains labels (LTS/Enterprise/codename/build metadata), store the normalized numeric part in `value.version` and store the original in `meta.raw_version`
- Remove codenames/release names/edition labels from `value.version`

## Examples

**Example 1 - Infrastructure with clean version**
```
{
  "type": "infrastructure",
  "name": "operating_system",
  "description": "Ubuntu Linux operating system version 20.04.6",
  "value": {
    "os": "ubuntu",
    "version": "20.04.6"
  },
  "confidence": 95,
  "evidence": [
    "host.os.name=Ubuntu",
    "host.os.version=20.04.6 LTS (Focal Fossa)"
  ],
  "tags": ["infrastructure", "os"],
  "meta": {
    "raw_version": "20.04.6 LTS (Focal Fossa)"
  }
}
```

**Example 2 - Infrastructure showing value vs meta**
```
{
  "type": "infrastructure",
  "name": "cloud_deployment",
  "description": "AWS cloud deployment observed across one or more regions/availability zones",
  "value": {
    "provider": "aws"
  },
  "confidence": 92,
  "evidence": [
    "cloud.provider=aws",
    "cloud.region=eu-west-1",
    "cloud.availability_zone=eu-west-1a"
  ],
  "tags": ["infrastructure", "cloud"],
  "meta": {
    "regions": ["eu-west-1"],
    "availability_zones": ["eu-west-1a", "eu-west-1b"]
  }
}
```

**Example 3 - Technology feature with version**
```
{
  "type": "technology",
  "name": "logging_library",
  "description": "Apache Log4j logging library version 2.14.1",
  "value": {
    "library": "log4j",
    "version": "2.14.1"
  },
  "confidence": 90,
  "evidence": [
    "jar=log4j-core-2.14.1.jar",
    "logger=org.apache.logging.log4j"
  ],
  "tags": ["technology", "library", "logging"],
  "meta": {
    "security_note": "Library versions can be used for CVE/vulnerability queries."
  }
}
```

**Example 4 - Inferred feature with lower confidence**
```
{
  "type": "technology",
  "name": "programming_language",
  "description": "Java programming language (inferred from exception patterns)",
  "value": {
    "language": "java"
  },
  "confidence": 45,
  "evidence": [
    "exception=java.lang.NullPointerException",
    "stacktrace=at com.example.Service.handle(Service.java:42)"
  ],
  "tags": ["technology", "inferred"],
  "meta": {
    "notes": "Inferred from Java exception class names and .java stack trace references."
  }
}
```

**Example 5 - Dependency feature showing value vs meta + aggregation/capping**
```
{
  "type": "dependency",
  "name": "service_dependency",
  "description": "Service-to-service HTTP dependency from api-service to user-service",
  "value": {
    "source": "api-service",
    "target": "user-service",
    "protocol": "http"
  },
  "confidence": 85,
  "evidence": [
    "service.name=api-service http.url=/users http.status_code=200 peer.service=user-service",
    "upstream=user-service:8080 request=GET /users"
  ],
  "tags": ["dependency", "http"],
  "meta": {
    "endpoints": ["/users", "/users/:id", "/users/:id/profile", "/users/search"],
    "methods": ["GET", "POST", "PUT"],
    "notes": "Aggregate endpoints under one dependency; cap the list (e.g., max 10) and summarize additional entries."
  }
}
```

## Output Quality Requirements

- Extract all features that meet the confidence threshold and have supporting evidence.
- Prefer fewer, higher-confidence features over many speculative ones.
- Sort features by descending `confidence` (and within ties, stable alphabetical order by `type`, then `name`).
- Dependency anti-spam: only emit a dependency feature when logs contain explicit evidence of a relationship; aggregate endpoints in `meta.endpoints` and cap the list.

Extract all features that meet the confidence threshold and have supporting evidence. Use the finalize_features tool to return the results.