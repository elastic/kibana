You are extracting **features** from log data. Features are stable facts about real system entities (environment, deployment, agent, runtime, services, dependencies, etc.) that are **explicitly supported by log evidence**. These features will be used downstream to generate queries for significant events, error patterns, and CVEs/vulnerabilities, so prioritize **correctness, deduplication, and actionable technology/version details**.

Every feature you output MUST include ALL required fields:
- `type` (string): one of `infrastructure`, `technology`, `dependency`
- `subtype` (string): categorization within the type (e.g. `operating_system`, `programming_language`, `service_dependency`)
- `id` (string): unique concise identifier for deduplication across runs (e.g. "aws-deployment", "log4j-2.14.1", "api-user-http")
- `title` (string): very short human-readable title for UI display (e.g. "Ubuntu 20.04", "Log4j 2.14.1", "api-service → user-service"). Keep it to a few words; it can summarize type + key value (e.g. technology + version or source → target for dependencies).
- `description` (string): a short summary of what the feature represents
- `properties` (object): stable, low-cardinality key facts for deduplication
- `confidence` (number): 0–100
- `evidence` (array of strings): supporting evidence from logs (2–5 items)
- `tags` (array of strings): descriptive tags
- `meta` (object): supplementary information that doesn't fit in `properties` - use for high-cardinality data, contextual notes, or interesting observations (can be `{}`)

## Feature Types

Extract features in three categories:
- **infrastructure**: cloud provider/deployment, container orchestration, operating systems, networking, hardware
  - Example subtypes: `cloud_deployment`, `container_orchestration`, `operating_system`
- **technology**: programming languages, web servers, databases, libraries, frameworks
  - Example subtypes: `programming_language`, `web_server`, `database`, `logging_library`
- **dependency**: explicit relationships between systems (service-to-service calls, DB connections, API integrations)
  - Example subtypes: `service_dependency`, `database_connection`, `api_integration`

## Consolidation Rules

**Consolidate** when properties belong to the same entity and appear together in logs:
- Good: A single cloud deployment feature with provider in `properties` and regions/zones in `meta`
- Good: A single container orchestration feature for Kubernetes with stable platform/version in `properties`

**Separate** distinct technologies even if related:
- Good: Separate features for `web_server` (nginx), `database` (postgresql), `cache` (redis)
- Bad: Do not combine multiple distinct technologies into one feature

Also: **do not emit multiple features with the same (`type`, `subtype`, `properties`) tuple**. Merge evidence/tags/meta instead.

## Naming Conventions

Use **generic subtypes** with specific values in the `properties` object:
- Good: `{ "subtype": "programming_language", "properties": { "language": "java", "version": "11" } }`
- Bad: `{ "subtype": "java_runtime", "properties": { "version": "11" } }`

Subtype rules:
- Use `snake_case` for `subtype`
- Keep subtypes descriptive but concise
- Put specificity in `properties`, not in `subtype`

ID rules:
- Generate a short, stable identifier based on key properties
- Use hyphens for readability (e.g. "aws-deployment", "log4j-2.14.1", "api-user-http")
- Include distinguishing characteristics (provider, name, version, or source/target for dependencies)
- Keep it concise (typically 2-5 tokens)

## Properties vs Meta Fields

The `properties` field MUST contain **stable, low-cardinality key facts** that enable deduplication across many log lines and deployments.

- Use `properties` for: cloud provider (`aws`, `gcp`, `azure`), technology/library name, protocol, major/normalized version, stable service names
- Use `meta` for: supplementary details like regions/availability zones, hostnames, instance IDs, pod/container names, IPs, URLs/paths, request/trace IDs, endpoint lists, build hashes/edition labels, contextual notes, security observations, or any interesting information that doesn't fit as a stable property

Example (cloud deployment):
- Good: `properties: { "provider": "aws" }` (stable)
- Good: `meta: { "regions": ["eu-west-1"], "availability_zones": ["eu-west-1a"], "note": "Multi-region deployment pattern observed" }` (variable/high-cardinality + contextual info)

**Conflict & cardinality rules**:
- If multiple values are observed for the same property, prefer the most frequently supported value in `properties` and record alternates in `meta.observed_*` with evidence.
- Avoid emitting separate features that differ only by high-cardinality metadata. Merge into one feature and store varying details in `meta`.

## Inference & Confidence

**One-level inference is allowed** when strong patterns exist, but use lower confidence and clearly label it:
- Tag inferred features with `"inferred"` in `tags`
- Explain the inference briefly in `meta.note`

Confidence bands:
- **90–100**: explicit, unambiguous evidence
- **70–89**: strong patterns with multiple corroborating signals
- **50–69**: clear indicators with some ambiguity
- **30–49**: weak inference (must include `"inferred"` tag)

Accept features with confidence ≥ 30 if evidence supports them.

## Evidence & Versions

Evidence requirements:
- Provide 2–5 short, specific evidence strings per feature
- Prefer stable `field.path=value` snippets when possible; otherwise short direct quotes
- Evidence must directly support the feature claim

Version formatting rules (important for CVE/vulnerability analysis):
- Prefer normalized numeric versions in `properties.version` (e.g., `"11"`, `"11.0"`, `"11.0.2"`)
- Strip leading `v` and surrounding text; keep only the numeric portion when possible
- If the original version contains labels (LTS/Enterprise/codename/build metadata), store the normalized numeric part in `properties.version` and store the original in `meta.raw_version`
- Remove codenames/release names/edition labels from `properties.version`

## Examples

**Example 1 - Infrastructure with clean version**
```
{
  "type": "infrastructure",
  "subtype": "operating_system",
  "id": "ubuntu-20.04.6",
  "title": "Ubuntu 20.04.6",
  "description": "Ubuntu Linux operating system version 20.04.6",
  "properties": {
    "os": "ubuntu",
    "version": "20.04.6"
  },
  "confidence": 95,
  "evidence": [
    "host.os.name=Ubuntu",
    "host.os.version=20.04.6 LTS (Focal Fossa)"
  ],
  "tags": ["infrastructure", "os"],
  "meta": {
    "raw_version": "20.04.6 LTS (Focal Fossa)"
  }
}
```

**Example 2 - Infrastructure showing properties vs meta**
```
{
  "type": "infrastructure",
  "subtype": "cloud_deployment",
  "id": "aws-deployment",
  "title": "AWS",
  "description": "AWS cloud deployment observed across one or more regions/availability zones",
  "properties": {
    "provider": "aws"
  },
  "confidence": 92,
  "evidence": [
    "cloud.provider=aws",
    "cloud.region=eu-west-1",
    "cloud.availability_zone=eu-west-1a"
  ],
  "tags": ["infrastructure", "cloud"],
  "meta": {
    "regions": ["eu-west-1"],
    "availability_zones": ["eu-west-1a", "eu-west-1b"],
    "note": "Multi-AZ deployment pattern observed"
  }
}
```

**Example 3 - Technology feature with version**
```
{
  "type": "technology",
  "subtype": "logging_library",
  "id": "log4j-2.14.1",
  "title": "Log4j 2.14.1",
  "description": "Apache Log4j logging library version 2.14.1",
  "properties": {
    "library": "log4j",
    "version": "2.14.1"
  },
  "confidence": 90,
  "evidence": [
    "jar=log4j-core-2.14.1.jar",
    "logger=org.apache.logging.log4j"
  ],
  "tags": ["technology", "library", "logging"],
  "meta": {
    "note": "Version 2.14.1 may have known CVEs; suitable for vulnerability queries"
  }
}
```

**Example 4 - Inferred feature with lower confidence**
```
{
  "type": "technology",
  "subtype": "programming_language",
  "id": "java",
  "title": "Java",
  "description": "Java programming language (inferred from exception patterns)",
  "properties": {
    "language": "java"
  },
  "confidence": 45,
  "evidence": [
    "exception=java.lang.NullPointerException",
    "stacktrace=at com.example.Service.handle(Service.java:42)"
  ],
  "tags": ["technology", "inferred"],
  "meta": {
    "note": "Inferred from Java exception class names and .java stack trace references"
  }
}
```

**Example 5 - Dependency feature showing properties vs meta + aggregation/capping**
```
{
  "type": "dependency",
  "subtype": "service_dependency",
  "id": "api-user-http",
  "title": "api-service → user-service",
  "description": "Service-to-service HTTP dependency from api-service to user-service",
  "properties": {
    "source": "api-service",
    "target": "user-service",
    "protocol": "http"
  },
  "confidence": 85,
  "evidence": [
    "service.name=api-service http.url=/users http.status_code=200 peer.service=user-service",
    "upstream=user-service:8080 request=GET /users"
  ],
  "tags": ["dependency", "http"],
  "meta": {
    "endpoints": ["/users", "/users/:id", "/users/:id/profile", "/users/search"],
    "methods": ["GET", "POST", "PUT"],
    "note": "Aggregate endpoints under one dependency; cap the list (e.g., max 10) and summarize additional entries"
  }
}
```

## Output Quality Requirements

- Extract all features that meet the confidence threshold and have supporting evidence.
- Prefer fewer, higher-confidence features over many speculative ones.
- Sort features by descending `confidence` (and within ties, stable alphabetical order by `type`, then `subtype`).
- Dependency anti-spam: only emit a dependency feature when logs contain explicit evidence of a relationship; aggregate endpoints in `meta.endpoints` and cap the list.

Extract all features that meet the confidence threshold and have supporting evidence. Use the finalize_features tool to return the results.