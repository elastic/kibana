/***************************************************************
*
*   For the prompt generating LLM:
*   
*   This is a fairly simple task, so the reasoning should be concise and not overly chatty,
*   to keep response times low. The final output should be 2-3 sentences tops.
*
***************************************************************/

Generate a set of queries that will help the user understand if anything significant is happening in their data.

These queries will use KQL and an additional filter will be added to only include the data from the specified system.

**Generally, these queries will be either on the `body.text` (OpenTelemetry) or `message` (ECS) fields**, but they could also include filters on other properties. If `body.text` is available, you must use `body.text`. Avoid filtering on unmapped fields (which will be marked as such in the data analysis).

## Context

You will be provided with a name (`name`), a written description (`description`) and sample values of the data from the system (`dataset_analysis`). This data could include things like:

### 1. **System Runtime and Execution Context**

* **Programming language & runtime versions**
  Example: Java 11 vs. Java 17 logs (GC logging formats changed, certain exceptions differ).
* **Frameworks and libraries in use (and their versions)**
  Example: Spring Boot 2.x logs startup differently than 3.x. Elasticsearch 7.x vs. 8.x has different log messages.
* **Application server / container**
  Example: Tomcat vs. Jetty vs. Netty, each has distinct log styles for errors, connection drops, thread pools.
* **Interpreter/runtime flags**
  Example: JVM `-XX:+PrintGCDetails` vs. G1GC logging flags, or Node.js with experimental features enabled.

### 2. **Operating System and Host Environment**

* **OS family and version**
  Example: Linux (systemd, kernel OOM killer messages) vs. Windows (Event Viewer logs).
* **Distro-specific details**
  Example: Ubuntu vs. RHEL system service messages, package manager failures.
* **Kernel version / patches**
  Example: Certain kernel versions emit different messages for network stack failures or memory exhaustion.
* **Filesystem and storage type**
  Example: ext4 vs. XFS vs. EBS on AWS — errors are logged differently.

### 3. **Cloud Platform and Infrastructure Layer**

* **Cloud provider**
  Example: AWS, GCP, Azure — each has its own service-specific logs (IAM auth errors, quota exceeded).
* **Platform services**
  Example: EKS vs. GKE vs. AKS will emit different Kubernetes event messages.
* **Resource identifiers**
  Example: Instance types (memory/cpu constrained), storage classes, networking modes (VPC vs. classic).
* **Service mesh / orchestration**
  Example: Istio proxy errors vs. Linkerd vs. plain Kubernetes events.

### 4. **Deployment & Build Context**

* **Application build version / commit hash**
  Example: Certain builds may introduce new log statements or error signatures.
* **Deployment strategy**
  Example: Canary vs. rolling — logs may contain annotations about traffic routing.
* **Configuration & environment variables**
  Example: Feature flags enabled/disabled change what errors surface.

### 5. **Observability Stack Context**

* **Log format and logging library**
  Example: Log4j, SLF4J, Winston, Bunyan — each has specific message structures.
* **Structured vs. unstructured logs**
  JSON logs (with fields like `level`, `service`, `component`) vs. plain text logs.
* **Instrumentation libraries**
  Example: OpenTelemetry traces can insert error codes/log attributes that change how queries should be written.

### 6. **Domain- or Application-Specific Context**

* **Application type**
  Web app, database, distributed job scheduler, stream processor.
* **Critical subsystems**
  Example: Auth, payment processing, message queues — each has their own failure patterns.
* **Regulatory/industry constraints**
  Example: PCI-compliant logs may mask certain fields, changing what’s queryable.

---

## Why this matters for query generation

Knowing these properties lets you:

1. **Anticipate error signatures** — e.g., you expect `"java.lang.OutOfMemoryError: GC overhead limit exceeded"` only in specific JVMs with certain GC configs.
2. **Reduce false positives** — e.g., filter queries to only match `"Connection reset by peer"` when it occurs in a given OS kernel or runtime where it’s symptomatic of real issues.
3. **Adapt queries across environments** — a query written for AWS Lambda (Node.js logs) won’t match Azure Functions (different formats).

---

## Query categories

Generate queries for the following categories, but only when applicable and there is data in the system to justify them. Use the specified category to classify the generated significant events.

### 1. **Startup and Shutdown Logs** (`operational`)

* **Boot logs**: Kernel initialization, hardware detection, driver loading.
* **Service startup**: Messages indicating services or daemons starting successfully.
* **Service shutdown**: Messages about stopping services, flushing buffers, closing connections.
* **Restart logs**: Notices about restarts, often with reason codes (manual restart, crash recovery, watchdog trigger).
* **Task/job results**: Success/failure of background jobs or scheduled tasks.
* **Data lifecycle**: File creation/deletion, database migrations, backup/restore events.

### 2. **Configuration and Initialization** (`configuration`)

* **Configuration loaded**: Which configuration files were used, settings applied.
* **Feature toggles**: Enabling or disabling of features at runtime.
* **Warnings**: Deprecations or invalid/unrecognized configuration values.

### 3. **Resource Usage and Health** (`resource_health`)

* **Memory warnings**: Low memory, swap usage increasing.
* **Disk warnings**: Low disk space, I/O errors, filesystem inconsistencies.
* **CPU warnings**: High utilization, throttling, unresponsive processes.
* **Network health**: Packet loss, failed connections, latency warnings.
* **Process/resource limits**: Exceeding file descriptors, threads, or quotas.

### 4. **Error and Failure Logs** (`error`)

* **Recoverable errors**: Temporary network failures, retries, degraded performance.
* **Non-recoverable errors**: Corrupted data, failed to allocate memory, permission denied.
* **Dependency failures**: Could not reach external service, library load failure.
* **Critical/system errors**: Kernel panics, fatal process crashes, hardware faults.

### 5. **Security and Access** (`security`)

* **Authentication attempts**: Failed logins, brute-force attempts.
* **Authorization checks**: Denied access to resources, privilege escalations.
* **Audit trails**: Changes to critical configurations, role/permission changes.
* **Integrity issues**: Tampered files, invalid signatures, checksum mismatches.

---

## Generating the queries

Use KQL to generate the queries.

/***************************************************************
*
*   For the prompt generating LLM:
*   
*   Reference the block below using `{{{kql_guide}}}` in
*   a section at the end called "System variables".
*   Mustache will be used to render it into the system prompt. You
*   should leave out the contents in the prompt you generate.
*
***************************************************************/

############ START OF KQL GUIDE ############

### Core Syntax Rule
`field:value` - Search for `value` within the specified `field`

### Key Principles

#### 1. Finding Values
- Find documents where any field matches any of the words/terms listed. The term must appear as it is in the document, e.g. this query `dark light` won’t match documents containing the word "darker".
- Use and/or and parentheses to define that multiple terms need to appear. This query `orange and (dark or light)` would find all documents that have the term "orange" and either "dark" or "light" (or both) in it.
- To find values only in specific fields you can put the field name before the value e.g. this query `title : our planet or title : dark` will only find document with the term "our" and "planet" in the title field, or document with the term "dark" in the title field.
- Putting quotes around values makes sure they are found in that specific order (match a phrase) e.g. if you want to make sure to only find documents containing “our planet” and not “planet our” you’d need the following query: `title: "our planet"`

#### 2. Wildcards
- Use wildcards * to match just parts of a term/word, e.g. this query `dark*` will find anything beginning with "dark" like "darker", "darkest", "darkness", etc.
- Wildcards can be used anywhere in a term/word. ⚡ Using a wildcard in front of a word can be rather slow and resource intensive for your Elasticsearch — use with care. e.g. d*k *les
- Wildcards cannot be used when searching for phrases i.e. "our plan*" will not retrieve results containing "our planet".
- Wildcards can be used for searching over multiple fields in KQL e.g. this query will search "fakestreet" in all fields beginning with "user.address.": `user.address.* : fakestreet`

#### 3. Boolean Operators
- `or`: Combines multiple conditions where at least one must match
  - `message:"dark cat" or message:"dark dog"` returns documents with either matching phrase
- `and`: Requires all conditions to match
  - `body.text:another thing and message:dark*` returns documents that have both conditions
- Operators are case-insensitive: `OR`, `or`, `And`, `AND` all work

#### 4. Nested Field Access
- Use dot notation for nested fields: `body.text:"value"` searches within the `text` field inside the `body` object
- Can chain multiple levels: `body.metadata.author:"John"`

### Query Construction Rules
1. Always specify the field explicitly when you want to search within a specific field
2. Use quotes for phrases containing spaces or special characters
3. Parentheses group conditions: `(message:cat or message:"dark dog") and status:active`
4. Default behavior without field: Searching just `"dark cat"` searches across all searchable fields

### Examples Explained
- `message:"dark cat" or message:"dark dog"` → Documents where message field match either phrase
- `message:"dark"` → Documents where message field contains the word "dark"
- `body.text:dark*` → Documents where body.text field contains the term starting with "dark", e.g. "darkness", "darker", "dark"
- `body.text:"another thing" and (dark or darker)` → Documents having "another thing" matching phrase in the body.text field, and dark or darker word in the document.

############ END OF KQL GUIDE ############

## Tool usage

The available tool to call is `add_queries`. Each query consists of a `title` and `kql`. Every time you call this tool, the queries will be added to a list of suggestions for the user. The tool will return the queries that were successfully added, and those that failed validation. You can and should add multiple queries in one go. Only call the tool again if you wish to retry adding queries that are invalid (due to syntax or other reasons). Once you're satisfied with the result, call `complete()`.
