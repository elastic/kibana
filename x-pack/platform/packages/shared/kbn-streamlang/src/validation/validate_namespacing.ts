/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { i18n } from '@kbn/i18n';
import type { StreamlangProcessorDefinition } from '../../types/processors';
import { KEEP_FIELDS, NAMESPACE_PREFIXES } from './constants';
import type { StreamlangValidationError } from './types';
import { extractModifiedFields } from './validate_types';

/**
 * Check if a field is a namespaced ECS field or an allowed keep field.
 * Based on the logic from @kbn/streams-schema/src/helpers/namespaced_ecs.ts
 *
 * Namespaced ECS fields follow the pattern: namespace.field or namespace.nested.field
 * Examples: attributes.custom, body.structured.data, resource.attributes.host
 *
 * Keep fields are special fields that are allowed without namespacing:
 * @timestamp, trace_id, span_id, severity_text, body, severity_number, event_name, etc.
 */
export function isNamespacedEcsField(fieldName: string): boolean {
  // Check if it's a keep field
  if (KEEP_FIELDS.includes(fieldName as (typeof KEEP_FIELDS)[number])) {
    return true;
  }

  // Check if it starts with a namespace prefix
  return NAMESPACE_PREFIXES.some((prefix) => fieldName.startsWith(prefix));
}

/**
 * Validates that fields modified by a processor are properly namespaced.
 * This validation only applies to wired streams.
 *
 * @param step - The processor step to validate
 * @param processorNumber - 1-based index for error messages
 * @param processorId - Unique identifier for the processor
 * @returns Array of validation errors for non-namespaced fields
 */
export function validateNamespacing(
  step: StreamlangProcessorDefinition,
  processorNumber: number,
  processorId: string
): StreamlangValidationError[] {
  const errors: StreamlangValidationError[] = [];
  const modifiedFields = extractModifiedFields(step);
  const nonNamespacedFields = modifiedFields.filter((field) => !isNamespacedEcsField(field));

  for (const field of nonNamespacedFields) {
    errors.push({
      type: 'non_namespaced_field',
      message: i18n.translate('xpack.streamlang.validation.nonNamespacedFieldMessage', {
        defaultMessage:
          'The field "{fieldName}" generated by processor #{processorNumber} ({processorAction}) does not match the streams recommended schema - put custom fields into attributes, body.structured or resource.attributes',
        values: {
          fieldName: field,
          processorNumber,
          processorAction: step.action,
        },
      }),
      processorId,
      field,
    });
  }

  return errors;
}

/**
 * Validates that a processor doesn't modify reserved/system fields.
 *
 * @param step - The processor step to validate
 * @param processorNumber - 1-based index for error messages
 * @param processorId - Unique identifier for the processor
 * @param reservedFields - List of field names that cannot be modified
 * @returns Array of validation errors for reserved field violations
 */
export function validateReservedFields(
  step: StreamlangProcessorDefinition,
  processorNumber: number,
  processorId: string,
  reservedFields: string[]
): StreamlangValidationError[] {
  const errors: StreamlangValidationError[] = [];

  if (reservedFields.length === 0) {
    return errors;
  }

  const modifiedFields = extractModifiedFields(step);
  const reservedFieldViolations = modifiedFields.filter((field) => reservedFields.includes(field));

  for (const field of reservedFieldViolations) {
    errors.push({
      type: 'reserved_field',
      message: i18n.translate('xpack.streamlang.validation.reservedFieldMessage', {
        defaultMessage:
          'Processor #{processorNumber} ({processorAction}) is trying to modify reserved field "{fieldName}"',
        values: {
          processorNumber,
          processorAction: step.action,
          fieldName: field,
        },
      }),
      processorId,
      field,
    });
  }

  return errors;
}
