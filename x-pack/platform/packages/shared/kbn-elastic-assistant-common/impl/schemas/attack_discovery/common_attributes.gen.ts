/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 *
 * info:
 *   title: Common Attack Discovery Attributes
 *   version: not applicable
 */

import { z } from '@kbn/zod';

import { NonEmptyString, User } from '../common_attributes.gen';
import { Replacements, ApiConfig } from '../conversations/common_attributes.gen';
import { AnonymizationFieldResponse } from '../anonymization_fields/bulk_crud_anonymization_fields_route.gen';

/**
 * An attack discovery generated from one or more alerts
 */
export type AttackDiscovery = z.infer<typeof AttackDiscovery>;
export const AttackDiscovery = z.object({
  /**
   * The alert IDs that the attack discovery is based on
   */
  alertIds: z.array(z.string()),
  /**
   * UUID of attack discovery
   */
  id: z.string().optional(),
  /**
   * Details of the attack with bulleted markdown that always uses special syntax for field names and values from the source data.
   */
  detailsMarkdown: z.string(),
  /**
   * A short (no more than a sentence) summary of the attack discovery featuring only the host.name and user.name fields (when they are applicable), using the same syntax
   */
  entitySummaryMarkdown: z.string().optional(),
  /**
   * An array of MITRE ATT&CK tactic for the attack discovery
   */
  mitreAttackTactics: z.array(z.string()).optional(),
  /**
   * A markdown summary of attack discovery, using the same syntax
   */
  summaryMarkdown: z.string(),
  /**
   * A title for the attack discovery, in plain text
   */
  title: z.string(),
  /**
   * The time the attack discovery was generated
   */
  timestamp: NonEmptyString.optional(),
});

/**
 * Array of attack discoveries
 */
export type AttackDiscoveries = z.infer<typeof AttackDiscoveries>;
export const AttackDiscoveries = z.array(AttackDiscovery);

/**
 * The status of the attack discovery.
 */
export type AttackDiscoveryStatus = z.infer<typeof AttackDiscoveryStatus>;
export const AttackDiscoveryStatus = z.enum(['running', 'succeeded', 'failed', 'canceled']);
export type AttackDiscoveryStatusEnum = typeof AttackDiscoveryStatus.enum;
export const AttackDiscoveryStatusEnum = AttackDiscoveryStatus.enum;

/**
 * Run durations for the attack discovery
 */
export type GenerationInterval = z.infer<typeof GenerationInterval>;
export const GenerationInterval = z.object({
  /**
   * The time the attack discovery was generated
   */
  date: z.string(),
  /**
   * The duration of the attack discovery generation
   */
  durationMs: z.number().int(),
});

/**
 * Attack discovery stats
 */
export type AttackDiscoveryStat = z.infer<typeof AttackDiscoveryStat>;
export const AttackDiscoveryStat = z.object({
  /**
   * Whether the user has viewed the results of the attack discovery run
   */
  hasViewed: z.boolean(),
  /**
   * The number of attack discoveries for the connector
   */
  count: z.number().int(),
  /**
   * The connector ID for the attack discovery
   */
  connectorId: z.string(),
  /**
   * The status of the attack discovery.
   */
  status: AttackDiscoveryStatus,
});

/**
 * Stats on existing attack discovery documents
 */
export type AttackDiscoveryStats = z.infer<typeof AttackDiscoveryStats>;
export const AttackDiscoveryStats = z.object({
  /**
   * The number of attack discoveries that have not yet been viewed
   */
  newDiscoveriesCount: z.number().int(),
  /**
   * The number of connectors with new results that have not yet been viewed
   */
  newConnectorResultsCount: z.number().int(),
  /**
   * Attack discovery stats per connector
   */
  statsPerConnector: z.array(AttackDiscoveryStat),
});

export type AttackDiscoveryResponse = z.infer<typeof AttackDiscoveryResponse>;
export const AttackDiscoveryResponse = z.object({
  id: NonEmptyString,
  timestamp: NonEmptyString.optional(),
  /**
   * The last time attack discovery was updated.
   */
  updatedAt: z.string(),
  /**
   * The last time attack discovery was viewed in the browser.
   */
  lastViewedAt: z.string(),
  /**
   * The number of alerts in the context.
   */
  alertsContextCount: z.number().int().optional(),
  /**
   * The time attack discovery was created.
   */
  createdAt: z.string(),
  replacements: Replacements.optional(),
  users: z.array(User),
  /**
   * The status of the attack discovery.
   */
  status: AttackDiscoveryStatus,
  /**
   * The attack discoveries.
   */
  attackDiscoveries: AttackDiscoveries,
  /**
   * LLM API configuration.
   */
  apiConfig: ApiConfig,
  /**
   * Kibana space
   */
  namespace: z.string(),
  /**
   * The backing index required for update requests.
   */
  backingIndex: z.string(),
  /**
   * The most 5 recent generation intervals
   */
  generationIntervals: z.array(GenerationInterval),
  /**
   * The average generation interval in milliseconds
   */
  averageIntervalMs: z.number().int(),
  /**
   * The reason for a status of failed.
   */
  failureReason: z.string().optional(),
});

export type AttackDiscoveryUpdateProps = z.infer<typeof AttackDiscoveryUpdateProps>;
export const AttackDiscoveryUpdateProps = z.object({
  id: NonEmptyString,
  /**
   * LLM API configuration.
   */
  apiConfig: ApiConfig.optional(),
  /**
   * The number of alerts in the context.
   */
  alertsContextCount: z.number().int().optional(),
  /**
   * The attack discoveries.
   */
  attackDiscoveries: AttackDiscoveries.optional(),
  /**
   * The status of the attack discovery.
   */
  status: AttackDiscoveryStatus.optional(),
  replacements: Replacements.optional(),
  /**
   * The most 5 recent generation intervals
   */
  generationIntervals: z.array(GenerationInterval).optional(),
  /**
   * The backing index required for update requests.
   */
  backingIndex: z.string(),
  /**
   * The reason for a status of failed.
   */
  failureReason: z.string().optional(),
  /**
   * The last time attack discovery was viewed in the browser.
   */
  lastViewedAt: z.string().optional(),
});

export type AttackDiscoveryCreateProps = z.infer<typeof AttackDiscoveryCreateProps>;
export const AttackDiscoveryCreateProps = z.object({
  /**
   * The attack discovery id.
   */
  id: z.string().optional(),
  /**
   * The status of the attack discovery.
   */
  status: AttackDiscoveryStatus,
  /**
   * The number of alerts in the context.
   */
  alertsContextCount: z.number().int().optional(),
  /**
   * The attack discoveries.
   */
  attackDiscoveries: AttackDiscoveries,
  /**
   * LLM API configuration.
   */
  apiConfig: ApiConfig,
  replacements: Replacements.optional(),
});

export type CreateAttackDiscoveryAlertsParams = z.infer<typeof CreateAttackDiscoveryAlertsParams>;
export const CreateAttackDiscoveryAlertsParams = z.object({
  /**
   * The number of alerts provided as context to the LLM
   */
  alertsContextCount: z.number().int(),
  /**
   * The anonymized alerts that were used to generate the attack discovery
   */
  anonymizedAlerts: z.array(
    z.object({
      id: z.string().optional(),
      metadata: z.object({}),
      pageContent: z.string(),
    })
  ),
  /**
   * LLM API configuration
   */
  apiConfig: ApiConfig,
  /**
   * The generated Attack discoveries
   */
  attackDiscoveries: AttackDiscoveries,
  /**
   * The name of the connector that generated the attack discovery
   */
  connectorName: z.string(),
  /**
   * The generation ID of the run that created the attack discovery
   */
  generationUuid: z.string(),
  /**
   * Replacements enable anonymization of data sent to the LLM. When Attack discoveries are added to an assistant conversation, replacements must be provided at the same time.
   */
  replacements: Replacements.optional(),
});

export type FindAttackDiscoveryAlertsParams = z.infer<typeof FindAttackDiscoveryAlertsParams>;
export const FindAttackDiscoveryAlertsParams = z.object({
  /**
   * filter by alert IDs within Attack discovery
   */
  alertIds: z.array(z.string()).optional(),
  /**
   * filter by connector names
   */
  connectorNames: z.array(z.string()).optional(),
  /**
   * filter by end date (relative or absolute)
   */
  end: z.string().optional(),
  /**
   * filter by Attack discovery IDs
   */
  ids: z.array(z.string()).optional(),
  page: z.number().int().min(1).optional().default(1),
  perPage: z.number().int().min(0).optional().default(10),
  /**
   * filter by search query
   */
  search: z.string().optional(),
  /**
   * `undefined`: show both shared, and only visible to me Attack discoveries. `true`: show only shared Attack discoveries. `false`: show only visible to me Attack discoveries.
   */
  shared: z.boolean().optional(),
  sortField: z.string().optional().default('@timestamp'),
  sortOrder: z.string().optional(),
  /**
   * filter by start date (relative or absolute)
   */
  start: z.string().optional(),
  /**
   * filter by kibana.alert.workflow.status
   */
  status: z.array(z.string()).optional(),
});

export type AttackDiscoveryGenerationConfig = z.infer<typeof AttackDiscoveryGenerationConfig>;
export const AttackDiscoveryGenerationConfig = z.object({
  alertsIndexPattern: z.string(),
  anonymizationFields: z.array(AnonymizationFieldResponse),
  /**
   * LLM API configuration.
   */
  apiConfig: ApiConfig,
  connectorName: z.string().optional(),
  end: z.string().optional(),
  filter: z.object({}).catchall(z.unknown()).optional(),
  langSmithProject: z.string().optional(),
  langSmithApiKey: z.string().optional(),
  model: z.string().optional(),
  replacements: Replacements.optional(),
  size: z.number(),
  start: z.string().optional(),
  subAction: z.enum(['invokeAI', 'invokeStream']),
});
