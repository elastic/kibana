/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 *
 * info:
 *   title: Common Conversation Attributes
 *   version: not applicable
 */

import { z } from '@kbn/zod';

import { NonEmptyString, User, NonEmptyTimestamp } from '../common_attributes.gen';

/**
 * Trace Data
 */
export type TraceData = z.infer<typeof TraceData>;
export const TraceData = z.object({
  /**
   * Could be any string, not necessarily a UUID
   */
  transactionId: z.string().optional(),
  /**
   * Could be any string, not necessarily a UUID
   */
  traceId: z.string().optional(),
});

/**
 * The type of interrupt
 */
export type InterruptType = z.infer<typeof InterruptType>;
export const InterruptType = z.enum(['SELECT_OPTION', 'INPUT_TEXT']);
export type InterruptTypeEnum = typeof InterruptType.enum;
export const InterruptTypeEnum = InterruptType.enum;

/**
 * The basis of an agent interrupt
 */
export type BaseInterruptValue = z.infer<typeof BaseInterruptValue>;
export const BaseInterruptValue = z.object({
  /**
   * Type of the interrupt
   */
  type: InterruptType,
  /**
   * Whether the interrupt has expired and can no longer be resumed.
   */
  expired: z.boolean().optional(),
  /**
   * Thread ID of the graph execution that produced this message.
   */
  threadId: z.string(),
});

/**
 * The basis of an interrupt resume value
 */
export type BaseInterruptResumeValue = z.infer<typeof BaseInterruptResumeValue>;
export const BaseInterruptResumeValue = z.object({
  /**
   * Type of the resume value
   */
  type: InterruptType,
});

/**
 * A request approval option
 */
export type SelectOptionInterruptOption = z.infer<typeof SelectOptionInterruptOption>;
export const SelectOptionInterruptOption = z.object({
  label: z.string(),
  value: z.string(),
  buttonColor: z
    .enum([
      'text',
      'accent',
      'accentSecondary',
      'primary',
      'success',
      'warning',
      'danger',
      'neutral',
      'risk',
    ])
    .optional(),
});

/**
 * Interrupt that requests user to select one of the provided options
 */
export type SelectOptionInterruptValue = z.infer<typeof SelectOptionInterruptValue>;
export const SelectOptionInterruptValue = BaseInterruptValue.merge(
  z.object({
    type: z.literal('SELECT_OPTION'),
    /**
     * Description of action required
     */
    description: z.string(),
    /**
     * List of actions to choose from
     */
    options: z.array(SelectOptionInterruptOption),
  })
);

/**
 * A request approval resume schema
 */
export type SelectOptionInterruptResumeValue = z.infer<typeof SelectOptionInterruptResumeValue>;
export const SelectOptionInterruptResumeValue = BaseInterruptResumeValue.merge(
  z.object({
    type: z.literal('SELECT_OPTION'),
    /**
     * The value of the selected option to resume the graph execution with
     */
    value: z.string(),
  })
);

/**
 * A request approval interrupt
 */
export type SelectOptionInterrupt = z.infer<typeof SelectOptionInterrupt>;
export const SelectOptionInterrupt = z.object({
  /**
   * The interrupt value
   */
  interruptValue: SelectOptionInterruptValue,
  /**
   * The resume value
   */
  resumeValue: SelectOptionInterruptResumeValue,
});

/**
 * Interrupt that requests user to provide text input
 */
export type InputTextInterruptValue = z.infer<typeof InputTextInterruptValue>;
export const InputTextInterruptValue = BaseInterruptValue.merge(
  z.object({
    type: z.literal('INPUT_TEXT'),
    /**
     * Description of action required
     */
    description: z.string().optional(),
    /**
     * Placeholder text for the input field
     */
    placeholder: z.string().optional(),
  })
);

/**
 * A resume value for input text
 */
export type InputTextInterruptResumeValue = z.infer<typeof InputTextInterruptResumeValue>;
export const InputTextInterruptResumeValue = BaseInterruptResumeValue.merge(
  z.object({
    type: z.literal('INPUT_TEXT'),
    /**
     * Text value used to resume the graph execution with.
     */
    value: z.string(),
  })
);

/**
 * A request text interrupt
 */
export type InputTextInterrupt = z.infer<typeof InputTextInterrupt>;
export const InputTextInterrupt = z.object({
  /**
   * The interrupt value
   */
  interruptValue: InputTextInterruptValue,
  /**
   * The resume value
   */
  resumeValue: InputTextInterruptResumeValue,
});

/**
 * Union of the interrupt values
 */
export type InterruptValue = z.infer<typeof InterruptValue>;
export const InterruptValue = z.union([SelectOptionInterruptValue, InputTextInterruptValue]);

/**
 * Union of the interrupt resume values
 */
export type InterruptResumeValue = z.infer<typeof InterruptResumeValue>;
export const InterruptResumeValue = z.union([
  SelectOptionInterruptResumeValue,
  InputTextInterruptResumeValue,
]);

/**
 * The basis of a content reference
 */
export type BaseContentReference = z.infer<typeof BaseContentReference>;
export const BaseContentReference = z.object({
  /**
   * Id of the content reference
   */
  id: z.string(),
  /**
   * Type of the content reference
   */
  type: z.string(),
});

/**
 * References a knowledge base entry
 */
export type KnowledgeBaseEntryContentReference = z.infer<typeof KnowledgeBaseEntryContentReference>;
export const KnowledgeBaseEntryContentReference = BaseContentReference.merge(
  z.object({
    type: z.literal('KnowledgeBaseEntry'),
    /**
     * Id of the Knowledge Base Entry
     */
    knowledgeBaseEntryId: z.string(),
    /**
     * Name of the knowledge base entry
     */
    knowledgeBaseEntryName: z.string(),
  })
);

/**
 * References an ESQL query
 */
export type EsqlContentReference = z.infer<typeof EsqlContentReference>;
export const EsqlContentReference = BaseContentReference.merge(
  z.object({
    type: z.literal('EsqlQuery'),
    /**
     * An ESQL query
     */
    query: z.string(),
    /**
     * Label of the query
     */
    label: z.string(),
    /**
     * Time range to select in the time picker.
     */
    timerange: z
      .object({
        from: z.string(),
        to: z.string(),
      })
      .optional(),
  })
);

/**
 * References a security alert
 */
export type SecurityAlertContentReference = z.infer<typeof SecurityAlertContentReference>;
export const SecurityAlertContentReference = BaseContentReference.merge(
  z.object({
    type: z.literal('SecurityAlert'),
    /**
     * ID of the Alert
     */
    alertId: z.string(),
  })
);

/**
 * References an external URL
 */
export type HrefContentReference = z.infer<typeof HrefContentReference>;
export const HrefContentReference = BaseContentReference.merge(
  z.object({
    type: z.literal('Href'),
    /**
     * Label of the query
     */
    label: z.string().optional(),
    /**
     * URL to the external resource
     */
    href: z.string(),
  })
);

/**
 * References the security alerts page
 */
export type SecurityAlertsPageContentReference = z.infer<typeof SecurityAlertsPageContentReference>;
export const SecurityAlertsPageContentReference = BaseContentReference.merge(
  z.object({
    type: z.literal('SecurityAlertsPage'),
  })
);

/**
 * References the product documentation
 */
export type ProductDocumentationContentReference = z.infer<
  typeof ProductDocumentationContentReference
>;
export const ProductDocumentationContentReference = BaseContentReference.merge(
  z.object({
    type: z.literal('ProductDocumentation'),
    /**
     * Title of the documentation
     */
    title: z.string(),
    /**
     * URL to the documentation
     */
    url: z.string(),
  })
);

/**
 * A content reference
 */
export const ContentReferenceInternal = z.union([
  KnowledgeBaseEntryContentReference,
  SecurityAlertContentReference,
  SecurityAlertsPageContentReference,
  ProductDocumentationContentReference,
  EsqlContentReference,
  HrefContentReference,
]);

export type ContentReference = z.infer<typeof ContentReferenceInternal>;
export const ContentReference = ContentReferenceInternal as z.ZodType<ContentReference>;

/**
 * A union of all content reference types
 */
export type ContentReferences = z.infer<typeof ContentReferences>;
export const ContentReferences = z
  .object({})
  .catchall(
    z.union([
      KnowledgeBaseEntryContentReference,
      SecurityAlertContentReference,
      SecurityAlertsPageContentReference,
      ProductDocumentationContentReference,
      EsqlContentReference,
      HrefContentReference,
    ])
  );

/**
 * Message metadata
 */
export type MessageMetadata = z.infer<typeof MessageMetadata>;
export const MessageMetadata = z.object({
  /**
   * Data referred to by the message content.
   */
  contentReferences: ContentReferences.optional(),
  /**
   * When the agent is interrupted (for example, when user input is required), this field is populated with the details of the interrupt. Messages containing interruptValues in the metadata are excluded from the LLM context.
   */
  interruptValue: InterruptValue.optional(),
  /**
   * When the agent is resumed after an interrupt, this field is populated with the details of the resume value.
   */
  interruptResumeValue: InterruptResumeValue.optional(),
});

/**
 * Replacements object used to anonymize/deanonymize messages
 */
export type Replacements = z.infer<typeof Replacements>;
export const Replacements = z.object({}).catchall(z.string());

export type Reader = z.infer<typeof Reader>;
export const Reader = z.object({}).catchall(z.unknown());

/**
 * Provider
 */
export type Provider = z.infer<typeof Provider>;
export const Provider = z.enum(['OpenAI', 'Azure OpenAI', 'Other']);
export type ProviderEnum = typeof Provider.enum;
export const ProviderEnum = Provider.enum;

/**
 * Message role.
 */
export type MessageRole = z.infer<typeof MessageRole>;
export const MessageRole = z.enum(['system', 'user', 'assistant']);
export type MessageRoleEnum = typeof MessageRole.enum;
export const MessageRoleEnum = MessageRole.enum;

/**
 * The conversation category.
 */
export type ConversationCategory = z.infer<typeof ConversationCategory>;
export const ConversationCategory = z.enum(['assistant', 'insights']);
export type ConversationCategoryEnum = typeof ConversationCategory.enum;
export const ConversationCategoryEnum = ConversationCategory.enum;

/**
 * AI assistant conversation message.
 */
export type Message = z.infer<typeof Message>;
export const Message = z.object({
  /**
   * Message id
   */
  id: NonEmptyString.optional(),
  /**
   * Message content.
   */
  content: z.string(),
  /**
   * Refusal reason returned by the model when content is filtered.
   */
  refusal: z.string().optional(),
  /**
   * Message content.
   */
  reader: Reader.optional(),
  /**
   * Message role.
   */
  role: MessageRole,
  /**
   * The user who sent the message.
   */
  user: User.optional(),
  /**
   * The timestamp message was sent or received.
   */
  timestamp: NonEmptyTimestamp,
  /**
   * Is error message.
   */
  isError: z.boolean().optional(),
  /**
   * Trace data
   */
  traceData: TraceData.optional(),
  /**
   * Metadata
   */
  metadata: MessageMetadata.optional(),
});

export type ApiConfig = z.infer<typeof ApiConfig>;
export const ApiConfig = z.object({
  /**
   * Connector ID
   */
  connectorId: z.string(),
  /**
   * Action type ID
   */
  actionTypeId: z.string(),
  /**
   * Default system prompt ID
   */
  defaultSystemPromptId: z.string().optional(),
  /**
   * Provider
   */
  provider: Provider.optional(),
  /**
   * Model
   */
  model: z.string().optional(),
});

export type ErrorSchema = z.infer<typeof ErrorSchema>;
export const ErrorSchema = z
  .object({
    id: NonEmptyString.optional(),
    error: z.object({
      status_code: z.number().int().min(400),
      message: z.string(),
    }),
  })
  .strict();

export type ConversationResponse = z.infer<typeof ConversationResponse>;
export const ConversationResponse = z.object({
  id: NonEmptyString,
  /**
   * The conversation title.
   */
  title: z.string(),
  /**
   * The conversation category.
   */
  category: ConversationCategory,
  timestamp: NonEmptyTimestamp.optional(),
  /**
   * The last time conversation was updated.
   */
  updatedAt: z.string().optional(),
  /**
   * The time conversation was created.
   */
  createdAt: z.string(),
  replacements: Replacements.optional(),
  /**
   * The user who created the conversation.
   */
  createdBy: User,
  users: z.array(User),
  /**
   * The conversation messages.
   */
  messages: z.array(Message).optional(),
  /**
   * LLM API configuration.
   */
  apiConfig: ApiConfig.optional(),
  /**
   * Exclude from last conversation storage.
   */
  excludeFromLastConversationStorage: z.boolean().optional(),
  /**
   * Kibana space
   */
  namespace: z.string(),
});

export type ConversationUpdateProps = z.infer<typeof ConversationUpdateProps>;
export const ConversationUpdateProps = z.object({
  id: NonEmptyString,
  /**
   * The conversation title.
   */
  title: z.string().optional(),
  /**
   * The conversation category.
   */
  category: ConversationCategory.optional(),
  /**
   * The conversation messages.
   */
  messages: z.array(Message).optional(),
  /**
   * LLM API configuration.
   */
  apiConfig: ApiConfig.optional(),
  /**
   * Exclude from last conversation storage.
   */
  excludeFromLastConversationStorage: z.boolean().optional(),
  replacements: Replacements.optional(),
  users: z.array(User).optional(),
});

export type ConversationCreateProps = z.infer<typeof ConversationCreateProps>;
export const ConversationCreateProps = z.object({
  /**
   * The conversation id.
   */
  id: z.string().optional(),
  /**
   * The conversation title.
   */
  title: z.string(),
  /**
   * The conversation category.
   */
  category: ConversationCategory.optional(),
  /**
   * The conversation messages.
   */
  messages: z.array(Message).optional(),
  /**
   * LLM API configuration.
   */
  apiConfig: ApiConfig.optional(),
  /**
   * Exclude from last conversation storage.
   */
  excludeFromLastConversationStorage: z.boolean().optional(),
  replacements: Replacements.optional(),
});

export type ConversationMessageCreateProps = z.infer<typeof ConversationMessageCreateProps>;
export const ConversationMessageCreateProps = z.object({
  /**
   * The conversation messages.
   */
  messages: z.array(Message),
});
