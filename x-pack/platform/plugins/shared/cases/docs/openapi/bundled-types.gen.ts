/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 *
 * info:
 *   title: Cases
 *   version: 0.1
 */

import { z } from '@kbn/zod';

/**
 * An array containing users that are assigned to the case.
 */
export type Assignees = z.infer<typeof Assignees>;
export const Assignees = z
  .array(
    z.object({
      /**
       * A unique identifier for the user profile. These identifiers can be found by using the suggest user profile API.
       */
      uid: z.string(),
    })
  )
  .max(10)
  .nullable();

/**
 * Defines properties for connectors when type is `.none`.
 */
export type ConnectorPropertiesNone = z.infer<typeof ConnectorPropertiesNone>;
export const ConnectorPropertiesNone = z.object({
  /**
   * An object containing the connector fields. To create a case without a connector, specify null. To update a case to remove the connector, specify null.
   */
  fields: z.string().nullable(),
  /**
   * The identifier for the connector. To create a case without a connector, use `none`. To update a case to remove the connector, specify `none`.
   */
  id: z.string(),
  /**
   * The name of the connector. To create a case without a connector, use `none`. To update a case to remove the connector, specify `none`.
   */
  name: z.string(),
  /**
   * The type of connector. To create a case without a connector, use `.none`. To update a case to remove the connector, specify `.none`.
   */
  type: z.literal('.none'),
});

/**
 * Defines properties for connectors when type is `.cases-webhook`.
 */
export type ConnectorPropertiesCasesWebhook = z.infer<typeof ConnectorPropertiesCasesWebhook>;
export const ConnectorPropertiesCasesWebhook = z.object({
  fields: z.string().nullable(),
  /**
   * The identifier for the connector. To retrieve connector IDs, use the find connectors API.
   */
  id: z.string(),
  /**
   * The name of the connector.
   */
  name: z.string(),
  /**
   * The type of connector.
   */
  type: z.literal('.cases-webhook'),
});

/**
 * Defines properties for connectors when type is `.jira`.
 */
export type ConnectorPropertiesJira = z.infer<typeof ConnectorPropertiesJira>;
export const ConnectorPropertiesJira = z.object({
  /**
   * An object containing the connector fields. If you want to omit any individual field, specify null as its value.
   */
  fields: z.object({
    /**
     * The type of issue.
     */
    issueType: z.string().nullable(),
    /**
     * The key of the parent issue, when the issue type is sub-task.
     */
    parent: z.string().nullable(),
    /**
     * The priority of the issue.
     */
    priority: z.string().nullable(),
  }),
  /**
   * The identifier for the connector. To retrieve connector IDs, use the find connectors API.
   */
  id: z.string(),
  /**
   * The name of the connector.
   */
  name: z.string(),
  /**
   * The type of connector.
   */
  type: z.literal('.jira'),
});

/**
 * Defines properties for connectors when type is `.resilient`.
 */
export type ConnectorPropertiesResilient = z.infer<typeof ConnectorPropertiesResilient>;
export const ConnectorPropertiesResilient = z.object({
  /**
   * An object containing the connector fields. If you want to omit any individual field, specify null as its value.
   */
  fields: z
    .object({
      /**
       * The type of incident.
       */
      issueTypes: z.array(z.string()),
      /**
       * The severity code of the incident.
       */
      severityCode: z.string(),
    })
    .nullable(),
  /**
   * The identifier for the connector.
   */
  id: z.string(),
  /**
   * The name of the connector.
   */
  name: z.string(),
  /**
   * The type of connector.
   */
  type: z.literal('.resilient'),
});

/**
 * Defines properties for connectors when type is `.servicenow`.
 */
export type ConnectorPropertiesServicenow = z.infer<typeof ConnectorPropertiesServicenow>;
export const ConnectorPropertiesServicenow = z.object({
  /**
   * An object containing the connector fields. If you want to omit any individual field, specify null as its value.
   */
  fields: z.object({
    /**
     * The category of the incident.
     */
    category: z.string().nullable(),
    /**
     * The effect an incident had on business.
     */
    impact: z.string().nullable(),
    /**
     * The severity of the incident.
     */
    severity: z.string().nullable(),
    /**
     * The subcategory of the incident.
     */
    subcategory: z.string().nullable(),
    /**
     * The extent to which the incident resolution can be delayed.
     */
    urgency: z.string().nullable(),
  }),
  /**
   * The identifier for the connector. To retrieve connector IDs, use the find connectors API.
   */
  id: z.string(),
  /**
   * The name of the connector.
   */
  name: z.string(),
  /**
   * The type of connector.
   */
  type: z.literal('.servicenow'),
});

/**
 * Defines properties for connectors when type is `.servicenow-sir`.
 */
export type ConnectorPropertiesServicenowSir = z.infer<typeof ConnectorPropertiesServicenowSir>;
export const ConnectorPropertiesServicenowSir = z.object({
  /**
   * An object containing the connector fields. If you want to omit any individual field, specify null as its value.
   */
  fields: z.object({
    /**
     * The category of the incident.
     */
    category: z.string().nullable(),
    /**
     * Indicates whether cases will send a comma-separated list of destination IPs.
     */
    destIp: z.boolean().nullable(),
    /**
     * Indicates whether cases will send a comma-separated list of malware hashes.
     */
    malwareHash: z.boolean().nullable(),
    /**
     * Indicates whether cases will send a comma-separated list of malware URLs.
     */
    malwareUrl: z.boolean().nullable(),
    /**
     * The priority of the issue.
     */
    priority: z.string().nullable(),
    /**
     * Indicates whether cases will send a comma-separated list of source IPs.
     */
    sourceIp: z.boolean().nullable(),
    /**
     * The subcategory of the incident.
     */
    subcategory: z.string().nullable(),
  }),
  /**
   * The identifier for the connector. To retrieve connector IDs, use the find connectors API.
   */
  id: z.string(),
  /**
   * The name of the connector.
   */
  name: z.string(),
  /**
   * The type of connector.
   */
  type: z.literal('.servicenow-sir'),
});

/**
 * Defines properties for connectors when type is `.swimlane`.
 */
export type ConnectorPropertiesSwimlane = z.infer<typeof ConnectorPropertiesSwimlane>;
export const ConnectorPropertiesSwimlane = z.object({
  /**
   * An object containing the connector fields. If you want to omit any individual field, specify null as its value.
   */
  fields: z.object({
    /**
     * The case identifier for Swimlane connectors.
     */
    caseId: z.string().nullable(),
  }),
  /**
   * The identifier for the connector. To retrieve connector IDs, use the find connectors API.
   */
  id: z.string(),
  /**
   * The name of the connector.
   */
  name: z.string(),
  /**
   * The type of connector.
   */
  type: z.literal('.swimlane'),
});

/**
 * The description for the case.
 */
export type CaseDescription = z.infer<typeof CaseDescription>;
export const CaseDescription = z.string().max(30000);

/**
  * The application that owns the cases: Stack Management, Observability, or Elastic Security.

  */
export type Owner = z.infer<typeof Owner>;
export const Owner = z.enum(['cases', 'observability', 'securitySolution']);
export type OwnerEnum = typeof Owner.enum;
export const OwnerEnum = Owner.enum;

/**
 * An object that contains the case settings.
 */
export type Settings = z.infer<typeof Settings>;
export const Settings = z.object({
  /**
   * Turns alert syncing on or off.
   */
  syncAlerts: z.boolean(),
});

/**
 * The severity of the case.
 */
export type CaseSeverity = z.infer<typeof CaseSeverity>;
export const CaseSeverity = z.enum(['critical', 'high', 'low', 'medium']);
export type CaseSeverityEnum = typeof CaseSeverity.enum;
export const CaseSeverityEnum = CaseSeverity.enum;

/**
  * The words and phrases that help categorize cases. It can be an empty array.

  */
export type CaseTags = z.infer<typeof CaseTags>;
export const CaseTags = z.array(z.string().max(256)).max(200);

/**
 * A word or phrase that categorizes the case.
 */
export type CaseCategory = z.infer<typeof CaseCategory>;
export const CaseCategory = z.string().max(50);

/**
 * A title for the case.
 */
export type CaseTitle = z.infer<typeof CaseTitle>;
export const CaseTitle = z.string().max(160);

/**
 * The create case API request body varies depending on the type of connector.
 */
export type CreateCaseRequest = z.infer<typeof CreateCaseRequest>;
export const CreateCaseRequest = z.object({
  assignees: Assignees.optional(),
  connector: z.union([
    ConnectorPropertiesNone,
    ConnectorPropertiesCasesWebhook,
    ConnectorPropertiesJira,
    ConnectorPropertiesResilient,
    ConnectorPropertiesServicenow,
    ConnectorPropertiesServicenowSir,
    ConnectorPropertiesSwimlane,
  ]),
  description: CaseDescription,
  owner: Owner,
  settings: Settings,
  severity: CaseSeverity.optional(),
  tags: CaseTags,
  category: CaseCategory.optional(),
  title: CaseTitle,
  /**
      * Custom field values for a case. Any optional custom fields that are not specified in the request are set to null.

      */
  customFields: z
    .array(
      z.object({
        /**
      * The unique identifier for the custom field. The key value must exist in the case configuration settings.

      */
        key: z.string(),
        /**
      * The custom field type. It must match the type specified in the case configuration settings.

      */
        type: z.enum(['text', 'toggle']),
        /**
      * The custom field value. If the custom field is required, it cannot be explicitly set to null. However, for cases that existed when the required custom field was added, the default value stored in Elasticsearch is `undefined`. The value returned in the API and user interface in this case is `null`.

      */
        value: z.union([z.string().min(1).max(160).nullable(), z.boolean()]),
      })
    )
    .max(10)
    .optional(),
});

export type CaseResponseClosedByProperties = z.infer<typeof CaseResponseClosedByProperties>;
export const CaseResponseClosedByProperties = z
  .object({
    email: z.string().nullable(),
    full_name: z.string().nullable(),
    username: z.string().nullable(),
    profile_uid: z.string().optional(),
  })
  .nullable();

export type AlertCommentResponseProperties = z.infer<typeof AlertCommentResponseProperties>;
export const AlertCommentResponseProperties = z.object({
  alertId: z.array(z.string()).optional(),
  created_at: z.string().datetime().optional(),
  created_by: z
    .object({
      email: z.string().nullable(),
      full_name: z.string().nullable(),
      username: z.string().nullable(),
      profile_uid: z.string().optional(),
    })
    .optional(),
  id: z.string().optional(),
  index: z.array(z.string()).optional(),
  owner: Owner.optional(),
  pushed_at: z.string().datetime().nullable().optional(),
  pushed_by: z
    .object({
      email: z.string().nullable(),
      full_name: z.string().nullable(),
      username: z.string().nullable(),
      profile_uid: z.string().optional(),
    })
    .nullable()
    .optional(),
  rule: z
    .object({
      /**
       * The rule identifier.
       */
      id: z.string().optional(),
      /**
       * The rule name.
       */
      name: z.string().optional(),
    })
    .optional(),
  type: z.literal('alert'),
  updated_at: z.string().datetime().nullable().optional(),
  updated_by: z
    .object({
      email: z.string().nullable(),
      full_name: z.string().nullable(),
      username: z.string().nullable(),
      profile_uid: z.string().optional(),
    })
    .nullable()
    .optional(),
  version: z.string().optional(),
});

export type CaseResponseCreatedByProperties = z.infer<typeof CaseResponseCreatedByProperties>;
export const CaseResponseCreatedByProperties = z.object({
  email: z.string().nullable(),
  full_name: z.string().nullable(),
  username: z.string().nullable(),
  profile_uid: z.string().optional(),
});

export type CaseResponsePushedByProperties = z.infer<typeof CaseResponsePushedByProperties>;
export const CaseResponsePushedByProperties = z
  .object({
    email: z.string().nullable(),
    full_name: z.string().nullable(),
    username: z.string().nullable(),
    profile_uid: z.string().optional(),
  })
  .nullable();

export type CaseResponseUpdatedByProperties = z.infer<typeof CaseResponseUpdatedByProperties>;
export const CaseResponseUpdatedByProperties = z
  .object({
    email: z.string().nullable(),
    full_name: z.string().nullable(),
    username: z.string().nullable(),
    profile_uid: z.string().optional(),
  })
  .nullable();

export type UserCommentResponseProperties = z.infer<typeof UserCommentResponseProperties>;
export const UserCommentResponseProperties = z.object({
  comment: z.string().optional(),
  created_at: z.string().datetime().optional(),
  created_by: CaseResponseCreatedByProperties.optional(),
  id: z.string().optional(),
  owner: Owner.optional(),
  pushed_at: z.string().datetime().nullable().optional(),
  pushed_by: CaseResponsePushedByProperties.optional(),
  type: z.literal('user'),
  updated_at: z.string().datetime().nullable().optional(),
  updated_by: CaseResponseUpdatedByProperties.optional(),
  version: z.string().optional(),
});

export type ExternalService = z.infer<typeof ExternalService>;
export const ExternalService = z
  .object({
    connector_id: z.string().optional(),
    connector_name: z.string().optional(),
    external_id: z.string().optional(),
    external_title: z.string().optional(),
    external_url: z.string().optional(),
    pushed_at: z.string().datetime().optional(),
    pushed_by: z
      .object({
        email: z.string().nullable().optional(),
        full_name: z.string().nullable().optional(),
        username: z.string().nullable().optional(),
        profile_uid: z.string().optional(),
      })
      .nullable()
      .optional(),
  })
  .nullable();

/**
 * The status of the case.
 */
export type CaseStatus = z.infer<typeof CaseStatus>;
export const CaseStatus = z.enum(['closed', 'in-progress', 'open']);
export type CaseStatusEnum = typeof CaseStatus.enum;
export const CaseStatusEnum = CaseStatus.enum;

export type CaseResponseProperties = z.infer<typeof CaseResponseProperties>;
export const CaseResponseProperties = z.object({
  assignees: Assignees.optional(),
  /**
   * The case category.
   */
  category: z.string().nullable().optional(),
  closed_at: z.string().datetime().nullable(),
  closed_by: CaseResponseClosedByProperties,
  /**
   * An array of comment objects for the case.
   */
  comments: z
    .array(
      z.discriminatedUnion('type', [AlertCommentResponseProperties, UserCommentResponseProperties])
    )
    .max(10000),
  connector: z.discriminatedUnion('type', [
    ConnectorPropertiesNone,
    ConnectorPropertiesCasesWebhook,
    ConnectorPropertiesJira,
    ConnectorPropertiesResilient,
    ConnectorPropertiesServicenow,
    ConnectorPropertiesServicenowSir,
    ConnectorPropertiesSwimlane,
  ]),
  created_at: z.string().datetime(),
  created_by: CaseResponseCreatedByProperties,
  /**
   * Custom field values for the case.
   */
  customFields: z
    .array(
      z.object({
        /**
      * The unique identifier for the custom field. The key value must exist in the case configuration settings.

      */
        key: z.string().optional(),
        /**
      * The custom field type. It must match the type specified in the case configuration settings.

      */
        type: z.enum(['text', 'toggle']).optional(),
        /**
      * The custom field value. If the custom field is required, it cannot be explicitly set to null. However, for cases that existed when the required custom field was added, the default value stored in Elasticsearch is `undefined`. The value returned in the API and user interface in this case is `null`.

      */
        value: z.union([z.string().min(1).max(160).nullable(), z.boolean()]).optional(),
      })
    )
    .optional(),
  description: z.string(),
  /**
      * The elapsed time from the creation of the case to its closure (in seconds). If the case has not been closed, the duration is set to null. If the case was closed after less than half a second, the duration is rounded down to zero.

      */
  duration: z.number().int().nullable(),
  external_service: ExternalService,
  id: z.string(),
  owner: Owner,
  settings: Settings,
  severity: CaseSeverity,
  status: CaseStatus,
  tags: z.array(z.string()),
  title: z.string(),
  totalAlerts: z.number().int(),
  totalComment: z.number().int(),
  updated_at: z.string().datetime().nullable(),
  updated_by: CaseResponseUpdatedByProperties,
  version: z.string(),
});

export type Response4Xx = z.infer<typeof Response4Xx>;
export const Response4Xx = z.object({
  error: z.string().optional(),
  message: z.string().optional(),
  statusCode: z.number().int().optional(),
});

/**
 * The update case API request body varies depending on the type of connector.
 */
export type UpdateCaseRequest = z.infer<typeof UpdateCaseRequest>;
export const UpdateCaseRequest = z.object({
  /**
   * An array containing one or more case objects.
   */
  cases: z
    .array(
      z.object({
        assignees: Assignees.optional(),
        category: CaseCategory.optional(),
        connector: z
          .union([
            ConnectorPropertiesNone,
            ConnectorPropertiesCasesWebhook,
            ConnectorPropertiesJira,
            ConnectorPropertiesResilient,
            ConnectorPropertiesServicenow,
            ConnectorPropertiesServicenowSir,
            ConnectorPropertiesSwimlane,
          ])
          .optional(),
        /**
      * Custom field values for a case. Any optional custom fields that are not specified in the request are set to null.

      */
        customFields: z
          .array(
            z.object({
              /**
      * The unique identifier for the custom field. The key value must exist in the case configuration settings.

      */
              key: z.string(),
              /**
      * The custom field type. It must match the type specified in the case configuration settings.

      */
              type: z.enum(['text', 'toggle']),
              /**
      * The custom field value. If the custom field is required, it cannot be explicitly set to null. However, for cases that existed when the required custom field was added, the default value stored in Elasticsearch is `undefined`. The value returned in the API and user interface in this case is `null`.

      */
              value: z.union([z.string().min(1).max(160).nullable(), z.boolean()]),
            })
          )
          .max(10)
          .optional(),
        description: CaseDescription.optional(),
        /**
         * The identifier for the case.
         */
        id: z.string().max(30000),
        settings: Settings.optional(),
        severity: CaseSeverity.optional(),
        status: CaseStatus.optional(),
        tags: CaseTags.optional(),
        title: CaseTitle.optional(),
        /**
      * The current version of the case. To determine this value, use the get case or search cases (`_find`) APIs.

      */
        version: z.string(),
      })
    )
    .min(1)
    .max(100),
});

export type String = z.infer<typeof String>;
export const String = z.string();

export type StringArray = z.infer<typeof StringArray>;
export const StringArray = z.array(String).max(100);

export type CaseCategories = z.infer<typeof CaseCategories>;
export const CaseCategories = z.array(CaseCategory).max(100);

export type Owners = z.infer<typeof Owners>;
export const Owners = z.array(Owner);

/**
 * The fields to perform the `simple_query_string` parsed query against.
 */
export type SearchFieldsType = z.infer<typeof SearchFieldsType>;
export const SearchFieldsType = z.enum(['description', 'title']);
export type SearchFieldsTypeEnum = typeof SearchFieldsType.enum;
export const SearchFieldsTypeEnum = SearchFieldsType.enum;

export type SearchFieldsTypeArray = z.infer<typeof SearchFieldsTypeArray>;
export const SearchFieldsTypeArray = z.array(SearchFieldsType);

/**
 * Indicates whether a case is automatically closed when it is pushed to external systems (`close-by-pushing`) or not automatically closed (`close-by-user`).
 */
export type ClosureTypes = z.infer<typeof ClosureTypes>;
export const ClosureTypes = z.enum(['close-by-pushing', 'close-by-user']);
export type ClosureTypesEnum = typeof ClosureTypes.enum;
export const ClosureTypesEnum = ClosureTypes.enum;

/**
 * The type of connector.
 */
export type ConnectorTypes = z.infer<typeof ConnectorTypes>;
export const ConnectorTypes = z.enum([
  '.cases-webhook',
  '.jira',
  '.none',
  '.resilient',
  '.servicenow',
  '.servicenow-sir',
  '.swimlane',
]);
export type ConnectorTypesEnum = typeof ConnectorTypes.enum;
export const ConnectorTypesEnum = ConnectorTypes.enum;

/**
  * The words and phrases that help categorize templates. It can be an empty array.

  */
export type TemplateTags = z.infer<typeof TemplateTags>;
export const TemplateTags = z.array(z.string().max(256)).max(200);

export type Templates = z.infer<typeof Templates>;
export const Templates = z.array(
  z.object({
    caseFields: z
      .object({
        assignees: Assignees.optional(),
        category: CaseCategory.optional(),
        connector: z
          .object({
            /**
             * The fields specified in the case configuration are not used and are not propagated to individual cases, therefore it is recommended to set it to `null`.
             */
            fields: z.object({}).nullable().optional(),
            /**
             * The identifier for the connector. If you do not want a default connector, use `none`. To retrieve connector IDs, use the find connectors API.
             */
            id: z.string().optional(),
            /**
             * The name of the connector. If you do not want a default connector, use `none`. To retrieve connector names, use the find connectors API.
             */
            name: z.string().optional(),
            type: ConnectorTypes.optional(),
          })
          .optional(),
        /**
         * Custom field values in the template.
         */
        customFields: z
          .array(
            z.object({
              /**
               * The unique key for the custom field.
               */
              key: z.string().optional(),
              /**
               * The type of the custom field.
               */
              type: z.enum(['text', 'toggle']).optional(),
              /**
      * The default value for the custom field when a case uses the template. If the `type` is `text`, the default value must be a string. If the `type` is `toggle`, the default value must be boolean.

      */
              value: z.union([z.string(), z.boolean()]).optional(),
            })
          )
          .optional(),
        description: CaseDescription.optional(),
        settings: Settings.optional(),
        severity: CaseSeverity.optional(),
        tags: CaseTags.optional(),
        title: CaseTitle.optional(),
      })
      .optional(),
    /**
     * A description for the template.
     */
    description: z.string().optional(),
    /**
      * A unique key for the template. Must be lower case and composed only of a-z, 0-9, '_', and '-' characters. It is used in API calls to refer to a specific template.

      */
    key: z.string().optional(),
    /**
     * The name of the template.
     */
    name: z.string().optional(),
    tags: TemplateTags.optional(),
  })
);

/**
 * External connection details, such as the closure type and default connector for cases.
 */
export type SetCaseConfigurationRequest = z.infer<typeof SetCaseConfigurationRequest>;
export const SetCaseConfigurationRequest = z.object({
  closure_type: ClosureTypes,
  /**
   * An object that contains the connector configuration.
   */
  connector: z.object({
    /**
     * The fields specified in the case configuration are not used and are not propagated to individual cases, therefore it is recommended to set it to `null`.
     */
    fields: z.object({}).nullable(),
    /**
     * The identifier for the connector. If you do not want a default connector, use `none`. To retrieve connector IDs, use the find connectors API.
     */
    id: z.string(),
    /**
     * The name of the connector. If you do not want a default connector, use `none`. To retrieve connector names, use the find connectors API.
     */
    name: z.string(),
    type: ConnectorTypes,
  }),
  /**
   * Custom fields case configuration.
   */
  customFields: z
    .array(
      z.object({
        /**
      * A default value for the custom field. If the `type` is `text`, the default value must be a string. If the `type` is `toggle`, the default value must be boolean.

      */
        defaultValue: z.union([z.string(), z.boolean()]).optional(),
        /**
      * A unique key for the custom field. Must be lower case and composed only of a-z, 0-9, '_', and '-' characters. It is used in API calls to refer to a specific custom field.

      */
        key: z.string().min(1).max(36),
        /**
         * The custom field label that is displayed in the case.
         */
        label: z.string().min(1).max(50),
        /**
      * Indicates whether the field is required. If `false`, the custom field can be set to null or omitted when a case is created or updated.

      */
        required: z.boolean(),
        /**
         * The type of the custom field.
         */
        type: z.enum(['text', 'toggle']),
      })
    )
    .max(10)
    .optional(),
  owner: Owner,
  templates: Templates.optional(),
});

/**
  * You can update settings such as the closure type, custom fields, templates, and the default connector for cases.

  */
export type UpdateCaseConfigurationRequest = z.infer<typeof UpdateCaseConfigurationRequest>;
export const UpdateCaseConfigurationRequest = z.object({
  closure_type: ClosureTypes.optional(),
  /**
   * An object that contains the connector configuration.
   */
  connector: z
    .object({
      /**
       * The fields specified in the case configuration are not used and are not propagated to individual cases, therefore it is recommended to set it to `null`.
       */
      fields: z.object({}).nullable(),
      /**
       * The identifier for the connector. If you do not want a default connector, use `none`. To retrieve connector IDs, use the find connectors API.
       */
      id: z.string(),
      /**
       * The name of the connector. If you do not want a default connector, use `none`. To retrieve connector names, use the find connectors API.
       */
      name: z.string(),
      type: ConnectorTypes,
    })
    .optional(),
  /**
   * Custom fields case configuration.
   */
  customFields: z
    .array(
      z.object({
        /**
      * A default value for the custom field. If the `type` is `text`, the default value must be a string. If the `type` is `toggle`, the default value must be boolean.

      */
        defaultValue: z.union([z.string(), z.boolean()]).optional(),
        /**
      * A unique key for the custom field. Must be lower case and composed only of a-z, 0-9, '_', and '-' characters. It is used in API calls to refer to a specific custom field.

      */
        key: z.string().min(1).max(36),
        /**
         * The custom field label that is displayed in the case.
         */
        label: z.string().min(1).max(50),
        /**
      * Indicates whether the field is required. If `false`, the custom field can be set to null or omitted when a case is created or updated.

      */
        required: z.boolean(),
        /**
         * The type of the custom field.
         */
        type: z.enum(['text', 'toggle']),
      })
    )
    .optional(),
  templates: Templates.optional(),
  /**
      * The version of the connector. To retrieve the version value, use the get configuration API.

      */
  version: z.string(),
});

export type AlertResponseProperties = z.infer<typeof AlertResponseProperties>;
export const AlertResponseProperties = z.object({
  attached_at: z.string().datetime().optional(),
  /**
   * The alert identifier.
   */
  id: z.string().optional(),
  /**
   * The alert index.
   */
  index: z.string().optional(),
});

/**
  * The alert identifiers. It is required only when `type` is `alert`. You can use an array of strings to add multiple alerts to a case, provided that they all relate to the same rule; `index` must also be an array with the same length or number of elements. Adding multiple alerts in this manner is recommended rather than calling the API multiple times. This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

  */
export type AlertIdentifiers = z.infer<typeof AlertIdentifiers>;
export const AlertIdentifiers = z.union([z.string(), z.array(z.string()).max(1000)]);

/**
  * The alert indices. It is required only when `type` is `alert`. If you are adding multiple alerts to a case, use an array of strings; the position of each index name in the array must match the position of the corresponding alert identifier in the `alertId` array.  This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

  */
export type AlertIndices = z.infer<typeof AlertIndices>;
export const AlertIndices = z.union([z.string(), z.array(z.string()).max(1000)]);

/**
  * The rule that is associated with the alerts. It is required only when `type` is `alert`. This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

  */
export type Rule = z.infer<typeof Rule>;
export const Rule = z.object({
  /**
   * The rule identifier.
   */
  id: z.string().optional(),
  /**
   * The rule name.
   */
  name: z.string().optional(),
});

/**
 * Defines properties for case comment requests when type is alert.
 */
export type AddAlertCommentRequestProperties = z.infer<typeof AddAlertCommentRequestProperties>;
export const AddAlertCommentRequestProperties = z.object({
  alertId: AlertIdentifiers,
  index: AlertIndices,
  owner: Owner,
  rule: Rule,
  /**
   * The type of comment.
   */
  type: z.literal('alert'),
});

/**
 * Defines properties for case comment requests when type is user.
 */
export type AddUserCommentRequestProperties = z.infer<typeof AddUserCommentRequestProperties>;
export const AddUserCommentRequestProperties = z.object({
  /**
   * The new comment. It is required only when `type` is `user`.
   */
  comment: z.string().max(30000),
  owner: Owner,
  /**
   * The type of comment.
   */
  type: z.literal('user'),
});

/**
 * The add comment to case API request body varies depending on whether you are adding an alert or a comment.
 */
export type AddCaseCommentRequest = z.infer<typeof AddCaseCommentRequest>;
export const AddCaseCommentRequest = z.discriminatedUnion('type', [
  AddAlertCommentRequestProperties,
  AddUserCommentRequestProperties,
]);

/**
 * Defines properties for case comment requests when type is alert.
 */
export type UpdateAlertCommentRequestProperties = z.infer<
  typeof UpdateAlertCommentRequestProperties
>;
export const UpdateAlertCommentRequestProperties = z.object({
  alertId: AlertIdentifiers,
  /**
      * The identifier for the comment. To retrieve comment IDs, use the get comments API.

      */
  id: z.string(),
  index: AlertIndices,
  owner: Owner,
  rule: Rule,
  /**
   * The type of comment.
   */
  type: z.literal('alert'),
  /**
      * The current comment version. To retrieve version values, use the get comments API.

      */
  version: z.string(),
});

/**
 * Defines properties for case comment requests when type is user.
 */
export type UpdateUserCommentRequestProperties = z.infer<typeof UpdateUserCommentRequestProperties>;
export const UpdateUserCommentRequestProperties = z.object({
  /**
   * The new comment. It is required only when `type` is `user`.
   */
  comment: z.string().max(30000),
  /**
      * The identifier for the comment. To retrieve comment IDs, use the get comments API.

      */
  id: z.string(),
  owner: Owner,
  /**
   * The type of comment.
   */
  type: z.literal('user'),
  /**
      * The current comment version. To retrieve version values, use the get comments API.

      */
  version: z.string(),
});

/**
 * The update case comment API request body varies depending on whether you are updating an alert or a comment.
 */
export type UpdateCaseCommentRequest = z.infer<typeof UpdateCaseCommentRequest>;
export const UpdateCaseCommentRequest = z.discriminatedUnion('type', [
  UpdateAlertCommentRequestProperties,
  UpdateUserCommentRequestProperties,
]);

export type Actions = z.infer<typeof Actions>;
export const Actions = z.enum(['add', 'create', 'delete', 'push_to_service', 'update']);
export type ActionsEnum = typeof Actions.enum;
export const ActionsEnum = Actions.enum;

export type PayloadAlertComment = z.infer<typeof PayloadAlertComment>;
export const PayloadAlertComment = z.object({
  comment: z
    .object({
      alertId: z.union([z.string(), z.array(z.string())]).optional(),
      index: z.union([z.string(), z.array(z.string())]).optional(),
      owner: Owner.optional(),
      rule: z
        .object({
          /**
           * The rule identifier.
           */
          id: z.string().optional(),
          /**
           * The rule name.
           */
          name: z.string().optional(),
        })
        .optional(),
      type: z.literal('alert').optional(),
    })
    .optional(),
});

export type PayloadAssignees = z.infer<typeof PayloadAssignees>;
export const PayloadAssignees = z.object({
  assignees: Assignees.optional(),
});

export type PayloadConnector = z.infer<typeof PayloadConnector>;
export const PayloadConnector = z.object({
  connector: z
    .object({
      /**
       * An object containing the connector fields. To create a case without a connector, specify null. If you want to omit any individual field, specify null as its value.
       */
      fields: z
        .object({
          /**
           * The case identifier for Swimlane connectors.
           */
          caseId: z.string().optional(),
          /**
           * The category of the incident for ServiceNow ITSM and ServiceNow SecOps connectors.
           */
          category: z.string().optional(),
          /**
           * Indicates whether cases will send a comma-separated list of destination IPs for ServiceNow SecOps connectors.
           */
          destIp: z.boolean().nullable().optional(),
          /**
           * The effect an incident had on business for ServiceNow ITSM connectors.
           */
          impact: z.string().optional(),
          /**
           * The type of issue for Jira connectors.
           */
          issueType: z.string().optional(),
          /**
           * The type of incident for IBM Resilient connectors.
           */
          issueTypes: z.array(z.string()).optional(),
          /**
           * Indicates whether cases will send a comma-separated list of malware hashes for ServiceNow SecOps connectors.
           */
          malwareHash: z.boolean().nullable().optional(),
          /**
           * Indicates whether cases will send a comma-separated list of malware URLs for ServiceNow SecOps connectors.
           */
          malwareUrl: z.boolean().nullable().optional(),
          /**
           * The key of the parent issue, when the issue type is sub-task for Jira connectors.
           */
          parent: z.string().optional(),
          /**
           * The priority of the issue for Jira and ServiceNow SecOps connectors.
           */
          priority: z.string().optional(),
          /**
           * The severity of the incident for ServiceNow ITSM connectors.
           */
          severity: z.string().optional(),
          /**
           * The severity code of the incident for IBM Resilient connectors.
           */
          severityCode: z.string().optional(),
          /**
           * Indicates whether cases will send a comma-separated list of source IPs for ServiceNow SecOps connectors.
           */
          sourceIp: z.boolean().nullable().optional(),
          /**
           * The subcategory of the incident for ServiceNow ITSM connectors.
           */
          subcategory: z.string().optional(),
          /**
           * The extent to which the incident resolution can be delayed for ServiceNow ITSM connectors.
           */
          urgency: z.string().optional(),
        })
        .nullable()
        .optional(),
      /**
       * The identifier for the connector. To create a case without a connector, use `none`.
       */
      id: z.string().optional(),
      /**
       * The name of the connector. To create a case without a connector, use `none`.
       */
      name: z.string().optional(),
      type: ConnectorTypes.optional(),
    })
    .optional(),
});

export type PayloadCreateCase = z.infer<typeof PayloadCreateCase>;
export const PayloadCreateCase = z.object({
  assignees: Assignees.optional(),
  connector: z
    .object({
      /**
       * An object containing the connector fields. To create a case without a connector, specify null. If you want to omit any individual field, specify null as its value.
       */
      fields: z
        .object({
          /**
           * The case identifier for Swimlane connectors.
           */
          caseId: z.string().optional(),
          /**
           * The category of the incident for ServiceNow ITSM and ServiceNow SecOps connectors.
           */
          category: z.string().optional(),
          /**
           * Indicates whether cases will send a comma-separated list of destination IPs for ServiceNow SecOps connectors.
           */
          destIp: z.boolean().nullable().optional(),
          /**
           * The effect an incident had on business for ServiceNow ITSM connectors.
           */
          impact: z.string().optional(),
          /**
           * The type of issue for Jira connectors.
           */
          issueType: z.string().optional(),
          /**
           * The type of incident for IBM Resilient connectors.
           */
          issueTypes: z.array(z.string()).optional(),
          /**
           * Indicates whether cases will send a comma-separated list of malware hashes for ServiceNow SecOps connectors.
           */
          malwareHash: z.boolean().nullable().optional(),
          /**
           * Indicates whether cases will send a comma-separated list of malware URLs for ServiceNow SecOps connectors.
           */
          malwareUrl: z.boolean().nullable().optional(),
          /**
           * The key of the parent issue, when the issue type is sub-task for Jira connectors.
           */
          parent: z.string().optional(),
          /**
           * The priority of the issue for Jira and ServiceNow SecOps connectors.
           */
          priority: z.string().optional(),
          /**
           * The severity of the incident for ServiceNow ITSM connectors.
           */
          severity: z.string().optional(),
          /**
           * The severity code of the incident for IBM Resilient connectors.
           */
          severityCode: z.string().optional(),
          /**
           * Indicates whether cases will send a comma-separated list of source IPs for ServiceNow SecOps connectors.
           */
          sourceIp: z.boolean().nullable().optional(),
          /**
           * The subcategory of the incident for ServiceNow ITSM connectors.
           */
          subcategory: z.string().optional(),
          /**
           * The extent to which the incident resolution can be delayed for ServiceNow ITSM connectors.
           */
          urgency: z.string().optional(),
        })
        .nullable()
        .optional(),
      /**
       * The identifier for the connector. To create a case without a connector, use `none`.
       */
      id: z.string().optional(),
      /**
       * The name of the connector. To create a case without a connector, use `none`.
       */
      name: z.string().optional(),
      type: ConnectorTypes.optional(),
    })
    .optional(),
  description: z.string().optional(),
  owner: Owner.optional(),
  settings: Settings.optional(),
  severity: CaseSeverity.optional(),
  status: CaseStatus.optional(),
  tags: z.array(z.string()).optional(),
  title: z.string().optional(),
});

/**
 * If the `action` is `delete` and the `type` is `delete_case`, the payload is nullable.
 */
export type PayloadDelete = z.infer<typeof PayloadDelete>;
export const PayloadDelete = z.object({}).nullable();

export type PayloadDescription = z.infer<typeof PayloadDescription>;
export const PayloadDescription = z.object({
  description: z.string().optional(),
});

export type PayloadPushed = z.infer<typeof PayloadPushed>;
export const PayloadPushed = z.object({
  externalService: ExternalService.optional(),
});

export type PayloadSettings = z.infer<typeof PayloadSettings>;
export const PayloadSettings = z.object({
  settings: Settings.optional(),
});

export type PayloadSeverity = z.infer<typeof PayloadSeverity>;
export const PayloadSeverity = z.object({
  severity: CaseSeverity.optional(),
});

export type PayloadStatus = z.infer<typeof PayloadStatus>;
export const PayloadStatus = z.object({
  status: CaseStatus.optional(),
});

export type PayloadTags = z.infer<typeof PayloadTags>;
export const PayloadTags = z.object({
  tags: z.array(z.string()).optional(),
});

export type PayloadTitle = z.infer<typeof PayloadTitle>;
export const PayloadTitle = z.object({
  title: z.string().optional(),
});

export type PayloadUserComment = z.infer<typeof PayloadUserComment>;
export const PayloadUserComment = z.object({
  comment: z
    .object({
      comment: z.string().optional(),
      owner: Owner.optional(),
      type: z.literal('user').optional(),
    })
    .optional(),
});

export type UserActionsFindResponseProperties = z.infer<typeof UserActionsFindResponseProperties>;
export const UserActionsFindResponseProperties = z.object({
  action: Actions,
  comment_id: z.string().nullable(),
  created_at: z.string().datetime(),
  created_by: z.object({
    email: z.string().nullable(),
    full_name: z.string().nullable(),
    username: z.string().nullable(),
    profile_uid: z.string().optional(),
  }),
  id: z.string(),
  owner: Owner,
  payload: z.union([
    PayloadAlertComment,
    PayloadAssignees,
    PayloadConnector,
    PayloadCreateCase,
    PayloadDelete,
    PayloadDescription,
    PayloadPushed,
    PayloadSettings,
    PayloadSeverity,
    PayloadStatus,
    PayloadTags,
    PayloadTitle,
    PayloadUserComment,
  ]),
  version: z.string(),
  /**
   * The type of action.
   */
  type: z.enum([
    'assignees',
    'create_case',
    'comment',
    'connector',
    'description',
    'pushed',
    'tags',
    'title',
    'status',
    'settings',
    'severity',
  ]),
});

/**
 * Defines the file that will be attached to the case. Optional parameters will be generated automatically from the file metadata if not defined.
 */
export type AddCaseFileRequest = z.infer<typeof AddCaseFileRequest>;
export const AddCaseFileRequest = z.object({
  /**
   * The file being attached to the case.
   */
  file: z.string(),
  /**
   * The desired name of the file being attached to the case, it can be different than the name of the file in the filesystem. **This should not include the file extension.**
   */
  filename: z.string().optional(),
});
