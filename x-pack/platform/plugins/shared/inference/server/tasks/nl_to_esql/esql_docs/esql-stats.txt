## STATS

The `STATS` processing command groups rows based on a common value and calculates one or more aggregated values over the grouped rows.

## Syntax

`STATS [column1 =] expression1 [WHERE boolean_expression1][, ..., [columnN =] expressionN [WHERE boolean_expressionN]] [BY grouping_expression1[, ..., grouping_expressionN]]`

### Parameters

#### `columnX`

The name by which the aggregated value is returned. If omitted, the name defaults to the corresponding expression (`expressionX`). If multiple columns have the same name, all but the rightmost column with this name are ignored.

#### `expressionX`

An expression that computes an aggregated value.

#### `grouping_expressionX`

An expression that outputs the values to group by. If its name coincides with one of the computed columns, that column will be ignored.

#### `boolean_expressionX`

The condition that must be met for a row to be included in the evaluation of `expressionX`.

## Examples

### Calculating a statistic and grouping by the values of another column

Group employees by the `languages` column and calculate the count of employees for each language:

```esql
FROM employees
| STATS count = COUNT(emp_no) BY languages
| SORT languages
```

### Omitting `BY` to return one row with the aggregations applied over the entire dataset

Calculate the average number of languages spoken by employees across the entire dataset:

```esql
FROM employees
| STATS avg_lang = AVG(languages)
```

### Calculating multiple values

Calculate both the average and maximum number of languages spoken by employees:

```esql
FROM employees
| STATS avg_lang = AVG(languages), max_lang = MAX(languages)
```

### Filtering rows that go into an aggregation using `WHERE`

Calculate the average salary for employees born before and after 1960, grouped by gender:

```esql
FROM employees
| STATS avg50s = AVG(salary)::LONG WHERE birth_date < "1960-01-01", avg60s = AVG(salary)::LONG WHERE birth_date > BY gender
| SORT gender
```

### Mixing aggregations with and without filters, and optional grouping

Count employees in different salary ranges and calculate the total count:

```esql
FROM employees
| EVAL Ks = salary / 1000 // thousands
| STATS under_40K = COUNT(*) WHERE Ks < 40, inbetween = COUNT(*) WHERE 40 <, over_60K = COUNT(*) WHERE 60 <, total = COUNT(*)
```

### Grouping by a multivalued key

Group rows by a multivalued column and calculate the minimum value for each group:

```esql
ROW i=1, a=["a", "b"]
| STATS MIN(i) BY a
| SORT a ASC
```

### Grouping by multiple values

Group employees by the year they were hired and the number of languages they speak, then calculate the average salary for each group:

```esql
FROM employees
| EVAL hired = DATE_FORMAT("yyyy", hire_date)
| STATS avg_salary = AVG(salary) BY hired, languages.long
| EVAL avg_salary = ROUND(avg_salary)
| SORT hired, languages.long
```

### Grouping by multiple multivalued keys

Group rows by multiple multivalued columns and calculate the minimum value for each group:

```esql
ROW i=1, a=["a", "b"], b=[2, 3]
| STATS MIN(i) BY a, b
| SORT a ASC, b ASC
```

### Using functions in aggregations and grouping expressions

Calculate the average salary change using the `MV_AVG` function:

```esql
FROM employees
| STATS avg_salary_change = ROUND(AVG(MV_AVG(salary_change)), 10)
```

### Grouping by an expression

Group employees by the first letter of their last name and count the number of employees in each group:

```esql
FROM employees
| STATS my_count = COUNT() BY LEFT(last_name, 1)
| SORT `LEFT(last_name, 1)`
```

### Specifying the output column name (optional)

Calculate the average salary without explicitly naming the output column:

```esql
FROM employees
| STATS AVG(salary)
```

### Using a column with special characters in subsequent commands

Calculate the average salary and round the result, using backticks to handle special characters in the column name:

```esql
FROM employees
| STATS AVG(salary)
| EVAL avg_salary_rounded = ROUND(`AVG(salary)`)
```

## Limitations

- Individual `null` values are skipped when computing aggregations.
- `STATS` without any groups is significantly faster than adding a group.
- Grouping on a single expression is more optimized than grouping on multiple expressions. For example, grouping on a single `keyword` column can be five times faster than grouping on two `keyword` columns. Avoid combining columns with functions like `CONCAT` for grouping, as it will not improve performance.