# WHERE

The WHERE command filters rows from the input table, returning only those for which the specified condition evaluates to true. When excluding values, fields with null values are also excluded from the results. In this context, a null value means either an explicit null or the absence of a value. For example, `WHERE field != "value"` is interpreted as `WHERE field != "value" AND field IS NOT NULL`.

## Syntax

`WHERE expression`

### Parameters

#### expression

A boolean expression that determines which rows are included in the output.

## Examples

Filter employees who are still hired:

This query selects the first name, last name, and hiring status of employees, and then filters the results to include only those employees who are currently hired.

```esql
FROM employees
| KEEP first_name, last_name, still_hired
| WHERE still_hired == true
```

Simplified filtering when the field is boolean:

This query keeps the first name, last name, and hiring status of employees, and filters to include only those where the `still_hired` field is true. Since `still_hired` is a boolean, the condition can be written directly.

```esql
FROM employees
| KEEP first_name, last_name, still_hired
| WHERE still_hired
```

Retrieve logs from the last hour using date math:

This query retrieves records from the `sample_data` source where the `@timestamp` field is within the last hour.

```esql
FROM sample_data
| WHERE @timestamp > NOW() - 1 hour
```

Filter employees with a first name shorter than 4 characters using the LENGTH function:

This query selects the first name, last name, and height of employees, and filters to include only those whose first name is less than 4 characters long.

```esql
FROM employees
| KEEP first_name, last_name, height
| WHERE LENGTH(first_name) < 4
```

Check for null values in the birth_date field:

This query returns all employees whose `birth_date` field is null or missing.

```esql
FROM employees
| WHERE birth_date IS NULL
```

Filter employees where is_rehired is not null and count them:

This query filters employees to include only those where the `is_rehired` field is not null, and then counts the number of such employees.

```esql
FROM employees
| WHERE is_rehired IS NOT NULL
| STATS COUNT(emp_no)
```

Match the author field for the term "Faulkner":

This query returns all books where the `author` field matches the term "Faulkner".

```esql
FROM books
| WHERE MATCH(author, "Faulkner")
```

Match the title field for all terms "Hobbit Back Again" using the AND operator:

This query returns book titles that contain all the terms "Hobbit", "Back", and "Again" in the `title` field, using the AND operator for matching.

```esql
FROM books
| WHERE MATCH(title, "Hobbit Back Again", {"operator": "AND"})
| KEEP title;
```

Use the shorthand match operator `:` to match text fields.

Filter employees whose first name matches the pattern "?b*":

This query returns employees whose first name matches the wildcard pattern "?b*", where "?" matches any single character and "*" matches any sequence of characters.

```esql
FROM employees
| WHERE first_name LIKE """?b*"""
| KEEP first_name, last_name
```

Match the exact characters `*` and `.` by escaping them:

This query creates a row with the message "foo * bar" and filters to include only those where the message matches the pattern "foo * bar", treating the asterisk as a literal character.

```esql
ROW message = "foo * bar"
| WHERE message LIKE "foo \\* bar"
```

Reduce escaping overhead with triple-quoted strings:

This query demonstrates how to use triple-quoted strings to reduce the need for escaping special characters when matching the message "foo * bar".

```esql
ROW message = "foo * bar"
| WHERE message LIKE """foo \* bar"""
```

Filter rows where the message matches any of the patterns "foo*" or "bar?":

This query creates a row with the message "foobar" and filters to include only those where the message matches either the pattern "foo*" or "bar?".

```esql
ROW message = "foobar"
| WHERE message like ("foo*", "bar?")
```

Use REST query placeholders for patterns:

This query filters employees to include only those whose first name matches a pattern provided as a REST query placeholder.

```esql
FROM employees
| WHERE first_name LIKE ?pattern
| KEEP first_name, last_name
```

Filter employees whose first name matches the regular expression ".leja.*":

This query returns employees whose first name matches the regular expression ".leja.*", where "." matches any character and ".*" matches any sequence of characters.

```esql
FROM employees
| WHERE first_name RLIKE """.leja.*"""
| KEEP first_name, last_name
```

Escape special regex characters with backslash:

This query creates a row with the message "foo ( bar" and filters to include only those where the message matches the regular expression "foo \( bar", treating the parenthesis as a literal character.

```esql
ROW message = "foo ( bar"
| WHERE message RLIKE "foo \\( bar"
```

Reduce escaping overhead for regex with triple-quoted strings:

This query demonstrates how to use triple-quoted strings to reduce the need for escaping special regex characters when matching the message "foo ( bar".

```esql
ROW message = "foo ( bar"
| WHERE message RLIKE """foo \( bar"""
```

Filter rows where the message matches any of the regex patterns "foo.*" or "bar.":

This query creates a row with the message "foobar" and filters to include only those where the message matches either the regular expression "foo.*" or "bar.".

```esql
ROW message = "foobar"
| WHERE message RLIKE ("foo.*", "bar.")
```

Use REST query placeholders for regex patterns:

This query filters employees to include only those whose first name matches a regular expression pattern provided as a REST query placeholder.

```esql
FROM employees
| WHERE first_name RLIKE ?pattern
| KEEP first_name, last_name
```

Test if an expression is in a list of values using IN:

This query creates a row with values for `a`, `b`, and `c`, and filters to include only those where the value of `c-a` is in the list (3, b / 2, a).

```esql
ROW a = 1, b = 4, c = 3
| WHERE c-a IN (3, b / 2, a)
```