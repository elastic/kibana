# TO_LONG

Converts the input value to a long integer. If the input is a date type, its value is interpreted as milliseconds since the Unix epoch and converted to long. Boolean `true` is converted to `1`, and `false` to `0`. When two arguments are provided—a string value and a whole number base—the string is parsed as a long in the specified base. If parsing fails, a warning is generated and the result is `null`. A leading '0x' prefix is allowed for base 16.

## Syntax

`TO_LONG(field, base)`

### Parameters

#### field

The input value to convert. This can be a single- or multi-valued column or an expression.

#### base

(Optional) The radix or base used to convert the input value. When a base is specified, the input type must be `keyword` or `text`.

## Examples

This query creates three string fields and attempts to convert each to a long integer. The first conversion succeeds, the second (a decimal string) fails and returns `null`, and the third (a non-numeric string) also fails and returns `null`, both generating warnings.
```esql
ROW str1 = "2147483648", str2 = "2147483648.2", str3 = "foo"
| EVAL long1 = TO_LONG(str1), long2 = TO_LONG(str2), long3 = TO_LONG(str3)
```

This query demonstrates parsing string values as long integers using different bases. The first string is parsed as a hexadecimal (base 16) value, and the second string is parsed as a base 13 value. The results are kept alongside the original strings.
```esql
ROW str1 = "0x32", str2 = "31"
| EVAL long1 = TO_LONG(str1, 16), long2 = TO_LONG(str2, 13)
| KEEP str1, long1, str2, long2
```

This query attempts to parse the string "Hazelnut" as a base 36 value (which succeeds and returns a numeric value) and as a base 10 value (which fails and returns `null` with a warning).
```esql
ROW str1 = "Hazelnut"
| EVAL long1 = TO_LONG(str1, 36), fail1 = TO_LONG(str1, 10)
```