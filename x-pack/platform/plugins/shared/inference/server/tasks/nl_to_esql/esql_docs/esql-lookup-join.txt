# LOOKUP-JOIN

The LOOKUP JOIN command adds new columns to your query results by finding documents in a lookup index that share the same join field value as your result rows. For each row that matches a document in the lookup index based on the join fields, all fields from the matching document are added as new columns to that row. If multiple documents in the lookup index match a single row, the output will contain one row for each matching combination. This command enables you to enrich your data by adding information from another index, simplifying data analysis workflows.

## Syntax

`FROM <source_index> | LOOKUP JOIN <lookup_index> ON <join_condition>`

### Parameters

#### <lookup_index>

The name of the lookup index. This must be a specific index name; wildcards, aliases, and remote cluster references are not supported. Indices used for lookups must be configured with the `lookup` index mode.

#### <join_condition>

Can be one of the following:
- A single field name.
- A comma-separated list of field names, for example `<field1>, <field2>, <field3>`.
- An expression with one or more predicates linked by `AND`, for example `<left_field1> >= <lookup_field1> AND <left_field2> == <lookup_field2>`. Each predicate compares a field from the left index with a field from the lookup index using binary operators (`==`, `>=`, `<=`, `>`, `<`, `!=`). Each field name in the join condition must exist in only one of the indexes. Use RENAME to resolve naming conflicts.
- An expression that includes full text functions and other Lucene-pushable functions, for example `MATCH(<lookup_field>, "search term") AND <left_field> == <lookup_field>`. These functions can be combined with binary operators and logical operators (`AND`, `OR`, `NOT`) to create complex join conditions. At least one condition that relates the lookup index fields to the left side of the join fields is still required.

If using join on a single field or a field list, the fields used must exist in both your current query results and in the lookup index. If the fields contain multi-valued entries, those entries will not match anything (the added fields will contain null for those rows).

## Examples

IP Threat correlation: See if any source IPs match known malicious addresses.

This query retrieves all records from the `firewall_logs` index and enriches each row by joining with the `threat_list` index where the `source.IP` field matches. This allows you to see which firewall log entries have source IPs that are present in the threat list.

```esql
FROM firewall_logs
| LOOKUP JOIN threat_list ON source.IP
```

This query retrieves all records from the `firewall_logs` index, joins them with the `threat_list` index on the `source.IP` field, and then filters the results to only include rows where a matching threat level was found (i.e., where `threat_level` is not null). This helps you focus on logs that are associated with known threats.

```esql
FROM firewall_logs
| LOOKUP JOIN threat_list ON source.IP
| WHERE threat_level IS NOT NULL
```

Host metadata correlation: Pull in environment or ownership details for each host to correlate with your metrics data.

This query retrieves all records from the `system_metrics` index, enriches them with host metadata from the `host_inventory` index by joining on `host.name`, and further enriches the results with ownership information from the `ownerships` index, also joined on `host.name`. This provides a comprehensive view of system metrics along with host and ownership details.

```esql
FROM system_metrics
| LOOKUP JOIN host_inventory ON host.name
| LOOKUP JOIN ownerships ON host.name
```

Service ownership mapping: Show logs with the owning team or escalation information for faster triage and incident response.

This query retrieves all records from the `app_logs` index and enriches each log entry with service ownership information from the `service_owners` index by joining on the `service_id` field. This helps you quickly identify the responsible team or escalation path for each log entry.

```esql
FROM app_logs
| LOOKUP JOIN service_owners ON service_id
```

LOOKUP JOIN is generally faster when there are fewer rows to join with. The optimizer will move the filter before the lookup when possible, regardless of query order.

This query retrieves records from the `employees` index, creates a new field `language_code` from the `languages` field, filters employees with `emp_no` between 10091 and 10093, and then enriches the results with language details from the `languages_lookup` index by joining on `language_code`.

```esql
FROM employees
| EVAL language_code = languages
| WHERE emp_no >= 10091 AND emp_no < 10094
| LOOKUP JOIN languages_lookup ON language_code
```

This query retrieves records from the `employees` index, creates a new field `language_code` from the `languages` field, enriches the results with language details from the `languages_lookup` index by joining that's done before filtering employees with `emp_no` between 10091 and 10093. The optimizer may reorder these operations for efficiency.

```esql
FROM employees
| EVAL language_code = languages
| LOOKUP JOIN languages_lookup ON language_code
| WHERE emp_no >= 10091 AND emp_no < 10094
```

## Limitations

- The lookup index must be a specific index name; wildcards, aliases, and remote cluster references are not supported.
- Indices used for lookups must be configured with the `lookup` index mode.
- If the join fields contain multi-valued entries, those entries will not match anything, and the added fields will contain null for those rows.
