# INFIX OPERATORS

Infix operators provide convenient ways to perform type casting, pattern matching, and membership tests within queries. These operators include cast (`::`), `IN`, `LIKE`, `RLIKE`, and match (`:`).

## Syntax

- Cast: `expression::TYPE`
- IN: `expression IN (value1, value2, ...)`
- LIKE: `expression LIKE pattern` or `expression LIKE (pattern1, pattern2, ...)`
- RLIKE: `expression RLIKE pattern` or `expression RLIKE (pattern1, pattern2, ...)`
- Match: `field:query`

### Parameters

#### Cast (`::`)

Provides an alternative syntax to the TO_<type> conversion functions for casting values to a specific type.

#### IN

Tests whether a field or expression equals any element in a list of literals, fields, or expressions.

#### LIKE

Filters data based on string patterns using wildcards. The left-hand side is typically a field or literal, and the right-hand side is the pattern. Supported wildcards:
- `*` matches zero or more characters.
- `?` matches one character.

Escaping special characters such as `*` and `.` requires a backslash (`\`). For easier escaping, use triple-quoted strings (`"""`).

Supports both single patterns and lists of patterns. Returns true if any pattern matches.

#### RLIKE

Filters data based on string patterns using regular expressions. The left-hand side is typically a field or literal, and the right-hand side is the regex pattern.

Escaping special regex characters (e.g., `.`, `*`, `(`) requires a backslash (`\`). For easier escaping, use triple-quoted strings (`"""`).

Supports both single patterns and lists of patterns. Returns true if any pattern matches.

#### Match (`:`)

Performs a match query on the specified field. Returns true if the provided query matches the row. Equivalent to the match function.

## Examples

Convert and concatenate values, then cast to a version:
```esql
ROW ver = CONCAT(("0"::INT + 1)::STRING, ".2.3")::VERSION
```

Check if the result of `c-a` matches any value in the list:
```esql
ROW a = 1, b = 4, c = 3
| WHERE c-a IN (3, b / 2, a)
```

Select employees whose first name matches the pattern `?b*`:
```esql
FROM employees
| WHERE first_name LIKE """?b*"""
| KEEP first_name, last_name
```

Match the string containing a literal asterisk:
```esql
ROW message = "foo * bar"
| WHERE message LIKE "foo \\* bar"
```

Match the string containing a literal asterisk using triple quotes:
```esql
ROW message = "foo * bar"
| WHERE message LIKE """foo \* bar"""
```

Return true if the message matches any of the provided patterns:
```esql
ROW message = "foobar"
| WHERE message like ("foo*", "bar?")
```

Filter employees by a pattern provided as a query parameter:
```esql
FROM employees
| WHERE first_name LIKE ?pattern
| KEEP first_name, last_name
```

Select employees whose first name matches the regex `.leja.*`:
```esql
FROM employees
| WHERE first_name RLIKE """.leja.*"""
| KEEP first_name, last_name
```

Match the string containing a literal parenthesis:
```esql
ROW message = "foo ( bar"
| WHERE message RLIKE "foo \\( bar"
```

Match the string containing a literal parenthesis using triple quotes:
```esql
ROW message = "foo ( bar"
| WHERE message RLIKE """foo \( bar"""
```

Return true if the message matches any of the provided regex patterns:
```esql
ROW message = "foobar"
| WHERE message RLIKE ("foo.*", "bar.")
```

Filter employees by a regex pattern provided as a query parameter:
```esql
FROM employees
| WHERE first_name RLIKE ?pattern
| KEEP first_name, last_name
```

Select books where the author matches "Faulkner":
```esql
FROM books
| WHERE author:"Faulkner"
```