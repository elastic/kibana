# INFIX OPERATORS

Infix operators provide convenient ways to perform operations such as casting, pattern matching, and membership checks directly within queries.

## Syntax

- Cast: `expression::type`
- IN: `expression IN (value1, value2, ...)`
- LIKE: `expression LIKE pattern` or `expression LIKE (pattern1, pattern2, ...)`
- RLIKE: `expression RLIKE pattern` or `expression RLIKE (pattern1, pattern2, ...)`
- Match: `field:query`

### Parameters

#### Cast (`::`)

The cast operator provides an alternative syntax to the TO_<type> conversion functions, allowing you to convert values from one type to another.

#### IN

Tests whether a field or expression equals any element in a list of literals, fields, or expressions.

#### LIKE

Filters data based on string patterns using wildcards. The left-hand side is typically a field or expression, and the right-hand side is the pattern. Supported wildcards:
- `*` matches zero or more characters.
- `?` matches one character.

You can use a single pattern or a list of patterns. Escaping special characters like `*` and `.` requires a backslash (`\`), and using triple-quoted strings (`"""`) can simplify escaping.

#### RLIKE

Filters data based on string patterns using regular expressions. The left-hand side is typically a field or expression, and the right-hand side is the regex pattern. Escaping special regex characters requires a backslash (`\`), and triple-quoted strings (`"""`) can help reduce escaping overhead.

You can use a single pattern or a list of patterns.

#### Match (`:`)

Performs a match query on the specified field. Returns true if the provided query matches the row. Equivalent to the match function.

## Examples

This example demonstrates casting between types and concatenating values. It casts the string "0" to an integer, adds 1, converts the result back to a string, concatenates ".2.3", and finally casts the result to a version type.
```esql
ROW ver = CONCAT(("0"::INT + 1)::STRING, ".2.3")::VERSION
```

This query checks if the result of the expression `c-a` is present in the list `(3, b / 2, a)`. It returns the row only if `c-a` matches any of these values.
```esql
ROW a = 1, b = 4, c = 3
| WHERE c-a IN (3, b / 2, a)
```

This query filters employees whose first name matches the pattern `?b*`, where `?` matches any single character and `*` matches zero or more characters. It then keeps only the `first_name` and `last_name` fields.
```esql
FROM employees
| WHERE first_name LIKE """?b*"""
| KEEP first_name, last_name
```

This query matches rows where the `message` field contains the literal string "foo * bar", treating the asterisk as a normal character rather than a wildcard.
```esql
ROW message = "foo * bar"
| WHERE message LIKE "foo \\* bar"
```

This query also matches rows where the `message` field contains the literal "foo * bar", but uses triple-quoted strings to simplify escaping the asterisk.
```esql
ROW message = "foo * bar"
| WHERE message LIKE """foo \* bar"""
```

This query checks if the `message` field matches any of the provided patterns: "foo*" or "bar?". It returns the row if either pattern matches.
```esql
ROW message = "foobar"
| WHERE message like ("foo*", "bar?")
```

This query allows dynamic pattern matching by using a REST query placeholder for the pattern. It filters employees whose first name matches the provided pattern and keeps only the `first_name` and `last_name` fields.
```esql
FROM employees
| WHERE first_name LIKE ?pattern
| KEEP first_name, last_name
```

This query filters employees whose first name matches the regular expression `.leja.*`, meaning any string that contains "leja" preceded by any single character and followed by any characters. It keeps only the `first_name` and `last_name` fields.
```esql
FROM employees
| WHERE first_name RLIKE """.leja.*"""
| KEEP first_name, last_name
```

This query matches rows where the `message` field contains the literal string "foo ( bar", treating the parenthesis as a normal character rather than a regex special character.
```esql
ROW message = "foo ( bar"
| WHERE message RLIKE "foo \\( bar"
```

This query also matches rows where the `message` field contains the literal "foo ( bar", but uses triple-quoted strings to simplify escaping the parenthesis.
```esql
ROW message = "foo ( bar"
| WHERE message RLIKE """foo \( bar"""
```

This query checks if the `message` field matches any of the provided regular expressions: "foo.*" or "bar.". It returns the row if either regex matches.
```esql
ROW message = "foobar"
| WHERE message RLIKE ("foo.*", "bar.")
```

This query allows dynamic regex pattern matching by using a REST query placeholder for the pattern. It filters employees whose first name matches the provided regex and keeps only the `first_name` and `last_name` fields.
```esql
FROM employees
| WHERE first_name RLIKE ?pattern
| KEEP first_name, last_name
```

This query returns books where the `author` field matches "Faulkner" using the match operator.
```esql
FROM books
| WHERE author:"Faulkner"
```