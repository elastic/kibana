# DISSECT

The DISSECT command is used to extract structured data from a string. It matches the string against a delimiter-based pattern and extracts the specified keys as columns.

## Syntax

`DISSECT input "pattern" [APPEND_SEPARATOR="<separator>"]`

### Parameters

#### input

The column containing the string you want to structure. If the column has multiple values, DISSECT will process each value.

#### pattern

A dissect pattern. If a field name conflicts with an existing column, the existing column is dropped. If a field name is used more than once, only the rightmost duplicate creates a column.

#### <separator>

A string used as the separator between appended values, when using the append modifier.

## Examples

The following example parses a string that contains a timestamp, some text, and an IP address:

This query creates a row with a single string containing a timestamp, some text, and an IP address. It then uses the DISSECT command to split the string into three separate columns: `date`, `msg`, and `ip`. Finally, it keeps only these extracted columns in the output.

```esql
ROW a = "2023-01-23T12:15:00.000Z - some text - 127.0.0.1"
| DISSECT a """%{date} - %{msg} - %{ip}"""
| KEEP date, msg, ip
```

Parse a string and then convert the extracted date to a datetime type:

This query performs the same string parsing as the previous example, extracting `date`, `msg`, and `ip` from the input string. Additionally, it converts the extracted `date` field from a string to a datetime type for further processing or analysis.

```esql
ROW a = "2023-01-23T12:15:00.000Z - some text - 127.0.0.1"
| DISSECT a """%{date} - %{msg} - %{ip}"""
| KEEP date, msg, ip
| EVAL date = TO_DATETIME(date)
```
