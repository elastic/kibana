# STATS-BY

The STATS command groups rows based on shared values and calculates one or more aggregated values over those groups. Each aggregation can be filtered using a WHERE clause. If BY is omitted, the output contains a single row with aggregations over the entire dataset. Supported aggregation functions include ABSENT, AVG, COUNT, COUNT_DISTINCT, MAX, MEDIAN, MEDIAN_ABSOLUTE_DEVIATION, MIN, PERCENTILE, PRESENT, SAMPLE, ST_CENTROID_AGG, ST_EXTENT_AGG, STD_DEV, SUM, TOP, VALUES, VARIANCE, and WEIGHTED_AVG. When used with the TS source command, time series aggregation functions are also available. Supported grouping functions are BUCKET, TBUCKET, and CATEGORIZE.

## Syntax

`STATS [column1 =] expression1 [WHERE boolean_expression1][, ..., [columnN =] expressionN [WHERE boolean_expressionN]] [BY grouping_expression1[, ..., grouping_expressionN]]`

### Parameters

#### columnX

The name for the aggregated value returned. If omitted, the name defaults to the corresponding expression. If multiple columns share the same name, only the rightmost column is kept.

#### expressionX

An expression that computes an aggregated value.

#### grouping_expressionX

An expression that determines the values to group by. If its name matches a computed column, that column will be ignored.

#### boolean_expressionX

(Optional) A condition that must be met for a row to be included in the evaluation of expressionX.

## Examples

Calculate the count of employees grouped by language:

This query retrieves all employee records, counts the number of employees for each language, and sorts the results by language.

```esql
FROM employees
| STATS count = COUNT(emp_no) BY languages
| SORT languages
```

Calculate the average language value over the entire dataset:

This query calculates the average value of the `languages` field across all employees, returning a single aggregated result.

```esql
FROM employees
| STATS avg_lang = AVG(languages)
```

Calculate both the average and maximum language values:

This query computes both the average and the maximum values of the `languages` field for all employees, returning both results in a single row.

```esql
FROM employees
| STATS avg_lang = AVG(languages), max_lang = MAX(languages)
```

Calculate average salaries for employees born before and after 1960, grouped by gender:

This query calculates the average salary for employees born before 1960 and those born in or after 1960, grouping the results by gender. The averages are cast to long integers, and the results are sorted by gender.

```esql
FROM employees
| STATS avg50s = AVG(salary)::LONG WHERE birth_date < "1960-01-01",
        avg60s = AVG(salary)::LONG WHERE birth_date >= "1960-01-01"
        BY gender
| SORT gender
```

Count employees in salary ranges, with and without filters:

This query divides employees into salary ranges (under 40K, between 40K and 60K, and over 60K), counts the number of employees in each range, and also provides the total count.

```esql
FROM employees
| EVAL Ks = salary / 1000
| STATS under_40K = COUNT(*) WHERE Ks < 40,
        inbetween = COUNT(*) WHERE 40 <= Ks AND Ks < 60,
        over_60K  = COUNT(*) WHERE 60 <= Ks,
        total     = COUNT(*)
```

Group by multiple values: year hired and language:

This query extracts the year from each employee's hire date, then calculates the average salary for each combination of hire year and language. The average salary is rounded, and the results are sorted by hire year and language.

```esql
FROM employees
| EVAL hired = DATE_FORMAT("yyyy", hire_date)
| STATS avg_salary = AVG(salary) BY hired, languages.long
| EVAL avg_salary = ROUND(avg_salary)
| SORT hired, languages.long
```

If the grouping key is multivalued, the input row is included in all groups:

This query demonstrates that if a row contains multiple values for the `color` field, the row is included in the aggregation for each color. It sums the `price` for each color.

```esql
ROW price = 10, color = ["blue", "pink", "yellow"]
| STATS SUM(price) BY color
```

If all grouping keys are multivalued, the input row is included in all groups:

This query shows that if both `color` and `size` fields are arrays, the row is included in every possible combination of color and size groups, and the sum of `price` is calculated for each group.

```esql
ROW price = 10, color = ["blue", "pink", "yellow"], size = ["s", "m", "l"]
| STATS SUM(price) BY color, size
```

The input row is included in all groups, even for group keys:

This query demonstrates that when grouping by a multivalued field, the row is included in all groups, and the unique values of `color` are collected for each group.

```esql
ROW color = ["blue", "pink", "yellow"]
| STATS VALUES(color) BY color
```

To send the group key to the function, use MV_EXPAND first:

This query expands the multivalued `color` field into separate rows, then collects the unique values of `color` for each group.

```esql
ROW color = ["blue", "pink", "yellow"]
| MV_EXPAND color
| STATS VALUES(color) BY color
```

Calculate the average salary change using MV_AVG and AVG:

This query calculates the average of the average salary changes (using `MV_AVG` for multivalued fields), rounds the result to 10 decimal places, and returns it as `avg_salary_change`.

```esql
FROM employees
| STATS avg_salary_change = ROUND(AVG(MV_AVG(salary_change)), 10)
```

Group employees by the first letter of their last name:

This query groups employees by the first letter of their last name, counts the number of employees in each group, and sorts the results alphabetically by the first letter.

```esql
FROM employees
| STATS my_count = COUNT() BY LEFT(last_name, 1)
| SORT `LEFT(last_name, 1)`
```

If no output column name is specified, the new column name is the expression:

This query calculates the average salary for all employees. Since no output column name is specified, the result column is named after the expression.

```esql
FROM employees
| STATS AVG(salary)
```

Use backticks to reference column names with special characters:

This query calculates the average salary, then creates a new column with the rounded average salary. Backticks are used to reference the column with special characters in its name.

```esql
FROM employees
| STATS AVG(salary)
| EVAL avg_salary_rounded = ROUND(`AVG(salary)`)
```

## Limitations

- STATS without any groups is significantly faster than when grouping is used.
- Grouping on a single expression is much more optimized than grouping on multiple expressions. Grouping on a single keyword column can be up to five times faster than grouping on two keyword columns. Combining columns with CONCAT for grouping does not improve performance.
- Individual null values are skipped when computing aggregations.
- If a grouping expression or output column name matches, the column will be ignored. If multiple columns have the same name, only the rightmost is kept.