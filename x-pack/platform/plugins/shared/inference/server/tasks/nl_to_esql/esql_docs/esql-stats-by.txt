# STATS-BY

The STATS command groups rows based on common values and calculates one or more aggregated values over these groups. Each aggregated value can be filtered using a WHERE clause. If BY is omitted, the output contains a single row with aggregations over the entire dataset. Supported aggregation functions include ABSENT, AVG, COUNT, COUNT_DISTINCT, MAX, MEDIAN, MEDIAN_ABSOLUTE_DEVIATION, MIN, PERCENTILE, PRESENT, SAMPLE, ST_CENTROID_AGG, ST_EXTENT_AGG, STD_DEV, SUM, TOP, VALUES, VARIANCE, and WEIGHTED_AVG. When used with the TS source command, time series aggregation functions are also available. Supported grouping functions are BUCKET, TBUCKET, and CATEGORIZE.

## Syntax

`STATS [column1 =] expression1 [WHERE boolean_expression1][, ..., [columnN =] expressionN [WHERE boolean_expressionN]] [BY grouping_expression1[, ..., grouping_expressionN]]`

### Parameters

#### columnX

The name for the aggregated value returned. If omitted, the name defaults to the corresponding expression. If multiple columns share the same name, only the rightmost column is kept.

#### expressionX

An expression that computes an aggregated value.

#### grouping_expressionX

An expression that determines the values to group by. If its name matches a computed column, that column will be ignored.

#### boolean_expressionX

The condition that must be met for a row to be included in the evaluation of expressionX.

## Examples

Calculate the count of employees grouped by language:
This query retrieves employee records, counts the number of employees for each language, and sorts the results by language.

```esql
FROM employees
| STATS count = COUNT(emp_no) BY languages
| SORT languages
```

Calculate the average language value over the entire dataset:
This query calculates the average value of the 'languages' field across all employees, returning a single aggregated result.

```esql
FROM employees
| STATS avg_lang = AVG(languages)
```

Calculate both the average and maximum language values:
This query computes both the average and the maximum value of the 'languages' field for all employees, returning both metrics in the result.

```esql
FROM employees
| STATS avg_lang = AVG(languages), max_lang = MAX(languages)
```

Calculate average salaries for employees born before and after 1960, grouped by gender:
This query calculates the average salary for employees born before 1960 and those born in or after 1960, grouping the results by gender. The averages are cast to long integers, and the results are sorted by gender.

```esql
FROM employees
| STATS avg50s = AVG(salary)::LONG WHERE birth_date < "1960-01-01",
        avg60s = AVG(salary)::LONG WHERE birth_date >= "1960-01-01"
        BY gender
| SORT gender
```

Count employees in different salary ranges and calculate the total count:
This query divides employees into three salary ranges (under 40K, between 40K and 60K, and over 60K) and counts the number of employees in each range, as well as the total number of employees.

```esql
FROM employees
| EVAL Ks = salary / 1000
| STATS under_40K = COUNT(*) WHERE Ks < 40,
        inbetween = COUNT(*) WHERE 40 <= Ks AND Ks < 60,
        over_60K  = COUNT(*) WHERE 60 <= Ks,
        total     = COUNT(*)
```

Calculate average salary grouped by year hired and language:
This query extracts the year from each employee's hire date, then calculates the average salary for each combination of hire year and language. The average salary is rounded, and the results are sorted by year and language.

```esql
FROM employees
| EVAL hired = DATE_FORMAT("yyyy", hire_date)
| STATS avg_salary = AVG(salary) BY hired, languages.long
| EVAL avg_salary = ROUND(avg_salary)
| SORT hired, languages.long
```

Sum the price for each color when the grouping key is multivalued:
This query creates a row with a price and a list of colors, then calculates the total price for each color, handling the case where the color field contains multiple values.

```esql
ROW price = 10, color = ["blue", "pink", "yellow"]
| STATS SUM(price) BY color
```

Sum the price for each combination of color and size when both grouping keys are multivalued:
This query creates a row with a price, a list of colors, and a list of sizes, then calculates the total price for each possible combination of color and size.

```esql
ROW price = 10, color = ["blue", "pink", "yellow"], size = ["s", "m", "l"]
| STATS SUM(price) BY color, size
```

Show all values of the group key when the grouping key is multivalued:
This query creates a row with a list of colors and then displays all unique color values for each color group.

```esql
ROW color = ["blue", "pink", "yellow"]
| STATS VALUES(color) BY color
```

Send the group key to the function using MV_EXPAND:
This query expands the multivalued color field into individual rows, then shows all unique color values for each color group.

```esql
ROW color = ["blue", "pink", "yellow"]
| MV_EXPAND color
| STATS VALUES(color) BY color
```

Calculate the average salary change using MV_AVG and AVG:
This query calculates the average of the average salary changes (using MV_AVG for multivalued fields), rounds the result to 10 decimal places, and returns it as avg_salary_change.

```esql
FROM employees
| STATS avg_salary_change = ROUND(AVG(MV_AVG(salary_change)), 10)
```

Group employees by the first letter of their last name:
This query groups employees by the first letter of their last name and counts the number of employees in each group, then sorts the results by the letter.

```esql
FROM employees
| STATS my_count = COUNT() BY LEFT(last_name, 1)
| SORT `LEFT(last_name, 1)`
```

Return a column named AVG(salary) when the output column name is not specified:
This query calculates the average salary for all employees and returns the result in a column named AVG(salary).

```esql
FROM employees
| STATS AVG(salary)
```

Quote the column name with backticks when using it in subsequent commands:
This query calculates the average salary, then rounds the result and stores it in a new column named avg_salary_rounded, referencing the original column name with backticks.

```esql
FROM employees
| STATS AVG(salary)
| EVAL avg_salary_rounded = ROUND(`AVG(salary)`)
```

## Limitations

- STATS without any groups is significantly faster than when grouping is used.
- Grouping on a single expression is much more optimized than grouping on multiple expressions. Grouping on a single keyword column can be up to five times faster than grouping on two keyword columns. Combining columns with CONCAT for grouping does not improve performance.
- Individual null values are skipped when computing aggregations.
- If the grouping key is multivalued, the input row is included in all groups. If all grouping keys are multivalued, the input row is included in all possible group combinations.
- If a computed column name matches a grouping expression, that column will be ignored.
- If multiple columns have the same name, only the rightmost column is kept.