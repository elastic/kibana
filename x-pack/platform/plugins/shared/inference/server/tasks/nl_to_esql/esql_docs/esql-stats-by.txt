# STATS-BY

The `STATS` processing command groups rows according to a common value
and calculates one or more aggregated values over the grouped rows. For the
calculation of each aggregated value, the rows in a group can be filtered with
`WHERE`. If `BY` is omitted, the output table contains exactly one row with
the aggregations applied over the entire dataset.
The following aggregation functions are supported:
- `ABSENT` `stack: ga 9.2`
- `AVG`
- `COUNT`
- `COUNT_DISTINCT`
- `MAX`
- `MEDIAN`
- `MEDIAN_ABSOLUTE_DEVIATION`
- `MIN`
- `PERCENTILE`
- `PRESENT` `stack: ga 9.2`
- `SAMPLE`
- `ST_CENTROID_AGG` `stack: preview` `serverless: preview`
- `ST_EXTENT_AGG` `stack: preview` `serverless: preview`
- `STD_DEV`
- `SUM`
- `TOP`
- `VALUES` `stack: preview` `serverless: preview`
- `VARIANCE`
- `WEIGHTED_AVG`

When `STATS` is used under the `TS` source command,
time series aggregation functions
are also supported.
The following grouping functions are supported:
- `BUCKET`
- `TBUCKET`
- `CATEGORIZE`

<note>
  `STATS` without any groups is much much faster than adding a group.
</note>

<note>
  Grouping on a single expression is currently much more optimized than grouping
  on many expressions. In some tests we have seen grouping on a single `keyword`
  column to be five times faster than grouping on two `keyword` columns. Do
  not try to work around this by combining the two columns together with
  something like `CONCAT`
  and then grouping - that is not going to be faster.
</note>

The `STATS` processing command groups rows according to a common value
and calculates one or more aggregated values over the grouped rows.
**Syntax**
```esql
STATS [column1 =] expression1 [WHERE boolean_expression1][,
      ...,
      [columnN =] expressionN [WHERE boolean_expressionN]]
      [BY grouping_expression1[, ..., grouping_expressionN]]
```

### Parameters

#### `columnX`

The name by which the aggregated value is returned. If omitted, the name is
 equal to the corresponding expression (`expressionX`).
 If multiple columns have the same name, all but the rightmost column with this
 name will be ignored.

#### `expressionX`

An expression that computes an aggregated value.

#### `grouping_expressionX`

An expression that outputs the values to group by.
 If its name coincides with one of the computed columns, that column will be ignored.

#### `boolean_expressionX`

The condition that must be met for a row to be included in the evaluation of `expressionX`.

<note>
  Individual `null` values are skipped when computing aggregations.
</note>

### Examples

Calculating a statistic and grouping by the values of another column:
```esql
FROM employees
| STATS count = COUNT(emp_no) BY languages
| SORT languages
```

Omitting `BY` returns one row with the aggregations applied over the entire
dataset:
```esql
FROM employees
| STATS avg_lang = AVG(languages)
```

It’s possible to calculate multiple values:
```esql
FROM employees
| STATS avg_lang = AVG(languages), max_lang = MAX(languages)
```

To filter the rows that go into an aggregation, use the `WHERE` clause:
```esql
FROM employees
| STATS avg50s = AVG(salary)::LONG WHERE birth_date < "1960-01-01",
        avg60s = AVG(salary)::LONG WHERE birth_date >= "1960-01-01"
        BY gender
| SORT gender
```

The aggregations can be mixed, with and without a filter and grouping is
optional as well:
```esql
FROM employees
| EVAL Ks = salary / 1000
| STATS under_40K = COUNT(*) WHERE Ks < 40,
        inbetween = COUNT(*) WHERE 40 <= Ks AND Ks < 60,
        over_60K  = COUNT(*) WHERE 60 <= Ks,
        total     = COUNT(*)
```

It’s also possible to group by multiple values:
```esql
FROM employees
| EVAL hired = DATE_FORMAT("yyyy", hire_date)
| STATS avg_salary = AVG(salary) BY hired, languages.long
| EVAL avg_salary = ROUND(avg_salary)
| SORT hired, languages.long
```

#### Multivalued inputs

If the grouping key is multivalued then the input row is in all groups:
```esql
ROW price = 10, color = ["blue", "pink", "yellow"]
| STATS SUM(price) BY color
```

If all the grouping keys are multivalued then the input row is in all groups:
```esql
ROW price = 10, color = ["blue", "pink", "yellow"], size = ["s", "m", "l"]
| STATS SUM(price) BY color, size
```

The input **ROW** is in all groups. The entire row. All the values. Even group
keys. That means that:
```esql
ROW color = ["blue", "pink", "yellow"]
| STATS VALUES(color) BY color
```

The `VALUES` function above sees the whole row - all of the values of the group
key. If you want to send the group key to the function then `MV_EXPAND` first:
```esql
ROW color = ["blue", "pink", "yellow"]
| MV_EXPAND color
| STATS VALUES(color) BY color
```

Refer to elasticsearch/issues/134792
for an even more in depth explanation.

#### Multivalue functions

Both the aggregating functions and the grouping expressions accept other
functions. This is useful for using `STATS` on multivalue columns.
For example, to calculate the average salary change, you can use `MV_AVG` to
first average the multiple values per employee, and use the result with the
`AVG` function:
```esql
FROM employees
| STATS avg_salary_change = ROUND(AVG(MV_AVG(salary_change)), 10)
```

An example of grouping by an expression is grouping employees on the first
letter of their last name:
```esql
FROM employees
| STATS my_count = COUNT() BY LEFT(last_name, 1)
| SORT `LEFT(last_name, 1)`
```

#### Naming

Specifying the output column name is optional. If not specified, the new column
name is equal to the expression. The following query returns a column named
`AVG(salary)`:
```esql
FROM employees
| STATS AVG(salary)
```

Because this name contains special characters,
it needs to be quoted
with backticks (```) when using it in subsequent commands:
```esql
FROM employees
| STATS AVG(salary)
| EVAL avg_salary_rounded = ROUND(`AVG(salary)`)
```

