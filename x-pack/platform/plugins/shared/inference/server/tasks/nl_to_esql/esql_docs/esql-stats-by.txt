# STATS-BY

The STATS command groups rows based on a common value and calculates one or more aggregated values over those groups. Each aggregated value can be filtered using a WHERE clause. If BY is omitted, the output contains a single row with aggregations over the entire dataset. Supported aggregation functions include ABSENT, AVG, COUNT, COUNT_DISTINCT, MAX, MEDIAN, MEDIAN_ABSOLUTE_DEVIATION, MIN, PERCENTILE, PRESENT, SAMPLE, ST_CENTROID_AGG, ST_EXTENT_AGG, STD_DEV, SUM, TOP, VALUES, VARIANCE, and WEIGHTED_AVG. When used with the TS source command, time series aggregation functions are also available. Supported grouping functions are BUCKET, TBUCKET, and CATEGORIZE.

## Syntax

`STATS [column1 =] expression1 [WHERE boolean_expression1][, ..., [columnN =] expressionN [WHERE boolean_expressionN]] [BY grouping_expression1[, ..., grouping_expressionN]]`

### Parameters

#### columnX

The name for the aggregated value returned. If omitted, the name defaults to the corresponding expression. If multiple columns share the same name, only the rightmost column is kept.

#### expressionX

An expression that computes an aggregated value.

#### grouping_expressionX

An expression that determines the values to group by. If its name matches a computed column, that column will be ignored.

#### boolean_expressionX

A condition that must be met for a row to be included in the evaluation of expressionX.

## Examples

Calculate the count of employees grouped by language:
Returns the number of employees for each language, sorted by language.
```esql
FROM employees
| STATS count = COUNT(emp_no) BY languages
| SORT languages
```

Calculate the average language value over the entire dataset:
Computes the average value of the 'languages' field across all employees.
```esql
FROM employees
| STATS avg_lang = AVG(languages)
```

Calculate both the average and maximum language values:
Finds both the average and the maximum value of the 'languages' field for all employees.
```esql
FROM employees
| STATS avg_lang = AVG(languages), max_lang = MAX(languages)
```

Calculate average salaries for employees born before and after 1960, grouped by gender:
Shows the average salary for employees born before 1960 and those born in or after 1960, grouped by gender and sorted by gender.
```esql
FROM employees
| STATS avg50s = AVG(salary)::LONG WHERE birth_date < "1960-01-01",
        avg60s = AVG(salary)::LONG WHERE birth_date >= "1960-01-01"
        BY gender
| SORT gender
```

Count employees in different salary ranges and total, without grouping:
Displays the number of employees in three salary ranges (under 40K, between 40K and 60K, over 60K) and the total count, without grouping.
```esql
FROM employees
| EVAL Ks = salary / 1000
| STATS under_40K = COUNT(*) WHERE Ks < 40,
        inbetween = COUNT(*) WHERE 40 <= Ks AND Ks < 60,
        over_60K  = COUNT(*) WHERE 60 <= Ks,
        total     = COUNT(*)
```

Calculate average salary grouped by year hired and language:
Shows the rounded average salary for each combination of hire year and language, sorted by year and language.
```esql
FROM employees
| EVAL hired = DATE_FORMAT("yyyy", hire_date)
| STATS avg_salary = AVG(salary) BY hired, languages.long
| EVAL avg_salary = ROUND(avg_salary)
| SORT hired, languages.long
```

Sum price grouped by color when color is a multivalued field:
Calculates the total price for each color when the color field contains multiple values.
```esql
ROW price = 10, color = ["blue", "pink", "yellow"]
| STATS SUM(price) BY color
```

Sum price grouped by both color and size, both multivalued:
Computes the total price for each combination of color and size when both fields have multiple values.
```esql
ROW price = 10, color = ["blue", "pink", "yellow"], size = ["s", "m", "l"]
| STATS SUM(price) BY color, size
```

Show all values of a multivalued group key:
Lists all unique color values present in the multivalued color field.
```esql
ROW color = ["blue", "pink", "yellow"]
| STATS VALUES(color) BY color
```

Expand multivalued group key before aggregation:
Expands the color field into individual values and then lists all unique colors.
```esql
ROW color = ["blue", "pink", "yellow"]
| MV_EXPAND color
| STATS VALUES(color) BY color
```

Calculate the average salary change using MV_AVG and AVG:
Rounds the average of the average salary changes (for multivalued fields) to 10 decimal places.
```esql
FROM employees
| STATS avg_salary_change = ROUND(AVG(MV_AVG(salary_change)), 10)
```

Group employees by the first letter of their last name:
Counts the number of employees for each initial letter of their last name, sorted by the initial.
```esql
FROM employees
| STATS my_count = COUNT() BY LEFT(last_name, 1)
| SORT `LEFT(last_name, 1)`
```

Return a column named AVG(salary) by omitting the output column name:
Displays the average salary for all employees, using the default column name.
```esql
FROM employees
| STATS AVG(salary)
```

Use a quoted column name with special characters in subsequent commands:
Calculates the average salary and then rounds it, referencing the column by its quoted name.
```esql
FROM employees
| STATS AVG(salary)
| EVAL avg_salary_rounded = ROUND(`AVG(salary)`)
```

## Limitations

- STATS without any groups is significantly faster than when grouping is used.
- Grouping on a single expression is much more optimized than grouping on multiple expressions. Grouping on a single keyword column can be up to five times faster than grouping on two keyword columns. Combining columns with CONCAT for grouping does not improve performance.
- Individual null values are skipped when computing aggregations.
- If the grouping key is multivalued, the input row is included in all groups. If all grouping keys are multivalued, the input row is included in all possible group combinations.
- If a computed column name matches a grouping expression, that column will be ignored.
- If multiple columns have the same name, only the rightmost column is kept.