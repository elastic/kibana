/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import type { LoggerFactory, Logger } from '@kbn/core/server';
import {
  type SavedObjectsClientContract,
  type SavedObjectsUpdateOptions,
  type SavedObjectsDeleteOptions,
  type SavedObjectsCreateOptions,
  type SavedObject,
  type SavedObjectsFindResponse,
  type SavedObjectsUpdateResponse,
  type KibanaRequest,
  type SecurityServiceStart,
  SavedObjectsErrorHelpers,
} from '@kbn/core/server';
import type { IntegrationAttributes, DataStreamAttributes } from './schemas/types';
import {
  DATA_STREAM_SAVED_OBJECT_TYPE,
  INTEGRATION_SAVED_OBJECT_TYPE,
  TASK_STATUSES,
} from './constants';

export class AutomaticImportSavedObjectService {
  private savedObjectsClient: SavedObjectsClientContract;
  private logger: Logger;
  private security: SecurityServiceStart | null = null;

  constructor(
    logger: LoggerFactory,
    savedObjectsClient: SavedObjectsClientContract,
    security: SecurityServiceStart
  ) {
    this.security = security;
    this.logger = logger.get('savedObjectsService');
    this.savedObjectsClient = savedObjectsClient;
  }

  /**
   * Helper function to parse and increment a semantic version string (x.y.z)
   * @param currentVersion - Current semantic version string (e.g., "1.0.0")
   * @param incrementType - Optional: Which part to increment: 'major' | 'minor' | 'patch'. Defaults to 'patch'.
   * @returns Incremented semantic version string
   */
  private incrementSemanticVersion(
    currentVersion: string | undefined,
    incrementType: 'major' | 'minor' | 'patch' = 'patch'
  ): string {
    if (!currentVersion) {
      return '0.0.0';
    }

    const versionParts = currentVersion.split('.');
    if (versionParts.length !== 3) {
      throw new Error('Invalid version format');
    }

    let [major, minor, patch] = versionParts.map((v) => parseInt(v, 10));

    if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
      return '0.0.0';
    }

    switch (incrementType) {
      case 'major':
        major += 1;
        minor = 0;
        patch = 0;
        break;
      case 'minor':
        minor += 1;
        patch = 0;
        break;
      case 'patch':
      default:
        patch += 1;
        break;
    }

    return `${major}.${minor}.${patch}`;
  }

  /**
   * Integration Operations
   */

  /**
   * Create an integration that may or may not already have data streams associated with it.
   * @param request - The Kibana request object
   * @param data - The integration data. Must include an integration_id.
   * @param options - The options for the create
   * @returns The saved object
   */
  public async insertIntegration(
    request: KibanaRequest,
    data: IntegrationAttributes,
    options?: SavedObjectsCreateOptions
  ): Promise<SavedObject<IntegrationAttributes>> {
    const authenticatedUser = this.security?.authc.getCurrentUser(request);
    if (!authenticatedUser) {
      throw new Error('No user authenticated');
    }

    const {
      integration_id: integrationId,
      data_stream_count: dataStreamCount = 0,
      metadata = {},
    } = data;

    if (!integrationId) {
      throw new Error('Integration ID is required');
    }

    try {
      this.logger.debug(`Creating integration: ${integrationId}`);

      const initialIntegrationData: IntegrationAttributes = {
        integration_id: integrationId,
        data_stream_count: dataStreamCount,
        created_by: authenticatedUser.username,
        status: TASK_STATUSES.pending,
        metadata: {
          ...metadata,
          created_at: new Date().toISOString(),
          version: '0.0.0',
        },
      };

      return await this.savedObjectsClient.create<IntegrationAttributes>(
        INTEGRATION_SAVED_OBJECT_TYPE,
        initialIntegrationData,
        {
          // overwrite id that is default generated by the saved objects service
          id: integrationId,
          ...options,
        }
      );
    } catch (error) {
      // Create will throw a confict if integration ID already exists.
      if (SavedObjectsErrorHelpers.isConflictError(error)) {
        throw new Error(`Integration ${integrationId} already exists`);
      }

      this.logger.error(`Failed to create integration: ${error}`);
      throw error;
    }
  }

  /**
   * Create or update an integration
   * @param data - The integration data. Must include an integration_id.
   * @param expectedVersion - The expected version for optimistic concurrency control at the application layer. Required to ensure data consistency.
   * @param versionUpdate - Optional: specify which version part to increment ('major' | 'minor' | 'patch'). Defaults to incrementing 'patch'.
   * @param options - The options for the update.
   * @returns The saved object
   */
  public async updateIntegration(
    data: IntegrationAttributes,
    expectedVersion: string,
    versionUpdate?: 'major' | 'minor' | 'patch',
    options?: SavedObjectsUpdateOptions<IntegrationAttributes>
  ): Promise<SavedObjectsUpdateResponse<IntegrationAttributes>> {
    const {
      integration_id: integrationId,
      data_stream_count: dataStreamCount = 0,
      status,
      metadata = {},
    } = data;

    if (!integrationId) {
      throw new Error('Integration ID is required');
    }

    try {
      this.logger.debug(`Updating integration: ${integrationId}`);

      const existingIntegration = await this.getIntegration(integrationId);
      if (!existingIntegration) {
        throw new Error(`Integration ${integrationId} not found`);
      }

      const currentVersion = existingIntegration.attributes.metadata?.version || '0.0.0';

      if (currentVersion !== expectedVersion) {
        throw new Error(
          `Version conflict: Integration ${integrationId} has been updated. Expected version ${expectedVersion}, but current version is ${currentVersion}. Please fetch the latest version and try again.`
        );
      }

      const newVersion = this.incrementSemanticVersion(currentVersion, versionUpdate);

      const integrationData: IntegrationAttributes = {
        integration_id: integrationId,
        data_stream_count: dataStreamCount,
        created_by: existingIntegration.attributes.created_by,
        status: status || existingIntegration.attributes.status,
        metadata: {
          ...metadata,
          version: newVersion,
        },
      };

      const internalVersion = existingIntegration.version;
      return await this.savedObjectsClient.update<IntegrationAttributes>(
        INTEGRATION_SAVED_OBJECT_TYPE,
        integrationId,
        integrationData,
        {
          ...options,
          version: internalVersion,
        }
      );
    } catch (error) {
      this.logger.error(`Failed to update integration: ${error}`);
      throw error;
    }
  }

  /**
   * Get an integration by ID
   * @param integrationId - The ID of the integration
   * @returns The integration
   */
  public async getIntegration(integrationId: string): Promise<SavedObject<IntegrationAttributes>> {
    try {
      this.logger.debug(`Getting integration: ${integrationId}`);
      return await this.savedObjectsClient.get<IntegrationAttributes>(
        INTEGRATION_SAVED_OBJECT_TYPE,
        integrationId
      );
    } catch (error) {
      this.logger.error(`Failed to get integration ${integrationId}: ${error}`);
      throw error;
    }
  }

  /**
   * @returns All integrations
   */
  public async getAllIntegrations(): Promise<SavedObjectsFindResponse<IntegrationAttributes>> {
    try {
      this.logger.debug('Getting all integrations');
      return await this.savedObjectsClient.find<IntegrationAttributes>({
        type: INTEGRATION_SAVED_OBJECT_TYPE,
      });
    } catch (error) {
      this.logger.error(`Failed to get all integrations: ${error}`);
      throw error;
    }
  }

  /**
   * Delete an integration by ID and cascade delete all associated data streams
   * @param integrationId - The ID of the integration
   * @param options - The options for the delete
   * @returns Object containing deletion results with success status and any errors
   */
  public async deleteIntegration(
    integrationId: string,
    options?: SavedObjectsDeleteOptions
  ): Promise<{
    success: boolean;
    dataStreamsDeleted: number;
    errors: Array<{ id: string; error: string }>;
  }> {
    this.logger.debug(`Starting cascade deletion for integration: ${integrationId}`);

    const deletionErrors: Array<{ id: string; error: string }> = [];
    let dataStreamsDeleted = 0;

    try {
      // delete up to 100 data streams at a time
      const perPage = 100;
      let page = 1;
      let hasMore = true;
      const dataStreamsToDelete: Array<{ id: string; type: string }> = [];

      while (hasMore) {
        try {
          const dataStreamsResponse = await this.savedObjectsClient.find<DataStreamAttributes>({
            type: DATA_STREAM_SAVED_OBJECT_TYPE,
            filter: `${DATA_STREAM_SAVED_OBJECT_TYPE}.attributes.integration_id: ${JSON.stringify(
              integrationId
            )}`,
            page,
            perPage,
            fields: ['integration_id'],
          });

          dataStreamsToDelete.push(
            ...dataStreamsResponse.saved_objects.map((ds) => ({
              id: ds.id,
              type: DATA_STREAM_SAVED_OBJECT_TYPE,
            }))
          );

          // If 100 saved objects are retrieved in a page, then we try to see if there are more
          hasMore = dataStreamsResponse.saved_objects.length === perPage;
          page++;
        } catch (error) {
          this.logger.error(
            `Failed to find data streams for integration ${integrationId} on page ${page}: ${error}`
          );
          hasMore = false;
        }
      }

      this.logger.debug(
        `Found ${dataStreamsToDelete.length} data streams to delete for integration ${integrationId}`
      );

      const CHUNK_SIZE = 50;
      if (dataStreamsToDelete.length > 0) {
        for (let i = 0; i < dataStreamsToDelete.length; i += CHUNK_SIZE) {
          const chunk = dataStreamsToDelete.slice(i, i + CHUNK_SIZE);
          try {
            const bulkDeleteResult = await this.savedObjectsClient.bulkDelete(chunk, {
              ...options,
              force: true,
            });

            // Process results to track successes and failures
            bulkDeleteResult.statuses.forEach((status) => {
              if (status.success) {
                dataStreamsDeleted++;
              } else {
                const errorMessage = status.error?.message || 'Unknown error';
                this.logger.warn(`Failed to delete data stream ${status.id}: ${errorMessage}`);
                deletionErrors.push({
                  id: status.id,
                  error: errorMessage,
                });
              }
            });
          } catch (bulkDeleteError) {
            // If bulk delete fails entirely, log and track errors for this chunk
            this.logger.error(
              `Bulk delete failed for chunk starting at index ${i}: ${bulkDeleteError}`
            );
            chunk.forEach((ds) => {
              deletionErrors.push({
                id: ds.id,
                error:
                  bulkDeleteError instanceof Error
                    ? bulkDeleteError.message
                    : String(bulkDeleteError),
              });
            });
          }
        }

        this.logger.debug(
          `Deleted ${dataStreamsDeleted} of ${dataStreamsToDelete.length} data streams for integration ${integrationId}`
        );
      }

      // Delete the integration if we successfully deleted all data streams OR the a force option is provided
      const allDataStreamsDeleted = deletionErrors.length === 0;
      if (!allDataStreamsDeleted && !options?.force) {
        throw new Error(
          `Cannot delete integration ${integrationId}: Failed to delete ${deletionErrors.length} data streams. ` +
            `Use force option to delete the integration anyway. Errors: ${JSON.stringify(
              deletionErrors
            )}`
        );
      }

      await this.savedObjectsClient.delete(INTEGRATION_SAVED_OBJECT_TYPE, integrationId, options);

      this.logger.info(
        `Successfully deleted integration ${integrationId} and ${dataStreamsDeleted} associated data streams`
      );

      return {
        success: true,
        dataStreamsDeleted,
        errors: deletionErrors,
      };
    } catch (error) {
      if (SavedObjectsErrorHelpers.isNotFoundError(error)) {
        this.logger.error(`Integration ${integrationId} not found`);
        throw error;
      }

      this.logger.error(`Failed to delete integration ${integrationId}: ${error}`);
      throw error;
    }
  }

  /**
   * Data Stream Operations
   */

  /**
   * Create a data stream
   * @param request - The Kibana request object
   * @param data - The data stream data. Must include an integration_id and data_stream_id.
   * @param options - The options for the create
   * @returns The created data stream
   */
  public async insertDataStream(
    request: KibanaRequest,
    data: DataStreamAttributes,
    options?: SavedObjectsCreateOptions
  ): Promise<SavedObject<DataStreamAttributes>> {
    const authenticatedUser = this.security?.authc.getCurrentUser(request);
    if (!authenticatedUser) {
      throw new Error('No user authenticated');
    }

    const {
      integration_id: integrationId,
      data_stream_id: dataStreamId,
      job_info: jobInfo = { status: TASK_STATUSES.pending, job_id: '', job_type: '' },
      metadata,
      result = {},
    } = data;

    if (!integrationId) {
      throw new Error('Integration ID is required');
    }

    if (!dataStreamId) {
      throw new Error('Data stream ID is required');
    }

    let existingIntegration: SavedObject<IntegrationAttributes> | null = null;
    // Check for existing integration
    try {
      existingIntegration = await this.getIntegration(integrationId);
      this.logger.debug(
        `Integration ${integrationId} found, will update count after data stream creation`
      );
    } catch (error) {
      this.logger.debug(
        `Integration ${integrationId} not found, will create after data stream creation`
      );
    }

    // Create the data stream first since we need it before we need to create a missing integration
    try {
      this.logger.debug(`Creating data stream: ${dataStreamId}`);

      const { sample_count: sampleCount = 0, ...restMetadata } = metadata || {};

      const initialDataStreamData: DataStreamAttributes = {
        integration_id: integrationId,
        data_stream_id: dataStreamId,
        created_by: authenticatedUser.username,
        job_info: jobInfo,
        metadata: {
          sample_count: sampleCount,
          ...restMetadata,
          created_at: new Date().toISOString(),
          version: '0.0.0',
        },
        result: result || {},
      };

      // Create automatically checks if there is an existing data stream with the same id and will throw an error if so
      const createdDataStream = await this.savedObjectsClient.create<DataStreamAttributes>(
        DATA_STREAM_SAVED_OBJECT_TYPE,
        initialDataStreamData,
        {
          ...options,
          id: dataStreamId,
        }
      );

      // After successful data stream creation, update data stream count in the integration
      // or create a new integration if it doesn't exist
      try {
        if (existingIntegration) {
          this.logger.debug(
            `Data stream created successfully, incrementing integration ${integrationId} count`
          );

          const updatedIntegrationData: IntegrationAttributes = {
            ...existingIntegration.attributes,
            data_stream_count: existingIntegration.attributes.data_stream_count! + 1,
          };

          await this.updateIntegration(
            updatedIntegrationData,
            existingIntegration.attributes.metadata?.version || '0.0.0'
          );
        } else {
          this.logger.debug(
            `Data stream created successfully, creating new integration ${integrationId}`
          );

          const defaultIntegrationData: IntegrationAttributes = {
            integration_id: integrationId,
            data_stream_count: 1,
            created_by: authenticatedUser.username,
            status: TASK_STATUSES.pending,
            metadata: {
              created_at: new Date().toISOString(),
              version: '0.0.0',
              title: `Auto-generated integration ${integrationId}`,
            },
          };

          await this.insertIntegration(request, defaultIntegrationData);
        }
      } catch (integrationError) {
        this.logger.error(
          `Failed to update/create integration ${integrationId} after creating data stream ${dataStreamId}: ${integrationError}`
        );
      }

      return createdDataStream;
    } catch (error) {
      if (SavedObjectsErrorHelpers.isConflictError(error)) {
        throw new Error(`Data stream ${dataStreamId} already exists`);
      }
      throw error;
    }
  }

  /**
   * Update a data stream
   * @param data - The data stream data. Must include an integration_id and data_stream_id.
   * @param expectedVersion - The expected version for optimistic concurrency control at the application layer. Required to ensure data consistency.
   * @param versionUpdate - Optional: specify which version part to increment ('major' | 'minor' | 'patch').  Defaults to incrementing 'patch'.
   * @param options - The options for the update.
   * @returns The updated data stream
   */
  public async updateDataStream(
    data: DataStreamAttributes,
    expectedVersion: string,
    versionUpdate?: 'major' | 'minor' | 'patch',
    options?: SavedObjectsUpdateOptions<DataStreamAttributes>
  ): Promise<SavedObjectsUpdateResponse<DataStreamAttributes>> {
    const {
      integration_id: integrationId,
      data_stream_id: dataStreamId,
      job_info: jobInfo,
      metadata = { sample_count: 0 },
      result = {},
    } = data;

    if (!integrationId) {
      throw new Error('Integration ID is required');
    }

    if (!dataStreamId) {
      throw new Error('Data stream ID is required');
    }
    try {
      this.logger.debug(`Updating data stream: ${dataStreamId}`);

      // A Data Stream must always be associated with an Integration
      const integrationTarget = await this.getIntegration(integrationId);
      if (!integrationTarget) {
        throw new Error(`Integration associated with this data stream ${integrationId} not found`);
      }

      const existingDataStream = await this.getDataStream(dataStreamId);
      const currentVersion = existingDataStream.attributes.metadata?.version || '0.0.0';

      if (currentVersion !== expectedVersion) {
        throw new Error(
          `Version conflict: Data stream ${dataStreamId} has been updated. Expected version ${expectedVersion}, but current version is ${currentVersion}. Please fetch the latest version and try again.`
        );
      }

      const newVersion = this.incrementSemanticVersion(currentVersion, versionUpdate);

      const dataStreamData: DataStreamAttributes = {
        integration_id: integrationId,
        data_stream_id: dataStreamId,
        created_by: existingDataStream.attributes.created_by,
        job_info: jobInfo,
        metadata: {
          ...metadata,
          created_at: existingDataStream.attributes.metadata.created_at,
          version: newVersion,
        },
        result: result || {},
      };

      const internalVersion = existingDataStream.version;
      return await this.savedObjectsClient.update<DataStreamAttributes>(
        DATA_STREAM_SAVED_OBJECT_TYPE,
        dataStreamId,
        dataStreamData,
        {
          ...options,
          version: internalVersion,
        }
      );
    } catch (error) {
      if (SavedObjectsErrorHelpers.isConflictError(error)) {
        throw new Error(
          `Data stream ${dataStreamId} has been updated since you last fetched it. Please fetch the latest version and try again.`
        );
      }
      this.logger.error(`Failed to update data stream: ${error}`);
      throw error;
    }
  }

  /**
   * Get a data stream by ID
   * @param dataStreamId - The ID of the data stream
   * @returns The data stream
   */
  public async getDataStream(dataStreamId: string): Promise<SavedObject<DataStreamAttributes>> {
    try {
      this.logger.debug(`Getting data stream: ${dataStreamId}`);
      return await this.savedObjectsClient.get<DataStreamAttributes>(
        DATA_STREAM_SAVED_OBJECT_TYPE,
        dataStreamId
      );
    } catch (error) {
      this.logger.error(`Failed to get data stream ${dataStreamId}: ${error}`);
      throw error;
    }
  }

  /**
   * Get all data streams
   * @returns All data streams
   */
  public async getAllDataStreams(): Promise<SavedObjectsFindResponse<DataStreamAttributes>> {
    try {
      this.logger.debug('Getting all data streams');
      return await this.savedObjectsClient.find<DataStreamAttributes>({
        type: DATA_STREAM_SAVED_OBJECT_TYPE,
      });
    } catch (error) {
      this.logger.error(`Failed to get all data streams: ${error}`);
      throw error;
    }
  }

  /**
   * Find all data streams by integration ID
   * @param integrationId - The ID of the integration
   * @returns All data streams for the integration
   */
  public async findAllDataStreamsByIntegrationId(
    integrationId: string
  ): Promise<SavedObjectsFindResponse<DataStreamAttributes>> {
    try {
      this.logger.debug(`Finding all data streams for integration: ${integrationId}`);

      return await this.savedObjectsClient.find<DataStreamAttributes>({
        type: DATA_STREAM_SAVED_OBJECT_TYPE,
        filter: `${DATA_STREAM_SAVED_OBJECT_TYPE}.attributes.integration_id: ${JSON.stringify(
          integrationId
        )}`,
      });
    } catch (error) {
      this.logger.error(
        `Failed to find all data streams for integration ${integrationId}: ${error}`
      );
      throw error;
    }
  }

  /**
   * Delete a data stream by ID
   * @param dataStreamId - The ID of the data stream
   * @param options - The options for the delete
   * @returns The deleted data stream
   */
  public async deleteDataStream(
    dataStreamId: string,
    options?: SavedObjectsDeleteOptions
  ): Promise<void> {
    let parentIntegrationId: string | undefined;
    try {
      const dataStream = await this.getDataStream(dataStreamId);
      parentIntegrationId = dataStream.attributes.integration_id;

      this.logger.debug(`Deleting data stream with id:${dataStreamId}`);
      await this.savedObjectsClient.delete(DATA_STREAM_SAVED_OBJECT_TYPE, dataStreamId, options);
    } catch (error) {
      this.logger.error(`Failed to delete data stream ${dataStreamId}: ${error}`);
      throw error;
    }

    // update the integration count since we are deleting a data stream
    try {
      const parentIntegration = await this.getIntegration(parentIntegrationId);
      if (!parentIntegration) {
        throw new Error(
          `Integration associated with this data stream ${parentIntegrationId} not found`
        );
      }

      const updatedIntegrationData: IntegrationAttributes = {
        ...parentIntegration.attributes,
        data_stream_count: parentIntegration.attributes.data_stream_count! - 1,
      };

      await this.updateIntegration(
        updatedIntegrationData,
        parentIntegration.attributes.metadata?.version || '0.0.0'
      );
    } catch (integrationError) {
      this.logger.error(
        `Failed to update integration ${parentIntegrationId} after deleting data stream ${dataStreamId}: ${integrationError}`
      );
    }
  }
}
