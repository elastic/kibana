/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import {
  type SavedObjectsClientContract,
  type SavedObjectsUpdateOptions,
  type SavedObjectsDeleteOptions,
  type SavedObjectsCreateOptions,
  type SavedObject,
  type SavedObjectsFindResponse,
  type SavedObjectsUpdateResponse,
  type Logger,
  SavedObjectsErrorHelpers,
} from '@kbn/core/server';
import type { IntegrationAttributes, DataStreamAttributes } from './schemas/types';
import { DATA_STREAM_SAVED_OBJECT_TYPE, INTEGRATION_SAVED_OBJECT_TYPE, TASK_STATUSES } from './constants';


interface SavedObjectServiceOptions {
  savedObjectsClient: SavedObjectsClientContract;
  logger: Logger;
}

export class AutomaticImportSavedObjectService {
  private savedObjectsClient: SavedObjectsClientContract;
  private logger: Logger;

  constructor({ savedObjectsClient, logger }: SavedObjectServiceOptions) {
    this.savedObjectsClient = savedObjectsClient;
    this.logger = logger;
  }

  /**
   * Integration Operations
   */

  /**
   * Create an integration that may or may not already have data streams associated with it.
   * @param data - The integration data. Must include an integration_id.
   * @param options - The options for the create
   * @returns The saved object
   */
  async insertIntegration(data: IntegrationAttributes, options?: SavedObjectsCreateOptions): Promise<SavedObject<IntegrationAttributes>> {
    const { integration_id, data_stream_count = 0, metadata = {} } = data;

    if (!integration_id) {
      throw new Error('Integration ID is required');
    }

    try {
      this.logger.debug(`Creating integration: ${data.integration_id}`);

      const initialIntegrationsData: IntegrationAttributes = {
        integration_id,
        data_stream_count,
        status: TASK_STATUSES.pending,
        metadata: {
          ...metadata,
          created_at: new Date().toISOString(),
          version: 0,
        },
      };

      return await this.savedObjectsClient.create<IntegrationAttributes>(
        INTEGRATION_SAVED_OBJECT_TYPE,
        initialIntegrationsData,
        {
          // overwrite id that is default generated by the saved objects service
          id: integration_id,
          ...options,
        }
      );
    } catch (error) {
      // Create will throw a confict if integration ID already exists.
      if (SavedObjectsErrorHelpers.isConflictError(error)) {
        throw new Error(`Integration ${integration_id} already exists`);
      }

      this.logger.error(`Failed to create integration: ${error}`);
      throw error;
    }
  }


  /**
  * Create or update an integration
  * @param data - The integration data. Must include an integration_id.
  * @param options - The options for the update
  * @returns The saved object
  */
  async updateIntegration(data: IntegrationAttributes, options?: SavedObjectsUpdateOptions<IntegrationAttributes>): Promise<SavedObjectsUpdateResponse<IntegrationAttributes>> {
    const { integration_id, data_stream_count = 0, status, metadata = {} } = data;

    if (!integration_id) {
      throw new Error('Integration ID is required');
    }

    try {
      this.logger.debug(`Updating integration: ${data.integration_id}`);

      // Check if integration already exists
      const existingIntegration = await this.getIntegration(integration_id);
      if (!existingIntegration) {
        throw new Error(`Integration ${integration_id} not found`);
      }

      const currentVersion = existingIntegration.attributes.metadata?.version || 0;
      const integrationsData: IntegrationAttributes = {
        integration_id,
        data_stream_count,
        status: status || existingIntegration.attributes.status,
        metadata: {
          ...metadata,
          version: currentVersion + 1,
        },
      };

      return await this.savedObjectsClient.update<IntegrationAttributes>(
        INTEGRATION_SAVED_OBJECT_TYPE,
        integration_id,
        integrationsData,
        {
          ...options,
        }
      );
    } catch (error) {
      this.logger.error(`Failed to update integration: ${error}`);
      throw error;
    }
  }

  /**
   * Get an integration by ID
   * @param integrationId - The ID of the integration
   * @returns The integration
   */
  async getIntegration(integrationId: string): Promise<SavedObject<IntegrationAttributes>> {
    try {
      this.logger.debug(`Getting integration: ${integrationId}`);
      return await this.savedObjectsClient.get<IntegrationAttributes>(
        INTEGRATION_SAVED_OBJECT_TYPE,
        integrationId
      );
    } catch (error) {
      this.logger.error(`Failed to get integration ${integrationId}: ${error}`);
      throw error;
    }
  }

  /**
   * @returns All integrations
   */
  async getAllIntegrations(): Promise<SavedObjectsFindResponse<IntegrationAttributes>> {
    try {
      this.logger.debug('Getting all integrations');
      return await this.savedObjectsClient.find<IntegrationAttributes>({
        type: INTEGRATION_SAVED_OBJECT_TYPE,
      });
    }
    catch (error) {
      this.logger.error(`Failed to get all integrations: ${error}`);
      throw error;
    }
  }

  /**
   * Delete an integration by ID
   * @param integrationId - The ID of the integration
   * @param options - The options for the delete
   * @returns The deleted integration
   */
  async deleteIntegration(integrationId: string, options?: SavedObjectsDeleteOptions): Promise<{}> {
    try {
      this.logger.debug(`Deleting integration with id:${integrationId}`)
      return await this.savedObjectsClient.delete(INTEGRATION_SAVED_OBJECT_TYPE, integrationId, options)
    } catch (error) {
      this.logger.error(`Failed to delete integration ${integrationId}: ${error}`);
      throw error;
    }
    // TODO: Delete all data streams associated with this integration in a Cascade type of operation
  }


  /**
   * Data Stream Operations
   */

  /**
   * Create a data stream
   * @param data - The data stream data. Must include an integration_id and data_stream_id.
   * @param options - The options for the create
   * @returns The created data stream
   */
  async insertDataStream(
    data: DataStreamAttributes,
    options?: SavedObjectsCreateOptions
  ): Promise<SavedObject<DataStreamAttributes>> {
    const { integration_id, data_stream_id, job_info = { status: TASK_STATUSES.pending, job_id: '', job_type: '' }, metadata = { sample_count: 0 }, result = {} } = data;

    if (!integration_id) {
      throw new Error('Integration ID is required');
    }

    if (!data_stream_id) {
      throw new Error('Data stream ID is required');
    }

    try {
      this.logger.debug(`Creating data stream: ${data.data_stream_id}`);

      // A Data Stream must always be associated with an Integration
      const integrationTarget = await this.getIntegration(integration_id);
      if (!integrationTarget) {
        throw new Error(`Integration associated with this data stream ${integration_id} not found`);
      }

      const dataStreamData: DataStreamAttributes = {
        integration_id,
        data_stream_id,
        job_info,
        metadata: {
          ...metadata,
          version: 0,
          created_at: new Date().toISOString(),
        },
        result: result || {},
      };

      return await this.savedObjectsClient.create<DataStreamAttributes>(
        DATA_STREAM_SAVED_OBJECT_TYPE,
        dataStreamData,
        {
          // overwrite id that is default generated by the saved objects service
          id: data_stream_id,
          ...options,
        }
      );
    } catch (error) {
      if (SavedObjectsErrorHelpers.isConflictError(error)) {
        throw new Error(`Data stream ${data_stream_id} already exists`);
      }
      throw error;
    }
  }

  /**
   * Update a data stream
   * @param data - The data stream data. Must include an integration_id and data_stream_id.
   * @param options - The options for the update
   * @returns The updated data stream
   */
  async updateDataStream(
    data: DataStreamAttributes,
    options?: SavedObjectsUpdateOptions<DataStreamAttributes>
  ): Promise<SavedObjectsUpdateResponse<DataStreamAttributes>> {
    const { integration_id, data_stream_id, job_info, metadata = { sample_count: 0 }, result = {} } = data;

    if (!integration_id) {
      throw new Error('Integration ID is required');
    }

    if (!data_stream_id) {
      throw new Error('Data stream ID is required');
    }

    try {
      this.logger.debug(`Updating data stream: ${data.data_stream_id}`);

      // A Data Stream must always be associated with an Integration
      const integrationTarget = await this.getIntegration(integration_id);
      if (!integrationTarget) {
        throw new Error(`Integration associated with this data stream ${integration_id} not found`);
      }

      const dataStreamTarget = await this.getDataStream(data_stream_id);
      if (!dataStreamTarget) {
        throw new Error(`Data stream ${data_stream_id} not found`);
      }

      const currentVersion = dataStreamTarget.attributes.metadata?.version || 0;
      const dataStreamData: DataStreamAttributes = {
        integration_id,
        data_stream_id,
        job_info,
        metadata: {
          ...metadata,
          version: currentVersion + 1,
        },
        result: result || {},
      };

      return await this.savedObjectsClient.update<DataStreamAttributes>(
        DATA_STREAM_SAVED_OBJECT_TYPE,
        data.data_stream_id,
        dataStreamData,
        {
          ...options,
        }
      );
    } catch (error) {
      this.logger.error(`Failed to update data stream: ${error}`);
      throw error;
    }
  }

  /**
   * Get a data stream by ID
   * @param dataStreamId - The ID of the data stream
   * @returns The data stream
   */
  async getDataStream(dataStreamId: string): Promise<SavedObject<DataStreamAttributes>> {
    try {
      this.logger.debug(`Getting data stream: ${dataStreamId}`);
      return await this.savedObjectsClient.get<DataStreamAttributes>(
        DATA_STREAM_SAVED_OBJECT_TYPE,
        dataStreamId
      );
    } catch (error) {
      this.logger.error(`Failed to get data stream ${dataStreamId}: ${error}`);
      throw error;
    }
  }

  /**
   * Get all data streams
   * @returns All data streams
   */
  async getAllDataStreams(): Promise<SavedObjectsFindResponse<DataStreamAttributes>> {
    try {
      this.logger.debug('Getting all data streams');
      return await this.savedObjectsClient.find<DataStreamAttributes>({
        type: DATA_STREAM_SAVED_OBJECT_TYPE,
      });
    }
    catch (error) {
      this.logger.error(`Failed to get all data streams: ${error}`);
      throw error;
    }
  }

  /**
   * Find all data streams by integration ID
   * @param integrationId - The ID of the integration
   * @returns All data streams for the integration
   */
  async findAllDataStreamsByIntegrationId(integrationId: string): Promise<SavedObjectsFindResponse<DataStreamAttributes>> {
    try {
      this.logger.debug(`Finding all data streams for integration: ${integrationId}`);

      return await this.savedObjectsClient.find<DataStreamAttributes>({
        type: DATA_STREAM_SAVED_OBJECT_TYPE,
        filter: `${DATA_STREAM_SAVED_OBJECT_TYPE}.attributes.integration_id: ${JSON.stringify(integrationId)}`,
      });
    } catch (error) {
      this.logger.error(`Failed to find all data streams for integration ${integrationId}: ${error}`);
      throw error;
    }
  }

  /**
   * Delete a data stream by ID
   * @param dataStreamId - The ID of the data stream
   * @param options - The options for the delete
   * @returns The deleted data stream
   */
  async deleteDataStream(dataStreamId: string, options?: SavedObjectsDeleteOptions): Promise<{}> {
    try {
      this.logger.debug(`Deleting data stream with id:${dataStreamId}`);
      return await this.savedObjectsClient.delete(DATA_STREAM_SAVED_OBJECT_TYPE, dataStreamId, options);
    } catch (error) {
      this.logger.error(`Failed to delete data stream ${dataStreamId}: ${error}`);
      throw error;
    }
  }
}

