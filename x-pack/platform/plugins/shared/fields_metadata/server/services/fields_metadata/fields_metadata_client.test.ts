/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
import type { TEcsFields, TMetadataFields, TOtelFields } from '../../../common';
import { FieldMetadata } from '../../../common';
import { loggerMock } from '@kbn/logging-mocks';
import { FieldsMetadataClient } from './fields_metadata_client';
import { EcsFieldsRepository } from './repositories/ecs_fields_repository';
import { IntegrationFieldsRepository } from './repositories/integration_fields_repository';
import { MetadataFieldsRepository } from './repositories/metadata_fields_repository';
import { OtelFieldsRepository } from './repositories/otel_fields_repository';

const ecsFields = {
  '@timestamp': {
    dashed_name: 'timestamp',
    description:
      'Date/time when the event originated.\nThis is the date/time extracted from the event, typically representing when the event was generated by the source.\nIf the event source has no original timestamp, this value is typically populated by the first time the event was received by the pipeline.\nRequired field for all events.',
    example: '2016-05-23T08:05:34.853Z',
    flat_name: '@timestamp',
    level: 'core',
    name: '@timestamp',
    normalize: [],
    required: !0,
    short: 'Date/time when the event originated.',
    type: 'date',
  },
} as TEcsFields;

const metadataFields = {
  _index: {
    dashed_name: 'index',
    description:
      'The index to which the document belongs. This metadata field specifies the exact index name in which the document is stored.',
    example: 'index_1',
    flat_name: '_index',
    name: '_index',
    short: 'The index to which the document belongs.',
    type: 'keyword',
    documentation_url:
      'https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-index-field.html',
  },
} as TMetadataFields;

const integrationFields = {
  '1password.item_usages': {
    'onepassword.client.platform_version': {
      name: 'platform_version',
      type: 'keyword',
      description:
        'The version of the browser or computer where the 1Password app is installed, or the CPU of the machine where the 1Password command-line tool is installed',
      flat_name: 'onepassword.client.platform_version',
      source: 'integration',
      dashed_name: 'onepassword-client-platform_version',
      normalize: [],
      short:
        'The version of the browser or computer where the 1Password app is installed, or the CPU of the machine where the 1Password command-line tool is installed',
    },
  },
  'mysql.slowlog': {
    'mysql.slowlog.filesort': {
      name: 'filesort',
      type: 'boolean',
      description: 'Whether filesort optimization was used.',
      flat_name: 'mysql.slowlog.filesort',
      source: 'integration',
      dashed_name: 'mysql-slowlog-filesort',
      normalize: [],
      short: 'Whether filesort optimization was used.',
    },
  },
};

// Mock OTel fields in the new structured format
const otelFields = {
  'service.name': {
    name: 'service.name',
    description: 'Logical name of the service.',

    type: 'keyword',
    example: 'shoppingcart',
  },
  'http.request.method': {
    name: 'http.request.method',
    description: 'HTTP request method.',
    type: 'keyword',
    example: 'GET',
  },
  '@timestamp': {
    name: '@timestamp',
    description: 'Time when the event occurred. UNIX Epoch time in nanoseconds.',
    type: 'date_nanos',
  },
  observed_timestamp: {
    name: 'observed_timestamp',
    description: 'Time when the event was observed by the collection system.',
    type: 'date_nanos',
  },
  severity_number: {
    name: 'severity_number',
    description: 'Numerical value of the severity.',
    type: 'long',
  },
  severity_text: {
    name: 'severity_text',
    description: 'The severity text (also known as log level).',
    type: 'keyword',
  },
} as Partial<TOtelFields>;

describe('FieldsMetadataClient class', () => {
  const logger = loggerMock.create();
  const ecsFieldsRepository = EcsFieldsRepository.create({ ecsFields });
  const metadataFieldsRepository = MetadataFieldsRepository.create({ metadataFields });
  const otelFieldsRepository = OtelFieldsRepository.create({
    otelFields: otelFields as TOtelFields,
  });
  const integrationFieldsExtractor = jest.fn();
  const integrationListExtractor = jest.fn();
  integrationFieldsExtractor.mockImplementation(() => Promise.resolve(integrationFields));
  integrationListExtractor.mockImplementation(() =>
    Promise.resolve([
      {
        id: '1password',
        name: '1password',
        version: '1.0.0',
      },
      {
        id: 'mysql',
        name: 'mysql',
        version: '1.0.0',
      },
    ])
  );

  let integrationFieldsRepository: IntegrationFieldsRepository;
  let fieldsMetadataClient: FieldsMetadataClient;

  beforeEach(() => {
    integrationFieldsExtractor.mockClear();
    integrationFieldsRepository = IntegrationFieldsRepository.create({
      integrationFieldsExtractor,
      integrationListExtractor,
    });
    fieldsMetadataClient = FieldsMetadataClient.create({
      capabilities: { fleet: { read: true }, fleetv2: { read: true } },
      logger,
      ecsFieldsRepository,
      integrationFieldsRepository,
      metadataFieldsRepository,
      otelFieldsRepository,
    });
  });

  describe('#getByName', () => {
    it('should resolve a single ECS/Metadata FieldMetadata instance by default', async () => {
      const timestampFieldInstance = await fieldsMetadataClient.getByName('@timestamp');

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();

      expectToBeDefined(timestampFieldInstance);
      expect(timestampFieldInstance).toBeInstanceOf(FieldMetadata);

      const timestampField = timestampFieldInstance.toPlain();

      expect(Object.hasOwn(timestampField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'description')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'example')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'level')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'required')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'short')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'type')).toBeTruthy();
    });

    it('should attempt resolving the field from an integration if it does not exist in ECS/Metadata by inferring the integration from the field name', async () => {
      const mysqlFieldInstance = await fieldsMetadataClient.getByName('mysql.slowlog.filesort');

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      expectToBeDefined(mysqlFieldInstance);
      expect(mysqlFieldInstance).toBeInstanceOf(FieldMetadata);

      const mysqlField = mysqlFieldInstance.toPlain();

      expect(Object.hasOwn(mysqlField, 'name')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'type')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'description')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'source')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'short')).toBeTruthy();
    });

    it('should attempt resolving the field from an integration if it does not exist in ECS/Metadata and the integration and dataset params are provided', async () => {
      const onePasswordFieldInstance = await fieldsMetadataClient.getByName(
        'onepassword.client.platform_version',
        { integration: '1password', dataset: '1password.item_usages' }
      );

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      expectToBeDefined(onePasswordFieldInstance);
      expect(onePasswordFieldInstance).toBeInstanceOf(FieldMetadata);

      const onePasswordField = onePasswordFieldInstance.toPlain();

      expect(Object.hasOwn(onePasswordField, 'name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'type')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'description')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'source')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'short')).toBeTruthy();
    });

    it('should not resolve the field from an integration if the integration name cannot be inferred from the field name and integration and dataset params are not provided', async () => {
      const unknownFieldInstance = await fieldsMetadataClient.getByName(
        'customField.duration.milliseconds'
      );

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();
      expect(unknownFieldInstance).toBeUndefined();
    });

    it('should not resolve the field from an integration if the user has not the fleet privileges to access it', async () => {
      const clientWithouthPrivileges = FieldsMetadataClient.create({
        capabilities: { fleet: { read: false }, fleetv2: { read: false } },
        logger,
        ecsFieldsRepository,
        integrationFieldsRepository,
        metadataFieldsRepository,
        otelFieldsRepository,
      });

      const fieldInstance = await clientWithouthPrivileges.getByName('mysql.slowlog.filesort');

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();
      expect(fieldInstance).toBeUndefined();
    });
  });

  describe('#find', () => {
    it('should resolve a FieldsMetadataDictionary of matching fields', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp'],
      });

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
    });

    it('should resolve a FieldsMetadataDictionary of matching fields, including integration fields when integration and dataset params are provided', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', 'onepassword.client.platform_version'],
        integration: '1password',
        dataset: '1password.item_usages',
      });

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
      expect(Object.hasOwn(fields, 'onepassword.client.platform_version')).toBeTruthy();
    });

    it('should resolve a FieldsMetadataDictionary of matching fields, skipping unmatched fields', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', 'onepassword.client.platform_version', 'not-existing-field'],
        integration: '1password',
        dataset: '1password.item_usages',
      });

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
      expect(Object.hasOwn(fields, 'onepassword.client.platform_version')).toBeTruthy();
      expect(Object.hasOwn(fields, 'not-existing-field')).toBeFalsy();
    });
  });

  describe('field resolution priority', () => {
    it('should prioritize MetadataFields over all other sources', async () => {
      // Test field '_index' exists in both metadata and otel fields
      const field = await fieldsMetadataClient.getByName('_index');

      expectToBeDefined(field);
      expect(field.source).toBe('metadata');
      expect(field.description).toContain('The index to which the document belongs');
    });

    it('should prioritize IntegrationFields over ECS and OTel when integration context provided', async () => {
      // This would need a field that exists in multiple sources
      // For now, test that integration fields are returned when available
      const field = await fieldsMetadataClient.getByName('onepassword.client.platform_version', {
        integration: '1password',
        dataset: '1password.item_usages',
      });

      expectToBeDefined(field);
      expect(field.source).toBe('integration');
    });

    it('should prioritize ECS over OTel for common fields', async () => {
      // Test field '@timestamp' exists in both ECS and OTel
      const field = await fieldsMetadataClient.getByName('@timestamp');

      expectToBeDefined(field);
      expect(field.source).toBe('ecs');
      expect(field.description).toContain('Date/time when the event originated');
    });

    it('should fall back to OTel when field not found in higher priority sources', async () => {
      // Test field 'service.name' only exists in OTel
      const field = await fieldsMetadataClient.getByName('service.name');

      expectToBeDefined(field);
      expect(field.source).toBe('otel');
      expect(field.description).toBe('Logical name of the service.');
      expect(field.type).toBe('keyword');
    });

    it('should fall back to OTel for HTTP fields', async () => {
      // Test field 'http.request.method' only exists in OTel
      const field = await fieldsMetadataClient.getByName('http.request.method');

      expectToBeDefined(field);
      expect(field.source).toBe('otel');
      expect(field.description).toBe('HTTP request method.');
      expect(field.type).toBe('keyword');
      expect(field.example).toBe('GET');
    });

    it('should return undefined when field not found in any source', async () => {
      const field = await fieldsMetadataClient.getByName('completely.non.existent.field');

      expect(field).toBeUndefined();
    });

    it('should include OTel fields in find() when no specific fieldNames provided', async () => {
      const fieldsDict = await fieldsMetadataClient.find();
      const fields = fieldsDict.getFields();

      // Should include fields from all sources including OTel
      expect(fields['service.name']).toBeDefined();
      expect(fields['http.request.method']).toBeDefined();
      expect(fields['@timestamp']).toBeDefined(); // ECS takes priority
      expect(fields._index).toBeDefined(); // Metadata takes priority

      // Verify OTel fields have correct source
      expect(fields['service.name'].source).toBe('otel');
      expect(fields['http.request.method'].source).toBe('otel');
    });

    it('should respect priority order in find() with specific fieldNames', async () => {
      const fieldsDict = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', 'service.name', '_index', 'http.request.method'],
      });
      const fields = fieldsDict.getFields();

      // Verify sources match priority order
      expect(fields._index.source).toBe('metadata'); // Highest priority
      expect(fields['@timestamp'].source).toBe('ecs'); // Second priority
      expect(fields['service.name'].source).toBe('otel'); // Lowest priority (fallback)
      expect(fields['http.request.method'].source).toBe('otel'); // Lowest priority (fallback)
    });
  });

  describe('OTel field-specific functionality', () => {
    it('should preserve OTel field examples when available', async () => {
      const field = await fieldsMetadataClient.getByName('service.name');

      expectToBeDefined(field);
      expect(field.example).toBe('shoppingcart');
    });

    it('should handle OTel fields without examples', async () => {
      // '@timestamp' in otel fields has no example
      const field = await fieldsMetadataClient.getByName('@timestamp');

      // This should return ECS version which has example, but if it returned OTel it would have no example
      expectToBeDefined(field);
      expect(field.source).toBe('ecs'); // ECS takes priority
    });

    it('should properly convert OTel structured format to FieldMetadata', async () => {
      const field = await fieldsMetadataClient.getByName('http.request.method');

      expectToBeDefined(field);
      expect(field.source).toBe('otel');
      expect(field.name).toBe('http.request.method');
      expect(field.description).toBe('HTTP request method.');
      expect(field.type).toBe('keyword');
      expect(field.example).toBe('GET');

      // Verify it's a proper FieldMetadata instance
      expect(typeof field.toPlain).toBe('function');
    });
  });
});

function expectToBeDefined<T>(value: T | undefined): asserts value is T {
  expect(value).toBeDefined();
}
