/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
import type { TEcsFields, TMetadataFields, TOtelFields } from '../../../common';
import { loggerMock } from '@kbn/logging-mocks';
import { FieldsMetadataClient } from './fields_metadata_client';
import { EcsFieldsRepository } from './repositories/ecs_fields_repository';
import { IntegrationFieldsRepository } from './repositories/integration_fields_repository';
import { MetadataFieldsRepository } from './repositories/metadata_fields_repository';
import { OtelFieldsRepository } from './repositories/otel_fields_repository';
import { FieldMetadata } from '../../../common/fields_metadata/models/field_metadata';

const ecsFields = {
  '@timestamp': {
    dashed_name: 'timestamp',
    description:
      'Date/time when the event originated.\nThis is the date/time extracted from the event, typically representing when the event was generated by the source.\nIf the event source has no original timestamp, this value is typically populated by the first time the event was received by the pipeline.\nRequired field for all events.',
    example: '2016-05-23T08:05:34.853Z',
    flat_name: '@timestamp',
    level: 'core',
    name: '@timestamp',
    normalize: [],
    required: !0,
    short: 'Date/time when the event originated.',
    type: 'date',
  },
  'user.name': {
    dashed_name: 'user-name',
    description: 'Short name or login of the user.',
    example: 'a.einstein',
    flat_name: 'user.name',
    level: 'core',
    name: 'name',
    normalize: [],
    short: 'Short name or login of the user.',
    type: 'keyword',
  },
} as TEcsFields;

const metadataFields = {
  _index: {
    dashed_name: 'index',
    description:
      'The index to which the document belongs. This metadata field specifies the exact index name in which the document is stored.',
    example: 'index_1',
    flat_name: '_index',
    name: '_index',
    short: 'The index to which the document belongs.',
    type: 'keyword',
    documentation_url:
      'https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-index-field.html',
  },
} as TMetadataFields;

const integrationFields = {
  '1password.item_usages': {
    'onepassword.client.platform_version': {
      name: 'platform_version',
      type: 'keyword',
      description:
        'The version of the browser or computer where the 1Password app is installed, or the CPU of the machine where the 1Password command-line tool is installed',
      flat_name: 'onepassword.client.platform_version',
      source: 'integration',
      dashed_name: 'onepassword-client-platform_version',
      normalize: [],
      short:
        'The version of the browser or computer where the 1Password app is installed, or the CPU of the machine where the 1Password command-line tool is installed',
    },
  },
  'mysql.slowlog': {
    'mysql.slowlog.filesort': {
      name: 'filesort',
      type: 'boolean',
      description: 'Whether filesort optimization was used.',
      flat_name: 'mysql.slowlog.filesort',
      source: 'integration',
      dashed_name: 'mysql-slowlog-filesort',
      normalize: [],
      short: 'Whether filesort optimization was used.',
    },
  },
};

// Mock OTel fields in the new structured format
const otelFields = {
  'service.name': {
    name: 'service.name',
    description: 'Logical name of the service.',

    type: 'keyword',
    example: 'shoppingcart',
  },
  'http.request.method': {
    name: 'http.request.method',
    description: 'HTTP request method.',
    type: 'keyword',
    example: 'GET',
  },
  '@timestamp': {
    name: '@timestamp',
    description: 'Time when the event occurred. UNIX Epoch time in nanoseconds.',
    type: 'date_nanos',
  },
  observed_timestamp: {
    name: 'observed_timestamp',
    description: 'Time when the event was observed by the collection system.',
    type: 'date_nanos',
  },
  severity_number: {
    name: 'severity_number',
    description: 'Numerical value of the severity.',
    type: 'long',
  },
  severity_text: {
    name: 'severity_text',
    description: 'The severity text (also known as log level).',
    type: 'keyword',
  },
  // Add a native OTel field with the 'attributes.' prefix to test priority
  'attributes.custom.otel.field': {
    name: 'attributes.custom.otel.field',
    description: 'A native OTel field with attributes prefix.',
    type: 'keyword',
    example: 'otel-value',
  },
} as Partial<TOtelFields>;

describe('FieldsMetadataClient class', () => {
  const logger = loggerMock.create();
  const ecsFieldsRepository = EcsFieldsRepository.create({ ecsFields });
  const metadataFieldsRepository = MetadataFieldsRepository.create({ metadataFields });
  const otelFieldsRepository = OtelFieldsRepository.create({
    otelFields: otelFields as TOtelFields,
  });
  const integrationFieldsExtractor = jest.fn();
  const integrationListExtractor = jest.fn();
  integrationFieldsExtractor.mockImplementation(() => Promise.resolve(integrationFields));
  integrationListExtractor.mockImplementation(() =>
    Promise.resolve([
      {
        id: '1password',
        name: '1password',
        version: '1.0.0',
      },
      {
        id: 'mysql',
        name: 'mysql',
        version: '1.0.0',
      },
    ])
  );

  let integrationFieldsRepository: IntegrationFieldsRepository;
  let fieldsMetadataClient: FieldsMetadataClient;

  beforeEach(() => {
    integrationFieldsExtractor.mockClear();
    integrationFieldsRepository = IntegrationFieldsRepository.create({
      integrationFieldsExtractor,
      integrationListExtractor,
    });
    fieldsMetadataClient = FieldsMetadataClient.create({
      capabilities: { fleet: { read: true }, fleetv2: { read: true } },
      logger,
      ecsFieldsRepository,
      integrationFieldsRepository,
      metadataFieldsRepository,
      otelFieldsRepository,
    });
  });

  describe('#getByName', () => {
    it('should resolve a single ECS/Metadata FieldMetadata instance by default', async () => {
      const timestampFieldInstance = await fieldsMetadataClient.getByName('@timestamp');

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();

      expectToBeDefined(timestampFieldInstance);
      expect(timestampFieldInstance).toBeInstanceOf(FieldMetadata);

      const timestampField = timestampFieldInstance.toPlain();

      expect(Object.hasOwn(timestampField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'description')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'example')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'level')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'name')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'required')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'short')).toBeTruthy();
      expect(Object.hasOwn(timestampField, 'type')).toBeTruthy();
    });

    it('should attempt resolving the field from an integration if it does not exist in ECS/Metadata by inferring the integration from the field name', async () => {
      const mysqlFieldInstance = await fieldsMetadataClient.getByName('mysql.slowlog.filesort');

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      expectToBeDefined(mysqlFieldInstance);
      expect(mysqlFieldInstance).toBeInstanceOf(FieldMetadata);

      const mysqlField = mysqlFieldInstance.toPlain();

      expect(Object.hasOwn(mysqlField, 'name')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'type')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'description')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'source')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(mysqlField, 'short')).toBeTruthy();
    });

    it('should attempt resolving the field from an integration if it does not exist in ECS/Metadata and the integration and dataset params are provided', async () => {
      const onePasswordFieldInstance = await fieldsMetadataClient.getByName(
        'onepassword.client.platform_version',
        { integration: '1password', dataset: '1password.item_usages' }
      );

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      expectToBeDefined(onePasswordFieldInstance);
      expect(onePasswordFieldInstance).toBeInstanceOf(FieldMetadata);

      const onePasswordField = onePasswordFieldInstance.toPlain();

      expect(Object.hasOwn(onePasswordField, 'name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'type')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'description')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'flat_name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'source')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'dashed_name')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'normalize')).toBeTruthy();
      expect(Object.hasOwn(onePasswordField, 'short')).toBeTruthy();
    });

    it('should not resolve the field from an integration if the integration name cannot be inferred from the field name and integration and dataset params are not provided', async () => {
      const unknownFieldInstance = await fieldsMetadataClient.getByName(
        'customField.duration.milliseconds'
      );

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();
      expect(unknownFieldInstance).toBeUndefined();
    });

    it('should not resolve the field from an integration if the user has not the fleet privileges to access it', async () => {
      const clientWithouthPrivileges = FieldsMetadataClient.create({
        capabilities: { fleet: { read: false }, fleetv2: { read: false } },
        logger,
        ecsFieldsRepository,
        integrationFieldsRepository,
        metadataFieldsRepository,
        otelFieldsRepository,
      });

      const fieldInstance = await clientWithouthPrivileges.getByName('mysql.slowlog.filesort');

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();
      expect(fieldInstance).toBeUndefined();
    });

    it('should not resolve the field if the source is not allowed', async () => {
      // '_index' is a metadata field, but we filter for ECS sources only
      const fieldInstance = await fieldsMetadataClient.getByName('_index', {
        source: ['ecs'],
      });

      expect(fieldInstance).toBeUndefined();
    });
  });

  describe('#find', () => {
    it('should resolve a FieldsMetadataDictionary of matching fields', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp'],
      });

      expect(integrationFieldsExtractor).not.toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
    });

    it('should resolve a FieldsMetadataDictionary of matching fields, including integration fields when integration and dataset params are provided', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', 'onepassword.client.platform_version'],
        integration: '1password',
        dataset: '1password.item_usages',
      });

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
      expect(Object.hasOwn(fields, 'onepassword.client.platform_version')).toBeTruthy();
    });

    it('should resolve a FieldsMetadataDictionary of matching fields, skipping unmatched fields', async () => {
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', 'onepassword.client.platform_version', 'not-existing-field'],
        integration: '1password',
        dataset: '1password.item_usages',
      });

      expect(integrationFieldsExtractor).toHaveBeenCalled();

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
      expect(Object.hasOwn(fields, 'onepassword.client.platform_version')).toBeTruthy();
      expect(Object.hasOwn(fields, 'not-existing-field')).toBeFalsy();
    });

    it('should not resolve the fields from sources not allowed', async () => {
      // Should resolve '@timestamp' from ECS but not '_index'
      const fieldsDictionaryInstance = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', '_index'],
        source: ['ecs'],
      });

      const fields = fieldsDictionaryInstance.toPlain();

      expect(Object.hasOwn(fields, '@timestamp')).toBeTruthy();
      expect(Object.hasOwn(fields, '_index')).toBeFalsy();
    });
  });

  describe('field resolution priority', () => {
    it('should prioritize MetadataFields over all other sources', async () => {
      // Test field '_index' exists in both metadata and otel fields
      const field = await fieldsMetadataClient.getByName('_index');

      expectToBeDefined(field);
      expect(field.source).toBe('metadata');
      expect(field.description).toContain('The index to which the document belongs');
    });

    it('should prioritize IntegrationFields over ECS and OTel when integration context provided', async () => {
      // This would need a field that exists in multiple sources
      // For now, test that integration fields are returned when available
      const field = await fieldsMetadataClient.getByName('onepassword.client.platform_version', {
        integration: '1password',
        dataset: '1password.item_usages',
      });

      expectToBeDefined(field);
      expect(field.source).toBe('integration');
    });

    it('should prioritize ECS over OTel for common fields', async () => {
      // Test field '@timestamp' exists in both ECS and OTel
      const field = await fieldsMetadataClient.getByName('@timestamp');

      expectToBeDefined(field);
      expect(field.source).toBe('ecs');
      expect(field.description).toContain('Date/time when the event originated');
    });

    it('should fall back to OTel when field not found in higher priority sources', async () => {
      // Test field 'service.name' only exists in OTel
      const field = await fieldsMetadataClient.getByName('service.name');

      expectToBeDefined(field);
      expect(field.source).toBe('otel');
      expect(field.description).toBe('Logical name of the service.');
      expect(field.type).toBe('keyword');
    });

    it('should fall back to OTel for HTTP fields', async () => {
      // Test field 'http.request.method' only exists in OTel
      const field = await fieldsMetadataClient.getByName('http.request.method');

      expectToBeDefined(field);
      expect(field.source).toBe('otel');
      expect(field.description).toBe('HTTP request method.');
      expect(field.type).toBe('keyword');
      expect(field.example).toBe('GET');
    });

    it('should return undefined when field not found in any source', async () => {
      const field = await fieldsMetadataClient.getByName('completely.non.existent.field');

      expect(field).toBeUndefined();
    });

    it('should include OTel fields in find() when no specific fieldNames provided', async () => {
      const fieldsDict = await fieldsMetadataClient.find();
      const fields = fieldsDict.getFields();

      // Should include fields from all sources including OTel
      expect(fields['service.name']).toBeDefined();
      expect(fields['http.request.method']).toBeDefined();
      expect(fields['@timestamp']).toBeDefined(); // ECS takes priority
      expect(fields._index).toBeDefined(); // Metadata takes priority

      // Verify OTel fields have correct source
      expect(fields['service.name'].source).toBe('otel');
      expect(fields['http.request.method'].source).toBe('otel');
    });

    it('should respect priority order in find() with specific fieldNames', async () => {
      const fieldsDict = await fieldsMetadataClient.find({
        fieldNames: ['@timestamp', 'service.name', '_index', 'http.request.method'],
      });
      const fields = fieldsDict.getFields();

      // Verify sources match priority order
      expect(fields._index.source).toBe('metadata'); // Highest priority
      expect(fields['@timestamp'].source).toBe('ecs'); // Second priority
      expect(fields['service.name'].source).toBe('otel'); // Lowest priority (fallback)
      expect(fields['http.request.method'].source).toBe('otel'); // Lowest priority (fallback)
    });

    it('should prioritize OTel over ECS for prefixed fields (attributes.* and resource.attributes.*)', async () => {
      // Test that native OTel prefixed fields take priority over ECS proxy-generated prefixed fields
      const nativeOtelField = await fieldsMetadataClient.getByName('attributes.custom.otel.field');

      expectToBeDefined(nativeOtelField);
      expect(nativeOtelField.source).toBe('otel');
      expect(nativeOtelField.description).toBe('A native OTel field with attributes prefix.');
      expect(nativeOtelField.example).toBe('otel-value');
    });

    it('should return ECS proxy-generated prefixed field when OTel does not have that base field', async () => {
      // When requesting a prefixed field where OTel doesn't have the base field,
      // it should fall back to the ECS proxy-generated field
      // Use a field that exists in ECS but not in OTel
      const ecsProxyField = await fieldsMetadataClient.getByName('attributes.user.name');

      expectToBeDefined(ecsProxyField);
      // Since 'user.name' doesn't exist in our mock OTel fields, it falls back to ECS
      expect(ecsProxyField.source).toBe('ecs');
      expect(ecsProxyField.name).toBe('attributes.user.name');
      expect(ecsProxyField.flat_name).toBe('attributes.user.name');
    });

    it('should prioritize OTel for prefixed fields when OTel has the base field', async () => {
      // When requesting a prefixed field where OTel DOES have the base field,
      // OTel should be prioritized over ECS
      const otelField = await fieldsMetadataClient.getByName('attributes.@timestamp');

      expectToBeDefined(otelField);
      // OTel has '@timestamp', so even with 'attributes.' prefix, OTel takes priority
      expect(otelField.source).toBe('otel');
      expect(otelField.description).toContain('Time when the event occurred');
    });
  });

  describe('OTel field-specific functionality', () => {
    it('should preserve OTel field examples when available', async () => {
      const field = await fieldsMetadataClient.getByName('service.name');

      expectToBeDefined(field);
      expect(field.example).toBe('shoppingcart');
    });

    it('should handle OTel fields without examples', async () => {
      // '@timestamp' in otel fields has no example
      const field = await fieldsMetadataClient.getByName('@timestamp');

      // This should return ECS version which has example, but if it returned OTel it would have no example
      expectToBeDefined(field);
      expect(field.source).toBe('ecs'); // ECS takes priority
    });

    it('should properly convert OTel structured format to FieldMetadata', async () => {
      const field = await fieldsMetadataClient.getByName('http.request.method');

      expectToBeDefined(field);
      expect(field.source).toBe('otel');
      expect(field.name).toBe('http.request.method');
      expect(field.description).toBe('HTTP request method.');
      expect(field.type).toBe('keyword');
      expect(field.example).toBe('GET');

      // Verify it's a proper FieldMetadata instance
      expect(typeof field.toPlain).toBe('function');
    });
  });
});

function expectToBeDefined<T>(value: T | undefined): asserts value is T {
  expect(value).toBeDefined();
}
