/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { waitFor, renderHook } from '@testing-library/react';

import { createUseFieldsMetadataHook, UseFieldsMetadataParams } from './use_fields_metadata';
import { FindFieldsMetadataResponsePayload } from '../../../common/latest';
import { createFieldsMetadataServiceStartMock } from '../../services/fields_metadata/fields_metadata_service.mock';
import { IFieldsMetadataClient } from '../../services/fields_metadata';

const fields: FindFieldsMetadataResponsePayload['fields'] = {
  '@timestamp': {
    dashed_name: 'timestamp',
    description:
      'Date/time when the event originated.\nThis is the date/time extracted from the event, typically representing when the event was generated by the source.\nIf the event source has no original timestamp, this value is typically populated by the first time the event was received by the pipeline.\nRequired field for all events.',
    example: '2016-05-23T08:05:34.853Z',
    flat_name: '@timestamp',
    level: 'core',
    name: '@timestamp',
    normalize: [],
    short: 'Date/time when the event originated.',
    type: 'date',
    source: 'ecs',
  },
};

const mockedFieldsMetadataResponse = { fields };

const fieldsMetadataService = createFieldsMetadataServiceStartMock();

const useFieldsMetadata = createUseFieldsMetadataHook({ fieldsMetadataService });

describe('useFieldsMetadata', () => {
  let fieldsMetadataClient: jest.Mocked<IFieldsMetadataClient>;
  beforeEach(async () => {
    fieldsMetadataClient = await fieldsMetadataService.getClient();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should return the fieldsMetadata value from the API', async () => {
    fieldsMetadataClient.find.mockResolvedValue(mockedFieldsMetadataResponse);
    const { result } = renderHook(() => useFieldsMetadata());

    expect(result.current.loading).toBe(true);
    expect(result.current.fieldsMetadata).toEqual(undefined);

    await waitFor(() => new Promise((resolve) => resolve(null)));

    const { fieldsMetadata, loading, error } = result.current;
    expect(fieldsMetadata).toEqual(fields);
    expect(loading).toBeFalsy();
    expect(error).toBeFalsy();
  });

  it('should call the fieldsMetadata service with the passed parameters', async () => {
    fieldsMetadataClient.find.mockResolvedValue(mockedFieldsMetadataResponse);
    const params: UseFieldsMetadataParams = {
      attributes: ['description', 'short'],
      fieldNames: ['@timestamp', 'agent.name'],
      integration: 'integration_name',
      dataset: 'dataset_name',
    };

    renderHook(() => useFieldsMetadata(params));

    await waitFor(() => expect(fieldsMetadataClient.find).toHaveBeenCalledWith(params));
  });

  it('should return an error if the API call fails', async () => {
    const error = new Error('Fetch fields metadata Failed');
    fieldsMetadataClient.find.mockRejectedValueOnce(error);

    const { result } = renderHook(() => useFieldsMetadata());

    await waitFor(() => expect(result.current.error?.message).toMatch(error.message));
  });
});
