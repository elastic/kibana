/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { MappingProperty } from '@elastic/elasticsearch/lib/api/types';
import {
  getDocsCount,
  getFieldTypes,
  getIncompatibleStatColor,
  getTotalDocsCount,
} from './helpers';
import { mockStatsGreenIndex } from './mock/stats/mock_stats_green_index';
import { mockStatsYellowIndex } from './mock/stats/mock_stats_yellow_index';

describe('helpers', () => {
  describe('getFieldTypes', () => {
    /**
     * These `mappingsProperties` represent mappings that were generated by
     * Elasticsearch automatically, for an index named `auditbeat-custom-index-1`:
     *
     * ```
     * DELETE auditbeat-custom-index-1
     *
     * PUT auditbeat-custom-index-1
     *
     * PUT auditbeat-custom-index-1/_mapping
     * {
     *   "properties": {
     *     "@timestamp": {
     *       "type": "date"
     *     },
     *     "event.category": {
     *       "type": "keyword",
     *       "ignore_above": 1024
     *     }
     *   }
     * }
     * ```
     *
     * when the following document was inserted:
     *
     * ```
     * POST auditbeat-custom-index-1/_doc
     * {
     *   "@timestamp": "2023-02-06T09:41:49.668Z",
     *   "host": {
     *     "name": "foo"
     *   },
     *   "event": {
     *     "category": "an_invalid_category"
     *   },
     *   "some.field": "this",
     *   "source": {
     *     "port": 90210,
     *     "ip": "10.1.2.3"
     *   }
     * }
     * ```
     */
    const mappingsProperties: Record<string, MappingProperty> = {
      '@timestamp': {
        type: 'date',
      },
      event: {
        properties: {
          category: {
            type: 'keyword',
            ignore_above: 1024,
          },
        },
      },
      host: {
        properties: {
          name: {
            type: 'text',
            fields: {
              keyword: {
                type: 'keyword',
                ignore_above: 256,
              },
            },
          },
        },
      },
      some: {
        properties: {
          field: {
            type: 'text',
            fields: {
              keyword: {
                type: 'keyword',
                ignore_above: 256,
              },
            },
          },
        },
      },
      source: {
        properties: {
          ip: {
            type: 'text',
            fields: {
              keyword: {
                type: 'keyword',
                ignore_above: 256,
              },
            },
          },
          port: {
            type: 'long',
          },
        },
      },
    };

    const expected = [
      {
        field: '@timestamp',
        type: 'date',
      },
      {
        field: 'event.category',
        type: 'keyword',
      },
      {
        field: 'host.name',
        type: 'text',
      },
      {
        field: 'host.name.keyword',
        type: 'keyword',
      },
      {
        field: 'some.field',
        type: 'text',
      },
      {
        field: 'some.field.keyword',
        type: 'keyword',
      },
      {
        field: 'source.ip',
        type: 'text',
      },
      {
        field: 'source.ip.keyword',
        type: 'keyword',
      },
      {
        field: 'source.port',
        type: 'long',
      },
    ];

    test('it flattens the field names and types in the mapping properties', () => {
      expect(getFieldTypes(mappingsProperties)).toEqual(expected);
    });

    test('it throws a type error when mappingsProperties is not flatten-able', () => {
      // @ts-expect-error
      const invalidType: Record<string, unknown> = []; // <-- this is an array, NOT a valid Record<string, unknown>

      expect(() => getFieldTypes(invalidType)).toThrowError('Root value is not flatten-able');
    });
  });

  describe('getDocsCount', () => {
    test('it returns the expected docs count when `stats` contains the `indexName`', () => {
      const indexName = '.ds-packetbeat-8.6.1-2023.02.04-000001';
      const expectedCount = mockStatsYellowIndex[indexName].primaries?.docs?.count;

      expect(
        getDocsCount({
          indexName,
          stats: mockStatsYellowIndex,
        })
      ).toEqual(expectedCount);
    });

    test('it returns zero when `stats` does NOT contain the `indexName`', () => {
      const indexName = 'not-gonna-find-it';

      expect(
        getDocsCount({
          indexName,
          stats: mockStatsYellowIndex,
        })
      ).toEqual(0);
    });

    test('it returns zero when `stats` is null', () => {
      const indexName = '.ds-packetbeat-8.6.1-2023.02.04-000001';

      expect(
        getDocsCount({
          indexName,
          stats: null,
        })
      ).toEqual(0);
    });

    test('it returns the expected total for a green index, where `primaries.docs.count` and `total.docs.count` have different values', () => {
      const indexName = 'auditbeat-custom-index-1';

      expect(
        getDocsCount({
          indexName,
          stats: mockStatsGreenIndex,
        })
      ).toEqual(mockStatsGreenIndex[indexName].primaries?.docs?.count);
    });
  });

  describe('getTotalDocsCount', () => {
    test('it returns the expected total given a subset of index names in the stats', () => {
      const indexName = '.ds-packetbeat-8.5.3-2023.02.04-000001';
      const expectedCount = mockStatsYellowIndex[indexName].primaries?.docs?.count;

      expect(
        getTotalDocsCount({
          indexNames: [indexName],
          stats: mockStatsYellowIndex,
        })
      ).toEqual(expectedCount);
    });

    test('it returns the expected total given all index names in the stats', () => {
      const allIndexNamesInStats = [
        '.ds-packetbeat-8.6.1-2023.02.04-000001',
        '.ds-packetbeat-8.5.3-2023.02.04-000001',
      ];

      expect(
        getTotalDocsCount({
          indexNames: allIndexNamesInStats,
          stats: mockStatsYellowIndex,
        })
      ).toEqual(3258632);
    });

    test('it returns zero given an empty collection of index names', () => {
      expect(
        getTotalDocsCount({
          indexNames: [], // <-- empty
          stats: mockStatsYellowIndex,
        })
      ).toEqual(0);
    });

    test('it returns the expected total for a green index', () => {
      const indexName = 'auditbeat-custom-index-1';
      const expectedCount = mockStatsGreenIndex[indexName].primaries?.docs?.count;

      expect(
        getTotalDocsCount({
          indexNames: [indexName],
          stats: mockStatsGreenIndex,
        })
      ).toEqual(expectedCount);
    });
  });

  describe('getIncompatibleStatColor', () => {
    test('it returns the expected color when incompatible is greater than zero', () => {
      const incompatible = 123;

      expect(getIncompatibleStatColor(incompatible)).toBe('#bd271e');
    });

    test('it returns undefined when incompatible is zero', () => {
      const incompatible = 0;

      expect(getIncompatibleStatColor(incompatible)).toBeUndefined();
    });

    test('it returns undefined when incompatible is undefined', () => {
      const incompatible = undefined;

      expect(getIncompatibleStatColor(incompatible)).toBeUndefined();
    });
  });
});
