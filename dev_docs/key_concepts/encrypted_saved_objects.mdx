---
id: kibDevDocsEncryptedSavedObjectsIntro
slug: /kibana-dev-docs/key-concepts/encrypted-saved-objects-intro
title: Encrypted Saved Objects
description: Configure your saved object types to secure sensitive data.
date: 2024-05-21
tags: ['kibana', 'dev', 'contributor', 'api docs']
---

"Encrypted Saved Objects" (ESO) are <DocLink id="kibDevDocsSavedObjectsIntro" text="Saved Object types" /> that have been registered with the Encrypted Saved Objects
Service (ESO Service) to the specify which attributes should be protected (encrypted attributes) and which attributes, if any, should be present and unchanged
in order to decrypt the protected attributes ("Additional Authenticated Data", or AAD).

The ESO Service encrypts ESOs with the Encrypted Saved Object encryption key, a Kibana configuration setting. This setting must have a valid value for the ESO Service
to function. For more details see [Secure saved objects](https://www.elastic.co/guide/en/kibana/current/xpack-security-secure-saved-objects.html).

Developers create and manage their Encrypted Saved Object types programmatically. This document will cover the basics.

## Registering an Encrypted Saved Object Type

### Should your Saved Object be an Encrypted Saved Object?

Most Saved Object types do not need to be registered as an encrypted type. Only register a Saved Object type with the ESO service if it contains sensitive
information. What sort of information is considered sensitive? Here is a non-inclusive list to help you make a determination:

- Authentication data: usernames, passwords, API or access keys, private endpoints
- Personal information: social security numbers or equivalent, back account or credit card numbers
- ToDo: what else?

When in doubt, consult with the Kibana Security team (Application Experience/Platform Services/Security).

### Registration

To register a Saved Object type with the ESO Service, call the service's `registerType` function, and provide an `EncryptedSavedObjectTypeRegistration`
object that defines how the object should be encrypted.

```ts
  export interface EncryptedSavedObjectTypeRegistration {
    readonly type: string; // The name of the Saved Object type. This must match the name used to register the type with Core's Saved Object Service.
    readonly attributesToEncrypt: ReadonlySet<string | AttributeToEncrypt>; // The attributes to protect (anything considered sensitive data)
    readonly attributesToIncludeInAAD?: ReadonlySet<string>; // The attributes to include in AAD (more on this below)
  }
```

`attributesToEncrypt` can be defined by either a string matching the name of the attribute, or an `AttributeToEncrypt` object, which enables you to specify when
an attribute's value should be allowed to be "dangerously exposed". By default, attribute values will not be exposed to end users, and can only be consumed by the
internal Kibana server. If end users must have access to the encrypted values, register the encrypted attribute with a `attributesToEncrypt` object and use
`dangerouslyExposeValue: true`.

### AAD

AAD, or Additional Authenticated Data, is part of an "Authenticated Encryption" schema. AAD is an unencrypted string that is used during encryption and decryption
operations in addition to the supplied encryption key, to protect access to encrypted values. If AAD is used during encryption, it must be provided during decryption,
and must be an exact match to the AAD value used during encryption, otherwise decryption will fail. Typically, AAD comprises data that could only be accessed by an
authenticated user and either never changes, or would only potentially change when encrypted values change.

For ESOs, AAD is constructed of key-value pairs composed of the Saved Object Descriptor and any attributes included in `attributesToIncludeInAAD` when the ESO is
registered. The Saved Object Descriptor consists of the object type, ID, and, if applicable, namespace (or space ID). The descriptor for Space-agnostic types
(`namespaceType: 'agnostic'`) will not include a namespace, and for multi-namespace types (`namespaceType: 'multiple-isolated'` and `namespaceType: 'multiple'`) will
only include the first namespace found in the object's list of namespaces.

```ts
  export interface SavedObjectDescriptor {
    readonly id: string;
    readonly type: string;
    readonly namespace?: string;
  }
```

#### Nested attributes

When an attribute is included in AAD, all of its properties, or subfields, are inherently included in AAD. When AAD is constructed as key-value pairs, the nested
properties of an attribute are all included in its value. In this way, AAD inclusion is hierarchical.

#### What attributes should be included in AAD?

Determining which attributes to include in AAD is not an exact science, however there are some basic guidelines.

Good candidates for attributes to INCLUDE in AAD are attributes that...
- are always populated with a value
- have a value that will never change once an object is created
- have a value that only changes when one or more encrypted attributes change

Good candidates for attributes to EXCLUDE from AAD are attributes that...

- the value of can be changed by an end user, or other means, independently of any encrypted attributes
- may or may not be present or populated
- may be removed from the object or refactored in the future

There are additional considerations to make due to how version upgrades work in Serverless. These are covered in more detail in [ToDo: doc link here], but the
basics are:

- An attribute cannot be removed from AAD once it is included, unless it can be altogether removed from the object type, or refactored with a new name.
- An existing attribute cannot be added to AAD if it was not included in AAD when it was first defined and has already been populated.

When making the decision of which attributes to include in AAD, it is best to be conservative and only include attributes that the owning team is 100% confident
should be included.

## Caveats

### Partial Updates

Partial updates on ESOs are only possible if the changes are limited to unencrypted and non-AAD attributes. Any changes to an ESO's encrypted values or AAD-
included values requires re-encryption, which means the entire object must be provided when updating to avoid corrupting the object. If an ESO is corrupted by
a partial update, it will be effectively undecryptable.

### Migrations, Backward compatibility, and Serverless

With time you may need to change your ESO types. Model Versions allow developers to make versioned changes to Saved Object types, but an ESO type requires special
handling if there are changes to its encrypted attributes or attributes that are included in AAD - in both cases an object must be re-encrypted. For this case the
ESO Service exposes a Model Version wrapper function API `createModelVersion`. Similar in utility to its predecessor (`createMigration` - used with non-Model Version
Saved Object legacy migrations), `createModelVersion` provides a way to wrap a Model Version definition such that decryption and encryption occur automatically
during migration of any applicable ESOs.

In addition to a Model Version definition, `createModelVersion` also requires both an "input type" and "output type" `EncryptedSavedObjectTypeRegistration`
input parameters.

```ts
export interface CreateEsoModelVersionFnOpts {
  modelVersion: SavedObjectsModelVersion;
  shouldTransformIfDecryptionFails?: boolean;
  inputType: EncryptedSavedObjectTypeRegistration;
  outputType: EncryptedSavedObjectTypeRegistration;
}
```

The `inputType` parameter provides the necessary ESO registration definition for decrypting an ESO of the preceding Model Version prior to performing any transforms
defined by the Model Version. The `outputType` parameter provides the necessary ESO registration definition for encrypting an ESO once the transforms defined in the
Model Version have been completed. All of the Model Version transform functions ('unsafe_transform', 'data_backfill', 'data_removal'), are merged into a single
transform function for efficiency. This way, each ESO only needs to be decrypted and re-encrypted once to incorporate all of the changes defined in a Model Version.
The optional `shouldTransformIfDecryptionFails` parameter defines whether an ESO type should proceed with the Model Version changes even if decryption fails.

Some examples of `createModelVersion` can be found in the ESO Model Version example plugin (examples/eso_model_version_example/server/plugin.ts) [ToDo: better link?]

For more information regarding Model Versions see the documentation at packages/core/saved-objects/core-saved-objects-server/docs/model_versions.md [ToDo: not sure
this exists in vercel yet?]

#### Serverless Considerations

Changes to ESOs must be carefully considered due to how upgrades occur for Serverless projects. In Serverless, there is a "Zero Downtime" (ZDT) upgrade algorithm. This
means that both the latest and previous versions of Kibana may be running simultaneously. In regard to ESOs, this means that the previous version of Kibana may attempt
to access ESOs that have been migrated by the latest version of Kibana, and in order to do so, must be able to decrypt them successfully without having any knowledge of
the new Model Version definition or changes to the ESO's `EncryptedSavedObjectTypeRegistration`. Thus, ff an ESO's AAD has changed due to the migration, the previous
version will not be able to decrypt it. It is critical that when changes are made to an ESO, that they either do not affect its AAD or are staged carefully in
subsequent Model Versions.

It is worth noting here that if a ESO's Model Version `forwardCompatibility` schema is set to drop unknown fields (when the `unknowns` option is set to `ignore`),
ESOs of this type will first be decrypted before the unknown fields are dropped. This more easily supports the hierarchical aspect of AAD-included attributes - when
subfields of an attribute are added or removed, the previous version of Kibana will still be able to successfully construct AAD and decrypt the object.

The table below offers some general guidance on how various changes could be supported (or not). Keep in mind that any time you are adding or removing attributes from
an Saved Object type, all related business logic for that type must be capable of gracefully and appropriately handling an object with or without the attribute in both
the current and previous version of Kibana. Some of the advice here is applicable to any Saved Object type migration.

| Change to ESO                                | Encrypted? | In AAD? | General Guidance                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| -------------------------------------------- | ---------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Add a new attribute                          | No         | No      | Implement a Model Version as needed. There is no need to wrap the Model Version with `createModelVersion` because AAD is unaffected. Implement a `forwardCompatibility` schema and ignore unknowns if the previous version of Kibana will not be able to tolerate the additional attribute.                                                                                                                                                                                                                                                                                                                                                                                                                |
| Add a new attribute                          | No         | Yes     | This will require 2 Serverless release stages. `Release 1`: Add the attribute to the ESO's `attributesToIncludeInAAD`. Do not yet populate or use the new attribute. `Release 2`: Implement a Model Version and wrap it in a call to `createModelVersion`, providing the former `EncryptedSavedObjectTypeRegistration` as the input type, and the new `EncryptedSavedObjectTypeRegistration` as the output type. Implement a Model Version `backfill` change as needed. The attribute can safely be populated in this release.                                                                                                                                                                             |
| Add a new attribute                          | Yes        | N/A     | Implement a Model Version and wrap it in a call to `createModelVersion`. Implement Model Version changes as needed. Implement a `forwardCompatibility` schema and ignore unknowns if the previous version of Kibana will not be able to tolerate additions to the attribute.                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Add an existing attribute to AAD             | No         | No->Yes | This is not currently supported. Existing attributes that are in use and populated with data cannot be added to AAD. The previous version of Kibana will never be able to successfully perform decryption in this case.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Remove an existing attribute                 | No         | No      | Implement the Model Version as needed. There is no need to wrap the Model Version with `createModelVersion` because AAD is unaffected. If the previous version of will not be able to tolerate the missing attribute, this will require 2 Serverless release stages. `Release 1`: update all business logic to handle this type without the attribute that will be removed. `Release 2`: implement the Model Version as described.                                                                                                                                                                                                                                                                         |
| Remove an existing attribute                 | No         | Yes     | Implement a Model Version and wrap it in a call to `createModelVersion`, providing the former `EncryptedSavedObjectTypeRegistration` as the input type, and the new `EncryptedSavedObjectTypeRegistration` as the output type. The previous version of Kibana will be able to decrypt objects without this attribute, as attributes that are not present are never included when constructing AAD. If the previous version of Kibana will not be able to tolerate the missing attribute, this will require 2 Serverless release stages. `Release 1`: update all business logic to handle this type without the attribute that will be removed. `Release 2`: implement the Model Version as described.      |
| Remove an existing attribute                 | Yes        | N/A     | Implement a Model Version as needed. There is no need to wrap the Model Version with `createModelVersion` because AAD is unaffected. The previous version of Kibana will not throw an error if there is a missing encrypted attribute, but will add a debug-level log. If the previous version of will not be able to tolerate the missing attribute, this will require 2 Serverless release stages. `Release 1`: update all business logic to handle this type without the attribute that will be removed. `Release 2`: implement the Model Version as described.                                                                                                                                         |
| Modify an attribute (add or remove subfield) | No         | No      | Implement a Model Version as needed. There is no need to wrap the Model Version with `createModelVersion` because AAD is unaffected. If the previous version of will not be able to tolerate the changes, this will require 2 Serverless release stages. `Release 1`: update all business logic to handle this type with the modified attribute. `Release 2`: implement the Model Version as described.                                                                                                                                                                                                                                                                                                    |
| Modify an attribute (add or remove subfield) | No         | Yes     | Implement a Model Version and wrap it in a call to `createModelVersion`, providing the former `EncryptedSavedObjectTypeRegistration` as the input type, and the new `EncryptedSavedObjectTypeRegistration` as the output type. The previous version of Kibana will be able to decrypt objects with the changed attribute, as all subfields are inherent in the value of AAD-included attributes when constructing AAD. If the previous version of Kibana will not be able to tolerate the attribute changes, this will require 2 Serverless release stages. `Release 1`: update all business logic to handle this type with the modified attribute. `Release 2`: implement the Model Version as described. |
| Modify an attribute (add or remove subfield) | Yes        | N/A     | Implement a Model Version and wrap it in a call to `createModelVersion`. Implement Model Version changes as needed. Even though AAD is unaffected, the objects will require decryption and re-encryption to be modified. If the previous version of will not be able to tolerate the attribute changes, this will require 2 Serverless release stages. `Release 1`: update all business logic to handle this type with the modified attribute. `Release 2`: implement the Model Version as described.                                                                                                                                                                                                      |
| Change an existing attribute to be encrypted | No->Yes    | No/Yes  | This is not currently supported. The previous version of Kibana will not know to decrypt this attribute, and any business logic that utilizes the attribute will fail.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Remove an attribute from the encrypted list  | Yes->No    | No      | This is not currently supported. The previous version of Kibana will always attempt to decrypt the attribute.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |

## Making Changes

If you will be making changes to your ESOs, or creating new ESOs, the AppEx Platform Servives Security team is available for consultation and assistance. Please reach
out to us on Slack (#kibana-security) with any questions or queries.

We also ask that you please tag us (@elastic/kibana-security) for review on any PRs related to ESOs.