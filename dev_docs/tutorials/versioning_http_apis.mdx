---
id: kibDevTutorialVersioningHTTPAPIs
slug: /kibana-dev-docs/versioning-http-apis
title: Versioning HTTP APIs
description: We need to keep old versions of HTTP APIs available. This tutorial shows you how to prepare existing HTTP APIs for vesrioning and how they can be managed over time.
date: 2023-02-09
tags: ['kibana', 'onboarding', 'dev', 'architecture']
---

All Kibana HTTP API developers and maintainers must ensure that past versions of HTTP APIs remain available. This tutorial demonstrates how versions HTTP APIs can be managed and what properties must hold true.

<DocCallOut title="A note on internal vs public HTTP APIs">
  HTTP APIs may be intended for **internal** or **public** use. Different levels of rigour are appropriate when designing and managing changes for each. However, in both cases we must support some minimal set of past HTTP APIs.

  The exact number of past APIs and the length of time they are kept available will vary per use case, but we assume this will be much shorter for internal than for public endpoints where change management will have a far longer tail.
</DocCallOut>

Versioned HTTP APIs should hold to the following set of properties. How you meet these is properties is up to you. Use the examples provided as insipiration for your case.

### 1. Do not directly expose persistence schemas on your HTTP API endpoints

Consider this example of directly exposing a persisted schema over HTTP:

```ts
router.get(
  {
    path: '/api/myobject/{id}',
    validate: { params: schema.object({ id: schema.string() }) },
  },
  (ctx, req, res) => {
    const { savedObjects } = await ctx.core;
    const myObject = await savedObjects.client.get<MyObjectAttributes>('myObject', req.params.id)
    return res.ok({
      body: { ...myObject.attributes }, // <- Directly exposing SO attributes
    })
  }
);
```

#### Why is this problemetic for versioning?

Whenever we perform a data migration the body of this endpoint will change for all clients. This prevents us from being able to maintain past interfaces and gracefully introduce new ones.

#### There are several examples of persistence schemas:

* The shape of attributes in your Saved Object(s)
* The shape of the document source in an Elasticsearch index you manage, for example, a report
* The shape of the data whose storage you delegate to some other code
  * One example is the metadata stored on a `file` object exposed by the `src/plugins/files` plugin

Therefore a persistence schema is the _shape_ of any data your code directly, or indirectly _persists_. Think carefully about any persisted schemas your code might be using and ensure that none of them are exposed directly over your HTTP APIs.

#### Make endpoints versionable

Consider the following changes to the code above:

```ts
// We add a new interface for this HTTP APIs return value
// Note: this interface can live in your plugins top-level "common" directory
interface GetMyObjectResponse {
  foo: string;
  bar: number;
}
router.get(
  {
    path: '/api/myobject/{id}',
    validate: { params: schema.object({ id: schema.string() }) },
  },
  (ctx, req, res) => {
    const { savedObjects } = await ctx.core;
    const {
      attributes: { foo, bar },
    } = await savedObjects.client.get<MyObjectAttributes>('myObject', req.params.id)
    // Explicitly map to our HTTP body
    const body: GetMyObjectResponse = { foo, bar };
    return res.ok({ body });
  }
);
```

The biggest changes are:

1. We created a **new interface** to represent our HTTP API contract. **Note:** Even though we duplicated some of our `MyObjectAttributes` in `GetMyObjectResponse`, it removed the risk that a data migration will break our current HTTP contract without TypeScript noticing.
2. We replaced object spread with **cherry-picking values** from our persistence schema. We now have a **translation layer** between our persistence schema and HTTP API interface.


These changes might seem subtle, but they have big implications for whether your HTTP API is versionable.

_See "[Versioning interfaces](/kibana-dev-docs/versioning-interfaces)" for a more detailed strategy for managing multiple versions of TypeScript interfaces._

### 2. Strict input validation

### 3. Keep interfaces as "narrow" as possible

### 4. Use the versioned API spec