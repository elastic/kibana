---
id: kibDevTutorialSavedObjectsSearch
slug: /kibana-dev-docs/tutorials/saved-objects-search
title: Saved Object `search` method
description: Learn how to use the `search` method to search for Saved Objects.
date: 2025-10-28
tags: ['kibana', 'dev', 'tutorials', 'saved-objects', 'search']
---

`SavedObjectsClientContract.search` is a powerful way to search for Saved Objects. It allows you to search Saved Objects using the [Elasticsearch query DSL](https://www.elastic.co/docs/explore-analyze/query-filter/languages/querydsl), [ES|QL](https://www.elastic.co/docs/reference/query-languages/esql/esql-syntax-reference), [runtime fields](https://www.elastic.co/docs/manage-data/data-store/mapping/define-runtime-fields-in-search-request) and more.

It is an alternative to the safer but more limited `SavedObjectsClientContract.find` method.

## See it in code

Consider this request to search for and sort Saved Objects by fields that are the same type, but named differently:

```ts
import { isResponseError } from '@kbn/es-errors';
import { TYPE_A, TYPE_B } from './saved_objects';
  /** ...some lines down we have a route hanlder like this: */
  async (ctx, req, res) => {
    log.info('Searching for saved objects');
    const core = await ctx.core;
    const savedObjectsClient = core.savedObjects.client;
    try {
      const result /* returns raw hits from Elasticsearch */ = await savedObjectsClient.search({
        type: [TYPE_A, TYPE_B],
        namespaces: ['default'],
        query: {
          bool: {
            must: [
              {
                match_all: {},
              },
            ],
          },
        },
        // The below runtime mappings would not be possible with the `find` method
        runtime_mappings: {
          merged_date: {
            type: 'date',
            script: {
              source: `
                if (doc.containsKey('${TYPE_A}.myDateField') && !doc['${TYPE_A}.myDateField'].empty) {
                  emit(doc['${TYPE_A}.myDateField'].value.toInstant().toEpochMilli());
                } else if (doc.containsKey('${TYPE_B}.myOtherDateField') && !doc['${TYPE_B}.myOtherDateField'].empty) {
                  emit(doc['${TYPE_B}.myOtherDateField'].value.toInstant().toEpochMilli());
                }
              `,
            },
          },
        },
        sort: [
          {
            merged_date: {
              order: 'desc',
              unmapped_type: 'date', // In case one type doesn't have the date field
            },
          },
        ],
      });
      return res.ok({
        body: {
          result,
        },
      });
    } catch (e) {
      if (isResponseError(e)) {
        log.error(JSON.stringify(e.meta.body, null, 2)); // good error logging is essential for debugging...
      }
      throw e;
    }
  }
```

See the full example in the Kibana repository at `examples/saved_objects`.


## When to use the `search` method

- You are trying to search across multiple types of Saved Objects while sorting by a field that is not present in all types
- You are trying to aggregate over multiple Saved Objects

## When to not to use the`search` method

- You just want a simple way to filter your Saved Object type, use `SavedObjectsClientContract.find` instead

## Disclaimer

While the `search` method is powerful, it can increase code complexity and introduce performance issues. Carefully consider how you would like to use this method in your plugin to unlock value for users.