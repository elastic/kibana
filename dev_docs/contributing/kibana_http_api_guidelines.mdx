---
id: kibHttpApiGuidelines
slug: /kibana-dev-docs/contributing/http-api-guidelines
title: Guidelines for HTTP API design in Kibana
description: Best practices and guidelines for designing consistent, user-friendly HTTP APIs in Kibana
date: 2025-07-02
tags: ['kibana', 'contributor', 'dev', 'http', 'api', 'rest', 'design']
---

<DocCallOut title="Some APIs need to be Terraform-friendly">
  As an extension to the guidance in this document refer to the <DocLink id="kibHttpApiTfGuidelines" text="Guidelines for Terraform friendly HTTP APIs" /> if you would like to support an Infrastructure-as-Code (IaC) use case.
</DocCallOut>

[Click here](#structure-and-conventions) to skip to the structure and conventions guides.

## Design principles

### Consistency

Consistency is key to a great API-user experience. APIs should be consistent in their naming, structure, and behavior. Consistency may be domain-specific: it's always best to follow an established pattern. If no pattern exists, consider creating one paying close attention to:

1. **Consistent naming**: Use the same suffix for IDs (e.g., `space_id`, `dashboard_id`, etc.).
2. **Consistent structure**: Use the same structure for referencing resources in requests and responses in all related APIs.
3. **Consistent validation**: Apply the same validation rules across all APIs.
4. **Consistent error messages**: Use the same error messages for the same errors.

This principle is embodied in the rest of this document, so read on for examples!

### Make a great API-user experience

Create a great _API_ user experience, as opposed to optimizing a single API for _UI_ use cases as well. Front-ends have very different needs and constraints from public HTTP API clients. Our public HTTP APIs should be primitives that are simple to use and compose.

For example, a UI might want to optimise it's network requests by bundling multiple requests into a single request, but an API client would be better designed to de-optimise and simplify the requests:

A view or component in the UI might do the following for some, UI-specific purpose:
```
GET /some_related_resources_for_this_page?ids_only=true&page=1
# Which returns:
{
  "a_ids": ["1", "2"],
  "b_ids": ["2"]
}
```

While API clients are better designed as:
```
# Request 1
GET /resource_as?page=1
{
  "items": [{ id: "1", "name": "Resource A 1" }, { id: "2", "name": "Resource A 2" }],
  "page": 1,
  "total": 2
}
# Request 2
GET /resource_bs?page=1
{
  "items": [{ id: "1", "name": "Resource B 1" }],
  "page": 1,
  "total": 1
}
```

<DocCallOut title="Internal vs Public APIs">
  To further reinforce these different purposes Kibana HTTP APIs serve, we categorise them as either **internal** or **public**. See the [Internal vs Public APIs](#internal-vs-public-apis) section for more details.
</DocCallOut>

### Commitment

Public HTTP APIs are long-term commitments that we make to users. We must be committed to maintaining them and ensuring they continue to work as expected (for at least 18 months).

Use the means available: first release new public HTTP APIs as `Technical Preview` or `Beta` to derisk any aspects of the API design you are uncertain about.

Getting your HTTP APIs into a stable state is a process based on feedback from actual users.

#### Breaking changes to HTTP APIs include

 - Rename or delete an API
 - Rename or delete a path, query or body parameter
 - Modifying the type of a property (including expanding to a union type!)
 - Set an existing property as required
 - Add or delete a security requirement
 - In some cases, changing a default

<DocCallOut title="Do not break clients!">
  A public HTTP API should never cause a client to break. Not without a long (18 month) deprecation period and a ready alternative.

  Even `Technical Preview` and `Beta` HTTP APIs should consider graceful paths for changes when possible.

  Linus Torvalds famously said of Kernel development: "WE DO NOT BREAK USERSPACE!" (along with some other expletives). We should adopt this kind of rigor and empathy when working with our _public_ HTTP APIs and always proiritise finding ways to avoid breaking our APIs.
</DocCallOut>

## Internal vs Public APIs

Public HTTP APIs are those that are exposed to users and are used by plugins and external tools. They are the backbone of our public HTTP APIs and are the focus of this document.

Internal HTTP APIs are those that are used by Kibana's own code, like the UI. By default, when you register a new HTTP API it will be classified as `internal`. For example, this API is internal:

```typescript
router.get({ path: '/api/foos' ... }, async () => {...})
```

You can make an HTTP API public by changing the `access` setting to `public`:

```typescript
router.get({ path: '/api/foos', options: { access: 'public' } }, async () => {...})
```

Again, see the principle regarding [commitment](#commitment) before making APIs public!

## Structure and conventions

The following are a quick reference for how to structure your HTTP APIs.

### Path

**Use snake case**

`/api/my_api` ✅

`/api/my-api`, `/api/myApi` ❌

**For public APIs, prefix with `/api`**

`/api/my_api` ✅

`/my_api` ❌

**Pluralize collection names**

`PUT /api/resources/{id}` ✅

`PUT /api/resource/{id}` ❌

### Methods

**GET does not accept a body**

`GET /api/resources/{id}` ✅

`GET /api/resources/{id} { body: { params } }` ❌

**POST is for creating a resource**

Sometimes `POST` can be used for an action against a resource or for actions like `GET` but with a body.

**PUT or PATCH are for updating a resource**

`PATCH` is typically used for partial updates and should not result in something being created, while `PUT` might create a resource.

**DELETE is for deleting a resource**

Delete can return a simple response instead of the full resource:

```
DELETE /api/resources/{id}
# -> 200 { "ok": true }
```

**Stick to simple methods**

`GET`, `POST`, `PUT`, `PATCH`, `DELETE` should cover almost all cases. If you are considering `HEAD` or some other method make sure you have a good justification for your HTTP API.

### Path parameters

**Should use snake case**

`/api/my_api/{my_id}` ✅

`/api/my_api/{myId}` ❌

**BEWARE: path parameters should not expect values of unknown length**

Accepting very long strings in path parameters can cause issues for HTTP servers that limit the byte length of certain parts of requests.

Use a body parameter for long strings instead and consider using validation to limit a path param's length.

### Query parameters

**Should use snake case**

`/api/my_api?snake_case=true` ✅

`/api/my_api?snakeCase=false` ❌

**BEWARE: query parameters should not expect values of unknown length**

Accepting very long strings in query parameters can cause issues for HTTP servers that limit the byte length of certain parts of requests.

Use a body parameter for long strings instead and consider using validation to limit a query param's length.

### Bodies

**Should contain camelCase keys**

While this diverges from the path, in JavaScript the convention to use `camelCase`
in our request and response bodies provides a better developer experience while
maintaining a solid API user experience.

**Use JSON**

Both requests and responses should be `application/json`, unless there is a good justification to use a different media type like when you're serving a file to a client.

**Resource shapes should be consistent**

`GET`, `PUT`, `POST` should return the same shape of data for the same resource.

`GET /api/my_resources/{id}` <br />
=> <br />
`{ "id": "1", "name": "My resource" }`<br /><br />

`POST /api/my_resources/{id} { "id": "1", "name": "My resource" }`<br />
=> <br />
`{ "id": "1", "name": "My resource" }`<br /><br />

`GET /api/my_resources` <br />
=> <br />
`{ items: [{ "id": "1", "name": "My resource" }], page: 1, size: 10, total: 100 }`

### Defaults

**Should be used to promote ease of use**

Carefully choose which values may be set as a sane default. If you are unsure rather ask the API caller to make an informed decision, see the [documentation section](#documentation).

**Should not be changed lightly**

Changing the value of a default may, in some cases, have a devastating result similar to a breaking change.

### Validation

**Runtime validation should be as narrow as feasible**

`schema.object({ id: schema.string({ minLength: 32, maxLength: 32 }) })` ✅

`schema.object({ id: schema.string() })` ❌

**It is easier to relax requirements than tighten them**

If you are in doubt, rather go with stricter validation. Make a requirement more lax if needed is never a breaking change!

### Headers

**Should not be used to specify behaviour**

Outside of exceptional cases, you should always use the parameters, query parameters or body of the request to specify behaviour.

### Response codes

**Should always be used as close as possible to their semantic meaning**

See the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status).

### Pagination

**Request**

`GET /api/resources?page=1&size=10`

**Response**

```json
{
  "items": [...],
  "total": 100,
  "page": 1,
  "size": 10
}
```

### Errors

```
4xx or 5xx status code
{
  code?: "A machine-friendly code for interpreting this error",
  ok: false,
  message: "A human-friendly explanation about what went wrong and how to fix it"
}
```

### Special data formats

**Dates**
Use [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) in UTC. This is the default representation in Node.js.

**Durations**
Can be specified in the [Elasticsearch date math](https://www.elastic.co/docs/reference/elasticsearch/rest-apis/common-options#date-math) format, for ex. `1m` for 1 minute if you want your duration to be relative to `now` where the full expression would be `now-1m`.

Alternatively, use 2 numbers in milliseconds or [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date strings.

## Documentation

**Public HTTP APIs must have reference documentation**

See our current reference documentation (here)[https://www.elastic.co/docs/api/doc/kibana/]. This is compiled from our OpenAPI spec. See <DocLink id="kibDevTutorialGeneratingOASForHTTPAPIs" text="this tutorial" /> about the code-first approach to generating OpenAPI spec available in Kibana.

## Versioning

Kibana's public HTTP APIs are versioned with the entire Elastic organization using data-based versioning. The date indicates the last breaking change. For example: version `2023-10-31` is saying "the last breaking change was at the end of October 2023".

<DocCallOut title="New public date versions will be very sparse" color="warning">
  Do not build your public HTTP APIs with the idea you will be able to change them quickly using versions! Due to the MASSIVE surface area, new date string versions are not introduced lightly and must go through rigorous review and justification.
</DocCallOut>

<DocCallOut title="What about Kibana public APIs that are not explicitly versioned?">
  You may see some routes using `router.get` instead of `router.versioned.get`. Routes registered in the former fashion are assumed to be part of the oldest, `2023-10-31` API surface area and will be included as-is in future version surface areas as well, unless they are explicitly versioned. This is to prevent the need for a wide-spread refactor.
</DocCallOut>

Kibana's internal HTTP APIs can be versioned too, but for a very different purpose! With serverless, we continually roll out code changes _without_ asking browsers to refresh. That means, for a time, browser clients might expect old internal API behavior. It is up to route authors and UI developers to consider how to handle breaking changes of internal routes. Note: you are free to version internal APIs at will to mitigate any unfortunate browser client breakages!

Please see the tutorial on <DocLink id="kibDevTutorialVersioningHTTPAPIs" text="versioning HTTP APIs" /> for more details.