/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import { makeApi, Zodios, type ZodiosOptions } from '@zodios/core';
import { z } from '@kbn/zod';

const bedrock_config = z
  .object({
    apiUrl: z.string(),
    defaultModel: z.string().optional().default('us.anthropic.claude-3-7-sonnet-20250219-v1:0'),
  })
  .passthrough();
const crowdstrike_config = z.object({ url: z.string() }).passthrough();
const d3security_config = z.object({ url: z.string() }).passthrough();
const email_config = z
  .object({
    clientId: z.string().nullish(),
    from: z.string(),
    hasAuth: z.boolean().optional().default(true),
    host: z.string().optional(),
    oauthTokenUrl: z.string().nullish(),
    port: z.number().int().optional(),
    secure: z.boolean().optional(),
    service: z
      .enum(['elastic_cloud', 'exchange_server', 'gmail', 'other', 'outlook365', 'ses'])
      .optional(),
    tenantId: z.string().nullish(),
  })
  .passthrough();
const gemini_config = z
  .object({
    apiUrl: z.string(),
    defaultModel: z.string().optional().default('gemini-2.5-pro'),
    gcpRegion: z.string(),
    gcpProjectID: z.string(),
  })
  .passthrough();
const resilient_config = z.object({ apiUrl: z.string(), orgId: z.string() }).passthrough();
const index_config = z
  .object({
    executionTimeField: z.string().nullish().default(null),
    index: z.string(),
    refresh: z.boolean().optional().default(false),
  })
  .passthrough();
const jira_config = z.object({ apiUrl: z.string(), projectKey: z.string() }).passthrough();
const genai_azure_config = z
  .object({ apiProvider: z.literal('Azure OpenAI'), apiUrl: z.string() })
  .passthrough();
const genai_openai_config = z
  .object({
    apiProvider: z.literal('OpenAI'),
    apiUrl: z.string(),
    defaultModel: z.string().optional(),
  })
  .passthrough();
const genai_openai_other_config = z
  .object({
    apiProvider: z.literal('Other'),
    apiUrl: z.string(),
    defaultModel: z.string(),
    certificateData: z.string().min(1).optional(),
    privateKeyData: z.string().min(1).optional(),
    caData: z.string().min(1).optional(),
    verificationMode: z.enum(['full', 'certificate', 'none']).optional().default('full'),
    headers: z.record(z.string()).optional(),
  })
  .passthrough();
const opsgenie_config = z.object({ apiUrl: z.string() }).passthrough();
const pagerduty_config = z.object({ apiUrl: z.string().nullable() }).partial().passthrough();
const sentinelone_config = z.object({ url: z.string() }).passthrough();
const servicenow_config = z
  .object({
    apiUrl: z.string(),
    clientId: z.string().optional(),
    isOAuth: z.boolean().optional().default(false),
    jwtKeyId: z.string().optional(),
    userIdentifierValue: z.string().optional(),
    usesTableApi: z.boolean().optional().default(true),
  })
  .passthrough();
const servicenow_itom_config = z
  .object({
    apiUrl: z.string(),
    clientId: z.string().optional(),
    isOAuth: z.boolean().optional().default(false),
    jwtKeyId: z.string().optional(),
    userIdentifierValue: z.string().optional(),
  })
  .passthrough();
const slack_api_config = z
  .object({
    allowedChannels: z.array(
      z.object({ id: z.string().min(1), name: z.string().min(1) }).passthrough()
    ),
  })
  .partial()
  .passthrough();
const swimlane_config = z
  .object({
    apiUrl: z.string(),
    appId: z.string(),
    connectorType: z.enum(['all', 'alerts', 'cases']),
    mappings: z
      .object({
        alertIdConfig: z
          .object({ fieldType: z.string(), id: z.string(), key: z.string(), name: z.string() })
          .passthrough(),
        caseIdConfig: z
          .object({ fieldType: z.string(), id: z.string(), key: z.string(), name: z.string() })
          .passthrough(),
        caseNameConfig: z
          .object({ fieldType: z.string(), id: z.string(), key: z.string(), name: z.string() })
          .passthrough(),
        commentsConfig: z
          .object({ fieldType: z.string(), id: z.string(), key: z.string(), name: z.string() })
          .passthrough(),
        descriptionConfig: z
          .object({ fieldType: z.string(), id: z.string(), key: z.string(), name: z.string() })
          .passthrough(),
        ruleNameConfig: z
          .object({ fieldType: z.string(), id: z.string(), key: z.string(), name: z.string() })
          .passthrough(),
        severityConfig: z
          .object({ fieldType: z.string(), id: z.string(), key: z.string(), name: z.string() })
          .passthrough(),
      })
      .partial()
      .passthrough()
      .optional(),
  })
  .passthrough();
const thehive_config = z
  .object({ organisation: z.string().optional(), url: z.string() })
  .passthrough();
const tines_config = z.object({ url: z.string() }).passthrough();
const torq_config = z.object({ webhookIntegrationUrl: z.string() }).passthrough();
const auth_type = z.enum(['webhook-authentication-basic', 'webhook-authentication-ssl']);
const ca = z.string();
const cert_type = z.enum(['ssl-crt-key', 'ssl-pfx']);
const has_auth = z.boolean();
const verification_mode = z.enum(['certificate', 'full', 'none']);
const webhook_config = z
  .object({
    authType: auth_type.nullable(),
    ca,
    certType: cert_type,
    hasAuth: has_auth.default(true),
    headers: z.object({}).partial().passthrough().nullable(),
    method: z.enum(['post', 'put']).default('post'),
    url: z.string(),
    verificationMode: verification_mode.default('full'),
  })
  .partial()
  .passthrough();
const cases_webhook_config = z
  .object({
    authType: auth_type.nullish(),
    ca: ca.optional(),
    certType: cert_type.optional(),
    createCommentJson: z.string().optional(),
    createCommentMethod: z.enum(['patch', 'post', 'put']).optional().default('put'),
    createCommentUrl: z.string().optional(),
    createIncidentJson: z.string(),
    createIncidentMethod: z.enum(['patch', 'post', 'put']).optional().default('post'),
    createIncidentResponseKey: z.string(),
    createIncidentUrl: z.string(),
    getIncidentResponseExternalTitleKey: z.string(),
    getIncidentUrl: z.string(),
    hasAuth: has_auth.optional().default(true),
    headers: z.string().optional(),
    updateIncidentJson: z.string(),
    updateIncidentMethod: z.enum(['patch', 'post', 'put']).optional().default('put'),
    updateIncidentUrl: z.string(),
    verificationMode: verification_mode.optional().default('full'),
    viewIncidentUrl: z.string(),
  })
  .passthrough();
const xmatters_config = z
  .object({ configUrl: z.string().nullable(), usesBasic: z.boolean().default(true) })
  .partial()
  .passthrough();
const bedrock_secrets = z.object({ accessKey: z.string(), secret: z.string() }).passthrough();
const crowdstrike_secrets = z
  .object({ clientId: z.string(), clientSecret: z.string() })
  .passthrough();
const d3security_secrets = z.object({ token: z.string() }).passthrough();
const email_secrets = z
  .object({ clientSecret: z.string(), password: z.string(), user: z.string() })
  .partial()
  .passthrough();
const gemini_secrets = z.object({ credentialsJson: z.string() }).passthrough();
const resilient_secrets = z
  .object({ apiKeyId: z.string(), apiKeySecret: z.string() })
  .passthrough();
const jira_secrets = z.object({ apiToken: z.string(), email: z.string() }).passthrough();
const defender_secrets = z.object({ clientSecret: z.string() }).passthrough();
const teams_secrets = z.object({ webhookUrl: z.string() }).passthrough();
const genai_secrets = z
  .object({
    apiKey: z.string(),
    certificateData: z.string().min(1),
    privateKeyData: z.string().min(1),
    caData: z.string().min(1),
  })
  .partial()
  .passthrough();
const opsgenie_secrets = z.object({ apiKey: z.string() }).passthrough();
const pagerduty_secrets = z.object({ routingKey: z.string() }).passthrough();
const sentinelone_secrets = z.object({ token: z.string() }).passthrough();
const servicenow_secrets = z
  .object({
    clientSecret: z.string(),
    password: z.string(),
    privateKey: z.string(),
    privateKeyPassword: z.string(),
    username: z.string(),
  })
  .partial()
  .passthrough();
const slack_api_secrets = z.object({ token: z.string() }).passthrough();
const swimlane_secrets = z.object({ apiToken: z.string() }).partial().passthrough();
const thehive_secrets = z.object({ apiKey: z.string() }).passthrough();
const tines_secrets = z.object({ email: z.string(), token: z.string() }).passthrough();
const torq_secrets = z.object({ token: z.string() }).passthrough();
const crt = z.string();
const key = z.string();
const pfx = z.string();
const webhook_secrets = z
  .object({ crt, key, pfx, password: z.string(), user: z.string() })
  .partial()
  .passthrough();
const cases_webhook_secrets = z
  .object({ crt, key, pfx, password: z.string(), user: z.string() })
  .partial()
  .passthrough();
const xmatters_secrets = z
  .object({ password: z.string(), secretsUrl: z.string(), user: z.string() })
  .partial()
  .passthrough();
const post_actions_connector_id_Body = z.object({
  connector_type_id: z.string(),
  name: z.string(),
  config: z
    .union([
      bedrock_config,
      crowdstrike_config,
      d3security_config,
      email_config,
      gemini_config,
      resilient_config,
      index_config,
      jira_config,
      genai_azure_config,
      genai_openai_config,
      genai_openai_other_config,
      opsgenie_config,
      pagerduty_config,
      sentinelone_config,
      servicenow_config,
      servicenow_itom_config,
      slack_api_config,
      swimlane_config,
      thehive_config,
      tines_config,
      torq_config,
      webhook_config,
      cases_webhook_config,
      xmatters_config,
    ])
    .optional()
    .default({}),
  secrets: z
    .union([
      bedrock_secrets,
      crowdstrike_secrets,
      d3security_secrets,
      email_secrets,
      gemini_secrets,
      resilient_secrets,
      jira_secrets,
      defender_secrets,
      teams_secrets,
      genai_secrets,
      opsgenie_secrets,
      pagerduty_secrets,
      sentinelone_secrets,
      servicenow_secrets,
      slack_api_secrets,
      swimlane_secrets,
      thehive_secrets,
      tines_secrets,
      torq_secrets,
      webhook_secrets,
      cases_webhook_secrets,
      xmatters_secrets,
    ])
    .optional()
    .default({}),
});
const defender_config = z
  .object({
    apiUrl: z.string(),
    clientId: z.string().optional(),
    oAuthScope: z.string().optional(),
    oAuthServerUrl: z.string().optional(),
    tenantId: z.string().optional(),
  })
  .passthrough();
const put_actions_connector_id_Body = z.object({
  name: z.string(),
  config: z
    .union([
      bedrock_config,
      crowdstrike_config,
      d3security_config,
      email_config,
      gemini_config,
      resilient_config,
      index_config,
      jira_config,
      defender_config,
      genai_azure_config,
      genai_openai_config,
      opsgenie_config,
      pagerduty_config,
      sentinelone_config,
      servicenow_config,
      servicenow_itom_config,
      slack_api_config,
      swimlane_config,
      thehive_config,
      tines_config,
      torq_config,
      webhook_config,
      cases_webhook_config,
      xmatters_config,
    ])
    .optional()
    .default({}),
  secrets: z
    .union([
      bedrock_secrets,
      crowdstrike_secrets,
      d3security_secrets,
      email_secrets,
      gemini_secrets,
      resilient_secrets,
      jira_secrets,
      teams_secrets,
      genai_secrets,
      opsgenie_secrets,
      pagerduty_secrets,
      sentinelone_secrets,
      servicenow_secrets,
      slack_api_secrets,
      swimlane_secrets,
      thehive_secrets,
      tines_secrets,
      torq_secrets,
      webhook_secrets,
      cases_webhook_secrets,
      xmatters_secrets,
    ])
    .optional()
    .default({}),
});
const run_acknowledge_resolve_pagerduty = z
  .object({ dedupKey: z.string().max(255), eventAction: z.enum(['acknowledge', 'resolve']) })
  .passthrough();
const run_documents = z
  .object({ documents: z.array(z.object({}).partial().passthrough()) })
  .passthrough();
const run_message_email = z
  .object({
    bcc: z.array(z.string()).optional(),
    cc: z.array(z.string()).optional(),
    message: z.string(),
    subject: z.string(),
    to: z.array(z.string()).optional(),
  })
  .passthrough();
const run_message_serverlog = z
  .object({
    level: z.enum(['debug', 'error', 'fatal', 'info', 'trace', 'warn']).optional().default('info'),
    message: z.string(),
  })
  .passthrough();
const run_message_slack = z.object({ message: z.string() }).passthrough();
const run_trigger_pagerduty = z
  .object({
    class: z.string().optional(),
    component: z.string().optional(),
    customDetails: z.object({}).partial().passthrough().optional(),
    dedupKey: z.string().max(255).optional(),
    eventAction: z.literal('trigger'),
    group: z.string().optional(),
    links: z
      .array(z.object({ href: z.string(), text: z.string() }).partial().passthrough())
      .optional(),
    severity: z.enum(['critical', 'error', 'info', 'warning']).optional().default('info'),
    source: z.string().optional(),
    summary: z.string().max(1024).optional(),
    timestamp: z.string().datetime({ offset: true }).optional(),
  })
  .passthrough();
const run_addevent = z
  .object({
    subAction: z.literal('addEvent'),
    subActionParams: z
      .object({
        additional_info: z.string(),
        description: z.string(),
        event_class: z.string(),
        message_key: z.string(),
        metric_name: z.string(),
        node: z.string(),
        resource: z.string(),
        severity: z.string(),
        source: z.string(),
        time_of_event: z.string(),
        type: z.string(),
      })
      .partial()
      .passthrough()
      .optional(),
  })
  .passthrough();
const run_closealert = z
  .object({
    subAction: z.literal('closeAlert'),
    subActionParams: z
      .object({
        alias: z.string(),
        note: z.string().optional(),
        source: z.string().optional(),
        user: z.string().optional(),
      })
      .passthrough(),
  })
  .passthrough();
const run_closeincident = z
  .object({
    subAction: z.literal('closeIncident'),
    subActionParams: z.object({ incident: z.union([z.unknown(), z.unknown()]) }).passthrough(),
  })
  .passthrough();
const run_createalert = z
  .object({
    subAction: z.literal('createAlert'),
    subActionParams: z
      .object({
        actions: z.array(z.string()),
        alias: z.string(),
        description: z.string(),
        details: z.object({}).partial().passthrough(),
        entity: z.string(),
        message: z.string(),
        note: z.string(),
        priority: z.enum(['P1', 'P2', 'P3', 'P4', 'P5']),
        responders: z.array(
          z
            .object({
              id: z.string(),
              name: z.string(),
              type: z.enum(['escalation', 'schedule', 'team', 'user']),
              username: z.string(),
            })
            .partial()
            .passthrough()
        ),
        severity: z.number().int().gte(1).lte(4),
        source: z.string(),
        sourceRef: z.string(),
        tags: z.array(z.string()),
        title: z.string(),
        tlp: z.number().int().gte(0).lte(4).default(2),
        type: z.string(),
        user: z.string(),
        visibleTo: z.array(
          z
            .object({
              id: z.string().optional(),
              name: z.string().optional(),
              type: z.enum(['team', 'user']),
              username: z.string().optional(),
            })
            .passthrough()
        ),
      })
      .partial()
      .passthrough(),
  })
  .passthrough();
const run_fieldsbyissuetype = z
  .object({
    subAction: z.literal('fieldsByIssueType'),
    subActionParams: z.object({ id: z.string() }).passthrough(),
  })
  .passthrough();
const run_getagentdetails = z
  .object({
    subAction: z.literal('getAgentDetails'),
    subActionParams: z.object({ ids: z.array(z.string()) }).passthrough(),
  })
  .passthrough();
const run_getagents = z.object({ subAction: z.literal('getAgents') }).passthrough();
const run_getchoices = z
  .object({
    subAction: z.literal('getChoices'),
    subActionParams: z.object({ fields: z.array(z.string()) }).passthrough(),
  })
  .passthrough();
const run_getfields = z.object({ subAction: z.literal('getFields') }).passthrough();
const run_getincident = z
  .object({
    subAction: z.literal('getIncident'),
    subActionParams: z.object({ externalId: z.string() }).passthrough(),
  })
  .passthrough();
const run_issue = z
  .object({
    subAction: z.literal('issue'),
    subActionParams: z.object({ id: z.string() }).passthrough().optional(),
  })
  .passthrough();
const run_issues = z
  .object({
    subAction: z.literal('issues'),
    subActionParams: z.object({ title: z.string() }).passthrough(),
  })
  .passthrough();
const run_issuetypes = z.object({ subAction: z.literal('issueTypes') }).passthrough();
const run_postmessage = z
  .object({
    subAction: z.literal('postMessage'),
    subActionParams: z
      .object({
        channelIds: z.array(z.string()).max(1),
        channels: z.array(z.string()).max(1),
        text: z.string().min(1),
      })
      .partial()
      .passthrough(),
  })
  .passthrough();
const run_pushtoservice = z
  .object({
    subAction: z.literal('pushToService'),
    subActionParams: z
      .object({
        comments: z.array(
          z.object({ comment: z.string(), commentId: z.number().int() }).partial().passthrough()
        ),
        incident: z
          .object({
            additional_fields: z.string().max(20).nullable(),
            alertId: z.string(),
            caseId: z.string(),
            caseName: z.string(),
            category: z.string(),
            correlation_display: z.string(),
            correlation_id: z.string(),
            description: z.string(),
            dest_ip: z.union([z.string(), z.array(z.string())]),
            externalId: z.string(),
            id: z.string(),
            impact: z.string(),
            issueType: z.number().int(),
            labels: z.array(z.string()),
            malware_hash: z.union([z.string(), z.array(z.string())]),
            malware_url: z.union([z.string(), z.array(z.string())]),
            otherFields: z.object({}).partial().passthrough(),
            parent: z.string(),
            priority: z.string(),
            ruleName: z.string(),
            severity: z.number().int(),
            short_description: z.string(),
            source_ip: z.union([z.string(), z.array(z.string())]),
            status: z.string(),
            subcategory: z.string(),
            summary: z.string(),
            tags: z.array(z.string()),
            title: z.string(),
            tlp: z.number().int().gte(0).lte(4).default(2),
            urgency: z.string(),
          })
          .partial()
          .passthrough(),
      })
      .partial()
      .passthrough(),
  })
  .passthrough();
const run_validchannelid = z
  .object({
    subAction: z.literal('validChannelId'),
    subActionParams: z.object({ channelId: z.string() }).passthrough(),
  })
  .passthrough();
const post_actions_connector_id_execute_Body = z.object({
  params: z.union([
    run_acknowledge_resolve_pagerduty,
    run_documents,
    run_message_email,
    run_message_serverlog,
    run_message_slack,
    run_trigger_pagerduty,
    run_addevent,
    run_closealert,
    run_closeincident,
    run_createalert,
    run_fieldsbyissuetype,
    run_getagentdetails,
    run_getagents,
    run_getchoices,
    run_getfields,
    run_getincident,
    run_issue,
    run_issues,
    run_issuetypes,
    run_postmessage,
    run_pushtoservice,
    run_validchannelid,
  ]),
});
const Alerting_401_response = z
  .object({ error: z.literal('Unauthorized'), message: z.string(), statusCode: z.literal(401) })
  .partial()
  .passthrough();
const Alerting_fieldmap_properties = z
  .object({
    array: z.boolean(),
    dynamic: z.boolean(),
    format: z.string(),
    ignore_above: z.number().int(),
    index: z.boolean(),
    path: z.string(),
    properties: z.record(z.object({ type: z.string() }).partial().passthrough()),
    required: z.boolean(),
    scaling_factor: z.number().int(),
    type: z.string(),
  })
  .partial()
  .passthrough();
const params_property_apm_anomaly = z
  .object({
    serviceName: z.string().optional(),
    transactionType: z.string().optional(),
    windowSize: z.number(),
    windowUnit: z.enum(['m', 'h', 'd']),
    environment: z.string(),
    anomalySeverityType: z.enum(['critical', 'major', 'minor', 'warning']),
  })
  .passthrough();
const params_property_apm_error_count = z
  .object({
    serviceName: z.string().optional(),
    windowSize: z.number(),
    windowUnit: z.enum(['m', 'h', 'd']),
    environment: z.string(),
    threshold: z.number(),
    groupBy: z
      .array(
        z.enum(['service.name', 'service.environment', 'transaction.name', 'error.grouping_key'])
      )
      .optional()
      .default(['service.name', 'service.environment']),
    errorGroupingKey: z.string().optional(),
  })
  .passthrough();
const params_property_apm_transaction_duration = z
  .object({
    serviceName: z.string().optional(),
    transactionType: z.string().optional(),
    transactionName: z.string().optional(),
    windowSize: z.number(),
    windowUnit: z.enum(['m', 'h', 'd']),
    environment: z.string(),
    threshold: z.number(),
    groupBy: z
      .array(
        z.enum(['service.name', 'service.environment', 'transaction.type', 'transaction.name'])
      )
      .optional()
      .default(['service.name', 'service.environment', 'transaction.type']),
    aggregationType: z.enum(['avg', '95th', '99th']),
  })
  .passthrough();
const params_property_apm_transaction_error_rate = z
  .object({
    serviceName: z.string().optional(),
    transactionType: z.string().optional(),
    transactionName: z.string().optional(),
    windowSize: z.number(),
    windowUnit: z.enum(['m', 'h', 'd']),
    environment: z.string(),
    threshold: z.number(),
    groupBy: z
      .array(
        z.enum(['service.name', 'service.environment', 'transaction.type', 'transaction.name'])
      )
      .optional()
      .default(['service.name', 'service.environment', 'transaction.type']),
  })
  .passthrough();
const aggfield = z.string();
const aggtype = z.enum(['avg', 'count', 'max', 'min', 'sum']);
const excludehitsfrompreviousrun = z.boolean();
const groupby = z.enum(['all', 'top']);
const size = z.number();
const termfield = z.union([z.string(), z.array(z.string())]);
const termsize = z.number();
const threshold = z.array(z.number().int());
const thresholdcomparator = z.enum(['>', '>=', '<', '<=', 'between', 'notBetween']);
const timefield = z.string();
const timewindowsize = z.number();
const timewindowunit = z.enum(['s', 'm', 'h', 'd']);
const params_es_query_dsl_rule = z
  .object({
    aggField: aggfield.optional(),
    aggType: aggtype.optional().default('count'),
    esQuery: z.string(),
    excludeHitsFromPreviousRun: excludehitsfrompreviousrun.optional(),
    groupBy: groupby.optional().default('all'),
    index: z.union([z.array(z.string()), z.string()]),
    searchType: z.literal('esQuery').optional().default('esQuery'),
    size: size.int().optional(),
    termField: termfield.optional(),
    termSize: termsize.int().optional(),
    threshold,
    thresholdComparator: thresholdcomparator,
    timeField: timefield,
    timeWindowSize: timewindowsize.int(),
    timeWindowUnit: timewindowunit,
  })
  .passthrough();
const params_es_query_esql_rule = z
  .object({
    aggField: aggfield.optional(),
    aggType: aggtype.optional().default('count'),
    esqlQuery: z.object({ esql: z.string() }).passthrough(),
    excludeHitsFromPreviousRun: excludehitsfrompreviousrun.optional(),
    groupBy: groupby.optional().default('all'),
    searchType: z.literal('esqlQuery'),
    size: z.number().int(),
    termSize: termsize.int().optional(),
    threshold: z.array(z.number().int().gte(0).lte(0)),
    thresholdComparator: z.literal('>'),
    timeField: timefield.optional(),
    timeWindowSize: timewindowsize.int(),
    timeWindowUnit: timewindowunit,
  })
  .passthrough();
const filter = z
  .object({
    meta: z
      .object({
        alias: z.string().nullable(),
        controlledBy: z.string(),
        disabled: z.boolean(),
        field: z.string(),
        group: z.string(),
        index: z.string(),
        isMultiIndex: z.boolean(),
        key: z.string(),
        negate: z.boolean(),
        params: z.object({}).partial().passthrough(),
        type: z.string(),
        value: z.string(),
      })
      .partial()
      .passthrough(),
    query: z.object({}).partial().passthrough(),
    $state: z.object({}).partial().passthrough(),
  })
  .partial()
  .passthrough();
const params_es_query_kql_rule = z
  .object({
    aggField: aggfield.optional(),
    aggType: aggtype.optional().default('count'),
    excludeHitsFromPreviousRun: excludehitsfrompreviousrun.optional(),
    groupBy: groupby.optional().default('all'),
    searchConfiguration: z
      .object({
        filter: z.array(filter),
        index: z.union([z.string(), z.array(z.string())]),
        query: z.object({ language: z.string(), query: z.string() }).partial().passthrough(),
      })
      .partial()
      .passthrough()
      .optional(),
    searchType: z.literal('searchSource'),
    size: size.int(),
    termField: termfield.optional(),
    termSize: termsize.int().optional(),
    threshold,
    thresholdComparator: thresholdcomparator,
    timeField: timefield.optional(),
    timeWindowSize: timewindowsize.int(),
    timeWindowUnit: timewindowunit,
  })
  .passthrough();
const params_index_threshold_rule = z
  .object({
    aggField: aggfield.optional(),
    aggType: aggtype.optional().default('count'),
    filterKuery: z.string().optional(),
    groupBy: groupby.optional().default('all'),
    index: z.array(z.string()),
    termField: termfield.optional(),
    termSize: termsize.int().optional(),
    threshold,
    thresholdComparator: thresholdcomparator,
    timeField: timefield,
    timeWindowSize: timewindowsize.int(),
    timeWindowUnit: timewindowunit,
  })
  .passthrough();
const params_property_infra_inventory = z
  .object({
    criteria: z.array(
      z
        .object({
          metric: z.enum([
            'count',
            'cpu',
            'diskLatency',
            'load',
            'memory',
            'memoryTotal',
            'tx',
            'rx',
            'logRate',
            'diskIOReadBytes',
            'diskIOWriteBytes',
            's3TotalRequests',
            's3NumberOfObjects',
            's3BucketSize',
            's3DownloadBytes',
            's3UploadBytes',
            'rdsConnections',
            'rdsQueriesExecuted',
            'rdsActiveTransactions',
            'rdsLatency',
            'sqsMessagesVisible',
            'sqsMessagesDelayed',
            'sqsMessagesSent',
            'sqsMessagesEmpty',
            'sqsOldestMessage',
            'custom',
          ]),
          timeSize: z.number(),
          timeUnit: z.enum(['s', 'm', 'h', 'd']),
          sourceId: z.string(),
          threshold: z.array(z.number()),
          comparator: z.enum(['<', '<=', '>', '>=', 'between', 'outside']),
          customMetric: z
            .object({
              type: z.literal('custom'),
              field: z.string(),
              aggregation: z.enum(['avg', 'max', 'min', 'rate']),
              id: z.string(),
              label: z.string(),
            })
            .partial()
            .passthrough(),
          warningThreshold: z.array(z.number()),
          warningComparator: z.enum(['<', '<=', '>', '>=', 'between', 'outside']),
        })
        .partial()
        .passthrough()
    ),
    filterQuery: z.string(),
    filterQueryText: z.string(),
    nodeType: z.enum(['host', 'pod', 'container', 'awsEC2', 'awsS3', 'awsSQS', 'awsRDS']),
    sourceId: z.string(),
    alertOnNoData: z.boolean(),
  })
  .partial()
  .passthrough();
const params_property_log_threshold = z.union([
  z
    .object({
      criteria: z
        .array(
          z
            .object({
              field: z.string(),
              comparator: z.enum([
                'more than',
                'more than or equals',
                'less than',
                'less than or equals',
                'equals',
                'does not equal',
                'matches',
                'does not match',
                'matches phrase',
                'does not match phrase',
              ]),
              value: z.union([z.number(), z.string()]),
            })
            .partial()
            .passthrough()
        )
        .optional(),
      count: z
        .object({
          comparator: z.enum([
            'more than',
            'more than or equals',
            'less than',
            'less than or equals',
            'equals',
            'does not equal',
            'matches',
            'does not match',
            'matches phrase',
            'does not match phrase',
          ]),
          value: z.number(),
        })
        .partial()
        .passthrough(),
      timeSize: z.number(),
      timeUnit: z.enum(['s', 'm', 'h', 'd']),
      logView: z
        .object({ logViewId: z.string(), type: z.literal('log-view-reference') })
        .partial()
        .passthrough(),
      groupBy: z.array(z.string()).optional(),
    })
    .passthrough(),
  z
    .object({
      criteria: z
        .array(
          z
            .array(
              z
                .object({
                  field: z.string(),
                  comparator: z.enum([
                    'more than',
                    'more than or equals',
                    'less than',
                    'less than or equals',
                    'equals',
                    'does not equal',
                    'matches',
                    'does not match',
                    'matches phrase',
                    'does not match phrase',
                  ]),
                  value: z.union([z.number(), z.string()]),
                })
                .partial()
                .passthrough()
            )
            .min(2)
            .max(2)
        )
        .optional(),
      count: z
        .object({
          comparator: z.enum([
            'more than',
            'more than or equals',
            'less than',
            'less than or equals',
            'equals',
            'does not equal',
            'matches',
            'does not match',
            'matches phrase',
            'does not match phrase',
          ]),
          value: z.number(),
        })
        .partial()
        .passthrough(),
      timeSize: z.number(),
      timeUnit: z.enum(['s', 'm', 'h', 'd']),
      logView: z
        .object({ logViewId: z.string(), type: z.literal('log-view-reference') })
        .partial()
        .passthrough(),
      groupBy: z.array(z.string()).optional(),
    })
    .passthrough(),
]);
const params_property_infra_metric_threshold = z
  .object({
    criteria: z.array(
      z.union([
        z
          .object({
            threshold: z.array(z.number()),
            comparator: z.enum(['<', '<=', '>', '>=', 'between', 'outside']),
            timeUnit: z.enum(['s', 'm', 'h', 'd']),
            timeSize: z.number(),
            warningThreshold: z.array(z.number()),
            warningComparator: z.enum(['<', '<=', '>', '>=', 'between', 'outside']),
            metric: z.string(),
            aggType: z.enum([
              'avg',
              'max',
              'min',
              'cardinality',
              'rate',
              'count',
              'sum',
              'p95',
              'p99',
              'custom',
            ]),
          })
          .partial()
          .passthrough(),
        z
          .object({
            threshold: z.array(z.number()),
            comparator: z.enum(['<', '<=', '>', '>=', 'between', 'outside']),
            timeUnit: z.enum(['s', 'm', 'h', 'd']),
            timeSize: z.number(),
            warningThreshold: z.array(z.number()),
            warningComparator: z.enum(['<', '<=', '>', '>=', 'between', 'outside']),
            aggType: z.literal('count'),
          })
          .partial()
          .passthrough(),
        z
          .object({
            threshold: z.array(z.number()),
            comparator: z.enum(['<', '<=', '>', '>=', 'between', 'outside']),
            timeUnit: z.enum(['s', 'm', 'h', 'd']),
            timeSize: z.number(),
            warningThreshold: z.array(z.number()),
            warningComparator: z.enum(['<', '<=', '>', '>=', 'between', 'outside']),
            aggType: z.literal('custom'),
            customMetric: z.array(
              z.union([
                z
                  .object({
                    name: z.string(),
                    aggType: z.enum(['avg', 'sum', 'max', 'min', 'cardinality']),
                    field: z.string(),
                  })
                  .partial()
                  .passthrough(),
                z
                  .object({ name: z.string(), aggType: z.literal('count'), filter: z.string() })
                  .partial()
                  .passthrough(),
              ])
            ),
            equation: z.string(),
            label: z.string(),
          })
          .partial()
          .passthrough(),
      ])
    ),
    groupBy: z.union([z.string(), z.array(z.string())]),
    filterQuery: z.string(),
    sourceId: z.string(),
    alertOnNoData: z.boolean(),
    alertOnGroupDisappear: z.boolean(),
  })
  .partial()
  .passthrough();
const params_property_slo_burn_rate = z
  .object({
    sloId: z.string(),
    burnRateThreshold: z.number(),
    maxBurnRateThreshold: z.number(),
    longWindow: z.object({ value: z.number(), unit: z.string() }).partial().passthrough(),
    shortWindow: z.object({ value: z.number(), unit: z.string() }).partial().passthrough(),
  })
  .partial()
  .passthrough();
const params_property_synthetics_uptime_tls = z
  .object({ search: z.string(), certExpirationThreshold: z.number(), certAgeThreshold: z.number() })
  .partial()
  .passthrough();
const params_property_synthetics_monitor_status = z
  .object({
    availability: z
      .object({ range: z.number(), rangeUnit: z.string(), threshold: z.string() })
      .partial()
      .passthrough()
      .optional(),
    filters: z
      .union([
        z.string(),
        z
          .object({
            'monitor.type': z.array(z.string()),
            'observer.geo.name': z.array(z.string()),
            tags: z.array(z.string()),
            'url.port': z.array(z.string()),
          })
          .partial()
          .passthrough(),
      ])
      .optional(),
    locations: z.array(z.string()).optional(),
    numTimes: z.number(),
    search: z.string().optional(),
    shouldCheckStatus: z.boolean(),
    shouldCheckAvailability: z.boolean(),
    timerangeCount: z.number().optional(),
    timerangeUnit: z.string().optional(),
    timerange: z.object({ from: z.string(), to: z.string() }).partial().passthrough().optional(),
    version: z.number().optional(),
    isAutoGenerated: z.boolean().optional(),
  })
  .passthrough();
const post_alerting_rule_id_Body = z.object({
  actions: z
    .array(
      z.object({
        alerts_filter: z
          .object({
            query: z.object({
              dsl: z.string().optional(),
              filters: z.array(
                z.object({
                  $state: z.object({ store: z.enum(['appState', 'globalState']) }).optional(),
                  meta: z.object({}).partial().passthrough(),
                  query: z.object({}).partial().passthrough().optional(),
                })
              ),
              kql: z.string(),
            }),
            timeframe: z.object({
              days: z.array(
                z.union([
                  z.literal(1),
                  z.literal(2),
                  z.literal(3),
                  z.literal(4),
                  z.literal(5),
                  z.literal(6),
                  z.literal(7),
                ])
              ),
              hours: z.object({ end: z.string(), start: z.string() }),
              timezone: z.string(),
            }),
          })
          .partial()
          .optional(),
        frequency: z
          .object({
            notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']),
            summary: z.boolean(),
            throttle: z.string().nullable(),
          })
          .optional(),
        group: z.string().optional(),
        id: z.string(),
        params: z.object({}).partial().passthrough().optional().default({}),
        use_alert_data_for_template: z.boolean().optional(),
        uuid: z.string().optional(),
      })
    )
    .optional()
    .default([]),
  alert_delay: z.object({ active: z.number() }).optional(),
  artifacts: z
    .object({
      dashboards: z.array(z.object({ id: z.string() })).max(10),
      investigation_guide: z.object({ blob: z.string().max(1000) }),
    })
    .partial()
    .optional(),
  consumer: z.string(),
  enabled: z.boolean().optional().default(true),
  flapping: z
    .object({
      look_back_window: z.number().gte(2).lte(20),
      status_change_threshold: z.number().gte(2).lte(20),
    })
    .nullish(),
  name: z.string(),
  notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']).nullish(),
  rule_type_id: z.string(),
  schedule: z.object({ interval: z.string() }),
  tags: z.array(z.string()).optional().default([]),
  throttle: z.string().nullish(),
  params: z
    .union([
      params_property_apm_anomaly,
      params_property_apm_error_count,
      params_property_apm_transaction_duration,
      params_property_apm_transaction_error_rate,
      params_es_query_dsl_rule,
      params_es_query_esql_rule,
      params_es_query_kql_rule,
      params_index_threshold_rule,
      params_property_infra_inventory,
      params_property_log_threshold,
      params_property_infra_metric_threshold,
      params_property_slo_burn_rate,
      params_property_synthetics_uptime_tls,
      params_property_synthetics_monitor_status,
    ])
    .optional()
    .default({}),
});
const put_alerting_rule_id_Body = z.object({
  actions: z
    .array(
      z.object({
        alerts_filter: z
          .object({
            query: z.object({
              dsl: z.string().optional(),
              filters: z.array(
                z.object({
                  $state: z.object({ store: z.enum(['appState', 'globalState']) }).optional(),
                  meta: z.object({}).partial().passthrough(),
                  query: z.object({}).partial().passthrough().optional(),
                })
              ),
              kql: z.string(),
            }),
            timeframe: z.object({
              days: z.array(
                z.union([
                  z.literal(1),
                  z.literal(2),
                  z.literal(3),
                  z.literal(4),
                  z.literal(5),
                  z.literal(6),
                  z.literal(7),
                ])
              ),
              hours: z.object({ end: z.string(), start: z.string() }),
              timezone: z.string(),
            }),
          })
          .partial()
          .optional(),
        frequency: z
          .object({
            notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']),
            summary: z.boolean(),
            throttle: z.string().nullable(),
          })
          .optional(),
        group: z.string().optional(),
        id: z.string(),
        params: z.object({}).partial().passthrough().optional().default({}),
        use_alert_data_for_template: z.boolean().optional(),
        uuid: z.string().optional(),
      })
    )
    .optional()
    .default([]),
  alert_delay: z.object({ active: z.number() }).optional(),
  artifacts: z
    .object({
      dashboards: z.array(z.object({ id: z.string() })).max(10),
      investigation_guide: z.object({ blob: z.string().max(1000) }),
    })
    .partial()
    .optional(),
  flapping: z
    .object({
      look_back_window: z.number().gte(2).lte(20),
      status_change_threshold: z.number().gte(2).lte(20),
    })
    .nullish(),
  name: z.string(),
  notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']).nullish(),
  params: z.object({}).partial().passthrough().optional().default({}),
  schedule: z.object({ interval: z.string() }),
  tags: z.array(z.string()).optional().default([]),
  throttle: z.string().nullish(),
});
const post_alerting_rule_id_snooze_schedule_Body = z.object({
  schedule: z
    .object({
      custom: z.object({
        duration: z.string(),
        recurring: z
          .object({
            end: z.string(),
            every: z.string(),
            occurrences: z.number().gte(1),
            onMonth: z.array(z.number().gte(1).lte(12)).min(1),
            onMonthDay: z.array(z.number().gte(1).lte(31)).min(1),
            onWeekDay: z.array(z.string()).min(1),
          })
          .partial()
          .optional(),
        start: z.string(),
        timezone: z.string().optional(),
      }),
    })
    .partial(),
});
const search_fields = z.union([z.array(z.string()), z.string()]).optional();
const has_reference = z.object({ id: z.string(), type: z.string() }).nullish();
const APM_UI_agent_keys_object = z
  .object({ name: z.string(), privileges: z.array(z.enum(['event:write', 'config_agent:read'])) })
  .passthrough();
const APM_UI_agent_keys_response = z
  .object({
    agentKey: z
      .object({
        api_key: z.string(),
        encoded: z.string(),
        expiration: z.number().int().optional(),
        id: z.string(),
        name: z.string(),
      })
      .passthrough(),
  })
  .partial()
  .passthrough();
const APM_UI_400_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .partial()
  .passthrough();
const APM_UI_401_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .partial()
  .passthrough();
const APM_UI_403_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .partial()
  .passthrough();
const APM_UI_500_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .partial()
  .passthrough();
const APM_UI_404_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .partial()
  .passthrough();
const APM_UI_create_annotation_object = z
  .object({
    '@timestamp': z.string(),
    message: z.string().optional(),
    service: z.object({ environment: z.string().optional(), version: z.string() }).passthrough(),
    tags: z.array(z.string()).optional(),
  })
  .passthrough();
const APM_UI_create_annotation_response = z
  .object({
    _id: z.string(),
    _index: z.string(),
    _source: z
      .object({
        '@timestamp': z.string(),
        annotation: z.object({ title: z.string(), type: z.string() }).partial().passthrough(),
        event: z.object({ created: z.string() }).partial().passthrough(),
        message: z.string(),
        service: z
          .object({ environment: z.string(), name: z.string(), version: z.string() })
          .partial()
          .passthrough(),
        tags: z.array(z.string()),
      })
      .partial()
      .passthrough(),
  })
  .partial()
  .passthrough();
const APM_UI_annotation_search_response = z
  .object({
    annotations: z.array(
      z
        .object({
          '@timestamp': z.number(),
          id: z.string(),
          text: z.string(),
          type: z.literal('version'),
        })
        .partial()
        .passthrough()
    ),
  })
  .partial()
  .passthrough();
const APM_UI_service_object = z
  .object({ environment: z.string(), name: z.string() })
  .partial()
  .passthrough();
const APM_UI_delete_service_object = z.object({ service: APM_UI_service_object }).passthrough();
const APM_UI_delete_agent_configurations_response = z
  .object({ result: z.string() })
  .partial()
  .passthrough();
const APM_UI_settings_object = z.record(z.string());
const APM_UI_agent_configuration_object = z
  .object({
    '@timestamp': z.number(),
    agent_name: z.string().optional(),
    applied_by_agent: z.boolean().optional(),
    etag: z.string(),
    service: APM_UI_service_object,
    settings: APM_UI_settings_object,
  })
  .passthrough();
const APM_UI_agent_configurations_response = z
  .object({ configurations: z.array(APM_UI_agent_configuration_object) })
  .partial()
  .passthrough();
const APM_UI_agent_configuration_intake_object = z
  .object({
    agent_name: z.string().optional(),
    service: APM_UI_service_object,
    settings: APM_UI_settings_object,
  })
  .passthrough();
const APM_UI_service_agent_name_response = z
  .object({ agentName: z.string() })
  .partial()
  .passthrough();
const APM_UI_service_environment_object = z
  .object({ alreadyConfigured: z.boolean(), name: z.string() })
  .partial()
  .passthrough();
const APM_UI_service_environments_response = z
  .object({ environments: z.array(APM_UI_service_environment_object) })
  .partial()
  .passthrough();
const APM_UI_search_agent_configuration_object = z
  .object({
    etag: z.string().optional(),
    mark_as_applied_by_agent: z.boolean().optional(),
    service: APM_UI_service_object,
  })
  .passthrough();
const APM_UI_search_agent_configuration_response = z
  .object({
    _id: z.string(),
    _index: z.string(),
    _score: z.number(),
    _source: APM_UI_agent_configuration_object,
  })
  .partial()
  .passthrough();
const APM_UI_single_agent_configuration_response = z
  .object({ id: z.string() })
  .passthrough()
  .and(APM_UI_agent_configuration_object);
const APM_UI_base_source_map_object = z
  .object({
    compressionAlgorithm: z.string(),
    created: z.string(),
    decodedSha256: z.string(),
    decodedSize: z.number(),
    encodedSha256: z.string(),
    encodedSize: z.number(),
    encryptionAlgorithm: z.string(),
    id: z.string(),
    identifier: z.string(),
    packageName: z.string(),
    relative_url: z.string(),
    type: z.string(),
  })
  .partial()
  .passthrough();
const APM_UI_source_maps_response = z
  .object({
    artifacts: z.array(
      z
        .object({
          body: z
            .object({
              bundleFilepath: z.string(),
              serviceName: z.string(),
              serviceVersion: z.string(),
              sourceMap: z
                .object({
                  file: z.string(),
                  mappings: z.string(),
                  sourceRoot: z.string(),
                  sources: z.array(z.string()),
                  sourcesContent: z.array(z.string()),
                  version: z.number(),
                })
                .partial()
                .passthrough(),
            })
            .partial()
            .passthrough(),
        })
        .partial()
        .passthrough()
        .and(APM_UI_base_source_map_object)
    ),
  })
  .partial()
  .passthrough();
const APM_UI_501_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .partial()
  .passthrough();
const APM_UI_upload_source_map_object = z
  .object({
    bundle_filepath: z.string(),
    service_name: z.string(),
    service_version: z.string(),
    sourcemap: z.instanceof(File),
  })
  .passthrough();
const APM_UI_upload_source_maps_response = z
  .object({ body: z.string() })
  .partial()
  .passthrough()
  .and(APM_UI_base_source_map_object);
const Security_Entity_Analytics_API_IdField = z.enum([
  'host.name',
  'user.name',
  'service.name',
  'entity.id',
]);
const Security_Entity_Analytics_API_AssetCriticalityRecordIdParts = z
  .object({ id_field: Security_Entity_Analytics_API_IdField, id_value: z.string() })
  .passthrough();
const Security_Entity_Analytics_API_AssetCriticalityLevel = z.enum([
  'low_impact',
  'medium_impact',
  'high_impact',
  'extreme_impact',
]);
const Security_Entity_Analytics_API_CreateAssetCriticalityRecord =
  Security_Entity_Analytics_API_AssetCriticalityRecordIdParts.and(
    z
      .object({ criticality_level: Security_Entity_Analytics_API_AssetCriticalityLevel })
      .passthrough()
  );
const Security_Entity_Analytics_API_AssetCriticalityRecordEcsParts = z
  .object({
    asset: z
      .object({ criticality: Security_Entity_Analytics_API_AssetCriticalityLevel.optional() })
      .passthrough(),
    entity: z
      .object({
        asset: z
          .object({ criticality: Security_Entity_Analytics_API_AssetCriticalityLevel })
          .passthrough()
          .optional(),
        id: z.string(),
      })
      .passthrough()
      .optional(),
    host: z
      .object({
        asset: z
          .object({ criticality: Security_Entity_Analytics_API_AssetCriticalityLevel })
          .passthrough()
          .optional(),
        name: z.string(),
      })
      .passthrough()
      .optional(),
    service: z
      .object({
        asset: z
          .object({ criticality: Security_Entity_Analytics_API_AssetCriticalityLevel })
          .passthrough()
          .optional(),
        name: z.string(),
      })
      .passthrough()
      .optional(),
    user: z
      .object({
        asset: z
          .object({ criticality: Security_Entity_Analytics_API_AssetCriticalityLevel })
          .passthrough()
          .optional(),
        name: z.string(),
      })
      .passthrough()
      .optional(),
  })
  .passthrough();
const Security_Entity_Analytics_API_AssetCriticalityRecord =
  Security_Entity_Analytics_API_CreateAssetCriticalityRecord.and(
    Security_Entity_Analytics_API_AssetCriticalityRecordEcsParts
  ).and(z.object({ '@timestamp': z.string().datetime({ offset: true }) }).passthrough());
const CreateAssetCriticalityRecord_Body =
  Security_Entity_Analytics_API_CreateAssetCriticalityRecord.and(
    z
      .object({ refresh: z.literal('wait_for') })
      .partial()
      .passthrough()
  );
const Security_Entity_Analytics_API_AssetCriticalityLevelsForBulkUpload = z.enum([
  'low_impact',
  'medium_impact',
  'high_impact',
  'extreme_impact',
  'unassigned',
]);
const BulkUpsertAssetCriticalityRecords_Body = z
  .object({
    records: z
      .array(
        Security_Entity_Analytics_API_AssetCriticalityRecordIdParts.and(
          z
            .object({
              criticality_level: Security_Entity_Analytics_API_AssetCriticalityLevelsForBulkUpload,
            })
            .passthrough()
        )
      )
      .min(1)
      .max(1000),
  })
  .passthrough();
const Security_Entity_Analytics_API_AssetCriticalityBulkUploadErrorItem = z
  .object({ index: z.number().int(), message: z.string() })
  .passthrough();
const Security_Entity_Analytics_API_AssetCriticalityBulkUploadStats = z
  .object({ failed: z.number().int(), successful: z.number().int(), total: z.number().int() })
  .passthrough();
const Cases_4xx_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number().int() })
  .partial()
  .passthrough();
const Cases_assignees = z.array(z.object({ uid: z.string() }).passthrough());
const Cases_case_category = z.string();
const Cases_connector_properties_none = z
  .object({
    fields: z.string().nullable(),
    id: z.string(),
    name: z.string(),
    type: z.literal('.none'),
  })
  .passthrough();
const Cases_connector_properties_cases_webhook = z
  .object({
    fields: z.string().nullable(),
    id: z.string(),
    name: z.string(),
    type: z.literal('.cases-webhook'),
  })
  .passthrough();
const Cases_connector_properties_jira = z
  .object({
    fields: z
      .object({
        issueType: z.string().nullable(),
        parent: z.string().nullable(),
        priority: z.string().nullable(),
      })
      .passthrough(),
    id: z.string(),
    name: z.string(),
    type: z.literal('.jira'),
  })
  .passthrough();
const Cases_connector_properties_resilient = z
  .object({
    fields: z
      .object({ issueTypes: z.array(z.string()), severityCode: z.string() })
      .passthrough()
      .nullable(),
    id: z.string(),
    name: z.string(),
    type: z.literal('.resilient'),
  })
  .passthrough();
const Cases_connector_properties_servicenow = z
  .object({
    fields: z
      .object({
        category: z.string().nullable(),
        impact: z.string().nullable(),
        severity: z.string().nullable(),
        subcategory: z.string().nullable(),
        urgency: z.string().nullable(),
      })
      .passthrough(),
    id: z.string(),
    name: z.string(),
    type: z.literal('.servicenow'),
  })
  .passthrough();
const Cases_connector_properties_servicenow_sir = z
  .object({
    fields: z
      .object({
        category: z.string().nullable(),
        destIp: z.boolean().nullable(),
        malwareHash: z.boolean().nullable(),
        malwareUrl: z.boolean().nullable(),
        priority: z.string().nullable(),
        sourceIp: z.boolean().nullable(),
        subcategory: z.string().nullable(),
      })
      .passthrough(),
    id: z.string(),
    name: z.string(),
    type: z.literal('.servicenow-sir'),
  })
  .passthrough();
const Cases_connector_properties_swimlane = z
  .object({
    fields: z.object({ caseId: z.string().nullable() }).passthrough(),
    id: z.string(),
    name: z.string(),
    type: z.literal('.swimlane'),
  })
  .passthrough();
const Cases_case_description = z.string();
const Cases_settings = z.object({ syncAlerts: z.boolean() }).passthrough();
const Cases_case_severity = z.enum(['critical', 'high', 'low', 'medium']);
const Cases_case_status = z.enum(['closed', 'in-progress', 'open']);
const Cases_case_tags = z.array(z.string().max(256));
const Cases_case_title = z.string();
const Cases_update_case_request = z
  .object({
    cases: z
      .array(
        z
          .object({
            assignees: Cases_assignees.max(10).nullish(),
            category: Cases_case_category.max(50).optional(),
            connector: z
              .union([
                Cases_connector_properties_none,
                Cases_connector_properties_cases_webhook,
                Cases_connector_properties_jira,
                Cases_connector_properties_resilient,
                Cases_connector_properties_servicenow,
                Cases_connector_properties_servicenow_sir,
                Cases_connector_properties_swimlane,
              ])
              .optional(),
            customFields: z
              .array(
                z
                  .object({
                    key: z.string(),
                    type: z.enum(['text', 'toggle']),
                    value: z.union([z.string(), z.boolean()]),
                  })
                  .passthrough()
              )
              .max(10)
              .optional(),
            description: Cases_case_description.max(30000).optional(),
            id: z.string().max(30000),
            settings: Cases_settings.optional(),
            severity: Cases_case_severity.optional().default('low'),
            status: Cases_case_status.optional(),
            tags: Cases_case_tags.max(200).optional(),
            title: Cases_case_title.max(160).optional(),
            version: z.string(),
          })
          .passthrough()
      )
      .min(1)
      .max(100),
  })
  .passthrough();
const Cases_case_response_closed_by_properties = z
  .object({
    email: z.string().nullable(),
    full_name: z.string().nullable(),
    profile_uid: z.string().optional(),
    username: z.string().nullable(),
  })
  .passthrough();
const Cases_owner = z.enum(['cases', 'observability', 'securitySolution']);
const Cases_alert_comment_response_properties = z
  .object({
    alertId: z.array(z.string()).optional(),
    created_at: z.string().datetime({ offset: true }).optional(),
    created_by: z
      .object({
        email: z.string().nullable(),
        full_name: z.string().nullable(),
        profile_uid: z.string().optional(),
        username: z.string().nullable(),
      })
      .passthrough()
      .optional(),
    id: z.string().optional(),
    index: z.array(z.string()).optional(),
    owner: Cases_owner.optional(),
    pushed_at: z.string().datetime({ offset: true }).nullish(),
    pushed_by: z
      .object({
        email: z.string().nullable(),
        full_name: z.string().nullable(),
        profile_uid: z.string().optional(),
        username: z.string().nullable(),
      })
      .passthrough()
      .nullish(),
    rule: z.object({ id: z.string(), name: z.string() }).partial().passthrough().optional(),
    type: z.literal('alert'),
    updated_at: z.string().datetime({ offset: true }).nullish(),
    updated_by: z
      .object({
        email: z.string().nullable(),
        full_name: z.string().nullable(),
        profile_uid: z.string().optional(),
        username: z.string().nullable(),
      })
      .passthrough()
      .nullish(),
    version: z.string().optional(),
  })
  .passthrough();
const Cases_case_response_created_by_properties = z
  .object({
    email: z.string().nullable(),
    full_name: z.string().nullable(),
    profile_uid: z.string().optional(),
    username: z.string().nullable(),
  })
  .passthrough();
const Cases_case_response_pushed_by_properties = z
  .object({
    email: z.string().nullable(),
    full_name: z.string().nullable(),
    profile_uid: z.string().optional(),
    username: z.string().nullable(),
  })
  .passthrough();
const Cases_case_response_updated_by_properties = z
  .object({
    email: z.string().nullable(),
    full_name: z.string().nullable(),
    profile_uid: z.string().optional(),
    username: z.string().nullable(),
  })
  .passthrough();
const Cases_user_comment_response_properties = z
  .object({
    comment: z.string().optional(),
    created_at: z.string().datetime({ offset: true }).optional(),
    created_by: Cases_case_response_created_by_properties.optional(),
    id: z.string().optional(),
    owner: Cases_owner.optional(),
    pushed_at: z.string().datetime({ offset: true }).nullish(),
    pushed_by: Cases_case_response_pushed_by_properties.nullish(),
    type: z.literal('user'),
    updated_at: z.string().datetime({ offset: true }).nullish(),
    updated_by: Cases_case_response_updated_by_properties.nullish(),
    version: z.string().optional(),
  })
  .passthrough();
const Cases_external_service = z
  .object({
    connector_id: z.string(),
    connector_name: z.string(),
    external_id: z.string(),
    external_title: z.string(),
    external_url: z.string(),
    pushed_at: z.string().datetime({ offset: true }),
    pushed_by: z
      .object({
        email: z.string().nullable(),
        full_name: z.string().nullable(),
        profile_uid: z.string(),
        username: z.string().nullable(),
      })
      .partial()
      .passthrough()
      .nullable(),
  })
  .partial()
  .passthrough();
const Cases_case_response_properties = z
  .object({
    assignees: Cases_assignees.max(10).nullish(),
    category: z.string().nullish(),
    closed_at: z.string().datetime({ offset: true }).nullable(),
    closed_by: Cases_case_response_closed_by_properties.nullable(),
    comments: z
      .array(
        z.discriminatedUnion('type', [
          Cases_alert_comment_response_properties,
          Cases_user_comment_response_properties,
        ])
      )
      .max(10000),
    connector: z.discriminatedUnion('type', [
      Cases_connector_properties_none,
      Cases_connector_properties_cases_webhook,
      Cases_connector_properties_jira,
      Cases_connector_properties_resilient,
      Cases_connector_properties_servicenow,
      Cases_connector_properties_servicenow_sir,
      Cases_connector_properties_swimlane,
    ]),
    created_at: z.string().datetime({ offset: true }),
    created_by: Cases_case_response_created_by_properties,
    customFields: z
      .array(
        z
          .object({
            key: z.string(),
            type: z.enum(['text', 'toggle']),
            value: z.union([z.string(), z.boolean()]),
          })
          .partial()
          .passthrough()
      )
      .optional(),
    description: z.string(),
    duration: z.number().int().nullable(),
    external_service: Cases_external_service.nullable(),
    id: z.string(),
    owner: Cases_owner,
    settings: Cases_settings,
    severity: Cases_case_severity.default('low'),
    status: Cases_case_status,
    tags: z.array(z.string()),
    title: z.string(),
    totalAlerts: z.number().int(),
    totalComment: z.number().int(),
    updated_at: z.string().datetime({ offset: true }).nullable(),
    updated_by: Cases_case_response_updated_by_properties.nullable(),
    version: z.string(),
  })
  .passthrough();
const Cases_create_case_request = z
  .object({
    assignees: Cases_assignees.max(10).nullish(),
    category: Cases_case_category.max(50).optional(),
    connector: z.union([
      Cases_connector_properties_none,
      Cases_connector_properties_cases_webhook,
      Cases_connector_properties_jira,
      Cases_connector_properties_resilient,
      Cases_connector_properties_servicenow,
      Cases_connector_properties_servicenow_sir,
      Cases_connector_properties_swimlane,
    ]),
    customFields: z
      .array(
        z
          .object({
            key: z.string(),
            type: z.enum(['text', 'toggle']),
            value: z.union([z.string(), z.boolean()]),
          })
          .passthrough()
      )
      .max(10)
      .optional(),
    description: Cases_case_description.max(30000),
    owner: Cases_owner,
    settings: Cases_settings,
    severity: Cases_case_severity.optional().default('low'),
    tags: Cases_case_tags.max(200),
    title: Cases_case_title.max(160),
  })
  .passthrough();
const Cases_string = z.string();
const Cases_string_array = z.array(Cases_string);
const assignees = z.union([Cases_string, Cases_string_array]).optional();
const Cases_case_categories = z.array(Cases_case_category);
const category = z.union([Cases_case_category, Cases_case_categories]).optional();
const Cases_owners = z.array(Cases_owner);
const owner = z.union([Cases_owner, Cases_owners]).optional();
const Cases_searchFieldsType = z.enum(['description', 'title']);
const Cases_searchFieldsTypeArray = z.array(Cases_searchFieldsType);
const searchFields = z.union([Cases_searchFieldsType, Cases_searchFieldsTypeArray]).optional();
const Cases_alert_response_properties = z
  .object({ attached_at: z.string().datetime({ offset: true }), id: z.string(), index: z.string() })
  .partial()
  .passthrough();
const Cases_alert_identifiers = z.union([z.string(), z.array(z.string())]);
const Cases_alert_indices = z.union([z.string(), z.array(z.string())]);
const Cases_rule = z.object({ id: z.string(), name: z.string() }).partial().passthrough();
const Cases_update_alert_comment_request_properties = z
  .object({
    alertId: Cases_alert_identifiers,
    id: z.string(),
    index: Cases_alert_indices,
    owner: Cases_owner,
    rule: Cases_rule,
    type: z.literal('alert'),
    version: z.string(),
  })
  .passthrough();
const Cases_update_user_comment_request_properties = z
  .object({
    comment: z.string().max(30000),
    id: z.string(),
    owner: Cases_owner,
    type: z.literal('user'),
    version: z.string(),
  })
  .passthrough();
const Cases_update_case_comment_request = z.discriminatedUnion('type', [
  Cases_update_alert_comment_request_properties,
  Cases_update_user_comment_request_properties,
]);
const Cases_add_alert_comment_request_properties = z
  .object({
    alertId: Cases_alert_identifiers,
    index: Cases_alert_indices,
    owner: Cases_owner,
    rule: Cases_rule,
    type: z.literal('alert'),
  })
  .passthrough();
const Cases_add_user_comment_request_properties = z
  .object({ comment: z.string().max(30000), owner: Cases_owner, type: z.literal('user') })
  .passthrough();
const Cases_add_case_comment_request = z.discriminatedUnion('type', [
  Cases_add_alert_comment_request_properties,
  Cases_add_user_comment_request_properties,
]);
const Cases_add_case_file_request = z
  .object({ file: z.instanceof(File), filename: z.string().optional() })
  .passthrough();
const Cases_actions = z.enum(['add', 'create', 'delete', 'push_to_service', 'update']);
const Cases_payload_alert_comment = z
  .object({
    comment: z
      .object({
        alertId: z.union([z.string(), z.array(z.string())]),
        index: z.union([z.string(), z.array(z.string())]),
        owner: Cases_owner,
        rule: z.object({ id: z.string(), name: z.string() }).partial().passthrough(),
        type: z.literal('alert'),
      })
      .partial()
      .passthrough(),
  })
  .partial()
  .passthrough();
const Cases_payload_assignees = z
  .object({ assignees: Cases_assignees.max(10).nullable() })
  .partial()
  .passthrough();
const Cases_connector_types = z.enum([
  '.cases-webhook',
  '.jira',
  '.none',
  '.resilient',
  '.servicenow',
  '.servicenow-sir',
  '.swimlane',
]);
const Cases_payload_connector = z
  .object({
    connector: z
      .object({
        fields: z
          .object({
            caseId: z.string(),
            category: z.string(),
            destIp: z.boolean().nullable(),
            impact: z.string(),
            issueType: z.string(),
            issueTypes: z.array(z.string()),
            malwareHash: z.boolean().nullable(),
            malwareUrl: z.boolean().nullable(),
            parent: z.string(),
            priority: z.string(),
            severity: z.string(),
            severityCode: z.string(),
            sourceIp: z.boolean().nullable(),
            subcategory: z.string(),
            urgency: z.string(),
          })
          .partial()
          .passthrough()
          .nullable(),
        id: z.string(),
        name: z.string(),
        type: Cases_connector_types,
      })
      .partial()
      .passthrough(),
  })
  .partial()
  .passthrough();
const Cases_payload_create_case = z
  .object({
    assignees: Cases_assignees.max(10).nullable(),
    connector: z
      .object({
        fields: z
          .object({
            caseId: z.string(),
            category: z.string(),
            destIp: z.boolean().nullable(),
            impact: z.string(),
            issueType: z.string(),
            issueTypes: z.array(z.string()),
            malwareHash: z.boolean().nullable(),
            malwareUrl: z.boolean().nullable(),
            parent: z.string(),
            priority: z.string(),
            severity: z.string(),
            severityCode: z.string(),
            sourceIp: z.boolean().nullable(),
            subcategory: z.string(),
            urgency: z.string(),
          })
          .partial()
          .passthrough()
          .nullable(),
        id: z.string(),
        name: z.string(),
        type: Cases_connector_types,
      })
      .partial()
      .passthrough(),
    description: z.string(),
    owner: Cases_owner,
    settings: Cases_settings,
    severity: Cases_case_severity.default('low'),
    status: Cases_case_status,
    tags: z.array(z.string()),
    title: z.string(),
  })
  .partial()
  .passthrough();
const Cases_payload_delete = z.object({}).partial().passthrough();
const Cases_payload_description = z.object({ description: z.string() }).partial().passthrough();
const Cases_payload_pushed = z
  .object({ externalService: Cases_external_service.nullable() })
  .partial()
  .passthrough();
const Cases_payload_settings = z.object({ settings: Cases_settings }).partial().passthrough();
const Cases_payload_severity = z
  .object({ severity: Cases_case_severity.default('low') })
  .partial()
  .passthrough();
const Cases_payload_status = z.object({ status: Cases_case_status }).partial().passthrough();
const Cases_payload_tags = z
  .object({ tags: z.array(z.string()) })
  .partial()
  .passthrough();
const Cases_payload_title = z.object({ title: z.string() }).partial().passthrough();
const Cases_payload_user_comment = z
  .object({
    comment: z
      .object({ comment: z.string(), owner: Cases_owner, type: z.literal('user') })
      .partial()
      .passthrough(),
  })
  .partial()
  .passthrough();
const Cases_user_actions_find_response_properties = z
  .object({
    action: Cases_actions,
    comment_id: z.string().nullable(),
    created_at: z.string().datetime({ offset: true }),
    created_by: z
      .object({
        email: z.string().nullable(),
        full_name: z.string().nullable(),
        profile_uid: z.string().optional(),
        username: z.string().nullable(),
      })
      .passthrough(),
    id: z.string(),
    owner: Cases_owner,
    payload: z.union([
      Cases_payload_alert_comment,
      Cases_payload_assignees,
      Cases_payload_connector,
      Cases_payload_create_case,
      Cases_payload_delete,
      Cases_payload_description,
      Cases_payload_pushed,
      Cases_payload_settings,
      Cases_payload_severity,
      Cases_payload_status,
      Cases_payload_tags,
      Cases_payload_title,
      Cases_payload_user_comment,
    ]),
    type: z.enum([
      'assignees',
      'create_case',
      'comment',
      'connector',
      'description',
      'pushed',
      'tags',
      'title',
      'status',
      'settings',
      'severity',
    ]),
    version: z.string(),
  })
  .passthrough();
const Cases_closure_types = z.enum(['close-by-pushing', 'close-by-user']);
const Cases_template_tags = z.array(z.string().max(256));
const Cases_templates = z.array(
  z
    .object({
      caseFields: z
        .object({
          assignees: Cases_assignees.max(10).nullable(),
          category: Cases_case_category.max(50),
          connector: z
            .object({
              fields: z.object({}).partial().passthrough().nullable(),
              id: z.string(),
              name: z.string(),
              type: Cases_connector_types,
            })
            .partial()
            .passthrough(),
          customFields: z.array(
            z
              .object({
                key: z.string(),
                type: z.enum(['text', 'toggle']),
                value: z.union([z.string(), z.boolean()]),
              })
              .partial()
              .passthrough()
          ),
          description: Cases_case_description.max(30000),
          settings: Cases_settings,
          severity: Cases_case_severity.default('low'),
          tags: Cases_case_tags.max(200),
          title: Cases_case_title.max(160),
        })
        .partial()
        .passthrough(),
      description: z.string(),
      key: z.string(),
      name: z.string(),
      tags: Cases_template_tags.max(200),
    })
    .partial()
    .passthrough()
);
const Cases_set_case_configuration_request = z
  .object({
    closure_type: Cases_closure_types,
    connector: z
      .object({
        fields: z.object({}).partial().passthrough().nullable(),
        id: z.string(),
        name: z.string(),
        type: Cases_connector_types,
      })
      .passthrough(),
    customFields: z
      .array(
        z
          .object({
            defaultValue: z.union([z.string(), z.boolean()]).optional(),
            key: z.string().min(1).max(36),
            label: z.string().min(1).max(50),
            type: z.enum(['text', 'toggle']),
            required: z.boolean(),
          })
          .passthrough()
      )
      .max(10)
      .optional(),
    owner: Cases_owner,
    templates: Cases_templates.optional(),
  })
  .passthrough();
const Cases_update_case_configuration_request = z
  .object({
    closure_type: Cases_closure_types.optional(),
    connector: z
      .object({
        fields: z.object({}).partial().passthrough().nullable(),
        id: z.string(),
        name: z.string(),
        type: Cases_connector_types,
      })
      .passthrough()
      .optional(),
    customFields: z
      .array(
        z
          .object({
            defaultValue: z.union([z.string(), z.boolean()]).optional(),
            key: z.string().min(1).max(36),
            label: z.string().min(1).max(50),
            type: z.enum(['text', 'toggle']),
            required: z.boolean(),
          })
          .passthrough()
      )
      .optional(),
    templates: Cases_templates.optional(),
    version: z.string(),
  })
  .passthrough();
const Data_views_400_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .passthrough();
const Data_views_allownoindex = z.boolean();
const Data_views_fieldattrs = z
  .object({
    count: z.number().int(),
    customDescription: z.string().max(300),
    customLabel: z.string(),
  })
  .partial()
  .passthrough();
const Data_views_fieldformats = z.object({}).partial().passthrough();
const Data_views_namespaces = z.array(z.string().default('default'));
const Data_views_runtimefieldmap = z
  .object({ script: z.object({ source: z.string() }).partial().passthrough(), type: z.string() })
  .passthrough();
const Data_views_sourcefilters = z.array(z.object({ value: z.string() }).passthrough());
const Data_views_timefieldname = z.string();
const Data_views_title = z.string();
const Data_views_type = z.string();
const Data_views_typemeta = z
  .object({
    aggs: z.object({}).partial().passthrough(),
    params: z.object({}).partial().passthrough(),
  })
  .passthrough();
const Data_views_create_data_view_request_object = z
  .object({
    data_view: z
      .object({
        allowNoIndex: Data_views_allownoindex.optional(),
        fieldAttrs: z.record(Data_views_fieldattrs).optional(),
        fieldFormats: Data_views_fieldformats.optional(),
        fields: z.object({}).partial().passthrough().optional(),
        id: z.string().optional(),
        name: z.string().optional(),
        namespaces: Data_views_namespaces.optional(),
        runtimeFieldMap: z.record(Data_views_runtimefieldmap).optional(),
        sourceFilters: Data_views_sourcefilters.optional(),
        timeFieldName: Data_views_timefieldname.optional(),
        title: Data_views_title,
        type: Data_views_type.optional(),
        typeMeta: Data_views_typemeta.optional(),
        version: z.string().optional(),
      })
      .passthrough(),
    override: z.boolean().optional().default(false),
  })
  .passthrough();
const Data_views_typemeta_response = z
  .object({
    aggs: z.object({}).partial().passthrough(),
    params: z.object({}).partial().passthrough(),
  })
  .partial()
  .passthrough();
const Data_views_data_view_response_object = z
  .object({
    data_view: z
      .object({
        allowNoIndex: Data_views_allownoindex,
        fieldAttrs: z.record(Data_views_fieldattrs),
        fieldFormats: Data_views_fieldformats,
        fields: z.object({}).partial().passthrough(),
        id: z.string(),
        name: z.string(),
        namespaces: Data_views_namespaces,
        runtimeFieldMap: z.record(Data_views_runtimefieldmap),
        sourceFilters: Data_views_sourcefilters,
        timeFieldName: Data_views_timefieldname,
        title: Data_views_title,
        typeMeta: Data_views_typemeta_response.nullable(),
        version: z.string(),
      })
      .partial()
      .passthrough(),
  })
  .partial()
  .passthrough();
const Data_views_404_response = z
  .object({ error: z.literal('Not Found'), message: z.string(), statusCode: z.literal(404) })
  .partial()
  .passthrough();
const Data_views_update_data_view_request_object = z
  .object({
    data_view: z
      .object({
        allowNoIndex: Data_views_allownoindex,
        fieldFormats: Data_views_fieldformats,
        fields: z.object({}).partial().passthrough(),
        name: z.string(),
        runtimeFieldMap: z.record(Data_views_runtimefieldmap),
        sourceFilters: Data_views_sourcefilters,
        timeFieldName: Data_views_timefieldname,
        title: Data_views_title,
        type: Data_views_type,
        typeMeta: Data_views_typemeta,
      })
      .partial()
      .passthrough(),
    refresh_fields: z.boolean().optional().default(false),
  })
  .passthrough();
const createRuntimeFieldDefault_Body = z
  .object({ name: z.string(), runtimeField: z.object({}).partial().passthrough() })
  .passthrough();
const setDefaultDatailViewDefault_Body = z
  .object({ data_view_id: z.string().nullable(), force: z.boolean().optional().default(false) })
  .passthrough();
const Data_views_swap_data_view_request_object = z
  .object({
    delete: z.boolean().optional(),
    forId: z.union([z.string(), z.array(z.string())]).optional(),
    forType: z.string().optional(),
    fromId: z.string(),
    fromType: z.string().optional(),
    toId: z.string(),
  })
  .passthrough();
const Security_Detections_API_PlatformErrorResponse = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number().int() })
  .passthrough();
const Security_Detections_API_SiemErrorResponse = z
  .object({ message: z.string(), status_code: z.number().int() })
  .passthrough();
const Security_Detections_API_RuleActionAlertsFilter = z.object({}).partial().passthrough();
const Security_Detections_API_RuleActionNotifyWhen = z.enum([
  'onActiveAlert',
  'onThrottleInterval',
  'onActionGroupChange',
]);
const Security_Detections_API_RuleActionThrottle = z.union([
  z.enum(['no_actions', 'rule']),
  z.string(),
]);
const Security_Detections_API_RuleActionFrequency = z
  .object({
    notifyWhen: Security_Detections_API_RuleActionNotifyWhen,
    summary: z.boolean(),
    throttle: Security_Detections_API_RuleActionThrottle,
  })
  .passthrough();
const Security_Detections_API_RuleActionGroup = z.string();
const Security_Detections_API_RuleActionId = z.string();
const Security_Detections_API_RuleActionParams = z.object({}).partial().passthrough();
const Security_Detections_API_NonEmptyString = z.string();
const Security_Detections_API_RuleAction = z
  .object({
    action_type_id: z.string(),
    alerts_filter: Security_Detections_API_RuleActionAlertsFilter.optional(),
    frequency: Security_Detections_API_RuleActionFrequency.optional(),
    group: Security_Detections_API_RuleActionGroup.optional(),
    id: Security_Detections_API_RuleActionId,
    params: Security_Detections_API_RuleActionParams,
    uuid: Security_Detections_API_NonEmptyString.min(1).optional(),
  })
  .passthrough();
const Security_Detections_API_SavedObjectResolveAliasPurpose = z.enum([
  'savedObjectConversion',
  'savedObjectImport',
]);
const Security_Detections_API_SavedObjectResolveAliasTargetId = z.string();
const Security_Detections_API_RuleAuthorArray = z.array(z.string());
const Security_Detections_API_BuildingBlockType = z.string();
const Security_Detections_API_RuleDescription = z.string();
const Security_Detections_API_IsRuleEnabled = z.boolean();
const Security_Detections_API_ExceptionListType = z.enum([
  'detection',
  'rule_default',
  'endpoint',
  'endpoint_trusted_apps',
  'endpoint_trusted_devices',
  'endpoint_events',
  'endpoint_host_isolation_exceptions',
  'endpoint_blocklists',
]);
const Security_Detections_API_RuleExceptionList = z
  .object({
    id: z.string().min(1),
    list_id: z.string().min(1),
    namespace_type: z.enum(['agnostic', 'single']),
    type: Security_Detections_API_ExceptionListType,
  })
  .passthrough();
const Security_Detections_API_RuleFalsePositiveArray = z.array(z.string());
const Security_Detections_API_RuleIntervalFrom = z.string();
const Security_Detections_API_RuleInterval = z.string();
const Security_Detections_API_InvestigationFields = z
  .object({ field_names: z.array(Security_Detections_API_NonEmptyString).min(1) })
  .passthrough();
const Security_Detections_API_RuleLicense = z.string();
const Security_Detections_API_MaxSignals = z.number();
const Security_Detections_API_RuleMetadata = z.object({}).partial().passthrough();
const Security_Detections_API_RuleName = z.string();
const Security_Detections_API_AlertsIndexNamespace = z.string();
const Security_Detections_API_InvestigationGuide = z.string();
const Security_Detections_API_SavedObjectResolveOutcome = z.enum([
  'exactMatch',
  'aliasMatch',
  'conflict',
]);
const Security_Detections_API_AlertsIndex = z.string();
const Security_Detections_API_RuleReferenceArray = z.array(z.string());
const Security_Detections_API_RelatedIntegration = z
  .object({
    integration: Security_Detections_API_NonEmptyString.min(1).optional(),
    package: Security_Detections_API_NonEmptyString.min(1),
    version: Security_Detections_API_NonEmptyString.min(1),
  })
  .passthrough();
const Security_Detections_API_RelatedIntegrationArray = z.array(
  Security_Detections_API_RelatedIntegration
);
const Security_Detections_API_RequiredFieldInput = z
  .object({ name: z.string().min(1), type: z.string().min(1) })
  .passthrough();
const Security_Detections_API_EcsMapping = z.record(
  z
    .object({ field: z.string(), value: z.union([z.string(), z.array(z.string())]) })
    .partial()
    .passthrough()
);
const Security_Detections_API_OsqueryQuery = z
  .object({
    ecs_mapping: Security_Detections_API_EcsMapping.optional(),
    id: z.string(),
    platform: z.string().optional(),
    query: z.string(),
    removed: z.boolean().optional(),
    snapshot: z.boolean().optional(),
    version: z.string().optional(),
  })
  .passthrough();
const Security_Detections_API_OsqueryParams = z
  .object({
    ecs_mapping: Security_Detections_API_EcsMapping,
    pack_id: z.string(),
    queries: z.array(Security_Detections_API_OsqueryQuery),
    query: z.string(),
    saved_query_id: z.string(),
    timeout: z.number(),
  })
  .partial()
  .passthrough();
const Security_Detections_API_OsqueryResponseAction = z
  .object({ action_type_id: z.literal('.osquery'), params: Security_Detections_API_OsqueryParams })
  .passthrough();
const Security_Detections_API_DefaultParams = z
  .object({ command: z.literal('isolate'), comment: z.string().optional() })
  .passthrough();
const Security_Detections_API_ProcessesParams = z
  .object({
    command: z.enum(['kill-process', 'suspend-process']),
    comment: z.string().optional(),
    config: z
      .object({ field: z.string(), overwrite: z.boolean().optional().default(true) })
      .passthrough(),
  })
  .passthrough();
const Security_Detections_API_EndpointResponseAction = z
  .object({
    action_type_id: z.literal('.endpoint'),
    params: z.union([
      Security_Detections_API_DefaultParams,
      Security_Detections_API_ProcessesParams,
    ]),
  })
  .passthrough();
const Security_Detections_API_ResponseAction = z.union([
  Security_Detections_API_OsqueryResponseAction,
  Security_Detections_API_EndpointResponseAction,
]);
const Security_Detections_API_RiskScore = z.number();
const Security_Detections_API_RiskScoreMapping = z.array(
  z
    .object({
      field: z.string(),
      operator: z.literal('equals'),
      risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100).optional(),
      value: z.string(),
    })
    .passthrough()
);
const Security_Detections_API_RuleNameOverride = z.string();
const Security_Detections_API_SetupGuide = z.string();
const Security_Detections_API_Severity = z.enum(['low', 'medium', 'high', 'critical']);
const Security_Detections_API_SeverityMapping = z.array(
  z
    .object({
      field: z.string(),
      operator: z.literal('equals'),
      severity: Security_Detections_API_Severity,
      value: z.string(),
    })
    .passthrough()
);
const Security_Detections_API_RuleTagArray = z.array(z.string());
const Security_Detections_API_ThreatTactic = z
  .object({ id: z.string(), name: z.string(), reference: z.string() })
  .passthrough();
const Security_Detections_API_ThreatSubtechnique = z
  .object({ id: z.string(), name: z.string(), reference: z.string() })
  .passthrough();
const Security_Detections_API_ThreatTechnique = z
  .object({
    id: z.string(),
    name: z.string(),
    reference: z.string(),
    subtechnique: z.array(Security_Detections_API_ThreatSubtechnique).optional(),
  })
  .passthrough();
const Security_Detections_API_Threat = z
  .object({
    framework: z.string(),
    tactic: Security_Detections_API_ThreatTactic,
    technique: z.array(Security_Detections_API_ThreatTechnique).optional(),
  })
  .passthrough();
const Security_Detections_API_ThreatArray = z.array(Security_Detections_API_Threat);
const Security_Detections_API_TimelineTemplateId = z.string();
const Security_Detections_API_TimelineTemplateTitle = z.string();
const Security_Detections_API_TimestampOverride = z.string();
const Security_Detections_API_TimestampOverrideFallbackDisabled = z.boolean();
const Security_Detections_API_RuleIntervalTo = z.string();
const Security_Detections_API_RuleVersion = z.number();
const Security_Detections_API_RuleExecutionMetrics = z
  .object({
    execution_gap_duration_s: z.number().int().gte(0),
    frozen_indices_queried_count: z.number().int().gte(0),
    gap_range: z.object({ gte: z.string(), lte: z.string() }).passthrough(),
    total_enrichment_duration_ms: z.number().int().gte(0),
    total_indexing_duration_ms: z.number().int().gte(0),
    total_search_duration_ms: z.number().int().gte(0),
  })
  .partial()
  .passthrough();
const Security_Detections_API_RuleExecutionStatus = z.enum([
  'going to run',
  'running',
  'partial failure',
  'failed',
  'succeeded',
]);
const Security_Detections_API_RuleExecutionStatusOrder = z.number();
const Security_Detections_API_RuleExecutionSummary = z
  .object({
    last_execution: z
      .object({
        date: z.string().datetime({ offset: true }),
        message: z.string(),
        metrics: Security_Detections_API_RuleExecutionMetrics,
        status: Security_Detections_API_RuleExecutionStatus,
        status_order: Security_Detections_API_RuleExecutionStatusOrder.int(),
      })
      .passthrough(),
  })
  .passthrough();
const Security_Detections_API_UUID = z.string();
const Security_Detections_API_RuleObjectId = Security_Detections_API_UUID;
const Security_Detections_API_IsRuleImmutable = z.boolean();
const Security_Detections_API_RequiredField = z
  .object({ ecs: z.boolean(), name: z.string().min(1), type: z.string().min(1) })
  .passthrough();
const Security_Detections_API_RequiredFieldArray = z.array(Security_Detections_API_RequiredField);
const Security_Detections_API_RuleRevision = z.number();
const Security_Detections_API_RuleSignatureId = z.string();
const Security_Detections_API_IsExternalRuleCustomized = z.boolean();
const Security_Detections_API_ExternalRuleSource = z
  .object({
    is_customized: Security_Detections_API_IsExternalRuleCustomized,
    type: z.literal('external'),
  })
  .passthrough();
const Security_Detections_API_InternalRuleSource = z
  .object({ type: z.literal('internal') })
  .passthrough();
const Security_Detections_API_RuleSource = z.discriminatedUnion('type', [
  Security_Detections_API_ExternalRuleSource,
  Security_Detections_API_InternalRuleSource,
]);
const Security_Detections_API_ResponseFields = z
  .object({
    created_at: z.string().datetime({ offset: true }),
    created_by: z.string(),
    execution_summary: Security_Detections_API_RuleExecutionSummary.optional(),
    id: Security_Detections_API_RuleObjectId,
    immutable: Security_Detections_API_IsRuleImmutable,
    required_fields: Security_Detections_API_RequiredFieldArray,
    revision: Security_Detections_API_RuleRevision.int().gte(0),
    rule_id: Security_Detections_API_RuleSignatureId,
    rule_source: Security_Detections_API_RuleSource,
    updated_at: z.string().datetime({ offset: true }),
    updated_by: z.string(),
  })
  .passthrough();
const Security_Detections_API_EqlQueryLanguage = z.literal('eql');
const Security_Detections_API_RuleQuery = z.string();
const Security_Detections_API_EqlRequiredFields = z
  .object({
    language: Security_Detections_API_EqlQueryLanguage,
    query: Security_Detections_API_RuleQuery,
    type: z.literal('eql'),
  })
  .passthrough();
const Security_Detections_API_AlertSuppressionDurationUnit = z.enum(['s', 'm', 'h']);
const Security_Detections_API_AlertSuppressionDuration = z
  .object({
    unit: Security_Detections_API_AlertSuppressionDurationUnit,
    value: z.number().int().gte(1),
  })
  .passthrough();
const Security_Detections_API_AlertSuppressionGroupBy = z.array(z.string());
const Security_Detections_API_AlertSuppressionMissingFieldsStrategy = z.enum([
  'doNotSuppress',
  'suppress',
]);
const Security_Detections_API_AlertSuppression = z
  .object({
    duration: Security_Detections_API_AlertSuppressionDuration.optional(),
    group_by: Security_Detections_API_AlertSuppressionGroupBy.min(1).max(3),
    missing_fields_strategy:
      Security_Detections_API_AlertSuppressionMissingFieldsStrategy.optional(),
  })
  .passthrough();
const Security_Detections_API_DataViewId = z.string();
const Security_Detections_API_EventCategoryOverride = z.string();
const Security_Detections_API_RuleFilterArray = z.array(z.unknown());
const Security_Detections_API_IndexPatternArray = z.array(z.string());
const Security_Detections_API_TiebreakerField = z.string();
const Security_Detections_API_TimestampField = z.string();
const Security_Detections_API_EqlOptionalFields = z
  .object({
    alert_suppression: Security_Detections_API_AlertSuppression,
    data_view_id: Security_Detections_API_DataViewId,
    event_category_override: Security_Detections_API_EventCategoryOverride,
    filters: Security_Detections_API_RuleFilterArray,
    index: Security_Detections_API_IndexPatternArray,
    tiebreaker_field: Security_Detections_API_TiebreakerField,
    timestamp_field: Security_Detections_API_TimestampField,
  })
  .partial()
  .passthrough();
const Security_Detections_API_EqlRuleResponseFields = Security_Detections_API_EqlRequiredFields.and(
  Security_Detections_API_EqlOptionalFields
);
const Security_Detections_API_EqlRule = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .passthrough()
  .and(Security_Detections_API_ResponseFields)
  .and(Security_Detections_API_EqlRuleResponseFields);
const Security_Detections_API_QueryRuleRequiredFields = z
  .object({ type: z.literal('query') })
  .passthrough();
const Security_Detections_API_SavedQueryId = z.string();
const Security_Detections_API_QueryRuleOptionalFields = z
  .object({
    alert_suppression: Security_Detections_API_AlertSuppression,
    data_view_id: Security_Detections_API_DataViewId,
    filters: Security_Detections_API_RuleFilterArray,
    index: Security_Detections_API_IndexPatternArray,
    saved_id: Security_Detections_API_SavedQueryId,
  })
  .partial()
  .passthrough();
const Security_Detections_API_KqlQueryLanguage = z.enum(['kuery', 'lucene']);
const Security_Detections_API_QueryRuleResponseFields =
  Security_Detections_API_QueryRuleRequiredFields.and(
    Security_Detections_API_QueryRuleOptionalFields
  ).and(
    z
      .object({
        language: Security_Detections_API_KqlQueryLanguage,
        query: Security_Detections_API_RuleQuery,
      })
      .passthrough()
  );
const Security_Detections_API_QueryRule = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .passthrough()
  .and(Security_Detections_API_ResponseFields)
  .and(Security_Detections_API_QueryRuleResponseFields);
const Security_Detections_API_SavedQueryRuleRequiredFields = z
  .object({ saved_id: Security_Detections_API_SavedQueryId, type: z.literal('saved_query') })
  .passthrough();
const Security_Detections_API_SavedQueryRuleOptionalFields = z
  .object({
    alert_suppression: Security_Detections_API_AlertSuppression,
    data_view_id: Security_Detections_API_DataViewId,
    filters: Security_Detections_API_RuleFilterArray,
    index: Security_Detections_API_IndexPatternArray,
    query: Security_Detections_API_RuleQuery,
  })
  .partial()
  .passthrough();
const Security_Detections_API_SavedQueryRuleResponseFields =
  Security_Detections_API_SavedQueryRuleRequiredFields.and(
    Security_Detections_API_SavedQueryRuleOptionalFields
  ).and(z.object({ language: Security_Detections_API_KqlQueryLanguage }).passthrough());
const Security_Detections_API_SavedQueryRule = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .passthrough()
  .and(Security_Detections_API_ResponseFields)
  .and(Security_Detections_API_SavedQueryRuleResponseFields);
const Security_Detections_API_ThresholdCardinality = z.array(
  z.object({ field: z.string(), value: z.number().int().gte(0) }).passthrough()
);
const Security_Detections_API_ThresholdField = z.union([z.string(), z.array(z.string())]);
const Security_Detections_API_ThresholdValue = z.number();
const Security_Detections_API_Threshold = z
  .object({
    cardinality: Security_Detections_API_ThresholdCardinality.optional(),
    field: Security_Detections_API_ThresholdField,
    value: Security_Detections_API_ThresholdValue.int().gte(1),
  })
  .passthrough();
const Security_Detections_API_ThresholdRuleRequiredFields = z
  .object({
    query: Security_Detections_API_RuleQuery,
    threshold: Security_Detections_API_Threshold,
    type: z.literal('threshold'),
  })
  .passthrough();
const Security_Detections_API_ThresholdAlertSuppression = z
  .object({ duration: Security_Detections_API_AlertSuppressionDuration })
  .passthrough();
const Security_Detections_API_ThresholdRuleOptionalFields = z
  .object({
    alert_suppression: Security_Detections_API_ThresholdAlertSuppression,
    data_view_id: Security_Detections_API_DataViewId,
    filters: Security_Detections_API_RuleFilterArray,
    index: Security_Detections_API_IndexPatternArray,
    saved_id: Security_Detections_API_SavedQueryId,
  })
  .partial()
  .passthrough();
const Security_Detections_API_ThresholdRuleResponseFields =
  Security_Detections_API_ThresholdRuleRequiredFields.and(
    Security_Detections_API_ThresholdRuleOptionalFields
  ).and(z.object({ language: Security_Detections_API_KqlQueryLanguage }).passthrough());
const Security_Detections_API_ThresholdRule = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .passthrough()
  .and(Security_Detections_API_ResponseFields)
  .and(Security_Detections_API_ThresholdRuleResponseFields);
const Security_Detections_API_ThreatIndex = z.array(z.string());
const Security_Detections_API_ThreatMappingEntry = z
  .object({
    field: Security_Detections_API_NonEmptyString.min(1),
    negate: z.boolean().optional(),
    type: z.literal('mapping'),
    value: Security_Detections_API_NonEmptyString.min(1),
  })
  .passthrough();
const Security_Detections_API_ThreatMapping = z.array(
  z.object({ entries: z.array(Security_Detections_API_ThreatMappingEntry) }).passthrough()
);
const Security_Detections_API_ThreatQuery = z.string();
const Security_Detections_API_ThreatMatchRuleRequiredFields = z
  .object({
    query: Security_Detections_API_RuleQuery,
    threat_index: Security_Detections_API_ThreatIndex,
    threat_mapping: Security_Detections_API_ThreatMapping.min(1),
    threat_query: Security_Detections_API_ThreatQuery,
    type: z.literal('threat_match'),
  })
  .passthrough();
const Security_Detections_API_ConcurrentSearches = z.number();
const Security_Detections_API_ItemsPerSearch = z.number();
const Security_Detections_API_ThreatFilters = z.array(z.unknown());
const Security_Detections_API_ThreatIndicatorPath = z.string();
const Security_Detections_API_ThreatMatchRuleOptionalFields = z
  .object({
    alert_suppression: Security_Detections_API_AlertSuppression,
    concurrent_searches: Security_Detections_API_ConcurrentSearches.int().gte(1),
    data_view_id: Security_Detections_API_DataViewId,
    filters: Security_Detections_API_RuleFilterArray,
    index: Security_Detections_API_IndexPatternArray,
    items_per_search: Security_Detections_API_ItemsPerSearch.int().gte(1),
    saved_id: Security_Detections_API_SavedQueryId,
    threat_filters: Security_Detections_API_ThreatFilters,
    threat_indicator_path: Security_Detections_API_ThreatIndicatorPath,
    threat_language: Security_Detections_API_KqlQueryLanguage,
  })
  .partial()
  .passthrough();
const Security_Detections_API_ThreatMatchRuleResponseFields =
  Security_Detections_API_ThreatMatchRuleRequiredFields.and(
    Security_Detections_API_ThreatMatchRuleOptionalFields
  ).and(z.object({ language: Security_Detections_API_KqlQueryLanguage }).passthrough());
const Security_Detections_API_ThreatMatchRule = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .passthrough()
  .and(Security_Detections_API_ResponseFields)
  .and(Security_Detections_API_ThreatMatchRuleResponseFields);
const Security_Detections_API_AnomalyThreshold = z.number();
const Security_Detections_API_MachineLearningJobId = z.union([z.string(), z.array(z.string())]);
const Security_Detections_API_MachineLearningRuleRequiredFields = z
  .object({
    anomaly_threshold: Security_Detections_API_AnomalyThreshold.int().gte(0),
    machine_learning_job_id: Security_Detections_API_MachineLearningJobId,
    type: z.literal('machine_learning'),
  })
  .passthrough();
const Security_Detections_API_MachineLearningRuleOptionalFields = z
  .object({ alert_suppression: Security_Detections_API_AlertSuppression })
  .partial()
  .passthrough();
const Security_Detections_API_MachineLearningRuleResponseFields =
  Security_Detections_API_MachineLearningRuleRequiredFields.and(
    Security_Detections_API_MachineLearningRuleOptionalFields
  );
const Security_Detections_API_MachineLearningRule = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .passthrough()
  .and(Security_Detections_API_ResponseFields)
  .and(Security_Detections_API_MachineLearningRuleResponseFields);
const Security_Detections_API_HistoryWindowStart = z.string();
const Security_Detections_API_NewTermsFields = z.array(z.string());
const Security_Detections_API_NewTermsRuleRequiredFields = z
  .object({
    history_window_start: Security_Detections_API_HistoryWindowStart.min(1),
    new_terms_fields: Security_Detections_API_NewTermsFields.min(1).max(3),
    query: Security_Detections_API_RuleQuery,
    type: z.literal('new_terms'),
  })
  .passthrough();
const Security_Detections_API_NewTermsRuleOptionalFields = z
  .object({
    alert_suppression: Security_Detections_API_AlertSuppression,
    data_view_id: Security_Detections_API_DataViewId,
    filters: Security_Detections_API_RuleFilterArray,
    index: Security_Detections_API_IndexPatternArray,
  })
  .partial()
  .passthrough();
const Security_Detections_API_NewTermsRuleResponseFields =
  Security_Detections_API_NewTermsRuleRequiredFields.and(
    Security_Detections_API_NewTermsRuleOptionalFields
  ).and(z.object({ language: Security_Detections_API_KqlQueryLanguage }).passthrough());
const Security_Detections_API_NewTermsRule = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .passthrough()
  .and(Security_Detections_API_ResponseFields)
  .and(Security_Detections_API_NewTermsRuleResponseFields);
const Security_Detections_API_EsqlRuleOptionalFields = z
  .object({ alert_suppression: Security_Detections_API_AlertSuppression })
  .partial()
  .passthrough();
const Security_Detections_API_EsqlQueryLanguage = z.literal('esql');
const Security_Detections_API_EsqlRuleRequiredFields = z
  .object({
    language: Security_Detections_API_EsqlQueryLanguage,
    query: Security_Detections_API_RuleQuery,
    type: z.literal('esql'),
  })
  .passthrough();
const Security_Detections_API_EsqlRuleResponseFields =
  Security_Detections_API_EsqlRuleOptionalFields.and(
    Security_Detections_API_EsqlRuleRequiredFields
  );
const Security_Detections_API_EsqlRule = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .passthrough()
  .and(Security_Detections_API_ResponseFields)
  .and(Security_Detections_API_EsqlRuleResponseFields);
const Security_Detections_API_RuleResponse = z.union([
  Security_Detections_API_EqlRule,
  Security_Detections_API_QueryRule,
  Security_Detections_API_SavedQueryRule,
  Security_Detections_API_ThresholdRule,
  Security_Detections_API_ThreatMatchRule,
  Security_Detections_API_MachineLearningRule,
  Security_Detections_API_NewTermsRule,
  Security_Detections_API_EsqlRule,
]);
const Security_Detections_API_EqlRulePatchFields = z
  .object({
    language: Security_Detections_API_EqlQueryLanguage,
    query: Security_Detections_API_RuleQuery,
    type: z.literal('eql'),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_EqlOptionalFields);
const Security_Detections_API_EqlRulePatchProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose,
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId,
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType,
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    id: Security_Detections_API_RuleObjectId,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields,
    license: Security_Detections_API_RuleLicense,
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata,
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace,
    note: Security_Detections_API_InvestigationGuide,
    outcome: Security_Detections_API_SavedObjectResolveOutcome,
    output_index: Security_Detections_API_AlertsIndex,
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_id: Security_Detections_API_RuleSignatureId,
    rule_name_override: Security_Detections_API_RuleNameOverride,
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle,
    timeline_id: Security_Detections_API_TimelineTemplateId,
    timeline_title: Security_Detections_API_TimelineTemplateTitle,
    timestamp_override: Security_Detections_API_TimestampOverride,
    timestamp_override_fallback_disabled: Security_Detections_API_TimestampOverrideFallbackDisabled,
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_EqlRulePatchFields);
const Security_Detections_API_QueryRuleDefaultableFields = z
  .object({
    language: Security_Detections_API_KqlQueryLanguage,
    query: Security_Detections_API_RuleQuery,
  })
  .partial()
  .passthrough();
const Security_Detections_API_QueryRulePatchFields = z
  .object({ type: z.literal('query') })
  .partial()
  .passthrough()
  .and(Security_Detections_API_QueryRuleOptionalFields)
  .and(Security_Detections_API_QueryRuleDefaultableFields);
const Security_Detections_API_QueryRulePatchProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose,
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId,
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType,
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    id: Security_Detections_API_RuleObjectId,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields,
    license: Security_Detections_API_RuleLicense,
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata,
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace,
    note: Security_Detections_API_InvestigationGuide,
    outcome: Security_Detections_API_SavedObjectResolveOutcome,
    output_index: Security_Detections_API_AlertsIndex,
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_id: Security_Detections_API_RuleSignatureId,
    rule_name_override: Security_Detections_API_RuleNameOverride,
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle,
    timeline_id: Security_Detections_API_TimelineTemplateId,
    timeline_title: Security_Detections_API_TimelineTemplateTitle,
    timestamp_override: Security_Detections_API_TimestampOverride,
    timestamp_override_fallback_disabled: Security_Detections_API_TimestampOverrideFallbackDisabled,
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_QueryRulePatchFields);
const Security_Detections_API_SavedQueryRuleDefaultableFields = z
  .object({ language: Security_Detections_API_KqlQueryLanguage })
  .partial()
  .passthrough();
const Security_Detections_API_SavedQueryRulePatchFields = z
  .object({ saved_id: Security_Detections_API_SavedQueryId, type: z.literal('saved_query') })
  .partial()
  .passthrough()
  .and(Security_Detections_API_SavedQueryRuleOptionalFields)
  .and(Security_Detections_API_SavedQueryRuleDefaultableFields);
const Security_Detections_API_SavedQueryRulePatchProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose,
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId,
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType,
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    id: Security_Detections_API_RuleObjectId,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields,
    license: Security_Detections_API_RuleLicense,
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata,
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace,
    note: Security_Detections_API_InvestigationGuide,
    outcome: Security_Detections_API_SavedObjectResolveOutcome,
    output_index: Security_Detections_API_AlertsIndex,
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_id: Security_Detections_API_RuleSignatureId,
    rule_name_override: Security_Detections_API_RuleNameOverride,
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle,
    timeline_id: Security_Detections_API_TimelineTemplateId,
    timeline_title: Security_Detections_API_TimelineTemplateTitle,
    timestamp_override: Security_Detections_API_TimestampOverride,
    timestamp_override_fallback_disabled: Security_Detections_API_TimestampOverrideFallbackDisabled,
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_SavedQueryRulePatchFields);
const Security_Detections_API_ThresholdRuleDefaultableFields = z
  .object({ language: Security_Detections_API_KqlQueryLanguage })
  .partial()
  .passthrough();
const Security_Detections_API_ThresholdRulePatchFields = z
  .object({
    query: Security_Detections_API_RuleQuery,
    threshold: Security_Detections_API_Threshold,
    type: z.literal('threshold'),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_ThresholdRuleOptionalFields)
  .and(Security_Detections_API_ThresholdRuleDefaultableFields);
const Security_Detections_API_ThresholdRulePatchProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose,
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId,
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType,
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    id: Security_Detections_API_RuleObjectId,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields,
    license: Security_Detections_API_RuleLicense,
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata,
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace,
    note: Security_Detections_API_InvestigationGuide,
    outcome: Security_Detections_API_SavedObjectResolveOutcome,
    output_index: Security_Detections_API_AlertsIndex,
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_id: Security_Detections_API_RuleSignatureId,
    rule_name_override: Security_Detections_API_RuleNameOverride,
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle,
    timeline_id: Security_Detections_API_TimelineTemplateId,
    timeline_title: Security_Detections_API_TimelineTemplateTitle,
    timestamp_override: Security_Detections_API_TimestampOverride,
    timestamp_override_fallback_disabled: Security_Detections_API_TimestampOverrideFallbackDisabled,
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_ThresholdRulePatchFields);
const Security_Detections_API_ThreatMatchRuleDefaultableFields = z
  .object({ language: Security_Detections_API_KqlQueryLanguage })
  .partial()
  .passthrough();
const Security_Detections_API_ThreatMatchRulePatchFields = z
  .object({
    query: Security_Detections_API_RuleQuery,
    threat_index: Security_Detections_API_ThreatIndex,
    threat_mapping: Security_Detections_API_ThreatMapping.min(1),
    threat_query: Security_Detections_API_ThreatQuery,
    type: z.literal('threat_match'),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_ThreatMatchRuleOptionalFields)
  .and(Security_Detections_API_ThreatMatchRuleDefaultableFields);
const Security_Detections_API_ThreatMatchRulePatchProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose,
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId,
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType,
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    id: Security_Detections_API_RuleObjectId,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields,
    license: Security_Detections_API_RuleLicense,
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata,
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace,
    note: Security_Detections_API_InvestigationGuide,
    outcome: Security_Detections_API_SavedObjectResolveOutcome,
    output_index: Security_Detections_API_AlertsIndex,
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_id: Security_Detections_API_RuleSignatureId,
    rule_name_override: Security_Detections_API_RuleNameOverride,
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle,
    timeline_id: Security_Detections_API_TimelineTemplateId,
    timeline_title: Security_Detections_API_TimelineTemplateTitle,
    timestamp_override: Security_Detections_API_TimestampOverride,
    timestamp_override_fallback_disabled: Security_Detections_API_TimestampOverrideFallbackDisabled,
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_ThreatMatchRulePatchFields);
const Security_Detections_API_MachineLearningRulePatchFields = z
  .object({
    anomaly_threshold: Security_Detections_API_AnomalyThreshold.int().gte(0),
    machine_learning_job_id: Security_Detections_API_MachineLearningJobId,
    type: z.literal('machine_learning'),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_MachineLearningRuleOptionalFields);
const Security_Detections_API_MachineLearningRulePatchProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose,
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId,
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType,
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    id: Security_Detections_API_RuleObjectId,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields,
    license: Security_Detections_API_RuleLicense,
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata,
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace,
    note: Security_Detections_API_InvestigationGuide,
    outcome: Security_Detections_API_SavedObjectResolveOutcome,
    output_index: Security_Detections_API_AlertsIndex,
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_id: Security_Detections_API_RuleSignatureId,
    rule_name_override: Security_Detections_API_RuleNameOverride,
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle,
    timeline_id: Security_Detections_API_TimelineTemplateId,
    timeline_title: Security_Detections_API_TimelineTemplateTitle,
    timestamp_override: Security_Detections_API_TimestampOverride,
    timestamp_override_fallback_disabled: Security_Detections_API_TimestampOverrideFallbackDisabled,
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_MachineLearningRulePatchFields);
const Security_Detections_API_NewTermsRuleDefaultableFields = z
  .object({ language: Security_Detections_API_KqlQueryLanguage })
  .partial()
  .passthrough();
const Security_Detections_API_NewTermsRulePatchFields = z
  .object({
    history_window_start: Security_Detections_API_HistoryWindowStart.min(1),
    new_terms_fields: Security_Detections_API_NewTermsFields.min(1).max(3),
    query: Security_Detections_API_RuleQuery,
    type: z.literal('new_terms'),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_NewTermsRuleOptionalFields)
  .and(Security_Detections_API_NewTermsRuleDefaultableFields);
const Security_Detections_API_NewTermsRulePatchProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose,
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId,
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType,
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    id: Security_Detections_API_RuleObjectId,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields,
    license: Security_Detections_API_RuleLicense,
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata,
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace,
    note: Security_Detections_API_InvestigationGuide,
    outcome: Security_Detections_API_SavedObjectResolveOutcome,
    output_index: Security_Detections_API_AlertsIndex,
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_id: Security_Detections_API_RuleSignatureId,
    rule_name_override: Security_Detections_API_RuleNameOverride,
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle,
    timeline_id: Security_Detections_API_TimelineTemplateId,
    timeline_title: Security_Detections_API_TimelineTemplateTitle,
    timestamp_override: Security_Detections_API_TimestampOverride,
    timestamp_override_fallback_disabled: Security_Detections_API_TimestampOverrideFallbackDisabled,
    to: Security_Detections_API_RuleIntervalTo,
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_NewTermsRulePatchFields);
const Security_Detections_API_EsqlRulePatchProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose,
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId,
    author: Security_Detections_API_RuleAuthorArray,
    building_block_type: Security_Detections_API_BuildingBlockType,
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled,
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList),
    false_positives: Security_Detections_API_RuleFalsePositiveArray,
    from: Security_Detections_API_RuleIntervalFrom,
    id: Security_Detections_API_RuleObjectId,
    interval: Security_Detections_API_RuleInterval,
    investigation_fields: Security_Detections_API_InvestigationFields,
    language: Security_Detections_API_EsqlQueryLanguage,
    license: Security_Detections_API_RuleLicense,
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).default(100),
    meta: Security_Detections_API_RuleMetadata,
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace,
    note: Security_Detections_API_InvestigationGuide,
    outcome: Security_Detections_API_SavedObjectResolveOutcome,
    output_index: Security_Detections_API_AlertsIndex,
    query: Security_Detections_API_RuleQuery,
    references: Security_Detections_API_RuleReferenceArray,
    related_integrations: Security_Detections_API_RelatedIntegrationArray,
    required_fields: z.array(Security_Detections_API_RequiredFieldInput),
    response_actions: z.array(Security_Detections_API_ResponseAction),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping,
    rule_id: Security_Detections_API_RuleSignatureId,
    rule_name_override: Security_Detections_API_RuleNameOverride,
    setup: Security_Detections_API_SetupGuide,
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping,
    tags: Security_Detections_API_RuleTagArray,
    threat: Security_Detections_API_ThreatArray,
    throttle: Security_Detections_API_RuleActionThrottle,
    timeline_id: Security_Detections_API_TimelineTemplateId,
    timeline_title: Security_Detections_API_TimelineTemplateTitle,
    timestamp_override: Security_Detections_API_TimestampOverride,
    timestamp_override_fallback_disabled: Security_Detections_API_TimestampOverrideFallbackDisabled,
    to: Security_Detections_API_RuleIntervalTo,
    type: z.literal('esql'),
    version: Security_Detections_API_RuleVersion.int().gte(1),
  })
  .partial()
  .passthrough()
  .and(Security_Detections_API_EsqlRuleOptionalFields);
const Security_Detections_API_RulePatchProps = z.union([
  Security_Detections_API_EqlRulePatchProps,
  Security_Detections_API_QueryRulePatchProps,
  Security_Detections_API_SavedQueryRulePatchProps,
  Security_Detections_API_ThresholdRulePatchProps,
  Security_Detections_API_ThreatMatchRulePatchProps,
  Security_Detections_API_MachineLearningRulePatchProps,
  Security_Detections_API_NewTermsRulePatchProps,
  Security_Detections_API_EsqlRulePatchProps,
]);
const Security_Detections_API_EqlRuleCreateFields = Security_Detections_API_EqlRequiredFields.and(
  Security_Detections_API_EqlOptionalFields
);
const Security_Detections_API_EqlRuleCreateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_EqlRuleCreateFields);
const Security_Detections_API_QueryRuleCreateFields =
  Security_Detections_API_QueryRuleRequiredFields.and(
    Security_Detections_API_QueryRuleOptionalFields
  ).and(Security_Detections_API_QueryRuleDefaultableFields);
const Security_Detections_API_QueryRuleCreateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_QueryRuleCreateFields);
const Security_Detections_API_SavedQueryRuleCreateFields =
  Security_Detections_API_SavedQueryRuleRequiredFields.and(
    Security_Detections_API_SavedQueryRuleOptionalFields
  ).and(Security_Detections_API_SavedQueryRuleDefaultableFields);
const Security_Detections_API_SavedQueryRuleCreateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_SavedQueryRuleCreateFields);
const Security_Detections_API_ThresholdRuleCreateFields =
  Security_Detections_API_ThresholdRuleRequiredFields.and(
    Security_Detections_API_ThresholdRuleOptionalFields
  ).and(Security_Detections_API_ThresholdRuleDefaultableFields);
const Security_Detections_API_ThresholdRuleCreateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_ThresholdRuleCreateFields);
const Security_Detections_API_ThreatMatchRuleCreateFields =
  Security_Detections_API_ThreatMatchRuleRequiredFields.and(
    Security_Detections_API_ThreatMatchRuleOptionalFields
  ).and(Security_Detections_API_ThreatMatchRuleDefaultableFields);
const Security_Detections_API_ThreatMatchRuleCreateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_ThreatMatchRuleCreateFields);
const Security_Detections_API_MachineLearningRuleCreateFields =
  Security_Detections_API_MachineLearningRuleRequiredFields.and(
    Security_Detections_API_MachineLearningRuleOptionalFields
  );
const Security_Detections_API_MachineLearningRuleCreateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_MachineLearningRuleCreateFields);
const Security_Detections_API_NewTermsRuleCreateFields =
  Security_Detections_API_NewTermsRuleRequiredFields.and(
    Security_Detections_API_NewTermsRuleOptionalFields
  ).and(Security_Detections_API_NewTermsRuleDefaultableFields);
const Security_Detections_API_NewTermsRuleCreateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_NewTermsRuleCreateFields);
const Security_Detections_API_EsqlRuleCreateFields =
  Security_Detections_API_EsqlRuleOptionalFields.and(
    Security_Detections_API_EsqlRuleRequiredFields
  );
const Security_Detections_API_EsqlRuleCreateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_EsqlRuleCreateFields);
const Security_Detections_API_RuleCreateProps = z.union([
  Security_Detections_API_EqlRuleCreateProps,
  Security_Detections_API_QueryRuleCreateProps,
  Security_Detections_API_SavedQueryRuleCreateProps,
  Security_Detections_API_ThresholdRuleCreateProps,
  Security_Detections_API_ThreatMatchRuleCreateProps,
  Security_Detections_API_MachineLearningRuleCreateProps,
  Security_Detections_API_NewTermsRuleCreateProps,
  Security_Detections_API_EsqlRuleCreateProps,
]);
const Security_Detections_API_EqlRuleUpdateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    id: Security_Detections_API_RuleObjectId.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_EqlRuleCreateFields);
const Security_Detections_API_QueryRuleUpdateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    id: Security_Detections_API_RuleObjectId.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_QueryRuleCreateFields);
const Security_Detections_API_SavedQueryRuleUpdateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    id: Security_Detections_API_RuleObjectId.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_SavedQueryRuleCreateFields);
const Security_Detections_API_ThresholdRuleUpdateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    id: Security_Detections_API_RuleObjectId.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_ThresholdRuleCreateFields);
const Security_Detections_API_ThreatMatchRuleUpdateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    id: Security_Detections_API_RuleObjectId.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_ThreatMatchRuleCreateFields);
const Security_Detections_API_MachineLearningRuleUpdateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    id: Security_Detections_API_RuleObjectId.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_MachineLearningRuleCreateFields);
const Security_Detections_API_NewTermsRuleUpdateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    id: Security_Detections_API_RuleObjectId.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_NewTermsRuleCreateFields);
const Security_Detections_API_EsqlRuleUpdateProps = z
  .object({
    actions: z.array(Security_Detections_API_RuleAction).optional(),
    alias_purpose: Security_Detections_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: Security_Detections_API_SavedObjectResolveAliasTargetId.optional(),
    author: Security_Detections_API_RuleAuthorArray.optional(),
    building_block_type: Security_Detections_API_BuildingBlockType.optional(),
    description: Security_Detections_API_RuleDescription.min(1),
    enabled: Security_Detections_API_IsRuleEnabled.optional(),
    exceptions_list: z.array(Security_Detections_API_RuleExceptionList).optional(),
    false_positives: Security_Detections_API_RuleFalsePositiveArray.optional(),
    from: Security_Detections_API_RuleIntervalFrom.optional(),
    id: Security_Detections_API_RuleObjectId.optional(),
    interval: Security_Detections_API_RuleInterval.optional(),
    investigation_fields: Security_Detections_API_InvestigationFields.optional(),
    license: Security_Detections_API_RuleLicense.optional(),
    max_signals: Security_Detections_API_MaxSignals.int().gte(1).optional().default(100),
    meta: Security_Detections_API_RuleMetadata.optional(),
    name: Security_Detections_API_RuleName.min(1),
    namespace: Security_Detections_API_AlertsIndexNamespace.optional(),
    note: Security_Detections_API_InvestigationGuide.optional(),
    outcome: Security_Detections_API_SavedObjectResolveOutcome.optional(),
    output_index: Security_Detections_API_AlertsIndex.optional(),
    references: Security_Detections_API_RuleReferenceArray.optional(),
    related_integrations: Security_Detections_API_RelatedIntegrationArray.optional(),
    required_fields: z.array(Security_Detections_API_RequiredFieldInput).optional(),
    response_actions: z.array(Security_Detections_API_ResponseAction).optional(),
    risk_score: Security_Detections_API_RiskScore.int().gte(0).lte(100),
    risk_score_mapping: Security_Detections_API_RiskScoreMapping.optional(),
    rule_id: Security_Detections_API_RuleSignatureId.optional(),
    rule_name_override: Security_Detections_API_RuleNameOverride.optional(),
    setup: Security_Detections_API_SetupGuide.optional(),
    severity: Security_Detections_API_Severity,
    severity_mapping: Security_Detections_API_SeverityMapping.optional(),
    tags: Security_Detections_API_RuleTagArray.optional(),
    threat: Security_Detections_API_ThreatArray.optional(),
    throttle: Security_Detections_API_RuleActionThrottle.optional(),
    timeline_id: Security_Detections_API_TimelineTemplateId.optional(),
    timeline_title: Security_Detections_API_TimelineTemplateTitle.optional(),
    timestamp_override: Security_Detections_API_TimestampOverride.optional(),
    timestamp_override_fallback_disabled:
      Security_Detections_API_TimestampOverrideFallbackDisabled.optional(),
    to: Security_Detections_API_RuleIntervalTo.optional(),
    version: Security_Detections_API_RuleVersion.int().gte(1).optional(),
  })
  .passthrough()
  .and(Security_Detections_API_EsqlRuleCreateFields);
const Security_Detections_API_RuleUpdateProps = z.union([
  Security_Detections_API_EqlRuleUpdateProps,
  Security_Detections_API_QueryRuleUpdateProps,
  Security_Detections_API_SavedQueryRuleUpdateProps,
  Security_Detections_API_ThresholdRuleUpdateProps,
  Security_Detections_API_ThreatMatchRuleUpdateProps,
  Security_Detections_API_MachineLearningRuleUpdateProps,
  Security_Detections_API_NewTermsRuleUpdateProps,
  Security_Detections_API_EsqlRuleUpdateProps,
]);
const Security_Detections_API_BulkDeleteRules = z
  .object({
    action: z.literal('delete'),
    gaps_range_end: z.string().optional(),
    gaps_range_start: z.string().optional(),
    ids: z.array(z.string()).min(1).optional(),
    query: z.string().optional(),
  })
  .passthrough();
const Security_Detections_API_BulkDisableRules = z
  .object({
    action: z.literal('disable'),
    gaps_range_end: z.string().optional(),
    gaps_range_start: z.string().optional(),
    ids: z.array(z.string()).min(1).optional(),
    query: z.string().optional(),
  })
  .passthrough();
const Security_Detections_API_BulkEnableRules = z
  .object({
    action: z.literal('enable'),
    gaps_range_end: z.string().optional(),
    gaps_range_start: z.string().optional(),
    ids: z.array(z.string()).min(1).optional(),
    query: z.string().optional(),
  })
  .passthrough();
const Security_Detections_API_BulkExportRules = z
  .object({
    action: z.literal('export'),
    gaps_range_end: z.string().optional(),
    gaps_range_start: z.string().optional(),
    ids: z.array(z.string()).min(1).optional(),
    query: z.string().optional(),
  })
  .passthrough();
const Security_Detections_API_BulkDuplicateRules = z
  .object({
    action: z.literal('duplicate'),
    duplicate: z
      .object({ include_exceptions: z.boolean(), include_expired_exceptions: z.boolean() })
      .passthrough()
      .optional(),
    gaps_range_end: z.string().optional(),
    gaps_range_start: z.string().optional(),
    ids: z.array(z.string()).min(1).optional(),
    query: z.string().optional(),
  })
  .passthrough();
const Security_Detections_API_BulkManualRuleRun = z
  .object({
    action: z.literal('run'),
    gaps_range_end: z.string().optional(),
    gaps_range_start: z.string().optional(),
    ids: z.array(z.string()).min(1).optional(),
    query: z.string().optional(),
    run: z.object({ end_date: z.string(), start_date: z.string() }).passthrough(),
  })
  .passthrough();
const Security_Detections_API_BulkManualRuleFillGaps = z
  .object({
    action: z.literal('fill_gaps'),
    fill_gaps: z.object({ end_date: z.string(), start_date: z.string() }).passthrough(),
    gaps_range_end: z.string().optional(),
    gaps_range_start: z.string().optional(),
    ids: z.array(z.string()).min(1).optional(),
    query: z.string().optional(),
  })
  .passthrough();
const Security_Detections_API_BulkActionEditPayloadTags = z
  .object({
    type: z.enum(['add_tags', 'delete_tags', 'set_tags']),
    value: Security_Detections_API_RuleTagArray,
  })
  .passthrough();
const Security_Detections_API_BulkActionEditPayloadIndexPatterns = z
  .object({
    overwrite_data_views: z.boolean().optional(),
    type: z.enum(['add_index_patterns', 'delete_index_patterns', 'set_index_patterns']),
    value: Security_Detections_API_IndexPatternArray,
  })
  .passthrough();
const Security_Detections_API_BulkActionEditPayloadInvestigationFields = z
  .object({
    type: z.enum([
      'add_investigation_fields',
      'delete_investigation_fields',
      'set_investigation_fields',
    ]),
    value: Security_Detections_API_InvestigationFields,
  })
  .passthrough();
const Security_Detections_API_BulkActionEditPayloadTimeline = z
  .object({
    type: z.literal('set_timeline'),
    value: z
      .object({
        timeline_id: Security_Detections_API_TimelineTemplateId,
        timeline_title: Security_Detections_API_TimelineTemplateTitle,
      })
      .passthrough(),
  })
  .passthrough();
const Security_Detections_API_NormalizedRuleAction = z.object({
  alerts_filter: Security_Detections_API_RuleActionAlertsFilter.optional(),
  frequency: Security_Detections_API_RuleActionFrequency.optional(),
  group: Security_Detections_API_RuleActionGroup.optional(),
  id: Security_Detections_API_RuleActionId,
  params: Security_Detections_API_RuleActionParams,
});
const Security_Detections_API_ThrottleForBulkActions = z.enum(['rule', '1h', '1d', '7d']);
const Security_Detections_API_BulkActionEditPayloadRuleActions = z
  .object({
    type: z.enum(['add_rule_actions', 'set_rule_actions']),
    value: z
      .object({
        actions: z.array(Security_Detections_API_NormalizedRuleAction),
        throttle: Security_Detections_API_ThrottleForBulkActions.optional(),
      })
      .passthrough(),
  })
  .passthrough();
const Security_Detections_API_BulkActionEditPayloadSchedule = z
  .object({
    type: z.literal('set_schedule'),
    value: z
      .object({
        interval: z.string().regex(/^[1-9]\d*[smh]$/),
        lookback: z.string().regex(/^[1-9]\d*[smh]$/),
      })
      .passthrough(),
  })
  .passthrough();
const Security_Detections_API_BulkActionEditPayloadSetAlertSuppression = z
  .object({
    type: z.literal('set_alert_suppression'),
    value: Security_Detections_API_AlertSuppression,
  })
  .passthrough();
const Security_Detections_API_BulkActionEditPayloadSetAlertSuppressionForThreshold = z
  .object({
    type: z.literal('set_alert_suppression_for_threshold'),
    value: Security_Detections_API_ThresholdAlertSuppression,
  })
  .passthrough();
const Security_Detections_API_BulkActionEditPayloadDeleteAlertSuppression = z
  .object({ type: z.literal('delete_alert_suppression') })
  .passthrough();
const Security_Detections_API_BulkActionEditPayloadAlertSuppression = z.union([
  Security_Detections_API_BulkActionEditPayloadSetAlertSuppression,
  Security_Detections_API_BulkActionEditPayloadSetAlertSuppressionForThreshold,
  Security_Detections_API_BulkActionEditPayloadDeleteAlertSuppression,
]);
const Security_Detections_API_BulkActionEditPayload = z.union([
  Security_Detections_API_BulkActionEditPayloadTags,
  Security_Detections_API_BulkActionEditPayloadIndexPatterns,
  Security_Detections_API_BulkActionEditPayloadInvestigationFields,
  Security_Detections_API_BulkActionEditPayloadTimeline,
  Security_Detections_API_BulkActionEditPayloadRuleActions,
  Security_Detections_API_BulkActionEditPayloadSchedule,
  Security_Detections_API_BulkActionEditPayloadAlertSuppression,
]);
const Security_Detections_API_BulkEditRules = z
  .object({
    action: z.literal('edit'),
    edit: z.array(Security_Detections_API_BulkActionEditPayload).min(1),
    gaps_range_end: z.string().optional(),
    gaps_range_start: z.string().optional(),
    ids: z.array(z.string()).min(1).optional(),
    query: z.string().optional(),
  })
  .passthrough();
const PerformRulesBulkAction_Body = z.union([
  Security_Detections_API_BulkDeleteRules,
  Security_Detections_API_BulkDisableRules,
  Security_Detections_API_BulkEnableRules,
  Security_Detections_API_BulkExportRules,
  Security_Detections_API_BulkDuplicateRules,
  Security_Detections_API_BulkManualRuleRun,
  Security_Detections_API_BulkManualRuleFillGaps,
  Security_Detections_API_BulkEditRules,
]);
const Security_Detections_API_BulkActionsDryRunErrCode = z.enum([
  'IMMUTABLE',
  'PREBUILT_CUSTOMIZATION_LICENSE',
  'MACHINE_LEARNING_AUTH',
  'MACHINE_LEARNING_INDEX_PATTERN',
  'ESQL_INDEX_PATTERN',
  'MANUAL_RULE_RUN_FEATURE',
  'MANUAL_RULE_RUN_DISABLED_RULE',
  'THRESHOLD_RULE_TYPE_IN_SUPPRESSION',
  'UNSUPPORTED_RULE_IN_SUPPRESSION_FOR_THRESHOLD',
  'RULE_FILL_GAPS_DISABLED_RULE',
]);
const Security_Detections_API_RuleDetailsInError = z
  .object({ id: z.string(), name: z.string().optional() })
  .passthrough();
const Security_Detections_API_NormalizedRuleError = z
  .object({
    err_code: Security_Detections_API_BulkActionsDryRunErrCode.optional(),
    message: z.string(),
    rules: z.array(Security_Detections_API_RuleDetailsInError),
    status_code: z.number().int(),
  })
  .passthrough();
const Security_Detections_API_BulkEditSkipReason = z.literal('RULE_NOT_MODIFIED');
const Security_Detections_API_BulkGapsFillingSkipReason = z.literal('NO_GAPS_TO_FILL');
const Security_Detections_API_BulkActionSkipResult = z
  .object({
    id: z.string(),
    name: z.string().optional(),
    skip_reason: z.union([
      Security_Detections_API_BulkEditSkipReason,
      Security_Detections_API_BulkGapsFillingSkipReason,
    ]),
  })
  .passthrough();
const Security_Detections_API_BulkEditActionResults = z
  .object({
    created: z.array(Security_Detections_API_RuleResponse),
    deleted: z.array(Security_Detections_API_RuleResponse),
    skipped: z.array(Security_Detections_API_BulkActionSkipResult),
    updated: z.array(Security_Detections_API_RuleResponse),
  })
  .passthrough();
const Security_Detections_API_BulkEditActionSummary = z
  .object({
    failed: z.number().int(),
    skipped: z.number().int(),
    succeeded: z.number().int(),
    total: z.number().int(),
  })
  .passthrough();
const Security_Detections_API_BulkEditActionResponse = z
  .object({
    attributes: z
      .object({
        errors: z.array(Security_Detections_API_NormalizedRuleError).optional(),
        results: Security_Detections_API_BulkEditActionResults,
        summary: Security_Detections_API_BulkEditActionSummary,
      })
      .passthrough(),
    message: z.string().optional(),
    rules_count: z.number().int().optional(),
    status_code: z.number().int().optional(),
    success: z.boolean().optional(),
  })
  .passthrough();
const Security_Detections_API_BulkExportActionResponse = z.string();
const ExportRules_Body = z
  .object({
    objects: z.array(z.object({ rule_id: Security_Detections_API_RuleSignatureId }).passthrough()),
  })
  .passthrough();
const Security_Detections_API_ErrorSchema = z.object({
  error: z.object({ message: z.string(), status_code: z.number().int().gte(400) }).passthrough(),
  id: z.string().optional(),
  item_id: z.string().min(1).optional(),
  list_id: z.string().min(1).optional(),
  rule_id: Security_Detections_API_RuleSignatureId.optional(),
});
const Security_Detections_API_WarningSchema = z
  .object({
    actionPath: z.string(),
    buttonLabel: z.string().optional(),
    message: z.string(),
    type: z.string(),
  })
  .passthrough();
const Security_Exceptions_API_NonEmptyString = z.string();
const Security_Exceptions_API_CreateRuleExceptionListItemComment = z
  .object({ comment: Security_Exceptions_API_NonEmptyString.min(1) })
  .passthrough();
const Security_Exceptions_API_CreateRuleExceptionListItemCommentArray = z.array(
  Security_Exceptions_API_CreateRuleExceptionListItemComment
);
const Security_Exceptions_API_ExceptionListItemDescription = z.string();
const Security_Exceptions_API_ExceptionListItemEntryOperator = z.enum(['excluded', 'included']);
const Security_Exceptions_API_ExceptionListItemEntryMatch = z
  .object({
    field: Security_Exceptions_API_NonEmptyString.min(1),
    operator: Security_Exceptions_API_ExceptionListItemEntryOperator,
    type: z.literal('match'),
    value: Security_Exceptions_API_NonEmptyString.min(1),
  })
  .passthrough();
const Security_Exceptions_API_ExceptionListItemEntryMatchAny = z
  .object({
    field: Security_Exceptions_API_NonEmptyString.min(1),
    operator: Security_Exceptions_API_ExceptionListItemEntryOperator,
    type: z.literal('match_any'),
    value: z.array(Security_Exceptions_API_NonEmptyString).min(1),
  })
  .passthrough();
const Security_Exceptions_API_ListId = z.string();
const Security_Exceptions_API_ListType = z.enum([
  'binary',
  'boolean',
  'byte',
  'date',
  'date_nanos',
  'date_range',
  'double',
  'double_range',
  'float',
  'float_range',
  'geo_point',
  'geo_shape',
  'half_float',
  'integer',
  'integer_range',
  'ip',
  'ip_range',
  'keyword',
  'long',
  'long_range',
  'shape',
  'short',
  'text',
]);
const Security_Exceptions_API_ExceptionListItemEntryList = z
  .object({
    field: Security_Exceptions_API_NonEmptyString.min(1),
    list: z
      .object({ id: Security_Exceptions_API_ListId.min(1), type: Security_Exceptions_API_ListType })
      .passthrough(),
    operator: Security_Exceptions_API_ExceptionListItemEntryOperator,
    type: z.literal('list'),
  })
  .passthrough();
const Security_Exceptions_API_ExceptionListItemEntryExists = z
  .object({
    field: Security_Exceptions_API_NonEmptyString.min(1),
    operator: Security_Exceptions_API_ExceptionListItemEntryOperator,
    type: z.literal('exists'),
  })
  .passthrough();
const Security_Exceptions_API_ExceptionListItemEntryNestedEntryItem = z.union([
  Security_Exceptions_API_ExceptionListItemEntryMatch,
  Security_Exceptions_API_ExceptionListItemEntryMatchAny,
  Security_Exceptions_API_ExceptionListItemEntryExists,
]);
const Security_Exceptions_API_ExceptionListItemEntryNested = z
  .object({
    entries: z.array(Security_Exceptions_API_ExceptionListItemEntryNestedEntryItem).min(1),
    field: Security_Exceptions_API_NonEmptyString.min(1),
    type: z.literal('nested'),
  })
  .passthrough();
const Security_Exceptions_API_ExceptionListItemEntryMatchWildcard = z
  .object({
    field: Security_Exceptions_API_NonEmptyString.min(1),
    operator: Security_Exceptions_API_ExceptionListItemEntryOperator,
    type: z.literal('wildcard'),
    value: Security_Exceptions_API_NonEmptyString.min(1),
  })
  .passthrough();
const Security_Exceptions_API_ExceptionListItemEntry = z.union([
  Security_Exceptions_API_ExceptionListItemEntryMatch,
  Security_Exceptions_API_ExceptionListItemEntryMatchAny,
  Security_Exceptions_API_ExceptionListItemEntryList,
  Security_Exceptions_API_ExceptionListItemEntryExists,
  Security_Exceptions_API_ExceptionListItemEntryNested,
  Security_Exceptions_API_ExceptionListItemEntryMatchWildcard,
]);
const Security_Exceptions_API_ExceptionListItemEntryArray = z.array(
  Security_Exceptions_API_ExceptionListItemEntry
);
const Security_Exceptions_API_ExceptionListItemHumanId = z.string();
const Security_Exceptions_API_ExceptionListItemMeta = z.object({}).partial().passthrough();
const Security_Exceptions_API_ExceptionListItemName = z.string();
const Security_Exceptions_API_ExceptionNamespaceType = z.enum(['agnostic', 'single']);
const Security_Exceptions_API_ExceptionListOsType = z.enum(['linux', 'macos', 'windows']);
const Security_Exceptions_API_ExceptionListItemOsTypeArray = z.array(
  Security_Exceptions_API_ExceptionListOsType
);
const Security_Exceptions_API_ExceptionListItemTags = z.array(z.string().min(1));
const Security_Exceptions_API_ExceptionListItemType = z.literal('simple');
const Security_Exceptions_API_CreateRuleExceptionListItemProps = z
  .object({
    comments: Security_Exceptions_API_CreateRuleExceptionListItemCommentArray.optional(),
    description: Security_Exceptions_API_ExceptionListItemDescription,
    entries: Security_Exceptions_API_ExceptionListItemEntryArray,
    expire_time: z.string().datetime({ offset: true }).optional(),
    item_id: Security_Exceptions_API_ExceptionListItemHumanId.min(1).optional(),
    meta: Security_Exceptions_API_ExceptionListItemMeta.optional(),
    name: Security_Exceptions_API_ExceptionListItemName.min(1),
    namespace_type: Security_Exceptions_API_ExceptionNamespaceType.optional(),
    os_types: Security_Exceptions_API_ExceptionListItemOsTypeArray.optional(),
    tags: Security_Exceptions_API_ExceptionListItemTags.optional(),
    type: Security_Exceptions_API_ExceptionListItemType,
  })
  .passthrough();
const CreateRuleExceptionListItems_Body = z
  .object({ items: z.array(Security_Exceptions_API_CreateRuleExceptionListItemProps) })
  .passthrough();
const Security_Exceptions_API_ExceptionListItemComment = z
  .object({
    comment: Security_Exceptions_API_NonEmptyString.min(1),
    created_at: z.string().datetime({ offset: true }),
    created_by: Security_Exceptions_API_NonEmptyString.min(1),
    id: Security_Exceptions_API_NonEmptyString.min(1),
    updated_at: z.string().datetime({ offset: true }).optional(),
    updated_by: Security_Exceptions_API_NonEmptyString.min(1).optional(),
  })
  .passthrough();
const Security_Exceptions_API_ExceptionListItemCommentArray = z.array(
  Security_Exceptions_API_ExceptionListItemComment
);
const Security_Exceptions_API_ExceptionListItemExpireTime = z.string();
const Security_Exceptions_API_ExceptionListItemId = z.string();
const Security_Exceptions_API_ExceptionListHumanId = z.string();
const Security_Exceptions_API_ExceptionListItem = z
  .object({
    _version: z.string().optional(),
    comments: Security_Exceptions_API_ExceptionListItemCommentArray,
    created_at: z.string().datetime({ offset: true }),
    created_by: z.string(),
    description: Security_Exceptions_API_ExceptionListItemDescription,
    entries: Security_Exceptions_API_ExceptionListItemEntryArray,
    expire_time: Security_Exceptions_API_ExceptionListItemExpireTime.datetime({
      offset: true,
    }).optional(),
    id: Security_Exceptions_API_ExceptionListItemId.min(1),
    item_id: Security_Exceptions_API_ExceptionListItemHumanId.min(1),
    list_id: Security_Exceptions_API_ExceptionListHumanId.min(1),
    meta: Security_Exceptions_API_ExceptionListItemMeta.optional(),
    name: Security_Exceptions_API_ExceptionListItemName.min(1),
    namespace_type: Security_Exceptions_API_ExceptionNamespaceType,
    os_types: Security_Exceptions_API_ExceptionListItemOsTypeArray.optional(),
    tags: Security_Exceptions_API_ExceptionListItemTags.optional(),
    tie_breaker_id: z.string(),
    type: Security_Exceptions_API_ExceptionListItemType,
    updated_at: z.string().datetime({ offset: true }),
    updated_by: z.string(),
  })
  .passthrough();
const Security_Exceptions_API_PlatformErrorResponse = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number().int() })
  .passthrough();
const Security_Exceptions_API_SiemErrorResponse = z
  .object({ message: z.string(), status_code: z.number().int() })
  .passthrough();
const Security_Detections_API_RulePreviewParams = z
  .object({
    invocationCount: z.number().int(),
    timeframeEnd: z.string().datetime({ offset: true }),
  })
  .passthrough();
const RulePreview_Body = z.union([
  Security_Detections_API_EqlRuleCreateProps.and(Security_Detections_API_RulePreviewParams),
  Security_Detections_API_QueryRuleCreateProps.and(Security_Detections_API_RulePreviewParams),
  Security_Detections_API_SavedQueryRuleCreateProps.and(Security_Detections_API_RulePreviewParams),
  Security_Detections_API_ThresholdRuleCreateProps.and(Security_Detections_API_RulePreviewParams),
  Security_Detections_API_ThreatMatchRuleCreateProps.and(Security_Detections_API_RulePreviewParams),
  Security_Detections_API_MachineLearningRuleCreateProps.and(
    Security_Detections_API_RulePreviewParams
  ),
  Security_Detections_API_NewTermsRuleCreateProps.and(Security_Detections_API_RulePreviewParams),
  Security_Detections_API_EsqlRuleCreateProps.and(Security_Detections_API_RulePreviewParams),
]);
const Security_Detections_API_RulePreviewLoggedRequest = z
  .object({
    description: Security_Detections_API_NonEmptyString.min(1),
    duration: z.number().int(),
    request: Security_Detections_API_NonEmptyString.min(1),
    request_type: Security_Detections_API_NonEmptyString.min(1),
  })
  .partial()
  .passthrough();
const Security_Detections_API_RulePreviewLogs = z
  .object({
    duration: z.number().int(),
    errors: z.array(Security_Detections_API_NonEmptyString),
    requests: z.array(Security_Detections_API_RulePreviewLoggedRequest).optional(),
    startedAt: Security_Detections_API_NonEmptyString.min(1).optional(),
    warnings: z.array(Security_Detections_API_NonEmptyString),
  })
  .passthrough();
const Security_Detections_API_AlertAssignees = z
  .object({ add: z.array(z.string().min(1)), remove: z.array(z.string().min(1)) })
  .passthrough();
const Security_Detections_API_AlertIds = z.array(z.string().min(1));
const SetAlertAssignees_Body = z
  .object({
    assignees: Security_Detections_API_AlertAssignees,
    ids: Security_Detections_API_AlertIds.min(1),
  })
  .passthrough();
const Security_Detections_API_AlertsSortCombinations = z.union([
  z.string(),
  z.object({}).partial().passthrough(),
]);
const Security_Detections_API_AlertsSort = z.union([
  Security_Detections_API_AlertsSortCombinations,
  z.array(Security_Detections_API_AlertsSortCombinations),
]);
const SearchAlerts_Body = z
  .object({
    _source: z.union([z.boolean(), z.string(), z.array(z.string())]),
    aggs: z.object({}).partial().passthrough(),
    fields: z.array(z.string()),
    query: z.object({}).partial().passthrough(),
    runtime_mappings: z.object({}).partial().passthrough(),
    size: z.number().int().gte(0),
    sort: Security_Detections_API_AlertsSort,
    track_total_hits: z.boolean(),
  })
  .partial()
  .passthrough();
const Security_Detections_API_AlertStatus = z.enum([
  'open',
  'closed',
  'acknowledged',
  'in-progress',
]);
const Security_Detections_API_SetAlertsStatusByIds = z
  .object({
    signal_ids: z.array(z.string().min(1)).min(1),
    status: Security_Detections_API_AlertStatus,
  })
  .passthrough();
const Security_Detections_API_SetAlertsStatusByQuery = z
  .object({
    conflicts: z.enum(['abort', 'proceed']).optional().default('abort'),
    query: z.object({}).partial().passthrough(),
    status: Security_Detections_API_AlertStatus,
  })
  .passthrough();
const SetAlertsStatus_Body = z.union([
  Security_Detections_API_SetAlertsStatusByIds,
  Security_Detections_API_SetAlertsStatusByQuery,
]);
const Security_Detections_API_AlertTag = z.string();
const Security_Detections_API_AlertTags = z.array(Security_Detections_API_AlertTag);
const Security_Detections_API_SetAlertTags = z
  .object({
    tags_to_add: Security_Detections_API_AlertTags,
    tags_to_remove: Security_Detections_API_AlertTags,
  })
  .passthrough();
const SetAlertTags_Body = z
  .object({
    ids: Security_Detections_API_AlertIds.min(1),
    tags: Security_Detections_API_SetAlertTags,
  })
  .passthrough();
const Saved_objects_400_response = z
  .object({ error: z.literal('Bad Request'), message: z.string(), statusCode: z.literal(400) })
  .passthrough();
const Security_Endpoint_Exceptions_API_ExceptionListDescription = z.string();
const Security_Endpoint_Exceptions_API_ExceptionListId = z.string();
const Security_Endpoint_Exceptions_API_ExceptionListHumanId = z.string();
const Security_Endpoint_Exceptions_API_ExceptionListMeta = z.object({}).partial().passthrough();
const Security_Endpoint_Exceptions_API_ExceptionListName = z.string();
const Security_Endpoint_Exceptions_API_ExceptionNamespaceType = z.enum(['agnostic', 'single']);
const Security_Endpoint_Exceptions_API_ExceptionListOsType = z.enum(['linux', 'macos', 'windows']);
const Security_Endpoint_Exceptions_API_ExceptionListOsTypeArray = z.array(
  Security_Endpoint_Exceptions_API_ExceptionListOsType
);
const Security_Endpoint_Exceptions_API_ExceptionListTags = z.array(z.string());
const Security_Endpoint_Exceptions_API_ExceptionListType = z.enum([
  'detection',
  'rule_default',
  'endpoint',
  'endpoint_trusted_apps',
  'endpoint_trusted_devices',
  'endpoint_events',
  'endpoint_host_isolation_exceptions',
  'endpoint_blocklists',
]);
const Security_Endpoint_Exceptions_API_ExceptionListVersion = z.number();
const Security_Endpoint_Exceptions_API_ExceptionList = z
  .object({
    _version: z.string().optional(),
    created_at: z.string().datetime({ offset: true }),
    created_by: z.string(),
    description: Security_Endpoint_Exceptions_API_ExceptionListDescription,
    id: Security_Endpoint_Exceptions_API_ExceptionListId.min(1),
    immutable: z.boolean(),
    list_id: Security_Endpoint_Exceptions_API_ExceptionListHumanId.min(1),
    meta: Security_Endpoint_Exceptions_API_ExceptionListMeta.optional(),
    name: Security_Endpoint_Exceptions_API_ExceptionListName,
    namespace_type: Security_Endpoint_Exceptions_API_ExceptionNamespaceType,
    os_types: Security_Endpoint_Exceptions_API_ExceptionListOsTypeArray.optional(),
    tags: Security_Endpoint_Exceptions_API_ExceptionListTags.optional(),
    tie_breaker_id: z.string(),
    type: Security_Endpoint_Exceptions_API_ExceptionListType,
    updated_at: z.string().datetime({ offset: true }),
    updated_by: z.string(),
    version: Security_Endpoint_Exceptions_API_ExceptionListVersion.int().gte(1),
  })
  .passthrough();
const Security_Endpoint_Exceptions_API_EndpointList = z.union([
  Security_Endpoint_Exceptions_API_ExceptionList,
  z.object({}).partial(),
]);
const Security_Endpoint_Exceptions_API_PlatformErrorResponse = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number().int() })
  .passthrough();
const Security_Endpoint_Exceptions_API_SiemErrorResponse = z
  .object({ message: z.string(), status_code: z.number().int() })
  .passthrough();
const Security_Endpoint_Exceptions_API_NonEmptyString = z.string();
const Security_Endpoint_Exceptions_API_ExceptionListItemComment = z
  .object({
    comment: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
    created_at: z.string().datetime({ offset: true }),
    created_by: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
    id: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
    updated_at: z.string().datetime({ offset: true }).optional(),
    updated_by: Security_Endpoint_Exceptions_API_NonEmptyString.min(1).optional(),
  })
  .passthrough();
const Security_Endpoint_Exceptions_API_ExceptionListItemCommentArray = z.array(
  Security_Endpoint_Exceptions_API_ExceptionListItemComment
);
const Security_Endpoint_Exceptions_API_ExceptionListItemDescription = z.string();
const Security_Endpoint_Exceptions_API_ExceptionListItemEntryOperator = z.enum([
  'excluded',
  'included',
]);
const Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatch = z
  .object({
    field: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
    operator: Security_Endpoint_Exceptions_API_ExceptionListItemEntryOperator,
    type: z.literal('match'),
    value: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
  })
  .passthrough();
const Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatchAny = z
  .object({
    field: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
    operator: Security_Endpoint_Exceptions_API_ExceptionListItemEntryOperator,
    type: z.literal('match_any'),
    value: z.array(Security_Endpoint_Exceptions_API_NonEmptyString).min(1),
  })
  .passthrough();
const Security_Endpoint_Exceptions_API_ListId = z.string();
const Security_Endpoint_Exceptions_API_ListType = z.enum([
  'binary',
  'boolean',
  'byte',
  'date',
  'date_nanos',
  'date_range',
  'double',
  'double_range',
  'float',
  'float_range',
  'geo_point',
  'geo_shape',
  'half_float',
  'integer',
  'integer_range',
  'ip',
  'ip_range',
  'keyword',
  'long',
  'long_range',
  'shape',
  'short',
  'text',
]);
const Security_Endpoint_Exceptions_API_ExceptionListItemEntryList = z
  .object({
    field: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
    list: z
      .object({
        id: Security_Endpoint_Exceptions_API_ListId.min(1),
        type: Security_Endpoint_Exceptions_API_ListType,
      })
      .passthrough(),
    operator: Security_Endpoint_Exceptions_API_ExceptionListItemEntryOperator,
    type: z.literal('list'),
  })
  .passthrough();
const Security_Endpoint_Exceptions_API_ExceptionListItemEntryExists = z
  .object({
    field: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
    operator: Security_Endpoint_Exceptions_API_ExceptionListItemEntryOperator,
    type: z.literal('exists'),
  })
  .passthrough();
const Security_Endpoint_Exceptions_API_ExceptionListItemEntryNestedEntryItem = z.union([
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatch,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatchAny,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryExists,
]);
const Security_Endpoint_Exceptions_API_ExceptionListItemEntryNested = z
  .object({
    entries: z.array(Security_Endpoint_Exceptions_API_ExceptionListItemEntryNestedEntryItem).min(1),
    field: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
    type: z.literal('nested'),
  })
  .passthrough();
const Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatchWildcard = z
  .object({
    field: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
    operator: Security_Endpoint_Exceptions_API_ExceptionListItemEntryOperator,
    type: z.literal('wildcard'),
    value: Security_Endpoint_Exceptions_API_NonEmptyString.min(1),
  })
  .passthrough();
const Security_Endpoint_Exceptions_API_ExceptionListItemEntry = z.union([
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatch,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatchAny,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryList,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryExists,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryNested,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatchWildcard,
]);
const Security_Endpoint_Exceptions_API_ExceptionListItemEntryArray = z.array(
  Security_Endpoint_Exceptions_API_ExceptionListItemEntry
);
const Security_Endpoint_Exceptions_API_ExceptionListItemExpireTime = z.string();
const Security_Endpoint_Exceptions_API_ExceptionListItemId = z.string();
const Security_Endpoint_Exceptions_API_ExceptionListItemHumanId = z.string();
const Security_Endpoint_Exceptions_API_ExceptionListItemMeta = z.object({}).partial().passthrough();
const Security_Endpoint_Exceptions_API_ExceptionListItemName = z.string();
const Security_Endpoint_Exceptions_API_ExceptionListItemOsTypeArray = z.array(
  Security_Endpoint_Exceptions_API_ExceptionListOsType
);
const Security_Endpoint_Exceptions_API_ExceptionListItemTags = z.array(z.string().min(1));
const Security_Endpoint_Exceptions_API_ExceptionListItemType = z.literal('simple');
const Security_Endpoint_Exceptions_API_ExceptionListItem = z
  .object({
    _version: z.string().optional(),
    comments: Security_Endpoint_Exceptions_API_ExceptionListItemCommentArray,
    created_at: z.string().datetime({ offset: true }),
    created_by: z.string(),
    description: Security_Endpoint_Exceptions_API_ExceptionListItemDescription,
    entries: Security_Endpoint_Exceptions_API_ExceptionListItemEntryArray,
    expire_time: Security_Endpoint_Exceptions_API_ExceptionListItemExpireTime.datetime({
      offset: true,
    }).optional(),
    id: Security_Endpoint_Exceptions_API_ExceptionListItemId.min(1),
    item_id: Security_Endpoint_Exceptions_API_ExceptionListItemHumanId.min(1),
    list_id: Security_Endpoint_Exceptions_API_ExceptionListHumanId.min(1),
    meta: Security_Endpoint_Exceptions_API_ExceptionListItemMeta.optional(),
    name: Security_Endpoint_Exceptions_API_ExceptionListItemName.min(1),
    namespace_type: Security_Endpoint_Exceptions_API_ExceptionNamespaceType,
    os_types: Security_Endpoint_Exceptions_API_ExceptionListItemOsTypeArray.optional(),
    tags: Security_Endpoint_Exceptions_API_ExceptionListItemTags.optional(),
    tie_breaker_id: z.string(),
    type: Security_Endpoint_Exceptions_API_ExceptionListItemType,
    updated_at: z.string().datetime({ offset: true }),
    updated_by: z.string(),
  })
  .passthrough();
const CreateEndpointListItem_Body = z
  .object({
    comments: Security_Endpoint_Exceptions_API_ExceptionListItemCommentArray.optional(),
    description: Security_Endpoint_Exceptions_API_ExceptionListItemDescription,
    entries: Security_Endpoint_Exceptions_API_ExceptionListItemEntryArray,
    item_id: Security_Endpoint_Exceptions_API_ExceptionListItemHumanId.min(1).optional(),
    meta: Security_Endpoint_Exceptions_API_ExceptionListItemMeta.optional(),
    name: Security_Endpoint_Exceptions_API_ExceptionListItemName.min(1),
    os_types: Security_Endpoint_Exceptions_API_ExceptionListItemOsTypeArray.optional(),
    tags: Security_Endpoint_Exceptions_API_ExceptionListItemTags.optional(),
    type: Security_Endpoint_Exceptions_API_ExceptionListItemType,
  })
  .passthrough();
const UpdateEndpointListItem_Body = z
  .object({
    _version: z.string().optional(),
    comments: Security_Endpoint_Exceptions_API_ExceptionListItemCommentArray.optional(),
    description: Security_Endpoint_Exceptions_API_ExceptionListItemDescription,
    entries: Security_Endpoint_Exceptions_API_ExceptionListItemEntryArray,
    id: Security_Endpoint_Exceptions_API_ExceptionListItemId.min(1).optional(),
    item_id: Security_Endpoint_Exceptions_API_ExceptionListItemHumanId.min(1).optional(),
    meta: Security_Endpoint_Exceptions_API_ExceptionListItemMeta.optional(),
    name: Security_Endpoint_Exceptions_API_ExceptionListItemName.min(1),
    os_types: Security_Endpoint_Exceptions_API_ExceptionListItemOsTypeArray.optional(),
    tags: Security_Endpoint_Exceptions_API_ExceptionListItemTags.optional(),
    type: Security_Endpoint_Exceptions_API_ExceptionListItemType,
  })
  .passthrough();
const Security_Endpoint_Management_API_Command = z.enum([
  'isolate',
  'unisolate',
  'kill-process',
  'suspend-process',
  'running-processes',
  'get-file',
  'execute',
  'upload',
  'scan',
]);
const agentIds = z.union([z.array(z.string().min(1)), z.string()]).optional();
const Security_Endpoint_Management_API_Type = z.enum(['automated', 'manual']);
const Security_Endpoint_Management_API_GetEndpointActionListResponse = z
  .object({})
  .partial()
  .passthrough();
const Security_Endpoint_Management_API_AgentIds = z.union([z.array(z.string().min(1)), z.string()]);
const query = z
  .object({ agent_ids: Security_Endpoint_Management_API_AgentIds })
  .partial()
  .passthrough();
const Security_Endpoint_Management_API_AgentId = z.string();
const Security_Endpoint_Management_API_PendingActionDataType = z.number();
const Security_Endpoint_Management_API_PendingActionsSchema = z.union([
  z
    .object({
      execute: Security_Endpoint_Management_API_PendingActionDataType.int(),
      'get-file': Security_Endpoint_Management_API_PendingActionDataType.int(),
      isolate: Security_Endpoint_Management_API_PendingActionDataType.int(),
      'kill-process': Security_Endpoint_Management_API_PendingActionDataType.int(),
      'running-processes': Security_Endpoint_Management_API_PendingActionDataType.int(),
      scan: Security_Endpoint_Management_API_PendingActionDataType.int(),
      'suspend-process': Security_Endpoint_Management_API_PendingActionDataType.int(),
      unisolate: Security_Endpoint_Management_API_PendingActionDataType.int(),
      upload: Security_Endpoint_Management_API_PendingActionDataType.int(),
    })
    .partial()
    .passthrough(),
  z.object({}).partial().passthrough(),
]);
const Security_Endpoint_Management_API_ActionStatusSuccessResponse = z
  .object({
    body: z
      .object({
        data: z
          .object({
            agent_id: Security_Endpoint_Management_API_AgentId,
            pending_actions: Security_Endpoint_Management_API_PendingActionsSchema,
          })
          .passthrough(),
      })
      .passthrough(),
  })
  .passthrough();
const Security_Endpoint_Management_API_GetEndpointActionResponse = z
  .object({})
  .partial()
  .passthrough();
const Security_Endpoint_Management_API_SuccessResponse = z.object({}).partial().passthrough();
const Security_Endpoint_Management_API_AgentTypes = z.enum([
  'endpoint',
  'sentinel_one',
  'crowdstrike',
  'microsoft_defender_endpoint',
]);
const Security_Endpoint_Management_API_AlertIds = z.array(z.string().min(1));
const Security_Endpoint_Management_API_CaseIds = z.array(z.string().min(1));
const Security_Endpoint_Management_API_Comment = z.string();
const Security_Endpoint_Management_API_EndpointIds = z.array(z.string().min(1));
const Security_Endpoint_Management_API_Parameters = z.object({}).partial().passthrough();
const Security_Endpoint_Management_API_Timeout = z.number();
const Security_Endpoint_Management_API_ExecuteRouteRequestBody = z
  .object({
    agent_type: Security_Endpoint_Management_API_AgentTypes.optional(),
    alert_ids: Security_Endpoint_Management_API_AlertIds.min(1).optional(),
    case_ids: Security_Endpoint_Management_API_CaseIds.min(1).optional(),
    comment: Security_Endpoint_Management_API_Comment.optional(),
    endpoint_ids: Security_Endpoint_Management_API_EndpointIds.min(1),
    parameters: Security_Endpoint_Management_API_Parameters.optional(),
  })
  .passthrough()
  .and(
    z
      .object({
        parameters: z
          .object({
            command: Security_Endpoint_Management_API_Command,
            timeout: Security_Endpoint_Management_API_Timeout.int().gte(1).optional(),
          })
          .passthrough(),
      })
      .passthrough()
  );
const Security_Endpoint_Management_API_ExecuteRouteResponse = z.object({}).partial().passthrough();
const Security_Endpoint_Management_API_GetFileRouteRequestBody = z
  .object({
    agent_type: Security_Endpoint_Management_API_AgentTypes.optional(),
    alert_ids: Security_Endpoint_Management_API_AlertIds.min(1).optional(),
    case_ids: Security_Endpoint_Management_API_CaseIds.min(1).optional(),
    comment: Security_Endpoint_Management_API_Comment.optional(),
    endpoint_ids: Security_Endpoint_Management_API_EndpointIds.min(1),
    parameters: Security_Endpoint_Management_API_Parameters.optional(),
  })
  .passthrough()
  .and(z.object({ parameters: z.object({ path: z.string() }).passthrough() }).passthrough());
const Security_Endpoint_Management_API_GetFileRouteResponse = z.object({}).partial().passthrough();
const EndpointIsolateAction_Body = z
  .object({
    agent_type: Security_Endpoint_Management_API_AgentTypes.optional(),
    alert_ids: Security_Endpoint_Management_API_AlertIds.min(1).optional(),
    case_ids: Security_Endpoint_Management_API_CaseIds.min(1).optional(),
    comment: Security_Endpoint_Management_API_Comment.optional(),
    endpoint_ids: Security_Endpoint_Management_API_EndpointIds.min(1),
    parameters: Security_Endpoint_Management_API_Parameters.optional(),
  })
  .passthrough();
const Security_Endpoint_Management_API_IsolateRouteResponse = z.object({}).partial().passthrough();
const Security_Endpoint_Management_API_KillProcessRouteRequestBody = z
  .object({
    agent_type: Security_Endpoint_Management_API_AgentTypes.optional(),
    alert_ids: Security_Endpoint_Management_API_AlertIds.min(1).optional(),
    case_ids: Security_Endpoint_Management_API_CaseIds.min(1).optional(),
    comment: Security_Endpoint_Management_API_Comment.optional(),
    endpoint_ids: Security_Endpoint_Management_API_EndpointIds.min(1),
    parameters: Security_Endpoint_Management_API_Parameters.optional(),
  })
  .passthrough()
  .and(
    z
      .object({
        parameters: z.union([
          z
            .object({ pid: z.number().int().gte(1) })
            .partial()
            .passthrough(),
          z
            .object({ entity_id: z.string().min(1) })
            .partial()
            .passthrough(),
          z
            .object({ process_name: z.string().min(1) })
            .partial()
            .passthrough(),
        ]),
      })
      .passthrough()
  );
const Security_Endpoint_Management_API_KillProcessRouteResponse = z
  .object({})
  .partial()
  .passthrough();
const Security_Endpoint_Management_API_GetProcessesRouteRequestBody = z
  .object({
    agent_type: Security_Endpoint_Management_API_AgentTypes.optional(),
    alert_ids: Security_Endpoint_Management_API_AlertIds.min(1).optional(),
    case_ids: Security_Endpoint_Management_API_CaseIds.min(1).optional(),
    comment: Security_Endpoint_Management_API_Comment.optional(),
    endpoint_ids: Security_Endpoint_Management_API_EndpointIds.min(1),
    parameters: Security_Endpoint_Management_API_Parameters.optional(),
  })
  .passthrough();
const Security_Endpoint_Management_API_GetProcessesRouteResponse = z
  .object({})
  .partial()
  .passthrough();
const Security_Endpoint_Management_API_RawScriptParameters = z
  .object({
    commandLine: z.string().min(1).optional(),
    raw: z.string().min(1),
    timeout: z.number().int().gte(1).optional(),
  })
  .passthrough();
const Security_Endpoint_Management_API_HostPathScriptParameters = z
  .object({
    commandLine: z.string().min(1).optional(),
    hostPath: z.string().min(1),
    timeout: z.number().int().gte(1).optional(),
  })
  .passthrough();
const Security_Endpoint_Management_API_CloudFileScriptParameters = z
  .object({
    cloudFile: z.string().min(1),
    commandLine: z.string().min(1).optional(),
    timeout: z.number().int().gte(1).optional(),
  })
  .passthrough();
const Security_Endpoint_Management_API_RunScriptRouteRequestBody = z
  .object({
    parameters: z.union([
      Security_Endpoint_Management_API_RawScriptParameters,
      Security_Endpoint_Management_API_HostPathScriptParameters,
      Security_Endpoint_Management_API_CloudFileScriptParameters,
    ]),
  })
  .passthrough();
const Security_Endpoint_Management_API_ScanRouteRequestBody = z
  .object({
    agent_type: Security_Endpoint_Management_API_AgentTypes.optional(),
    alert_ids: Security_Endpoint_Management_API_AlertIds.min(1).optional(),
    case_ids: Security_Endpoint_Management_API_CaseIds.min(1).optional(),
    comment: Security_Endpoint_Management_API_Comment.optional(),
    endpoint_ids: Security_Endpoint_Management_API_EndpointIds.min(1),
    parameters: Security_Endpoint_Management_API_Parameters.optional(),
  })
  .passthrough()
  .and(z.object({ parameters: z.object({ path: z.string() }).passthrough() }).passthrough());
const Security_Endpoint_Management_API_ScanRouteResponse = z.object({}).partial().passthrough();
const Security_Endpoint_Management_API_ActionStateSuccessResponse = z
  .object({
    body: z
      .object({ data: z.object({ canEncrypt: z.boolean() }).partial().passthrough() })
      .passthrough(),
  })
  .passthrough();
const Security_Endpoint_Management_API_SuspendProcessRouteRequestBody = z
  .object({
    agent_type: Security_Endpoint_Management_API_AgentTypes.optional(),
    alert_ids: Security_Endpoint_Management_API_AlertIds.min(1).optional(),
    case_ids: Security_Endpoint_Management_API_CaseIds.min(1).optional(),
    comment: Security_Endpoint_Management_API_Comment.optional(),
    endpoint_ids: Security_Endpoint_Management_API_EndpointIds.min(1),
    parameters: Security_Endpoint_Management_API_Parameters.optional(),
  })
  .passthrough()
  .and(
    z
      .object({
        parameters: z.union([
          z
            .object({ pid: z.number().int().gte(1) })
            .partial()
            .passthrough(),
          z
            .object({ entity_id: z.string().min(1) })
            .partial()
            .passthrough(),
        ]),
      })
      .passthrough()
  );
const Security_Endpoint_Management_API_SuspendProcessRouteResponse = z
  .object({})
  .partial()
  .passthrough();
const Security_Endpoint_Management_API_UnisolateRouteResponse = z
  .object({})
  .partial()
  .passthrough();
const Security_Endpoint_Management_API_UploadRouteRequestBody = z
  .object({
    agent_type: Security_Endpoint_Management_API_AgentTypes.optional(),
    alert_ids: Security_Endpoint_Management_API_AlertIds.min(1).optional(),
    case_ids: Security_Endpoint_Management_API_CaseIds.min(1).optional(),
    comment: Security_Endpoint_Management_API_Comment.optional(),
    endpoint_ids: Security_Endpoint_Management_API_EndpointIds.min(1),
    parameters: Security_Endpoint_Management_API_Parameters.optional(),
  })
  .passthrough()
  .and(
    z
      .object({
        file: z.instanceof(File),
        parameters: z
          .object({ overwrite: z.boolean().default(false) })
          .partial()
          .passthrough(),
      })
      .passthrough()
  );
const Security_Endpoint_Management_API_UploadRouteResponse = z.object({}).partial().passthrough();
const Security_Endpoint_Management_API_MetadataListResponse = z.object({}).partial().passthrough();
const Security_Endpoint_Management_API_EndpointMetadataResponse = z
  .object({})
  .partial()
  .passthrough();
const query__2 = z
  .object({ agentId: Security_Endpoint_Management_API_AgentId })
  .partial()
  .passthrough();
const Security_Endpoint_Management_API_ProtectionUpdatesNoteResponse = z
  .object({ note: z.string() })
  .partial()
  .passthrough();
const Security_Entity_Analytics_API_PrivilegeMonitoringEngineStatus = z.enum([
  'started',
  'error',
  'disabled',
  'not_installed',
]);
const Security_Entity_Analytics_API_MonitoringEngineDescriptor = z
  .object({ status: Security_Entity_Analytics_API_PrivilegeMonitoringEngineStatus })
  .passthrough();
const Security_Entity_Analytics_API_EntityAnalyticsPrivileges = z
  .object({
    has_all_required: z.boolean(),
    has_read_permissions: z.boolean().optional(),
    has_write_permissions: z.boolean().optional(),
    privileges: z
      .object({
        elasticsearch: z
          .object({ cluster: z.record(z.boolean()), index: z.record(z.record(z.boolean())) })
          .partial()
          .passthrough(),
        kibana: z.record(z.boolean()).optional(),
      })
      .passthrough(),
  })
  .passthrough();
const Security_Entity_Analytics_API_UserName = z
  .object({ user: z.object({ name: z.string() }).partial().passthrough() })
  .partial()
  .passthrough();
const Security_Entity_Analytics_API_MonitoredUserDoc = z
  .object({
    '@timestamp': z.string().datetime({ offset: true }),
    entity_analytics_monitoring: z
      .object({
        labels: z.array(
          z
            .object({ field: z.string(), source: z.string(), value: z.string() })
            .partial()
            .passthrough()
        ),
      })
      .partial()
      .passthrough(),
    event: z
      .object({ ingested: z.string().datetime({ offset: true }) })
      .partial()
      .passthrough(),
    id: z.string(),
    labels: z
      .object({
        source_ids: z.array(z.string()),
        source_integrations: z.array(z.string()),
        sources: z.array(z.unknown()),
      })
      .partial()
      .passthrough(),
    user: z.object({ is_privileged: z.boolean(), name: z.string() }).partial().passthrough(),
  })
  .partial()
  .passthrough();
const Security_Entity_Analytics_API_PrivmonUserCsvUploadErrorItem = z
  .object({
    index: z.number().int().nullable(),
    message: z.string(),
    username: z.string().nullable(),
  })
  .passthrough();
const Security_Entity_Analytics_API_PrivmonUserCsvUploadStats = z
  .object({ failed: z.number().int(), successful: z.number().int(), total: z.number().int() })
  .passthrough();
const Security_Entity_Analytics_API_Interval = z.string();
const Security_Entity_Analytics_API_EntityType = z.enum(['user', 'host', 'service', 'generic']);
const Security_Entity_Analytics_API_IndexPattern = z.string();
const InitEntityStore_Body = z
  .object({
    delay: z
      .string()
      .regex(/[smdh]$/)
      .default('1m'),
    docsPerSecond: z.number().int().default(-1),
    enrichPolicyExecutionInterval: Security_Entity_Analytics_API_Interval.regex(/^[1-9]\d*[smh]$/),
    entityTypes: z.array(Security_Entity_Analytics_API_EntityType),
    fieldHistoryLength: z.number().int().default(10),
    filter: z.string(),
    frequency: z
      .string()
      .regex(/[smdh]$/)
      .default('1m'),
    indexPattern: Security_Entity_Analytics_API_IndexPattern,
    lookbackPeriod: z
      .string()
      .regex(/[smdh]$/)
      .default('3h'),
    maxPageSearchSize: z.number().int().default(500),
    timeout: z
      .string()
      .regex(/[smdh]$/)
      .default('180s'),
    timestampField: z.string().default('@timestamp'),
  })
  .partial()
  .passthrough();
const Security_Entity_Analytics_API_EngineStatus = z.enum([
  'installing',
  'started',
  'stopped',
  'updating',
  'error',
]);
const Security_Entity_Analytics_API_EngineDescriptor = z
  .object({
    delay: z
      .string()
      .regex(/[smdh]$/)
      .optional()
      .default('1m'),
    docsPerSecond: z.number().int().optional(),
    error: z
      .object({ action: z.literal('init'), message: z.string() })
      .passthrough()
      .optional(),
    fieldHistoryLength: z.number().int(),
    filter: z.string().optional(),
    frequency: z
      .string()
      .regex(/[smdh]$/)
      .optional()
      .default('1m'),
    indexPattern: Security_Entity_Analytics_API_IndexPattern,
    lookbackPeriod: z
      .string()
      .regex(/[smdh]$/)
      .optional()
      .default('24h'),
    status: Security_Entity_Analytics_API_EngineStatus,
    timeout: z
      .string()
      .regex(/[smdh]$/)
      .optional()
      .default('180s'),
    timestampField: z.string().optional(),
    type: Security_Entity_Analytics_API_EntityType,
  })
  .passthrough();
const InitEntityEngine_Body = z
  .object({
    delay: z
      .string()
      .regex(/[smdh]$/)
      .default('1m'),
    docsPerSecond: z.number().int().default(-1),
    enrichPolicyExecutionInterval: Security_Entity_Analytics_API_Interval.regex(/^[1-9]\d*[smh]$/),
    fieldHistoryLength: z.number().int().default(10),
    filter: z.string(),
    frequency: z
      .string()
      .regex(/[smdh]$/)
      .default('1m'),
    indexPattern: Security_Entity_Analytics_API_IndexPattern,
    lookbackPeriod: z
      .string()
      .regex(/[smdh]$/)
      .default('3h'),
    maxPageSearchSize: z.number().int().default(500),
    timeout: z
      .string()
      .regex(/[smdh]$/)
      .default('180s'),
    timestampField: z.string().default('@timestamp'),
  })
  .partial()
  .passthrough();
const Security_Entity_Analytics_API_EngineDataviewUpdateResult = z
  .object({
    changes: z
      .object({ indexPatterns: z.array(z.string()) })
      .partial()
      .passthrough()
      .optional(),
    type: z.string(),
  })
  .passthrough();
const Security_Entity_Analytics_API_InspectQuery = z
  .object({ dsl: z.array(z.string()), response: z.array(z.string()) })
  .passthrough();
const Security_Entity_Analytics_API_EngineMetadata = z.object({ Type: z.string() }).passthrough();
const Security_Entity_Analytics_API_EntityRiskLevels = z.enum([
  'Unknown',
  'Low',
  'Moderate',
  'High',
  'Critical',
]);
const Security_Entity_Analytics_API_RiskScoreInput = z
  .object({
    category: z.string(),
    contribution_score: z.number().optional(),
    description: z.string(),
    id: z.string(),
    index: z.string(),
    risk_score: z.number().gte(0).lte(100).optional(),
    timestamp: z.string().optional(),
  })
  .passthrough();
const Security_Entity_Analytics_API_EntityRiskScoreRecord = z
  .object({
    '@timestamp': z.string().datetime({ offset: true }),
    calculated_level: Security_Entity_Analytics_API_EntityRiskLevels,
    calculated_score: z.number(),
    calculated_score_norm: z.number().gte(0).lte(100),
    category_1_count: z.number().int(),
    category_1_score: z.number(),
    category_2_count: z.number().int().optional(),
    category_2_score: z.number().optional(),
    criticality_level: Security_Entity_Analytics_API_AssetCriticalityLevel.optional(),
    criticality_modifier: z.number().optional(),
    id_field: z.string(),
    id_value: z.string(),
    inputs: z.array(Security_Entity_Analytics_API_RiskScoreInput),
    notes: z.array(z.string()),
  })
  .passthrough();
const Security_Entity_Analytics_API_UserEntity = z
  .object({
    '@timestamp': z.string().datetime({ offset: true }).optional(),
    asset: z
      .object({ criticality: Security_Entity_Analytics_API_AssetCriticalityLevel })
      .passthrough()
      .optional(),
    entity: z
      .object({
        EngineMetadata: Security_Entity_Analytics_API_EngineMetadata.optional(),
        name: z.string(),
        source: z.string(),
        type: z.string(),
      })
      .passthrough(),
    event: z
      .object({ ingested: z.string().datetime({ offset: true }) })
      .partial()
      .passthrough()
      .optional(),
    user: z
      .object({
        domain: z.array(z.string()).optional(),
        email: z.array(z.string()).optional(),
        full_name: z.array(z.string()).optional(),
        hash: z.array(z.string()).optional(),
        id: z.array(z.string()).optional(),
        name: z.string(),
        risk: Security_Entity_Analytics_API_EntityRiskScoreRecord.optional(),
        roles: z.array(z.string()).optional(),
      })
      .passthrough(),
  })
  .passthrough();
const Security_Entity_Analytics_API_HostEntity = z
  .object({
    '@timestamp': z.string().datetime({ offset: true }).optional(),
    asset: z
      .object({ criticality: Security_Entity_Analytics_API_AssetCriticalityLevel })
      .passthrough()
      .optional(),
    entity: z
      .object({
        EngineMetadata: Security_Entity_Analytics_API_EngineMetadata.optional(),
        name: z.string(),
        source: z.string(),
        type: z.string(),
      })
      .passthrough(),
    event: z
      .object({ ingested: z.string().datetime({ offset: true }) })
      .partial()
      .passthrough()
      .optional(),
    host: z
      .object({
        architecture: z.array(z.string()).optional(),
        domain: z.array(z.string()).optional(),
        hostname: z.array(z.string()).optional(),
        id: z.array(z.string()).optional(),
        ip: z.array(z.string()).optional(),
        mac: z.array(z.string()).optional(),
        name: z.string(),
        risk: Security_Entity_Analytics_API_EntityRiskScoreRecord.optional(),
        type: z.array(z.string()).optional(),
      })
      .passthrough(),
  })
  .passthrough();
const Security_Entity_Analytics_API_ServiceEntity = z
  .object({
    '@timestamp': z.string().datetime({ offset: true }).optional(),
    asset: z
      .object({ criticality: Security_Entity_Analytics_API_AssetCriticalityLevel })
      .passthrough()
      .optional(),
    entity: z
      .object({
        EngineMetadata: Security_Entity_Analytics_API_EngineMetadata.optional(),
        name: z.string(),
        source: z.string(),
        type: z.string(),
      })
      .passthrough(),
    event: z
      .object({ ingested: z.string().datetime({ offset: true }) })
      .partial()
      .passthrough()
      .optional(),
    service: z
      .object({
        name: z.string(),
        risk: Security_Entity_Analytics_API_EntityRiskScoreRecord.optional(),
      })
      .passthrough(),
  })
  .passthrough();
const Security_Entity_Analytics_API_GenericEntity = z
  .object({
    '@timestamp': z.string().datetime({ offset: true }).optional(),
    asset: z
      .object({ criticality: Security_Entity_Analytics_API_AssetCriticalityLevel })
      .passthrough()
      .optional(),
    entity: z
      .object({
        category: z.string().optional(),
        EngineMetadata: Security_Entity_Analytics_API_EngineMetadata.optional(),
        id: z.string(),
        name: z.string(),
        source: z.string().optional(),
        type: z.string(),
      })
      .passthrough(),
  })
  .passthrough();
const Security_Entity_Analytics_API_Entity = z.union([
  Security_Entity_Analytics_API_UserEntity,
  Security_Entity_Analytics_API_HostEntity,
  Security_Entity_Analytics_API_ServiceEntity,
  Security_Entity_Analytics_API_GenericEntity,
]);
const Security_Entity_Analytics_API_TransformStatsMetadata = z
  .object({
    delete_time_in_ms: z.number().int().optional(),
    documents_deleted: z.number().int().optional(),
    documents_indexed: z.number().int(),
    documents_processed: z.number().int(),
    exponential_avg_checkpoint_duration_ms: z.number().int(),
    exponential_avg_documents_indexed: z.number().int(),
    exponential_avg_documents_processed: z.number().int(),
    index_failures: z.number().int(),
    index_time_in_ms: z.number().int(),
    index_total: z.number().int(),
    pages_processed: z.number().int(),
    processing_time_in_ms: z.number().int(),
    processing_total: z.number().int(),
    search_failures: z.number().int(),
    search_time_in_ms: z.number().int(),
    search_total: z.number().int(),
    trigger_count: z.number().int(),
  })
  .passthrough();
const Security_Entity_Analytics_API_EngineComponentResource = z.enum([
  'entity_engine',
  'entity_definition',
  'index',
  'component_template',
  'index_template',
  'ingest_pipeline',
  'enrich_policy',
  'task',
  'transform',
]);
const Security_Entity_Analytics_API_EngineComponentStatus = z
  .object({
    errors: z
      .array(z.object({ message: z.string(), title: z.string() }).partial().passthrough())
      .optional(),
    health: z.enum(['green', 'yellow', 'red', 'unavailable', 'unknown']).optional(),
    id: z.string(),
    installed: z.boolean(),
    metadata: Security_Entity_Analytics_API_TransformStatsMetadata.optional(),
    resource: Security_Entity_Analytics_API_EngineComponentResource,
  })
  .passthrough();
const Security_Entity_Analytics_API_StoreStatus = z.enum([
  'not_installed',
  'installing',
  'running',
  'stopped',
  'error',
]);
const Security_Exceptions_API_ExceptionListDescription = z.string();
const Security_Exceptions_API_ExceptionListId = z.string();
const Security_Exceptions_API_ExceptionListMeta = z.object({}).partial().passthrough();
const Security_Exceptions_API_ExceptionListName = z.string();
const Security_Exceptions_API_ExceptionListOsTypeArray = z.array(
  Security_Exceptions_API_ExceptionListOsType
);
const Security_Exceptions_API_ExceptionListTags = z.array(z.string());
const Security_Exceptions_API_ExceptionListType = z.enum([
  'detection',
  'rule_default',
  'endpoint',
  'endpoint_trusted_apps',
  'endpoint_trusted_devices',
  'endpoint_events',
  'endpoint_host_isolation_exceptions',
  'endpoint_blocklists',
]);
const Security_Exceptions_API_ExceptionListVersion = z.number();
const Security_Exceptions_API_ExceptionList = z
  .object({
    _version: z.string().optional(),
    created_at: z.string().datetime({ offset: true }),
    created_by: z.string(),
    description: Security_Exceptions_API_ExceptionListDescription,
    id: Security_Exceptions_API_ExceptionListId.min(1),
    immutable: z.boolean(),
    list_id: Security_Exceptions_API_ExceptionListHumanId.min(1),
    meta: Security_Exceptions_API_ExceptionListMeta.optional(),
    name: Security_Exceptions_API_ExceptionListName,
    namespace_type: Security_Exceptions_API_ExceptionNamespaceType,
    os_types: Security_Exceptions_API_ExceptionListOsTypeArray.optional(),
    tags: Security_Exceptions_API_ExceptionListTags.optional(),
    tie_breaker_id: z.string(),
    type: Security_Exceptions_API_ExceptionListType,
    updated_at: z.string().datetime({ offset: true }),
    updated_by: z.string(),
    version: Security_Exceptions_API_ExceptionListVersion.int().gte(1),
  })
  .passthrough();
const CreateExceptionList_Body = z
  .object({
    description: Security_Exceptions_API_ExceptionListDescription,
    list_id: Security_Exceptions_API_ExceptionListHumanId.min(1).optional(),
    meta: Security_Exceptions_API_ExceptionListMeta.optional(),
    name: Security_Exceptions_API_ExceptionListName,
    namespace_type: Security_Exceptions_API_ExceptionNamespaceType.optional(),
    os_types: Security_Exceptions_API_ExceptionListOsTypeArray.optional(),
    tags: Security_Exceptions_API_ExceptionListTags.optional(),
    type: Security_Exceptions_API_ExceptionListType,
    version: Security_Exceptions_API_ExceptionListVersion.int().gte(1).optional(),
  })
  .passthrough();
const UpdateExceptionList_Body = z
  .object({
    _version: z.string().optional(),
    description: Security_Exceptions_API_ExceptionListDescription,
    id: Security_Exceptions_API_ExceptionListId.min(1).optional(),
    list_id: Security_Exceptions_API_ExceptionListHumanId.min(1).optional(),
    meta: Security_Exceptions_API_ExceptionListMeta.optional(),
    name: Security_Exceptions_API_ExceptionListName,
    namespace_type: Security_Exceptions_API_ExceptionNamespaceType.optional(),
    os_types: Security_Exceptions_API_ExceptionListOsTypeArray.optional(),
    tags: Security_Exceptions_API_ExceptionListTags.optional(),
    type: Security_Exceptions_API_ExceptionListType,
    version: Security_Exceptions_API_ExceptionListVersion.int().gte(1).optional(),
  })
  .passthrough();
const Security_Exceptions_API_ExceptionListsImportBulkError = z
  .object({
    error: z.object({ message: z.string(), status_code: z.number().int() }).passthrough(),
    id: Security_Exceptions_API_ExceptionListId.min(1).optional(),
    item_id: Security_Exceptions_API_ExceptionListItemHumanId.min(1).optional(),
    list_id: Security_Exceptions_API_ExceptionListHumanId.min(1).optional(),
  })
  .passthrough();
const Security_Exceptions_API_ExceptionListsImportBulkErrorArray = z.array(
  Security_Exceptions_API_ExceptionListsImportBulkError
);
const Security_Exceptions_API_CreateExceptionListItemComment = z
  .object({ comment: Security_Exceptions_API_NonEmptyString.min(1) })
  .passthrough();
const Security_Exceptions_API_CreateExceptionListItemCommentArray = z.array(
  Security_Exceptions_API_CreateExceptionListItemComment
);
const CreateExceptionListItem_Body = z
  .object({
    comments: Security_Exceptions_API_CreateExceptionListItemCommentArray.optional(),
    description: Security_Exceptions_API_ExceptionListItemDescription,
    entries: Security_Exceptions_API_ExceptionListItemEntryArray,
    expire_time: Security_Exceptions_API_ExceptionListItemExpireTime.datetime({
      offset: true,
    }).optional(),
    item_id: Security_Exceptions_API_ExceptionListItemHumanId.min(1).optional(),
    list_id: Security_Exceptions_API_ExceptionListHumanId.min(1),
    meta: Security_Exceptions_API_ExceptionListItemMeta.optional(),
    name: Security_Exceptions_API_ExceptionListItemName.min(1),
    namespace_type: Security_Exceptions_API_ExceptionNamespaceType.optional(),
    os_types: Security_Exceptions_API_ExceptionListItemOsTypeArray.optional(),
    tags: Security_Exceptions_API_ExceptionListItemTags.optional(),
    type: Security_Exceptions_API_ExceptionListItemType,
  })
  .passthrough();
const Security_Exceptions_API_UpdateExceptionListItemComment = z
  .object({
    comment: Security_Exceptions_API_NonEmptyString.min(1),
    id: Security_Exceptions_API_NonEmptyString.min(1).optional(),
  })
  .passthrough();
const Security_Exceptions_API_UpdateExceptionListItemCommentArray = z.array(
  Security_Exceptions_API_UpdateExceptionListItemComment
);
const UpdateExceptionListItem_Body = z
  .object({
    _version: z.string().optional(),
    comments: Security_Exceptions_API_UpdateExceptionListItemCommentArray.optional(),
    description: Security_Exceptions_API_ExceptionListItemDescription,
    entries: Security_Exceptions_API_ExceptionListItemEntryArray,
    expire_time: Security_Exceptions_API_ExceptionListItemExpireTime.datetime({
      offset: true,
    }).optional(),
    id: Security_Exceptions_API_ExceptionListItemId.min(1).optional(),
    item_id: Security_Exceptions_API_ExceptionListItemHumanId.min(1).optional(),
    list_id: Security_Exceptions_API_ExceptionListHumanId.min(1).optional(),
    meta: Security_Exceptions_API_ExceptionListItemMeta.optional(),
    name: Security_Exceptions_API_ExceptionListItemName.min(1),
    namespace_type: Security_Exceptions_API_ExceptionNamespaceType.optional(),
    os_types: Security_Exceptions_API_ExceptionListItemOsTypeArray.optional(),
    tags: Security_Exceptions_API_ExceptionListItemTags.optional(),
    type: Security_Exceptions_API_ExceptionListItemType,
  })
  .passthrough();
const CreateSharedExceptionList_Body = z
  .object({
    description: Security_Exceptions_API_ExceptionListDescription,
    name: Security_Exceptions_API_ExceptionListName,
  })
  .passthrough();
const post_fleet_agent_download_sources_Body = z.object({
  host: z.string().url(),
  id: z.string().optional(),
  is_default: z.boolean().optional().default(false),
  name: z.string(),
  proxy_id: z.string().nullish(),
  secrets: z
    .object({
      ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
    })
    .partial()
    .optional(),
  ssl: z
    .object({
      certificate: z.string(),
      certificate_authorities: z.array(z.string()),
      key: z.string(),
    })
    .partial()
    .optional(),
});
const post_fleet_agent_policies_Body = z.object({
  advanced_settings: z
    .object({
      agent_download_target_directory: z.unknown().nullable(),
      agent_download_timeout: z.unknown().nullable(),
      agent_limits_go_max_procs: z.unknown().nullable(),
      agent_logging_files_interval: z.unknown().nullable(),
      agent_logging_files_keepfiles: z.unknown().nullable(),
      agent_logging_files_rotateeverybytes: z.unknown().nullable(),
      agent_logging_level: z.unknown().nullable(),
      agent_logging_metrics_period: z.unknown().nullable(),
      agent_logging_to_files: z.unknown().nullable(),
      agent_monitoring_runtime_experimental: z.unknown().nullable(),
    })
    .partial()
    .optional(),
  agent_features: z.array(z.object({ enabled: z.boolean(), name: z.string() })).optional(),
  agentless: z
    .object({
      cloud_connectors: z.object({ enabled: z.boolean(), target_csp: z.string().optional() }),
      resources: z
        .object({ requests: z.object({ cpu: z.string(), memory: z.string() }).partial() })
        .partial(),
    })
    .partial()
    .optional(),
  data_output_id: z.string().nullish(),
  description: z.string().optional(),
  download_source_id: z.string().nullish(),
  fleet_server_host_id: z.string().nullish(),
  force: z.boolean().optional(),
  global_data_tags: z
    .array(z.object({ name: z.string(), value: z.union([z.string(), z.number()]) }))
    .optional(),
  has_fleet_server: z.boolean().optional(),
  id: z.string().optional(),
  inactivity_timeout: z.number().gte(0).optional().default(1209600),
  is_default: z.boolean().optional(),
  is_default_fleet_server: z.boolean().optional(),
  is_managed: z.boolean().optional(),
  is_protected: z.boolean().optional(),
  keep_monitoring_alive: z.boolean().nullish().default(false),
  monitoring_diagnostics: z
    .object({
      limit: z.object({ burst: z.number(), interval: z.string() }).partial(),
      uploader: z
        .object({ init_dur: z.string(), max_dur: z.string(), max_retries: z.number() })
        .partial(),
    })
    .partial()
    .optional(),
  monitoring_enabled: z.array(z.enum(['logs', 'metrics', 'traces'])).optional(),
  monitoring_http: z
    .object({
      buffer: z.object({ enabled: z.boolean().default(false) }).partial(),
      enabled: z.boolean(),
      host: z.string(),
      port: z.number().gte(0).lte(65353),
    })
    .partial()
    .optional(),
  monitoring_output_id: z.string().nullish(),
  monitoring_pprof_enabled: z.boolean().optional(),
  name: z.string().min(1),
  namespace: z.string().min(1),
  overrides: z.object({}).partial().passthrough().nullish(),
  required_versions: z
    .array(z.object({ percentage: z.number().gte(0).lte(100), version: z.string() }))
    .nullish(),
  space_ids: z.array(z.string()).optional(),
  supports_agentless: z.boolean().nullish().default(false),
  unenroll_timeout: z.number().gte(0).optional(),
});
const post_fleet_agent_policies_bulk_get_Body = z.object({
  full: z.boolean().optional(),
  ids: z.array(z.string()),
  ignoreMissing: z.boolean().optional(),
});
const put_fleet_agent_policies_agentpolicyid_Body = z.object({
  advanced_settings: z
    .object({
      agent_download_target_directory: z.unknown().nullable(),
      agent_download_timeout: z.unknown().nullable(),
      agent_limits_go_max_procs: z.unknown().nullable(),
      agent_logging_files_interval: z.unknown().nullable(),
      agent_logging_files_keepfiles: z.unknown().nullable(),
      agent_logging_files_rotateeverybytes: z.unknown().nullable(),
      agent_logging_level: z.unknown().nullable(),
      agent_logging_metrics_period: z.unknown().nullable(),
      agent_logging_to_files: z.unknown().nullable(),
      agent_monitoring_runtime_experimental: z.unknown().nullable(),
    })
    .partial()
    .optional(),
  agent_features: z.array(z.object({ enabled: z.boolean(), name: z.string() })).optional(),
  agentless: z
    .object({
      cloud_connectors: z.object({ enabled: z.boolean(), target_csp: z.string().optional() }),
      resources: z
        .object({ requests: z.object({ cpu: z.string(), memory: z.string() }).partial() })
        .partial(),
    })
    .partial()
    .optional(),
  bumpRevision: z.boolean().optional(),
  data_output_id: z.string().nullish(),
  description: z.string().optional(),
  download_source_id: z.string().nullish(),
  fleet_server_host_id: z.string().nullish(),
  force: z.boolean().optional(),
  global_data_tags: z
    .array(z.object({ name: z.string(), value: z.union([z.string(), z.number()]) }))
    .optional(),
  has_fleet_server: z.boolean().optional(),
  id: z.string().optional(),
  inactivity_timeout: z.number().gte(0).optional().default(1209600),
  is_default: z.boolean().optional(),
  is_default_fleet_server: z.boolean().optional(),
  is_managed: z.boolean().optional(),
  is_protected: z.boolean().optional(),
  keep_monitoring_alive: z.boolean().nullish().default(false),
  monitoring_diagnostics: z
    .object({
      limit: z.object({ burst: z.number(), interval: z.string() }).partial(),
      uploader: z
        .object({ init_dur: z.string(), max_dur: z.string(), max_retries: z.number() })
        .partial(),
    })
    .partial()
    .optional(),
  monitoring_enabled: z.array(z.enum(['logs', 'metrics', 'traces'])).optional(),
  monitoring_http: z
    .object({
      buffer: z.object({ enabled: z.boolean().default(false) }).partial(),
      enabled: z.boolean(),
      host: z.string(),
      port: z.number().gte(0).lte(65353),
    })
    .partial()
    .optional(),
  monitoring_output_id: z.string().nullish(),
  monitoring_pprof_enabled: z.boolean().optional(),
  name: z.string().min(1),
  namespace: z.string().min(1),
  overrides: z.object({}).partial().passthrough().nullish(),
  required_versions: z
    .array(z.object({ percentage: z.number().gte(0).lte(100), version: z.string() }))
    .nullish(),
  space_ids: z.array(z.string()).optional(),
  supports_agentless: z.boolean().nullish().default(false),
  unenroll_timeout: z.number().gte(0).optional(),
});
const post_fleet_agent_policies_agentpolicyid_copy_Body = z.object({
  description: z.string().optional(),
  name: z.string().min(1),
});
const post_fleet_agent_policies_delete_Body = z.object({
  agentPolicyId: z.string(),
  force: z.boolean().optional(),
});
const post_fleet_agent_policies_outputs_Body = z.object({ ids: z.array(z.string()) });
const agentsIds = z.union([z.array(z.string()), z.string()]);
const post_fleet_agents_Body = z.object({ actionIds: z.array(z.string()) });
const put_fleet_agents_agentid_Body = z
  .object({
    tags: z.array(z.string()),
    user_provided_metadata: z.object({}).partial().passthrough(),
  })
  .partial();
const post_fleet_agents_agentid_actions_Body = z.object({
  action: z.union([
    z.object({
      ack_data: z.unknown(),
      data: z.unknown(),
      type: z.enum(['UNENROLL', 'UPGRADE', 'POLICY_REASSIGN']),
    }),
    z.object({
      data: z.object({ log_level: z.enum(['debug', 'info', 'warning', 'error']).nullable() }),
      type: z.literal('SETTINGS'),
    }),
  ]),
});
const post_fleet_agents_agentid_request_diagnostics_Body = z
  .object({ additional_metrics: z.array(z.literal('CPU')) })
  .partial();
const post_fleet_agents_agentid_unenroll_Body = z
  .object({ force: z.boolean(), revoke: z.boolean() })
  .partial();
const post_fleet_agents_agentid_upgrade_Body = z.object({
  force: z.boolean().optional(),
  skipRateLimitCheck: z.boolean().optional(),
  source_uri: z.string().optional(),
  version: z.string(),
});
const post_fleet_agents_bulk_reassign_Body = z.object({
  agents: z.union([z.array(z.string()), z.string()]),
  batchSize: z.number().optional(),
  includeInactive: z.boolean().optional().default(false),
  policy_id: z.string(),
});
const post_fleet_agents_bulk_request_diagnostics_Body = z.object({
  additional_metrics: z.array(z.literal('CPU')).optional(),
  agents: z.union([z.array(z.string()), z.string()]),
  batchSize: z.number().optional(),
});
const post_fleet_agents_bulk_unenroll_Body = z.object({
  agents: z.union([z.array(z.string()), z.string()]),
  batchSize: z.number().optional(),
  force: z.boolean().optional(),
  includeInactive: z.boolean().optional(),
  revoke: z.boolean().optional(),
});
const post_fleet_agents_bulk_update_agent_tags_Body = z.object({
  agents: z.union([z.array(z.string()), z.string()]),
  batchSize: z.number().optional(),
  includeInactive: z.boolean().optional().default(false),
  tagsToAdd: z.array(z.string()).optional(),
  tagsToRemove: z.array(z.string()).optional(),
});
const post_fleet_agents_bulk_upgrade_Body = z.object({
  agents: z.union([z.array(z.string()), z.string()]),
  batchSize: z.number().optional(),
  force: z.boolean().optional(),
  includeInactive: z.boolean().optional().default(false),
  rollout_duration_seconds: z.number().gte(600).optional(),
  skipRateLimitCheck: z.boolean().optional(),
  source_uri: z.string().optional(),
  start_time: z.string().optional(),
  version: z.string(),
});
const post_fleet_enrollment_api_keys_Body = z.object({
  expiration: z.string().optional(),
  name: z.string().optional(),
  policy_id: z.string(),
});
const post_fleet_epm_bulk_assets_Body = z.object({
  assetIds: z.array(z.object({ id: z.string(), type: z.string() })),
});
const post_fleet_epm_custom_integrations_Body = z.object({
  datasets: z.array(
    z.object({
      name: z.string(),
      type: z.enum(['logs', 'metrics', 'traces', 'synthetics', 'profiling']),
    })
  ),
  force: z.boolean().optional(),
  integrationName: z.string(),
});
const put_fleet_epm_custom_integrations_pkgname_Body = z.object({
  categories: z.array(z.string()).optional(),
  readMeData: z.string(),
});
const post_fleet_epm_packages_bulk_Body = z.object({
  force: z.boolean().optional().default(false),
  packages: z
    .array(
      z.union([
        z.string(),
        z.object({ name: z.string(), prerelease: z.boolean().optional(), version: z.string() }),
      ])
    )
    .min(1),
});
const post_fleet_epm_packages_bulk_uninstall_Body = z.object({
  force: z.boolean().optional().default(false),
  packages: z.array(z.object({ name: z.string(), version: z.string() })).min(1),
});
const post_fleet_epm_packages_bulk_upgrade_Body = z.object({
  force: z.boolean().optional().default(false),
  packages: z.array(z.object({ name: z.string(), version: z.string().optional() })).min(1),
  prerelease: z.boolean().optional(),
  upgrade_package_policies: z.boolean().optional().default(false),
});
const post_fleet_epm_packages_pkgname_pkgversion_Body = z
  .object({ force: z.boolean().default(false), ignore_constraints: z.boolean().default(false) })
  .partial();
const post_fleet_epm_packages_pkgname_pkgversion_kibana_assets_Body = z
  .object({ force: z.boolean(), space_ids: z.array(z.string()).min(1) })
  .partial();
const post_fleet_epm_packages_pkgname_pkgversion_transforms_authorize_Body = z.object({
  transforms: z.array(z.object({ transformId: z.string() })),
});
const searchAfter = z.array(z.union([z.string(), z.number()])).optional();
const post_fleet_fleet_server_hosts_Body = z.object({
  host_urls: z.array(z.string()).min(1),
  id: z.string().optional(),
  is_default: z.boolean().optional().default(false),
  is_internal: z.boolean().optional(),
  is_preconfigured: z.boolean().optional().default(false),
  name: z.string(),
  proxy_id: z.string().nullish(),
  secrets: z
    .object({
      ssl: z
        .object({
          es_key: z.union([z.object({ id: z.string() }), z.string()]),
          key: z.union([z.object({ id: z.string() }), z.string()]),
        })
        .partial(),
    })
    .partial()
    .optional(),
  ssl: z
    .object({
      certificate: z.string(),
      certificate_authorities: z.array(z.string()),
      client_auth: z.enum(['optional', 'required', 'none']),
      es_certificate: z.string(),
      es_certificate_authorities: z.array(z.string()),
      es_key: z.string(),
      key: z.string(),
    })
    .partial()
    .nullish(),
});
const put_fleet_fleet_server_hosts_itemid_Body = z.object({
  host_urls: z.array(z.string()).min(1).optional(),
  is_default: z.boolean().optional(),
  is_internal: z.boolean().optional(),
  name: z.string().optional(),
  proxy_id: z.string().nullable(),
  secrets: z
    .object({
      ssl: z
        .object({
          es_key: z.union([z.object({ id: z.string() }), z.string()]),
          key: z.union([z.object({ id: z.string() }), z.string()]),
        })
        .partial(),
    })
    .partial()
    .optional(),
  ssl: z
    .object({
      certificate: z.string(),
      certificate_authorities: z.array(z.string()),
      client_auth: z.enum(['optional', 'required', 'none']),
      es_certificate: z.string(),
      es_certificate_authorities: z.array(z.string()),
      es_key: z.string(),
      key: z.string(),
    })
    .partial()
    .nullish(),
});
const post_fleet_outputs_Body = z.union([
  z.object({
    allow_edit: z.array(z.string()).optional(),
    ca_sha256: z.string().nullish(),
    ca_trusted_fingerprint: z.string().nullish(),
    config_yaml: z.string().nullish(),
    hosts: z.array(z.string().url()).min(1),
    id: z.string().optional(),
    is_default: z.boolean().optional().default(false),
    is_default_monitoring: z.boolean().optional().default(false),
    is_internal: z.boolean().optional(),
    is_preconfigured: z.boolean().optional(),
    name: z.string(),
    preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']).optional(),
    proxy_id: z.string().nullish(),
    secrets: z
      .object({
        ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
      })
      .partial()
      .optional(),
    shipper: z
      .object({
        compression_level: z.number().nullable(),
        disk_queue_compression_enabled: z.boolean().nullable(),
        disk_queue_enabled: z.boolean().nullish().default(false),
        disk_queue_encryption_enabled: z.boolean().nullable(),
        disk_queue_max_size: z.number().nullable(),
        disk_queue_path: z.string().nullable(),
        loadbalance: z.boolean().nullable(),
        max_batch_bytes: z.number().nullable(),
        mem_queue_events: z.number().nullable(),
        queue_flush_timeout: z.number().nullable(),
      })
      .nullish(),
    ssl: z
      .object({
        certificate: z.string(),
        certificate_authorities: z.array(z.string()),
        key: z.string(),
        verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
      })
      .partial()
      .nullish(),
    type: z.literal('elasticsearch'),
    write_to_logs_streams: z.boolean().optional(),
  }),
  z.object({
    allow_edit: z.array(z.string()).optional(),
    ca_sha256: z.string().nullish(),
    ca_trusted_fingerprint: z.string().nullish(),
    config_yaml: z.string().nullish(),
    hosts: z.array(z.string().url()).min(1),
    id: z.string().optional(),
    is_default: z.boolean().optional().default(false),
    is_default_monitoring: z.boolean().optional().default(false),
    is_internal: z.boolean().optional(),
    is_preconfigured: z.boolean().optional(),
    kibana_api_key: z.string().nullish(),
    kibana_url: z.string().nullish(),
    name: z.string(),
    preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']).optional(),
    proxy_id: z.string().nullish(),
    secrets: z
      .object({
        service_token: z.union([z.object({ id: z.string() }), z.string()]),
        ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
      })
      .partial()
      .optional(),
    service_token: z.string().nullish(),
    shipper: z
      .object({
        compression_level: z.number().nullable(),
        disk_queue_compression_enabled: z.boolean().nullable(),
        disk_queue_enabled: z.boolean().nullish().default(false),
        disk_queue_encryption_enabled: z.boolean().nullable(),
        disk_queue_max_size: z.number().nullable(),
        disk_queue_path: z.string().nullable(),
        loadbalance: z.boolean().nullable(),
        max_batch_bytes: z.number().nullable(),
        mem_queue_events: z.number().nullable(),
        queue_flush_timeout: z.number().nullable(),
      })
      .nullish(),
    ssl: z
      .object({
        certificate: z.string(),
        certificate_authorities: z.array(z.string()),
        key: z.string(),
        verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
      })
      .partial()
      .nullish(),
    sync_integrations: z.boolean().optional(),
    sync_uninstalled_integrations: z.boolean().optional(),
    type: z.literal('remote_elasticsearch'),
    write_to_logs_streams: z.boolean().optional(),
  }),
  z.object({
    allow_edit: z.array(z.string()).optional(),
    ca_sha256: z.string().nullish(),
    ca_trusted_fingerprint: z.string().nullish(),
    config_yaml: z.string().nullish(),
    hosts: z.array(z.string()).min(1),
    id: z.string().optional(),
    is_default: z.boolean().optional().default(false),
    is_default_monitoring: z.boolean().optional().default(false),
    is_internal: z.boolean().optional(),
    is_preconfigured: z.boolean().optional(),
    name: z.string(),
    proxy_id: z.string().nullish(),
    secrets: z
      .object({
        ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
      })
      .partial()
      .optional(),
    shipper: z
      .object({
        compression_level: z.number().nullable(),
        disk_queue_compression_enabled: z.boolean().nullable(),
        disk_queue_enabled: z.boolean().nullish().default(false),
        disk_queue_encryption_enabled: z.boolean().nullable(),
        disk_queue_max_size: z.number().nullable(),
        disk_queue_path: z.string().nullable(),
        loadbalance: z.boolean().nullable(),
        max_batch_bytes: z.number().nullable(),
        mem_queue_events: z.number().nullable(),
        queue_flush_timeout: z.number().nullable(),
      })
      .nullish(),
    ssl: z
      .object({
        certificate: z.string(),
        certificate_authorities: z.array(z.string()),
        key: z.string(),
        verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
      })
      .partial()
      .nullish(),
    type: z.literal('logstash'),
    write_to_logs_streams: z.boolean().optional(),
  }),
  z.object({
    allow_edit: z.array(z.string()).optional(),
    auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']),
    broker_timeout: z.number().optional(),
    ca_sha256: z.string().nullish(),
    ca_trusted_fingerprint: z.string().nullish(),
    client_id: z.string().optional(),
    compression: z.enum(['gzip', 'snappy', 'lz4', 'none']).optional(),
    compression_level: z.union([z.number(), z.unknown()]).nullable(),
    config_yaml: z.string().nullish(),
    connection_type: z.union([z.enum(['plaintext', 'encryption']), z.unknown()]).nullable(),
    hash: z.object({ hash: z.string(), random: z.boolean() }).partial().optional(),
    headers: z.array(z.object({ key: z.string(), value: z.string() })).optional(),
    hosts: z.array(z.string()).min(1),
    id: z.string().optional(),
    is_default: z.boolean().optional().default(false),
    is_default_monitoring: z.boolean().optional().default(false),
    is_internal: z.boolean().optional(),
    is_preconfigured: z.boolean().optional(),
    key: z.string().optional(),
    name: z.string(),
    partition: z.enum(['random', 'round_robin', 'hash']).optional(),
    password: z.union([z.unknown(), z.union([z.string(), z.unknown()])]).nullable(),
    proxy_id: z.string().nullish(),
    random: z.object({ group_events: z.number() }).partial().optional(),
    required_acks: z.union([z.literal(1), z.literal(0), z.literal(-1)]).optional(),
    round_robin: z.object({ group_events: z.number() }).partial().optional(),
    sasl: z
      .object({ mechanism: z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512']) })
      .partial()
      .nullish(),
    secrets: z
      .object({
        password: z.union([z.object({ id: z.string() }), z.string()]),
        ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }),
      })
      .partial()
      .optional(),
    shipper: z
      .object({
        compression_level: z.number().nullable(),
        disk_queue_compression_enabled: z.boolean().nullable(),
        disk_queue_enabled: z.boolean().nullish().default(false),
        disk_queue_encryption_enabled: z.boolean().nullable(),
        disk_queue_max_size: z.number().nullable(),
        disk_queue_path: z.string().nullable(),
        loadbalance: z.boolean().nullable(),
        max_batch_bytes: z.number().nullable(),
        mem_queue_events: z.number().nullable(),
        queue_flush_timeout: z.number().nullable(),
      })
      .nullish(),
    ssl: z
      .object({
        certificate: z.string(),
        certificate_authorities: z.array(z.string()),
        key: z.string(),
        verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
      })
      .partial()
      .nullish(),
    timeout: z.number().optional(),
    topic: z.string().optional(),
    type: z.literal('kafka'),
    username: z.union([z.string(), z.unknown()]).nullable(),
    version: z.string().optional(),
    write_to_logs_streams: z.boolean().optional(),
  }),
]);
const put_fleet_outputs_outputid_Body = z.union([
  z
    .object({
      allow_edit: z.array(z.string()),
      ca_sha256: z.string().nullable(),
      ca_trusted_fingerprint: z.string().nullable(),
      config_yaml: z.string().nullable(),
      hosts: z.array(z.string().url()).min(1),
      id: z.string(),
      is_default: z.boolean(),
      is_default_monitoring: z.boolean(),
      is_internal: z.boolean(),
      is_preconfigured: z.boolean(),
      name: z.string(),
      preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']),
      proxy_id: z.string().nullable(),
      secrets: z
        .object({
          ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
        })
        .partial(),
      shipper: z
        .object({
          compression_level: z.number().nullable(),
          disk_queue_compression_enabled: z.boolean().nullable(),
          disk_queue_enabled: z.boolean().nullish().default(false),
          disk_queue_encryption_enabled: z.boolean().nullable(),
          disk_queue_max_size: z.number().nullable(),
          disk_queue_path: z.string().nullable(),
          loadbalance: z.boolean().nullable(),
          max_batch_bytes: z.number().nullable(),
          mem_queue_events: z.number().nullable(),
          queue_flush_timeout: z.number().nullable(),
        })
        .nullable(),
      ssl: z
        .object({
          certificate: z.string(),
          certificate_authorities: z.array(z.string()),
          key: z.string(),
          verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
        })
        .partial()
        .nullable(),
      type: z.literal('elasticsearch'),
      write_to_logs_streams: z.boolean(),
    })
    .partial(),
  z
    .object({
      allow_edit: z.array(z.string()),
      ca_sha256: z.string().nullable(),
      ca_trusted_fingerprint: z.string().nullable(),
      config_yaml: z.string().nullable(),
      hosts: z.array(z.string().url()).min(1),
      id: z.string(),
      is_default: z.boolean(),
      is_default_monitoring: z.boolean(),
      is_internal: z.boolean(),
      is_preconfigured: z.boolean(),
      kibana_api_key: z.string().nullable(),
      kibana_url: z.string().nullable(),
      name: z.string(),
      preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']),
      proxy_id: z.string().nullable(),
      secrets: z
        .object({
          service_token: z.union([z.object({ id: z.string() }), z.string()]),
          ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
        })
        .partial(),
      service_token: z.string().nullable(),
      shipper: z
        .object({
          compression_level: z.number().nullable(),
          disk_queue_compression_enabled: z.boolean().nullable(),
          disk_queue_enabled: z.boolean().nullish().default(false),
          disk_queue_encryption_enabled: z.boolean().nullable(),
          disk_queue_max_size: z.number().nullable(),
          disk_queue_path: z.string().nullable(),
          loadbalance: z.boolean().nullable(),
          max_batch_bytes: z.number().nullable(),
          mem_queue_events: z.number().nullable(),
          queue_flush_timeout: z.number().nullable(),
        })
        .nullable(),
      ssl: z
        .object({
          certificate: z.string(),
          certificate_authorities: z.array(z.string()),
          key: z.string(),
          verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
        })
        .partial()
        .nullable(),
      sync_integrations: z.boolean(),
      sync_uninstalled_integrations: z.boolean(),
      type: z.literal('remote_elasticsearch'),
      write_to_logs_streams: z.boolean(),
    })
    .partial(),
  z
    .object({
      allow_edit: z.array(z.string()),
      ca_sha256: z.string().nullable(),
      ca_trusted_fingerprint: z.string().nullable(),
      config_yaml: z.string().nullable(),
      hosts: z.array(z.string()).min(1),
      id: z.string(),
      is_default: z.boolean(),
      is_default_monitoring: z.boolean(),
      is_internal: z.boolean(),
      is_preconfigured: z.boolean(),
      name: z.string(),
      proxy_id: z.string().nullable(),
      secrets: z
        .object({
          ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
        })
        .partial(),
      shipper: z
        .object({
          compression_level: z.number().nullable(),
          disk_queue_compression_enabled: z.boolean().nullable(),
          disk_queue_enabled: z.boolean().nullish().default(false),
          disk_queue_encryption_enabled: z.boolean().nullable(),
          disk_queue_max_size: z.number().nullable(),
          disk_queue_path: z.string().nullable(),
          loadbalance: z.boolean().nullable(),
          max_batch_bytes: z.number().nullable(),
          mem_queue_events: z.number().nullable(),
          queue_flush_timeout: z.number().nullable(),
        })
        .nullable(),
      ssl: z
        .object({
          certificate: z.string(),
          certificate_authorities: z.array(z.string()),
          key: z.string(),
          verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
        })
        .partial()
        .nullable(),
      type: z.literal('logstash'),
      write_to_logs_streams: z.boolean(),
    })
    .partial(),
  z.object({
    allow_edit: z.array(z.string()).optional(),
    auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']).optional(),
    broker_timeout: z.number().optional(),
    ca_sha256: z.string().nullish(),
    ca_trusted_fingerprint: z.string().nullish(),
    client_id: z.string().optional(),
    compression: z.enum(['gzip', 'snappy', 'lz4', 'none']).optional(),
    compression_level: z.union([z.number(), z.unknown()]).nullable(),
    config_yaml: z.string().nullish(),
    connection_type: z.union([z.enum(['plaintext', 'encryption']), z.unknown()]).nullable(),
    hash: z.object({ hash: z.string(), random: z.boolean() }).partial().optional(),
    headers: z.array(z.object({ key: z.string(), value: z.string() })).optional(),
    hosts: z.array(z.string()).min(1).optional(),
    id: z.string().optional(),
    is_default: z.boolean().optional().default(false),
    is_default_monitoring: z.boolean().optional().default(false),
    is_internal: z.boolean().optional(),
    is_preconfigured: z.boolean().optional(),
    key: z.string().optional(),
    name: z.string(),
    partition: z.enum(['random', 'round_robin', 'hash']).optional(),
    password: z.union([z.unknown(), z.union([z.string(), z.unknown()])]).nullable(),
    proxy_id: z.string().nullish(),
    random: z.object({ group_events: z.number() }).partial().optional(),
    required_acks: z.union([z.literal(1), z.literal(0), z.literal(-1)]).optional(),
    round_robin: z.object({ group_events: z.number() }).partial().optional(),
    sasl: z
      .object({ mechanism: z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512']) })
      .partial()
      .nullish(),
    secrets: z
      .object({
        password: z.union([z.object({ id: z.string() }), z.string()]),
        ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }),
      })
      .partial()
      .optional(),
    shipper: z
      .object({
        compression_level: z.number().nullable(),
        disk_queue_compression_enabled: z.boolean().nullable(),
        disk_queue_enabled: z.boolean().nullish().default(false),
        disk_queue_encryption_enabled: z.boolean().nullable(),
        disk_queue_max_size: z.number().nullable(),
        disk_queue_path: z.string().nullable(),
        loadbalance: z.boolean().nullable(),
        max_batch_bytes: z.number().nullable(),
        mem_queue_events: z.number().nullable(),
        queue_flush_timeout: z.number().nullable(),
      })
      .nullish(),
    ssl: z
      .object({
        certificate: z.string(),
        certificate_authorities: z.array(z.string()),
        key: z.string(),
        verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
      })
      .partial()
      .nullish(),
    timeout: z.number().optional(),
    topic: z.string().optional(),
    type: z.literal('kafka').optional(),
    username: z.union([z.string(), z.unknown()]).nullable(),
    version: z.string().optional(),
    write_to_logs_streams: z.boolean().optional(),
  }),
]);
const post_fleet_package_policies_Body = z.union([
  z.object({
    additional_datastreams_permissions: z.array(z.string()).nullish(),
    description: z.string().optional(),
    enabled: z.boolean().optional(),
    force: z.boolean().optional(),
    id: z.string().optional(),
    inputs: z.array(
      z.object({
        config: z
          .record(
            z.object({
              frozen: z.boolean().optional(),
              type: z.string().optional(),
              value: z.unknown(),
            })
          )
          .optional(),
        enabled: z.boolean(),
        id: z.string().optional(),
        keep_enabled: z.boolean().optional(),
        policy_template: z.string().optional(),
        streams: z
          .array(
            z.object({
              compiled_stream: z.unknown(),
              config: z
                .record(
                  z.object({
                    frozen: z.boolean().optional(),
                    type: z.string().optional(),
                    value: z.unknown(),
                  })
                )
                .optional(),
              data_stream: z.object({
                dataset: z.string(),
                elasticsearch: z
                  .object({
                    dynamic_dataset: z.boolean(),
                    dynamic_namespace: z.boolean(),
                    privileges: z.object({ indices: z.array(z.string()) }).partial(),
                  })
                  .partial()
                  .optional(),
                type: z.string(),
              }),
              enabled: z.boolean(),
              id: z.string().optional(),
              keep_enabled: z.boolean().optional(),
              release: z.enum(['ga', 'beta', 'experimental']).optional(),
              vars: z
                .record(
                  z.object({
                    frozen: z.boolean().optional(),
                    type: z.string().optional(),
                    value: z.unknown(),
                  })
                )
                .optional(),
            })
          )
          .optional(),
        type: z.string(),
        vars: z
          .record(
            z.object({
              frozen: z.boolean().optional(),
              type: z.string().optional(),
              value: z.unknown(),
            })
          )
          .optional(),
      })
    ),
    is_managed: z.boolean().optional(),
    name: z.string(),
    namespace: z.string().optional(),
    output_id: z.string().nullish(),
    overrides: z
      .object({ inputs: z.object({}).partial().passthrough() })
      .partial()
      .nullish(),
    package: z
      .object({
        experimental_data_stream_features: z
          .array(
            z.object({
              data_stream: z.string(),
              features: z
                .object({
                  doc_value_only_numeric: z.boolean(),
                  doc_value_only_other: z.boolean(),
                  synthetic_source: z.boolean(),
                  tsdb: z.boolean(),
                })
                .partial(),
            })
          )
          .optional(),
        name: z.string(),
        requires_root: z.boolean().optional(),
        title: z.string().optional(),
        version: z.string(),
      })
      .optional(),
    policy_id: z.string().nullish(),
    policy_ids: z.array(z.string()).optional(),
    spaceIds: z.array(z.string()).optional(),
    supports_agentless: z.boolean().nullish().default(false),
    vars: z
      .record(
        z.object({
          frozen: z.boolean().optional(),
          type: z.string().optional(),
          value: z.unknown(),
        })
      )
      .optional(),
  }),
  z.object({
    additional_datastreams_permissions: z.array(z.string()).nullish(),
    description: z.string().optional(),
    force: z.boolean().optional(),
    id: z.string().optional(),
    inputs: z
      .record(
        z
          .object({
            enabled: z.boolean(),
            streams: z.record(
              z
                .object({
                  enabled: z.boolean(),
                  vars: z.record(
                    z
                      .union([
                        z.boolean(),
                        z.string(),
                        z.number(),
                        z.array(z.string()),
                        z.array(z.number()),
                        z.object({ id: z.string(), isSecretRef: z.boolean() }),
                      ])
                      .nullable()
                  ),
                })
                .partial()
            ),
            vars: z.record(
              z
                .union([
                  z.boolean(),
                  z.string(),
                  z.number(),
                  z.array(z.string()),
                  z.array(z.number()),
                  z.object({ id: z.string(), isSecretRef: z.boolean() }),
                ])
                .nullable()
            ),
          })
          .partial()
      )
      .optional(),
    name: z.string(),
    namespace: z.string().optional(),
    output_id: z.string().nullish(),
    package: z.object({
      experimental_data_stream_features: z
        .array(
          z.object({
            data_stream: z.string(),
            features: z
              .object({
                doc_value_only_numeric: z.boolean(),
                doc_value_only_other: z.boolean(),
                synthetic_source: z.boolean(),
                tsdb: z.boolean(),
              })
              .partial(),
          })
        )
        .optional(),
      name: z.string(),
      requires_root: z.boolean().optional(),
      title: z.string().optional(),
      version: z.string(),
    }),
    policy_id: z.string().nullish(),
    policy_ids: z.array(z.string()).optional(),
    supports_agentless: z.boolean().nullish().default(false),
    vars: z
      .record(
        z
          .union([
            z.boolean(),
            z.string(),
            z.number(),
            z.array(z.string()),
            z.array(z.number()),
            z.object({ id: z.string(), isSecretRef: z.boolean() }),
          ])
          .nullable()
      )
      .optional(),
  }),
]);
const post_fleet_package_policies_bulk_get_Body = z.object({
  ids: z.array(z.string()),
  ignoreMissing: z.boolean().optional(),
});
const put_fleet_package_policies_packagepolicyid_Body = z.union([
  z
    .object({
      additional_datastreams_permissions: z.array(z.string()).nullable(),
      description: z.string(),
      enabled: z.boolean(),
      force: z.boolean(),
      inputs: z.array(
        z.object({
          config: z
            .record(
              z.object({
                frozen: z.boolean().optional(),
                type: z.string().optional(),
                value: z.unknown(),
              })
            )
            .optional(),
          enabled: z.boolean(),
          id: z.string().optional(),
          keep_enabled: z.boolean().optional(),
          policy_template: z.string().optional(),
          streams: z
            .array(
              z.object({
                compiled_stream: z.unknown(),
                config: z
                  .record(
                    z.object({
                      frozen: z.boolean().optional(),
                      type: z.string().optional(),
                      value: z.unknown(),
                    })
                  )
                  .optional(),
                data_stream: z.object({
                  dataset: z.string(),
                  elasticsearch: z
                    .object({
                      dynamic_dataset: z.boolean(),
                      dynamic_namespace: z.boolean(),
                      privileges: z.object({ indices: z.array(z.string()) }).partial(),
                    })
                    .partial()
                    .optional(),
                  type: z.string(),
                }),
                enabled: z.boolean(),
                id: z.string().optional(),
                keep_enabled: z.boolean().optional(),
                release: z.enum(['ga', 'beta', 'experimental']).optional(),
                vars: z
                  .record(
                    z.object({
                      frozen: z.boolean().optional(),
                      type: z.string().optional(),
                      value: z.unknown(),
                    })
                  )
                  .optional(),
              })
            )
            .optional(),
          type: z.string(),
          vars: z
            .record(
              z.object({
                frozen: z.boolean().optional(),
                type: z.string().optional(),
                value: z.unknown(),
              })
            )
            .optional(),
        })
      ),
      is_managed: z.boolean(),
      name: z.string(),
      namespace: z.string(),
      output_id: z.string().nullable(),
      overrides: z
        .object({ inputs: z.object({}).partial().passthrough() })
        .partial()
        .nullable(),
      package: z.object({
        experimental_data_stream_features: z
          .array(
            z.object({
              data_stream: z.string(),
              features: z
                .object({
                  doc_value_only_numeric: z.boolean(),
                  doc_value_only_other: z.boolean(),
                  synthetic_source: z.boolean(),
                  tsdb: z.boolean(),
                })
                .partial(),
            })
          )
          .optional(),
        name: z.string(),
        requires_root: z.boolean().optional(),
        title: z.string().optional(),
        version: z.string(),
      }),
      policy_id: z.string().nullable(),
      policy_ids: z.array(z.string()),
      spaceIds: z.array(z.string()),
      supports_agentless: z.boolean().nullable().default(false),
      vars: z.record(
        z.object({
          frozen: z.boolean().optional(),
          type: z.string().optional(),
          value: z.unknown(),
        })
      ),
      version: z.string(),
    })
    .partial(),
  z.object({
    additional_datastreams_permissions: z.array(z.string()).nullish(),
    description: z.string().optional(),
    force: z.boolean().optional(),
    id: z.string().optional(),
    inputs: z
      .record(
        z
          .object({
            enabled: z.boolean(),
            streams: z.record(
              z
                .object({
                  enabled: z.boolean(),
                  vars: z.record(
                    z
                      .union([
                        z.boolean(),
                        z.string(),
                        z.number(),
                        z.array(z.string()),
                        z.array(z.number()),
                        z.object({ id: z.string(), isSecretRef: z.boolean() }),
                      ])
                      .nullable()
                  ),
                })
                .partial()
            ),
            vars: z.record(
              z
                .union([
                  z.boolean(),
                  z.string(),
                  z.number(),
                  z.array(z.string()),
                  z.array(z.number()),
                  z.object({ id: z.string(), isSecretRef: z.boolean() }),
                ])
                .nullable()
            ),
          })
          .partial()
      )
      .optional(),
    name: z.string(),
    namespace: z.string().optional(),
    output_id: z.string().nullish(),
    package: z.object({
      experimental_data_stream_features: z
        .array(
          z.object({
            data_stream: z.string(),
            features: z
              .object({
                doc_value_only_numeric: z.boolean(),
                doc_value_only_other: z.boolean(),
                synthetic_source: z.boolean(),
                tsdb: z.boolean(),
              })
              .partial(),
          })
        )
        .optional(),
      name: z.string(),
      requires_root: z.boolean().optional(),
      title: z.string().optional(),
      version: z.string(),
    }),
    policy_id: z.string().nullish(),
    policy_ids: z.array(z.string()).optional(),
    supports_agentless: z.boolean().nullish().default(false),
    vars: z
      .record(
        z
          .union([
            z.boolean(),
            z.string(),
            z.number(),
            z.array(z.string()),
            z.array(z.number()),
            z.object({ id: z.string(), isSecretRef: z.boolean() }),
          ])
          .nullable()
      )
      .optional(),
  }),
]);
const post_fleet_package_policies_delete_Body = z.object({
  force: z.boolean().optional(),
  packagePolicyIds: z.array(z.string()),
});
const post_fleet_package_policies_upgrade_Body = z.object({
  packagePolicyIds: z.array(z.string()),
});
const post_fleet_package_policies_upgrade_dryrun_Body = z.object({
  packagePolicyIds: z.array(z.string()),
  packageVersion: z.string().optional(),
});
const post_fleet_proxies_Body = z.object({
  certificate: z.string().nullish(),
  certificate_authorities: z.string().nullish(),
  certificate_key: z.string().nullish(),
  id: z.string().optional(),
  is_preconfigured: z.boolean().optional().default(false),
  name: z.string(),
  proxy_headers: z.record(z.union([z.string(), z.boolean(), z.number()])).nullish(),
  url: z.string(),
});
const put_fleet_proxies_itemid_Body = z.object({
  certificate: z.string().nullable(),
  certificate_authorities: z.string().nullable(),
  certificate_key: z.string().nullable(),
  name: z.string().optional(),
  proxy_headers: z.record(z.union([z.string(), z.boolean(), z.number()])).nullable(),
  url: z.string().optional(),
});
const put_fleet_settings_Body = z
  .object({
    additional_yaml_config: z.string(),
    delete_unenrolled_agents: z.object({ enabled: z.boolean(), is_preconfigured: z.boolean() }),
    has_seen_add_data_notice: z.boolean(),
    kibana_ca_sha256: z.string(),
    kibana_urls: z.array(z.string().url()),
    prerelease_integrations_enabled: z.boolean(),
  })
  .partial();
const put_fleet_space_settings_Body = z
  .object({ allowed_namespace_prefixes: z.array(z.string()) })
  .partial();
const Security_Lists_API_ListVersionId = z.string();
const Security_Lists_API_ListDescription = z.string();
const Security_Lists_API_ListDeserializer = z.string();
const Security_Lists_API_ListId = z.string();
const Security_Lists_API_ListMetadata = z.object({}).partial().passthrough();
const Security_Lists_API_ListName = z.string();
const Security_Lists_API_ListSerializer = z.string();
const Security_Lists_API_ListType = z.enum([
  'binary',
  'boolean',
  'byte',
  'date',
  'date_nanos',
  'date_range',
  'double',
  'double_range',
  'float',
  'float_range',
  'geo_point',
  'geo_shape',
  'half_float',
  'integer',
  'integer_range',
  'ip',
  'ip_range',
  'keyword',
  'long',
  'long_range',
  'shape',
  'short',
  'text',
]);
const Security_Lists_API_ListVersion = z.number();
const Security_Lists_API_List = z
  .object({
    _version: Security_Lists_API_ListVersionId.optional(),
    '@timestamp': z.string().datetime({ offset: true }).optional(),
    created_at: z.string().datetime({ offset: true }),
    created_by: z.string(),
    description: Security_Lists_API_ListDescription.min(1),
    deserializer: Security_Lists_API_ListDeserializer.optional(),
    id: Security_Lists_API_ListId.min(1),
    immutable: z.boolean(),
    meta: Security_Lists_API_ListMetadata.optional(),
    name: Security_Lists_API_ListName.min(1),
    serializer: Security_Lists_API_ListSerializer.optional(),
    tie_breaker_id: z.string(),
    type: Security_Lists_API_ListType,
    updated_at: z.string().datetime({ offset: true }),
    updated_by: z.string(),
    version: Security_Lists_API_ListVersion.int().gte(1),
  })
  .passthrough();
const Security_Lists_API_PlatformErrorResponse = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number().int() })
  .passthrough();
const Security_Lists_API_SiemErrorResponse = z
  .object({ message: z.string(), status_code: z.number().int() })
  .passthrough();
const PatchList_Body = z
  .object({
    _version: Security_Lists_API_ListVersionId.optional(),
    description: Security_Lists_API_ListDescription.min(1).optional(),
    id: Security_Lists_API_ListId.min(1),
    meta: Security_Lists_API_ListMetadata.optional(),
    name: Security_Lists_API_ListName.min(1).optional(),
    version: Security_Lists_API_ListVersion.int().gte(1).optional(),
  })
  .passthrough();
const CreateList_Body = z
  .object({
    description: Security_Lists_API_ListDescription.min(1),
    deserializer: Security_Lists_API_ListDeserializer.optional(),
    id: Security_Lists_API_ListId.min(1).optional(),
    meta: Security_Lists_API_ListMetadata.optional(),
    name: Security_Lists_API_ListName.min(1),
    serializer: Security_Lists_API_ListSerializer.optional(),
    type: Security_Lists_API_ListType,
    version: z.number().int().gte(1).optional().default(1),
  })
  .passthrough();
const UpdateList_Body = z
  .object({
    _version: Security_Lists_API_ListVersionId.optional(),
    description: Security_Lists_API_ListDescription.min(1),
    id: Security_Lists_API_ListId.min(1),
    meta: Security_Lists_API_ListMetadata.optional(),
    name: Security_Lists_API_ListName.min(1),
    version: Security_Lists_API_ListVersion.int().gte(1).optional(),
  })
  .passthrough();
const Security_Lists_API_FindListsCursor = z.string();
const Security_Lists_API_ListItemId = z.string();
const Security_Lists_API_ListItemMetadata = z.object({}).partial().passthrough();
const Security_Lists_API_ListItemValue = z.string();
const Security_Lists_API_ListItem = z
  .object({
    _version: Security_Lists_API_ListVersionId.optional(),
    '@timestamp': z.string().datetime({ offset: true }).optional(),
    created_at: z.string().datetime({ offset: true }),
    created_by: z.string(),
    deserializer: Security_Lists_API_ListDeserializer.optional(),
    id: Security_Lists_API_ListItemId.min(1),
    list_id: Security_Lists_API_ListId.min(1),
    meta: Security_Lists_API_ListItemMetadata.optional(),
    serializer: Security_Lists_API_ListSerializer.optional(),
    tie_breaker_id: z.string(),
    type: Security_Lists_API_ListType,
    updated_at: z.string().datetime({ offset: true }),
    updated_by: z.string(),
    value: Security_Lists_API_ListItemValue.min(1),
  })
  .passthrough();
const PatchListItem_Body = z
  .object({
    _version: Security_Lists_API_ListVersionId.optional(),
    id: Security_Lists_API_ListItemId.min(1),
    meta: Security_Lists_API_ListItemMetadata.optional(),
    refresh: z.enum(['true', 'false', 'wait_for']).optional(),
    value: Security_Lists_API_ListItemValue.min(1).optional(),
  })
  .passthrough();
const CreateListItem_Body = z
  .object({
    id: Security_Lists_API_ListItemId.min(1).optional(),
    list_id: Security_Lists_API_ListId.min(1),
    meta: Security_Lists_API_ListItemMetadata.optional(),
    refresh: z.enum(['true', 'false', 'wait_for']).optional(),
    value: Security_Lists_API_ListItemValue.min(1),
  })
  .passthrough();
const UpdateListItem_Body = z
  .object({
    _version: Security_Lists_API_ListVersionId.optional(),
    id: Security_Lists_API_ListItemId.min(1),
    meta: Security_Lists_API_ListItemMetadata.optional(),
    value: Security_Lists_API_ListItemValue.min(1),
  })
  .passthrough();
const Security_Lists_API_FindListItemsCursor = z.string();
const Security_Lists_API_ListItemPrivileges = z
  .object({
    application: z.record(z.boolean()),
    cluster: z.record(z.boolean()),
    has_all_requested: z.boolean(),
    index: z.record(z.record(z.boolean())),
    username: z.string(),
  })
  .passthrough();
const Security_Lists_API_ListPrivileges = z
  .object({
    application: z.record(z.boolean()),
    cluster: z.record(z.boolean()),
    has_all_requested: z.boolean(),
    index: z.record(z.record(z.boolean())),
    username: z.string(),
  })
  .passthrough();
const put_logstash_pipeline_Body = z
  .object({
    description: z.string().optional(),
    pipeline: z.string(),
    settings: z.object({}).partial().passthrough().optional(),
  })
  .passthrough();
const post_maintenance_window_Body = z.object({
  enabled: z.boolean().optional(),
  schedule: z.object({
    custom: z.object({
      duration: z.string(),
      recurring: z
        .object({
          end: z.string(),
          every: z.string(),
          occurrences: z.number().gte(1),
          onMonth: z.array(z.number().gte(1).lte(12)).min(1),
          onMonthDay: z.array(z.number().gte(1).lte(31)).min(1),
          onWeekDay: z.array(z.string()).min(1),
        })
        .partial()
        .optional(),
      start: z.string(),
      timezone: z.string().optional(),
    }),
  }),
  scope: z.object({ alerting: z.object({ query: z.object({ kql: z.string() }) }) }).optional(),
  title: z.string(),
});
const patch_maintenance_window_id_Body = z
  .object({
    enabled: z.boolean(),
    schedule: z.object({
      custom: z.object({
        duration: z.string(),
        recurring: z
          .object({
            end: z.string(),
            every: z.string(),
            occurrences: z.number().gte(1),
            onMonth: z.array(z.number().gte(1).lte(12)).min(1),
            onMonthDay: z.array(z.number().gte(1).lte(31)).min(1),
            onWeekDay: z.array(z.string()).min(1),
          })
          .partial()
          .optional(),
        start: z.string(),
        timezone: z.string().optional(),
      }),
    }),
    scope: z.object({ alerting: z.object({ query: z.object({ kql: z.string() }) }) }),
    title: z.string(),
  })
  .partial();
const Machine_learning_APIs_mlSyncResponseSuccess = z.boolean();
const Machine_learning_APIs_mlSyncResponseDatafeeds = z
  .object({ success: Machine_learning_APIs_mlSyncResponseSuccess })
  .partial()
  .passthrough();
const Machine_learning_APIs_mlSyncResponseAnomalyDetectors = z
  .object({ success: Machine_learning_APIs_mlSyncResponseSuccess })
  .partial()
  .passthrough();
const Machine_learning_APIs_mlSyncResponseDataFrameAnalytics = z
  .object({ success: Machine_learning_APIs_mlSyncResponseSuccess })
  .partial()
  .passthrough();
const Machine_learning_APIs_mlSyncResponseTrainedModels = z
  .object({ success: Machine_learning_APIs_mlSyncResponseSuccess })
  .partial()
  .passthrough();
const Machine_learning_APIs_mlSyncResponseSavedObjectsCreated = z
  .object({
    'anomaly-detector': z.record(Machine_learning_APIs_mlSyncResponseAnomalyDetectors),
    'data-frame-analytics': z.record(Machine_learning_APIs_mlSyncResponseDataFrameAnalytics),
    'trained-model': z.record(Machine_learning_APIs_mlSyncResponseTrainedModels),
  })
  .partial()
  .passthrough();
const Machine_learning_APIs_mlSyncResponseSavedObjectsDeleted = z
  .object({
    'anomaly-detector': z.record(Machine_learning_APIs_mlSyncResponseAnomalyDetectors),
    'data-frame-analytics': z.record(Machine_learning_APIs_mlSyncResponseDataFrameAnalytics),
    'trained-model': z.record(Machine_learning_APIs_mlSyncResponseTrainedModels),
  })
  .partial()
  .passthrough();
const Machine_learning_APIs_mlSync200Response = z
  .object({
    datafeedsAdded: z.record(Machine_learning_APIs_mlSyncResponseDatafeeds),
    datafeedsRemoved: z.record(Machine_learning_APIs_mlSyncResponseDatafeeds),
    savedObjectsCreated: Machine_learning_APIs_mlSyncResponseSavedObjectsCreated,
    savedObjectsDeleted: Machine_learning_APIs_mlSyncResponseSavedObjectsDeleted,
  })
  .partial()
  .passthrough();
const Machine_learning_APIs_mlSync4xxResponse = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number().int() })
  .partial()
  .passthrough();
const DeleteNote_Body = z.union([
  z.object({ noteId: z.string() }).passthrough(),
  z.object({ noteIds: z.array(z.string()).nullable() }).passthrough(),
]);
const Security_Timeline_API_NoteCreatedAndUpdatedMetadata = z
  .object({
    created: z.number().nullable(),
    createdBy: z.string().nullable(),
    updated: z.number().nullable(),
    updatedBy: z.string().nullable(),
  })
  .partial()
  .passthrough();
const Security_Timeline_API_BareNote = Security_Timeline_API_NoteCreatedAndUpdatedMetadata.and(
  z
    .object({ eventId: z.string().nullish(), note: z.string().nullish(), timelineId: z.string() })
    .passthrough()
);
const Security_Timeline_API_Note = Security_Timeline_API_BareNote.and(
  z.object({ noteId: z.string(), version: z.string() }).passthrough()
);
const Security_Timeline_API_GetNotesResult = z
  .object({ notes: z.array(Security_Timeline_API_Note), totalCount: z.number() })
  .passthrough();
const PersistNoteRoute_Body = z
  .object({
    note: Security_Timeline_API_BareNote,
    noteId: z.string().nullish(),
    version: z.string().nullish(),
  })
  .passthrough();
const Security_Timeline_API_ResponseNote = z
  .object({ note: Security_Timeline_API_Note })
  .passthrough();
const Observability_AI_Assistant_API_Function = z
  .object({
    description: z.string(),
    name: z.string(),
    parameters: z.object({}).partial().passthrough(),
  })
  .partial()
  .passthrough();
const Observability_AI_Assistant_API_Instruction = z.union([
  z.string(),
  z.object({ id: z.string(), text: z.string() }).passthrough(),
]);
const Observability_AI_Assistant_API_FunctionCall = z
  .object({
    arguments: z.string().optional(),
    name: z.string(),
    trigger: z.enum(['assistant', 'user', 'elastic']),
  })
  .passthrough();
const Observability_AI_Assistant_API_MessageRoleEnum = z.enum([
  'system',
  'assistant',
  'function',
  'user',
  'elastic',
]);
const Observability_AI_Assistant_API_Message = z
  .object({
    '@timestamp': z.string(),
    message: z
      .object({
        content: z.string().optional(),
        data: z.string().optional(),
        event: z.string().optional(),
        function_call: Observability_AI_Assistant_API_FunctionCall.optional(),
        name: z.string().optional(),
        role: Observability_AI_Assistant_API_MessageRoleEnum,
      })
      .passthrough(),
  })
  .passthrough();
const observability_ai_assistant_chat_complete_Body = z
  .object({
    actions: z.array(Observability_AI_Assistant_API_Function).optional(),
    connectorId: z.string(),
    conversationId: z.string().optional(),
    disableFunctions: z.boolean().optional(),
    instructions: z.array(Observability_AI_Assistant_API_Instruction).optional(),
    messages: z.array(Observability_AI_Assistant_API_Message),
    persist: z.boolean(),
    title: z.string().optional(),
  })
  .passthrough();
const Security_Osquery_API_FindLiveQueryResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_ECSMappingItem = z
  .object({ field: z.string(), value: z.union([z.string(), z.array(z.string())]) })
  .partial()
  .passthrough();
const Security_Osquery_API_ECSMapping = z.record(Security_Osquery_API_ECSMappingItem);
const Security_Osquery_API_ECSMappingOrUndefined = Security_Osquery_API_ECSMapping;
const Security_Osquery_API_PackId = z.string();
const Security_Osquery_API_PackIdOrUndefined = Security_Osquery_API_PackId;
const Security_Osquery_API_QueryId = z.string();
const Security_Osquery_API_Platform = z.string();
const Security_Osquery_API_PlatformOrUndefined = Security_Osquery_API_Platform;
const Security_Osquery_API_Query = z.string();
const Security_Osquery_API_Removed = z.boolean();
const Security_Osquery_API_RemovedOrUndefined = Security_Osquery_API_Removed;
const Security_Osquery_API_Snapshot = z.boolean();
const Security_Osquery_API_SnapshotOrUndefined = Security_Osquery_API_Snapshot;
const Security_Osquery_API_Version = z.string();
const Security_Osquery_API_VersionOrUndefined = Security_Osquery_API_Version;
const Security_Osquery_API_ArrayQueriesItem = z
  .object({
    ecs_mapping: Security_Osquery_API_ECSMappingOrUndefined.nullable(),
    id: Security_Osquery_API_QueryId,
    platform: Security_Osquery_API_PlatformOrUndefined.nullable(),
    query: Security_Osquery_API_Query,
    removed: Security_Osquery_API_RemovedOrUndefined.nullable(),
    snapshot: Security_Osquery_API_SnapshotOrUndefined.nullable(),
    version: Security_Osquery_API_VersionOrUndefined.nullable(),
  })
  .partial()
  .passthrough();
const Security_Osquery_API_ArrayQueries = z.array(Security_Osquery_API_ArrayQueriesItem);
const Security_Osquery_API_QueryOrUndefined = Security_Osquery_API_Query;
const Security_Osquery_API_SavedQueryId = z.string();
const Security_Osquery_API_SavedQueryIdOrUndefined = Security_Osquery_API_SavedQueryId;
const Security_Osquery_API_CreateLiveQueryRequestBody = z
  .object({
    agent_all: z.boolean(),
    agent_ids: z.array(z.string()),
    agent_platforms: z.array(z.string()),
    agent_policy_ids: z.array(z.string()),
    alert_ids: z.array(z.string()),
    case_ids: z.array(z.string()),
    ecs_mapping: Security_Osquery_API_ECSMappingOrUndefined.nullable(),
    event_ids: z.array(z.string()),
    metadata: z.object({}).partial().passthrough().nullable(),
    pack_id: Security_Osquery_API_PackIdOrUndefined.nullable(),
    queries: Security_Osquery_API_ArrayQueries,
    query: Security_Osquery_API_QueryOrUndefined.nullable(),
    saved_query_id: Security_Osquery_API_SavedQueryIdOrUndefined.nullable(),
  })
  .partial()
  .passthrough();
const Security_Osquery_API_CreateLiveQueryResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_FindLiveQueryDetailsResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_GetLiveQueryResultsResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_FindPacksResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_PackDescription = z.string();
const Security_Osquery_API_PackDescriptionOrUndefined = Security_Osquery_API_PackDescription;
const Security_Osquery_API_Enabled = z.boolean();
const Security_Osquery_API_EnabledOrUndefined = Security_Osquery_API_Enabled;
const Security_Osquery_API_PackName = z.string();
const Security_Osquery_API_PolicyIds = z.array(z.string());
const Security_Osquery_API_PolicyIdsOrUndefined = Security_Osquery_API_PolicyIds;
const Security_Osquery_API_ObjectQueriesItem = z
  .object({
    ecs_mapping: Security_Osquery_API_ECSMappingOrUndefined.nullable(),
    id: Security_Osquery_API_QueryId,
    platform: Security_Osquery_API_PlatformOrUndefined.nullable(),
    query: Security_Osquery_API_Query,
    removed: Security_Osquery_API_RemovedOrUndefined.nullable(),
    saved_query_id: Security_Osquery_API_SavedQueryIdOrUndefined.nullable(),
    snapshot: Security_Osquery_API_SnapshotOrUndefined.nullable(),
    version: Security_Osquery_API_VersionOrUndefined.nullable(),
  })
  .partial()
  .passthrough();
const Security_Osquery_API_ObjectQueries = z.record(Security_Osquery_API_ObjectQueriesItem);
const Security_Osquery_API_Shards = z.record(z.number());
const Security_Osquery_API_CreatePacksRequestBody = z
  .object({
    description: Security_Osquery_API_PackDescriptionOrUndefined.nullable(),
    enabled: Security_Osquery_API_EnabledOrUndefined.nullable(),
    name: Security_Osquery_API_PackName,
    policy_ids: Security_Osquery_API_PolicyIdsOrUndefined.nullable(),
    queries: Security_Osquery_API_ObjectQueries,
    shards: Security_Osquery_API_Shards,
  })
  .partial()
  .passthrough();
const Security_Osquery_API_CreatePacksResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_FindPackResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_UpdatePacksRequestBody = z
  .object({
    description: Security_Osquery_API_PackDescriptionOrUndefined.nullable(),
    enabled: Security_Osquery_API_EnabledOrUndefined.nullable(),
    name: Security_Osquery_API_PackName,
    policy_ids: Security_Osquery_API_PolicyIdsOrUndefined.nullable(),
    queries: Security_Osquery_API_ObjectQueries,
    shards: Security_Osquery_API_Shards,
  })
  .partial()
  .passthrough();
const Security_Osquery_API_UpdatePacksResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_FindSavedQueryResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_SavedQueryDescription = z.string();
const Security_Osquery_API_SavedQueryDescriptionOrUndefined =
  Security_Osquery_API_SavedQueryDescription;
const Security_Osquery_API_Interval = z.string();
const Security_Osquery_API_CreateSavedQueryRequestBody = z
  .object({
    description: Security_Osquery_API_SavedQueryDescriptionOrUndefined.nullable(),
    ecs_mapping: Security_Osquery_API_ECSMappingOrUndefined.nullable(),
    id: Security_Osquery_API_SavedQueryId,
    interval: Security_Osquery_API_Interval,
    platform: Security_Osquery_API_PlatformOrUndefined.nullable(),
    query: Security_Osquery_API_QueryOrUndefined.nullable(),
    removed: Security_Osquery_API_RemovedOrUndefined.nullable(),
    snapshot: Security_Osquery_API_SnapshotOrUndefined.nullable(),
    version: Security_Osquery_API_VersionOrUndefined.nullable(),
  })
  .partial()
  .passthrough();
const Security_Osquery_API_CreateSavedQueryResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_DefaultSuccessResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_FindSavedQueryDetailResponse = z.object({}).partial().passthrough();
const Security_Osquery_API_IntervalOrUndefined = Security_Osquery_API_Interval;
const Security_Osquery_API_UpdateSavedQueryRequestBody = z
  .object({
    description: Security_Osquery_API_SavedQueryDescriptionOrUndefined.nullable(),
    ecs_mapping: Security_Osquery_API_ECSMappingOrUndefined.nullable(),
    id: Security_Osquery_API_SavedQueryId,
    interval: Security_Osquery_API_IntervalOrUndefined.nullable(),
    platform: Security_Osquery_API_PlatformOrUndefined.nullable(),
    query: Security_Osquery_API_QueryOrUndefined.nullable(),
    removed: Security_Osquery_API_RemovedOrUndefined.nullable(),
    snapshot: Security_Osquery_API_SnapshotOrUndefined.nullable(),
    version: Security_Osquery_API_VersionOrUndefined.nullable(),
  })
  .partial()
  .passthrough();
const Security_Osquery_API_UpdateSavedQueryResponse = z.object({}).partial().passthrough();
const PersistPinnedEventRoute_Body = z
  .object({ eventId: z.string(), pinnedEventId: z.string().nullish(), timelineId: z.string() })
  .passthrough();
const Security_Timeline_API_PinnedEventCreatedAndUpdatedMetadata = z
  .object({
    created: z.number().nullable(),
    createdBy: z.string().nullable(),
    updated: z.number().nullable(),
    updatedBy: z.string().nullable(),
  })
  .partial()
  .passthrough();
const Security_Timeline_API_BarePinnedEvent =
  Security_Timeline_API_PinnedEventCreatedAndUpdatedMetadata.and(
    z.object({ eventId: z.string(), timelineId: z.string() }).passthrough()
  );
const Security_Timeline_API_PinnedEvent = Security_Timeline_API_BarePinnedEvent.and(
  z.object({ pinnedEventId: z.string(), version: z.string() }).passthrough()
);
const Security_Timeline_API_PersistPinnedEventResponse = z.union([
  Security_Timeline_API_PinnedEvent,
  z.object({ unpinned: z.boolean() }).passthrough(),
]);
const Security_Entity_Analytics_API_TaskManagerUnavailableResponse = z
  .object({ message: z.string(), status_code: z.number().int().gte(400) })
  .passthrough();
const Security_Entity_Analytics_API_CleanUpRiskEngineErrorResponse = z
  .object({
    cleanup_successful: z.boolean(),
    errors: z.array(z.object({ error: z.string(), seq: z.number().int() }).passthrough()),
  })
  .passthrough();
const ConfigureRiskEngineSavedObject_Body = z
  .object({
    exclude_alert_statuses: z.array(z.string()),
    exclude_alert_tags: z.array(z.string()),
    range: z.object({ end: z.string(), start: z.string() }).partial().passthrough(),
  })
  .partial()
  .passthrough();
const Security_Entity_Analytics_API_ConfigureRiskEngineSavedObjectErrorResponse = z
  .object({
    errors: z.array(z.object({ error: z.string(), seq: z.number().int() }).passthrough()),
    risk_engine_saved_object_configured: z.boolean(),
  })
  .passthrough();
const Security_Entity_Analytics_API_RiskEngineScheduleNowResponse = z
  .object({ success: z.boolean() })
  .partial()
  .passthrough();
const Security_Entity_Analytics_API_RiskEngineScheduleNowErrorResponse = z
  .object({ full_error: z.string(), message: z.string() })
  .passthrough();
const post_saved_objects_export_Body = z
  .object({
    excludeExportDetails: z.boolean().default(false),
    hasReference: z.union([
      z.object({ id: z.string(), type: z.string() }),
      z.array(z.object({ id: z.string(), type: z.string() })),
    ]),
    includeReferencesDeep: z.boolean().default(false),
    objects: z.array(z.object({ id: z.string(), type: z.string() })).max(10000),
    search: z.string(),
    type: z.union([z.string(), z.array(z.string())]),
  })
  .partial();
const resolveImportErrors_Body = z
  .object({
    file: z.instanceof(File).optional(),
    retries: z.array(
      z
        .object({
          destinationId: z.string().optional(),
          id: z.string(),
          ignoreMissingReferences: z.boolean().optional(),
          overwrite: z.boolean().optional(),
          replaceReferences: z
            .array(
              z
                .object({ from: z.string(), to: z.string(), type: z.string() })
                .partial()
                .passthrough()
            )
            .optional(),
          type: z.string(),
        })
        .passthrough()
    ),
  })
  .passthrough();
const Security_AI_Assistant_API_AnonymizationFieldCreateProps = z
  .object({
    allowed: z.boolean().optional(),
    anonymized: z.boolean().optional(),
    field: z.string(),
  })
  .passthrough();
const Security_AI_Assistant_API_AnonymizationFieldUpdateProps = z
  .object({ allowed: z.boolean().optional(), anonymized: z.boolean().optional(), id: z.string() })
  .passthrough();
const PerformAnonymizationFieldsBulkAction_Body = z
  .object({
    create: z.array(Security_AI_Assistant_API_AnonymizationFieldCreateProps),
    delete: z
      .object({ ids: z.array(z.string()).min(1), query: z.string() })
      .partial()
      .passthrough(),
    update: z.array(Security_AI_Assistant_API_AnonymizationFieldUpdateProps),
  })
  .partial()
  .passthrough();
const Security_AI_Assistant_API_AnonymizationFieldDetailsInError = z
  .object({ id: z.string(), name: z.string().optional() })
  .passthrough();
const Security_AI_Assistant_API_NormalizedAnonymizationFieldError = z
  .object({
    anonymization_fields: z.array(Security_AI_Assistant_API_AnonymizationFieldDetailsInError),
    err_code: z.string().optional(),
    message: z.string(),
    status_code: z.number().int(),
  })
  .passthrough();
const Security_AI_Assistant_API_NonEmptyString = z.string();
const Security_AI_Assistant_API_NonEmptyTimestamp = z.string();
const Security_AI_Assistant_API_AnonymizationFieldResponse = z
  .object({
    allowed: z.boolean().optional(),
    anonymized: z.boolean().optional(),
    createdAt: z.string().optional(),
    createdBy: z.string().optional(),
    field: z.string(),
    id: Security_AI_Assistant_API_NonEmptyString.min(1),
    namespace: z.string().optional(),
    timestamp: Security_AI_Assistant_API_NonEmptyTimestamp.min(1).optional(),
    updatedAt: z.string().optional(),
    updatedBy: z.string().optional(),
  })
  .passthrough();
const Security_AI_Assistant_API_AnonymizationFieldsBulkActionSkipReason = z.literal(
  'ANONYMIZATION_FIELD_NOT_MODIFIED'
);
const Security_AI_Assistant_API_AnonymizationFieldsBulkActionSkipResult = z
  .object({
    id: z.string(),
    name: z.string().optional(),
    skip_reason: Security_AI_Assistant_API_AnonymizationFieldsBulkActionSkipReason,
  })
  .passthrough();
const Security_AI_Assistant_API_AnonymizationFieldsBulkCrudActionResults = z
  .object({
    created: z.array(Security_AI_Assistant_API_AnonymizationFieldResponse),
    deleted: z.array(z.string()),
    skipped: z.array(Security_AI_Assistant_API_AnonymizationFieldsBulkActionSkipResult),
    updated: z.array(Security_AI_Assistant_API_AnonymizationFieldResponse),
  })
  .passthrough();
const Security_AI_Assistant_API_BulkCrudActionSummary = z
  .object({
    failed: z.number().int(),
    skipped: z.number().int(),
    succeeded: z.number().int(),
    total: z.number().int(),
  })
  .passthrough();
const Security_AI_Assistant_API_AnonymizationFieldsBulkCrudActionResponse = z
  .object({
    anonymization_fields_count: z.number().int().optional(),
    attributes: z
      .object({
        errors: z.array(Security_AI_Assistant_API_NormalizedAnonymizationFieldError).optional(),
        results: Security_AI_Assistant_API_AnonymizationFieldsBulkCrudActionResults,
        summary: Security_AI_Assistant_API_BulkCrudActionSummary,
      })
      .passthrough(),
    message: z.string().optional(),
    status_code: z.number().int().optional(),
    success: z.boolean().optional(),
  })
  .passthrough();
const Security_AI_Assistant_API_MessageData = z.object({}).partial().passthrough();
const Security_AI_Assistant_API_ChatMessageRole = z.enum(['system', 'user', 'assistant']);
const Security_AI_Assistant_API_ChatMessage = z
  .object({
    content: z.string().optional(),
    data: Security_AI_Assistant_API_MessageData.optional(),
    fields_to_anonymize: z.array(z.string()).optional(),
    role: Security_AI_Assistant_API_ChatMessageRole,
  })
  .passthrough();
const Security_AI_Assistant_API_ChatCompleteProps = z
  .object({
    connectorId: z.string(),
    conversationId: Security_AI_Assistant_API_NonEmptyString.min(1).optional(),
    isStream: z.boolean().optional(),
    langSmithApiKey: z.string().optional(),
    langSmithProject: z.string().optional(),
    messages: z.array(Security_AI_Assistant_API_ChatMessage),
    model: z.string().optional(),
    persist: z.boolean(),
    promptId: z.string().optional(),
    responseLanguage: z.string().optional(),
  })
  .passthrough();
const DeleteAllConversations_Body = z
  .object({ excludedIds: z.array(z.string()) })
  .partial()
  .passthrough();
const Security_AI_Assistant_API_Provider = z.enum(['OpenAI', 'Azure OpenAI', 'Other']);
const Security_AI_Assistant_API_ApiConfig = z
  .object({
    actionTypeId: z.string(),
    connectorId: z.string(),
    defaultSystemPromptId: z.string().optional(),
    model: z.string().optional(),
    provider: Security_AI_Assistant_API_Provider.optional(),
  })
  .passthrough();
const Security_AI_Assistant_API_ConversationCategory = z.enum(['assistant', 'insights']);
const Security_AI_Assistant_API_BaseContentReference = z
  .object({ id: z.string(), type: z.string() })
  .passthrough();
const Security_AI_Assistant_API_KnowledgeBaseEntryContentReference =
  Security_AI_Assistant_API_BaseContentReference.and(
    z
      .object({
        knowledgeBaseEntryId: z.string(),
        knowledgeBaseEntryName: z.string(),
        type: z.literal('KnowledgeBaseEntry'),
      })
      .passthrough()
  );
const Security_AI_Assistant_API_SecurityAlertContentReference =
  Security_AI_Assistant_API_BaseContentReference.and(
    z.object({ alertId: z.string(), type: z.literal('SecurityAlert') }).passthrough()
  );
const Security_AI_Assistant_API_SecurityAlertsPageContentReference =
  Security_AI_Assistant_API_BaseContentReference.and(
    z.object({ type: z.literal('SecurityAlertsPage') }).passthrough()
  );
const Security_AI_Assistant_API_ProductDocumentationContentReference =
  Security_AI_Assistant_API_BaseContentReference.and(
    z
      .object({ title: z.string(), type: z.literal('ProductDocumentation'), url: z.string() })
      .passthrough()
  );
const Security_AI_Assistant_API_EsqlContentReference =
  Security_AI_Assistant_API_BaseContentReference.and(
    z
      .object({
        label: z.string(),
        query: z.string(),
        timerange: z.object({ from: z.string(), to: z.string() }).passthrough().optional(),
        type: z.literal('EsqlQuery'),
      })
      .passthrough()
  );
const Security_AI_Assistant_API_HrefContentReference =
  Security_AI_Assistant_API_BaseContentReference.and(
    z
      .object({ href: z.string(), label: z.string().optional(), type: z.literal('Href') })
      .passthrough()
  );
const Security_AI_Assistant_API_ContentReferences = z.record(
  z.union([
    Security_AI_Assistant_API_KnowledgeBaseEntryContentReference,
    Security_AI_Assistant_API_SecurityAlertContentReference,
    Security_AI_Assistant_API_SecurityAlertsPageContentReference,
    Security_AI_Assistant_API_ProductDocumentationContentReference,
    Security_AI_Assistant_API_EsqlContentReference,
    Security_AI_Assistant_API_HrefContentReference,
  ])
);
const Security_AI_Assistant_API_MessageMetadata = z
  .object({ contentReferences: Security_AI_Assistant_API_ContentReferences })
  .partial()
  .passthrough();
const Security_AI_Assistant_API_Reader = z.object({}).partial().passthrough();
const Security_AI_Assistant_API_MessageRole = z.enum(['system', 'user', 'assistant']);
const Security_AI_Assistant_API_TraceData = z
  .object({ traceId: z.string(), transactionId: z.string() })
  .partial()
  .passthrough();
const Security_AI_Assistant_API_User = z
  .object({ id: z.string(), name: z.string() })
  .partial()
  .passthrough();
const Security_AI_Assistant_API_Message = z
  .object({
    content: z.string(),
    id: Security_AI_Assistant_API_NonEmptyString.min(1).optional(),
    isError: z.boolean().optional(),
    metadata: Security_AI_Assistant_API_MessageMetadata.optional(),
    reader: Security_AI_Assistant_API_Reader.optional(),
    role: Security_AI_Assistant_API_MessageRole,
    timestamp: Security_AI_Assistant_API_NonEmptyTimestamp.min(1),
    traceData: Security_AI_Assistant_API_TraceData.optional(),
    user: Security_AI_Assistant_API_User.optional(),
  })
  .passthrough();
const Security_AI_Assistant_API_Replacements = z.record(z.string());
const Security_AI_Assistant_API_ConversationCreateProps = z
  .object({
    apiConfig: Security_AI_Assistant_API_ApiConfig.optional(),
    category: Security_AI_Assistant_API_ConversationCategory.optional(),
    excludeFromLastConversationStorage: z.boolean().optional(),
    id: z.string().optional(),
    messages: z.array(Security_AI_Assistant_API_Message).optional(),
    replacements: Security_AI_Assistant_API_Replacements.optional(),
    title: z.string(),
  })
  .passthrough();
const Security_AI_Assistant_API_ConversationResponse = z
  .object({
    apiConfig: Security_AI_Assistant_API_ApiConfig.optional(),
    category: Security_AI_Assistant_API_ConversationCategory,
    createdAt: z.string(),
    createdBy: Security_AI_Assistant_API_User,
    excludeFromLastConversationStorage: z.boolean().optional(),
    id: Security_AI_Assistant_API_NonEmptyString.min(1),
    messages: z.array(Security_AI_Assistant_API_Message).optional(),
    namespace: z.string(),
    replacements: Security_AI_Assistant_API_Replacements.optional(),
    timestamp: Security_AI_Assistant_API_NonEmptyTimestamp.min(1).optional(),
    title: z.string(),
    updatedAt: z.string().optional(),
    users: z.array(Security_AI_Assistant_API_User),
  })
  .passthrough();
const Security_AI_Assistant_API_ConversationUpdateProps = z
  .object({
    apiConfig: Security_AI_Assistant_API_ApiConfig.optional(),
    category: Security_AI_Assistant_API_ConversationCategory.optional(),
    excludeFromLastConversationStorage: z.boolean().optional(),
    id: Security_AI_Assistant_API_NonEmptyString.min(1),
    messages: z.array(Security_AI_Assistant_API_Message).optional(),
    replacements: Security_AI_Assistant_API_Replacements.optional(),
    title: z.string().optional(),
    users: z.array(Security_AI_Assistant_API_User).optional(),
  })
  .passthrough();
const Security_AI_Assistant_API_KnowledgeBaseResponse = z
  .object({ success: z.boolean() })
  .partial()
  .passthrough();
const Security_AI_Assistant_API_KnowledgeBaseResource = z.enum([
  'security_labs',
  'defend_insights',
  'user',
]);
const Security_AI_Assistant_API_DocumentEntryRequiredFields = z
  .object({
    kbResource: Security_AI_Assistant_API_KnowledgeBaseResource,
    source: z.string(),
    text: z.string(),
    type: z.literal('document'),
  })
  .passthrough();
const Security_AI_Assistant_API_Vector = z
  .object({ modelId: z.string(), tokens: z.record(z.number()) })
  .passthrough();
const Security_AI_Assistant_API_DocumentEntryOptionalFields = z
  .object({ required: z.boolean(), vector: Security_AI_Assistant_API_Vector })
  .partial()
  .passthrough();
const Security_AI_Assistant_API_DocumentEntryCreateFields = z
  .object({
    global: z.boolean().optional(),
    name: z.string(),
    namespace: z.string().optional(),
    users: z.array(Security_AI_Assistant_API_User).optional(),
  })
  .passthrough()
  .and(Security_AI_Assistant_API_DocumentEntryRequiredFields)
  .and(Security_AI_Assistant_API_DocumentEntryOptionalFields);
const Security_AI_Assistant_API_IndexEntryRequiredFields = z
  .object({
    description: z.string(),
    field: z.string(),
    index: z.string(),
    queryDescription: z.string(),
    type: z.literal('index'),
  })
  .passthrough();
const Security_AI_Assistant_API_InputSchema = z.array(
  z.object({ description: z.string(), fieldName: z.string(), fieldType: z.string() }).passthrough()
);
const Security_AI_Assistant_API_IndexEntryOptionalFields = z
  .object({ inputSchema: Security_AI_Assistant_API_InputSchema, outputFields: z.array(z.string()) })
  .partial()
  .passthrough();
const Security_AI_Assistant_API_IndexEntryCreateFields = z
  .object({
    global: z.boolean().optional(),
    name: z.string(),
    namespace: z.string().optional(),
    users: z.array(Security_AI_Assistant_API_User).optional(),
  })
  .passthrough()
  .and(Security_AI_Assistant_API_IndexEntryRequiredFields)
  .and(Security_AI_Assistant_API_IndexEntryOptionalFields);
const Security_AI_Assistant_API_KnowledgeBaseEntryCreateProps = z.union([
  Security_AI_Assistant_API_DocumentEntryCreateFields,
  Security_AI_Assistant_API_IndexEntryCreateFields,
]);
const Security_AI_Assistant_API_ResponseFields = z
  .object({
    createdAt: z.string(),
    createdBy: z.string(),
    id: Security_AI_Assistant_API_NonEmptyString.min(1),
    updatedAt: z.string(),
    updatedBy: z.string(),
  })
  .passthrough();
const Security_AI_Assistant_API_DocumentEntryResponseFields =
  Security_AI_Assistant_API_DocumentEntryRequiredFields.and(
    Security_AI_Assistant_API_DocumentEntryOptionalFields
  );
const Security_AI_Assistant_API_DocumentEntry = z
  .object({
    global: z.boolean(),
    name: z.string(),
    namespace: z.string(),
    users: z.array(Security_AI_Assistant_API_User),
  })
  .passthrough()
  .and(Security_AI_Assistant_API_ResponseFields)
  .and(Security_AI_Assistant_API_DocumentEntryResponseFields);
const Security_AI_Assistant_API_IndexEntryResponseFields =
  Security_AI_Assistant_API_IndexEntryRequiredFields.and(
    Security_AI_Assistant_API_IndexEntryOptionalFields
  );
const Security_AI_Assistant_API_IndexEntry = z
  .object({
    global: z.boolean(),
    name: z.string(),
    namespace: z.string(),
    users: z.array(Security_AI_Assistant_API_User),
  })
  .passthrough()
  .and(Security_AI_Assistant_API_ResponseFields)
  .and(Security_AI_Assistant_API_IndexEntryResponseFields);
const Security_AI_Assistant_API_KnowledgeBaseEntryResponse = z.union([
  Security_AI_Assistant_API_DocumentEntry,
  Security_AI_Assistant_API_IndexEntry,
]);
const Security_AI_Assistant_API_KnowledgeBaseEntryErrorSchema = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.number(),
});
const Security_AI_Assistant_API_DocumentEntryUpdateFields = z
  .object({
    global: z.boolean().optional(),
    id: Security_AI_Assistant_API_NonEmptyString.min(1),
    name: z.string().optional(),
    namespace: z.string().optional(),
    users: z.array(Security_AI_Assistant_API_User).optional(),
  })
  .passthrough()
  .and(Security_AI_Assistant_API_DocumentEntryCreateFields);
const Security_AI_Assistant_API_IndexEntryUpdateFields = z
  .object({
    global: z.boolean().optional(),
    id: Security_AI_Assistant_API_NonEmptyString.min(1),
    name: z.string().optional(),
    namespace: z.string().optional(),
    users: z.array(Security_AI_Assistant_API_User).optional(),
  })
  .passthrough()
  .and(Security_AI_Assistant_API_IndexEntryCreateFields);
const Security_AI_Assistant_API_KnowledgeBaseEntryUpdateProps = z.union([
  Security_AI_Assistant_API_DocumentEntryUpdateFields,
  Security_AI_Assistant_API_IndexEntryUpdateFields,
]);
const PerformKnowledgeBaseEntryBulkAction_Body = z
  .object({
    create: z.array(Security_AI_Assistant_API_KnowledgeBaseEntryCreateProps),
    delete: z
      .object({ ids: z.array(z.string()).min(1), query: z.string() })
      .partial()
      .passthrough(),
    update: z.array(Security_AI_Assistant_API_KnowledgeBaseEntryUpdateProps),
  })
  .partial()
  .passthrough();
const Security_AI_Assistant_API_KnowledgeBaseEntryDetailsInError = z
  .object({ id: z.string(), name: z.string().optional() })
  .passthrough();
const Security_AI_Assistant_API_NormalizedKnowledgeBaseEntryError = z
  .object({
    err_code: z.string().optional(),
    knowledgeBaseEntries: z.array(Security_AI_Assistant_API_KnowledgeBaseEntryDetailsInError),
    message: z.string(),
    statusCode: z.number().int(),
  })
  .passthrough();
const Security_AI_Assistant_API_KnowledgeBaseEntryBulkActionSkipReason = z.literal(
  'KNOWLEDGE_BASE_ENTRY_NOT_MODIFIED'
);
const Security_AI_Assistant_API_KnowledgeBaseEntryBulkActionSkipResult = z
  .object({
    id: z.string(),
    name: z.string().optional(),
    skip_reason: Security_AI_Assistant_API_KnowledgeBaseEntryBulkActionSkipReason,
  })
  .passthrough();
const Security_AI_Assistant_API_KnowledgeBaseEntryBulkCrudActionResults = z
  .object({
    created: z.array(Security_AI_Assistant_API_KnowledgeBaseEntryResponse),
    deleted: z.array(z.string()),
    skipped: z.array(Security_AI_Assistant_API_KnowledgeBaseEntryBulkActionSkipResult),
    updated: z.array(Security_AI_Assistant_API_KnowledgeBaseEntryResponse),
  })
  .passthrough();
const Security_AI_Assistant_API_KnowledgeBaseEntryBulkCrudActionSummary = z
  .object({
    failed: z.number().int(),
    skipped: z.number().int(),
    succeeded: z.number().int(),
    total: z.number().int(),
  })
  .passthrough();
const Security_AI_Assistant_API_KnowledgeBaseEntryBulkCrudActionResponse = z
  .object({
    attributes: z
      .object({
        errors: z.array(Security_AI_Assistant_API_NormalizedKnowledgeBaseEntryError).optional(),
        results: Security_AI_Assistant_API_KnowledgeBaseEntryBulkCrudActionResults,
        summary: Security_AI_Assistant_API_KnowledgeBaseEntryBulkCrudActionSummary,
      })
      .passthrough(),
    knowledgeBaseEntriesCount: z.number().int().optional(),
    message: z.string().optional(),
    statusCode: z.number().int().optional(),
    success: z.boolean().optional(),
  })
  .passthrough();
const Security_AI_Assistant_API_DeleteResponseFields = z
  .object({ id: Security_AI_Assistant_API_NonEmptyString.min(1) })
  .passthrough();
const Security_AI_Assistant_API_KnowledgeBaseEntryUpdateRouteProps = z.union([
  Security_AI_Assistant_API_DocumentEntryCreateFields,
  Security_AI_Assistant_API_IndexEntryCreateFields,
]);
const Security_AI_Assistant_API_PromptType = z.enum(['system', 'quick']);
const Security_AI_Assistant_API_PromptCreateProps = z
  .object({
    categories: z.array(z.string()).optional(),
    color: z.string().optional(),
    consumer: z.string().optional(),
    content: z.string(),
    isDefault: z.boolean().optional(),
    isNewConversationDefault: z.boolean().optional(),
    name: z.string(),
    promptType: Security_AI_Assistant_API_PromptType,
  })
  .passthrough();
const Security_AI_Assistant_API_PromptUpdateProps = z
  .object({
    categories: z.array(z.string()).optional(),
    color: z.string().optional(),
    consumer: z.string().optional(),
    content: z.string().optional(),
    id: z.string(),
    isDefault: z.boolean().optional(),
    isNewConversationDefault: z.boolean().optional(),
  })
  .passthrough();
const PerformPromptsBulkAction_Body = z
  .object({
    create: z.array(Security_AI_Assistant_API_PromptCreateProps),
    delete: z
      .object({ ids: z.array(z.string()).min(1), query: z.string() })
      .partial()
      .passthrough(),
    update: z.array(Security_AI_Assistant_API_PromptUpdateProps),
  })
  .partial()
  .passthrough();
const Security_AI_Assistant_API_PromptDetailsInError = z
  .object({ id: z.string(), name: z.string().optional() })
  .passthrough();
const Security_AI_Assistant_API_NormalizedPromptError = z
  .object({
    err_code: z.string().optional(),
    message: z.string(),
    prompts: z.array(Security_AI_Assistant_API_PromptDetailsInError),
    status_code: z.number().int(),
  })
  .passthrough();
const Security_AI_Assistant_API_PromptResponse = z
  .object({
    categories: z.array(z.string()).optional(),
    color: z.string().optional(),
    consumer: z.string().optional(),
    content: z.string(),
    createdAt: z.string().optional(),
    createdBy: z.string().optional(),
    id: Security_AI_Assistant_API_NonEmptyString.min(1),
    isDefault: z.boolean().optional(),
    isNewConversationDefault: z.boolean().optional(),
    name: z.string(),
    namespace: z.string().optional(),
    promptType: Security_AI_Assistant_API_PromptType,
    timestamp: Security_AI_Assistant_API_NonEmptyTimestamp.min(1).optional(),
    updatedAt: z.string().optional(),
    updatedBy: z.string().optional(),
    users: z.array(Security_AI_Assistant_API_User).optional(),
  })
  .passthrough();
const Security_AI_Assistant_API_PromptsBulkActionSkipReason = z.literal(
  'PROMPT_FIELD_NOT_MODIFIED'
);
const Security_AI_Assistant_API_PromptsBulkActionSkipResult = z
  .object({
    id: z.string(),
    name: z.string().optional(),
    skip_reason: Security_AI_Assistant_API_PromptsBulkActionSkipReason,
  })
  .passthrough();
const Security_AI_Assistant_API_PromptsBulkCrudActionResults = z
  .object({
    created: z.array(Security_AI_Assistant_API_PromptResponse),
    deleted: z.array(z.string()),
    skipped: z.array(Security_AI_Assistant_API_PromptsBulkActionSkipResult),
    updated: z.array(Security_AI_Assistant_API_PromptResponse),
  })
  .passthrough();
const Security_AI_Assistant_API_PromptsBulkCrudActionResponse = z
  .object({
    attributes: z
      .object({
        errors: z.array(Security_AI_Assistant_API_NormalizedPromptError).optional(),
        results: Security_AI_Assistant_API_PromptsBulkCrudActionResults,
        summary: Security_AI_Assistant_API_BulkCrudActionSummary,
      })
      .passthrough(),
    message: z.string().optional(),
    prompts_count: z.number().int().optional(),
    status_code: z.number().int().optional(),
    success: z.boolean().optional(),
  })
  .passthrough();
const post_security_role_query_Body = z
  .object({
    filters: z.object({ showReservedRoles: z.boolean() }).partial(),
    from: z.number(),
    query: z.string(),
    size: z.number(),
    sort: z.object({ direction: z.enum(['asc', 'desc']), field: z.string() }),
  })
  .partial();
const put_security_role_name_Body = z.object({
  description: z.string().max(2048).optional(),
  elasticsearch: z
    .object({
      cluster: z.array(z.string()),
      indices: z.array(
        z.object({
          allow_restricted_indices: z.boolean().optional(),
          field_security: z.record(z.array(z.string())).optional(),
          names: z.array(z.string()).min(1),
          privileges: z.array(z.string()).min(1),
          query: z.string().optional(),
        })
      ),
      remote_cluster: z.array(
        z.object({ clusters: z.array(z.string()).min(1), privileges: z.array(z.string()).min(1) })
      ),
      remote_indices: z.array(
        z.object({
          allow_restricted_indices: z.boolean().optional(),
          clusters: z.array(z.string()).min(1),
          field_security: z.record(z.array(z.string())).optional(),
          names: z.array(z.string()).min(1),
          privileges: z.array(z.string()).min(1),
          query: z.string().optional(),
        })
      ),
      run_as: z.array(z.string()),
    })
    .partial(),
  kibana: z
    .array(
      z.object({
        base: z.union([z.array(z.string()), z.array(z.string())]).nullable(),
        feature: z.record(z.array(z.string())).optional(),
        spaces: z
          .union([z.array(z.literal('*')), z.array(z.string())])
          .optional()
          .default(['*']),
      })
    )
    .optional(),
  metadata: z.object({}).partial().passthrough().optional(),
});
const post_security_roles_Body = z.object({
  roles: z.record(
    z.object({
      description: z.string().max(2048).optional(),
      elasticsearch: z
        .object({
          cluster: z.array(z.string()),
          indices: z.array(
            z.object({
              allow_restricted_indices: z.boolean().optional(),
              field_security: z.record(z.array(z.string())).optional(),
              names: z.array(z.string()).min(1),
              privileges: z.array(z.string()).min(1),
              query: z.string().optional(),
            })
          ),
          remote_cluster: z.array(
            z.object({
              clusters: z.array(z.string()).min(1),
              privileges: z.array(z.string()).min(1),
            })
          ),
          remote_indices: z.array(
            z.object({
              allow_restricted_indices: z.boolean().optional(),
              clusters: z.array(z.string()).min(1),
              field_security: z.record(z.array(z.string())).optional(),
              names: z.array(z.string()).min(1),
              privileges: z.array(z.string()).min(1),
              query: z.string().optional(),
            })
          ),
          run_as: z.array(z.string()),
        })
        .partial(),
      kibana: z
        .array(
          z.object({
            base: z.union([z.array(z.string()), z.array(z.string())]).nullable(),
            feature: z.record(z.array(z.string())).optional(),
            spaces: z
              .union([z.array(z.literal('*')), z.array(z.string())])
              .optional()
              .default(['*']),
          })
        )
        .optional(),
      metadata: z.object({}).partial().passthrough().optional(),
    })
  ),
});
const post_security_session_invalidate_Body = z
  .object({
    match: z.enum(['all', 'query']),
    query: z
      .object({
        provider: z.object({ name: z.string().optional(), type: z.string() }).passthrough(),
        username: z.string().optional(),
      })
      .passthrough()
      .optional(),
  })
  .passthrough();
const post_url_Body = z
  .object({
    humanReadableSlug: z.boolean().optional(),
    locatorId: z.string(),
    params: z.object({}).partial().passthrough(),
    slug: z.string().optional(),
  })
  .passthrough();
const Short_URL_APIs_urlResponse = z
  .object({
    accessCount: z.number().int(),
    accessDate: z.string(),
    createDate: z.string(),
    id: z.string(),
    locator: z
      .object({ id: z.string(), state: z.object({}).partial().passthrough(), version: z.string() })
      .partial()
      .passthrough(),
    slug: z.string(),
  })
  .partial()
  .passthrough();
const post_spaces_copy_saved_objects_Body = z.object({
  compatibilityMode: z.boolean().optional().default(false),
  createNewCopies: z.boolean().optional().default(true),
  includeReferences: z.boolean().optional().default(false),
  objects: z.array(z.object({ id: z.string(), type: z.string() })),
  overwrite: z.boolean().optional().default(false),
  spaces: z.array(z.string()),
});
const post_spaces_disable_legacy_url_aliases_Body = z.object({
  aliases: z.array(
    z.object({ sourceId: z.string(), targetSpace: z.string(), targetType: z.string() })
  ),
});
const post_spaces_get_shareable_references_Body = z.object({
  objects: z.array(z.object({ id: z.string(), type: z.string() })),
});
const post_spaces_resolve_copy_saved_objects_errors_Body = z.object({
  compatibilityMode: z.boolean().optional().default(false),
  createNewCopies: z.boolean().optional().default(true),
  includeReferences: z.boolean().optional().default(false),
  objects: z.array(z.object({ id: z.string(), type: z.string() })),
  retries: z.record(
    z.array(
      z.object({
        createNewCopy: z.boolean().optional(),
        destinationId: z.string().optional(),
        id: z.string(),
        ignoreMissingReferences: z.boolean().optional(),
        overwrite: z.boolean().optional().default(false),
        type: z.string(),
      })
    )
  ),
});
const post_spaces_update_objects_spaces_Body = z.object({
  objects: z.array(z.object({ id: z.string(), type: z.string() })),
  spacesToAdd: z.array(z.string()),
  spacesToRemove: z.array(z.string()),
});
const include_authorized_purposes = z.union([z.literal(false), z.boolean()]).nullable();
const post_spaces_space_Body = z.object({
  _reserved: z.boolean().optional(),
  color: z.string().optional(),
  description: z.string().optional(),
  disabledFeatures: z.array(z.string()).optional().default([]),
  id: z.string(),
  imageUrl: z.string().optional(),
  initials: z.string().max(2).optional(),
  name: z.string().min(1),
  solution: z.enum(['security', 'oblt', 'es', 'classic']).optional(),
});
const Kibana_HTTP_APIs_core_status_response = z.object({
  metrics: z.object({
    collection_interval_in_millis: z.number(),
    elasticsearch_client: z.object({
      totalActiveSockets: z.number(),
      totalIdleSockets: z.number(),
      totalQueuedRequests: z.number(),
    }),
    last_updated: z.string(),
  }),
  name: z.string(),
  status: z.object({
    core: z.object({
      elasticsearch: z.object({
        detail: z.string().optional(),
        documentationUrl: z.string().optional(),
        level: z.enum(['available', 'degraded', 'unavailable', 'critical']),
        meta: z.object({}).partial().passthrough(),
        summary: z.string(),
      }),
      http: z
        .object({
          detail: z.string().optional(),
          documentationUrl: z.string().optional(),
          level: z.enum(['available', 'degraded', 'unavailable', 'critical']),
          meta: z.object({}).partial().passthrough(),
          summary: z.string(),
        })
        .optional(),
      savedObjects: z.object({
        detail: z.string().optional(),
        documentationUrl: z.string().optional(),
        level: z.enum(['available', 'degraded', 'unavailable', 'critical']),
        meta: z.object({}).partial().passthrough(),
        summary: z.string(),
      }),
    }),
    overall: z.object({
      detail: z.string().optional(),
      documentationUrl: z.string().optional(),
      level: z.enum(['available', 'degraded', 'unavailable', 'critical']),
      meta: z.object({}).partial().passthrough(),
      summary: z.string(),
    }),
    plugins: z.record(
      z.object({
        detail: z.string().optional(),
        documentationUrl: z.string().optional(),
        level: z.enum(['available', 'degraded', 'unavailable', 'critical']),
        meta: z.object({}).partial().passthrough(),
        summary: z.string(),
      })
    ),
  }),
  uuid: z.string(),
  version: z.object({
    build_date: z.string(),
    build_flavor: z.enum(['serverless', 'traditional']),
    build_hash: z.string(),
    build_number: z.number(),
    build_snapshot: z.boolean(),
    number: z.string(),
  }),
});
const Kibana_HTTP_APIs_core_status_redactedResponse = z.object({
  status: z.object({
    overall: z.object({ level: z.enum(['available', 'degraded', 'unavailable', 'critical']) }),
  }),
});
const get_streams_Body = z.union([z.object({}).partial(), z.unknown(), z.unknown()]);
const put_streams_name_Body = z.union([
  z.union([
    z
      .object({})
      .partial()
      .passthrough()
      .and(
        z
          .object({
            stream: z
              .object({ name: z.unknown() })
              .partial()
              .passthrough()
              .and(z.object({ description: z.string(), name: z.string() })),
          })
          .passthrough()
      )
      .and(
        z
          .object({
            dashboards: z.array(z.string()),
            queries: z.array(
              z
                .object({ id: z.string().min(1), title: z.string().min(1) })
                .passthrough()
                .and(z.object({ kql: z.object({ query: z.string() }) }).passthrough())
            ),
            rules: z.array(z.string()),
          })
          .passthrough()
      )
      .and(
        z
          .object({
            stream: z
              .object({ name: z.unknown() })
              .partial()
              .passthrough()
              .and(
                z
                  .object({})
                  .partial()
                  .passthrough()
                  .and(z.object({ description: z.string(), name: z.string() }).passthrough())
                  .and(
                    z
                      .object({
                        ingest: z.object({
                          lifecycle: z.union([
                            z.object({
                              dsl: z.object({ data_retention: z.string().min(1) }).partial(),
                            }),
                            z.object({ ilm: z.object({ policy: z.string().min(1) }) }),
                            z.object({ inherit: z.object({}).partial() }),
                          ]),
                          processing: z.object({
                            steps: z.array(
                              z.union([
                                z.union([
                                  z.object({
                                    action: z.literal('grok'),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    from: z.string().min(1),
                                    ignore_failure: z.boolean().optional(),
                                    ignore_missing: z.boolean().optional(),
                                    patterns: z.array(z.string().min(1)).min(1),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('dissect'),
                                    append_separator: z.string().min(1).optional(),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    from: z.string().min(1),
                                    ignore_failure: z.boolean().optional(),
                                    ignore_missing: z.boolean().optional(),
                                    pattern: z.string().min(1),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('date'),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    formats: z.array(z.string().min(1)),
                                    from: z.string().min(1),
                                    ignore_failure: z.boolean().optional(),
                                    output_format: z.string().min(1).optional(),
                                    to: z.string().min(1).optional(),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('rename'),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    from: z.string().min(1),
                                    ignore_failure: z.boolean().optional(),
                                    ignore_missing: z.boolean().optional(),
                                    override: z.boolean().optional(),
                                    to: z.string().min(1),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('set'),
                                    copy_from: z.string().min(1).optional(),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    ignore_failure: z.boolean().optional(),
                                    override: z.boolean().optional(),
                                    to: z.string().min(1),
                                    value: z.string().min(1).optional(),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('append'),
                                    allow_duplicates: z.boolean().optional(),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    ignore_failure: z.boolean().optional(),
                                    to: z.string().min(1),
                                    value: z.array(z.unknown()).min(1),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('manual_ingest_pipeline'),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    ignore_failure: z.boolean().optional(),
                                    on_failure: z
                                      .array(z.object({}).partial().passthrough())
                                      .optional(),
                                    processors: z.array(
                                      z.object({
                                        append: z.unknown(),
                                        attachment: z.unknown(),
                                        bytes: z.unknown(),
                                        circle: z.unknown(),
                                        community_id: z.unknown(),
                                        convert: z.unknown(),
                                        csv: z.unknown(),
                                        date: z.unknown(),
                                        date_index_name: z.unknown(),
                                        dissect: z.unknown(),
                                        dot_expander: z.unknown(),
                                        drop: z.unknown(),
                                        enrich: z.unknown(),
                                        fail: z.unknown(),
                                        fingerprint: z.unknown(),
                                        foreach: z.unknown(),
                                        geo_grid: z.unknown(),
                                        geoip: z.unknown(),
                                        grok: z.unknown(),
                                        gsub: z.unknown(),
                                        html_strip: z.unknown(),
                                        inference: z.unknown(),
                                        ip_location: z.unknown(),
                                        join: z.unknown(),
                                        json: z.unknown(),
                                        kv: z.unknown(),
                                        lowercase: z.unknown(),
                                        network_direction: z.unknown(),
                                        pipeline: z.unknown(),
                                        redact: z.unknown(),
                                        registered_domain: z.unknown(),
                                        remove: z.unknown(),
                                        rename: z.unknown(),
                                        reroute: z.unknown(),
                                        script: z.unknown(),
                                        set: z.unknown(),
                                        set_security_user: z.unknown(),
                                        sort: z.unknown(),
                                        split: z.unknown(),
                                        terminate: z.unknown(),
                                        trim: z.unknown(),
                                        uppercase: z.unknown(),
                                        uri_parts: z.unknown(),
                                        urldecode: z.unknown(),
                                        user_agent: z.unknown(),
                                      })
                                    ),
                                    tag: z.string().optional(),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                ]),
                                z.object({
                                  where: z
                                    .union([
                                      z.union([
                                        z.object({
                                          contains: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          endsWith: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          eq: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          field: z.string().min(1),
                                          gt: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          gte: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          lt: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          lte: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          neq: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          range: z
                                            .object({
                                              gt: z.union([z.string(), z.number(), z.boolean()]),
                                              gte: z.union([z.string(), z.number(), z.boolean()]),
                                              lt: z.union([z.string(), z.number(), z.boolean()]),
                                              lte: z.union([z.string(), z.number(), z.boolean()]),
                                            })
                                            .partial()
                                            .optional(),
                                          startsWith: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                        }),
                                        z.object({
                                          exists: z.boolean().optional(),
                                          field: z.string().min(1),
                                        }),
                                      ]),
                                      z.object({ and: z.array(z.unknown()) }),
                                      z.object({ or: z.array(z.unknown()) }),
                                      z.object({ not: z.unknown() }),
                                      z.object({ never: z.object({}).partial() }),
                                      z.object({ always: z.object({}).partial() }),
                                    ])
                                    .and(z.object({ steps: z.array(z.unknown()) }).passthrough()),
                                }),
                              ])
                            ),
                          }),
                        }),
                      })
                      .passthrough()
                  )
                  .and(
                    z
                      .object({
                        ingest: z.object({
                          wired: z.object({
                            fields: z.record(
                              z
                                .record(
                                  z.union([
                                    z.union([
                                      z.string(),
                                      z.number(),
                                      z.boolean(),
                                      z.unknown(),
                                      z.unknown(),
                                    ]),
                                    z.array(
                                      z.union([
                                        z.string(),
                                        z.number(),
                                        z.boolean(),
                                        z.unknown(),
                                        z.unknown(),
                                      ])
                                    ),
                                    z.unknown(),
                                  ])
                                )
                                .and(
                                  z.union([
                                    z.object({
                                      format: z.string().min(1).optional(),
                                      type: z.enum([
                                        'keyword',
                                        'match_only_text',
                                        'long',
                                        'double',
                                        'date',
                                        'boolean',
                                        'ip',
                                      ]),
                                    }),
                                    z.object({ type: z.literal('system') }),
                                  ])
                                )
                            ),
                            routing: z.array(
                              z.object({
                                destination: z.string().min(1),
                                status: z.enum(['enabled', 'disabled']).optional(),
                                where: z.union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ]),
                              })
                            ),
                          }),
                        }),
                      })
                      .passthrough()
                  )
              ),
          })
          .passthrough()
      )
      .and(z.object({}).partial().passthrough())
      .and(
        z
          .object({
            stream: z
              .object({ name: z.unknown() })
              .partial()
              .passthrough()
              .and(z.object({ description: z.string(), name: z.string() })),
          })
          .passthrough()
      )
      .and(
        z
          .object({
            dashboards: z.array(z.string()),
            queries: z.array(
              z
                .object({ id: z.string().min(1), title: z.string().min(1) })
                .passthrough()
                .and(z.object({ kql: z.object({ query: z.string() }) }).passthrough())
            ),
            rules: z.array(z.string()),
          })
          .passthrough()
      )
      .and(
        z
          .object({
            stream: z
              .object({ name: z.unknown() })
              .partial()
              .passthrough()
              .and(
                z.object({
                  ingest: z.object({
                    lifecycle: z.union([
                      z.object({ dsl: z.object({ data_retention: z.string().min(1) }).partial() }),
                      z.object({ ilm: z.object({ policy: z.string().min(1) }) }),
                      z.object({ inherit: z.object({}).partial() }),
                    ]),
                    processing: z.object({
                      steps: z.array(
                        z.union([
                          z.union([
                            z.object({
                              action: z.literal('grok'),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              from: z.string().min(1),
                              ignore_failure: z.boolean().optional(),
                              ignore_missing: z.boolean().optional(),
                              patterns: z.array(z.string().min(1)).min(1),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('dissect'),
                              append_separator: z.string().min(1).optional(),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              from: z.string().min(1),
                              ignore_failure: z.boolean().optional(),
                              ignore_missing: z.boolean().optional(),
                              pattern: z.string().min(1),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('date'),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              formats: z.array(z.string().min(1)),
                              from: z.string().min(1),
                              ignore_failure: z.boolean().optional(),
                              output_format: z.string().min(1).optional(),
                              to: z.string().min(1).optional(),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('rename'),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              from: z.string().min(1),
                              ignore_failure: z.boolean().optional(),
                              ignore_missing: z.boolean().optional(),
                              override: z.boolean().optional(),
                              to: z.string().min(1),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('set'),
                              copy_from: z.string().min(1).optional(),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              ignore_failure: z.boolean().optional(),
                              override: z.boolean().optional(),
                              to: z.string().min(1),
                              value: z.string().min(1).optional(),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('append'),
                              allow_duplicates: z.boolean().optional(),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              ignore_failure: z.boolean().optional(),
                              to: z.string().min(1),
                              value: z.array(z.unknown()).min(1),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('manual_ingest_pipeline'),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              ignore_failure: z.boolean().optional(),
                              on_failure: z.array(z.object({}).partial().passthrough()).optional(),
                              processors: z.array(
                                z.object({
                                  append: z.unknown(),
                                  attachment: z.unknown(),
                                  bytes: z.unknown(),
                                  circle: z.unknown(),
                                  community_id: z.unknown(),
                                  convert: z.unknown(),
                                  csv: z.unknown(),
                                  date: z.unknown(),
                                  date_index_name: z.unknown(),
                                  dissect: z.unknown(),
                                  dot_expander: z.unknown(),
                                  drop: z.unknown(),
                                  enrich: z.unknown(),
                                  fail: z.unknown(),
                                  fingerprint: z.unknown(),
                                  foreach: z.unknown(),
                                  geo_grid: z.unknown(),
                                  geoip: z.unknown(),
                                  grok: z.unknown(),
                                  gsub: z.unknown(),
                                  html_strip: z.unknown(),
                                  inference: z.unknown(),
                                  ip_location: z.unknown(),
                                  join: z.unknown(),
                                  json: z.unknown(),
                                  kv: z.unknown(),
                                  lowercase: z.unknown(),
                                  network_direction: z.unknown(),
                                  pipeline: z.unknown(),
                                  redact: z.unknown(),
                                  registered_domain: z.unknown(),
                                  remove: z.unknown(),
                                  rename: z.unknown(),
                                  reroute: z.unknown(),
                                  script: z.unknown(),
                                  set: z.unknown(),
                                  set_security_user: z.unknown(),
                                  sort: z.unknown(),
                                  split: z.unknown(),
                                  terminate: z.unknown(),
                                  trim: z.unknown(),
                                  uppercase: z.unknown(),
                                  uri_parts: z.unknown(),
                                  urldecode: z.unknown(),
                                  user_agent: z.unknown(),
                                })
                              ),
                              tag: z.string().optional(),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                          ]),
                          z.object({
                            where: z
                              .union([
                                z.union([
                                  z.object({
                                    contains: z
                                      .union([z.string(), z.number(), z.boolean()])
                                      .optional(),
                                    endsWith: z
                                      .union([z.string(), z.number(), z.boolean()])
                                      .optional(),
                                    eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    field: z.string().min(1),
                                    gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    range: z
                                      .object({
                                        gt: z.union([z.string(), z.number(), z.boolean()]),
                                        gte: z.union([z.string(), z.number(), z.boolean()]),
                                        lt: z.union([z.string(), z.number(), z.boolean()]),
                                        lte: z.union([z.string(), z.number(), z.boolean()]),
                                      })
                                      .partial()
                                      .optional(),
                                    startsWith: z
                                      .union([z.string(), z.number(), z.boolean()])
                                      .optional(),
                                  }),
                                  z.object({
                                    exists: z.boolean().optional(),
                                    field: z.string().min(1),
                                  }),
                                ]),
                                z.object({ and: z.array(z.unknown()) }),
                                z.object({ or: z.array(z.unknown()) }),
                                z.object({ not: z.unknown() }),
                                z.object({ never: z.object({}).partial() }),
                                z.object({ always: z.object({}).partial() }),
                              ])
                              .and(z.object({ steps: z.array(z.unknown()) }).passthrough()),
                          }),
                        ])
                      ),
                    }),
                  }),
                })
              ),
          })
          .passthrough()
      )
      .and(z.object({}).partial().passthrough())
      .and(z.object({}).partial().passthrough()),
    z
      .object({})
      .partial()
      .passthrough()
      .and(
        z
          .object({
            stream: z
              .object({ name: z.unknown() })
              .partial()
              .passthrough()
              .and(z.object({ description: z.string(), name: z.string() })),
          })
          .passthrough()
      )
      .and(
        z
          .object({
            dashboards: z.array(z.string()),
            queries: z.array(
              z
                .object({ id: z.string().min(1), title: z.string().min(1) })
                .passthrough()
                .and(z.object({ kql: z.object({ query: z.string() }) }).passthrough())
            ),
            rules: z.array(z.string()),
          })
          .passthrough()
      )
      .and(
        z
          .object({
            stream: z
              .object({ name: z.unknown() })
              .partial()
              .passthrough()
              .and(
                z
                  .object({})
                  .partial()
                  .passthrough()
                  .and(z.object({ description: z.string(), name: z.string() }).passthrough())
                  .and(
                    z
                      .object({
                        ingest: z.object({
                          lifecycle: z.union([
                            z.object({
                              dsl: z.object({ data_retention: z.string().min(1) }).partial(),
                            }),
                            z.object({ ilm: z.object({ policy: z.string().min(1) }) }),
                            z.object({ inherit: z.object({}).partial() }),
                          ]),
                          processing: z.object({
                            steps: z.array(
                              z.union([
                                z.union([
                                  z.object({
                                    action: z.literal('grok'),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    from: z.string().min(1),
                                    ignore_failure: z.boolean().optional(),
                                    ignore_missing: z.boolean().optional(),
                                    patterns: z.array(z.string().min(1)).min(1),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('dissect'),
                                    append_separator: z.string().min(1).optional(),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    from: z.string().min(1),
                                    ignore_failure: z.boolean().optional(),
                                    ignore_missing: z.boolean().optional(),
                                    pattern: z.string().min(1),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('date'),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    formats: z.array(z.string().min(1)),
                                    from: z.string().min(1),
                                    ignore_failure: z.boolean().optional(),
                                    output_format: z.string().min(1).optional(),
                                    to: z.string().min(1).optional(),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('rename'),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    from: z.string().min(1),
                                    ignore_failure: z.boolean().optional(),
                                    ignore_missing: z.boolean().optional(),
                                    override: z.boolean().optional(),
                                    to: z.string().min(1),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('set'),
                                    copy_from: z.string().min(1).optional(),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    ignore_failure: z.boolean().optional(),
                                    override: z.boolean().optional(),
                                    to: z.string().min(1),
                                    value: z.string().min(1).optional(),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('append'),
                                    allow_duplicates: z.boolean().optional(),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    ignore_failure: z.boolean().optional(),
                                    to: z.string().min(1),
                                    value: z.array(z.unknown()).min(1),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                  z.object({
                                    action: z.literal('manual_ingest_pipeline'),
                                    customIdentifier: z.string().min(1).optional(),
                                    description: z.string().optional(),
                                    ignore_failure: z.boolean().optional(),
                                    on_failure: z
                                      .array(z.object({}).partial().passthrough())
                                      .optional(),
                                    processors: z.array(
                                      z.object({
                                        append: z.unknown(),
                                        attachment: z.unknown(),
                                        bytes: z.unknown(),
                                        circle: z.unknown(),
                                        community_id: z.unknown(),
                                        convert: z.unknown(),
                                        csv: z.unknown(),
                                        date: z.unknown(),
                                        date_index_name: z.unknown(),
                                        dissect: z.unknown(),
                                        dot_expander: z.unknown(),
                                        drop: z.unknown(),
                                        enrich: z.unknown(),
                                        fail: z.unknown(),
                                        fingerprint: z.unknown(),
                                        foreach: z.unknown(),
                                        geo_grid: z.unknown(),
                                        geoip: z.unknown(),
                                        grok: z.unknown(),
                                        gsub: z.unknown(),
                                        html_strip: z.unknown(),
                                        inference: z.unknown(),
                                        ip_location: z.unknown(),
                                        join: z.unknown(),
                                        json: z.unknown(),
                                        kv: z.unknown(),
                                        lowercase: z.unknown(),
                                        network_direction: z.unknown(),
                                        pipeline: z.unknown(),
                                        redact: z.unknown(),
                                        registered_domain: z.unknown(),
                                        remove: z.unknown(),
                                        rename: z.unknown(),
                                        reroute: z.unknown(),
                                        script: z.unknown(),
                                        set: z.unknown(),
                                        set_security_user: z.unknown(),
                                        sort: z.unknown(),
                                        split: z.unknown(),
                                        terminate: z.unknown(),
                                        trim: z.unknown(),
                                        uppercase: z.unknown(),
                                        uri_parts: z.unknown(),
                                        urldecode: z.unknown(),
                                        user_agent: z.unknown(),
                                      })
                                    ),
                                    tag: z.string().optional(),
                                    where: z
                                      .union([
                                        z.union([
                                          z.object({
                                            contains: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            endsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            eq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            field: z.string().min(1),
                                            gt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            gte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lt: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            lte: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            neq: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                            range: z
                                              .object({
                                                gt: z.union([z.string(), z.number(), z.boolean()]),
                                                gte: z.union([z.string(), z.number(), z.boolean()]),
                                                lt: z.union([z.string(), z.number(), z.boolean()]),
                                                lte: z.union([z.string(), z.number(), z.boolean()]),
                                              })
                                              .partial()
                                              .optional(),
                                            startsWith: z
                                              .union([z.string(), z.number(), z.boolean()])
                                              .optional(),
                                          }),
                                          z.object({
                                            exists: z.boolean().optional(),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({ and: z.array(z.unknown()) }),
                                        z.object({ or: z.array(z.unknown()) }),
                                        z.object({ not: z.unknown() }),
                                        z.object({ never: z.object({}).partial() }),
                                        z.object({ always: z.object({}).partial() }),
                                      ])
                                      .optional(),
                                  }),
                                ]),
                                z.object({
                                  where: z
                                    .union([
                                      z.union([
                                        z.object({
                                          contains: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          endsWith: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          eq: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          field: z.string().min(1),
                                          gt: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          gte: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          lt: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          lte: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          neq: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                          range: z
                                            .object({
                                              gt: z.union([z.string(), z.number(), z.boolean()]),
                                              gte: z.union([z.string(), z.number(), z.boolean()]),
                                              lt: z.union([z.string(), z.number(), z.boolean()]),
                                              lte: z.union([z.string(), z.number(), z.boolean()]),
                                            })
                                            .partial()
                                            .optional(),
                                          startsWith: z
                                            .union([z.string(), z.number(), z.boolean()])
                                            .optional(),
                                        }),
                                        z.object({
                                          exists: z.boolean().optional(),
                                          field: z.string().min(1),
                                        }),
                                      ]),
                                      z.object({ and: z.array(z.unknown()) }),
                                      z.object({ or: z.array(z.unknown()) }),
                                      z.object({ not: z.unknown() }),
                                      z.object({ never: z.object({}).partial() }),
                                      z.object({ always: z.object({}).partial() }),
                                    ])
                                    .and(z.object({ steps: z.array(z.unknown()) }).passthrough()),
                                }),
                              ])
                            ),
                          }),
                        }),
                      })
                      .passthrough()
                  )
                  .and(
                    z
                      .object({
                        ingest: z.object({
                          classic: z
                            .object({
                              field_overrides: z.record(
                                z
                                  .record(
                                    z.union([
                                      z.union([
                                        z.string(),
                                        z.number(),
                                        z.boolean(),
                                        z.unknown(),
                                        z.unknown(),
                                      ]),
                                      z.array(
                                        z.union([
                                          z.string(),
                                          z.number(),
                                          z.boolean(),
                                          z.unknown(),
                                          z.unknown(),
                                        ])
                                      ),
                                      z.unknown(),
                                    ])
                                  )
                                  .and(
                                    z.union([
                                      z.object({
                                        format: z.string().min(1).optional(),
                                        type: z.enum([
                                          'keyword',
                                          'match_only_text',
                                          'long',
                                          'double',
                                          'date',
                                          'boolean',
                                          'ip',
                                        ]),
                                      }),
                                      z.object({ type: z.literal('system') }),
                                    ])
                                  )
                              ),
                            })
                            .partial(),
                        }),
                      })
                      .passthrough()
                  )
              ),
          })
          .passthrough()
      )
      .and(z.object({}).partial().passthrough())
      .and(
        z
          .object({
            stream: z
              .object({ name: z.unknown() })
              .partial()
              .passthrough()
              .and(z.object({ description: z.string(), name: z.string() })),
          })
          .passthrough()
      )
      .and(
        z
          .object({
            dashboards: z.array(z.string()),
            queries: z.array(
              z
                .object({ id: z.string().min(1), title: z.string().min(1) })
                .passthrough()
                .and(z.object({ kql: z.object({ query: z.string() }) }).passthrough())
            ),
            rules: z.array(z.string()),
          })
          .passthrough()
      )
      .and(
        z
          .object({
            stream: z
              .object({ name: z.unknown() })
              .partial()
              .passthrough()
              .and(
                z.object({
                  ingest: z.object({
                    lifecycle: z.union([
                      z.object({ dsl: z.object({ data_retention: z.string().min(1) }).partial() }),
                      z.object({ ilm: z.object({ policy: z.string().min(1) }) }),
                      z.object({ inherit: z.object({}).partial() }),
                    ]),
                    processing: z.object({
                      steps: z.array(
                        z.union([
                          z.union([
                            z.object({
                              action: z.literal('grok'),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              from: z.string().min(1),
                              ignore_failure: z.boolean().optional(),
                              ignore_missing: z.boolean().optional(),
                              patterns: z.array(z.string().min(1)).min(1),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('dissect'),
                              append_separator: z.string().min(1).optional(),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              from: z.string().min(1),
                              ignore_failure: z.boolean().optional(),
                              ignore_missing: z.boolean().optional(),
                              pattern: z.string().min(1),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('date'),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              formats: z.array(z.string().min(1)),
                              from: z.string().min(1),
                              ignore_failure: z.boolean().optional(),
                              output_format: z.string().min(1).optional(),
                              to: z.string().min(1).optional(),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('rename'),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              from: z.string().min(1),
                              ignore_failure: z.boolean().optional(),
                              ignore_missing: z.boolean().optional(),
                              override: z.boolean().optional(),
                              to: z.string().min(1),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('set'),
                              copy_from: z.string().min(1).optional(),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              ignore_failure: z.boolean().optional(),
                              override: z.boolean().optional(),
                              to: z.string().min(1),
                              value: z.string().min(1).optional(),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('append'),
                              allow_duplicates: z.boolean().optional(),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              ignore_failure: z.boolean().optional(),
                              to: z.string().min(1),
                              value: z.array(z.unknown()).min(1),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                            z.object({
                              action: z.literal('manual_ingest_pipeline'),
                              customIdentifier: z.string().min(1).optional(),
                              description: z.string().optional(),
                              ignore_failure: z.boolean().optional(),
                              on_failure: z.array(z.object({}).partial().passthrough()).optional(),
                              processors: z.array(
                                z.object({
                                  append: z.unknown(),
                                  attachment: z.unknown(),
                                  bytes: z.unknown(),
                                  circle: z.unknown(),
                                  community_id: z.unknown(),
                                  convert: z.unknown(),
                                  csv: z.unknown(),
                                  date: z.unknown(),
                                  date_index_name: z.unknown(),
                                  dissect: z.unknown(),
                                  dot_expander: z.unknown(),
                                  drop: z.unknown(),
                                  enrich: z.unknown(),
                                  fail: z.unknown(),
                                  fingerprint: z.unknown(),
                                  foreach: z.unknown(),
                                  geo_grid: z.unknown(),
                                  geoip: z.unknown(),
                                  grok: z.unknown(),
                                  gsub: z.unknown(),
                                  html_strip: z.unknown(),
                                  inference: z.unknown(),
                                  ip_location: z.unknown(),
                                  join: z.unknown(),
                                  json: z.unknown(),
                                  kv: z.unknown(),
                                  lowercase: z.unknown(),
                                  network_direction: z.unknown(),
                                  pipeline: z.unknown(),
                                  redact: z.unknown(),
                                  registered_domain: z.unknown(),
                                  remove: z.unknown(),
                                  rename: z.unknown(),
                                  reroute: z.unknown(),
                                  script: z.unknown(),
                                  set: z.unknown(),
                                  set_security_user: z.unknown(),
                                  sort: z.unknown(),
                                  split: z.unknown(),
                                  terminate: z.unknown(),
                                  trim: z.unknown(),
                                  uppercase: z.unknown(),
                                  uri_parts: z.unknown(),
                                  urldecode: z.unknown(),
                                  user_agent: z.unknown(),
                                })
                              ),
                              tag: z.string().optional(),
                              where: z
                                .union([
                                  z.union([
                                    z.object({
                                      contains: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      endsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      field: z.string().min(1),
                                      gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      gte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                      lte: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      neq: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                      range: z
                                        .object({
                                          gt: z.union([z.string(), z.number(), z.boolean()]),
                                          gte: z.union([z.string(), z.number(), z.boolean()]),
                                          lt: z.union([z.string(), z.number(), z.boolean()]),
                                          lte: z.union([z.string(), z.number(), z.boolean()]),
                                        })
                                        .partial()
                                        .optional(),
                                      startsWith: z
                                        .union([z.string(), z.number(), z.boolean()])
                                        .optional(),
                                    }),
                                    z.object({
                                      exists: z.boolean().optional(),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({ and: z.array(z.unknown()) }),
                                  z.object({ or: z.array(z.unknown()) }),
                                  z.object({ not: z.unknown() }),
                                  z.object({ never: z.object({}).partial() }),
                                  z.object({ always: z.object({}).partial() }),
                                ])
                                .optional(),
                            }),
                          ]),
                          z.object({
                            where: z
                              .union([
                                z.union([
                                  z.object({
                                    contains: z
                                      .union([z.string(), z.number(), z.boolean()])
                                      .optional(),
                                    endsWith: z
                                      .union([z.string(), z.number(), z.boolean()])
                                      .optional(),
                                    eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    field: z.string().min(1),
                                    gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                                    range: z
                                      .object({
                                        gt: z.union([z.string(), z.number(), z.boolean()]),
                                        gte: z.union([z.string(), z.number(), z.boolean()]),
                                        lt: z.union([z.string(), z.number(), z.boolean()]),
                                        lte: z.union([z.string(), z.number(), z.boolean()]),
                                      })
                                      .partial()
                                      .optional(),
                                    startsWith: z
                                      .union([z.string(), z.number(), z.boolean()])
                                      .optional(),
                                  }),
                                  z.object({
                                    exists: z.boolean().optional(),
                                    field: z.string().min(1),
                                  }),
                                ]),
                                z.object({ and: z.array(z.unknown()) }),
                                z.object({ or: z.array(z.unknown()) }),
                                z.object({ not: z.unknown() }),
                                z.object({ never: z.object({}).partial() }),
                                z.object({ always: z.object({}).partial() }),
                              ])
                              .and(z.object({ steps: z.array(z.unknown()) }).passthrough()),
                          }),
                        ])
                      ),
                    }),
                  }),
                })
              ),
          })
          .passthrough()
      )
      .and(z.object({}).partial().passthrough())
      .and(z.object({}).partial().passthrough()),
  ]),
  z
    .object({})
    .partial()
    .passthrough()
    .and(
      z
        .object({
          stream: z
            .object({ name: z.unknown() })
            .partial()
            .passthrough()
            .and(z.object({ description: z.string(), name: z.string() })),
        })
        .passthrough()
    )
    .and(
      z
        .object({
          dashboards: z.array(z.string()),
          queries: z.array(
            z
              .object({ id: z.string().min(1), title: z.string().min(1) })
              .passthrough()
              .and(z.object({ kql: z.object({ query: z.string() }) }).passthrough())
          ),
          rules: z.array(z.string()),
        })
        .passthrough()
    )
    .and(
      z
        .object({
          stream: z
            .object({ name: z.unknown() })
            .partial()
            .passthrough()
            .and(
              z.object({
                group: z.object({ members: z.array(z.string()), tags: z.array(z.string()) }),
              })
            ),
        })
        .passthrough()
    )
    .and(z.object({}).partial().passthrough()),
]);
const post_streams_name_fork_Body = z.object({
  status: z.enum(['enabled', 'disabled']).optional(),
  stream: z.object({ name: z.string() }),
  where: z.union([
    z.union([
      z.object({
        contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
        endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
        eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
        field: z.string().min(1),
        gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
        gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
        lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
        lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
        neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
        range: z
          .object({
            gt: z.union([z.string(), z.number(), z.boolean()]),
            gte: z.union([z.string(), z.number(), z.boolean()]),
            lt: z.union([z.string(), z.number(), z.boolean()]),
            lte: z.union([z.string(), z.number(), z.boolean()]),
          })
          .partial()
          .optional(),
        startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
      }),
      z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
    ]),
    z.object({ and: z.array(z.unknown()) }),
    z.object({ or: z.array(z.unknown()) }),
    z.object({ not: z.unknown() }),
    z.object({ never: z.object({}).partial() }),
    z.object({ always: z.object({}).partial() }),
  ]),
});
const put_streams_name_group_Body = z.object({
  group: z.object({ members: z.array(z.string()), tags: z.array(z.string()) }),
});
const put_streams_name_ingest_Body = z.object({
  ingest: z.union([
    z
      .object({
        lifecycle: z.union([
          z.object({ dsl: z.object({ data_retention: z.string().min(1) }).partial() }),
          z.object({ ilm: z.object({ policy: z.string().min(1) }) }),
          z.object({ inherit: z.object({}).partial() }),
        ]),
        processing: z.object({
          steps: z.array(
            z.union([
              z.union([
                z.object({
                  action: z.literal('grok'),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  from: z.string().min(1),
                  ignore_failure: z.boolean().optional(),
                  ignore_missing: z.boolean().optional(),
                  patterns: z.array(z.string().min(1)).min(1),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('dissect'),
                  append_separator: z.string().min(1).optional(),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  from: z.string().min(1),
                  ignore_failure: z.boolean().optional(),
                  ignore_missing: z.boolean().optional(),
                  pattern: z.string().min(1),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('date'),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  formats: z.array(z.string().min(1)),
                  from: z.string().min(1),
                  ignore_failure: z.boolean().optional(),
                  output_format: z.string().min(1).optional(),
                  to: z.string().min(1).optional(),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('rename'),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  from: z.string().min(1),
                  ignore_failure: z.boolean().optional(),
                  ignore_missing: z.boolean().optional(),
                  override: z.boolean().optional(),
                  to: z.string().min(1),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('set'),
                  copy_from: z.string().min(1).optional(),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  ignore_failure: z.boolean().optional(),
                  override: z.boolean().optional(),
                  to: z.string().min(1),
                  value: z.string().min(1).optional(),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('append'),
                  allow_duplicates: z.boolean().optional(),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  ignore_failure: z.boolean().optional(),
                  to: z.string().min(1),
                  value: z.array(z.unknown()).min(1),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('manual_ingest_pipeline'),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  ignore_failure: z.boolean().optional(),
                  on_failure: z.array(z.object({}).partial().passthrough()).optional(),
                  processors: z.array(
                    z.object({
                      append: z.unknown(),
                      attachment: z.unknown(),
                      bytes: z.unknown(),
                      circle: z.unknown(),
                      community_id: z.unknown(),
                      convert: z.unknown(),
                      csv: z.unknown(),
                      date: z.unknown(),
                      date_index_name: z.unknown(),
                      dissect: z.unknown(),
                      dot_expander: z.unknown(),
                      drop: z.unknown(),
                      enrich: z.unknown(),
                      fail: z.unknown(),
                      fingerprint: z.unknown(),
                      foreach: z.unknown(),
                      geo_grid: z.unknown(),
                      geoip: z.unknown(),
                      grok: z.unknown(),
                      gsub: z.unknown(),
                      html_strip: z.unknown(),
                      inference: z.unknown(),
                      ip_location: z.unknown(),
                      join: z.unknown(),
                      json: z.unknown(),
                      kv: z.unknown(),
                      lowercase: z.unknown(),
                      network_direction: z.unknown(),
                      pipeline: z.unknown(),
                      redact: z.unknown(),
                      registered_domain: z.unknown(),
                      remove: z.unknown(),
                      rename: z.unknown(),
                      reroute: z.unknown(),
                      script: z.unknown(),
                      set: z.unknown(),
                      set_security_user: z.unknown(),
                      sort: z.unknown(),
                      split: z.unknown(),
                      terminate: z.unknown(),
                      trim: z.unknown(),
                      uppercase: z.unknown(),
                      uri_parts: z.unknown(),
                      urldecode: z.unknown(),
                      user_agent: z.unknown(),
                    })
                  ),
                  tag: z.string().optional(),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
              ]),
              z.object({
                where: z
                  .union([
                    z.union([
                      z.object({
                        contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        field: z.string().min(1),
                        gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        range: z
                          .object({
                            gt: z.union([z.string(), z.number(), z.boolean()]),
                            gte: z.union([z.string(), z.number(), z.boolean()]),
                            lt: z.union([z.string(), z.number(), z.boolean()]),
                            lte: z.union([z.string(), z.number(), z.boolean()]),
                          })
                          .partial()
                          .optional(),
                        startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                      }),
                      z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                    ]),
                    z.object({ and: z.array(z.unknown()) }),
                    z.object({ or: z.array(z.unknown()) }),
                    z.object({ not: z.unknown() }),
                    z.object({ never: z.object({}).partial() }),
                    z.object({ always: z.object({}).partial() }),
                  ])
                  .and(z.object({ steps: z.array(z.unknown()) }).passthrough()),
              }),
            ])
          ),
        }),
      })
      .passthrough()
      .and(
        z
          .object({
            wired: z.object({
              fields: z.record(
                z
                  .record(
                    z.union([
                      z.union([z.string(), z.number(), z.boolean(), z.unknown(), z.unknown()]),
                      z.array(
                        z.union([z.string(), z.number(), z.boolean(), z.unknown(), z.unknown()])
                      ),
                      z.unknown(),
                    ])
                  )
                  .and(
                    z.union([
                      z.object({
                        format: z.string().min(1).optional(),
                        type: z.enum([
                          'keyword',
                          'match_only_text',
                          'long',
                          'double',
                          'date',
                          'boolean',
                          'ip',
                        ]),
                      }),
                      z.object({ type: z.literal('system') }),
                    ])
                  )
              ),
              routing: z.array(
                z.object({
                  destination: z.string().min(1),
                  status: z.enum(['enabled', 'disabled']).optional(),
                  where: z.union([
                    z.union([
                      z.object({
                        contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        field: z.string().min(1),
                        gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        range: z
                          .object({
                            gt: z.union([z.string(), z.number(), z.boolean()]),
                            gte: z.union([z.string(), z.number(), z.boolean()]),
                            lt: z.union([z.string(), z.number(), z.boolean()]),
                            lte: z.union([z.string(), z.number(), z.boolean()]),
                          })
                          .partial()
                          .optional(),
                        startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                      }),
                      z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                    ]),
                    z.object({ and: z.array(z.unknown()) }),
                    z.object({ or: z.array(z.unknown()) }),
                    z.object({ not: z.unknown() }),
                    z.object({ never: z.object({}).partial() }),
                    z.object({ always: z.object({}).partial() }),
                  ]),
                })
              ),
            }),
          })
          .passthrough()
      ),
    z
      .object({
        lifecycle: z.union([
          z.object({ dsl: z.object({ data_retention: z.string().min(1) }).partial() }),
          z.object({ ilm: z.object({ policy: z.string().min(1) }) }),
          z.object({ inherit: z.object({}).partial() }),
        ]),
        processing: z.object({
          steps: z.array(
            z.union([
              z.union([
                z.object({
                  action: z.literal('grok'),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  from: z.string().min(1),
                  ignore_failure: z.boolean().optional(),
                  ignore_missing: z.boolean().optional(),
                  patterns: z.array(z.string().min(1)).min(1),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('dissect'),
                  append_separator: z.string().min(1).optional(),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  from: z.string().min(1),
                  ignore_failure: z.boolean().optional(),
                  ignore_missing: z.boolean().optional(),
                  pattern: z.string().min(1),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('date'),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  formats: z.array(z.string().min(1)),
                  from: z.string().min(1),
                  ignore_failure: z.boolean().optional(),
                  output_format: z.string().min(1).optional(),
                  to: z.string().min(1).optional(),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('rename'),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  from: z.string().min(1),
                  ignore_failure: z.boolean().optional(),
                  ignore_missing: z.boolean().optional(),
                  override: z.boolean().optional(),
                  to: z.string().min(1),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('set'),
                  copy_from: z.string().min(1).optional(),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  ignore_failure: z.boolean().optional(),
                  override: z.boolean().optional(),
                  to: z.string().min(1),
                  value: z.string().min(1).optional(),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('append'),
                  allow_duplicates: z.boolean().optional(),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  ignore_failure: z.boolean().optional(),
                  to: z.string().min(1),
                  value: z.array(z.unknown()).min(1),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
                z.object({
                  action: z.literal('manual_ingest_pipeline'),
                  customIdentifier: z.string().min(1).optional(),
                  description: z.string().optional(),
                  ignore_failure: z.boolean().optional(),
                  on_failure: z.array(z.object({}).partial().passthrough()).optional(),
                  processors: z.array(
                    z.object({
                      append: z.unknown(),
                      attachment: z.unknown(),
                      bytes: z.unknown(),
                      circle: z.unknown(),
                      community_id: z.unknown(),
                      convert: z.unknown(),
                      csv: z.unknown(),
                      date: z.unknown(),
                      date_index_name: z.unknown(),
                      dissect: z.unknown(),
                      dot_expander: z.unknown(),
                      drop: z.unknown(),
                      enrich: z.unknown(),
                      fail: z.unknown(),
                      fingerprint: z.unknown(),
                      foreach: z.unknown(),
                      geo_grid: z.unknown(),
                      geoip: z.unknown(),
                      grok: z.unknown(),
                      gsub: z.unknown(),
                      html_strip: z.unknown(),
                      inference: z.unknown(),
                      ip_location: z.unknown(),
                      join: z.unknown(),
                      json: z.unknown(),
                      kv: z.unknown(),
                      lowercase: z.unknown(),
                      network_direction: z.unknown(),
                      pipeline: z.unknown(),
                      redact: z.unknown(),
                      registered_domain: z.unknown(),
                      remove: z.unknown(),
                      rename: z.unknown(),
                      reroute: z.unknown(),
                      script: z.unknown(),
                      set: z.unknown(),
                      set_security_user: z.unknown(),
                      sort: z.unknown(),
                      split: z.unknown(),
                      terminate: z.unknown(),
                      trim: z.unknown(),
                      uppercase: z.unknown(),
                      uri_parts: z.unknown(),
                      urldecode: z.unknown(),
                      user_agent: z.unknown(),
                    })
                  ),
                  tag: z.string().optional(),
                  where: z
                    .union([
                      z.union([
                        z.object({
                          contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          field: z.string().min(1),
                          gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                          range: z
                            .object({
                              gt: z.union([z.string(), z.number(), z.boolean()]),
                              gte: z.union([z.string(), z.number(), z.boolean()]),
                              lt: z.union([z.string(), z.number(), z.boolean()]),
                              lte: z.union([z.string(), z.number(), z.boolean()]),
                            })
                            .partial()
                            .optional(),
                          startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        }),
                        z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                      ]),
                      z.object({ and: z.array(z.unknown()) }),
                      z.object({ or: z.array(z.unknown()) }),
                      z.object({ not: z.unknown() }),
                      z.object({ never: z.object({}).partial() }),
                      z.object({ always: z.object({}).partial() }),
                    ])
                    .optional(),
                }),
              ]),
              z.object({
                where: z
                  .union([
                    z.union([
                      z.object({
                        contains: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        endsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        eq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        field: z.string().min(1),
                        gt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        gte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        lt: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        lte: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        neq: z.union([z.string(), z.number(), z.boolean()]).optional(),
                        range: z
                          .object({
                            gt: z.union([z.string(), z.number(), z.boolean()]),
                            gte: z.union([z.string(), z.number(), z.boolean()]),
                            lt: z.union([z.string(), z.number(), z.boolean()]),
                            lte: z.union([z.string(), z.number(), z.boolean()]),
                          })
                          .partial()
                          .optional(),
                        startsWith: z.union([z.string(), z.number(), z.boolean()]).optional(),
                      }),
                      z.object({ exists: z.boolean().optional(), field: z.string().min(1) }),
                    ]),
                    z.object({ and: z.array(z.unknown()) }),
                    z.object({ or: z.array(z.unknown()) }),
                    z.object({ not: z.unknown() }),
                    z.object({ never: z.object({}).partial() }),
                    z.object({ always: z.object({}).partial() }),
                  ])
                  .and(z.object({ steps: z.array(z.unknown()) }).passthrough()),
              }),
            ])
          ),
        }),
      })
      .passthrough()
      .and(
        z
          .object({
            classic: z
              .object({
                field_overrides: z.record(
                  z
                    .record(
                      z.union([
                        z.union([z.string(), z.number(), z.boolean(), z.unknown(), z.unknown()]),
                        z.array(
                          z.union([z.string(), z.number(), z.boolean(), z.unknown(), z.unknown()])
                        ),
                        z.unknown(),
                      ])
                    )
                    .and(
                      z.union([
                        z.object({
                          format: z.string().min(1).optional(),
                          type: z.enum([
                            'keyword',
                            'match_only_text',
                            'long',
                            'double',
                            'date',
                            'boolean',
                            'ip',
                          ]),
                        }),
                        z.object({ type: z.literal('system') }),
                      ])
                    )
                ),
              })
              .partial(),
          })
          .passthrough()
      ),
  ]),
});
const post_streams_name_content_export_Body = z.object({
  description: z.string(),
  include: z.union([
    z.object({ objects: z.object({ all: z.object({}).partial() }) }),
    z.object({
      objects: z.object({
        queries: z.array(z.object({ id: z.string() })),
        routing: z.array(z.unknown().and(z.object({ destination: z.string() }).passthrough())),
      }),
    }),
  ]),
  name: z.string(),
  version: z.string(),
});
const post_streams_name_dashboards_bulk_Body = z.object({
  operations: z.array(
    z.union([
      z.object({ index: z.object({ id: z.string() }) }),
      z.object({ delete: z.object({ id: z.string() }) }),
    ])
  ),
});
const post_streams_name_queries_bulk_Body = z.object({
  operations: z.array(
    z.union([
      z.object({
        index: z
          .object({ id: z.string().min(1), title: z.string().min(1) })
          .passthrough()
          .and(z.object({ kql: z.object({ query: z.string() }) }).passthrough()),
      }),
      z.object({ delete: z.object({ id: z.string() }) }),
    ])
  ),
});
const put_streams_name_queries_queryid_Body = z.object({
  kql: z.object({ query: z.string() }),
  title: z.string().min(1),
});
const post_streams_name_significant_events_preview_Body = z.object({
  query: z.object({ kql: z.object({ query: z.string() }) }),
});
const locations = z.union([z.string(), z.array(z.any())]).optional();
const monitorTypes = z
  .union([z.enum(['browser', 'http', 'icmp', 'tcp']), z.array(z.any())])
  .optional();
const schedules = z.union([z.array(z.any()), z.string()]).optional();
const useLogicalAndFor = z
  .union([z.enum(['tags', 'locations']), z.array(z.enum(['tags', 'locations']))])
  .optional();
const Synthetics_commonMonitorFields = z
  .object({
    alert: z.object({}).partial().passthrough().optional(),
    enabled: z.boolean().optional().default(true),
    labels: z.record(z.string()).optional(),
    locations: z.array(z.string()).optional(),
    name: z.string(),
    namespace: z.string().optional().default('default'),
    params: z.string().optional(),
    private_locations: z.array(z.string()).optional(),
    retest_on_failure: z.boolean().optional().default(true),
    schedule: z.number().optional(),
    'service.name': z.string().optional(),
    tags: z.array(z.string()).optional(),
    timeout: z.number().optional().default(16),
  })
  .passthrough();
const Synthetics_browserMonitorFields = Synthetics_commonMonitorFields.and(
  z
    .object({
      ignore_https_errors: z.boolean().optional().default(false),
      inline_script: z.string(),
      playwright_options: z.object({}).partial().passthrough().optional(),
      screenshots: z.enum(['on', 'off', 'only-on-failure']).optional().default('on'),
      synthetics_args: z.array(z.any()).optional(),
      type: z.literal('browser'),
    })
    .passthrough()
);
const Synthetics_httpMonitorFields = Synthetics_commonMonitorFields.and(
  z
    .object({
      check: z
        .object({
          request: z
            .object({
              body: z.string(),
              headers: z.object({}).partial().passthrough(),
              method: z.enum(['HEAD', 'GET', 'POST', 'OPTIONS']),
            })
            .partial()
            .passthrough(),
          response: z
            .object({
              body: z.object({}).partial().passthrough(),
              headers: z.object({}).partial().passthrough(),
            })
            .partial()
            .passthrough(),
        })
        .partial()
        .passthrough()
        .optional(),
      ipv4: z.boolean().optional().default(true),
      ipv6: z.boolean().optional().default(true),
      max_redirects: z.number().optional().default(0),
      mode: z.enum(['all', 'any']).optional().default('any'),
      password: z.string().optional(),
      proxy_headers: z.object({}).partial().passthrough().optional(),
      proxy_url: z.string().optional(),
      response: z.object({}).partial().passthrough().optional(),
      ssl: z.object({}).partial().passthrough().optional(),
      type: z.literal('http'),
      url: z.string(),
      username: z.string().optional(),
    })
    .passthrough()
);
const Synthetics_icmpMonitorFields = Synthetics_commonMonitorFields.and(
  z
    .object({ host: z.string(), type: z.literal('icmp'), wait: z.number().optional().default(1) })
    .passthrough()
);
const Synthetics_tcpMonitorFields = Synthetics_commonMonitorFields.and(
  z
    .object({
      host: z.string(),
      proxy_url: z.string().optional(),
      proxy_use_local_resolver: z.boolean().optional().default(false),
      ssl: z.object({}).partial().passthrough().optional(),
      type: z.literal('tcp'),
    })
    .passthrough()
);
const post_synthetic_monitors_Body = z.discriminatedUnion('type', [
  Synthetics_browserMonitorFields,
  Synthetics_httpMonitorFields,
  Synthetics_icmpMonitorFields,
  Synthetics_tcpMonitorFields,
]);
const delete_synthetic_monitors_Body = z.object({ ids: z.array(z.string()) }).passthrough();
const Synthetics_getParameterResponse = z
  .object({
    description: z.string(),
    id: z.string(),
    key: z.string(),
    namespaces: z.array(z.string()),
    tags: z.array(z.string()),
    value: z.string(),
  })
  .partial()
  .passthrough();
const Synthetics_parameterRequest = z
  .object({
    description: z.string().optional(),
    key: z.string(),
    share_across_spaces: z.boolean().optional(),
    tags: z.array(z.string()).optional(),
    value: z.string(),
  })
  .passthrough();
const post_parameters_Body = z.union([
  z.array(Synthetics_parameterRequest),
  Synthetics_parameterRequest,
]);
const Synthetics_postParameterResponse = z
  .object({
    description: z.string(),
    id: z.string(),
    key: z.string(),
    share_across_spaces: z.boolean(),
    tags: z.array(z.string()),
    value: z.string(),
  })
  .partial()
  .passthrough();
const put_parameter_Body = z
  .object({
    description: z.string(),
    key: z.string(),
    tags: z.array(z.string()),
    value: z.string(),
  })
  .partial()
  .passthrough();
const Synthetics_getPrivateLocation = z
  .object({
    agentPolicyId: z.string(),
    geo: z.object({ lat: z.number(), lon: z.number() }).passthrough(),
    id: z.string(),
    isInvalid: z.boolean(),
    label: z.string(),
    namespace: z.string(),
  })
  .partial()
  .passthrough();
const post_private_location_Body = z
  .object({
    agentPolicyId: z.string(),
    geo: z.object({ lat: z.number(), lon: z.number() }).passthrough().optional(),
    label: z.string(),
    spaces: z.array(z.string()).optional(),
    tags: z.array(z.string()).optional(),
  })
  .passthrough();
const Task_manager_health_APIs_configuration = z.object({}).partial().passthrough();
const Task_manager_health_APIs_workload = z.object({}).partial().passthrough();
const Task_manager_health_APIs_health_response = z
  .object({
    id: z.string(),
    last_update: z.string(),
    stats: z
      .object({
        capacity_estimation: z.object({}).partial().passthrough(),
        configuration: Task_manager_health_APIs_configuration,
        runtime: z.object({}).partial().passthrough(),
        workload: Task_manager_health_APIs_workload,
      })
      .partial()
      .passthrough(),
    status: z.string(),
    timestamp: z.string(),
  })
  .partial()
  .passthrough();
const DeleteTimelines_Body = z
  .object({ savedObjectIds: z.array(z.string()), searchIds: z.array(z.string()).optional() })
  .passthrough();
const Security_Timeline_API_ColumnHeaderResult = z
  .object({
    aggregatable: z.boolean().nullable(),
    category: z.string().nullable(),
    columnHeaderType: z.string().nullable(),
    description: z.string().nullable(),
    example: z.string().nullable(),
    id: z.string().nullable(),
    indexes: z.array(z.string()).nullable(),
    name: z.string().nullable(),
    placeholder: z.string().nullable(),
    searchable: z.boolean().nullable(),
    type: z.string().nullable(),
  })
  .partial()
  .passthrough();
const Security_Timeline_API_QueryMatchResult = z
  .object({
    displayField: z.string().nullable(),
    displayValue: z.string().nullable(),
    field: z.string().nullable(),
    operator: z.string().nullable(),
    value: z.union([z.string(), z.array(z.string())]),
  })
  .partial()
  .passthrough();
const Security_Timeline_API_DataProviderType = z.enum(['default', 'template']);
const Security_Timeline_API_DataProviderQueryMatch = z
  .object({
    enabled: z.boolean().nullable(),
    excluded: z.boolean().nullable(),
    id: z.string().nullable(),
    kqlQuery: z.string().nullable(),
    name: z.string().nullable(),
    queryMatch: Security_Timeline_API_QueryMatchResult,
    type: Security_Timeline_API_DataProviderType,
  })
  .partial()
  .passthrough();
const Security_Timeline_API_DataProviderResult = z
  .object({
    and: z.array(Security_Timeline_API_DataProviderQueryMatch).nullable(),
    enabled: z.boolean().nullable(),
    excluded: z.boolean().nullable(),
    id: z.string().nullable(),
    kqlQuery: z.string().nullable(),
    name: z.string().nullable(),
    queryMatch: Security_Timeline_API_QueryMatchResult,
    type: Security_Timeline_API_DataProviderType,
  })
  .partial()
  .passthrough();
const Security_Timeline_API_RowRendererId = z.enum([
  'alert',
  'alerts',
  'auditd',
  'auditd_file',
  'library',
  'netflow',
  'plain',
  'registry',
  'suricata',
  'system',
  'system_dns',
  'system_endgame_process',
  'system_file',
  'system_fim',
  'system_security_event',
  'system_socket',
  'threat_match',
  'zeek',
]);
const Security_Timeline_API_FavoriteTimelineResult = z
  .object({
    favoriteDate: z.number().nullable(),
    fullName: z.string().nullable(),
    userName: z.string().nullable(),
  })
  .partial()
  .passthrough();
const Security_Timeline_API_FilterTimelineResult = z
  .object({
    exists: z.string().nullable(),
    match_all: z.string().nullable(),
    meta: z
      .object({
        alias: z.string().nullable(),
        controlledBy: z.string().nullable(),
        disabled: z.boolean().nullable(),
        field: z.string().nullable(),
        formattedValue: z.string().nullable(),
        index: z.string().nullable(),
        key: z.string().nullable(),
        negate: z.boolean().nullable(),
        params: z.string().nullable(),
        type: z.string().nullable(),
        value: z.string().nullable(),
      })
      .partial()
      .passthrough()
      .nullable(),
    missing: z.string().nullable(),
    query: z.string().nullable(),
    range: z.string().nullable(),
    script: z.string().nullable(),
  })
  .partial()
  .passthrough();
const Security_Timeline_API_SerializedFilterQueryResult = z
  .object({
    filterQuery: z
      .object({
        kuery: z
          .object({ expression: z.string().nullable(), kind: z.string().nullable() })
          .partial()
          .passthrough()
          .nullable(),
        serializedQuery: z.string().nullable(),
      })
      .partial()
      .passthrough()
      .nullable(),
  })
  .partial()
  .passthrough();
const Security_Timeline_API_SortObject = z
  .object({
    columnId: z.string().nullable(),
    columnType: z.string().nullable(),
    sortDirection: z.string().nullable(),
  })
  .partial()
  .passthrough();
const Security_Timeline_API_Sort = z.union([
  Security_Timeline_API_SortObject,
  z.array(Security_Timeline_API_SortObject),
]);
const Security_Timeline_API_TimelineStatus = z.enum(['active', 'draft', 'immutable']);
const Security_Timeline_API_TimelineType = z.enum(['default', 'template']);
const Security_Timeline_API_SavedTimeline = z
  .object({
    columns: z.array(Security_Timeline_API_ColumnHeaderResult).nullable(),
    created: z.number().nullable(),
    createdBy: z.string().nullable(),
    dataProviders: z.array(Security_Timeline_API_DataProviderResult).nullable(),
    dataViewId: z.string().nullable(),
    dateRange: z
      .object({ end: z.union([z.string(), z.number()]), start: z.union([z.string(), z.number()]) })
      .partial()
      .passthrough()
      .nullable(),
    description: z.string().nullable(),
    eqlOptions: z
      .object({
        eventCategoryField: z.string().nullable(),
        query: z.string().nullable(),
        size: z.union([z.string(), z.number()]),
        tiebreakerField: z.string().nullable(),
        timestampField: z.string().nullable(),
      })
      .partial()
      .passthrough()
      .nullable(),
    eventType: z.string().nullable(),
    excludedRowRendererIds: z.array(Security_Timeline_API_RowRendererId).nullable(),
    favorite: z.array(Security_Timeline_API_FavoriteTimelineResult).nullable(),
    filters: z.array(Security_Timeline_API_FilterTimelineResult).nullable(),
    indexNames: z.array(z.string()).nullable(),
    kqlMode: z.string().nullable(),
    kqlQuery: Security_Timeline_API_SerializedFilterQueryResult,
    savedQueryId: z.string().nullable(),
    savedSearchId: z.string().nullable(),
    sort: Security_Timeline_API_Sort,
    status: Security_Timeline_API_TimelineStatus,
    templateTimelineId: z.string().nullable(),
    templateTimelineVersion: z.number().nullable(),
    timelineType: Security_Timeline_API_TimelineType,
    title: z.string().nullable(),
    updated: z.number().nullable(),
    updatedBy: z.string().nullable(),
  })
  .partial()
  .passthrough();
const Security_Timeline_API_SavedTimelineWithSavedObjectId =
  Security_Timeline_API_SavedTimeline.and(
    z.object({ savedObjectId: z.string(), version: z.string() }).passthrough()
  );
const Security_Timeline_API_TimelineResponse = Security_Timeline_API_SavedTimeline.and(
  Security_Timeline_API_SavedTimelineWithSavedObjectId
).and(
  z
    .object({
      eventIdToNoteIds: z.array(Security_Timeline_API_Note).nullable(),
      noteIds: z.array(z.string()).nullable(),
      notes: z.array(Security_Timeline_API_Note).nullable(),
      pinnedEventIds: z.array(z.string()).nullable(),
      pinnedEventsSaveObject: z.array(Security_Timeline_API_PinnedEvent).nullable(),
    })
    .partial()
    .passthrough()
);
const PatchTimeline_Body = z
  .object({
    timeline: Security_Timeline_API_SavedTimeline,
    timelineId: z.string().nullable(),
    version: z.string().nullable(),
  })
  .passthrough();
const CreateTimelines_Body = z
  .object({
    status: Security_Timeline_API_TimelineStatus.optional(),
    templateTimelineId: z.string().nullish(),
    templateTimelineVersion: z.number().nullish(),
    timeline: Security_Timeline_API_SavedTimeline,
    timelineId: z.string().nullish(),
    timelineType: Security_Timeline_API_TimelineType.optional(),
    version: z.string().nullish(),
  })
  .passthrough();
const CopyTimeline_Body = z
  .object({ timeline: Security_Timeline_API_SavedTimeline, timelineIdToCopy: z.string() })
  .passthrough();
const CleanDraftTimelines_Body = z
  .object({ timelineType: Security_Timeline_API_TimelineType })
  .passthrough();
const ExportTimelines_Body = z
  .object({ ids: z.array(z.string()).nullable() })
  .partial()
  .passthrough();
const PersistFavoriteRoute_Body = z
  .object({
    templateTimelineId: z.string().nullable(),
    templateTimelineVersion: z.number().nullable(),
    timelineId: z.string().nullable(),
    timelineType: Security_Timeline_API_TimelineType,
  })
  .passthrough();
const Security_Timeline_API_FavoriteTimelineResponse = z
  .object({
    favorite: z.array(Security_Timeline_API_FavoriteTimelineResult).optional(),
    savedObjectId: z.string(),
    templateTimelineId: z.string().nullish(),
    templateTimelineVersion: z.number().nullish(),
    timelineType: Security_Timeline_API_TimelineType.optional(),
    version: z.string(),
  })
  .passthrough();
const ImportTimelines_Body = z
  .object({ file: z.unknown(), isImmutable: z.enum(['true', 'false']).optional() })
  .passthrough();
const Security_Timeline_API_ImportTimelineResult = z
  .object({
    errors: z.array(
      z
        .object({
          error: z.object({ message: z.string(), status_code: z.number() }).partial().passthrough(),
          id: z.string(),
        })
        .partial()
        .passthrough()
    ),
    success: z.boolean(),
    success_count: z.number(),
    timelines_installed: z.number(),
    timelines_updated: z.number(),
  })
  .partial()
  .passthrough();
const Security_Timeline_API_TimelineSavedToReturnObject = Security_Timeline_API_SavedTimeline.and(
  z
    .object({
      eventIdToNoteIds: z.array(Security_Timeline_API_Note).nullish(),
      noteIds: z.array(z.string()).nullish(),
      notes: z.array(Security_Timeline_API_Note).nullish(),
      pinnedEventIds: z.array(z.string()).nullish(),
      pinnedEventsSaveObject: z.array(Security_Timeline_API_PinnedEvent).nullish(),
      savedObjectId: z.string(),
      version: z.string(),
    })
    .passthrough()
);
const Security_Timeline_API_ImportTimelines = Security_Timeline_API_SavedTimeline.and(
  z
    .object({
      eventNotes: z.array(Security_Timeline_API_BareNote).nullable(),
      globalNotes: z.array(Security_Timeline_API_BareNote).nullable(),
      pinnedEventIds: z.array(z.string()).nullable(),
      savedObjectId: z.string().nullable(),
      version: z.string().nullable(),
    })
    .passthrough()
);
const InstallPrepackedTimelines_Body = z
  .object({
    prepackagedTimelines: z.array(Security_Timeline_API_TimelineSavedToReturnObject.nullable()),
    timelinesToInstall: z.array(Security_Timeline_API_ImportTimelines.nullable()),
    timelinesToUpdate: z.array(Security_Timeline_API_ImportTimelines.nullable()),
  })
  .passthrough();
const Security_Timeline_API_SavedObjectResolveAliasPurpose = z.enum([
  'savedObjectConversion',
  'savedObjectImport',
]);
const Security_Timeline_API_SavedObjectResolveOutcome = z.enum([
  'exactMatch',
  'aliasMatch',
  'conflict',
]);
const Security_Timeline_API_ResolvedTimeline = z
  .object({
    alias_purpose: Security_Timeline_API_SavedObjectResolveAliasPurpose.optional(),
    alias_target_id: z.string().optional(),
    outcome: Security_Timeline_API_SavedObjectResolveOutcome,
    timeline: Security_Timeline_API_TimelineSavedToReturnObject,
  })
  .passthrough();
const put_uptime_settings_Body = z
  .object({
    certAgeThreshold: z.number().default(730),
    certExpirationThreshold: z.number().default(30),
    defaultConnectors: z.array(z.any()).default([]),
    defaultEmail: z
      .object({
        bcc: z.array(z.string()).default([]),
        cc: z.array(z.string()).default([]),
        to: z.array(z.string()).default([]),
      })
      .partial()
      .passthrough(),
    heartbeatIndices: z.string().default('heartbeat-*'),
  })
  .partial()
  .passthrough();
const SLOs_budgeting_method = z.enum(['occurrences', 'timeslices']);
const SLOs_group_by = z.union([z.string(), z.array(z.string())]);
const SLOs_filter_meta = z
  .object({
    alias: z.string().nullable(),
    controlledBy: z.string(),
    disabled: z.boolean(),
    field: z.string(),
    group: z.string(),
    index: z.string(),
    isMultiIndex: z.boolean(),
    key: z.string(),
    negate: z.boolean(),
    params: z.object({}).partial().passthrough(),
    type: z.string(),
    value: z.string(),
  })
  .partial()
  .passthrough();
const SLOs_filter = z
  .object({ meta: SLOs_filter_meta, query: z.object({}).partial().passthrough() })
  .partial()
  .passthrough();
const SLOs_kql_with_filters = z.union([
  z.string(),
  z
    .object({ filters: z.array(SLOs_filter), kqlQuery: z.string() })
    .partial()
    .passthrough(),
]);
const SLOs_kql_with_filters_good = z.union([
  z.string(),
  z
    .object({ filters: z.array(SLOs_filter), kqlQuery: z.string() })
    .partial()
    .passthrough(),
]);
const SLOs_kql_with_filters_total = z.union([
  z.string(),
  z
    .object({ filters: z.array(SLOs_filter), kqlQuery: z.string() })
    .partial()
    .passthrough(),
]);
const SLOs_indicator_properties_custom_kql = z
  .object({
    params: z
      .object({
        dataViewId: z.string().optional(),
        filter: SLOs_kql_with_filters.optional(),
        good: SLOs_kql_with_filters_good,
        index: z.string(),
        timestampField: z.string(),
        total: SLOs_kql_with_filters_total,
      })
      .passthrough(),
    type: z.string(),
  })
  .passthrough();
const SLOs_indicator_properties_apm_availability = z
  .object({
    params: z
      .object({
        environment: z.string(),
        filter: z.string().optional(),
        index: z.string(),
        service: z.string(),
        transactionName: z.string(),
        transactionType: z.string(),
      })
      .passthrough(),
    type: z.string(),
  })
  .passthrough();
const SLOs_indicator_properties_apm_latency = z
  .object({
    params: z
      .object({
        environment: z.string(),
        filter: z.string().optional(),
        index: z.string(),
        service: z.string(),
        threshold: z.number(),
        transactionName: z.string(),
        transactionType: z.string(),
      })
      .passthrough(),
    type: z.string(),
  })
  .passthrough();
const SLOs_indicator_properties_custom_metric = z
  .object({
    params: z
      .object({
        dataViewId: z.string().optional(),
        filter: z.string().optional(),
        good: z
          .object({
            equation: z.string(),
            metrics: z.array(
              z.union([
                z
                  .object({
                    aggregation: z.literal('sum'),
                    field: z.string(),
                    filter: z.string().optional(),
                    name: z.string().regex(/^[A-Z]$/),
                  })
                  .passthrough(),
                z
                  .object({
                    aggregation: z.literal('doc_count'),
                    filter: z.string().optional(),
                    name: z.string().regex(/^[A-Z]$/),
                  })
                  .passthrough(),
              ])
            ),
          })
          .passthrough(),
        index: z.string(),
        timestampField: z.string(),
        total: z
          .object({
            equation: z.string(),
            metrics: z.array(
              z.union([
                z
                  .object({
                    aggregation: z.literal('sum'),
                    field: z.string(),
                    filter: z.string().optional(),
                    name: z.string().regex(/^[A-Z]$/),
                  })
                  .passthrough(),
                z
                  .object({
                    aggregation: z.literal('doc_count'),
                    filter: z.string().optional(),
                    name: z.string().regex(/^[A-Z]$/),
                  })
                  .passthrough(),
              ])
            ),
          })
          .passthrough(),
      })
      .passthrough(),
    type: z.string(),
  })
  .passthrough();
const SLOs_indicator_properties_histogram = z
  .object({
    params: z
      .object({
        dataViewId: z.string().optional(),
        filter: z.string().optional(),
        good: z
          .object({
            aggregation: z.enum(['value_count', 'range']),
            field: z.string(),
            filter: z.string().optional(),
            from: z.number().optional(),
            to: z.number().optional(),
          })
          .passthrough(),
        index: z.string(),
        timestampField: z.string(),
        total: z
          .object({
            aggregation: z.enum(['value_count', 'range']),
            field: z.string(),
            filter: z.string().optional(),
            from: z.number().optional(),
            to: z.number().optional(),
          })
          .passthrough(),
      })
      .passthrough(),
    type: z.string(),
  })
  .passthrough();
const SLOs_timeslice_metric_basic_metric_with_field = z
  .object({
    aggregation: z.enum(['sum', 'avg', 'min', 'max', 'std_deviation', 'last_value', 'cardinality']),
    field: z.string(),
    filter: z.string().optional(),
    name: z.string().regex(/^[A-Z]$/),
  })
  .passthrough();
const SLOs_timeslice_metric_percentile_metric = z
  .object({
    aggregation: z.literal('percentile'),
    field: z.string(),
    filter: z.string().optional(),
    name: z.string().regex(/^[A-Z]$/),
    percentile: z.number(),
  })
  .passthrough();
const SLOs_timeslice_metric_doc_count_metric = z
  .object({
    aggregation: z.literal('doc_count'),
    filter: z.string().optional(),
    name: z.string().regex(/^[A-Z]$/),
  })
  .passthrough();
const SLOs_indicator_properties_timeslice_metric = z
  .object({
    params: z
      .object({
        dataViewId: z.string().optional(),
        filter: z.string().optional(),
        index: z.string(),
        metric: z
          .object({
            comparator: z.enum(['GT', 'GTE', 'LT', 'LTE']),
            equation: z.string(),
            metrics: z.array(
              z.union([
                SLOs_timeslice_metric_basic_metric_with_field,
                SLOs_timeslice_metric_percentile_metric,
                SLOs_timeslice_metric_doc_count_metric,
              ])
            ),
            threshold: z.number(),
          })
          .passthrough(),
        timestampField: z.string(),
      })
      .passthrough(),
    type: z.string(),
  })
  .passthrough();
const SLOs_objective = z
  .object({
    target: z.number().gt(0).lt(100),
    timesliceTarget: z.number().gte(0).lte(100).optional(),
    timesliceWindow: z.string().optional(),
  })
  .passthrough();
const SLOs_settings = z
  .object({
    frequency: z.string().default('1m'),
    preventInitialBackfill: z.boolean().default(false),
    syncDelay: z.string().default('1m'),
    syncField: z.string(),
  })
  .partial()
  .passthrough();
const SLOs_error_budget = z
  .object({
    consumed: z.number(),
    initial: z.number(),
    isEstimated: z.boolean(),
    remaining: z.number(),
  })
  .passthrough();
const SLOs_summary_status = z.enum(['NO_DATA', 'HEALTHY', 'DEGRADING', 'VIOLATED']);
const SLOs_summary = z
  .object({ errorBudget: SLOs_error_budget, sliValue: z.number(), status: SLOs_summary_status })
  .passthrough();
const SLOs_time_window = z
  .object({ duration: z.string(), type: z.enum(['rolling', 'calendarAligned']) })
  .passthrough();
const SLOs_slo_with_summary_response = z
  .object({
    budgetingMethod: SLOs_budgeting_method,
    createdAt: z.string(),
    description: z.string(),
    enabled: z.boolean(),
    groupBy: SLOs_group_by,
    id: z.string(),
    indicator: z.discriminatedUnion('type', [
      SLOs_indicator_properties_custom_kql,
      SLOs_indicator_properties_apm_availability,
      SLOs_indicator_properties_apm_latency,
      SLOs_indicator_properties_custom_metric,
      SLOs_indicator_properties_histogram,
      SLOs_indicator_properties_timeslice_metric,
    ]),
    instanceId: z.string(),
    name: z.string(),
    objective: SLOs_objective,
    revision: z.number(),
    settings: SLOs_settings,
    summary: SLOs_summary,
    tags: z.array(z.string()),
    timeWindow: SLOs_time_window,
    updatedAt: z.string(),
    version: z.number(),
  })
  .passthrough();
const SLOs_find_slo_response = z
  .object({
    page: z.number(),
    perPage: z.number(),
    results: z.array(SLOs_slo_with_summary_response),
    searchAfter: z.string(),
    size: z.number(),
    total: z.number(),
  })
  .partial()
  .passthrough();
const SLOs_400_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .passthrough();
const SLOs_401_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .passthrough();
const SLOs_403_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .passthrough();
const SLOs_404_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .passthrough();
const SLOs_create_slo_request = z
  .object({
    budgetingMethod: SLOs_budgeting_method,
    description: z.string(),
    groupBy: SLOs_group_by.optional(),
    id: z.string().optional(),
    indicator: z.union([
      SLOs_indicator_properties_custom_kql,
      SLOs_indicator_properties_apm_availability,
      SLOs_indicator_properties_apm_latency,
      SLOs_indicator_properties_custom_metric,
      SLOs_indicator_properties_histogram,
      SLOs_indicator_properties_timeslice_metric,
    ]),
    name: z.string(),
    objective: SLOs_objective,
    settings: SLOs_settings.optional(),
    tags: z.array(z.string()).optional(),
    timeWindow: SLOs_time_window,
  })
  .passthrough();
const SLOs_create_slo_response = z.object({ id: z.string() }).passthrough();
const SLOs_409_response = z
  .object({ error: z.string(), message: z.string(), statusCode: z.number() })
  .passthrough();
const SLOs_bulk_delete_request = z.object({ list: z.array(z.string()) }).passthrough();
const SLOs_bulk_delete_response = z.object({ taskId: z.string() }).partial().passthrough();
const SLOs_bulk_delete_status_response = z
  .object({
    error: z.string(),
    isDone: z.boolean(),
    results: z.array(
      z.object({ error: z.string(), id: z.string(), success: z.boolean() }).partial().passthrough()
    ),
  })
  .partial()
  .passthrough();
const SLOs_bulk_purge_rollup_request = z
  .object({
    list: z.array(z.string()),
    purgePolicy: z.union([
      z
        .object({ age: z.string(), purgeType: z.literal('fixed-age') })
        .partial()
        .passthrough(),
      z
        .object({ purgeType: z.literal('fixed-time'), timestamp: z.string() })
        .partial()
        .passthrough(),
    ]),
  })
  .passthrough();
const SLOs_bulk_purge_rollup_response = z.object({ taskId: z.string() }).partial().passthrough();
const SLOs_delete_slo_instances_request = z
  .object({ list: z.array(z.object({ instanceId: z.string(), sloId: z.string() }).passthrough()) })
  .passthrough();
const SLOs_update_slo_request = z
  .object({
    budgetingMethod: SLOs_budgeting_method,
    description: z.string(),
    groupBy: SLOs_group_by,
    indicator: z.union([
      SLOs_indicator_properties_custom_kql,
      SLOs_indicator_properties_apm_availability,
      SLOs_indicator_properties_apm_latency,
      SLOs_indicator_properties_custom_metric,
      SLOs_indicator_properties_histogram,
      SLOs_indicator_properties_timeslice_metric,
    ]),
    name: z.string(),
    objective: SLOs_objective,
    settings: SLOs_settings,
    tags: z.array(z.string()),
    timeWindow: SLOs_time_window,
  })
  .partial()
  .passthrough();
const SLOs_slo_definition_response = z
  .object({
    budgetingMethod: SLOs_budgeting_method,
    createdAt: z.string(),
    description: z.string(),
    enabled: z.boolean(),
    groupBy: SLOs_group_by,
    id: z.string(),
    indicator: z.discriminatedUnion('type', [
      SLOs_indicator_properties_custom_kql,
      SLOs_indicator_properties_apm_availability,
      SLOs_indicator_properties_apm_latency,
      SLOs_indicator_properties_custom_metric,
      SLOs_indicator_properties_histogram,
      SLOs_indicator_properties_timeslice_metric,
    ]),
    name: z.string(),
    objective: SLOs_objective,
    revision: z.number(),
    settings: SLOs_settings,
    tags: z.array(z.string()),
    timeWindow: SLOs_time_window,
    updatedAt: z.string(),
    version: z.number(),
  })
  .passthrough();
const SLOs_find_slo_definitions_response = z.union([
  z
    .object({
      page: z.number(),
      perPage: z.number(),
      results: z.array(SLOs_slo_with_summary_response),
      total: z.number(),
    })
    .partial()
    .passthrough(),
  z
    .object({
      page: z.number().default(1),
      perPage: z.number(),
      results: z.array(SLOs_slo_with_summary_response),
      searchAfter: z.array(z.string()),
      size: z.number(),
      total: z.number(),
    })
    .partial()
    .passthrough(),
]);

export const schemas = {
  bedrock_config,
  crowdstrike_config,
  d3security_config,
  email_config,
  gemini_config,
  resilient_config,
  index_config,
  jira_config,
  genai_azure_config,
  genai_openai_config,
  genai_openai_other_config,
  opsgenie_config,
  pagerduty_config,
  sentinelone_config,
  servicenow_config,
  servicenow_itom_config,
  slack_api_config,
  swimlane_config,
  thehive_config,
  tines_config,
  torq_config,
  auth_type,
  ca,
  cert_type,
  has_auth,
  verification_mode,
  webhook_config,
  cases_webhook_config,
  xmatters_config,
  bedrock_secrets,
  crowdstrike_secrets,
  d3security_secrets,
  email_secrets,
  gemini_secrets,
  resilient_secrets,
  jira_secrets,
  defender_secrets,
  teams_secrets,
  genai_secrets,
  opsgenie_secrets,
  pagerduty_secrets,
  sentinelone_secrets,
  servicenow_secrets,
  slack_api_secrets,
  swimlane_secrets,
  thehive_secrets,
  tines_secrets,
  torq_secrets,
  crt,
  key,
  pfx,
  webhook_secrets,
  cases_webhook_secrets,
  xmatters_secrets,
  post_actions_connector_id_Body,
  defender_config,
  put_actions_connector_id_Body,
  run_acknowledge_resolve_pagerduty,
  run_documents,
  run_message_email,
  run_message_serverlog,
  run_message_slack,
  run_trigger_pagerduty,
  run_addevent,
  run_closealert,
  run_closeincident,
  run_createalert,
  run_fieldsbyissuetype,
  run_getagentdetails,
  run_getagents,
  run_getchoices,
  run_getfields,
  run_getincident,
  run_issue,
  run_issues,
  run_issuetypes,
  run_postmessage,
  run_pushtoservice,
  run_validchannelid,
  post_actions_connector_id_execute_Body,
  Alerting_401_response,
  Alerting_fieldmap_properties,
  params_property_apm_anomaly,
  params_property_apm_error_count,
  params_property_apm_transaction_duration,
  params_property_apm_transaction_error_rate,
  aggfield,
  aggtype,
  excludehitsfrompreviousrun,
  groupby,
  size,
  termfield,
  termsize,
  threshold,
  thresholdcomparator,
  timefield,
  timewindowsize,
  timewindowunit,
  params_es_query_dsl_rule,
  params_es_query_esql_rule,
  filter,
  params_es_query_kql_rule,
  params_index_threshold_rule,
  params_property_infra_inventory,
  params_property_log_threshold,
  params_property_infra_metric_threshold,
  params_property_slo_burn_rate,
  params_property_synthetics_uptime_tls,
  params_property_synthetics_monitor_status,
  post_alerting_rule_id_Body,
  put_alerting_rule_id_Body,
  post_alerting_rule_id_snooze_schedule_Body,
  search_fields,
  has_reference,
  APM_UI_agent_keys_object,
  APM_UI_agent_keys_response,
  APM_UI_400_response,
  APM_UI_401_response,
  APM_UI_403_response,
  APM_UI_500_response,
  APM_UI_404_response,
  APM_UI_create_annotation_object,
  APM_UI_create_annotation_response,
  APM_UI_annotation_search_response,
  APM_UI_service_object,
  APM_UI_delete_service_object,
  APM_UI_delete_agent_configurations_response,
  APM_UI_settings_object,
  APM_UI_agent_configuration_object,
  APM_UI_agent_configurations_response,
  APM_UI_agent_configuration_intake_object,
  APM_UI_service_agent_name_response,
  APM_UI_service_environment_object,
  APM_UI_service_environments_response,
  APM_UI_search_agent_configuration_object,
  APM_UI_search_agent_configuration_response,
  APM_UI_single_agent_configuration_response,
  APM_UI_base_source_map_object,
  APM_UI_source_maps_response,
  APM_UI_501_response,
  APM_UI_upload_source_map_object,
  APM_UI_upload_source_maps_response,
  Security_Entity_Analytics_API_IdField,
  Security_Entity_Analytics_API_AssetCriticalityRecordIdParts,
  Security_Entity_Analytics_API_AssetCriticalityLevel,
  Security_Entity_Analytics_API_CreateAssetCriticalityRecord,
  Security_Entity_Analytics_API_AssetCriticalityRecordEcsParts,
  Security_Entity_Analytics_API_AssetCriticalityRecord,
  CreateAssetCriticalityRecord_Body,
  Security_Entity_Analytics_API_AssetCriticalityLevelsForBulkUpload,
  BulkUpsertAssetCriticalityRecords_Body,
  Security_Entity_Analytics_API_AssetCriticalityBulkUploadErrorItem,
  Security_Entity_Analytics_API_AssetCriticalityBulkUploadStats,
  Cases_4xx_response,
  Cases_assignees,
  Cases_case_category,
  Cases_connector_properties_none,
  Cases_connector_properties_cases_webhook,
  Cases_connector_properties_jira,
  Cases_connector_properties_resilient,
  Cases_connector_properties_servicenow,
  Cases_connector_properties_servicenow_sir,
  Cases_connector_properties_swimlane,
  Cases_case_description,
  Cases_settings,
  Cases_case_severity,
  Cases_case_status,
  Cases_case_tags,
  Cases_case_title,
  Cases_update_case_request,
  Cases_case_response_closed_by_properties,
  Cases_owner,
  Cases_alert_comment_response_properties,
  Cases_case_response_created_by_properties,
  Cases_case_response_pushed_by_properties,
  Cases_case_response_updated_by_properties,
  Cases_user_comment_response_properties,
  Cases_external_service,
  Cases_case_response_properties,
  Cases_create_case_request,
  Cases_string,
  Cases_string_array,
  assignees,
  Cases_case_categories,
  category,
  Cases_owners,
  owner,
  Cases_searchFieldsType,
  Cases_searchFieldsTypeArray,
  searchFields,
  Cases_alert_response_properties,
  Cases_alert_identifiers,
  Cases_alert_indices,
  Cases_rule,
  Cases_update_alert_comment_request_properties,
  Cases_update_user_comment_request_properties,
  Cases_update_case_comment_request,
  Cases_add_alert_comment_request_properties,
  Cases_add_user_comment_request_properties,
  Cases_add_case_comment_request,
  Cases_add_case_file_request,
  Cases_actions,
  Cases_payload_alert_comment,
  Cases_payload_assignees,
  Cases_connector_types,
  Cases_payload_connector,
  Cases_payload_create_case,
  Cases_payload_delete,
  Cases_payload_description,
  Cases_payload_pushed,
  Cases_payload_settings,
  Cases_payload_severity,
  Cases_payload_status,
  Cases_payload_tags,
  Cases_payload_title,
  Cases_payload_user_comment,
  Cases_user_actions_find_response_properties,
  Cases_closure_types,
  Cases_template_tags,
  Cases_templates,
  Cases_set_case_configuration_request,
  Cases_update_case_configuration_request,
  Data_views_400_response,
  Data_views_allownoindex,
  Data_views_fieldattrs,
  Data_views_fieldformats,
  Data_views_namespaces,
  Data_views_runtimefieldmap,
  Data_views_sourcefilters,
  Data_views_timefieldname,
  Data_views_title,
  Data_views_type,
  Data_views_typemeta,
  Data_views_create_data_view_request_object,
  Data_views_typemeta_response,
  Data_views_data_view_response_object,
  Data_views_404_response,
  Data_views_update_data_view_request_object,
  createRuntimeFieldDefault_Body,
  setDefaultDatailViewDefault_Body,
  Data_views_swap_data_view_request_object,
  Security_Detections_API_PlatformErrorResponse,
  Security_Detections_API_SiemErrorResponse,
  Security_Detections_API_RuleActionAlertsFilter,
  Security_Detections_API_RuleActionNotifyWhen,
  Security_Detections_API_RuleActionThrottle,
  Security_Detections_API_RuleActionFrequency,
  Security_Detections_API_RuleActionGroup,
  Security_Detections_API_RuleActionId,
  Security_Detections_API_RuleActionParams,
  Security_Detections_API_NonEmptyString,
  Security_Detections_API_RuleAction,
  Security_Detections_API_SavedObjectResolveAliasPurpose,
  Security_Detections_API_SavedObjectResolveAliasTargetId,
  Security_Detections_API_RuleAuthorArray,
  Security_Detections_API_BuildingBlockType,
  Security_Detections_API_RuleDescription,
  Security_Detections_API_IsRuleEnabled,
  Security_Detections_API_ExceptionListType,
  Security_Detections_API_RuleExceptionList,
  Security_Detections_API_RuleFalsePositiveArray,
  Security_Detections_API_RuleIntervalFrom,
  Security_Detections_API_RuleInterval,
  Security_Detections_API_InvestigationFields,
  Security_Detections_API_RuleLicense,
  Security_Detections_API_MaxSignals,
  Security_Detections_API_RuleMetadata,
  Security_Detections_API_RuleName,
  Security_Detections_API_AlertsIndexNamespace,
  Security_Detections_API_InvestigationGuide,
  Security_Detections_API_SavedObjectResolveOutcome,
  Security_Detections_API_AlertsIndex,
  Security_Detections_API_RuleReferenceArray,
  Security_Detections_API_RelatedIntegration,
  Security_Detections_API_RelatedIntegrationArray,
  Security_Detections_API_RequiredFieldInput,
  Security_Detections_API_EcsMapping,
  Security_Detections_API_OsqueryQuery,
  Security_Detections_API_OsqueryParams,
  Security_Detections_API_OsqueryResponseAction,
  Security_Detections_API_DefaultParams,
  Security_Detections_API_ProcessesParams,
  Security_Detections_API_EndpointResponseAction,
  Security_Detections_API_ResponseAction,
  Security_Detections_API_RiskScore,
  Security_Detections_API_RiskScoreMapping,
  Security_Detections_API_RuleNameOverride,
  Security_Detections_API_SetupGuide,
  Security_Detections_API_Severity,
  Security_Detections_API_SeverityMapping,
  Security_Detections_API_RuleTagArray,
  Security_Detections_API_ThreatTactic,
  Security_Detections_API_ThreatSubtechnique,
  Security_Detections_API_ThreatTechnique,
  Security_Detections_API_Threat,
  Security_Detections_API_ThreatArray,
  Security_Detections_API_TimelineTemplateId,
  Security_Detections_API_TimelineTemplateTitle,
  Security_Detections_API_TimestampOverride,
  Security_Detections_API_TimestampOverrideFallbackDisabled,
  Security_Detections_API_RuleIntervalTo,
  Security_Detections_API_RuleVersion,
  Security_Detections_API_RuleExecutionMetrics,
  Security_Detections_API_RuleExecutionStatus,
  Security_Detections_API_RuleExecutionStatusOrder,
  Security_Detections_API_RuleExecutionSummary,
  Security_Detections_API_UUID,
  Security_Detections_API_RuleObjectId,
  Security_Detections_API_IsRuleImmutable,
  Security_Detections_API_RequiredField,
  Security_Detections_API_RequiredFieldArray,
  Security_Detections_API_RuleRevision,
  Security_Detections_API_RuleSignatureId,
  Security_Detections_API_IsExternalRuleCustomized,
  Security_Detections_API_ExternalRuleSource,
  Security_Detections_API_InternalRuleSource,
  Security_Detections_API_RuleSource,
  Security_Detections_API_ResponseFields,
  Security_Detections_API_EqlQueryLanguage,
  Security_Detections_API_RuleQuery,
  Security_Detections_API_EqlRequiredFields,
  Security_Detections_API_AlertSuppressionDurationUnit,
  Security_Detections_API_AlertSuppressionDuration,
  Security_Detections_API_AlertSuppressionGroupBy,
  Security_Detections_API_AlertSuppressionMissingFieldsStrategy,
  Security_Detections_API_AlertSuppression,
  Security_Detections_API_DataViewId,
  Security_Detections_API_EventCategoryOverride,
  Security_Detections_API_RuleFilterArray,
  Security_Detections_API_IndexPatternArray,
  Security_Detections_API_TiebreakerField,
  Security_Detections_API_TimestampField,
  Security_Detections_API_EqlOptionalFields,
  Security_Detections_API_EqlRuleResponseFields,
  Security_Detections_API_EqlRule,
  Security_Detections_API_QueryRuleRequiredFields,
  Security_Detections_API_SavedQueryId,
  Security_Detections_API_QueryRuleOptionalFields,
  Security_Detections_API_KqlQueryLanguage,
  Security_Detections_API_QueryRuleResponseFields,
  Security_Detections_API_QueryRule,
  Security_Detections_API_SavedQueryRuleRequiredFields,
  Security_Detections_API_SavedQueryRuleOptionalFields,
  Security_Detections_API_SavedQueryRuleResponseFields,
  Security_Detections_API_SavedQueryRule,
  Security_Detections_API_ThresholdCardinality,
  Security_Detections_API_ThresholdField,
  Security_Detections_API_ThresholdValue,
  Security_Detections_API_Threshold,
  Security_Detections_API_ThresholdRuleRequiredFields,
  Security_Detections_API_ThresholdAlertSuppression,
  Security_Detections_API_ThresholdRuleOptionalFields,
  Security_Detections_API_ThresholdRuleResponseFields,
  Security_Detections_API_ThresholdRule,
  Security_Detections_API_ThreatIndex,
  Security_Detections_API_ThreatMappingEntry,
  Security_Detections_API_ThreatMapping,
  Security_Detections_API_ThreatQuery,
  Security_Detections_API_ThreatMatchRuleRequiredFields,
  Security_Detections_API_ConcurrentSearches,
  Security_Detections_API_ItemsPerSearch,
  Security_Detections_API_ThreatFilters,
  Security_Detections_API_ThreatIndicatorPath,
  Security_Detections_API_ThreatMatchRuleOptionalFields,
  Security_Detections_API_ThreatMatchRuleResponseFields,
  Security_Detections_API_ThreatMatchRule,
  Security_Detections_API_AnomalyThreshold,
  Security_Detections_API_MachineLearningJobId,
  Security_Detections_API_MachineLearningRuleRequiredFields,
  Security_Detections_API_MachineLearningRuleOptionalFields,
  Security_Detections_API_MachineLearningRuleResponseFields,
  Security_Detections_API_MachineLearningRule,
  Security_Detections_API_HistoryWindowStart,
  Security_Detections_API_NewTermsFields,
  Security_Detections_API_NewTermsRuleRequiredFields,
  Security_Detections_API_NewTermsRuleOptionalFields,
  Security_Detections_API_NewTermsRuleResponseFields,
  Security_Detections_API_NewTermsRule,
  Security_Detections_API_EsqlRuleOptionalFields,
  Security_Detections_API_EsqlQueryLanguage,
  Security_Detections_API_EsqlRuleRequiredFields,
  Security_Detections_API_EsqlRuleResponseFields,
  Security_Detections_API_EsqlRule,
  Security_Detections_API_RuleResponse,
  Security_Detections_API_EqlRulePatchFields,
  Security_Detections_API_EqlRulePatchProps,
  Security_Detections_API_QueryRuleDefaultableFields,
  Security_Detections_API_QueryRulePatchFields,
  Security_Detections_API_QueryRulePatchProps,
  Security_Detections_API_SavedQueryRuleDefaultableFields,
  Security_Detections_API_SavedQueryRulePatchFields,
  Security_Detections_API_SavedQueryRulePatchProps,
  Security_Detections_API_ThresholdRuleDefaultableFields,
  Security_Detections_API_ThresholdRulePatchFields,
  Security_Detections_API_ThresholdRulePatchProps,
  Security_Detections_API_ThreatMatchRuleDefaultableFields,
  Security_Detections_API_ThreatMatchRulePatchFields,
  Security_Detections_API_ThreatMatchRulePatchProps,
  Security_Detections_API_MachineLearningRulePatchFields,
  Security_Detections_API_MachineLearningRulePatchProps,
  Security_Detections_API_NewTermsRuleDefaultableFields,
  Security_Detections_API_NewTermsRulePatchFields,
  Security_Detections_API_NewTermsRulePatchProps,
  Security_Detections_API_EsqlRulePatchProps,
  Security_Detections_API_RulePatchProps,
  Security_Detections_API_EqlRuleCreateFields,
  Security_Detections_API_EqlRuleCreateProps,
  Security_Detections_API_QueryRuleCreateFields,
  Security_Detections_API_QueryRuleCreateProps,
  Security_Detections_API_SavedQueryRuleCreateFields,
  Security_Detections_API_SavedQueryRuleCreateProps,
  Security_Detections_API_ThresholdRuleCreateFields,
  Security_Detections_API_ThresholdRuleCreateProps,
  Security_Detections_API_ThreatMatchRuleCreateFields,
  Security_Detections_API_ThreatMatchRuleCreateProps,
  Security_Detections_API_MachineLearningRuleCreateFields,
  Security_Detections_API_MachineLearningRuleCreateProps,
  Security_Detections_API_NewTermsRuleCreateFields,
  Security_Detections_API_NewTermsRuleCreateProps,
  Security_Detections_API_EsqlRuleCreateFields,
  Security_Detections_API_EsqlRuleCreateProps,
  Security_Detections_API_RuleCreateProps,
  Security_Detections_API_EqlRuleUpdateProps,
  Security_Detections_API_QueryRuleUpdateProps,
  Security_Detections_API_SavedQueryRuleUpdateProps,
  Security_Detections_API_ThresholdRuleUpdateProps,
  Security_Detections_API_ThreatMatchRuleUpdateProps,
  Security_Detections_API_MachineLearningRuleUpdateProps,
  Security_Detections_API_NewTermsRuleUpdateProps,
  Security_Detections_API_EsqlRuleUpdateProps,
  Security_Detections_API_RuleUpdateProps,
  Security_Detections_API_BulkDeleteRules,
  Security_Detections_API_BulkDisableRules,
  Security_Detections_API_BulkEnableRules,
  Security_Detections_API_BulkExportRules,
  Security_Detections_API_BulkDuplicateRules,
  Security_Detections_API_BulkManualRuleRun,
  Security_Detections_API_BulkManualRuleFillGaps,
  Security_Detections_API_BulkActionEditPayloadTags,
  Security_Detections_API_BulkActionEditPayloadIndexPatterns,
  Security_Detections_API_BulkActionEditPayloadInvestigationFields,
  Security_Detections_API_BulkActionEditPayloadTimeline,
  Security_Detections_API_NormalizedRuleAction,
  Security_Detections_API_ThrottleForBulkActions,
  Security_Detections_API_BulkActionEditPayloadRuleActions,
  Security_Detections_API_BulkActionEditPayloadSchedule,
  Security_Detections_API_BulkActionEditPayloadSetAlertSuppression,
  Security_Detections_API_BulkActionEditPayloadSetAlertSuppressionForThreshold,
  Security_Detections_API_BulkActionEditPayloadDeleteAlertSuppression,
  Security_Detections_API_BulkActionEditPayloadAlertSuppression,
  Security_Detections_API_BulkActionEditPayload,
  Security_Detections_API_BulkEditRules,
  PerformRulesBulkAction_Body,
  Security_Detections_API_BulkActionsDryRunErrCode,
  Security_Detections_API_RuleDetailsInError,
  Security_Detections_API_NormalizedRuleError,
  Security_Detections_API_BulkEditSkipReason,
  Security_Detections_API_BulkGapsFillingSkipReason,
  Security_Detections_API_BulkActionSkipResult,
  Security_Detections_API_BulkEditActionResults,
  Security_Detections_API_BulkEditActionSummary,
  Security_Detections_API_BulkEditActionResponse,
  Security_Detections_API_BulkExportActionResponse,
  ExportRules_Body,
  Security_Detections_API_ErrorSchema,
  Security_Detections_API_WarningSchema,
  Security_Exceptions_API_NonEmptyString,
  Security_Exceptions_API_CreateRuleExceptionListItemComment,
  Security_Exceptions_API_CreateRuleExceptionListItemCommentArray,
  Security_Exceptions_API_ExceptionListItemDescription,
  Security_Exceptions_API_ExceptionListItemEntryOperator,
  Security_Exceptions_API_ExceptionListItemEntryMatch,
  Security_Exceptions_API_ExceptionListItemEntryMatchAny,
  Security_Exceptions_API_ListId,
  Security_Exceptions_API_ListType,
  Security_Exceptions_API_ExceptionListItemEntryList,
  Security_Exceptions_API_ExceptionListItemEntryExists,
  Security_Exceptions_API_ExceptionListItemEntryNestedEntryItem,
  Security_Exceptions_API_ExceptionListItemEntryNested,
  Security_Exceptions_API_ExceptionListItemEntryMatchWildcard,
  Security_Exceptions_API_ExceptionListItemEntry,
  Security_Exceptions_API_ExceptionListItemEntryArray,
  Security_Exceptions_API_ExceptionListItemHumanId,
  Security_Exceptions_API_ExceptionListItemMeta,
  Security_Exceptions_API_ExceptionListItemName,
  Security_Exceptions_API_ExceptionNamespaceType,
  Security_Exceptions_API_ExceptionListOsType,
  Security_Exceptions_API_ExceptionListItemOsTypeArray,
  Security_Exceptions_API_ExceptionListItemTags,
  Security_Exceptions_API_ExceptionListItemType,
  Security_Exceptions_API_CreateRuleExceptionListItemProps,
  CreateRuleExceptionListItems_Body,
  Security_Exceptions_API_ExceptionListItemComment,
  Security_Exceptions_API_ExceptionListItemCommentArray,
  Security_Exceptions_API_ExceptionListItemExpireTime,
  Security_Exceptions_API_ExceptionListItemId,
  Security_Exceptions_API_ExceptionListHumanId,
  Security_Exceptions_API_ExceptionListItem,
  Security_Exceptions_API_PlatformErrorResponse,
  Security_Exceptions_API_SiemErrorResponse,
  Security_Detections_API_RulePreviewParams,
  RulePreview_Body,
  Security_Detections_API_RulePreviewLoggedRequest,
  Security_Detections_API_RulePreviewLogs,
  Security_Detections_API_AlertAssignees,
  Security_Detections_API_AlertIds,
  SetAlertAssignees_Body,
  Security_Detections_API_AlertsSortCombinations,
  Security_Detections_API_AlertsSort,
  SearchAlerts_Body,
  Security_Detections_API_AlertStatus,
  Security_Detections_API_SetAlertsStatusByIds,
  Security_Detections_API_SetAlertsStatusByQuery,
  SetAlertsStatus_Body,
  Security_Detections_API_AlertTag,
  Security_Detections_API_AlertTags,
  Security_Detections_API_SetAlertTags,
  SetAlertTags_Body,
  Saved_objects_400_response,
  Security_Endpoint_Exceptions_API_ExceptionListDescription,
  Security_Endpoint_Exceptions_API_ExceptionListId,
  Security_Endpoint_Exceptions_API_ExceptionListHumanId,
  Security_Endpoint_Exceptions_API_ExceptionListMeta,
  Security_Endpoint_Exceptions_API_ExceptionListName,
  Security_Endpoint_Exceptions_API_ExceptionNamespaceType,
  Security_Endpoint_Exceptions_API_ExceptionListOsType,
  Security_Endpoint_Exceptions_API_ExceptionListOsTypeArray,
  Security_Endpoint_Exceptions_API_ExceptionListTags,
  Security_Endpoint_Exceptions_API_ExceptionListType,
  Security_Endpoint_Exceptions_API_ExceptionListVersion,
  Security_Endpoint_Exceptions_API_ExceptionList,
  Security_Endpoint_Exceptions_API_EndpointList,
  Security_Endpoint_Exceptions_API_PlatformErrorResponse,
  Security_Endpoint_Exceptions_API_SiemErrorResponse,
  Security_Endpoint_Exceptions_API_NonEmptyString,
  Security_Endpoint_Exceptions_API_ExceptionListItemComment,
  Security_Endpoint_Exceptions_API_ExceptionListItemCommentArray,
  Security_Endpoint_Exceptions_API_ExceptionListItemDescription,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryOperator,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatch,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatchAny,
  Security_Endpoint_Exceptions_API_ListId,
  Security_Endpoint_Exceptions_API_ListType,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryList,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryExists,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryNestedEntryItem,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryNested,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatchWildcard,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntry,
  Security_Endpoint_Exceptions_API_ExceptionListItemEntryArray,
  Security_Endpoint_Exceptions_API_ExceptionListItemExpireTime,
  Security_Endpoint_Exceptions_API_ExceptionListItemId,
  Security_Endpoint_Exceptions_API_ExceptionListItemHumanId,
  Security_Endpoint_Exceptions_API_ExceptionListItemMeta,
  Security_Endpoint_Exceptions_API_ExceptionListItemName,
  Security_Endpoint_Exceptions_API_ExceptionListItemOsTypeArray,
  Security_Endpoint_Exceptions_API_ExceptionListItemTags,
  Security_Endpoint_Exceptions_API_ExceptionListItemType,
  Security_Endpoint_Exceptions_API_ExceptionListItem,
  CreateEndpointListItem_Body,
  UpdateEndpointListItem_Body,
  Security_Endpoint_Management_API_Command,
  agentIds,
  Security_Endpoint_Management_API_Type,
  Security_Endpoint_Management_API_GetEndpointActionListResponse,
  Security_Endpoint_Management_API_AgentIds,
  query,
  Security_Endpoint_Management_API_AgentId,
  Security_Endpoint_Management_API_PendingActionDataType,
  Security_Endpoint_Management_API_PendingActionsSchema,
  Security_Endpoint_Management_API_ActionStatusSuccessResponse,
  Security_Endpoint_Management_API_GetEndpointActionResponse,
  Security_Endpoint_Management_API_SuccessResponse,
  Security_Endpoint_Management_API_AgentTypes,
  Security_Endpoint_Management_API_AlertIds,
  Security_Endpoint_Management_API_CaseIds,
  Security_Endpoint_Management_API_Comment,
  Security_Endpoint_Management_API_EndpointIds,
  Security_Endpoint_Management_API_Parameters,
  Security_Endpoint_Management_API_Timeout,
  Security_Endpoint_Management_API_ExecuteRouteRequestBody,
  Security_Endpoint_Management_API_ExecuteRouteResponse,
  Security_Endpoint_Management_API_GetFileRouteRequestBody,
  Security_Endpoint_Management_API_GetFileRouteResponse,
  EndpointIsolateAction_Body,
  Security_Endpoint_Management_API_IsolateRouteResponse,
  Security_Endpoint_Management_API_KillProcessRouteRequestBody,
  Security_Endpoint_Management_API_KillProcessRouteResponse,
  Security_Endpoint_Management_API_GetProcessesRouteRequestBody,
  Security_Endpoint_Management_API_GetProcessesRouteResponse,
  Security_Endpoint_Management_API_RawScriptParameters,
  Security_Endpoint_Management_API_HostPathScriptParameters,
  Security_Endpoint_Management_API_CloudFileScriptParameters,
  Security_Endpoint_Management_API_RunScriptRouteRequestBody,
  Security_Endpoint_Management_API_ScanRouteRequestBody,
  Security_Endpoint_Management_API_ScanRouteResponse,
  Security_Endpoint_Management_API_ActionStateSuccessResponse,
  Security_Endpoint_Management_API_SuspendProcessRouteRequestBody,
  Security_Endpoint_Management_API_SuspendProcessRouteResponse,
  Security_Endpoint_Management_API_UnisolateRouteResponse,
  Security_Endpoint_Management_API_UploadRouteRequestBody,
  Security_Endpoint_Management_API_UploadRouteResponse,
  Security_Endpoint_Management_API_MetadataListResponse,
  Security_Endpoint_Management_API_EndpointMetadataResponse,
  query__2,
  Security_Endpoint_Management_API_ProtectionUpdatesNoteResponse,
  Security_Entity_Analytics_API_PrivilegeMonitoringEngineStatus,
  Security_Entity_Analytics_API_MonitoringEngineDescriptor,
  Security_Entity_Analytics_API_EntityAnalyticsPrivileges,
  Security_Entity_Analytics_API_UserName,
  Security_Entity_Analytics_API_MonitoredUserDoc,
  Security_Entity_Analytics_API_PrivmonUserCsvUploadErrorItem,
  Security_Entity_Analytics_API_PrivmonUserCsvUploadStats,
  Security_Entity_Analytics_API_Interval,
  Security_Entity_Analytics_API_EntityType,
  Security_Entity_Analytics_API_IndexPattern,
  InitEntityStore_Body,
  Security_Entity_Analytics_API_EngineStatus,
  Security_Entity_Analytics_API_EngineDescriptor,
  InitEntityEngine_Body,
  Security_Entity_Analytics_API_EngineDataviewUpdateResult,
  Security_Entity_Analytics_API_InspectQuery,
  Security_Entity_Analytics_API_EngineMetadata,
  Security_Entity_Analytics_API_EntityRiskLevels,
  Security_Entity_Analytics_API_RiskScoreInput,
  Security_Entity_Analytics_API_EntityRiskScoreRecord,
  Security_Entity_Analytics_API_UserEntity,
  Security_Entity_Analytics_API_HostEntity,
  Security_Entity_Analytics_API_ServiceEntity,
  Security_Entity_Analytics_API_GenericEntity,
  Security_Entity_Analytics_API_Entity,
  Security_Entity_Analytics_API_TransformStatsMetadata,
  Security_Entity_Analytics_API_EngineComponentResource,
  Security_Entity_Analytics_API_EngineComponentStatus,
  Security_Entity_Analytics_API_StoreStatus,
  Security_Exceptions_API_ExceptionListDescription,
  Security_Exceptions_API_ExceptionListId,
  Security_Exceptions_API_ExceptionListMeta,
  Security_Exceptions_API_ExceptionListName,
  Security_Exceptions_API_ExceptionListOsTypeArray,
  Security_Exceptions_API_ExceptionListTags,
  Security_Exceptions_API_ExceptionListType,
  Security_Exceptions_API_ExceptionListVersion,
  Security_Exceptions_API_ExceptionList,
  CreateExceptionList_Body,
  UpdateExceptionList_Body,
  Security_Exceptions_API_ExceptionListsImportBulkError,
  Security_Exceptions_API_ExceptionListsImportBulkErrorArray,
  Security_Exceptions_API_CreateExceptionListItemComment,
  Security_Exceptions_API_CreateExceptionListItemCommentArray,
  CreateExceptionListItem_Body,
  Security_Exceptions_API_UpdateExceptionListItemComment,
  Security_Exceptions_API_UpdateExceptionListItemCommentArray,
  UpdateExceptionListItem_Body,
  CreateSharedExceptionList_Body,
  post_fleet_agent_download_sources_Body,
  post_fleet_agent_policies_Body,
  post_fleet_agent_policies_bulk_get_Body,
  put_fleet_agent_policies_agentpolicyid_Body,
  post_fleet_agent_policies_agentpolicyid_copy_Body,
  post_fleet_agent_policies_delete_Body,
  post_fleet_agent_policies_outputs_Body,
  agentsIds,
  post_fleet_agents_Body,
  put_fleet_agents_agentid_Body,
  post_fleet_agents_agentid_actions_Body,
  post_fleet_agents_agentid_request_diagnostics_Body,
  post_fleet_agents_agentid_unenroll_Body,
  post_fleet_agents_agentid_upgrade_Body,
  post_fleet_agents_bulk_reassign_Body,
  post_fleet_agents_bulk_request_diagnostics_Body,
  post_fleet_agents_bulk_unenroll_Body,
  post_fleet_agents_bulk_update_agent_tags_Body,
  post_fleet_agents_bulk_upgrade_Body,
  post_fleet_enrollment_api_keys_Body,
  post_fleet_epm_bulk_assets_Body,
  post_fleet_epm_custom_integrations_Body,
  put_fleet_epm_custom_integrations_pkgname_Body,
  post_fleet_epm_packages_bulk_Body,
  post_fleet_epm_packages_bulk_uninstall_Body,
  post_fleet_epm_packages_bulk_upgrade_Body,
  post_fleet_epm_packages_pkgname_pkgversion_Body,
  post_fleet_epm_packages_pkgname_pkgversion_kibana_assets_Body,
  post_fleet_epm_packages_pkgname_pkgversion_transforms_authorize_Body,
  searchAfter,
  post_fleet_fleet_server_hosts_Body,
  put_fleet_fleet_server_hosts_itemid_Body,
  post_fleet_outputs_Body,
  put_fleet_outputs_outputid_Body,
  post_fleet_package_policies_Body,
  post_fleet_package_policies_bulk_get_Body,
  put_fleet_package_policies_packagepolicyid_Body,
  post_fleet_package_policies_delete_Body,
  post_fleet_package_policies_upgrade_Body,
  post_fleet_package_policies_upgrade_dryrun_Body,
  post_fleet_proxies_Body,
  put_fleet_proxies_itemid_Body,
  put_fleet_settings_Body,
  put_fleet_space_settings_Body,
  Security_Lists_API_ListVersionId,
  Security_Lists_API_ListDescription,
  Security_Lists_API_ListDeserializer,
  Security_Lists_API_ListId,
  Security_Lists_API_ListMetadata,
  Security_Lists_API_ListName,
  Security_Lists_API_ListSerializer,
  Security_Lists_API_ListType,
  Security_Lists_API_ListVersion,
  Security_Lists_API_List,
  Security_Lists_API_PlatformErrorResponse,
  Security_Lists_API_SiemErrorResponse,
  PatchList_Body,
  CreateList_Body,
  UpdateList_Body,
  Security_Lists_API_FindListsCursor,
  Security_Lists_API_ListItemId,
  Security_Lists_API_ListItemMetadata,
  Security_Lists_API_ListItemValue,
  Security_Lists_API_ListItem,
  PatchListItem_Body,
  CreateListItem_Body,
  UpdateListItem_Body,
  Security_Lists_API_FindListItemsCursor,
  Security_Lists_API_ListItemPrivileges,
  Security_Lists_API_ListPrivileges,
  put_logstash_pipeline_Body,
  post_maintenance_window_Body,
  patch_maintenance_window_id_Body,
  Machine_learning_APIs_mlSyncResponseSuccess,
  Machine_learning_APIs_mlSyncResponseDatafeeds,
  Machine_learning_APIs_mlSyncResponseAnomalyDetectors,
  Machine_learning_APIs_mlSyncResponseDataFrameAnalytics,
  Machine_learning_APIs_mlSyncResponseTrainedModels,
  Machine_learning_APIs_mlSyncResponseSavedObjectsCreated,
  Machine_learning_APIs_mlSyncResponseSavedObjectsDeleted,
  Machine_learning_APIs_mlSync200Response,
  Machine_learning_APIs_mlSync4xxResponse,
  DeleteNote_Body,
  Security_Timeline_API_NoteCreatedAndUpdatedMetadata,
  Security_Timeline_API_BareNote,
  Security_Timeline_API_Note,
  Security_Timeline_API_GetNotesResult,
  PersistNoteRoute_Body,
  Security_Timeline_API_ResponseNote,
  Observability_AI_Assistant_API_Function,
  Observability_AI_Assistant_API_Instruction,
  Observability_AI_Assistant_API_FunctionCall,
  Observability_AI_Assistant_API_MessageRoleEnum,
  Observability_AI_Assistant_API_Message,
  observability_ai_assistant_chat_complete_Body,
  Security_Osquery_API_FindLiveQueryResponse,
  Security_Osquery_API_ECSMappingItem,
  Security_Osquery_API_ECSMapping,
  Security_Osquery_API_ECSMappingOrUndefined,
  Security_Osquery_API_PackId,
  Security_Osquery_API_PackIdOrUndefined,
  Security_Osquery_API_QueryId,
  Security_Osquery_API_Platform,
  Security_Osquery_API_PlatformOrUndefined,
  Security_Osquery_API_Query,
  Security_Osquery_API_Removed,
  Security_Osquery_API_RemovedOrUndefined,
  Security_Osquery_API_Snapshot,
  Security_Osquery_API_SnapshotOrUndefined,
  Security_Osquery_API_Version,
  Security_Osquery_API_VersionOrUndefined,
  Security_Osquery_API_ArrayQueriesItem,
  Security_Osquery_API_ArrayQueries,
  Security_Osquery_API_QueryOrUndefined,
  Security_Osquery_API_SavedQueryId,
  Security_Osquery_API_SavedQueryIdOrUndefined,
  Security_Osquery_API_CreateLiveQueryRequestBody,
  Security_Osquery_API_CreateLiveQueryResponse,
  Security_Osquery_API_FindLiveQueryDetailsResponse,
  Security_Osquery_API_GetLiveQueryResultsResponse,
  Security_Osquery_API_FindPacksResponse,
  Security_Osquery_API_PackDescription,
  Security_Osquery_API_PackDescriptionOrUndefined,
  Security_Osquery_API_Enabled,
  Security_Osquery_API_EnabledOrUndefined,
  Security_Osquery_API_PackName,
  Security_Osquery_API_PolicyIds,
  Security_Osquery_API_PolicyIdsOrUndefined,
  Security_Osquery_API_ObjectQueriesItem,
  Security_Osquery_API_ObjectQueries,
  Security_Osquery_API_Shards,
  Security_Osquery_API_CreatePacksRequestBody,
  Security_Osquery_API_CreatePacksResponse,
  Security_Osquery_API_FindPackResponse,
  Security_Osquery_API_UpdatePacksRequestBody,
  Security_Osquery_API_UpdatePacksResponse,
  Security_Osquery_API_FindSavedQueryResponse,
  Security_Osquery_API_SavedQueryDescription,
  Security_Osquery_API_SavedQueryDescriptionOrUndefined,
  Security_Osquery_API_Interval,
  Security_Osquery_API_CreateSavedQueryRequestBody,
  Security_Osquery_API_CreateSavedQueryResponse,
  Security_Osquery_API_DefaultSuccessResponse,
  Security_Osquery_API_FindSavedQueryDetailResponse,
  Security_Osquery_API_IntervalOrUndefined,
  Security_Osquery_API_UpdateSavedQueryRequestBody,
  Security_Osquery_API_UpdateSavedQueryResponse,
  PersistPinnedEventRoute_Body,
  Security_Timeline_API_PinnedEventCreatedAndUpdatedMetadata,
  Security_Timeline_API_BarePinnedEvent,
  Security_Timeline_API_PinnedEvent,
  Security_Timeline_API_PersistPinnedEventResponse,
  Security_Entity_Analytics_API_TaskManagerUnavailableResponse,
  Security_Entity_Analytics_API_CleanUpRiskEngineErrorResponse,
  ConfigureRiskEngineSavedObject_Body,
  Security_Entity_Analytics_API_ConfigureRiskEngineSavedObjectErrorResponse,
  Security_Entity_Analytics_API_RiskEngineScheduleNowResponse,
  Security_Entity_Analytics_API_RiskEngineScheduleNowErrorResponse,
  post_saved_objects_export_Body,
  resolveImportErrors_Body,
  Security_AI_Assistant_API_AnonymizationFieldCreateProps,
  Security_AI_Assistant_API_AnonymizationFieldUpdateProps,
  PerformAnonymizationFieldsBulkAction_Body,
  Security_AI_Assistant_API_AnonymizationFieldDetailsInError,
  Security_AI_Assistant_API_NormalizedAnonymizationFieldError,
  Security_AI_Assistant_API_NonEmptyString,
  Security_AI_Assistant_API_NonEmptyTimestamp,
  Security_AI_Assistant_API_AnonymizationFieldResponse,
  Security_AI_Assistant_API_AnonymizationFieldsBulkActionSkipReason,
  Security_AI_Assistant_API_AnonymizationFieldsBulkActionSkipResult,
  Security_AI_Assistant_API_AnonymizationFieldsBulkCrudActionResults,
  Security_AI_Assistant_API_BulkCrudActionSummary,
  Security_AI_Assistant_API_AnonymizationFieldsBulkCrudActionResponse,
  Security_AI_Assistant_API_MessageData,
  Security_AI_Assistant_API_ChatMessageRole,
  Security_AI_Assistant_API_ChatMessage,
  Security_AI_Assistant_API_ChatCompleteProps,
  DeleteAllConversations_Body,
  Security_AI_Assistant_API_Provider,
  Security_AI_Assistant_API_ApiConfig,
  Security_AI_Assistant_API_ConversationCategory,
  Security_AI_Assistant_API_BaseContentReference,
  Security_AI_Assistant_API_KnowledgeBaseEntryContentReference,
  Security_AI_Assistant_API_SecurityAlertContentReference,
  Security_AI_Assistant_API_SecurityAlertsPageContentReference,
  Security_AI_Assistant_API_ProductDocumentationContentReference,
  Security_AI_Assistant_API_EsqlContentReference,
  Security_AI_Assistant_API_HrefContentReference,
  Security_AI_Assistant_API_ContentReferences,
  Security_AI_Assistant_API_MessageMetadata,
  Security_AI_Assistant_API_Reader,
  Security_AI_Assistant_API_MessageRole,
  Security_AI_Assistant_API_TraceData,
  Security_AI_Assistant_API_User,
  Security_AI_Assistant_API_Message,
  Security_AI_Assistant_API_Replacements,
  Security_AI_Assistant_API_ConversationCreateProps,
  Security_AI_Assistant_API_ConversationResponse,
  Security_AI_Assistant_API_ConversationUpdateProps,
  Security_AI_Assistant_API_KnowledgeBaseResponse,
  Security_AI_Assistant_API_KnowledgeBaseResource,
  Security_AI_Assistant_API_DocumentEntryRequiredFields,
  Security_AI_Assistant_API_Vector,
  Security_AI_Assistant_API_DocumentEntryOptionalFields,
  Security_AI_Assistant_API_DocumentEntryCreateFields,
  Security_AI_Assistant_API_IndexEntryRequiredFields,
  Security_AI_Assistant_API_InputSchema,
  Security_AI_Assistant_API_IndexEntryOptionalFields,
  Security_AI_Assistant_API_IndexEntryCreateFields,
  Security_AI_Assistant_API_KnowledgeBaseEntryCreateProps,
  Security_AI_Assistant_API_ResponseFields,
  Security_AI_Assistant_API_DocumentEntryResponseFields,
  Security_AI_Assistant_API_DocumentEntry,
  Security_AI_Assistant_API_IndexEntryResponseFields,
  Security_AI_Assistant_API_IndexEntry,
  Security_AI_Assistant_API_KnowledgeBaseEntryResponse,
  Security_AI_Assistant_API_KnowledgeBaseEntryErrorSchema,
  Security_AI_Assistant_API_DocumentEntryUpdateFields,
  Security_AI_Assistant_API_IndexEntryUpdateFields,
  Security_AI_Assistant_API_KnowledgeBaseEntryUpdateProps,
  PerformKnowledgeBaseEntryBulkAction_Body,
  Security_AI_Assistant_API_KnowledgeBaseEntryDetailsInError,
  Security_AI_Assistant_API_NormalizedKnowledgeBaseEntryError,
  Security_AI_Assistant_API_KnowledgeBaseEntryBulkActionSkipReason,
  Security_AI_Assistant_API_KnowledgeBaseEntryBulkActionSkipResult,
  Security_AI_Assistant_API_KnowledgeBaseEntryBulkCrudActionResults,
  Security_AI_Assistant_API_KnowledgeBaseEntryBulkCrudActionSummary,
  Security_AI_Assistant_API_KnowledgeBaseEntryBulkCrudActionResponse,
  Security_AI_Assistant_API_DeleteResponseFields,
  Security_AI_Assistant_API_KnowledgeBaseEntryUpdateRouteProps,
  Security_AI_Assistant_API_PromptType,
  Security_AI_Assistant_API_PromptCreateProps,
  Security_AI_Assistant_API_PromptUpdateProps,
  PerformPromptsBulkAction_Body,
  Security_AI_Assistant_API_PromptDetailsInError,
  Security_AI_Assistant_API_NormalizedPromptError,
  Security_AI_Assistant_API_PromptResponse,
  Security_AI_Assistant_API_PromptsBulkActionSkipReason,
  Security_AI_Assistant_API_PromptsBulkActionSkipResult,
  Security_AI_Assistant_API_PromptsBulkCrudActionResults,
  Security_AI_Assistant_API_PromptsBulkCrudActionResponse,
  post_security_role_query_Body,
  put_security_role_name_Body,
  post_security_roles_Body,
  post_security_session_invalidate_Body,
  post_url_Body,
  Short_URL_APIs_urlResponse,
  post_spaces_copy_saved_objects_Body,
  post_spaces_disable_legacy_url_aliases_Body,
  post_spaces_get_shareable_references_Body,
  post_spaces_resolve_copy_saved_objects_errors_Body,
  post_spaces_update_objects_spaces_Body,
  include_authorized_purposes,
  post_spaces_space_Body,
  Kibana_HTTP_APIs_core_status_response,
  Kibana_HTTP_APIs_core_status_redactedResponse,
  get_streams_Body,
  put_streams_name_Body,
  post_streams_name_fork_Body,
  put_streams_name_group_Body,
  put_streams_name_ingest_Body,
  post_streams_name_content_export_Body,
  post_streams_name_dashboards_bulk_Body,
  post_streams_name_queries_bulk_Body,
  put_streams_name_queries_queryid_Body,
  post_streams_name_significant_events_preview_Body,
  locations,
  monitorTypes,
  schedules,
  useLogicalAndFor,
  Synthetics_commonMonitorFields,
  Synthetics_browserMonitorFields,
  Synthetics_httpMonitorFields,
  Synthetics_icmpMonitorFields,
  Synthetics_tcpMonitorFields,
  post_synthetic_monitors_Body,
  delete_synthetic_monitors_Body,
  Synthetics_getParameterResponse,
  Synthetics_parameterRequest,
  post_parameters_Body,
  Synthetics_postParameterResponse,
  put_parameter_Body,
  Synthetics_getPrivateLocation,
  post_private_location_Body,
  Task_manager_health_APIs_configuration,
  Task_manager_health_APIs_workload,
  Task_manager_health_APIs_health_response,
  DeleteTimelines_Body,
  Security_Timeline_API_ColumnHeaderResult,
  Security_Timeline_API_QueryMatchResult,
  Security_Timeline_API_DataProviderType,
  Security_Timeline_API_DataProviderQueryMatch,
  Security_Timeline_API_DataProviderResult,
  Security_Timeline_API_RowRendererId,
  Security_Timeline_API_FavoriteTimelineResult,
  Security_Timeline_API_FilterTimelineResult,
  Security_Timeline_API_SerializedFilterQueryResult,
  Security_Timeline_API_SortObject,
  Security_Timeline_API_Sort,
  Security_Timeline_API_TimelineStatus,
  Security_Timeline_API_TimelineType,
  Security_Timeline_API_SavedTimeline,
  Security_Timeline_API_SavedTimelineWithSavedObjectId,
  Security_Timeline_API_TimelineResponse,
  PatchTimeline_Body,
  CreateTimelines_Body,
  CopyTimeline_Body,
  CleanDraftTimelines_Body,
  ExportTimelines_Body,
  PersistFavoriteRoute_Body,
  Security_Timeline_API_FavoriteTimelineResponse,
  ImportTimelines_Body,
  Security_Timeline_API_ImportTimelineResult,
  Security_Timeline_API_TimelineSavedToReturnObject,
  Security_Timeline_API_ImportTimelines,
  InstallPrepackedTimelines_Body,
  Security_Timeline_API_SavedObjectResolveAliasPurpose,
  Security_Timeline_API_SavedObjectResolveOutcome,
  Security_Timeline_API_ResolvedTimeline,
  put_uptime_settings_Body,
  SLOs_budgeting_method,
  SLOs_group_by,
  SLOs_filter_meta,
  SLOs_filter,
  SLOs_kql_with_filters,
  SLOs_kql_with_filters_good,
  SLOs_kql_with_filters_total,
  SLOs_indicator_properties_custom_kql,
  SLOs_indicator_properties_apm_availability,
  SLOs_indicator_properties_apm_latency,
  SLOs_indicator_properties_custom_metric,
  SLOs_indicator_properties_histogram,
  SLOs_timeslice_metric_basic_metric_with_field,
  SLOs_timeslice_metric_percentile_metric,
  SLOs_timeslice_metric_doc_count_metric,
  SLOs_indicator_properties_timeslice_metric,
  SLOs_objective,
  SLOs_settings,
  SLOs_error_budget,
  SLOs_summary_status,
  SLOs_summary,
  SLOs_time_window,
  SLOs_slo_with_summary_response,
  SLOs_find_slo_response,
  SLOs_400_response,
  SLOs_401_response,
  SLOs_403_response,
  SLOs_404_response,
  SLOs_create_slo_request,
  SLOs_create_slo_response,
  SLOs_409_response,
  SLOs_bulk_delete_request,
  SLOs_bulk_delete_response,
  SLOs_bulk_delete_status_response,
  SLOs_bulk_purge_rollup_request,
  SLOs_bulk_purge_rollup_response,
  SLOs_delete_slo_instances_request,
  SLOs_update_slo_request,
  SLOs_slo_definition_response,
  SLOs_find_slo_definitions_response,
};

const endpoints = makeApi([
  {
    method: 'get',
    path: '/api/actions/connector_types',
    alias: 'get-actions-connector-types',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/actions/connector_types&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You do not need any Kibana feature privileges to run this API.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'feature_id',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'delete',
    path: '/api/actions/connector/:id',
    alias: 'delete-actions-connector-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/actions/connector/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

WARNING: When you delete a connector, it cannot be recovered.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/actions/connector/:id',
    alias: 'get-actions-connector-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/actions/connector/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      config: z.object({}).partial().passthrough().optional(),
      connector_type_id: z.string(),
      id: z.string(),
      is_deprecated: z.boolean(),
      is_missing_secrets: z.boolean().optional(),
      is_preconfigured: z.boolean(),
      is_system_action: z.boolean(),
      name: z.string(),
    }),
  },
  {
    method: 'post',
    path: '/api/actions/connector/:id',
    alias: 'post-actions-connector-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/actions/connector/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_actions_connector_id_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      config: z.object({}).partial().passthrough().optional(),
      connector_type_id: z.string(),
      id: z.string(),
      is_deprecated: z.boolean(),
      is_missing_secrets: z.boolean().optional(),
      is_preconfigured: z.boolean(),
      is_system_action: z.boolean(),
      name: z.string(),
    }),
  },
  {
    method: 'put',
    path: '/api/actions/connector/:id',
    alias: 'put-actions-connector-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/actions/connector/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_actions_connector_id_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      config: z.object({}).partial().passthrough().optional(),
      connector_type_id: z.string(),
      id: z.string(),
      is_deprecated: z.boolean(),
      is_missing_secrets: z.boolean().optional(),
      is_preconfigured: z.boolean(),
      is_system_action: z.boolean(),
      name: z.string(),
    }),
  },
  {
    method: 'post',
    path: '/api/actions/connector/:id/_execute',
    alias: 'post-actions-connector-id-execute',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/actions/connector/{id}/_execute&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You can use this API to test an action that involves interaction with Kibana services or integrations with third-party systems.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_actions_connector_id_execute_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      config: z.object({}).partial().passthrough().optional(),
      connector_type_id: z.string(),
      id: z.string(),
      is_deprecated: z.boolean(),
      is_missing_secrets: z.boolean().optional(),
      is_preconfigured: z.boolean(),
      is_system_action: z.boolean(),
      name: z.string(),
    }),
  },
  {
    method: 'get',
    path: '/api/actions/connectors',
    alias: 'get-actions-connectors',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/actions/connectors&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/alerting/_health',
    alias: 'getAlertingHealth',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/_health&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;read&#x60; privileges for the **Management &gt; Stack Rules** feature or for at least one of the **Analytics &gt; Discover**, **Analytics &gt; Machine Learning**, **Observability**, or **Security** features.
`,
    requestFormat: 'json',
    response: z
      .object({
        alerting_framework_health: z
          .object({
            decryption_health: z
              .object({
                status: z.enum(['error', 'ok', 'warn']),
                timestamp: z.string().datetime({ offset: true }),
              })
              .partial()
              .passthrough(),
            execution_health: z
              .object({
                status: z.enum(['error', 'ok', 'warn']),
                timestamp: z.string().datetime({ offset: true }),
              })
              .partial()
              .passthrough(),
            read_health: z
              .object({
                status: z.enum(['error', 'ok', 'warn']),
                timestamp: z.string().datetime({ offset: true }),
              })
              .partial()
              .passthrough(),
          })
          .partial()
          .passthrough(),
        has_permanent_encryption_key: z.boolean(),
        is_sufficiently_secure: z.boolean(),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Alerting_401_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/alerting/rule_types',
    alias: 'getRuleTypes',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule_types&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

If you have &#x60;read&#x60; privileges for one or more Kibana features, the API response contains information about the appropriate rule types. For example, there are rule types associated with the **Management &gt; Stack Rules** feature, **Analytics &gt; Discover** and **Machine Learning** features, **Observability** features, and **Security** features. To get rule types associated with the **Stack Monitoring** feature, use the &#x60;monitoring_user&#x60; built-in role.
`,
    requestFormat: 'json',
    response: z.array(
      z
        .object({
          action_groups: z.array(
            z.object({ id: z.string(), name: z.string() }).partial().passthrough()
          ),
          action_variables: z
            .object({
              context: z.array(
                z
                  .object({
                    description: z.string(),
                    name: z.string(),
                    useWithTripleBracesInTemplates: z.boolean(),
                  })
                  .partial()
                  .passthrough()
              ),
              params: z.array(
                z.object({ description: z.string(), name: z.string() }).partial().passthrough()
              ),
              state: z.array(
                z.object({ description: z.string(), name: z.string() }).partial().passthrough()
              ),
            })
            .partial()
            .passthrough(),
          alerts: z
            .object({
              context: z.enum([
                'ml.anomaly-detection',
                'observability.apm',
                'observability.logs',
                'observability.metrics',
                'observability.slo',
                'observability.threshold',
                'observability.uptime',
                'security',
                'stack',
              ]),
              dynamic: z.enum(['false', 'runtime', 'strict', 'true']),
              isSpaceAware: z.boolean(),
              mappings: z
                .object({ fieldMap: z.record(Alerting_fieldmap_properties) })
                .partial()
                .passthrough(),
              secondaryAlias: z.string(),
              shouldWrite: z.boolean(),
              useEcs: z.boolean(),
              useLegacyAlerts: z.boolean().default(false),
            })
            .partial()
            .passthrough(),
          authorized_consumers: z
            .object({
              alerts: z.object({ all: z.boolean(), read: z.boolean() }).partial().passthrough(),
              apm: z.object({ all: z.boolean(), read: z.boolean() }).partial().passthrough(),
              discover: z.object({ all: z.boolean(), read: z.boolean() }).partial().passthrough(),
              infrastructure: z
                .object({ all: z.boolean(), read: z.boolean() })
                .partial()
                .passthrough(),
              logs: z.object({ all: z.boolean(), read: z.boolean() }).partial().passthrough(),
              ml: z.object({ all: z.boolean(), read: z.boolean() }).partial().passthrough(),
              monitoring: z.object({ all: z.boolean(), read: z.boolean() }).partial().passthrough(),
              siem: z.object({ all: z.boolean(), read: z.boolean() }).partial().passthrough(),
              slo: z.object({ all: z.boolean(), read: z.boolean() }).partial().passthrough(),
              stackAlerts: z
                .object({ all: z.boolean(), read: z.boolean() })
                .partial()
                .passthrough(),
              uptime: z.object({ all: z.boolean(), read: z.boolean() }).partial().passthrough(),
            })
            .partial()
            .passthrough(),
          category: z.enum(['management', 'observability', 'securitySolution']),
          default_action_group_id: z.string(),
          does_set_recovery_context: z.boolean(),
          enabled_in_license: z.boolean(),
          has_alerts_mappings: z.boolean(),
          has_fields_for_a_a_d: z.boolean(),
          id: z.string(),
          is_exportable: z.boolean(),
          minimum_license_required: z.string(),
          name: z.string(),
          producer: z.string(),
          recovery_action_group: z
            .object({ id: z.string(), name: z.string() })
            .partial()
            .passthrough(),
          rule_task_timeout: z.string(),
        })
        .partial()
        .passthrough()
    ),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Alerting_401_response,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/alerting/rule/:id',
    alias: 'delete-alerting-rule-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/alerting/rule/:id',
    alias: 'get-alerting-rule-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      actions: z.array(
        z.object({
          alerts_filter: z
            .object({
              query: z.object({
                dsl: z.string().optional(),
                filters: z.array(
                  z.object({
                    $state: z.object({ store: z.enum(['appState', 'globalState']) }).optional(),
                    meta: z.object({}).partial().passthrough(),
                    query: z.object({}).partial().passthrough().optional(),
                  })
                ),
                kql: z.string(),
              }),
              timeframe: z.object({
                days: z.array(
                  z.union([
                    z.literal(1),
                    z.literal(2),
                    z.literal(3),
                    z.literal(4),
                    z.literal(5),
                    z.literal(6),
                    z.literal(7),
                  ])
                ),
                hours: z.object({ end: z.string(), start: z.string() }),
                timezone: z.string(),
              }),
            })
            .partial()
            .optional(),
          connector_type_id: z.string(),
          frequency: z
            .object({
              notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']),
              summary: z.boolean(),
              throttle: z.string().nullable(),
            })
            .optional(),
          group: z.string().optional(),
          id: z.string(),
          params: z.object({}).partial().passthrough(),
          use_alert_data_for_template: z.boolean().optional(),
          uuid: z.string().optional(),
        })
      ),
      active_snoozes: z.array(z.string()).optional(),
      alert_delay: z.object({ active: z.number() }).optional(),
      api_key_created_by_user: z.boolean().nullish(),
      api_key_owner: z.string().nullable(),
      artifacts: z
        .object({
          dashboards: z.array(z.object({ id: z.string() })),
          investigation_guide: z.object({ blob: z.string() }),
        })
        .partial()
        .optional(),
      consumer: z.string(),
      created_at: z.string(),
      created_by: z.string().nullable(),
      enabled: z.boolean(),
      execution_status: z.object({
        error: z
          .object({
            message: z.string(),
            reason: z.enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
            ]),
          })
          .optional(),
        last_duration: z.number().optional(),
        last_execution_date: z.string(),
        status: z.enum(['ok', 'active', 'error', 'warning', 'pending', 'unknown']),
        warning: z
          .object({
            message: z.string(),
            reason: z.enum([
              'maxExecutableActions',
              'maxAlerts',
              'maxQueuedActions',
              'ruleExecution',
            ]),
          })
          .optional(),
      }),
      flapping: z
        .object({
          look_back_window: z.number().gte(2).lte(20),
          status_change_threshold: z.number().gte(2).lte(20),
        })
        .nullish(),
      id: z.string(),
      is_snoozed_until: z.string().nullish(),
      last_run: z
        .object({
          alerts_count: z
            .object({
              active: z.number().nullable(),
              ignored: z.number().nullable(),
              new: z.number().nullable(),
              recovered: z.number().nullable(),
            })
            .partial(),
          outcome: z.enum(['succeeded', 'warning', 'failed']),
          outcome_msg: z.array(z.string()).nullish(),
          outcome_order: z.number().optional(),
          warning: z
            .enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
              'maxExecutableActions',
              'maxAlerts',
              'maxQueuedActions',
              'ruleExecution',
            ])
            .nullish(),
        })
        .nullish(),
      mapped_params: z.object({}).partial().passthrough().optional(),
      monitoring: z
        .object({
          run: z.object({
            calculated_metrics: z.object({
              p50: z.number().optional(),
              p95: z.number().optional(),
              p99: z.number().optional(),
              success_ratio: z.number(),
            }),
            history: z.array(
              z.object({
                duration: z.number().optional(),
                outcome: z.enum(['succeeded', 'warning', 'failed']).optional(),
                success: z.boolean(),
                timestamp: z.number(),
              })
            ),
            last_run: z.object({
              metrics: z
                .object({
                  duration: z.number(),
                  gap_duration_s: z.number().nullable(),
                  gap_range: z.object({ gte: z.string(), lte: z.string() }).nullable(),
                  total_alerts_created: z.number().nullable(),
                  total_alerts_detected: z.number().nullable(),
                  total_indexing_duration_ms: z.number().nullable(),
                  total_search_duration_ms: z.number().nullable(),
                })
                .partial(),
              timestamp: z.string(),
            }),
          }),
        })
        .optional(),
      mute_all: z.boolean(),
      muted_alert_ids: z.array(z.string()),
      name: z.string(),
      next_run: z.string().nullish(),
      notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']).nullish(),
      params: z.object({}).partial().passthrough(),
      revision: z.number(),
      rule_type_id: z.string(),
      running: z.boolean().nullish(),
      schedule: z.object({ interval: z.string() }),
      scheduled_task_id: z.string().optional(),
      snooze_schedule: z
        .array(
          z.object({
            duration: z.number(),
            id: z.string().optional(),
            rRule: z.object({
              byhour: z.array(z.number()).nullish(),
              byminute: z.array(z.number()).nullish(),
              bymonth: z.array(z.number()).nullish(),
              bymonthday: z.array(z.number()).nullish(),
              bysecond: z.array(z.number()).nullish(),
              bysetpos: z.array(z.number()).nullish(),
              byweekday: z.array(z.union([z.string(), z.number()])).nullish(),
              byweekno: z.array(z.number()).nullish(),
              byyearday: z.array(z.number()).nullish(),
              count: z.number().optional(),
              dtstart: z.string(),
              freq: z
                .union([
                  z.literal(0),
                  z.literal(1),
                  z.literal(2),
                  z.literal(3),
                  z.literal(4),
                  z.literal(5),
                  z.literal(6),
                ])
                .optional(),
              interval: z.number().optional(),
              tzid: z.string(),
              until: z.string().optional(),
              wkst: z.enum(['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU']).optional(),
            }),
            skipRecurrences: z.array(z.string()).optional(),
          })
        )
        .optional(),
      tags: z.array(z.string()),
      throttle: z.string().nullish(),
      updated_at: z.string(),
      updated_by: z.string().nullable(),
      view_in_app_relative_url: z.string().nullish(),
    }),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/alerting/rule/:id',
    alias: 'post-alerting-rule-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_alerting_rule_id_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      actions: z.array(
        z.object({
          alerts_filter: z
            .object({
              query: z.object({
                dsl: z.string().optional(),
                filters: z.array(
                  z.object({
                    $state: z.object({ store: z.enum(['appState', 'globalState']) }).optional(),
                    meta: z.object({}).partial().passthrough(),
                    query: z.object({}).partial().passthrough().optional(),
                  })
                ),
                kql: z.string(),
              }),
              timeframe: z.object({
                days: z.array(
                  z.union([
                    z.literal(1),
                    z.literal(2),
                    z.literal(3),
                    z.literal(4),
                    z.literal(5),
                    z.literal(6),
                    z.literal(7),
                  ])
                ),
                hours: z.object({ end: z.string(), start: z.string() }),
                timezone: z.string(),
              }),
            })
            .partial()
            .optional(),
          connector_type_id: z.string(),
          frequency: z
            .object({
              notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']),
              summary: z.boolean(),
              throttle: z.string().nullable(),
            })
            .optional(),
          group: z.string().optional(),
          id: z.string(),
          params: z.object({}).partial().passthrough(),
          use_alert_data_for_template: z.boolean().optional(),
          uuid: z.string().optional(),
        })
      ),
      active_snoozes: z.array(z.string()).optional(),
      alert_delay: z.object({ active: z.number() }).optional(),
      api_key_created_by_user: z.boolean().nullish(),
      api_key_owner: z.string().nullable(),
      artifacts: z
        .object({
          dashboards: z.array(z.object({ id: z.string() })),
          investigation_guide: z.object({ blob: z.string() }),
        })
        .partial()
        .optional(),
      consumer: z.string(),
      created_at: z.string(),
      created_by: z.string().nullable(),
      enabled: z.boolean(),
      execution_status: z.object({
        error: z
          .object({
            message: z.string(),
            reason: z.enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
            ]),
          })
          .optional(),
        last_duration: z.number().optional(),
        last_execution_date: z.string(),
        status: z.enum(['ok', 'active', 'error', 'warning', 'pending', 'unknown']),
        warning: z
          .object({
            message: z.string(),
            reason: z.enum([
              'maxExecutableActions',
              'maxAlerts',
              'maxQueuedActions',
              'ruleExecution',
            ]),
          })
          .optional(),
      }),
      flapping: z
        .object({
          look_back_window: z.number().gte(2).lte(20),
          status_change_threshold: z.number().gte(2).lte(20),
        })
        .nullish(),
      id: z.string(),
      is_snoozed_until: z.string().nullish(),
      last_run: z
        .object({
          alerts_count: z
            .object({
              active: z.number().nullable(),
              ignored: z.number().nullable(),
              new: z.number().nullable(),
              recovered: z.number().nullable(),
            })
            .partial(),
          outcome: z.enum(['succeeded', 'warning', 'failed']),
          outcome_msg: z.array(z.string()).nullish(),
          outcome_order: z.number().optional(),
          warning: z
            .enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
              'maxExecutableActions',
              'maxAlerts',
              'maxQueuedActions',
              'ruleExecution',
            ])
            .nullish(),
        })
        .nullish(),
      mapped_params: z.object({}).partial().passthrough().optional(),
      monitoring: z
        .object({
          run: z.object({
            calculated_metrics: z.object({
              p50: z.number().optional(),
              p95: z.number().optional(),
              p99: z.number().optional(),
              success_ratio: z.number(),
            }),
            history: z.array(
              z.object({
                duration: z.number().optional(),
                outcome: z.enum(['succeeded', 'warning', 'failed']).optional(),
                success: z.boolean(),
                timestamp: z.number(),
              })
            ),
            last_run: z.object({
              metrics: z
                .object({
                  duration: z.number(),
                  gap_duration_s: z.number().nullable(),
                  gap_range: z.object({ gte: z.string(), lte: z.string() }).nullable(),
                  total_alerts_created: z.number().nullable(),
                  total_alerts_detected: z.number().nullable(),
                  total_indexing_duration_ms: z.number().nullable(),
                  total_search_duration_ms: z.number().nullable(),
                })
                .partial(),
              timestamp: z.string(),
            }),
          }),
        })
        .optional(),
      mute_all: z.boolean(),
      muted_alert_ids: z.array(z.string()),
      name: z.string(),
      next_run: z.string().nullish(),
      notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']).nullish(),
      params: z.object({}).partial().passthrough(),
      revision: z.number(),
      rule_type_id: z.string(),
      running: z.boolean().nullish(),
      schedule: z.object({ interval: z.string() }),
      scheduled_task_id: z.string().optional(),
      snooze_schedule: z
        .array(
          z.object({
            duration: z.number(),
            id: z.string().optional(),
            rRule: z.object({
              byhour: z.array(z.number()).nullish(),
              byminute: z.array(z.number()).nullish(),
              bymonth: z.array(z.number()).nullish(),
              bymonthday: z.array(z.number()).nullish(),
              bysecond: z.array(z.number()).nullish(),
              bysetpos: z.array(z.number()).nullish(),
              byweekday: z.array(z.union([z.string(), z.number()])).nullish(),
              byweekno: z.array(z.number()).nullish(),
              byyearday: z.array(z.number()).nullish(),
              count: z.number().optional(),
              dtstart: z.string(),
              freq: z
                .union([
                  z.literal(0),
                  z.literal(1),
                  z.literal(2),
                  z.literal(3),
                  z.literal(4),
                  z.literal(5),
                  z.literal(6),
                ])
                .optional(),
              interval: z.number().optional(),
              tzid: z.string(),
              until: z.string().optional(),
              wkst: z.enum(['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU']).optional(),
            }),
            skipRecurrences: z.array(z.string()).optional(),
          })
        )
        .optional(),
      tags: z.array(z.string()),
      throttle: z.string().nullish(),
      updated_at: z.string(),
      updated_by: z.string().nullable(),
      view_in_app_relative_url: z.string().nullish(),
    }),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 409,
        description: `Indicates that the rule id is already in use.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/alerting/rule/:id',
    alias: 'put-alerting-rule-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_alerting_rule_id_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      actions: z.array(
        z.object({
          alerts_filter: z
            .object({
              query: z.object({
                dsl: z.string().optional(),
                filters: z.array(
                  z.object({
                    $state: z.object({ store: z.enum(['appState', 'globalState']) }).optional(),
                    meta: z.object({}).partial().passthrough(),
                    query: z.object({}).partial().passthrough().optional(),
                  })
                ),
                kql: z.string(),
              }),
              timeframe: z.object({
                days: z.array(
                  z.union([
                    z.literal(1),
                    z.literal(2),
                    z.literal(3),
                    z.literal(4),
                    z.literal(5),
                    z.literal(6),
                    z.literal(7),
                  ])
                ),
                hours: z.object({ end: z.string(), start: z.string() }),
                timezone: z.string(),
              }),
            })
            .partial()
            .optional(),
          connector_type_id: z.string(),
          frequency: z
            .object({
              notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']),
              summary: z.boolean(),
              throttle: z.string().nullable(),
            })
            .optional(),
          group: z.string().optional(),
          id: z.string(),
          params: z.object({}).partial().passthrough(),
          use_alert_data_for_template: z.boolean().optional(),
          uuid: z.string().optional(),
        })
      ),
      active_snoozes: z.array(z.string()).optional(),
      alert_delay: z.object({ active: z.number() }).optional(),
      api_key_created_by_user: z.boolean().nullish(),
      api_key_owner: z.string().nullable(),
      artifacts: z
        .object({
          dashboards: z.array(z.object({ id: z.string() })),
          investigation_guide: z.object({ blob: z.string() }),
        })
        .partial()
        .optional(),
      consumer: z.string(),
      created_at: z.string(),
      created_by: z.string().nullable(),
      enabled: z.boolean(),
      execution_status: z.object({
        error: z
          .object({
            message: z.string(),
            reason: z.enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
            ]),
          })
          .optional(),
        last_duration: z.number().optional(),
        last_execution_date: z.string(),
        status: z.enum(['ok', 'active', 'error', 'warning', 'pending', 'unknown']),
        warning: z
          .object({
            message: z.string(),
            reason: z.enum([
              'maxExecutableActions',
              'maxAlerts',
              'maxQueuedActions',
              'ruleExecution',
            ]),
          })
          .optional(),
      }),
      flapping: z
        .object({
          look_back_window: z.number().gte(2).lte(20),
          status_change_threshold: z.number().gte(2).lte(20),
        })
        .nullish(),
      id: z.string(),
      is_snoozed_until: z.string().nullish(),
      last_run: z
        .object({
          alerts_count: z
            .object({
              active: z.number().nullable(),
              ignored: z.number().nullable(),
              new: z.number().nullable(),
              recovered: z.number().nullable(),
            })
            .partial(),
          outcome: z.enum(['succeeded', 'warning', 'failed']),
          outcome_msg: z.array(z.string()).nullish(),
          outcome_order: z.number().optional(),
          warning: z
            .enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
              'maxExecutableActions',
              'maxAlerts',
              'maxQueuedActions',
              'ruleExecution',
            ])
            .nullish(),
        })
        .nullish(),
      mapped_params: z.object({}).partial().passthrough().optional(),
      monitoring: z
        .object({
          run: z.object({
            calculated_metrics: z.object({
              p50: z.number().optional(),
              p95: z.number().optional(),
              p99: z.number().optional(),
              success_ratio: z.number(),
            }),
            history: z.array(
              z.object({
                duration: z.number().optional(),
                outcome: z.enum(['succeeded', 'warning', 'failed']).optional(),
                success: z.boolean(),
                timestamp: z.number(),
              })
            ),
            last_run: z.object({
              metrics: z
                .object({
                  duration: z.number(),
                  gap_duration_s: z.number().nullable(),
                  gap_range: z.object({ gte: z.string(), lte: z.string() }).nullable(),
                  total_alerts_created: z.number().nullable(),
                  total_alerts_detected: z.number().nullable(),
                  total_indexing_duration_ms: z.number().nullable(),
                  total_search_duration_ms: z.number().nullable(),
                })
                .partial(),
              timestamp: z.string(),
            }),
          }),
        })
        .optional(),
      mute_all: z.boolean(),
      muted_alert_ids: z.array(z.string()),
      name: z.string(),
      next_run: z.string().nullish(),
      notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']).nullish(),
      params: z.object({}).partial().passthrough(),
      revision: z.number(),
      rule_type_id: z.string(),
      running: z.boolean().nullish(),
      schedule: z.object({ interval: z.string() }),
      scheduled_task_id: z.string().optional(),
      snooze_schedule: z
        .array(
          z.object({
            duration: z.number(),
            id: z.string().optional(),
            rRule: z.object({
              byhour: z.array(z.number()).nullish(),
              byminute: z.array(z.number()).nullish(),
              bymonth: z.array(z.number()).nullish(),
              bymonthday: z.array(z.number()).nullish(),
              bysecond: z.array(z.number()).nullish(),
              bysetpos: z.array(z.number()).nullish(),
              byweekday: z.array(z.union([z.string(), z.number()])).nullish(),
              byweekno: z.array(z.number()).nullish(),
              byyearday: z.array(z.number()).nullish(),
              count: z.number().optional(),
              dtstart: z.string(),
              freq: z
                .union([
                  z.literal(0),
                  z.literal(1),
                  z.literal(2),
                  z.literal(3),
                  z.literal(4),
                  z.literal(5),
                  z.literal(6),
                ])
                .optional(),
              interval: z.number().optional(),
              tzid: z.string(),
              until: z.string().optional(),
              wkst: z.enum(['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU']).optional(),
            }),
            skipRecurrences: z.array(z.string()).optional(),
          })
        )
        .optional(),
      tags: z.array(z.string()),
      throttle: z.string().nullish(),
      updated_at: z.string(),
      updated_by: z.string().nullable(),
      view_in_app_relative_url: z.string().nullish(),
    }),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule with the given ID does not exist.`,
        schema: z.void(),
      },
      {
        status: 409,
        description: `Indicates that the rule has already been updated by another user.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/alerting/rule/:id/_disable',
    alias: 'post-alerting-rule-id-disable',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{id}/_disable&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ untrack: z.boolean() }).partial().nullable(),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/alerting/rule/:id/_enable',
    alias: 'post-alerting-rule-id-enable',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{id}/_enable&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/alerting/rule/:id/_mute_all',
    alias: 'post-alerting-rule-id-mute-all',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{id}/_mute_all&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/alerting/rule/:id/_unmute_all',
    alias: 'post-alerting-rule-id-unmute-all',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{id}/_unmute_all&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/alerting/rule/:id/_update_api_key',
    alias: 'post-alerting-rule-id-update-api-key',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{id}/_update_api_key&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule with the given ID does not exist.`,
        schema: z.void(),
      },
      {
        status: 409,
        description: `Indicates that the rule has already been updated by another user.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/alerting/rule/:id/snooze_schedule',
    alias: 'post-alerting-rule-id-snooze-schedule',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{id}/snooze_schedule&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

When you snooze a rule, the rule checks continue to run but alerts will not generate actions. You can snooze for a specified period of time and schedule single or recurring downtimes.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_alerting_rule_id_snooze_schedule_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      body: z.object({
        schedule: z.object({
          custom: z
            .object({
              duration: z.string(),
              recurring: z
                .object({
                  end: z.string(),
                  every: z.string(),
                  occurrences: z.number().gte(1),
                  onMonth: z.array(z.number().gte(1).lte(12)).min(1),
                  onMonthDay: z.array(z.number().gte(1).lte(31)).min(1),
                  onWeekDay: z.array(z.string()).min(1),
                })
                .partial()
                .optional(),
              start: z.string(),
              timezone: z.string().optional(),
            })
            .optional(),
          id: z.string(),
        }),
      }),
    }),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule with the given id does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/alerting/rule/:rule_id/alert/:alert_id/_mute',
    alias: 'post-alerting-rule-rule-id-alert-alert-id-mute',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{rule_id}/alert/{alert_id}/_mute&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'rule_id',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'alert_id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule or alert with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/alerting/rule/:rule_id/alert/:alert_id/_unmute',
    alias: 'post-alerting-rule-rule-id-alert-alert-id-unmute',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{rule_id}/alert/{alert_id}/_unmute&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'rule_id',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'alert_id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule or alert with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/alerting/rule/:ruleId/snooze_schedule/:scheduleId',
    alias: 'delete-alerting-rule-ruleid-snooze-schedule-scheduleid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rule/{ruleId}/snooze_schedule/{scheduleId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'ruleId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'scheduleId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a rule with the given id does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/alerting/rules/_find',
    alias: 'get-alerting-rules-find',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/alerting/rules/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().gte(0).optional().default(10),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().gte(1).optional().default(1),
      },
      {
        name: 'search',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'default_search_operator',
        type: 'Query',
        schema: z.enum(['OR', 'AND']).optional().default('OR'),
      },
      {
        name: 'search_fields',
        type: 'Query',
        schema: search_fields,
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'has_reference',
        type: 'Query',
        schema: has_reference,
      },
      {
        name: 'fields',
        type: 'Query',
        schema: search_fields,
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'filter_consumers',
        type: 'Query',
        schema: z.array(z.string()).optional(),
      },
    ],
    response: z.object({
      actions: z.array(
        z.object({
          alerts_filter: z
            .object({
              query: z.object({
                dsl: z.string().optional(),
                filters: z.array(
                  z.object({
                    $state: z.object({ store: z.enum(['appState', 'globalState']) }).optional(),
                    meta: z.object({}).partial().passthrough(),
                    query: z.object({}).partial().passthrough().optional(),
                  })
                ),
                kql: z.string(),
              }),
              timeframe: z.object({
                days: z.array(
                  z.union([
                    z.literal(1),
                    z.literal(2),
                    z.literal(3),
                    z.literal(4),
                    z.literal(5),
                    z.literal(6),
                    z.literal(7),
                  ])
                ),
                hours: z.object({ end: z.string(), start: z.string() }),
                timezone: z.string(),
              }),
            })
            .partial()
            .optional(),
          connector_type_id: z.string(),
          frequency: z
            .object({
              notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']),
              summary: z.boolean(),
              throttle: z.string().nullable(),
            })
            .optional(),
          group: z.string().optional(),
          id: z.string(),
          params: z.object({}).partial().passthrough(),
          use_alert_data_for_template: z.boolean().optional(),
          uuid: z.string().optional(),
        })
      ),
      active_snoozes: z.array(z.string()).optional(),
      alert_delay: z.object({ active: z.number() }).optional(),
      api_key_created_by_user: z.boolean().nullish(),
      api_key_owner: z.string().nullable(),
      artifacts: z
        .object({
          dashboards: z.array(z.object({ id: z.string() })),
          investigation_guide: z.object({ blob: z.string() }),
        })
        .partial()
        .optional(),
      consumer: z.string(),
      created_at: z.string(),
      created_by: z.string().nullable(),
      enabled: z.boolean(),
      execution_status: z.object({
        error: z
          .object({
            message: z.string(),
            reason: z.enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
            ]),
          })
          .optional(),
        last_duration: z.number().optional(),
        last_execution_date: z.string(),
        status: z.enum(['ok', 'active', 'error', 'warning', 'pending', 'unknown']),
        warning: z
          .object({
            message: z.string(),
            reason: z.enum([
              'maxExecutableActions',
              'maxAlerts',
              'maxQueuedActions',
              'ruleExecution',
            ]),
          })
          .optional(),
      }),
      flapping: z
        .object({
          look_back_window: z.number().gte(2).lte(20),
          status_change_threshold: z.number().gte(2).lte(20),
        })
        .nullish(),
      id: z.string(),
      is_snoozed_until: z.string().nullish(),
      last_run: z
        .object({
          alerts_count: z
            .object({
              active: z.number().nullable(),
              ignored: z.number().nullable(),
              new: z.number().nullable(),
              recovered: z.number().nullable(),
            })
            .partial(),
          outcome: z.enum(['succeeded', 'warning', 'failed']),
          outcome_msg: z.array(z.string()).nullish(),
          outcome_order: z.number().optional(),
          warning: z
            .enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
              'maxExecutableActions',
              'maxAlerts',
              'maxQueuedActions',
              'ruleExecution',
            ])
            .nullish(),
        })
        .nullish(),
      mapped_params: z.object({}).partial().passthrough().optional(),
      monitoring: z
        .object({
          run: z.object({
            calculated_metrics: z.object({
              p50: z.number().optional(),
              p95: z.number().optional(),
              p99: z.number().optional(),
              success_ratio: z.number(),
            }),
            history: z.array(
              z.object({
                duration: z.number().optional(),
                outcome: z.enum(['succeeded', 'warning', 'failed']).optional(),
                success: z.boolean(),
                timestamp: z.number(),
              })
            ),
            last_run: z.object({
              metrics: z
                .object({
                  duration: z.number(),
                  gap_duration_s: z.number().nullable(),
                  gap_range: z.object({ gte: z.string(), lte: z.string() }).nullable(),
                  total_alerts_created: z.number().nullable(),
                  total_alerts_detected: z.number().nullable(),
                  total_indexing_duration_ms: z.number().nullable(),
                  total_search_duration_ms: z.number().nullable(),
                })
                .partial(),
              timestamp: z.string(),
            }),
          }),
        })
        .optional(),
      mute_all: z.boolean(),
      muted_alert_ids: z.array(z.string()),
      name: z.string(),
      next_run: z.string().nullish(),
      notify_when: z.enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval']).nullish(),
      params: z.object({}).partial().passthrough(),
      revision: z.number(),
      rule_type_id: z.string(),
      running: z.boolean().nullish(),
      schedule: z.object({ interval: z.string() }),
      scheduled_task_id: z.string().optional(),
      snooze_schedule: z
        .array(
          z.object({
            duration: z.number(),
            id: z.string().optional(),
            rRule: z.object({
              byhour: z.array(z.number()).nullish(),
              byminute: z.array(z.number()).nullish(),
              bymonth: z.array(z.number()).nullish(),
              bymonthday: z.array(z.number()).nullish(),
              bysecond: z.array(z.number()).nullish(),
              bysetpos: z.array(z.number()).nullish(),
              byweekday: z.array(z.union([z.string(), z.number()])).nullish(),
              byweekno: z.array(z.number()).nullish(),
              byyearday: z.array(z.number()).nullish(),
              count: z.number().optional(),
              dtstart: z.string(),
              freq: z
                .union([
                  z.literal(0),
                  z.literal(1),
                  z.literal(2),
                  z.literal(3),
                  z.literal(4),
                  z.literal(5),
                  z.literal(6),
                ])
                .optional(),
              interval: z.number().optional(),
              tzid: z.string(),
              until: z.string().optional(),
              wkst: z.enum(['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU']).optional(),
            }),
            skipRecurrences: z.array(z.string()).optional(),
          })
        )
        .optional(),
      tags: z.array(z.string()),
      throttle: z.string().nullish(),
      updated_at: z.string(),
      updated_by: z.string().nullable(),
      view_in_app_relative_url: z.string().nullish(),
    }),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/apm/agent_keys',
    alias: 'createAgentKey',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/agent_keys&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a new agent key for APM.
The user creating an APM agent API key must have at least the &#x60;manage_own_api_key&#x60; cluster privilege and the APM application-level privileges that it wishes to grant.
After it is created, you can copy the API key (Base64 encoded) and use it to to authorize requests from APM agents to the APM Server.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: APM_UI_agent_keys_object,
      },
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: APM_UI_agent_keys_response,
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 403,
        description: `Forbidden response`,
        schema: APM_UI_403_response,
      },
      {
        status: 500,
        description: `Internal Server Error response`,
        schema: APM_UI_500_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/apm/fleet/apm_server_schema',
    alias: 'saveApmServerSchema',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/fleet/apm_server_schema&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z
          .object({ schema: z.object({}).partial().passthrough() })
          .partial()
          .passthrough(),
      },
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial(),
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 403,
        description: `Forbidden response`,
        schema: APM_UI_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: APM_UI_404_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/apm/services/:serviceName/annotation',
    alias: 'createAnnotation',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/services/{serviceName}/annotation&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a new annotation for a specific service.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: APM_UI_create_annotation_object,
      },
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'serviceName',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: APM_UI_create_annotation_response,
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 403,
        description: `Forbidden response`,
        schema: APM_UI_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: APM_UI_404_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/apm/services/:serviceName/annotation/search',
    alias: 'getAnnotation',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/services/{serviceName}/annotation/search&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Search for annotations related to a specific service.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'serviceName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'environment',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'start',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'end',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: APM_UI_annotation_search_response,
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 500,
        description: `Internal Server Error response`,
        schema: APM_UI_500_response,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/apm/settings/agent-configuration',
    alias: 'deleteAgentConfiguration',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/settings/agent-configuration&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: APM_UI_delete_service_object,
      },
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ result: z.string() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 403,
        description: `Forbidden response`,
        schema: APM_UI_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: APM_UI_404_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/apm/settings/agent-configuration',
    alias: 'getAgentConfigurations',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/settings/agent-configuration&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
    ],
    response: APM_UI_agent_configurations_response,
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: APM_UI_404_response,
      },
    ],
  },
  {
    method: 'put',
    path: '/api/apm/settings/agent-configuration',
    alias: 'createUpdateAgentConfiguration',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/settings/agent-configuration&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: APM_UI_agent_configuration_intake_object,
      },
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'overwrite',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({}).partial(),
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 403,
        description: `Forbidden response`,
        schema: APM_UI_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: APM_UI_404_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/apm/settings/agent-configuration/agent_name',
    alias: 'getAgentNameForService',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/settings/agent-configuration/agent_name&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Retrieve &#x60;agentName&#x60; for a service.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'serviceName',
        type: 'Query',
        schema: z.string(),
      },
    ],
    response: z.object({ agentName: z.string() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: APM_UI_404_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/apm/settings/agent-configuration/environments',
    alias: 'getEnvironmentsForService',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/settings/agent-configuration/environments&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'serviceName',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: APM_UI_service_environments_response,
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: APM_UI_404_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/apm/settings/agent-configuration/search',
    alias: 'searchSingleConfiguration',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/settings/agent-configuration/search&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

This endpoint enables you to search for a single agent configuration and update the &#x27;applied_by_agent&#x27; field.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: APM_UI_search_agent_configuration_object,
      },
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: APM_UI_search_agent_configuration_response,
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: APM_UI_404_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/apm/settings/agent-configuration/view',
    alias: 'getSingleAgentConfiguration',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/settings/agent-configuration/view&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'name',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'environment',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: APM_UI_single_agent_configuration_response,
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: APM_UI_404_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/apm/sourcemaps',
    alias: 'getSourceMaps',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/sourcemaps&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get an array of Fleet artifacts, including source map uploads. You must have &#x60;read&#x60; or &#x60;all&#x60; Kibana privileges for the APM and User Experience feature.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().optional(),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().optional(),
      },
    ],
    response: APM_UI_source_maps_response,
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 500,
        description: `Internal Server Error response`,
        schema: APM_UI_500_response,
      },
      {
        status: 501,
        description: `Not Implemented response`,
        schema: APM_UI_501_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/apm/sourcemaps',
    alias: 'uploadSourceMap',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/sourcemaps&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Upload a source map for a specific service and version. You must have &#x60;all&#x60; Kibana privileges for the APM and User Experience feature.
The maximum payload size is &#x60;1mb&#x60;. If you attempt to upload a source map that exceeds the maximum payload size, you will get a 413 error. Before uploading source maps that exceed this default, change the maximum payload size allowed by Kibana with the &#x60;server.maxPayload&#x60; variable.
`,
    requestFormat: 'form-data',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: APM_UI_upload_source_map_object,
      },
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: APM_UI_upload_source_maps_response,
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 403,
        description: `Forbidden response`,
        schema: APM_UI_403_response,
      },
      {
        status: 500,
        description: `Internal Server Error response`,
        schema: APM_UI_500_response,
      },
      {
        status: 501,
        description: `Not Implemented response`,
        schema: APM_UI_501_response,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/apm/sourcemaps/:id',
    alias: 'deleteSourceMap',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/apm/sourcemaps/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a previously uploaded source map. You must have &#x60;all&#x60; Kibana privileges for the APM and User Experience feature.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'elastic-api-version',
        type: 'Header',
        schema: z.literal('2023-10-31').default('2023-10-31'),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial(),
    errors: [
      {
        status: 400,
        description: `Bad Request response`,
        schema: APM_UI_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: APM_UI_401_response,
      },
      {
        status: 403,
        description: `Forbidden response`,
        schema: APM_UI_403_response,
      },
      {
        status: 500,
        description: `Internal Server Error response`,
        schema: APM_UI_500_response,
      },
      {
        status: 501,
        description: `Not Implemented response`,
        schema: APM_UI_501_response,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/asset_criticality',
    alias: 'DeleteAssetCriticalityRecord',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/asset_criticality&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete the asset criticality record for a specific entity.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id_value',
        type: 'Query',
        schema: z.string(),
      },
      {
        name: 'id_field',
        type: 'Query',
        schema: z.enum(['host.name', 'user.name', 'service.name', 'entity.id']),
      },
      {
        name: 'refresh',
        type: 'Query',
        schema: z.literal('wait_for').optional(),
      },
    ],
    response: z
      .object({
        deleted: z.boolean(),
        record: Security_Entity_Analytics_API_AssetCriticalityRecord.optional(),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid request`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/asset_criticality',
    alias: 'GetAssetCriticalityRecord',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/asset_criticality&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the asset criticality record for a specific entity.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id_value',
        type: 'Query',
        schema: z.string(),
      },
      {
        name: 'id_field',
        type: 'Query',
        schema: z.enum(['host.name', 'user.name', 'service.name', 'entity.id']),
      },
    ],
    response: Security_Entity_Analytics_API_AssetCriticalityRecord,
    errors: [
      {
        status: 400,
        description: `Invalid request`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Criticality record not found`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/asset_criticality',
    alias: 'CreateAssetCriticalityRecord',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/asset_criticality&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create or update an asset criticality record for a specific entity.

If a record already exists for the specified entity, that record is overwritten with the specified value. If a record doesn&#x27;t exist for the specified entity, a new record is created.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: CreateAssetCriticalityRecord_Body,
      },
    ],
    response: Security_Entity_Analytics_API_AssetCriticalityRecord,
    errors: [
      {
        status: 400,
        description: `Invalid request`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/asset_criticality/bulk',
    alias: 'BulkUpsertAssetCriticalityRecords',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/asset_criticality/bulk&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Bulk upsert up to 1000 asset criticality records.

If asset criticality records already exist for the specified entities, those records are overwritten with the specified values. If asset criticality records don&#x27;t exist for the specified entities, new records are created.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: BulkUpsertAssetCriticalityRecords_Body,
      },
    ],
    response: z
      .object({
        errors: z.array(Security_Entity_Analytics_API_AssetCriticalityBulkUploadErrorItem),
        stats: Security_Entity_Analytics_API_AssetCriticalityBulkUploadStats,
      })
      .passthrough(),
    errors: [
      {
        status: 413,
        description: `File too large`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/asset_criticality/list',
    alias: 'FindAssetCriticalityRecords',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/asset_criticality/list&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

List asset criticality records, paging, sorting and filtering as needed.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.enum(['id_value', 'id_field', 'criticality_level', '@timestamp']).optional(),
      },
      {
        name: 'sort_direction',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(1).optional(),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().gte(1).lte(1000).optional(),
      },
      {
        name: 'kuery',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z
      .object({
        page: z.number().int().gte(1),
        per_page: z.number().int().gte(1).lte(1000),
        records: z.array(Security_Entity_Analytics_API_AssetCriticalityRecord),
        total: z.number().int().gte(0),
      })
      .passthrough(),
  },
  {
    method: 'delete',
    path: '/api/cases',
    alias: 'deleteCaseDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;read&#x60; or &#x60;all&#x60; privileges and the &#x60;delete&#x60; sub-feature privilege for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the cases you&#x27;re deleting.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'ids',
        type: 'Query',
        schema: z.array(z.string()),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'patch',
    path: '/api/cases',
    alias: 'updateCaseDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;all&#x60; privileges for the **Cases** feature in the  **Management**, **Observability**, or **Security** section of the Kibana  feature privileges, depending on the owner of the case you&#x27;re updating.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Cases_update_case_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.array(Cases_case_response_properties),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/cases',
    alias: 'createCaseDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;all&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana  feature privileges, depending on the owner of the case you&#x27;re creating.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Cases_create_case_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: Cases_case_response_properties,
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/_find',
    alias: 'findCasesDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;read&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the cases you&#x27;re seeking.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'assignees',
        type: 'Query',
        schema: assignees,
      },
      {
        name: 'category',
        type: 'Query',
        schema: category,
      },
      {
        name: 'defaultSearchOperator',
        type: 'Query',
        schema: z.string().optional().default('OR'),
      },
      {
        name: 'from',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'owner',
        type: 'Query',
        schema: owner,
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().optional().default(1),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().int().lte(100).optional().default(20),
      },
      {
        name: 'reporters',
        type: 'Query',
        schema: assignees,
      },
      {
        name: 'search',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'searchFields',
        type: 'Query',
        schema: searchFields,
      },
      {
        name: 'severity',
        type: 'Query',
        schema: z.enum(['critical', 'high', 'low', 'medium']).optional(),
      },
      {
        name: 'sortField',
        type: 'Query',
        schema: z
          .enum(['createdAt', 'updatedAt', 'closedAt', 'title', 'category', 'status', 'severity'])
          .optional()
          .default('createdAt'),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional().default('desc'),
      },
      {
        name: 'status',
        type: 'Query',
        schema: z.enum(['closed', 'in-progress', 'open']).optional(),
      },
      {
        name: 'tags',
        type: 'Query',
        schema: assignees,
      },
      {
        name: 'to',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z
      .object({
        cases: z.array(Cases_case_response_properties).max(10000),
        count_closed_cases: z.number().int(),
        count_in_progress_cases: z.number().int(),
        count_open_cases: z.number().int(),
        page: z.number().int(),
        per_page: z.number().int(),
        total: z.number().int(),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/:caseId',
    alias: 'getCaseDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;read&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the case you&#x27;re seeking.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: Cases_case_response_properties,
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/:caseId/alerts',
    alias: 'getCaseAlertsDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}/alerts&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;read&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the cases you&#x27;re seeking.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.array(Cases_alert_response_properties),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/cases/:caseId/comments',
    alias: 'deleteCaseCommentsDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}/comments&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Deletes all comments and alerts from a case. You must have &#x60;all&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the cases you&#x27;re deleting.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'patch',
    path: '/api/cases/:caseId/comments',
    alias: 'updateCaseCommentDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}/comments&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;all&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the case you&#x27;re updating. NOTE: You cannot change the comment type or the owner of a comment.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Cases_update_case_comment_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: Cases_case_response_properties,
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/cases/:caseId/comments',
    alias: 'addCaseCommentDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}/comments&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;all&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the case you&#x27;re creating. NOTE: Each case can have a maximum of 1,000 alerts.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Cases_add_case_comment_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: Cases_case_response_properties,
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/:caseId/comments/_find',
    alias: 'findCaseCommentsDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}/comments/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Retrieves a paginated list of comments for a case. You must have &#x60;read&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the cases with the comments you&#x27;re seeking.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().optional().default(1),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().int().lte(100).optional().default(20),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional().default('desc'),
      },
    ],
    response: Cases_case_response_properties,
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/cases/:caseId/comments/:commentId',
    alias: 'deleteCaseCommentDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}/comments/{commentId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;all&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the cases you&#x27;re deleting.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'commentId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/:caseId/comments/:commentId',
    alias: 'getCaseCommentDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}/comments/{commentId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;read&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the cases with the comments you&#x27;re seeking.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'commentId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.union([
      Cases_alert_comment_response_properties,
      Cases_user_comment_response_properties,
    ]),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/cases/:caseId/connector/:connectorId/_push',
    alias: 'pushCaseDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}/connector/{connectorId}/_push&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;all&#x60; privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges. You must also have &#x60;all&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the case you&#x27;re pushing.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({}).partial().passthrough().nullable(),
      },
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'connectorId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: Cases_case_response_properties,
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/cases/:caseId/files',
    alias: 'addCaseFileDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}/files&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Attach a file to a case. You must have &#x60;all&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the case you&#x27;re updating. The request must include:
- The &#x60;Content-Type: multipart/form-data&#x60; HTTP header.
- The location of the file that is being uploaded.
`,
    requestFormat: 'form-data',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Cases_add_case_file_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: Cases_case_response_properties,
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/:caseId/user_actions/_find',
    alias: 'findCaseActivityDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/{caseId}/user_actions/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Retrives a paginated list of user activity for a case. You must have &#x60;read&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the case you&#x27;re seeking.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'caseId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().optional().default(1),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().int().lte(100).optional().default(20),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional().default('desc'),
      },
      {
        name: 'types',
        type: 'Query',
        schema: z
          .array(
            z.enum([
              'action',
              'alert',
              'assignees',
              'attachment',
              'comment',
              'connector',
              'create_case',
              'description',
              'pushed',
              'settings',
              'severity',
              'status',
              'tags',
              'title',
              'user',
            ])
          )
          .optional(),
      },
    ],
    response: z
      .object({
        page: z.number().int(),
        perPage: z.number().int(),
        total: z.number().int(),
        userActions: z.array(Cases_user_actions_find_response_properties).max(10000),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/alerts/:alertId',
    alias: 'getCasesByAlertDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/alerts/{alertId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;read&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the cases you&#x27;re seeking.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'alertId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'owner',
        type: 'Query',
        schema: owner,
      },
    ],
    response: z
      .array(z.object({ id: z.string(), title: z.string() }).partial().passthrough())
      .max(10000),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/configure',
    alias: 'getCaseConfigurationDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/configure&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get setting details such as the closure type, custom fields, templatse, and the default connector for cases. You must have &#x60;read&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on where the cases were created.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'owner',
        type: 'Query',
        schema: owner,
      },
    ],
    response: z.array(
      z
        .object({
          closure_type: Cases_closure_types,
          connector: z
            .object({
              fields: z.object({}).partial().passthrough().nullable(),
              id: z.string(),
              name: z.string(),
              type: Cases_connector_types,
            })
            .partial()
            .passthrough(),
          created_at: z.string().datetime({ offset: true }),
          created_by: z
            .object({
              email: z.string().nullable(),
              full_name: z.string().nullable(),
              profile_uid: z.string().optional(),
              username: z.string().nullable(),
            })
            .passthrough(),
          customFields: z.array(
            z
              .object({
                defaultValue: z.union([z.string(), z.boolean()]),
                key: z.string().min(1).max(36),
                label: z.string().min(1).max(50),
                type: z.enum(['text', 'toggle']),
                required: z.boolean(),
              })
              .partial()
              .passthrough()
          ),
          error: z.string().nullable(),
          id: z.string(),
          mappings: z.array(
            z
              .object({ action_type: z.string(), source: z.string(), target: z.string() })
              .partial()
              .passthrough()
          ),
          owner: Cases_owner,
          templates: Cases_templates,
          updated_at: z.string().datetime({ offset: true }).nullable(),
          updated_by: z
            .object({
              email: z.string().nullable(),
              full_name: z.string().nullable(),
              profile_uid: z.string().optional(),
              username: z.string().nullable(),
            })
            .passthrough()
            .nullable(),
          version: z.string(),
        })
        .partial()
        .passthrough()
    ),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/cases/configure',
    alias: 'setCaseConfigurationDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/configure&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Case settings include external connection details, custom fields, and templates. Connectors are used to interface with external systems. You must create a connector before you can use it in your cases. If you set a default connector, it is automatically selected when you create cases in Kibana. If you use the create case API, however, you must still specify all of the connector details. You must have &#x60;all&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on where you are creating cases.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Cases_set_case_configuration_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z
      .object({
        closure_type: Cases_closure_types,
        connector: z
          .object({
            fields: z.object({}).partial().passthrough().nullable(),
            id: z.string(),
            name: z.string(),
            type: Cases_connector_types,
          })
          .partial()
          .passthrough(),
        created_at: z.string().datetime({ offset: true }),
        created_by: z
          .object({
            email: z.string().nullable(),
            full_name: z.string().nullable(),
            profile_uid: z.string().optional(),
            username: z.string().nullable(),
          })
          .passthrough(),
        customFields: z.array(
          z
            .object({
              defaultValue: z.union([z.string(), z.boolean()]),
              key: z.string().min(1).max(36),
              label: z.string().min(1).max(50),
              type: z.enum(['text', 'toggle']),
              required: z.boolean(),
            })
            .partial()
            .passthrough()
        ),
        error: z.string().nullable(),
        id: z.string(),
        mappings: z.array(
          z
            .object({ action_type: z.string(), source: z.string(), target: z.string() })
            .partial()
            .passthrough()
        ),
        owner: Cases_owner,
        templates: Cases_templates,
        updated_at: z.string().datetime({ offset: true }).nullable(),
        updated_by: z
          .object({
            email: z.string().nullable(),
            full_name: z.string().nullable(),
            profile_uid: z.string().optional(),
            username: z.string().nullable(),
          })
          .passthrough()
          .nullable(),
        version: z.string(),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'patch',
    path: '/api/cases/configure/:configurationId',
    alias: 'updateCaseConfigurationDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/configure/{configurationId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Updates setting details such as the closure type, custom fields, templates, and the default connector for cases. Connectors are used to interface with external systems. You must create a connector before you can use it in your cases. You must have &#x60;all&#x60; privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on where the case was created.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Cases_update_case_configuration_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'configurationId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z
      .object({
        closure_type: Cases_closure_types,
        connector: z
          .object({
            fields: z.object({}).partial().passthrough().nullable(),
            id: z.string(),
            name: z.string(),
            type: Cases_connector_types,
          })
          .partial()
          .passthrough(),
        created_at: z.string().datetime({ offset: true }),
        created_by: z
          .object({
            email: z.string().nullable(),
            full_name: z.string().nullable(),
            profile_uid: z.string().optional(),
            username: z.string().nullable(),
          })
          .passthrough(),
        customFields: z.array(
          z
            .object({
              defaultValue: z.union([z.string(), z.boolean()]),
              key: z.string().min(1).max(36),
              label: z.string().min(1).max(50),
              type: z.enum(['text', 'toggle']),
              required: z.boolean(),
            })
            .partial()
            .passthrough()
        ),
        error: z.string().nullable(),
        id: z.string(),
        mappings: z.array(
          z
            .object({ action_type: z.string(), source: z.string(), target: z.string() })
            .partial()
            .passthrough()
        ),
        owner: Cases_owner,
        templates: Cases_templates,
        updated_at: z.string().datetime({ offset: true }).nullable(),
        updated_by: z
          .object({
            email: z.string().nullable(),
            full_name: z.string().nullable(),
            profile_uid: z.string().optional(),
            username: z.string().nullable(),
          })
          .passthrough()
          .nullable(),
        version: z.string(),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/configure/connectors/_find',
    alias: 'findCaseConnectorsDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/configure/connectors/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get information about connectors that are supported for use in cases. You must have &#x60;read&#x60; privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    response: z
      .array(
        z
          .object({
            actionTypeId: Cases_connector_types,
            config: z
              .object({ apiUrl: z.string(), projectKey: z.string() })
              .partial()
              .passthrough(),
            id: z.string(),
            isDeprecated: z.boolean(),
            isMissingSecrets: z.boolean(),
            isPreconfigured: z.boolean(),
            name: z.string(),
            referencedByCount: z.number().int(),
          })
          .partial()
          .passthrough()
      )
      .max(1000),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/reporters',
    alias: 'getCaseReportersDefaultSpace',
    description: `Returns information about the users who opened cases. You must have read privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the cases. The API returns information about the users as they existed at the time of the case creation, including their name, full name, and email address. If any of those details change thereafter or if a user is deleted, the information returned by this API is unchanged.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'owner',
        type: 'Query',
        schema: owner,
      },
    ],
    response: z
      .array(
        z
          .object({
            email: z.string().nullable(),
            full_name: z.string().nullable(),
            profile_uid: z.string().optional(),
            username: z.string().nullable(),
          })
          .passthrough()
      )
      .max(10000),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/cases/tags',
    alias: 'getCaseTagsDefaultSpace',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/cases/tags&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Aggregates and returns a list of case tags. You must have read privileges for the **Cases** feature in the **Management**, **Observability**, or **Security** section of the Kibana feature privileges, depending on the owner of the cases you&#x27;re seeking.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'owner',
        type: 'Query',
        schema: owner,
      },
    ],
    response: z.array(z.string()).max(10000),
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Cases_4xx_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/data_views',
    alias: 'getAllDataViewsDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z
      .object({
        data_view: z.array(
          z
            .object({
              id: z.string(),
              name: z.string(),
              namespaces: z.array(z.string()),
              title: z.string(),
              typeMeta: z.object({}).partial().passthrough(),
            })
            .partial()
            .passthrough()
        ),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: Data_views_400_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/data_views/data_view',
    alias: 'createDataViewDefaultw',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/data_view&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Data_views_create_data_view_request_object,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: Data_views_data_view_response_object,
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: Data_views_400_response,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/data_views/data_view/:viewId',
    alias: 'deleteDataViewDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/data_view/{viewId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

WARNING: When you delete a data view, it cannot be recovered.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'viewId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 404,
        description: `Object is not found.`,
        schema: Data_views_404_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/data_views/data_view/:viewId',
    alias: 'getDataViewDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/data_view/{viewId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'viewId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: Data_views_data_view_response_object,
    errors: [
      {
        status: 404,
        description: `Object is not found.`,
        schema: Data_views_404_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/data_views/data_view/:viewId',
    alias: 'updateDataViewDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/data_view/{viewId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Data_views_update_data_view_request_object,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'viewId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: Data_views_data_view_response_object,
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: Data_views_400_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/data_views/data_view/:viewId/fields',
    alias: 'updateFieldsMetadataDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/data_view/{viewId}/fields&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update fields presentation metadata such as count, customLabel, customDescription, and format.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ fields: z.object({}).partial().passthrough() }).passthrough(),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'viewId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ acknowledged: z.boolean() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: Data_views_400_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/data_views/data_view/:viewId/runtime_field',
    alias: 'createRuntimeFieldDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/data_view/{viewId}/runtime_field&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: createRuntimeFieldDefault_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'viewId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'put',
    path: '/api/data_views/data_view/:viewId/runtime_field',
    alias: 'createUpdateRuntimeFieldDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/data_view/{viewId}/runtime_field&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: createRuntimeFieldDefault_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'viewId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z
      .object({
        data_view: z.object({}).partial().passthrough(),
        fields: z.array(z.object({}).partial().passthrough()),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: Data_views_400_response,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/data_views/data_view/:viewId/runtime_field/:fieldName',
    alias: 'deleteRuntimeFieldDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/data_view/{viewId}/runtime_field/{fieldName}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'fieldName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'viewId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 404,
        description: `Object is not found.`,
        schema: Data_views_404_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/data_views/data_view/:viewId/runtime_field/:fieldName',
    alias: 'getRuntimeFieldDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/data_view/{viewId}/runtime_field/{fieldName}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'fieldName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'viewId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z
      .object({
        data_view: z.object({}).partial().passthrough(),
        fields: z.array(z.object({}).partial().passthrough()),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 404,
        description: `Object is not found.`,
        schema: Data_views_404_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/data_views/data_view/:viewId/runtime_field/:fieldName',
    alias: 'updateRuntimeFieldDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/data_view/{viewId}/runtime_field/{fieldName}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ runtimeField: z.object({}).partial().passthrough() }).passthrough(),
      },
      {
        name: 'fieldName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'viewId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: Data_views_400_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/data_views/default',
    alias: 'getDefaultDataViewDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/default&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z.object({ data_view_id: z.string() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: Data_views_400_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/data_views/default',
    alias: 'setDefaultDatailViewDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/default&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: setDefaultDatailViewDefault_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ acknowledged: z.boolean() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: Data_views_400_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/data_views/swap_references',
    alias: 'swapDataViewsDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/swap_references&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Changes saved object references from one data view identifier to another. WARNING: Misuse can break large numbers of saved objects! Practicing with a backup is recommended.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Data_views_swap_data_view_request_object,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z
      .object({
        deleteStatus: z
          .object({ deletePerformed: z.boolean(), remainingRefs: z.number().int() })
          .partial()
          .passthrough(),
        result: z.array(z.object({ id: z.string(), type: z.string() }).partial().passthrough()),
      })
      .partial()
      .passthrough(),
  },
  {
    method: 'post',
    path: '/api/data_views/swap_references/_preview',
    alias: 'previewSwapDataViewsDefault',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/data_views/swap_references/_preview&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Preview the impact of swapping saved object references from one data view identifier to another.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Data_views_swap_data_view_request_object,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z
      .object({
        result: z.array(z.object({ id: z.string(), type: z.string() }).partial().passthrough()),
      })
      .partial()
      .passthrough(),
  },
  {
    method: 'delete',
    path: '/api/detection_engine/index',
    alias: 'DeleteAlertsIndex',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/index&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z.object({ acknowledged: z.boolean() }).passthrough(),
    errors: [
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Detections_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough permissions response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
      {
        status: 404,
        description: `Index does not exist response`,
        schema: z.string(),
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/detection_engine/index',
    alias: 'ReadAlertsIndex',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/index&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z
      .object({ index_mapping_outdated: z.boolean().nullable(), name: z.string() })
      .passthrough(),
    errors: [
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Detections_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough permissions response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
      {
        status: 404,
        description: `Not found`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/detection_engine/index',
    alias: 'CreateAlertsIndex',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/index&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z.object({ acknowledged: z.boolean() }).passthrough(),
    errors: [
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Detections_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough permissions response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
      {
        status: 404,
        description: `Not found`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/detection_engine/privileges',
    alias: 'ReadPrivileges',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/privileges&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Retrieves whether or not the user is authenticated, and the user&#x27;s Kibana
space and index privileges, which determine if the user can create an
index for the Elastic Security alerts generated by
detection engine rules.
`,
    requestFormat: 'json',
    response: z
      .object({ has_encryption_key: z.boolean(), is_authenticated: z.boolean() })
      .passthrough(),
    errors: [
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Detections_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/detection_engine/rules',
    alias: 'DeleteRule',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a detection rule using the &#x60;rule_id&#x60; or &#x60;id&#x60; field.

The URL query must include one of the following:

* &#x60;id&#x60; - &#x60;DELETE /api/detection_engine/rules?id&#x3D;&lt;id&gt;&#x60;
* &#x60;rule_id&#x60;- &#x60;DELETE /api/detection_engine/rules?rule_id&#x3D;&lt;rule_id&gt;&#x60;

The difference between the &#x60;id&#x60; and &#x60;rule_id&#x60; is that the &#x60;id&#x60; is a unique rule identifier that is randomly generated when a rule is created and cannot be set, whereas &#x60;rule_id&#x60; is a stable rule identifier that can be assigned during rule creation.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().uuid().optional(),
      },
      {
        name: 'rule_id',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: Security_Detections_API_RuleResponse,
  },
  {
    method: 'get',
    path: '/api/detection_engine/rules',
    alias: 'ReadRule',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Retrieve a detection rule using the &#x60;rule_id&#x60; or &#x60;id&#x60; field.

The URL query must include one of the following:

* &#x60;id&#x60; - &#x60;GET /api/detection_engine/rules?id&#x3D;&lt;id&gt;&#x60;
* &#x60;rule_id&#x60; - &#x60;GET /api/detection_engine/rules?rule_id&#x3D;&lt;rule_id&gt;&#x60;

The difference between the &#x60;id&#x60; and &#x60;rule_id&#x60; is that the &#x60;id&#x60; is a unique rule identifier that is randomly generated when a rule is created and cannot be set, whereas &#x60;rule_id&#x60; is a stable rule identifier that can be assigned during rule creation.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().uuid().optional(),
      },
      {
        name: 'rule_id',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: Security_Detections_API_RuleResponse,
  },
  {
    method: 'patch',
    path: '/api/detection_engine/rules',
    alias: 'PatchRule',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update specific fields of an existing detection rule using the &#x60;rule_id&#x60; or &#x60;id&#x60; field.

The difference between the &#x60;id&#x60; and &#x60;rule_id&#x60; is that the &#x60;id&#x60; is a unique rule identifier that is randomly generated when a rule is created and cannot be set, whereas &#x60;rule_id&#x60; is a stable rule identifier that can be assigned during rule creation.
&gt; warn
&gt; When used with [API key](https://www.elastic.co/docs/deploy-manage/api-keys) authentication, the user&#x27;s key gets assigned to the affected rules. If the user&#x27;s key gets deleted or the user becomes inactive, the rules will stop running.

&gt; If the API key that is used for authorization has different privileges than the key that created or most recently updated the rule, the rule behavior might change.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `&gt; info
&gt; You cannot modify the &#x60;id&#x60; or &#x60;rule_id&#x60; values.
`,
        type: 'Body',
        schema: Security_Detections_API_RulePatchProps,
      },
    ],
    response: Security_Detections_API_RuleResponse,
  },
  {
    method: 'post',
    path: '/api/detection_engine/rules',
    alias: 'CreateRule',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a new detection rule.
&gt; warn
&gt; When used with [API key](https://www.elastic.co/docs/deploy-manage/api-keys) authentication, the user&#x27;s key gets assigned to the affected rules. If the user&#x27;s key gets deleted or the user becomes inactive, the rules will stop running.

&gt; If the API key that is used for authorization has different privileges than the key that created or most recently updated the rule, the rule behavior might change.

You can create the following types of rules:

* **Custom query**: Searches the defined indices and creates an alert when a document matches the rule&#x27;s KQL query.
* **Event correlation**: Searches the defined indices and creates an alert when results match an [Event Query Language (EQL)](https://www.elastic.co/guide/en/elasticsearch/reference/current/eql.html) query.
* **Threshold**: Searches the defined indices and creates an alert when the number of times the specified field&#x27;s value meets the threshold during a single execution. When there are multiple values that meet the threshold, an alert is generated for each value.
  For example, if the threshold &#x60;field&#x60; is &#x60;source.ip&#x60; and its &#x60;value&#x60; is &#x60;10&#x60;, an alert is generated for every source IP address that appears in at least 10 of the rule&#x27;s search results. If you&#x27;re interested, see [Terms Aggregation](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html) for more information.
* **Indicator match**: Creates an alert when fields match values defined in the specified [Elasticsearch index](https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html). For example, you can create an index for IP addresses and use this index to create an alert whenever an event&#x27;s &#x60;destination.ip&#x60; equals a value in the index. The index&#x27;s field mappings should be [ECS-compliant](https://www.elastic.co/guide/en/ecs/current/ecs-reference.html).
* **New terms**: Generates an alert for each new term detected in source documents within a specified time range.
* **ES|QL**: Uses [Elasticsearch Query Language (ES|QL)](https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html) to find events and aggregate search results.
* **Machine learning rules**: Creates an alert when a machine learning job discovers an anomaly above the defined threshold.
&gt; info
&gt; To create machine learning rules, you must have the [appropriate license](https://www.elastic.co/subscriptions) or use a [cloud deployment](https://cloud.elastic.co/registration). Additionally, for the machine learning rule to function correctly, the associated machine learning job must be running.

To retrieve machine learning job IDs, which are required to create machine learning jobs, call the [Elasticsearch Get jobs API](https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job.html). Machine learning jobs that contain &#x60;siem&#x60; in the &#x60;groups&#x60; field can be used to create rules:

&#x60;&#x60;&#x60;json
...
&quot;job_id&quot;: &quot;linux_anomalous_network_activity_ecs&quot;,
&quot;job_type&quot;: &quot;anomaly_detector&quot;,
&quot;job_version&quot;: &quot;7.7.0&quot;,
&quot;groups&quot;: [
  &quot;auditbeat&quot;,
  &quot;process&quot;,
  &quot;siem&quot;
],
...
&#x60;&#x60;&#x60;

Additionally, you can set up notifications for when rules create alerts. The notifications use the [Alerting and Actions framework](https://www.elastic.co/guide/en/kibana/current/alerting-getting-started.html). Each action type requires a connector. Connectors store the information required to send notifications via external systems. The following connector types are supported for rule notifications:

* Slack
* Email
* PagerDuty
* Webhook
* Microsoft Teams
* IBM Resilient
* Jira
* ServiceNow ITSM
&gt; info
&gt; For more information on PagerDuty fields, see [Send a v2 Event](https://developer.pagerduty.com/docs/events-api-v2/trigger-events/).

To retrieve connector IDs, which are required to configure rule notifications, call the [Find objects API](https://www.elastic.co/guide/en/kibana/current/saved-objects-api-find.html) with &#x60;&quot;type&quot;: &quot;action&quot;&#x60; in the request payload.

For detailed information on Kibana actions and alerting, and additional API calls, see:

* [Alerting API](https://www.elastic.co/docs/api/doc/kibana/group/endpoint-alerting)
* [Alerting and Actions framework](https://www.elastic.co/guide/en/kibana/current/alerting-getting-started.html)
* [Connectors API](https://www.elastic.co/docs/api/doc/kibana/group/endpoint-connectors)
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Detections_API_RuleCreateProps,
      },
    ],
    response: Security_Detections_API_RuleResponse,
  },
  {
    method: 'put',
    path: '/api/detection_engine/rules',
    alias: 'UpdateRule',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update a detection rule using the &#x60;rule_id&#x60; or &#x60;id&#x60; field. The original rule is replaced, and all unspecified fields are deleted.

The difference between the &#x60;id&#x60; and &#x60;rule_id&#x60; is that the &#x60;id&#x60; is a unique rule identifier that is randomly generated when a rule is created and cannot be set, whereas &#x60;rule_id&#x60; is a stable rule identifier that can be assigned during rule creation.
&gt; warn
&gt; When used with [API key](https://www.elastic.co/docs/deploy-manage/api-keys) authentication, the user&#x27;s key gets assigned to the affected rules. If the user&#x27;s key gets deleted or the user becomes inactive, the rules will stop running.

&gt; If the API key that is used for authorization has different privileges than the key that created or most recently updated the rule, the rule behavior might change.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `&gt; info
&gt; All unspecified fields are deleted. You cannot modify the &#x60;id&#x60; or &#x60;rule_id&#x60; values.
`,
        type: 'Body',
        schema: Security_Detections_API_RuleUpdateProps,
      },
    ],
    response: Security_Detections_API_RuleResponse,
  },
  {
    method: 'post',
    path: '/api/detection_engine/rules/_bulk_action',
    alias: 'PerformRulesBulkAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules/_bulk_action&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Apply a bulk action, such as bulk edit, duplicate, or delete, to multiple detection rules. The bulk action is applied to all rules that match the query or to the rules listed by their IDs.

The edit action allows you to add, delete, or set tags, index patterns, investigation fields, rule actions and schedules for multiple rules at once. 
The edit action is idempotent, meaning that if you add a tag to a rule that already has that tag, no changes are made. The same is true for other edit actions, for example removing an index pattern that is not specified in a rule will not result in any changes. The only exception is the &#x60;add_rule_actions&#x60; and &#x60;set_rule_actions&#x60; action, which is non-idempotent. This means that if you add or set a rule action to a rule that already has that action, a new action is created with a new unique ID.
&gt; warn
&gt; When used with [API key](https://www.elastic.co/docs/deploy-manage/api-keys) authentication, the user&#x27;s key gets assigned to the affected rules. If the user&#x27;s key gets deleted or the user becomes inactive, the rules will stop running.

&gt; If the API key that is used for authorization has different privileges than the key that created or most recently updated the rule, the rule behavior might change.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: PerformRulesBulkAction_Body,
      },
      {
        name: 'dry_run',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.union([
      Security_Detections_API_BulkEditActionResponse,
      Security_Detections_API_BulkExportActionResponse,
    ]),
  },
  {
    method: 'post',
    path: '/api/detection_engine/rules/_export',
    alias: 'ExportRules',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules/_export&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Export detection rules to an &#x60;.ndjson&#x60; file. The following configuration items are also included in the &#x60;.ndjson&#x60; file:
- Actions
- Exception lists
&gt; info
&gt; Rule actions and connectors are included in the exported file, but sensitive information about the connector (such as authentication credentials) is not included. You must re-add missing connector details after importing detection rules.

&gt; You can use Kibanas [Saved Objects](https://www.elastic.co/guide/en/kibana/current/managing-saved-objects.html) UI (Stack Management  Kibana  Saved Objects) or the Saved Objects APIs (experimental) to [export](https://www.elastic.co/docs/api/doc/kibana/operation/operation-exportsavedobjectsdefault) and [import](https://www.elastic.co/docs/api/doc/kibana/operation/operation-importsavedobjectsdefault) any necessary connectors before importing detection rules.

&gt; Similarly, any value lists used for rule exceptions are not included in rule exports or imports. Use the [Manage value lists](https://www.elastic.co/guide/en/security/current/value-lists-exceptions.html#manage-value-lists) UI (Rules  Detection rules (SIEM)  Manage value lists) to export and import value lists separately.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: ExportRules_Body.nullish(),
      },
      {
        name: 'exclude_export_details',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'file_name',
        type: 'Query',
        schema: z.string().optional().default('export.ndjson'),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/detection_engine/rules/_find',
    alias: 'FindRules',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Retrieve a paginated list of detection rules. By default, the first page is returned, with 20 results per page.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'fields',
        type: 'Query',
        schema: z.array(z.string()).optional(),
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z
          .enum([
            'created_at',
            'createdAt',
            'enabled',
            'execution_summary.last_execution.date',
            'execution_summary.last_execution.metrics.execution_gap_duration_s',
            'execution_summary.last_execution.metrics.total_indexing_duration_ms',
            'execution_summary.last_execution.metrics.total_search_duration_ms',
            'execution_summary.last_execution.status',
            'name',
            'risk_score',
            'riskScore',
            'severity',
            'updated_at',
            'updatedAt',
          ])
          .optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(1).optional().default(1),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().gte(0).optional().default(20),
      },
      {
        name: 'gaps_range_start',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'gaps_range_end',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z
      .object({
        data: z.array(Security_Detections_API_RuleResponse),
        page: z.number().int(),
        perPage: z.number().int(),
        total: z.number().int(),
      })
      .passthrough(),
  },
  {
    method: 'post',
    path: '/api/detection_engine/rules/_import',
    alias: 'ImportRules',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules/_import&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Import detection rules from an &#x60;.ndjson&#x60; file, including actions and exception lists. The request must include:
- The &#x60;Content-Type: multipart/form-data&#x60; HTTP header.
- A link to the &#x60;.ndjson&#x60; file containing the rules.
&gt; warn
&gt; When used with [API key](https://www.elastic.co/docs/deploy-manage/api-keys) authentication, the user&#x27;s key gets assigned to the affected rules. If the user&#x27;s key gets deleted or the user becomes inactive, the rules will stop running.

&gt; If the API key that is used for authorization has different privileges than the key that created or most recently updated the rule, the rule behavior might change.
&gt; info
&gt; To import rules with actions, you need at least Read privileges for the Action and Connectors feature. To overwrite or add new connectors, you need All privileges for the Actions and Connectors feature. To import rules without actions, you dont need Actions and Connectors privileges. Refer to [Enable and access detections](https://www.elastic.co/guide/en/security/current/detections-permissions-section.html#enable-detections-ui) for more information.

&gt; info
&gt; Rule actions and connectors are included in the exported file, but sensitive information about the connector (such as authentication credentials) is not included. You must re-add missing connector details after importing detection rules.

&gt; You can use Kibanas [Saved Objects](https://www.elastic.co/guide/en/kibana/current/managing-saved-objects.html) UI (Stack Management  Kibana  Saved Objects) or the Saved Objects APIs (experimental) to [export](https://www.elastic.co/docs/api/doc/kibana/operation/operation-exportsavedobjectsdefault) and [import](https://www.elastic.co/docs/api/doc/kibana/operation/operation-importsavedobjectsdefault) any necessary connectors before importing detection rules.

&gt; Similarly, any value lists used for rule exceptions are not included in rule exports or imports. Use the [Manage value lists](https://www.elastic.co/guide/en/security/current/value-lists-exceptions.html#manage-value-lists) UI (Rules  Detection rules (SIEM)  Manage value lists) to export and import value lists separately.
`,
    requestFormat: 'form-data',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z
          .object({ file: z.instanceof(File) })
          .partial()
          .passthrough(),
      },
      {
        name: 'overwrite',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'overwrite_exceptions',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'overwrite_action_connectors',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'as_new_list',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({
      action_connectors_errors: z.array(Security_Detections_API_ErrorSchema),
      action_connectors_success: z.boolean(),
      action_connectors_success_count: z.number().int().gte(0),
      action_connectors_warnings: z.array(Security_Detections_API_WarningSchema),
      errors: z.array(Security_Detections_API_ErrorSchema),
      exceptions_errors: z.array(Security_Detections_API_ErrorSchema),
      exceptions_success: z.boolean(),
      exceptions_success_count: z.number().int().gte(0),
      rules_count: z.number().int().gte(0),
      success: z.boolean(),
      success_count: z.number().int().gte(0),
    }),
  },
  {
    method: 'post',
    path: '/api/detection_engine/rules/:id/exceptions',
    alias: 'CreateRuleExceptionListItems',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules/{id}/exceptions&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create exception items that apply to a single detection rule.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Rule exception items.`,
        type: 'Body',
        schema: CreateRuleExceptionListItems_Body,
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string().uuid(),
      },
    ],
    response: z.array(Security_Exceptions_API_ExceptionListItem),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'put',
    path: '/api/detection_engine/rules/prepackaged',
    alias: 'InstallPrebuiltRulesAndTimelines',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules/prepackaged&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Install and update all Elastic prebuilt detection rules and Timelines.

This endpoint allows you to install and update prebuilt detection rules and Timelines provided by Elastic. 
When you call this endpoint, it will:
- Install any new prebuilt detection rules that are not currently installed in your system.
- Update any existing prebuilt detection rules that have been modified or improved by Elastic.
- Install any new prebuilt Timelines that are not currently installed in your system.
- Update any existing prebuilt Timelines that have been modified or improved by Elastic.

This ensures that your detection engine is always up-to-date with the latest rules and Timelines, 
providing you with the most current and effective threat detection capabilities.
`,
    requestFormat: 'json',
    response: z.object({
      rules_installed: z.number().int().gte(0),
      rules_updated: z.number().int().gte(0),
      timelines_installed: z.number().int().gte(0),
      timelines_updated: z.number().int().gte(0),
    }),
  },
  {
    method: 'get',
    path: '/api/detection_engine/rules/prepackaged/_status',
    alias: 'ReadPrebuiltRulesAndTimelinesStatus',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules/prepackaged/_status&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Retrieve the status of all Elastic prebuilt detection rules and Timelines. 

This endpoint provides detailed information about the number of custom rules, installed prebuilt rules, available prebuilt rules that are not installed, outdated prebuilt rules, installed prebuilt timelines, available prebuilt timelines that are not installed, and outdated prebuilt timelines.
`,
    requestFormat: 'json',
    response: z.object({
      rules_custom_installed: z.number().int().gte(0),
      rules_installed: z.number().int().gte(0),
      rules_not_installed: z.number().int().gte(0),
      rules_not_updated: z.number().int().gte(0),
      timelines_installed: z.number().int().gte(0),
      timelines_not_installed: z.number().int().gte(0),
      timelines_not_updated: z.number().int().gte(0),
    }),
  },
  {
    method: 'post',
    path: '/api/detection_engine/rules/preview',
    alias: 'RulePreview',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/rules/preview&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `An object containing tags to add or remove and alert ids the changes will be applied`,
        type: 'Body',
        schema: RulePreview_Body,
      },
      {
        name: 'enable_logged_requests',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z
      .object({
        isAborted: z.boolean().optional(),
        logs: z.array(Security_Detections_API_RulePreviewLogs),
        previewId: Security_Detections_API_NonEmptyString.min(1).optional(),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Detections_API_PlatformErrorResponse,
          Security_Detections_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Detections_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/detection_engine/signals/assignees',
    alias: 'SetAlertAssignees',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/signals/assignees&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Assign users to detection alerts, and unassign them from alerts.
&gt; info
&gt; You cannot add and remove the same assignee in the same request.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: SetAlertAssignees_Body,
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Invalid request.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/detection_engine/signals/search',
    alias: 'SearchAlerts',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/signals/search&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Find and/or aggregate detection alerts that match the given query.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Search and/or aggregation query`,
        type: 'Body',
        schema: SearchAlerts_Body,
      },
    ],
    response: z.object({}).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Detections_API_PlatformErrorResponse,
          Security_Detections_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Detections_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/detection_engine/signals/status',
    alias: 'SetAlertsStatus',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/signals/status&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Set the status of one or more detection alerts.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `An object containing desired status and explicit alert ids or a query to select alerts`,
        type: 'Body',
        schema: SetAlertsStatus_Body,
      },
    ],
    response: z.object({}).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Detections_API_PlatformErrorResponse,
          Security_Detections_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Detections_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/detection_engine/signals/tags',
    alias: 'SetAlertTags',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/signals/tags&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

And tags to detection alerts, and remove them from alerts.
&gt; info
&gt; You cannot add and remove the same alert tag in the same request.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `An object containing tags to add or remove and alert ids the changes will be applied`,
        type: 'Body',
        schema: SetAlertTags_Body,
      },
    ],
    response: z.object({}).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Detections_API_PlatformErrorResponse,
          Security_Detections_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Detections_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Detections_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/detection_engine/tags',
    alias: 'ReadTags',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/detection_engine/tags&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

List all unique tags from all detection rules.`,
    requestFormat: 'json',
    response: z.array(z.string()),
  },
  {
    method: 'post',
    path: '/api/encrypted_saved_objects/_rotate_key',
    alias: 'rotateEncryptionKey',
    description: `Superuser role required.

If a saved object cannot be decrypted using the primary encryption key, then Kibana will attempt to decrypt it using the specified decryption-only keys. In most of the cases this overhead is negligible, but if you&#x27;re dealing with a large number of saved objects and experiencing performance issues, you may want to rotate the encryption key.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'batch_size',
        type: 'Query',
        schema: z.number().optional().default(10000),
      },
      {
        name: 'type',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z
      .object({ failed: z.number(), successful: z.number(), total: z.number() })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: Saved_objects_400_response,
      },
      {
        status: 429,
        description: `Already in progress.`,
        schema: z.object({}).partial().passthrough(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/endpoint_list',
    alias: 'CreateEndpointList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint_list&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create the exception list for Elastic Endpoint rule exceptions. When you create the exception list, it will have a &#x60;list_id&#x60; of &#x60;endpoint_list&#x60;. If the Elastic Endpoint exception list already exists, your request will return an empty response.`,
    requestFormat: 'json',
    response: Security_Endpoint_Exceptions_API_EndpointList,
    errors: [
      {
        status: 400,
        description: `Invalid input data`,
        schema: z.union([
          Security_Endpoint_Exceptions_API_PlatformErrorResponse,
          Security_Endpoint_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Insufficient privileges`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/endpoint_list/items',
    alias: 'DeleteEndpointListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint_list/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete an Elastic Endpoint exception list item, specified by the &#x60;id&#x60; or &#x60;item_id&#x60; field.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'item_id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
    ],
    response: Security_Endpoint_Exceptions_API_ExceptionListItem,
    errors: [
      {
        status: 400,
        description: `Invalid input data`,
        schema: z.union([
          Security_Endpoint_Exceptions_API_PlatformErrorResponse,
          Security_Endpoint_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Insufficient privileges`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Endpoint list item not found`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/endpoint_list/items',
    alias: 'ReadEndpointListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint_list/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of an Elastic Endpoint exception list item, specified by the &#x60;id&#x60; or &#x60;item_id&#x60; field.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'item_id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
    ],
    response: z.array(Security_Endpoint_Exceptions_API_ExceptionListItem),
    errors: [
      {
        status: 400,
        description: `Invalid input data`,
        schema: z.union([
          Security_Endpoint_Exceptions_API_PlatformErrorResponse,
          Security_Endpoint_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Insufficient privileges`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Endpoint list item not found`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/endpoint_list/items',
    alias: 'CreateEndpointListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint_list/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create an Elastic Endpoint exception list item, and associate it with the Elastic Endpoint exception list.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Exception list item&#x27;s properties`,
        type: 'Body',
        schema: CreateEndpointListItem_Body,
      },
    ],
    response: Security_Endpoint_Exceptions_API_ExceptionListItem,
    errors: [
      {
        status: 400,
        description: `Invalid input data`,
        schema: z.union([
          Security_Endpoint_Exceptions_API_PlatformErrorResponse,
          Security_Endpoint_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Insufficient privileges`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 409,
        description: `Endpoint list item already exists`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'put',
    path: '/api/endpoint_list/items',
    alias: 'UpdateEndpointListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint_list/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update an Elastic Endpoint exception list item, specified by the &#x60;id&#x60; or &#x60;item_id&#x60; field.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Exception list item&#x27;s properties`,
        type: 'Body',
        schema: UpdateEndpointListItem_Body,
      },
    ],
    response: Security_Endpoint_Exceptions_API_ExceptionListItem,
    errors: [
      {
        status: 400,
        description: `Invalid input data`,
        schema: z.union([
          Security_Endpoint_Exceptions_API_PlatformErrorResponse,
          Security_Endpoint_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Insufficient privileges`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Endpoint list item not found`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/endpoint_list/items/_find',
    alias: 'FindEndpointListItems',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint_list/items/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all Elastic Endpoint exception list items.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(0).optional(),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().gte(0).optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['desc', 'asc']).optional(),
      },
    ],
    response: z
      .object({
        data: z.array(Security_Endpoint_Exceptions_API_ExceptionListItem),
        page: z.number().int().gte(0),
        per_page: z.number().int().gte(0),
        pit: z.string().optional(),
        total: z.number().int().gte(0),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data`,
        schema: z.union([
          Security_Endpoint_Exceptions_API_PlatformErrorResponse,
          Security_Endpoint_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Insufficient privileges`,
        schema: Security_Endpoint_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Endpoint list not found`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error`,
        schema: Security_Endpoint_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/endpoint/action',
    alias: 'EndpointGetActionsList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all response actions.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(1).optional().default(1),
      },
      {
        name: 'pageSize',
        type: 'Query',
        schema: z.number().int().gte(1).lte(100).optional().default(10),
      },
      {
        name: 'commands',
        type: 'Query',
        schema: z.array(Security_Endpoint_Management_API_Command).optional(),
      },
      {
        name: 'agentIds',
        type: 'Query',
        schema: agentIds,
      },
      {
        name: 'userIds',
        type: 'Query',
        schema: agentIds,
      },
      {
        name: 'startDate',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'endDate',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'agentTypes',
        type: 'Query',
        schema: z
          .enum(['endpoint', 'sentinel_one', 'crowdstrike', 'microsoft_defender_endpoint'])
          .optional(),
      },
      {
        name: 'withOutputs',
        type: 'Query',
        schema: agentIds,
      },
      {
        name: 'types',
        type: 'Query',
        schema: z.array(Security_Endpoint_Management_API_Type).optional(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/endpoint/action_status',
    alias: 'EndpointGetActionsStatus',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action_status&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the status of response actions for the specified agent IDs.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'query',
        type: 'Query',
        schema: query,
      },
    ],
    response: Security_Endpoint_Management_API_ActionStatusSuccessResponse,
  },
  {
    method: 'get',
    path: '/api/endpoint/action/:action_id',
    alias: 'EndpointGetActionsDetails',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/{action_id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of a response action using the action ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'action_id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/endpoint/action/:action_id/file/:file_id',
    alias: 'EndpointFileInfo',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/{action_id}/file/{file_id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get information for the specified file using the file ID.
&gt; info
&gt; To construct a &#x60;file_id&#x60;, combine the &#x60;action_id&#x60; and &#x60;agent_id&#x60; values using a dot separator:
&gt; {&#x60;file_id&#x60;} &#x3D; {&#x60;action_id&#x60;}&#x60;.&#x60;{&#x60;agent_id&#x60;}
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'action_id',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'file_id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/endpoint/action/:action_id/file/:file_id/download',
    alias: 'EndpointFileDownload',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/{action_id}/file/{file_id}/download&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Download a file from an endpoint. 
&gt; info
&gt; To construct a &#x60;file_id&#x60;, combine the &#x60;action_id&#x60; and &#x60;agent_id&#x60; values using a dot separator:
&gt; {&#x60;file_id&#x60;} &#x3D; {&#x60;action_id&#x60;}&#x60;.&#x60;{&#x60;agent_id&#x60;}
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'action_id',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'file_id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/endpoint/action/execute',
    alias: 'EndpointExecuteAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/execute&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Run a shell command on an endpoint.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Endpoint_Management_API_ExecuteRouteRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/endpoint/action/get_file',
    alias: 'EndpointGetFileAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/get_file&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a file from an endpoint.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Endpoint_Management_API_GetFileRouteRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/endpoint/action/isolate',
    alias: 'EndpointIsolateAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/isolate&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Isolate an endpoint from the network. The endpoint remains isolated until it&#x27;s released.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: EndpointIsolateAction_Body,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/endpoint/action/kill_process',
    alias: 'EndpointKillProcessAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/kill_process&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Terminate a running process on an endpoint.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Endpoint_Management_API_KillProcessRouteRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/endpoint/action/running_procs',
    alias: 'EndpointGetProcessesAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/running_procs&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all processes running on an endpoint.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Endpoint_Management_API_GetProcessesRouteRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/endpoint/action/runscript',
    alias: 'RunScriptAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/runscript&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Run a shell command on an endpoint.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Endpoint_Management_API_RunScriptRouteRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/endpoint/action/scan',
    alias: 'EndpointScanAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/scan&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Scan a specific file or directory on an endpoint for malware.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Endpoint_Management_API_ScanRouteRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/endpoint/action/state',
    alias: 'EndpointGetActionsState',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/state&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a response actions state, which reports whether encryption is enabled.`,
    requestFormat: 'json',
    response: Security_Endpoint_Management_API_ActionStateSuccessResponse,
  },
  {
    method: 'post',
    path: '/api/endpoint/action/suspend_process',
    alias: 'EndpointSuspendProcessAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/suspend_process&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Suspend a running process on an endpoint.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Endpoint_Management_API_SuspendProcessRouteRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/endpoint/action/unisolate',
    alias: 'EndpointUnisolateAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/unisolate&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Release an isolated endpoint, allowing it to rejoin a network.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: EndpointIsolateAction_Body,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/endpoint/action/upload',
    alias: 'EndpointUploadAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/action/upload&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Upload a file to an endpoint.`,
    requestFormat: 'form-data',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Endpoint_Management_API_UploadRouteRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/endpoint/metadata',
    alias: 'GetEndpointMetadataList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/metadata&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(1).optional().default(1),
      },
      {
        name: 'pageSize',
        type: 'Query',
        schema: z.number().int().gte(1).lte(100).optional().default(10),
      },
      {
        name: 'kuery',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'hostStatuses',
        type: 'Query',
        schema: z.array(z.enum(['healthy', 'offline', 'updating', 'inactive', 'unenrolled'])),
      },
      {
        name: 'sortField',
        type: 'Query',
        schema: z
          .enum([
            'enrolled_at',
            'metadata.host.hostname',
            'host_status',
            'metadata.Endpoint.policy.applied.name',
            'metadata.Endpoint.policy.applied.status',
            'metadata.host.os.name',
            'metadata.host.ip',
            'metadata.agent.version',
            'last_checkin',
          ])
          .optional(),
      },
      {
        name: 'sortDirection',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/endpoint/metadata/:id',
    alias: 'GetEndpointMetadata',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/metadata/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/endpoint/policy_response',
    alias: 'GetPolicyResponse',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/policy_response&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'query',
        type: 'Query',
        schema: query__2,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/endpoint/protection_updates_note/:package_policy_id',
    alias: 'GetProtectionUpdatesNote',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/protection_updates_note/{package_policy_id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'package_policy_id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ note: z.string() }).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/endpoint/protection_updates_note/:package_policy_id',
    alias: 'CreateUpdateProtectionUpdatesNote',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/endpoint/protection_updates_note/{package_policy_id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ note: z.string() }).partial().passthrough(),
      },
      {
        name: 'package_policy_id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ note: z.string() }).partial().passthrough(),
  },
  {
    method: 'delete',
    path: '/api/entity_analytics/monitoring/engine/delete',
    alias: 'DeleteMonitoringEngine',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/engine/delete&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'data',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({ deleted: z.boolean() }).passthrough(),
  },
  {
    method: 'post',
    path: '/api/entity_analytics/monitoring/engine/disable',
    alias: 'DisableMonitoringEngine',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/engine/disable&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: Security_Entity_Analytics_API_MonitoringEngineDescriptor,
  },
  {
    method: 'post',
    path: '/api/entity_analytics/monitoring/engine/init',
    alias: 'InitMonitoringEngine',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/engine/init&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: Security_Entity_Analytics_API_MonitoringEngineDescriptor,
  },
  {
    method: 'post',
    path: '/api/entity_analytics/monitoring/engine/schedule_now',
    alias: 'ScheduleMonitoringEngine',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/engine/schedule_now&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z.object({ success: z.boolean() }).partial().passthrough(),
    errors: [
      {
        status: 409,
        description: `Conflict - Monitoring engine is already running`,
        schema: z.object({ message: z.string() }).partial().passthrough(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/entity_analytics/monitoring/privileges/health',
    alias: 'PrivMonHealth',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/privileges/health&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z
      .object({
        error: z.object({ message: z.string().optional() }).passthrough().optional(),
        status: Security_Entity_Analytics_API_PrivilegeMonitoringEngineStatus,
      })
      .passthrough(),
  },
  {
    method: 'get',
    path: '/api/entity_analytics/monitoring/privileges/privileges',
    alias: 'PrivMonPrivileges',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/privileges/privileges&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Check if the current user has all required permissions for Privilege Monitoring`,
    requestFormat: 'json',
    response: Security_Entity_Analytics_API_EntityAnalyticsPrivileges,
  },
  {
    method: 'post',
    path: '/api/entity_analytics/monitoring/users',
    alias: 'CreatePrivMonUser',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/users&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Entity_Analytics_API_UserName,
      },
    ],
    response: Security_Entity_Analytics_API_MonitoredUserDoc,
  },
  {
    method: 'post',
    path: '/api/entity_analytics/monitoring/users/_csv',
    alias: 'PrivmonBulkUploadUsersCSV',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/users/_csv&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'form-data',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ file: z.instanceof(File) }).passthrough(),
      },
    ],
    response: z
      .object({
        errors: z.array(Security_Entity_Analytics_API_PrivmonUserCsvUploadErrorItem),
        stats: Security_Entity_Analytics_API_PrivmonUserCsvUploadStats,
      })
      .passthrough(),
    errors: [
      {
        status: 413,
        description: `File too large`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/entity_analytics/monitoring/users/:id',
    alias: 'DeletePrivMonUser',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/users/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z
      .object({ acknowledged: z.boolean().optional(), message: z.string().optional() })
      .passthrough(),
  },
  {
    method: 'put',
    path: '/api/entity_analytics/monitoring/users/:id',
    alias: 'UpdatePrivMonUser',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/users/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Entity_Analytics_API_MonitoredUserDoc,
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: Security_Entity_Analytics_API_MonitoredUserDoc,
  },
  {
    method: 'get',
    path: '/api/entity_analytics/monitoring/users/list',
    alias: 'ListPrivMonUsers',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/monitoring/users/list&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kql',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z.array(Security_Entity_Analytics_API_MonitoredUserDoc),
  },
  {
    method: 'post',
    path: '/api/entity_analytics/privileged_user_monitoring/pad/install',
    alias: 'InstallPrivilegedAccessDetectionPackage',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/privileged_user_monitoring/pad/install&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z.object({ message: z.string() }).passthrough(),
  },
  {
    method: 'get',
    path: '/api/entity_analytics/privileged_user_monitoring/pad/status',
    alias: 'GetPrivilegedAccessDetectionPackageStatus',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_analytics/privileged_user_monitoring/pad/status&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z
      .object({
        jobs: z.array(
          z
            .object({
              description: z.string().optional(),
              job_id: z.string(),
              state: z.enum(['closing', 'closed', 'opened', 'failed', 'opening']),
            })
            .passthrough()
        ),
        ml_module_setup_status: z.enum(['complete', 'incomplete']),
        package_installation_status: z.enum(['complete', 'incomplete']),
      })
      .passthrough(),
  },
  {
    method: 'post',
    path: '/api/entity_store/enable',
    alias: 'InitEntityStore',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_store/enable&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Schema for the entity store initialization`,
        type: 'Body',
        schema: InitEntityStore_Body,
      },
    ],
    response: z
      .object({
        engines: z.array(Security_Entity_Analytics_API_EngineDescriptor),
        succeeded: z.boolean(),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid request`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/entity_store/engines',
    alias: 'ListEntityEngines',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_store/engines&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z
      .object({
        count: z.number().int(),
        engines: z.array(Security_Entity_Analytics_API_EngineDescriptor),
      })
      .partial()
      .passthrough(),
  },
  {
    method: 'delete',
    path: '/api/entity_store/engines/:entityType',
    alias: 'DeleteEntityEngine',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_store/engines/{entityType}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'entityType',
        type: 'Path',
        schema: z.enum(['user', 'host', 'service', 'generic']),
      },
      {
        name: 'data',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({ deleted: z.boolean() }).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/entity_store/engines/:entityType',
    alias: 'GetEntityEngine',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_store/engines/{entityType}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'entityType',
        type: 'Path',
        schema: z.enum(['user', 'host', 'service', 'generic']),
      },
    ],
    response: Security_Entity_Analytics_API_EngineDescriptor,
  },
  {
    method: 'post',
    path: '/api/entity_store/engines/:entityType/init',
    alias: 'InitEntityEngine',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_store/engines/{entityType}/init&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Schema for the engine initialization`,
        type: 'Body',
        schema: InitEntityEngine_Body,
      },
      {
        name: 'entityType',
        type: 'Path',
        schema: z.enum(['user', 'host', 'service', 'generic']),
      },
    ],
    response: Security_Entity_Analytics_API_EngineDescriptor,
    errors: [
      {
        status: 400,
        description: `Invalid request`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/entity_store/engines/:entityType/start',
    alias: 'StartEntityEngine',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_store/engines/{entityType}/start&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'entityType',
        type: 'Path',
        schema: z.enum(['user', 'host', 'service', 'generic']),
      },
    ],
    response: z.object({ started: z.boolean() }).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/entity_store/engines/:entityType/stop',
    alias: 'StopEntityEngine',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_store/engines/{entityType}/stop&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'entityType',
        type: 'Path',
        schema: z.enum(['user', 'host', 'service', 'generic']),
      },
    ],
    response: z.object({ stopped: z.boolean() }).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/entity_store/engines/apply_dataview_indices',
    alias: 'ApplyEntityEngineDataviewIndices',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_store/engines/apply_dataview_indices&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z
      .object({
        result: z.array(Security_Entity_Analytics_API_EngineDataviewUpdateResult),
        success: z.boolean(),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 500,
        description: `Error response`,
        schema: z.object({ body: z.string(), statusCode: z.number() }).partial().passthrough(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/entity_store/entities/list',
    alias: 'ListEntities',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_store/entities/list&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

List entities records, paging, sorting and filtering as needed.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(1).optional(),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().gte(1).lte(10000).optional(),
      },
      {
        name: 'filterQuery',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'entity_types',
        type: 'Query',
        schema: z.array(Security_Entity_Analytics_API_EntityType),
      },
    ],
    response: z
      .object({
        inspect: Security_Entity_Analytics_API_InspectQuery.optional(),
        page: z.number().int().gte(1),
        per_page: z.number().int().gte(1).lte(1000),
        records: z.array(Security_Entity_Analytics_API_Entity),
        total: z.number().int().gte(0),
      })
      .passthrough(),
  },
  {
    method: 'get',
    path: '/api/entity_store/status',
    alias: 'GetEntityStoreStatus',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/entity_store/status&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'include_components',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z
      .object({
        engines: z.array(
          Security_Entity_Analytics_API_EngineDescriptor.and(
            z
              .object({ components: z.array(Security_Entity_Analytics_API_EngineComponentStatus) })
              .partial()
              .passthrough()
          )
        ),
        status: Security_Entity_Analytics_API_StoreStatus,
      })
      .passthrough(),
  },
  {
    method: 'delete',
    path: '/api/exception_lists',
    alias: 'DeleteExceptionList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete an exception list using the &#x60;id&#x60; or &#x60;list_id&#x60; field.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'list_id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'namespace_type',
        type: 'Query',
        schema: z.enum(['agnostic', 'single']).optional(),
      },
    ],
    response: Security_Exceptions_API_ExceptionList,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Exception list not found response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/exception_lists',
    alias: 'ReadExceptionList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of an exception list using the &#x60;id&#x60; or &#x60;list_id&#x60; field.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'list_id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'namespace_type',
        type: 'Query',
        schema: z.enum(['agnostic', 'single']).optional(),
      },
    ],
    response: Security_Exceptions_API_ExceptionList,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Exception list item not found response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/exception_lists',
    alias: 'CreateExceptionList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

An exception list groups exception items and can be associated with detection rules. You can assign exception lists to multiple detection rules.
&gt; info
&gt; All exception items added to the same list are evaluated using &#x60;OR&#x60; logic. That is, if any of the items in a list evaluate to &#x60;true&#x60;, the exception prevents the rule from generating an alert. Likewise, &#x60;OR&#x60; logic is used for evaluating exceptions when more than one exception list is assigned to a rule. To use the &#x60;AND&#x60; operator, you can define multiple clauses (&#x60;entries&#x60;) in a single exception item.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Exception list&#x27;s properties`,
        type: 'Body',
        schema: CreateExceptionList_Body,
      },
    ],
    response: Security_Exceptions_API_ExceptionList,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 409,
        description: `Exception list already exists response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'put',
    path: '/api/exception_lists',
    alias: 'UpdateExceptionList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update an exception list using the &#x60;id&#x60; or &#x60;list_id&#x60; field.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Exception list&#x27;s properties`,
        type: 'Body',
        schema: UpdateExceptionList_Body,
      },
    ],
    response: Security_Exceptions_API_ExceptionList,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Exception list not found response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/exception_lists/_duplicate',
    alias: 'DuplicateExceptionList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists/_duplicate&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Duplicate an existing exception list.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'list_id',
        type: 'Query',
        schema: z.string().min(1),
      },
      {
        name: 'namespace_type',
        type: 'Query',
        schema: z.enum(['agnostic', 'single']),
      },
      {
        name: 'include_expired_exceptions',
        type: 'Query',
        schema: z.enum(['true', 'false']).default('true'),
      },
    ],
    response: Security_Exceptions_API_ExceptionList,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Exception list not found`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 405,
        description: `Exception list to duplicate not found response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/exception_lists/_export',
    alias: 'ExportExceptionList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists/_export&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Export an exception list and its associated items to an NDJSON file.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1),
      },
      {
        name: 'list_id',
        type: 'Query',
        schema: z.string().min(1),
      },
      {
        name: 'namespace_type',
        type: 'Query',
        schema: z.enum(['agnostic', 'single']),
      },
      {
        name: 'include_expired_exceptions',
        type: 'Query',
        schema: z.enum(['true', 'false']).default('true'),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Exception list not found response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/exception_lists/_find',
    alias: 'FindExceptionLists',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all exception list containers.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'namespace_type',
        type: 'Query',
        schema: z
          .array(Security_Exceptions_API_ExceptionNamespaceType)
          .optional()
          .default(['single']),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(1).optional(),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().gte(1).optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['desc', 'asc']).optional(),
      },
    ],
    response: z
      .object({
        data: z.array(Security_Exceptions_API_ExceptionList),
        page: z.number().int().gte(1),
        per_page: z.number().int().gte(1),
        total: z.number().int().gte(0),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/exception_lists/_import',
    alias: 'ImportExceptionList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists/_import&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Import an exception list and its associated items from an NDJSON file.`,
    requestFormat: 'form-data',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z
          .object({ file: z.instanceof(File) })
          .partial()
          .passthrough(),
      },
      {
        name: 'overwrite',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'as_new_list',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z
      .object({
        errors: Security_Exceptions_API_ExceptionListsImportBulkErrorArray,
        success: z.boolean(),
        success_count: z.number().int().gte(0),
        success_count_exception_list_items: z.number().int().gte(0),
        success_count_exception_lists: z.number().int().gte(0),
        success_exception_list_items: z.boolean(),
        success_exception_lists: z.boolean(),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/exception_lists/items',
    alias: 'DeleteExceptionListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete an exception list item using the &#x60;id&#x60; or &#x60;item_id&#x60; field.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'item_id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'namespace_type',
        type: 'Query',
        schema: z.enum(['agnostic', 'single']).optional(),
      },
    ],
    response: Security_Exceptions_API_ExceptionListItem,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Exception list item not found response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/exception_lists/items',
    alias: 'ReadExceptionListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of an exception list item using the &#x60;id&#x60; or &#x60;item_id&#x60; field.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'item_id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'namespace_type',
        type: 'Query',
        schema: z.enum(['agnostic', 'single']).optional(),
      },
    ],
    response: Security_Exceptions_API_ExceptionListItem,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Exception list item not found response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/exception_lists/items',
    alias: 'CreateExceptionListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create an exception item and associate it with the specified exception list.
&gt; info
&gt; Before creating exception items, you must create an exception list.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Exception list item&#x27;s properties`,
        type: 'Body',
        schema: CreateExceptionListItem_Body,
      },
    ],
    response: Security_Exceptions_API_ExceptionListItem,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 409,
        description: `Exception list item already exists response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'put',
    path: '/api/exception_lists/items',
    alias: 'UpdateExceptionListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update an exception list item using the &#x60;id&#x60; or &#x60;item_id&#x60; field.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Exception list item&#x27;s properties`,
        type: 'Body',
        schema: UpdateExceptionListItem_Body,
      },
    ],
    response: Security_Exceptions_API_ExceptionListItem,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Exception list item not found response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/exception_lists/items/_find',
    alias: 'FindExceptionListItems',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists/items/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all exception list items in the specified list.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'list_id',
        type: 'Query',
        schema: z.array(Security_Exceptions_API_ExceptionListHumanId),
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.array(Security_Exceptions_API_NonEmptyString).optional().default([]),
      },
      {
        name: 'namespace_type',
        type: 'Query',
        schema: z
          .array(Security_Exceptions_API_ExceptionNamespaceType)
          .optional()
          .default(['single']),
      },
      {
        name: 'search',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(0).optional(),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().gte(0).optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['desc', 'asc']).optional(),
      },
    ],
    response: z
      .object({
        data: z.array(Security_Exceptions_API_ExceptionListItem),
        page: z.number().int().gte(1),
        per_page: z.number().int().gte(1),
        pit: z.string().optional(),
        total: z.number().int().gte(0),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Exception list not found response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/exception_lists/summary',
    alias: 'ReadExceptionListSummary',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exception_lists/summary&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a summary of the specified exception list.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'list_id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'namespace_type',
        type: 'Query',
        schema: z.enum(['agnostic', 'single']).optional(),
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z
      .object({
        linux: z.number().int().gte(0),
        macos: z.number().int().gte(0),
        total: z.number().int().gte(0),
        windows: z.number().int().gte(0),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Exception list not found response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/exceptions/shared',
    alias: 'CreateSharedExceptionList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/exceptions/shared&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

An exception list groups exception items and can be associated with detection rules. A shared exception list can apply to multiple detection rules.
&gt; info
&gt; All exception items added to the same list are evaluated using &#x60;OR&#x60; logic. That is, if any of the items in a list evaluate to &#x60;true&#x60;, the exception prevents the rule from generating an alert. Likewise, &#x60;OR&#x60; logic is used for evaluating exceptions when more than one exception list is assigned to a rule. To use the &#x60;AND&#x60; operator, you can define multiple clauses (&#x60;entries&#x60;) in a single exception item.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: CreateSharedExceptionList_Body,
      },
    ],
    response: Security_Exceptions_API_ExceptionList,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Exceptions_API_PlatformErrorResponse,
          Security_Exceptions_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Exceptions_API_PlatformErrorResponse,
      },
      {
        status: 409,
        description: `Exception list already exists response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Exceptions_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/features',
    alias: 'get-features',
    description: `Get information about all Kibana features. Features are used by spaces and security to refine and secure access to Kibana.
`,
    requestFormat: 'json',
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/fleet/agent_download_sources',
    alias: 'get-fleet-agent-download-sources',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_download_sources&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agent-policies-read OR fleet-settings-read.`,
    requestFormat: 'json',
    response: z.object({
      items: z.array(
        z.object({
          host: z.string().url(),
          id: z.string(),
          is_default: z.boolean().optional().default(false),
          name: z.string(),
          proxy_id: z.string().nullish(),
          secrets: z
            .object({
              ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
            })
            .partial()
            .optional(),
          ssl: z
            .object({
              certificate: z.string(),
              certificate_authorities: z.array(z.string()),
              key: z.string(),
            })
            .partial()
            .optional(),
        })
      ),
      page: z.number(),
      perPage: z.number(),
      total: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agent_download_sources',
    alias: 'post-fleet-agent-download-sources',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_download_sources&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agent_download_sources_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        host: z.string().url(),
        id: z.string(),
        is_default: z.boolean().optional().default(false),
        name: z.string(),
        proxy_id: z.string().nullish(),
        secrets: z
          .object({
            ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
          })
          .partial()
          .optional(),
        ssl: z
          .object({
            certificate: z.string(),
            certificate_authorities: z.array(z.string()),
            key: z.string(),
          })
          .partial()
          .optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/agent_download_sources/:sourceId',
    alias: 'delete-fleet-agent-download-sources-sourceid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_download_sources/{sourceId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete an agent binary download source by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'sourceId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ id: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agent_download_sources/:sourceId',
    alias: 'get-fleet-agent-download-sources-sourceid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_download_sources/{sourceId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get an agent binary download source by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-read OR fleet-settings-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'sourceId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        host: z.string().url(),
        id: z.string(),
        is_default: z.boolean().optional().default(false),
        name: z.string(),
        proxy_id: z.string().nullish(),
        secrets: z
          .object({
            ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
          })
          .partial()
          .optional(),
        ssl: z
          .object({
            certificate: z.string(),
            certificate_authorities: z.array(z.string()),
            key: z.string(),
          })
          .partial()
          .optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/fleet/agent_download_sources/:sourceId',
    alias: 'put-fleet-agent-download-sources-sourceid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_download_sources/{sourceId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update an agent binary download source by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agent_download_sources_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'sourceId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        host: z.string().url(),
        id: z.string(),
        is_default: z.boolean().optional().default(false),
        name: z.string(),
        proxy_id: z.string().nullish(),
        secrets: z
          .object({
            ssl: z.object({ key: z.union([z.object({ id: z.string() }), z.string()]) }).partial(),
          })
          .partial()
          .optional(),
        ssl: z
          .object({
            certificate: z.string(),
            certificate_authorities: z.array(z.string()),
            key: z.string(),
          })
          .partial()
          .optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agent_policies',
    alias: 'get-fleet-agent-policies',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agent-policies-read OR fleet-agents-read OR fleet-setup.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'page',
        type: 'Query',
        schema: z.number().optional(),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().optional(),
      },
      {
        name: 'sortField',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['desc', 'asc']).optional(),
      },
      {
        name: 'showUpgradeable',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'kuery',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'noAgentCount',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'withAgentCount',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'full',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['simplified', 'legacy']).optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          advanced_settings: z
            .object({
              agent_download_target_directory: z.unknown().nullable(),
              agent_download_timeout: z.unknown().nullable(),
              agent_limits_go_max_procs: z.unknown().nullable(),
              agent_logging_files_interval: z.unknown().nullable(),
              agent_logging_files_keepfiles: z.unknown().nullable(),
              agent_logging_files_rotateeverybytes: z.unknown().nullable(),
              agent_logging_level: z.unknown().nullable(),
              agent_logging_metrics_period: z.unknown().nullable(),
              agent_logging_to_files: z.unknown().nullable(),
              agent_monitoring_runtime_experimental: z.unknown().nullable(),
            })
            .partial()
            .optional(),
          agent_features: z.array(z.object({ enabled: z.boolean(), name: z.string() })).optional(),
          agentless: z
            .object({
              cloud_connectors: z.object({
                enabled: z.boolean(),
                target_csp: z.string().optional(),
              }),
              resources: z
                .object({ requests: z.object({ cpu: z.string(), memory: z.string() }).partial() })
                .partial(),
            })
            .partial()
            .optional(),
          agents: z.number().optional(),
          data_output_id: z.string().nullish(),
          description: z.string().optional(),
          download_source_id: z.string().nullish(),
          fleet_server_host_id: z.string().nullish(),
          global_data_tags: z
            .array(z.object({ name: z.string(), value: z.union([z.string(), z.number()]) }))
            .optional(),
          has_fleet_server: z.boolean().optional(),
          id: z.string(),
          inactivity_timeout: z.number().gte(0).optional().default(1209600),
          is_default: z.boolean().optional(),
          is_default_fleet_server: z.boolean().optional(),
          is_managed: z.boolean(),
          is_preconfigured: z.boolean().optional(),
          is_protected: z.boolean(),
          keep_monitoring_alive: z.boolean().nullish().default(false),
          monitoring_diagnostics: z
            .object({
              limit: z.object({ burst: z.number(), interval: z.string() }).partial(),
              uploader: z
                .object({ init_dur: z.string(), max_dur: z.string(), max_retries: z.number() })
                .partial(),
            })
            .partial()
            .optional(),
          monitoring_enabled: z.array(z.enum(['logs', 'metrics', 'traces'])).optional(),
          monitoring_http: z
            .object({
              buffer: z.object({ enabled: z.boolean().default(false) }).partial(),
              enabled: z.boolean(),
              host: z.string(),
              port: z.number().gte(0).lte(65353),
            })
            .partial()
            .optional(),
          monitoring_output_id: z.string().nullish(),
          monitoring_pprof_enabled: z.boolean().optional(),
          name: z.string().min(1),
          namespace: z.string().min(1),
          overrides: z.object({}).partial().passthrough().nullish(),
          package_policies: z
            .union([
              z.array(z.string()),
              z.array(
                z.object({
                  additional_datastreams_permissions: z.array(z.string()).nullish(),
                  agents: z.number().optional(),
                  created_at: z.string(),
                  created_by: z.string(),
                  description: z.string().optional(),
                  elasticsearch: z
                    .object({
                      privileges: z
                        .object({ cluster: z.array(z.string()) })
                        .partial()
                        .passthrough(),
                    })
                    .partial()
                    .passthrough()
                    .optional(),
                  enabled: z.boolean(),
                  id: z.string(),
                  inputs: z.union([
                    z.array(
                      z.object({
                        compiled_input: z.unknown(),
                        config: z
                          .record(
                            z.object({
                              frozen: z.boolean().optional(),
                              type: z.string().optional(),
                              value: z.unknown(),
                            })
                          )
                          .optional(),
                        enabled: z.boolean(),
                        id: z.string().optional(),
                        keep_enabled: z.boolean().optional(),
                        policy_template: z.string().optional(),
                        streams: z.array(
                          z.object({
                            compiled_stream: z.unknown(),
                            config: z
                              .record(
                                z.object({
                                  frozen: z.boolean().optional(),
                                  type: z.string().optional(),
                                  value: z.unknown(),
                                })
                              )
                              .optional(),
                            data_stream: z.object({
                              dataset: z.string(),
                              elasticsearch: z
                                .object({
                                  dynamic_dataset: z.boolean(),
                                  dynamic_namespace: z.boolean(),
                                  privileges: z.object({ indices: z.array(z.string()) }).partial(),
                                })
                                .partial()
                                .optional(),
                              type: z.string(),
                            }),
                            enabled: z.boolean(),
                            id: z.string().optional(),
                            keep_enabled: z.boolean().optional(),
                            release: z.enum(['ga', 'beta', 'experimental']).optional(),
                            vars: z
                              .record(
                                z.object({
                                  frozen: z.boolean().optional(),
                                  type: z.string().optional(),
                                  value: z.unknown(),
                                })
                              )
                              .optional(),
                          })
                        ),
                        type: z.string(),
                        vars: z
                          .record(
                            z.object({
                              frozen: z.boolean().optional(),
                              type: z.string().optional(),
                              value: z.unknown(),
                            })
                          )
                          .optional(),
                      })
                    ),
                    z.record(
                      z
                        .object({
                          enabled: z.boolean(),
                          streams: z.record(
                            z
                              .object({
                                enabled: z.boolean(),
                                vars: z.record(
                                  z
                                    .union([
                                      z.boolean(),
                                      z.string(),
                                      z.number(),
                                      z.array(z.string()),
                                      z.array(z.number()),
                                      z.object({ id: z.string(), isSecretRef: z.boolean() }),
                                    ])
                                    .nullable()
                                ),
                              })
                              .partial()
                          ),
                          vars: z.record(
                            z
                              .union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({ id: z.string(), isSecretRef: z.boolean() }),
                              ])
                              .nullable()
                          ),
                        })
                        .partial()
                    ),
                  ]),
                  is_managed: z.boolean().optional(),
                  name: z.string(),
                  namespace: z.string().optional(),
                  output_id: z.string().nullish(),
                  overrides: z
                    .object({ inputs: z.object({}).partial().passthrough() })
                    .partial()
                    .nullish(),
                  package: z
                    .object({
                      experimental_data_stream_features: z
                        .array(
                          z.object({
                            data_stream: z.string(),
                            features: z
                              .object({
                                doc_value_only_numeric: z.boolean(),
                                doc_value_only_other: z.boolean(),
                                synthetic_source: z.boolean(),
                                tsdb: z.boolean(),
                              })
                              .partial(),
                          })
                        )
                        .optional(),
                      name: z.string(),
                      requires_root: z.boolean().optional(),
                      title: z.string().optional(),
                      version: z.string(),
                    })
                    .optional(),
                  policy_id: z.string().nullish(),
                  policy_ids: z.array(z.string()).optional(),
                  revision: z.number(),
                  secret_references: z.array(z.object({ id: z.string() })).optional(),
                  spaceIds: z.array(z.string()).optional(),
                  supports_agentless: z.boolean().nullish().default(false),
                  updated_at: z.string(),
                  updated_by: z.string(),
                  vars: z
                    .union([
                      z.record(
                        z.object({
                          frozen: z.boolean().optional(),
                          type: z.string().optional(),
                          value: z.unknown(),
                        })
                      ),
                      z.record(
                        z
                          .union([
                            z.boolean(),
                            z.string(),
                            z.number(),
                            z.array(z.string()),
                            z.array(z.number()),
                            z.object({ id: z.string(), isSecretRef: z.boolean() }),
                          ])
                          .nullable()
                      ),
                    ])
                    .optional(),
                  version: z.string().optional(),
                })
              ),
            ])
            .optional(),
          required_versions: z
            .array(z.object({ percentage: z.number().gte(0).lte(100), version: z.string() }))
            .nullish(),
          revision: z.number(),
          schema_version: z.string().optional(),
          space_ids: z.array(z.string()).optional(),
          status: z.enum(['active', 'inactive']),
          supports_agentless: z.boolean().nullish().default(false),
          unenroll_timeout: z.number().gte(0).optional(),
          unprivileged_agents: z.number().optional(),
          updated_at: z.string(),
          updated_by: z.string(),
          version: z.string().optional(),
        })
      ),
      page: z.number(),
      perPage: z.number(),
      total: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agent_policies',
    alias: 'post-fleet-agent-policies',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agent_policies_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'sys_monitoring',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({
      item: z.object({
        advanced_settings: z
          .object({
            agent_download_target_directory: z.unknown().nullable(),
            agent_download_timeout: z.unknown().nullable(),
            agent_limits_go_max_procs: z.unknown().nullable(),
            agent_logging_files_interval: z.unknown().nullable(),
            agent_logging_files_keepfiles: z.unknown().nullable(),
            agent_logging_files_rotateeverybytes: z.unknown().nullable(),
            agent_logging_level: z.unknown().nullable(),
            agent_logging_metrics_period: z.unknown().nullable(),
            agent_logging_to_files: z.unknown().nullable(),
            agent_monitoring_runtime_experimental: z.unknown().nullable(),
          })
          .partial()
          .optional(),
        agent_features: z.array(z.object({ enabled: z.boolean(), name: z.string() })).optional(),
        agentless: z
          .object({
            cloud_connectors: z.object({ enabled: z.boolean(), target_csp: z.string().optional() }),
            resources: z
              .object({ requests: z.object({ cpu: z.string(), memory: z.string() }).partial() })
              .partial(),
          })
          .partial()
          .optional(),
        agents: z.number().optional(),
        data_output_id: z.string().nullish(),
        description: z.string().optional(),
        download_source_id: z.string().nullish(),
        fleet_server_host_id: z.string().nullish(),
        global_data_tags: z
          .array(z.object({ name: z.string(), value: z.union([z.string(), z.number()]) }))
          .optional(),
        has_fleet_server: z.boolean().optional(),
        id: z.string(),
        inactivity_timeout: z.number().gte(0).optional().default(1209600),
        is_default: z.boolean().optional(),
        is_default_fleet_server: z.boolean().optional(),
        is_managed: z.boolean(),
        is_preconfigured: z.boolean().optional(),
        is_protected: z.boolean(),
        keep_monitoring_alive: z.boolean().nullish().default(false),
        monitoring_diagnostics: z
          .object({
            limit: z.object({ burst: z.number(), interval: z.string() }).partial(),
            uploader: z
              .object({ init_dur: z.string(), max_dur: z.string(), max_retries: z.number() })
              .partial(),
          })
          .partial()
          .optional(),
        monitoring_enabled: z.array(z.enum(['logs', 'metrics', 'traces'])).optional(),
        monitoring_http: z
          .object({
            buffer: z.object({ enabled: z.boolean().default(false) }).partial(),
            enabled: z.boolean(),
            host: z.string(),
            port: z.number().gte(0).lte(65353),
          })
          .partial()
          .optional(),
        monitoring_output_id: z.string().nullish(),
        monitoring_pprof_enabled: z.boolean().optional(),
        name: z.string().min(1),
        namespace: z.string().min(1),
        overrides: z.object({}).partial().passthrough().nullish(),
        package_policies: z
          .union([
            z.array(z.string()),
            z.array(
              z.object({
                additional_datastreams_permissions: z.array(z.string()).nullish(),
                agents: z.number().optional(),
                created_at: z.string(),
                created_by: z.string(),
                description: z.string().optional(),
                elasticsearch: z
                  .object({
                    privileges: z
                      .object({ cluster: z.array(z.string()) })
                      .partial()
                      .passthrough(),
                  })
                  .partial()
                  .passthrough()
                  .optional(),
                enabled: z.boolean(),
                id: z.string(),
                inputs: z.union([
                  z.array(
                    z.object({
                      compiled_input: z.unknown(),
                      config: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                      enabled: z.boolean(),
                      id: z.string().optional(),
                      keep_enabled: z.boolean().optional(),
                      policy_template: z.string().optional(),
                      streams: z.array(
                        z.object({
                          compiled_stream: z.unknown(),
                          config: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                          data_stream: z.object({
                            dataset: z.string(),
                            elasticsearch: z
                              .object({
                                dynamic_dataset: z.boolean(),
                                dynamic_namespace: z.boolean(),
                                privileges: z.object({ indices: z.array(z.string()) }).partial(),
                              })
                              .partial()
                              .optional(),
                            type: z.string(),
                          }),
                          enabled: z.boolean(),
                          id: z.string().optional(),
                          keep_enabled: z.boolean().optional(),
                          release: z.enum(['ga', 'beta', 'experimental']).optional(),
                          vars: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                        })
                      ),
                      type: z.string(),
                      vars: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                    })
                  ),
                  z.record(
                    z
                      .object({
                        enabled: z.boolean(),
                        streams: z.record(
                          z
                            .object({
                              enabled: z.boolean(),
                              vars: z.record(
                                z
                                  .union([
                                    z.boolean(),
                                    z.string(),
                                    z.number(),
                                    z.array(z.string()),
                                    z.array(z.number()),
                                    z.object({ id: z.string(), isSecretRef: z.boolean() }),
                                  ])
                                  .nullable()
                              ),
                            })
                            .partial()
                        ),
                        vars: z.record(
                          z
                            .union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({ id: z.string(), isSecretRef: z.boolean() }),
                            ])
                            .nullable()
                        ),
                      })
                      .partial()
                  ),
                ]),
                is_managed: z.boolean().optional(),
                name: z.string(),
                namespace: z.string().optional(),
                output_id: z.string().nullish(),
                overrides: z
                  .object({ inputs: z.object({}).partial().passthrough() })
                  .partial()
                  .nullish(),
                package: z
                  .object({
                    experimental_data_stream_features: z
                      .array(
                        z.object({
                          data_stream: z.string(),
                          features: z
                            .object({
                              doc_value_only_numeric: z.boolean(),
                              doc_value_only_other: z.boolean(),
                              synthetic_source: z.boolean(),
                              tsdb: z.boolean(),
                            })
                            .partial(),
                        })
                      )
                      .optional(),
                    name: z.string(),
                    requires_root: z.boolean().optional(),
                    title: z.string().optional(),
                    version: z.string(),
                  })
                  .optional(),
                policy_id: z.string().nullish(),
                policy_ids: z.array(z.string()).optional(),
                revision: z.number(),
                secret_references: z.array(z.object({ id: z.string() })).optional(),
                spaceIds: z.array(z.string()).optional(),
                supports_agentless: z.boolean().nullish().default(false),
                updated_at: z.string(),
                updated_by: z.string(),
                vars: z
                  .union([
                    z.record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    ),
                    z.record(
                      z
                        .union([
                          z.boolean(),
                          z.string(),
                          z.number(),
                          z.array(z.string()),
                          z.array(z.number()),
                          z.object({ id: z.string(), isSecretRef: z.boolean() }),
                        ])
                        .nullable()
                    ),
                  ])
                  .optional(),
                version: z.string().optional(),
              })
            ),
          ])
          .optional(),
        required_versions: z
          .array(z.object({ percentage: z.number().gte(0).lte(100), version: z.string() }))
          .nullish(),
        revision: z.number(),
        schema_version: z.string().optional(),
        space_ids: z.array(z.string()).optional(),
        status: z.enum(['active', 'inactive']),
        supports_agentless: z.boolean().nullish().default(false),
        unenroll_timeout: z.number().gte(0).optional(),
        unprivileged_agents: z.number().optional(),
        updated_at: z.string(),
        updated_by: z.string(),
        version: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agent_policies/_bulk_get',
    alias: 'post-fleet-agent-policies-bulk-get',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies/_bulk_get&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agent-policies-read OR fleet-agents-read OR fleet-setup.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agent_policies_bulk_get_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['simplified', 'legacy']).optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          advanced_settings: z
            .object({
              agent_download_target_directory: z.unknown().nullable(),
              agent_download_timeout: z.unknown().nullable(),
              agent_limits_go_max_procs: z.unknown().nullable(),
              agent_logging_files_interval: z.unknown().nullable(),
              agent_logging_files_keepfiles: z.unknown().nullable(),
              agent_logging_files_rotateeverybytes: z.unknown().nullable(),
              agent_logging_level: z.unknown().nullable(),
              agent_logging_metrics_period: z.unknown().nullable(),
              agent_logging_to_files: z.unknown().nullable(),
              agent_monitoring_runtime_experimental: z.unknown().nullable(),
            })
            .partial()
            .optional(),
          agent_features: z.array(z.object({ enabled: z.boolean(), name: z.string() })).optional(),
          agentless: z
            .object({
              cloud_connectors: z.object({
                enabled: z.boolean(),
                target_csp: z.string().optional(),
              }),
              resources: z
                .object({ requests: z.object({ cpu: z.string(), memory: z.string() }).partial() })
                .partial(),
            })
            .partial()
            .optional(),
          agents: z.number().optional(),
          data_output_id: z.string().nullish(),
          description: z.string().optional(),
          download_source_id: z.string().nullish(),
          fleet_server_host_id: z.string().nullish(),
          global_data_tags: z
            .array(z.object({ name: z.string(), value: z.union([z.string(), z.number()]) }))
            .optional(),
          has_fleet_server: z.boolean().optional(),
          id: z.string(),
          inactivity_timeout: z.number().gte(0).optional().default(1209600),
          is_default: z.boolean().optional(),
          is_default_fleet_server: z.boolean().optional(),
          is_managed: z.boolean(),
          is_preconfigured: z.boolean().optional(),
          is_protected: z.boolean(),
          keep_monitoring_alive: z.boolean().nullish().default(false),
          monitoring_diagnostics: z
            .object({
              limit: z.object({ burst: z.number(), interval: z.string() }).partial(),
              uploader: z
                .object({ init_dur: z.string(), max_dur: z.string(), max_retries: z.number() })
                .partial(),
            })
            .partial()
            .optional(),
          monitoring_enabled: z.array(z.enum(['logs', 'metrics', 'traces'])).optional(),
          monitoring_http: z
            .object({
              buffer: z.object({ enabled: z.boolean().default(false) }).partial(),
              enabled: z.boolean(),
              host: z.string(),
              port: z.number().gte(0).lte(65353),
            })
            .partial()
            .optional(),
          monitoring_output_id: z.string().nullish(),
          monitoring_pprof_enabled: z.boolean().optional(),
          name: z.string().min(1),
          namespace: z.string().min(1),
          overrides: z.object({}).partial().passthrough().nullish(),
          package_policies: z
            .union([
              z.array(z.string()),
              z.array(
                z.object({
                  additional_datastreams_permissions: z.array(z.string()).nullish(),
                  agents: z.number().optional(),
                  created_at: z.string(),
                  created_by: z.string(),
                  description: z.string().optional(),
                  elasticsearch: z
                    .object({
                      privileges: z
                        .object({ cluster: z.array(z.string()) })
                        .partial()
                        .passthrough(),
                    })
                    .partial()
                    .passthrough()
                    .optional(),
                  enabled: z.boolean(),
                  id: z.string(),
                  inputs: z.union([
                    z.array(
                      z.object({
                        compiled_input: z.unknown(),
                        config: z
                          .record(
                            z.object({
                              frozen: z.boolean().optional(),
                              type: z.string().optional(),
                              value: z.unknown(),
                            })
                          )
                          .optional(),
                        enabled: z.boolean(),
                        id: z.string().optional(),
                        keep_enabled: z.boolean().optional(),
                        policy_template: z.string().optional(),
                        streams: z.array(
                          z.object({
                            compiled_stream: z.unknown(),
                            config: z
                              .record(
                                z.object({
                                  frozen: z.boolean().optional(),
                                  type: z.string().optional(),
                                  value: z.unknown(),
                                })
                              )
                              .optional(),
                            data_stream: z.object({
                              dataset: z.string(),
                              elasticsearch: z
                                .object({
                                  dynamic_dataset: z.boolean(),
                                  dynamic_namespace: z.boolean(),
                                  privileges: z.object({ indices: z.array(z.string()) }).partial(),
                                })
                                .partial()
                                .optional(),
                              type: z.string(),
                            }),
                            enabled: z.boolean(),
                            id: z.string().optional(),
                            keep_enabled: z.boolean().optional(),
                            release: z.enum(['ga', 'beta', 'experimental']).optional(),
                            vars: z
                              .record(
                                z.object({
                                  frozen: z.boolean().optional(),
                                  type: z.string().optional(),
                                  value: z.unknown(),
                                })
                              )
                              .optional(),
                          })
                        ),
                        type: z.string(),
                        vars: z
                          .record(
                            z.object({
                              frozen: z.boolean().optional(),
                              type: z.string().optional(),
                              value: z.unknown(),
                            })
                          )
                          .optional(),
                      })
                    ),
                    z.record(
                      z
                        .object({
                          enabled: z.boolean(),
                          streams: z.record(
                            z
                              .object({
                                enabled: z.boolean(),
                                vars: z.record(
                                  z
                                    .union([
                                      z.boolean(),
                                      z.string(),
                                      z.number(),
                                      z.array(z.string()),
                                      z.array(z.number()),
                                      z.object({ id: z.string(), isSecretRef: z.boolean() }),
                                    ])
                                    .nullable()
                                ),
                              })
                              .partial()
                          ),
                          vars: z.record(
                            z
                              .union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({ id: z.string(), isSecretRef: z.boolean() }),
                              ])
                              .nullable()
                          ),
                        })
                        .partial()
                    ),
                  ]),
                  is_managed: z.boolean().optional(),
                  name: z.string(),
                  namespace: z.string().optional(),
                  output_id: z.string().nullish(),
                  overrides: z
                    .object({ inputs: z.object({}).partial().passthrough() })
                    .partial()
                    .nullish(),
                  package: z
                    .object({
                      experimental_data_stream_features: z
                        .array(
                          z.object({
                            data_stream: z.string(),
                            features: z
                              .object({
                                doc_value_only_numeric: z.boolean(),
                                doc_value_only_other: z.boolean(),
                                synthetic_source: z.boolean(),
                                tsdb: z.boolean(),
                              })
                              .partial(),
                          })
                        )
                        .optional(),
                      name: z.string(),
                      requires_root: z.boolean().optional(),
                      title: z.string().optional(),
                      version: z.string(),
                    })
                    .optional(),
                  policy_id: z.string().nullish(),
                  policy_ids: z.array(z.string()).optional(),
                  revision: z.number(),
                  secret_references: z.array(z.object({ id: z.string() })).optional(),
                  spaceIds: z.array(z.string()).optional(),
                  supports_agentless: z.boolean().nullish().default(false),
                  updated_at: z.string(),
                  updated_by: z.string(),
                  vars: z
                    .union([
                      z.record(
                        z.object({
                          frozen: z.boolean().optional(),
                          type: z.string().optional(),
                          value: z.unknown(),
                        })
                      ),
                      z.record(
                        z
                          .union([
                            z.boolean(),
                            z.string(),
                            z.number(),
                            z.array(z.string()),
                            z.array(z.number()),
                            z.object({ id: z.string(), isSecretRef: z.boolean() }),
                          ])
                          .nullable()
                      ),
                    ])
                    .optional(),
                  version: z.string().optional(),
                })
              ),
            ])
            .optional(),
          required_versions: z
            .array(z.object({ percentage: z.number().gte(0).lte(100), version: z.string() }))
            .nullish(),
          revision: z.number(),
          schema_version: z.string().optional(),
          space_ids: z.array(z.string()).optional(),
          status: z.enum(['active', 'inactive']),
          supports_agentless: z.boolean().nullish().default(false),
          unenroll_timeout: z.number().gte(0).optional(),
          unprivileged_agents: z.number().optional(),
          updated_at: z.string(),
          updated_by: z.string(),
          version: z.string().optional(),
        })
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agent_policies/:agentPolicyId',
    alias: 'get-fleet-agent-policies-agentpolicyid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies/{agentPolicyId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get an agent policy by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-read OR fleet-agents-read OR fleet-setup.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'agentPolicyId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['simplified', 'legacy']).optional(),
      },
    ],
    response: z.object({
      item: z.object({
        advanced_settings: z
          .object({
            agent_download_target_directory: z.unknown().nullable(),
            agent_download_timeout: z.unknown().nullable(),
            agent_limits_go_max_procs: z.unknown().nullable(),
            agent_logging_files_interval: z.unknown().nullable(),
            agent_logging_files_keepfiles: z.unknown().nullable(),
            agent_logging_files_rotateeverybytes: z.unknown().nullable(),
            agent_logging_level: z.unknown().nullable(),
            agent_logging_metrics_period: z.unknown().nullable(),
            agent_logging_to_files: z.unknown().nullable(),
            agent_monitoring_runtime_experimental: z.unknown().nullable(),
          })
          .partial()
          .optional(),
        agent_features: z.array(z.object({ enabled: z.boolean(), name: z.string() })).optional(),
        agentless: z
          .object({
            cloud_connectors: z.object({ enabled: z.boolean(), target_csp: z.string().optional() }),
            resources: z
              .object({ requests: z.object({ cpu: z.string(), memory: z.string() }).partial() })
              .partial(),
          })
          .partial()
          .optional(),
        agents: z.number().optional(),
        data_output_id: z.string().nullish(),
        description: z.string().optional(),
        download_source_id: z.string().nullish(),
        fleet_server_host_id: z.string().nullish(),
        global_data_tags: z
          .array(z.object({ name: z.string(), value: z.union([z.string(), z.number()]) }))
          .optional(),
        has_fleet_server: z.boolean().optional(),
        id: z.string(),
        inactivity_timeout: z.number().gte(0).optional().default(1209600),
        is_default: z.boolean().optional(),
        is_default_fleet_server: z.boolean().optional(),
        is_managed: z.boolean(),
        is_preconfigured: z.boolean().optional(),
        is_protected: z.boolean(),
        keep_monitoring_alive: z.boolean().nullish().default(false),
        monitoring_diagnostics: z
          .object({
            limit: z.object({ burst: z.number(), interval: z.string() }).partial(),
            uploader: z
              .object({ init_dur: z.string(), max_dur: z.string(), max_retries: z.number() })
              .partial(),
          })
          .partial()
          .optional(),
        monitoring_enabled: z.array(z.enum(['logs', 'metrics', 'traces'])).optional(),
        monitoring_http: z
          .object({
            buffer: z.object({ enabled: z.boolean().default(false) }).partial(),
            enabled: z.boolean(),
            host: z.string(),
            port: z.number().gte(0).lte(65353),
          })
          .partial()
          .optional(),
        monitoring_output_id: z.string().nullish(),
        monitoring_pprof_enabled: z.boolean().optional(),
        name: z.string().min(1),
        namespace: z.string().min(1),
        overrides: z.object({}).partial().passthrough().nullish(),
        package_policies: z
          .union([
            z.array(z.string()),
            z.array(
              z.object({
                additional_datastreams_permissions: z.array(z.string()).nullish(),
                agents: z.number().optional(),
                created_at: z.string(),
                created_by: z.string(),
                description: z.string().optional(),
                elasticsearch: z
                  .object({
                    privileges: z
                      .object({ cluster: z.array(z.string()) })
                      .partial()
                      .passthrough(),
                  })
                  .partial()
                  .passthrough()
                  .optional(),
                enabled: z.boolean(),
                id: z.string(),
                inputs: z.union([
                  z.array(
                    z.object({
                      compiled_input: z.unknown(),
                      config: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                      enabled: z.boolean(),
                      id: z.string().optional(),
                      keep_enabled: z.boolean().optional(),
                      policy_template: z.string().optional(),
                      streams: z.array(
                        z.object({
                          compiled_stream: z.unknown(),
                          config: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                          data_stream: z.object({
                            dataset: z.string(),
                            elasticsearch: z
                              .object({
                                dynamic_dataset: z.boolean(),
                                dynamic_namespace: z.boolean(),
                                privileges: z.object({ indices: z.array(z.string()) }).partial(),
                              })
                              .partial()
                              .optional(),
                            type: z.string(),
                          }),
                          enabled: z.boolean(),
                          id: z.string().optional(),
                          keep_enabled: z.boolean().optional(),
                          release: z.enum(['ga', 'beta', 'experimental']).optional(),
                          vars: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                        })
                      ),
                      type: z.string(),
                      vars: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                    })
                  ),
                  z.record(
                    z
                      .object({
                        enabled: z.boolean(),
                        streams: z.record(
                          z
                            .object({
                              enabled: z.boolean(),
                              vars: z.record(
                                z
                                  .union([
                                    z.boolean(),
                                    z.string(),
                                    z.number(),
                                    z.array(z.string()),
                                    z.array(z.number()),
                                    z.object({ id: z.string(), isSecretRef: z.boolean() }),
                                  ])
                                  .nullable()
                              ),
                            })
                            .partial()
                        ),
                        vars: z.record(
                          z
                            .union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({ id: z.string(), isSecretRef: z.boolean() }),
                            ])
                            .nullable()
                        ),
                      })
                      .partial()
                  ),
                ]),
                is_managed: z.boolean().optional(),
                name: z.string(),
                namespace: z.string().optional(),
                output_id: z.string().nullish(),
                overrides: z
                  .object({ inputs: z.object({}).partial().passthrough() })
                  .partial()
                  .nullish(),
                package: z
                  .object({
                    experimental_data_stream_features: z
                      .array(
                        z.object({
                          data_stream: z.string(),
                          features: z
                            .object({
                              doc_value_only_numeric: z.boolean(),
                              doc_value_only_other: z.boolean(),
                              synthetic_source: z.boolean(),
                              tsdb: z.boolean(),
                            })
                            .partial(),
                        })
                      )
                      .optional(),
                    name: z.string(),
                    requires_root: z.boolean().optional(),
                    title: z.string().optional(),
                    version: z.string(),
                  })
                  .optional(),
                policy_id: z.string().nullish(),
                policy_ids: z.array(z.string()).optional(),
                revision: z.number(),
                secret_references: z.array(z.object({ id: z.string() })).optional(),
                spaceIds: z.array(z.string()).optional(),
                supports_agentless: z.boolean().nullish().default(false),
                updated_at: z.string(),
                updated_by: z.string(),
                vars: z
                  .union([
                    z.record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    ),
                    z.record(
                      z
                        .union([
                          z.boolean(),
                          z.string(),
                          z.number(),
                          z.array(z.string()),
                          z.array(z.number()),
                          z.object({ id: z.string(), isSecretRef: z.boolean() }),
                        ])
                        .nullable()
                    ),
                  ])
                  .optional(),
                version: z.string().optional(),
              })
            ),
          ])
          .optional(),
        required_versions: z
          .array(z.object({ percentage: z.number().gte(0).lte(100), version: z.string() }))
          .nullish(),
        revision: z.number(),
        schema_version: z.string().optional(),
        space_ids: z.array(z.string()).optional(),
        status: z.enum(['active', 'inactive']),
        supports_agentless: z.boolean().nullish().default(false),
        unenroll_timeout: z.number().gte(0).optional(),
        unprivileged_agents: z.number().optional(),
        updated_at: z.string(),
        updated_by: z.string(),
        version: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/fleet/agent_policies/:agentPolicyId',
    alias: 'put-fleet-agent-policies-agentpolicyid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies/{agentPolicyId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update an agent policy by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_fleet_agent_policies_agentpolicyid_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'agentPolicyId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['simplified', 'legacy']).optional(),
      },
    ],
    response: z.object({
      item: z.object({
        advanced_settings: z
          .object({
            agent_download_target_directory: z.unknown().nullable(),
            agent_download_timeout: z.unknown().nullable(),
            agent_limits_go_max_procs: z.unknown().nullable(),
            agent_logging_files_interval: z.unknown().nullable(),
            agent_logging_files_keepfiles: z.unknown().nullable(),
            agent_logging_files_rotateeverybytes: z.unknown().nullable(),
            agent_logging_level: z.unknown().nullable(),
            agent_logging_metrics_period: z.unknown().nullable(),
            agent_logging_to_files: z.unknown().nullable(),
            agent_monitoring_runtime_experimental: z.unknown().nullable(),
          })
          .partial()
          .optional(),
        agent_features: z.array(z.object({ enabled: z.boolean(), name: z.string() })).optional(),
        agentless: z
          .object({
            cloud_connectors: z.object({ enabled: z.boolean(), target_csp: z.string().optional() }),
            resources: z
              .object({ requests: z.object({ cpu: z.string(), memory: z.string() }).partial() })
              .partial(),
          })
          .partial()
          .optional(),
        agents: z.number().optional(),
        data_output_id: z.string().nullish(),
        description: z.string().optional(),
        download_source_id: z.string().nullish(),
        fleet_server_host_id: z.string().nullish(),
        global_data_tags: z
          .array(z.object({ name: z.string(), value: z.union([z.string(), z.number()]) }))
          .optional(),
        has_fleet_server: z.boolean().optional(),
        id: z.string(),
        inactivity_timeout: z.number().gte(0).optional().default(1209600),
        is_default: z.boolean().optional(),
        is_default_fleet_server: z.boolean().optional(),
        is_managed: z.boolean(),
        is_preconfigured: z.boolean().optional(),
        is_protected: z.boolean(),
        keep_monitoring_alive: z.boolean().nullish().default(false),
        monitoring_diagnostics: z
          .object({
            limit: z.object({ burst: z.number(), interval: z.string() }).partial(),
            uploader: z
              .object({ init_dur: z.string(), max_dur: z.string(), max_retries: z.number() })
              .partial(),
          })
          .partial()
          .optional(),
        monitoring_enabled: z.array(z.enum(['logs', 'metrics', 'traces'])).optional(),
        monitoring_http: z
          .object({
            buffer: z.object({ enabled: z.boolean().default(false) }).partial(),
            enabled: z.boolean(),
            host: z.string(),
            port: z.number().gte(0).lte(65353),
          })
          .partial()
          .optional(),
        monitoring_output_id: z.string().nullish(),
        monitoring_pprof_enabled: z.boolean().optional(),
        name: z.string().min(1),
        namespace: z.string().min(1),
        overrides: z.object({}).partial().passthrough().nullish(),
        package_policies: z
          .union([
            z.array(z.string()),
            z.array(
              z.object({
                additional_datastreams_permissions: z.array(z.string()).nullish(),
                agents: z.number().optional(),
                created_at: z.string(),
                created_by: z.string(),
                description: z.string().optional(),
                elasticsearch: z
                  .object({
                    privileges: z
                      .object({ cluster: z.array(z.string()) })
                      .partial()
                      .passthrough(),
                  })
                  .partial()
                  .passthrough()
                  .optional(),
                enabled: z.boolean(),
                id: z.string(),
                inputs: z.union([
                  z.array(
                    z.object({
                      compiled_input: z.unknown(),
                      config: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                      enabled: z.boolean(),
                      id: z.string().optional(),
                      keep_enabled: z.boolean().optional(),
                      policy_template: z.string().optional(),
                      streams: z.array(
                        z.object({
                          compiled_stream: z.unknown(),
                          config: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                          data_stream: z.object({
                            dataset: z.string(),
                            elasticsearch: z
                              .object({
                                dynamic_dataset: z.boolean(),
                                dynamic_namespace: z.boolean(),
                                privileges: z.object({ indices: z.array(z.string()) }).partial(),
                              })
                              .partial()
                              .optional(),
                            type: z.string(),
                          }),
                          enabled: z.boolean(),
                          id: z.string().optional(),
                          keep_enabled: z.boolean().optional(),
                          release: z.enum(['ga', 'beta', 'experimental']).optional(),
                          vars: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                        })
                      ),
                      type: z.string(),
                      vars: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                    })
                  ),
                  z.record(
                    z
                      .object({
                        enabled: z.boolean(),
                        streams: z.record(
                          z
                            .object({
                              enabled: z.boolean(),
                              vars: z.record(
                                z
                                  .union([
                                    z.boolean(),
                                    z.string(),
                                    z.number(),
                                    z.array(z.string()),
                                    z.array(z.number()),
                                    z.object({ id: z.string(), isSecretRef: z.boolean() }),
                                  ])
                                  .nullable()
                              ),
                            })
                            .partial()
                        ),
                        vars: z.record(
                          z
                            .union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({ id: z.string(), isSecretRef: z.boolean() }),
                            ])
                            .nullable()
                        ),
                      })
                      .partial()
                  ),
                ]),
                is_managed: z.boolean().optional(),
                name: z.string(),
                namespace: z.string().optional(),
                output_id: z.string().nullish(),
                overrides: z
                  .object({ inputs: z.object({}).partial().passthrough() })
                  .partial()
                  .nullish(),
                package: z
                  .object({
                    experimental_data_stream_features: z
                      .array(
                        z.object({
                          data_stream: z.string(),
                          features: z
                            .object({
                              doc_value_only_numeric: z.boolean(),
                              doc_value_only_other: z.boolean(),
                              synthetic_source: z.boolean(),
                              tsdb: z.boolean(),
                            })
                            .partial(),
                        })
                      )
                      .optional(),
                    name: z.string(),
                    requires_root: z.boolean().optional(),
                    title: z.string().optional(),
                    version: z.string(),
                  })
                  .optional(),
                policy_id: z.string().nullish(),
                policy_ids: z.array(z.string()).optional(),
                revision: z.number(),
                secret_references: z.array(z.object({ id: z.string() })).optional(),
                spaceIds: z.array(z.string()).optional(),
                supports_agentless: z.boolean().nullish().default(false),
                updated_at: z.string(),
                updated_by: z.string(),
                vars: z
                  .union([
                    z.record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    ),
                    z.record(
                      z
                        .union([
                          z.boolean(),
                          z.string(),
                          z.number(),
                          z.array(z.string()),
                          z.array(z.number()),
                          z.object({ id: z.string(), isSecretRef: z.boolean() }),
                        ])
                        .nullable()
                    ),
                  ])
                  .optional(),
                version: z.string().optional(),
              })
            ),
          ])
          .optional(),
        required_versions: z
          .array(z.object({ percentage: z.number().gte(0).lte(100), version: z.string() }))
          .nullish(),
        revision: z.number(),
        schema_version: z.string().optional(),
        space_ids: z.array(z.string()).optional(),
        status: z.enum(['active', 'inactive']),
        supports_agentless: z.boolean().nullish().default(false),
        unenroll_timeout: z.number().gte(0).optional(),
        unprivileged_agents: z.number().optional(),
        updated_at: z.string(),
        updated_by: z.string(),
        version: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agent_policies/:agentPolicyId/auto_upgrade_agents_status',
    alias: 'get-fleet-agent-policies-agentpolicyid-auto-upgrade-agents-status',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies/{agentPolicyId}/auto_upgrade_agents_status&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get auto upgrade agent status&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'agentPolicyId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      currentVersions: z.array(
        z.object({ agents: z.number(), failedUpgradeAgents: z.number(), version: z.string() })
      ),
      totalAgents: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agent_policies/:agentPolicyId/copy',
    alias: 'post-fleet-agent-policies-agentpolicyid-copy',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies/{agentPolicyId}/copy&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Copy an agent policy by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agent_policies_agentpolicyid_copy_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'agentPolicyId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['simplified', 'legacy']).optional(),
      },
    ],
    response: z.object({
      item: z.object({
        advanced_settings: z
          .object({
            agent_download_target_directory: z.unknown().nullable(),
            agent_download_timeout: z.unknown().nullable(),
            agent_limits_go_max_procs: z.unknown().nullable(),
            agent_logging_files_interval: z.unknown().nullable(),
            agent_logging_files_keepfiles: z.unknown().nullable(),
            agent_logging_files_rotateeverybytes: z.unknown().nullable(),
            agent_logging_level: z.unknown().nullable(),
            agent_logging_metrics_period: z.unknown().nullable(),
            agent_logging_to_files: z.unknown().nullable(),
            agent_monitoring_runtime_experimental: z.unknown().nullable(),
          })
          .partial()
          .optional(),
        agent_features: z.array(z.object({ enabled: z.boolean(), name: z.string() })).optional(),
        agentless: z
          .object({
            cloud_connectors: z.object({ enabled: z.boolean(), target_csp: z.string().optional() }),
            resources: z
              .object({ requests: z.object({ cpu: z.string(), memory: z.string() }).partial() })
              .partial(),
          })
          .partial()
          .optional(),
        agents: z.number().optional(),
        data_output_id: z.string().nullish(),
        description: z.string().optional(),
        download_source_id: z.string().nullish(),
        fleet_server_host_id: z.string().nullish(),
        global_data_tags: z
          .array(z.object({ name: z.string(), value: z.union([z.string(), z.number()]) }))
          .optional(),
        has_fleet_server: z.boolean().optional(),
        id: z.string(),
        inactivity_timeout: z.number().gte(0).optional().default(1209600),
        is_default: z.boolean().optional(),
        is_default_fleet_server: z.boolean().optional(),
        is_managed: z.boolean(),
        is_preconfigured: z.boolean().optional(),
        is_protected: z.boolean(),
        keep_monitoring_alive: z.boolean().nullish().default(false),
        monitoring_diagnostics: z
          .object({
            limit: z.object({ burst: z.number(), interval: z.string() }).partial(),
            uploader: z
              .object({ init_dur: z.string(), max_dur: z.string(), max_retries: z.number() })
              .partial(),
          })
          .partial()
          .optional(),
        monitoring_enabled: z.array(z.enum(['logs', 'metrics', 'traces'])).optional(),
        monitoring_http: z
          .object({
            buffer: z.object({ enabled: z.boolean().default(false) }).partial(),
            enabled: z.boolean(),
            host: z.string(),
            port: z.number().gte(0).lte(65353),
          })
          .partial()
          .optional(),
        monitoring_output_id: z.string().nullish(),
        monitoring_pprof_enabled: z.boolean().optional(),
        name: z.string().min(1),
        namespace: z.string().min(1),
        overrides: z.object({}).partial().passthrough().nullish(),
        package_policies: z
          .union([
            z.array(z.string()),
            z.array(
              z.object({
                additional_datastreams_permissions: z.array(z.string()).nullish(),
                agents: z.number().optional(),
                created_at: z.string(),
                created_by: z.string(),
                description: z.string().optional(),
                elasticsearch: z
                  .object({
                    privileges: z
                      .object({ cluster: z.array(z.string()) })
                      .partial()
                      .passthrough(),
                  })
                  .partial()
                  .passthrough()
                  .optional(),
                enabled: z.boolean(),
                id: z.string(),
                inputs: z.union([
                  z.array(
                    z.object({
                      compiled_input: z.unknown(),
                      config: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                      enabled: z.boolean(),
                      id: z.string().optional(),
                      keep_enabled: z.boolean().optional(),
                      policy_template: z.string().optional(),
                      streams: z.array(
                        z.object({
                          compiled_stream: z.unknown(),
                          config: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                          data_stream: z.object({
                            dataset: z.string(),
                            elasticsearch: z
                              .object({
                                dynamic_dataset: z.boolean(),
                                dynamic_namespace: z.boolean(),
                                privileges: z.object({ indices: z.array(z.string()) }).partial(),
                              })
                              .partial()
                              .optional(),
                            type: z.string(),
                          }),
                          enabled: z.boolean(),
                          id: z.string().optional(),
                          keep_enabled: z.boolean().optional(),
                          release: z.enum(['ga', 'beta', 'experimental']).optional(),
                          vars: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                        })
                      ),
                      type: z.string(),
                      vars: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                    })
                  ),
                  z.record(
                    z
                      .object({
                        enabled: z.boolean(),
                        streams: z.record(
                          z
                            .object({
                              enabled: z.boolean(),
                              vars: z.record(
                                z
                                  .union([
                                    z.boolean(),
                                    z.string(),
                                    z.number(),
                                    z.array(z.string()),
                                    z.array(z.number()),
                                    z.object({ id: z.string(), isSecretRef: z.boolean() }),
                                  ])
                                  .nullable()
                              ),
                            })
                            .partial()
                        ),
                        vars: z.record(
                          z
                            .union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({ id: z.string(), isSecretRef: z.boolean() }),
                            ])
                            .nullable()
                        ),
                      })
                      .partial()
                  ),
                ]),
                is_managed: z.boolean().optional(),
                name: z.string(),
                namespace: z.string().optional(),
                output_id: z.string().nullish(),
                overrides: z
                  .object({ inputs: z.object({}).partial().passthrough() })
                  .partial()
                  .nullish(),
                package: z
                  .object({
                    experimental_data_stream_features: z
                      .array(
                        z.object({
                          data_stream: z.string(),
                          features: z
                            .object({
                              doc_value_only_numeric: z.boolean(),
                              doc_value_only_other: z.boolean(),
                              synthetic_source: z.boolean(),
                              tsdb: z.boolean(),
                            })
                            .partial(),
                        })
                      )
                      .optional(),
                    name: z.string(),
                    requires_root: z.boolean().optional(),
                    title: z.string().optional(),
                    version: z.string(),
                  })
                  .optional(),
                policy_id: z.string().nullish(),
                policy_ids: z.array(z.string()).optional(),
                revision: z.number(),
                secret_references: z.array(z.object({ id: z.string() })).optional(),
                spaceIds: z.array(z.string()).optional(),
                supports_agentless: z.boolean().nullish().default(false),
                updated_at: z.string(),
                updated_by: z.string(),
                vars: z
                  .union([
                    z.record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    ),
                    z.record(
                      z
                        .union([
                          z.boolean(),
                          z.string(),
                          z.number(),
                          z.array(z.string()),
                          z.array(z.number()),
                          z.object({ id: z.string(), isSecretRef: z.boolean() }),
                        ])
                        .nullable()
                    ),
                  ])
                  .optional(),
                version: z.string().optional(),
              })
            ),
          ])
          .optional(),
        required_versions: z
          .array(z.object({ percentage: z.number().gte(0).lte(100), version: z.string() }))
          .nullish(),
        revision: z.number(),
        schema_version: z.string().optional(),
        space_ids: z.array(z.string()).optional(),
        status: z.enum(['active', 'inactive']),
        supports_agentless: z.boolean().nullish().default(false),
        unenroll_timeout: z.number().gte(0).optional(),
        unprivileged_agents: z.number().optional(),
        updated_at: z.string(),
        updated_by: z.string(),
        version: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agent_policies/:agentPolicyId/download',
    alias: 'get-fleet-agent-policies-agentpolicyid-download',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies/{agentPolicyId}/download&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Download an agent policy by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-read AND fleet-setup.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'agentPolicyId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'download',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'standalone',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'kubernetes',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.string(),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 404,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agent_policies/:agentPolicyId/full',
    alias: 'get-fleet-agent-policies-agentpolicyid-full',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies/{agentPolicyId}/full&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a full agent policy by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'agentPolicyId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'download',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'standalone',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'kubernetes',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({
      item: z.union([
        z.string(),
        z.object({
          agent: z
            .object({
              download: z.object({
                secrets: z
                  .object({
                    ssl: z
                      .object({ key: z.object({ id: z.string() }).partial().passthrough() })
                      .passthrough(),
                  })
                  .partial()
                  .passthrough()
                  .optional(),
                sourceURI: z.string(),
                ssl: z
                  .object({
                    certificate: z.string(),
                    certificate_authorities: z.array(z.string()),
                    key: z.string(),
                    renegotiation: z.string(),
                    verification_mode: z.string(),
                  })
                  .partial()
                  .optional(),
                target_directory: z.string().optional(),
                timeout: z.string().optional(),
              }),
              features: z.record(z.object({ enabled: z.boolean() })),
              limits: z.object({ go_max_procs: z.number() }).partial().optional(),
              logging: z
                .object({
                  files: z
                    .object({
                      interval: z.string(),
                      keepfiles: z.number(),
                      rotateeverybytes: z.number(),
                    })
                    .partial(),
                  level: z.string(),
                  metrics: z.object({ period: z.string() }).partial(),
                  to_files: z.boolean(),
                })
                .partial()
                .optional(),
              monitoring: z.object({
                _runtime_experimental: z.string().optional(),
                apm: z.unknown(),
                enabled: z.boolean(),
                logs: z.boolean(),
                metrics: z.boolean(),
                namespace: z.string().optional(),
                traces: z.boolean(),
                use_output: z.string().optional(),
              }),
              protection: z
                .object({
                  enabled: z.boolean(),
                  signing_key: z.string(),
                  uninstall_token_hash: z.string(),
                })
                .optional(),
            })
            .optional(),
          connectors: z.object({}).partial().passthrough().optional(),
          exporters: z.object({}).partial().passthrough().optional(),
          extensions: z.object({}).partial().passthrough().optional(),
          fleet: z
            .union([
              z.object({
                hosts: z.array(z.string()),
                proxy_headers: z.unknown(),
                proxy_url: z.string().optional(),
                secrets: z
                  .object({
                    ssl: z
                      .object({ key: z.object({ id: z.string() }).partial().passthrough() })
                      .passthrough(),
                  })
                  .partial()
                  .passthrough()
                  .optional(),
                ssl: z
                  .object({
                    certificate: z.string(),
                    certificate_authorities: z.array(z.string()),
                    key: z.string(),
                    renegotiation: z.string(),
                    verification_mode: z.string(),
                  })
                  .partial()
                  .optional(),
              }),
              z.object({
                kibana: z.object({
                  hosts: z.array(z.string()),
                  path: z.string().optional(),
                  protocol: z.string(),
                }),
              }),
            ])
            .optional(),
          id: z.string(),
          inputs: z.array(
            z
              .object({
                data_stream: z.object({ namespace: z.string() }).passthrough(),
                id: z.string(),
                meta: z
                  .object({
                    package: z.object({ name: z.string(), version: z.string() }).passthrough(),
                  })
                  .partial()
                  .passthrough()
                  .optional(),
                name: z.string(),
                package_policy_id: z.string(),
                processors: z
                  .array(
                    z
                      .object({
                        add_fields: z
                          .object({
                            fields: z.record(z.union([z.string(), z.number()])),
                            target: z.string(),
                          })
                          .passthrough(),
                      })
                      .passthrough()
                  )
                  .optional(),
                revision: z.number(),
                streams: z
                  .array(
                    z
                      .object({
                        data_stream: z
                          .object({ dataset: z.string(), type: z.string().optional() })
                          .passthrough(),
                        id: z.string(),
                      })
                      .passthrough()
                  )
                  .optional(),
                type: z.string(),
                use_output: z.string(),
              })
              .passthrough()
          ),
          namespaces: z.array(z.string()).optional(),
          output_permissions: z.record(z.object({}).partial().passthrough()).optional(),
          outputs: z.record(
            z
              .object({
                ca_sha256: z.string().nullish(),
                hosts: z.array(z.string()).optional(),
                proxy_headers: z.unknown(),
                proxy_url: z.string().optional(),
                type: z.string(),
              })
              .passthrough()
          ),
          processors: z.object({}).partial().passthrough().optional(),
          receivers: z.object({}).partial().passthrough().optional(),
          revision: z.number().optional(),
          secret_references: z.array(z.object({ id: z.string() })).optional(),
          service: z
            .object({
              extensions: z.array(z.string()),
              pipelines: z.record(
                z
                  .object({
                    exporters: z.array(z.string()),
                    processors: z.array(z.string()),
                    receivers: z.array(z.string()),
                  })
                  .partial()
              ),
            })
            .partial()
            .optional(),
          signed: z.object({ data: z.string(), signature: z.string() }).optional(),
        }),
      ]),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agent_policies/:agentPolicyId/outputs',
    alias: 'get-fleet-agent-policies-agentpolicyid-outputs',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies/{agentPolicyId}/outputs&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of outputs associated with agent policy by policy id.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-read AND fleet-settings-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'agentPolicyId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        agentPolicyId: z.string().optional(),
        data: z.object({
          integrations: z
            .array(
              z
                .object({
                  id: z.string(),
                  integrationPolicyName: z.string(),
                  name: z.string(),
                  pkgName: z.string(),
                })
                .partial()
            )
            .optional(),
          output: z.object({ id: z.string(), name: z.string() }),
        }),
        monitoring: z.object({ output: z.object({ id: z.string(), name: z.string() }) }),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agent_policies/delete',
    alias: 'post-fleet-agent-policies-delete',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies/delete&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete an agent policy by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agent_policies_delete_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ id: z.string(), name: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agent_policies/outputs',
    alias: 'post-fleet-agent-policies-outputs',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_policies/outputs&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of outputs associated with agent policies.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-read AND fleet-settings-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agent_policies_outputs_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          agentPolicyId: z.string().optional(),
          data: z.object({
            integrations: z
              .array(
                z
                  .object({
                    id: z.string(),
                    integrationPolicyName: z.string(),
                    name: z.string(),
                    pkgName: z.string(),
                  })
                  .partial()
              )
              .optional(),
            output: z.object({ id: z.string(), name: z.string() }),
          }),
          monitoring: z.object({ output: z.object({ id: z.string(), name: z.string() }) }),
        })
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agent_status',
    alias: 'get-fleet-agent-status',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_status&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'policyId',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'policyIds',
        type: 'Query',
        schema: search_fields,
      },
      {
        name: 'kuery',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z.object({
      results: z.object({
        active: z.number(),
        all: z.number(),
        error: z.number(),
        events: z.number(),
        inactive: z.number(),
        offline: z.number(),
        online: z.number(),
        orphaned: z.number().optional(),
        other: z.number(),
        unenrolled: z.number(),
        uninstalled: z.number().optional(),
        updating: z.number(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agent_status/data',
    alias: 'get-fleet-agent-status-data',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agent_status/data&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'agentsIds',
        type: 'Query',
        schema: agentsIds,
      },
      {
        name: 'pkgName',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'pkgVersion',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'previewData',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({
      dataPreview: z.array(z.unknown()),
      items: z.array(z.record(z.object({ data: z.boolean() }))),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agents',
    alias: 'get-fleet-agents',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'page',
        type: 'Query',
        schema: z.number().optional(),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().optional().default(20),
      },
      {
        name: 'kuery',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'showAgentless',
        type: 'Query',
        schema: z.boolean().optional().default(true),
      },
      {
        name: 'showInactive',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'withMetrics',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'showUpgradeable',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'getStatusSummary',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'sortField',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'searchAfter',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'openPit',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'pitId',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'pitKeepAlive',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          access_api_key: z.string().optional(),
          access_api_key_id: z.string().optional(),
          active: z.boolean(),
          agent: z.object({ id: z.string(), version: z.string() }).passthrough().optional(),
          audit_unenrolled_reason: z.string().optional(),
          components: z
            .array(
              z.object({
                id: z.string(),
                message: z.string(),
                status: z.enum([
                  'STARTING',
                  'CONFIGURING',
                  'HEALTHY',
                  'DEGRADED',
                  'FAILED',
                  'STOPPING',
                  'STOPPED',
                ]),
                type: z.string(),
                units: z
                  .array(
                    z.object({
                      id: z.string(),
                      message: z.string(),
                      payload: z.object({}).partial().passthrough().optional(),
                      status: z.enum([
                        'STARTING',
                        'CONFIGURING',
                        'HEALTHY',
                        'DEGRADED',
                        'FAILED',
                        'STOPPING',
                        'STOPPED',
                      ]),
                      type: z.enum(['input', 'output']),
                    })
                  )
                  .optional(),
              })
            )
            .optional(),
          default_api_key: z.string().optional(),
          default_api_key_history: z
            .array(z.object({ id: z.string(), retired_at: z.string() }))
            .optional(),
          default_api_key_id: z.string().optional(),
          enrolled_at: z.string(),
          id: z.string(),
          last_checkin: z.string().optional(),
          last_checkin_message: z.string().optional(),
          last_checkin_status: z
            .enum(['error', 'online', 'degraded', 'updating', 'starting'])
            .optional(),
          last_known_status: z
            .enum([
              'offline',
              'error',
              'online',
              'inactive',
              'enrolling',
              'unenrolling',
              'unenrolled',
              'updating',
              'degraded',
              'uninstalled',
              'orphaned',
            ])
            .optional(),
          local_metadata: z.object({}).partial().passthrough(),
          metrics: z
            .object({ cpu_avg: z.number(), memory_size_byte_avg: z.number() })
            .partial()
            .optional(),
          namespaces: z.array(z.string()).optional(),
          outputs: z
            .record(
              z
                .object({
                  api_key_id: z.string(),
                  to_retire_api_key_ids: z.array(
                    z.object({ id: z.string(), retired_at: z.string() })
                  ),
                  type: z.string(),
                })
                .partial()
            )
            .optional(),
          packages: z.array(z.string()),
          policy_id: z.string().optional(),
          policy_revision: z.number().nullish(),
          sort: z.array(z.unknown()).optional(),
          status: z
            .enum([
              'offline',
              'error',
              'online',
              'inactive',
              'enrolling',
              'unenrolling',
              'unenrolled',
              'updating',
              'degraded',
              'uninstalled',
              'orphaned',
            ])
            .optional(),
          tags: z.array(z.string()).optional(),
          type: z.enum(['PERMANENT', 'EPHEMERAL', 'TEMPORARY']),
          unenrolled_at: z.string().optional(),
          unenrollment_started_at: z.string().optional(),
          unhealthy_reason: z.array(z.enum(['input', 'output', 'other'])).nullish(),
          upgrade_attempts: z.array(z.string()).nullish(),
          upgrade_details: z
            .object({
              action_id: z.string(),
              metadata: z
                .object({
                  download_percent: z.number(),
                  download_rate: z.number(),
                  error_msg: z.string(),
                  failed_state: z.enum([
                    'UPG_REQUESTED',
                    'UPG_SCHEDULED',
                    'UPG_DOWNLOADING',
                    'UPG_EXTRACTING',
                    'UPG_REPLACING',
                    'UPG_RESTARTING',
                    'UPG_FAILED',
                    'UPG_WATCHING',
                    'UPG_ROLLBACK',
                  ]),
                  retry_error_msg: z.string(),
                  retry_until: z.string(),
                  scheduled_at: z.string(),
                })
                .partial()
                .optional(),
              state: z.enum([
                'UPG_REQUESTED',
                'UPG_SCHEDULED',
                'UPG_DOWNLOADING',
                'UPG_EXTRACTING',
                'UPG_REPLACING',
                'UPG_RESTARTING',
                'UPG_FAILED',
                'UPG_WATCHING',
                'UPG_ROLLBACK',
              ]),
              target_version: z.string(),
            })
            .nullish(),
          upgrade_started_at: z.string().nullish(),
          upgraded_at: z.string().nullish(),
          user_provided_metadata: z.object({}).partial().passthrough().optional(),
        })
      ),
      nextSearchAfter: z.string().optional(),
      page: z.number(),
      perPage: z.number(),
      pit: z.string().optional(),
      statusSummary: z.record(z.number()).optional(),
      total: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents',
    alias: 'post-fleet-agents',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agents_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ items: z.array(z.string()) }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/agents/:agentId',
    alias: 'delete-fleet-agents-agentid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/{agentId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete an agent by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'agentId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ action: z.literal('deleted') }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agents/:agentId',
    alias: 'get-fleet-agents-agentid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/{agentId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get an agent by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'agentId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'withMetrics',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({
      item: z.object({
        access_api_key: z.string().optional(),
        access_api_key_id: z.string().optional(),
        active: z.boolean(),
        agent: z.object({ id: z.string(), version: z.string() }).passthrough().optional(),
        audit_unenrolled_reason: z.string().optional(),
        components: z
          .array(
            z.object({
              id: z.string(),
              message: z.string(),
              status: z.enum([
                'STARTING',
                'CONFIGURING',
                'HEALTHY',
                'DEGRADED',
                'FAILED',
                'STOPPING',
                'STOPPED',
              ]),
              type: z.string(),
              units: z
                .array(
                  z.object({
                    id: z.string(),
                    message: z.string(),
                    payload: z.object({}).partial().passthrough().optional(),
                    status: z.enum([
                      'STARTING',
                      'CONFIGURING',
                      'HEALTHY',
                      'DEGRADED',
                      'FAILED',
                      'STOPPING',
                      'STOPPED',
                    ]),
                    type: z.enum(['input', 'output']),
                  })
                )
                .optional(),
            })
          )
          .optional(),
        default_api_key: z.string().optional(),
        default_api_key_history: z
          .array(z.object({ id: z.string(), retired_at: z.string() }))
          .optional(),
        default_api_key_id: z.string().optional(),
        enrolled_at: z.string(),
        id: z.string(),
        last_checkin: z.string().optional(),
        last_checkin_message: z.string().optional(),
        last_checkin_status: z
          .enum(['error', 'online', 'degraded', 'updating', 'starting'])
          .optional(),
        last_known_status: z
          .enum([
            'offline',
            'error',
            'online',
            'inactive',
            'enrolling',
            'unenrolling',
            'unenrolled',
            'updating',
            'degraded',
            'uninstalled',
            'orphaned',
          ])
          .optional(),
        local_metadata: z.object({}).partial().passthrough(),
        metrics: z
          .object({ cpu_avg: z.number(), memory_size_byte_avg: z.number() })
          .partial()
          .optional(),
        namespaces: z.array(z.string()).optional(),
        outputs: z
          .record(
            z
              .object({
                api_key_id: z.string(),
                to_retire_api_key_ids: z.array(
                  z.object({ id: z.string(), retired_at: z.string() })
                ),
                type: z.string(),
              })
              .partial()
          )
          .optional(),
        packages: z.array(z.string()),
        policy_id: z.string().optional(),
        policy_revision: z.number().nullish(),
        sort: z.array(z.unknown()).optional(),
        status: z
          .enum([
            'offline',
            'error',
            'online',
            'inactive',
            'enrolling',
            'unenrolling',
            'unenrolled',
            'updating',
            'degraded',
            'uninstalled',
            'orphaned',
          ])
          .optional(),
        tags: z.array(z.string()).optional(),
        type: z.enum(['PERMANENT', 'EPHEMERAL', 'TEMPORARY']),
        unenrolled_at: z.string().optional(),
        unenrollment_started_at: z.string().optional(),
        unhealthy_reason: z.array(z.enum(['input', 'output', 'other'])).nullish(),
        upgrade_attempts: z.array(z.string()).nullish(),
        upgrade_details: z
          .object({
            action_id: z.string(),
            metadata: z
              .object({
                download_percent: z.number(),
                download_rate: z.number(),
                error_msg: z.string(),
                failed_state: z.enum([
                  'UPG_REQUESTED',
                  'UPG_SCHEDULED',
                  'UPG_DOWNLOADING',
                  'UPG_EXTRACTING',
                  'UPG_REPLACING',
                  'UPG_RESTARTING',
                  'UPG_FAILED',
                  'UPG_WATCHING',
                  'UPG_ROLLBACK',
                ]),
                retry_error_msg: z.string(),
                retry_until: z.string(),
                scheduled_at: z.string(),
              })
              .partial()
              .optional(),
            state: z.enum([
              'UPG_REQUESTED',
              'UPG_SCHEDULED',
              'UPG_DOWNLOADING',
              'UPG_EXTRACTING',
              'UPG_REPLACING',
              'UPG_RESTARTING',
              'UPG_FAILED',
              'UPG_WATCHING',
              'UPG_ROLLBACK',
            ]),
            target_version: z.string(),
          })
          .nullish(),
        upgrade_started_at: z.string().nullish(),
        upgraded_at: z.string().nullish(),
        user_provided_metadata: z.object({}).partial().passthrough().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/fleet/agents/:agentId',
    alias: 'put-fleet-agents-agentid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/{agentId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update an agent by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_fleet_agents_agentid_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'agentId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        access_api_key: z.string().optional(),
        access_api_key_id: z.string().optional(),
        active: z.boolean(),
        agent: z.object({ id: z.string(), version: z.string() }).passthrough().optional(),
        audit_unenrolled_reason: z.string().optional(),
        components: z
          .array(
            z.object({
              id: z.string(),
              message: z.string(),
              status: z.enum([
                'STARTING',
                'CONFIGURING',
                'HEALTHY',
                'DEGRADED',
                'FAILED',
                'STOPPING',
                'STOPPED',
              ]),
              type: z.string(),
              units: z
                .array(
                  z.object({
                    id: z.string(),
                    message: z.string(),
                    payload: z.object({}).partial().passthrough().optional(),
                    status: z.enum([
                      'STARTING',
                      'CONFIGURING',
                      'HEALTHY',
                      'DEGRADED',
                      'FAILED',
                      'STOPPING',
                      'STOPPED',
                    ]),
                    type: z.enum(['input', 'output']),
                  })
                )
                .optional(),
            })
          )
          .optional(),
        default_api_key: z.string().optional(),
        default_api_key_history: z
          .array(z.object({ id: z.string(), retired_at: z.string() }))
          .optional(),
        default_api_key_id: z.string().optional(),
        enrolled_at: z.string(),
        id: z.string(),
        last_checkin: z.string().optional(),
        last_checkin_message: z.string().optional(),
        last_checkin_status: z
          .enum(['error', 'online', 'degraded', 'updating', 'starting'])
          .optional(),
        last_known_status: z
          .enum([
            'offline',
            'error',
            'online',
            'inactive',
            'enrolling',
            'unenrolling',
            'unenrolled',
            'updating',
            'degraded',
            'uninstalled',
            'orphaned',
          ])
          .optional(),
        local_metadata: z.object({}).partial().passthrough(),
        metrics: z
          .object({ cpu_avg: z.number(), memory_size_byte_avg: z.number() })
          .partial()
          .optional(),
        namespaces: z.array(z.string()).optional(),
        outputs: z
          .record(
            z
              .object({
                api_key_id: z.string(),
                to_retire_api_key_ids: z.array(
                  z.object({ id: z.string(), retired_at: z.string() })
                ),
                type: z.string(),
              })
              .partial()
          )
          .optional(),
        packages: z.array(z.string()),
        policy_id: z.string().optional(),
        policy_revision: z.number().nullish(),
        sort: z.array(z.unknown()).optional(),
        status: z
          .enum([
            'offline',
            'error',
            'online',
            'inactive',
            'enrolling',
            'unenrolling',
            'unenrolled',
            'updating',
            'degraded',
            'uninstalled',
            'orphaned',
          ])
          .optional(),
        tags: z.array(z.string()).optional(),
        type: z.enum(['PERMANENT', 'EPHEMERAL', 'TEMPORARY']),
        unenrolled_at: z.string().optional(),
        unenrollment_started_at: z.string().optional(),
        unhealthy_reason: z.array(z.enum(['input', 'output', 'other'])).nullish(),
        upgrade_attempts: z.array(z.string()).nullish(),
        upgrade_details: z
          .object({
            action_id: z.string(),
            metadata: z
              .object({
                download_percent: z.number(),
                download_rate: z.number(),
                error_msg: z.string(),
                failed_state: z.enum([
                  'UPG_REQUESTED',
                  'UPG_SCHEDULED',
                  'UPG_DOWNLOADING',
                  'UPG_EXTRACTING',
                  'UPG_REPLACING',
                  'UPG_RESTARTING',
                  'UPG_FAILED',
                  'UPG_WATCHING',
                  'UPG_ROLLBACK',
                ]),
                retry_error_msg: z.string(),
                retry_until: z.string(),
                scheduled_at: z.string(),
              })
              .partial()
              .optional(),
            state: z.enum([
              'UPG_REQUESTED',
              'UPG_SCHEDULED',
              'UPG_DOWNLOADING',
              'UPG_EXTRACTING',
              'UPG_REPLACING',
              'UPG_RESTARTING',
              'UPG_FAILED',
              'UPG_WATCHING',
              'UPG_ROLLBACK',
            ]),
            target_version: z.string(),
          })
          .nullish(),
        upgrade_started_at: z.string().nullish(),
        upgraded_at: z.string().nullish(),
        user_provided_metadata: z.object({}).partial().passthrough().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/:agentId/actions',
    alias: 'post-fleet-agents-agentid-actions',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/{agentId}/actions&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agents_agentid_actions_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'agentId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        ack_data: z.unknown(),
        agents: z.array(z.string()).optional(),
        created_at: z.string(),
        data: z.unknown(),
        expiration: z.string().optional(),
        id: z.string(),
        minimum_execution_duration: z.number().optional(),
        namespaces: z.array(z.string()).optional(),
        rollout_duration_seconds: z.number().optional(),
        sent_at: z.string().optional(),
        source_uri: z.string().optional(),
        start_time: z.string().optional(),
        total: z.number().optional(),
        type: z.string(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/:agentId/reassign',
    alias: 'post-fleet-agents-agentid-reassign',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/{agentId}/reassign&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ policy_id: z.string() }),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'agentId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial(),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/:agentId/request_diagnostics',
    alias: 'post-fleet-agents-agentid-request-diagnostics',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/{agentId}/request_diagnostics&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agents_agentid_request_diagnostics_Body.nullable(),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'agentId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ actionId: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/:agentId/unenroll',
    alias: 'post-fleet-agents-agentid-unenroll',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/{agentId}/unenroll&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agents_agentid_unenroll_Body.nullable(),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'agentId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/fleet/agents/:agentId/upgrade',
    alias: 'post-fleet-agents-agentid-upgrade',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/{agentId}/upgrade&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agents_agentid_upgrade_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'agentId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial(),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agents/:agentId/uploads',
    alias: 'get-fleet-agents-agentid-uploads',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/{agentId}/uploads&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'agentId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          actionId: z.string(),
          createTime: z.string(),
          error: z.string().optional(),
          filePath: z.string(),
          id: z.string(),
          name: z.string(),
          status: z.enum([
            'READY',
            'AWAITING_UPLOAD',
            'DELETED',
            'EXPIRED',
            'IN_PROGRESS',
            'FAILED',
          ]),
        })
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agents/action_status',
    alias: 'get-fleet-agents-action-status',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/action_status&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'page',
        type: 'Query',
        schema: z.number().optional().default(0),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().optional().default(20),
      },
      {
        name: 'date',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'latest',
        type: 'Query',
        schema: z.number().optional(),
      },
      {
        name: 'errorSize',
        type: 'Query',
        schema: z.number().optional().default(5),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          actionId: z.string(),
          cancellationTime: z.string().optional(),
          completionTime: z.string().optional(),
          creationTime: z.string(),
          expiration: z.string().optional(),
          hasRolloutPeriod: z.boolean().optional(),
          is_automatic: z.boolean().optional(),
          latestErrors: z
            .array(
              z.object({
                agentId: z.string(),
                error: z.string(),
                hostname: z.string().optional(),
                timestamp: z.string(),
              })
            )
            .optional(),
          nbAgentsAck: z.number(),
          nbAgentsActionCreated: z.number(),
          nbAgentsActioned: z.number(),
          nbAgentsFailed: z.number(),
          newPolicyId: z.string().optional(),
          policyId: z.string().optional(),
          revision: z.number().optional(),
          startTime: z.string().optional(),
          status: z.enum([
            'COMPLETE',
            'EXPIRED',
            'CANCELLED',
            'FAILED',
            'IN_PROGRESS',
            'ROLLOUT_PASSED',
          ]),
          type: z.enum([
            'UPGRADE',
            'UNENROLL',
            'SETTINGS',
            'POLICY_REASSIGN',
            'CANCEL',
            'FORCE_UNENROLL',
            'REQUEST_DIAGNOSTICS',
            'UPDATE_TAGS',
            'POLICY_CHANGE',
            'INPUT_ACTION',
            'MIGRATE',
            'PRIVILEGE_LEVEL_CHANGE',
          ]),
          version: z.string().optional(),
        })
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/actions/:actionId/cancel',
    alias: 'post-fleet-agents-actions-actionid-cancel',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/actions/{actionId}/cancel&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'actionId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        ack_data: z.unknown(),
        agents: z.array(z.string()).optional(),
        created_at: z.string(),
        data: z.unknown(),
        expiration: z.string().optional(),
        id: z.string(),
        minimum_execution_duration: z.number().optional(),
        namespaces: z.array(z.string()).optional(),
        rollout_duration_seconds: z.number().optional(),
        sent_at: z.string().optional(),
        source_uri: z.string().optional(),
        start_time: z.string().optional(),
        total: z.number().optional(),
        type: z.string(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agents/available_versions',
    alias: 'get-fleet-agents-available-versions',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/available_versions&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    response: z.object({ items: z.array(z.string()) }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/bulk_reassign',
    alias: 'post-fleet-agents-bulk-reassign',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/bulk_reassign&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agents_bulk_reassign_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ actionId: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/bulk_request_diagnostics',
    alias: 'post-fleet-agents-bulk-request-diagnostics',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/bulk_request_diagnostics&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agents_bulk_request_diagnostics_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ actionId: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/bulk_unenroll',
    alias: 'post-fleet-agents-bulk-unenroll',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/bulk_unenroll&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agents_bulk_unenroll_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ actionId: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/bulk_update_agent_tags',
    alias: 'post-fleet-agents-bulk-update-agent-tags',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/bulk_update_agent_tags&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agents_bulk_update_agent_tags_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ actionId: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/bulk_upgrade',
    alias: 'post-fleet-agents-bulk-upgrade',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/bulk_upgrade&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_agents_bulk_upgrade_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ actionId: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/agents/files/:fileId',
    alias: 'delete-fleet-agents-files-fileid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/files/{fileId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a file uploaded by an agent.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'fileId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ deleted: z.boolean(), id: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agents/files/:fileId/:fileName',
    alias: 'get-fleet-agents-files-fileid-filename',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/files/{fileId}/{fileName}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a file uploaded by an agent.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'fileId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'fileName',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agents/setup',
    alias: 'get-fleet-agents-setup',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/setup&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read OR fleet-agent-policies-read OR fleet-settings-read OR fleet-setup.`,
    requestFormat: 'json',
    response: z.object({
      is_secrets_storage_enabled: z.boolean().optional(),
      is_space_awareness_enabled: z.boolean().optional(),
      isReady: z.boolean(),
      missing_optional_features: z.array(
        z.literal('encrypted_saved_object_encryption_key_required')
      ),
      missing_requirements: z.array(
        z.enum([
          'security_required',
          'tls_required',
          'api_keys',
          'fleet_admin_user',
          'fleet_server',
        ])
      ),
      package_verification_key_id: z.string().optional(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/agents/setup',
    alias: 'post-fleet-agents-setup',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/setup&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read OR fleet-agent-policies-read OR fleet-settings-read OR fleet-setup.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      isInitialized: z.boolean(),
      nonFatalErrors: z.array(z.object({ message: z.string(), name: z.string() })),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/agents/tags',
    alias: 'get-fleet-agents-tags',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/agents/tags&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kuery',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'showInactive',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({ items: z.array(z.string()) }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/check-permissions',
    alias: 'get-fleet-check-permissions',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/check-permissions&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'fleetServerSetup',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({
      error: z
        .enum(['MISSING_SECURITY', 'MISSING_PRIVILEGES', 'MISSING_FLEET_SERVER_SETUP_PRIVILEGES'])
        .optional(),
      success: z.boolean(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/data_streams',
    alias: 'get-fleet-data-streams',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/data_streams&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all AND fleet-agent-policies-all AND fleet-settings-all.`,
    requestFormat: 'json',
    response: z.object({
      data_streams: z.array(
        z.object({
          dashboards: z.array(z.object({ id: z.string(), title: z.string() })),
          dataset: z.string(),
          index: z.string(),
          last_activity_ms: z.number(),
          namespace: z.string(),
          package: z.string(),
          package_version: z.string(),
          serviceDetails: z.object({ environment: z.string(), serviceName: z.string() }).nullable(),
          size_in_bytes: z.number(),
          size_in_bytes_formatted: z.union([z.number(), z.string()]),
          type: z.string(),
        })
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/enrollment_api_keys',
    alias: 'get-fleet-enrollment-api-keys',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/enrollment_api_keys&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all OR fleet-setup.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'page',
        type: 'Query',
        schema: z.number().optional().default(1),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().optional().default(20),
      },
      {
        name: 'kuery',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          active: z.boolean(),
          api_key: z.string(),
          api_key_id: z.string(),
          created_at: z.string(),
          hidden: z.boolean().optional(),
          id: z.string(),
          name: z.string().optional(),
          policy_id: z.string().optional(),
        })
      ),
      list: z.array(
        z.object({
          active: z.boolean(),
          api_key: z.string(),
          api_key_id: z.string(),
          created_at: z.string(),
          hidden: z.boolean().optional(),
          id: z.string(),
          name: z.string().optional(),
          policy_id: z.string().optional(),
        })
      ),
      page: z.number(),
      perPage: z.number(),
      total: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/enrollment_api_keys',
    alias: 'post-fleet-enrollment-api-keys',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/enrollment_api_keys&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_enrollment_api_keys_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      action: z.literal('created'),
      item: z.object({
        active: z.boolean(),
        api_key: z.string(),
        api_key_id: z.string(),
        created_at: z.string(),
        hidden: z.boolean().optional(),
        id: z.string(),
        name: z.string().optional(),
        policy_id: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/enrollment_api_keys/:keyId',
    alias: 'delete-fleet-enrollment-api-keys-keyid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/enrollment_api_keys/{keyId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Revoke an enrollment API key by ID by marking it as inactive.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'keyId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ action: z.literal('deleted') }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/enrollment_api_keys/:keyId',
    alias: 'get-fleet-enrollment-api-keys-keyid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/enrollment_api_keys/{keyId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get an enrollment API key by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agents-all OR fleet-setup.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'keyId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        active: z.boolean(),
        api_key: z.string(),
        api_key_id: z.string(),
        created_at: z.string(),
        hidden: z.boolean().optional(),
        id: z.string(),
        name: z.string().optional(),
        policy_id: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/epm/bulk_assets',
    alias: 'post-fleet-epm-bulk-assets',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/bulk_assets&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-read OR fleet-setup OR fleet-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_epm_bulk_assets_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          appLink: z.string().optional(),
          attributes: z
            .object({ description: z.string(), service: z.string(), title: z.string() })
            .partial(),
          id: z.string(),
          type: z.string(),
          updatedAt: z.string().optional(),
        })
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/categories',
    alias: 'get-fleet-epm-categories',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/categories&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-read OR fleet-setup OR fleet-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'prerelease',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'include_policy_templates',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          count: z.number(),
          id: z.string(),
          parent_id: z.string().optional(),
          parent_title: z.string().optional(),
          title: z.string(),
        })
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/epm/custom_integrations',
    alias: 'post-fleet-epm-custom-integrations',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/custom_integrations&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_epm_custom_integrations_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      _meta: z.object({ install_source: z.string(), name: z.string() }),
      items: z.array(
        z.union([
          z.object({
            id: z.string(),
            originId: z.string().optional(),
            type: z.union([
              z.enum([
                'dashboard',
                'lens',
                'visualization',
                'search',
                'index-pattern',
                'map',
                'ml-module',
                'security-rule',
                'csp-rule-template',
                'osquery-pack-asset',
                'osquery-saved-query',
                'tag',
              ]),
              z.string(),
            ]),
          }),
          z.object({
            deferred: z.boolean().optional(),
            id: z.string(),
            type: z.enum([
              'index',
              'index_template',
              'component_template',
              'ingest_pipeline',
              'ilm_policy',
              'data_stream_ilm_policy',
              'transform',
              'ml_model',
            ]),
            version: z.string().optional(),
          }),
        ])
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/fleet/epm/custom_integrations/:pkgName',
    alias: 'put-fleet-epm-custom-integrations-pkgname',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/custom_integrations/{pkgName}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-all AND integrations-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_fleet_epm_custom_integrations_pkgname_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/data_streams',
    alias: 'get-fleet-epm-data-streams',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/data_streams&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-read OR fleet-setup OR fleet-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'type',
        type: 'Query',
        schema: z.enum(['logs', 'metrics', 'traces', 'synthetics', 'profiling']).optional(),
      },
      {
        name: 'datasetQuery',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional().default('asc'),
      },
      {
        name: 'uncategorisedOnly',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({ items: z.array(z.object({ name: z.string() })) }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/packages',
    alias: 'get-fleet-epm-packages',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-read OR fleet-setup OR fleet-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'category',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'prerelease',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'excludeInstallStatus',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'withPackagePoliciesCount',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z
          .object({
            categories: z.array(z.string()).optional(),
            conditions: z
              .object({
                elastic: z
                  .object({ capabilities: z.array(z.string()), subscription: z.string() })
                  .partial()
                  .passthrough(),
                kibana: z.object({ version: z.string() }).partial().passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            data_streams: z.array(z.object({}).partial().passthrough()).optional(),
            description: z.string().optional(),
            discovery: z
              .object({
                datasets: z.array(z.object({ name: z.string() }).passthrough()),
                fields: z.array(z.object({ name: z.string() }).passthrough()),
              })
              .partial()
              .passthrough()
              .optional(),
            download: z.string().optional(),
            format_version: z.string().optional(),
            icons: z
              .array(
                z
                  .object({
                    dark_mode: z.boolean().optional(),
                    path: z.string().optional(),
                    size: z.string().optional(),
                    src: z.string(),
                    title: z.string().optional(),
                    type: z.string().optional(),
                  })
                  .passthrough()
              )
              .optional(),
            id: z.string(),
            installationInfo: z
              .object({
                additional_spaces_installed_kibana: z
                  .record(
                    z.array(
                      z
                        .object({
                          id: z.string(),
                          originId: z.string().optional(),
                          type: z.union([
                            z.enum([
                              'dashboard',
                              'lens',
                              'visualization',
                              'search',
                              'index-pattern',
                              'map',
                              'ml-module',
                              'security-rule',
                              'csp-rule-template',
                              'osquery-pack-asset',
                              'osquery-saved-query',
                              'tag',
                            ]),
                            z.string(),
                          ]),
                        })
                        .passthrough()
                    )
                  )
                  .optional(),
                created_at: z.string().optional(),
                experimental_data_stream_features: z
                  .array(
                    z
                      .object({
                        data_stream: z.string(),
                        features: z
                          .object({
                            doc_value_only_numeric: z.boolean(),
                            doc_value_only_other: z.boolean(),
                            synthetic_source: z.boolean(),
                            tsdb: z.boolean(),
                          })
                          .partial()
                          .passthrough(),
                      })
                      .passthrough()
                  )
                  .optional(),
                install_format_schema_version: z.string().optional(),
                install_source: z.enum(['registry', 'upload', 'bundled', 'custom']),
                install_status: z.enum(['installed', 'installing', 'install_failed']),
                installed_es: z.array(
                  z
                    .object({
                      deferred: z.boolean().optional(),
                      id: z.string(),
                      type: z.enum([
                        'index',
                        'index_template',
                        'component_template',
                        'ingest_pipeline',
                        'ilm_policy',
                        'data_stream_ilm_policy',
                        'transform',
                        'ml_model',
                      ]),
                      version: z.string().optional(),
                    })
                    .passthrough()
                ),
                installed_kibana: z.array(
                  z
                    .object({
                      id: z.string(),
                      originId: z.string().optional(),
                      type: z.union([
                        z.enum([
                          'dashboard',
                          'lens',
                          'visualization',
                          'search',
                          'index-pattern',
                          'map',
                          'ml-module',
                          'security-rule',
                          'csp-rule-template',
                          'osquery-pack-asset',
                          'osquery-saved-query',
                          'tag',
                        ]),
                        z.string(),
                      ]),
                    })
                    .passthrough()
                ),
                installed_kibana_space_id: z.string().optional(),
                latest_executed_state: z
                  .object({ error: z.string(), name: z.string(), started_at: z.string() })
                  .partial()
                  .passthrough()
                  .optional(),
                latest_install_failed_attempts: z
                  .array(
                    z
                      .object({
                        created_at: z.string(),
                        error: z
                          .object({
                            message: z.string(),
                            name: z.string(),
                            stack: z.string().optional(),
                          })
                          .passthrough(),
                        target_version: z.string(),
                      })
                      .passthrough()
                  )
                  .optional(),
                name: z.string(),
                namespaces: z.array(z.string()).optional(),
                type: z.string(),
                updated_at: z.string().optional(),
                verification_key_id: z.string().nullish(),
                verification_status: z.enum(['unverified', 'verified', 'unknown']),
                version: z.string(),
              })
              .passthrough()
              .optional(),
            integration: z.string().optional(),
            internal: z.boolean().optional(),
            latestVersion: z.string().optional(),
            name: z.string(),
            owner: z
              .object({ github: z.string(), type: z.enum(['elastic', 'partner', 'community']) })
              .partial()
              .passthrough()
              .optional(),
            path: z.string().optional(),
            policy_templates: z.array(z.object({}).partial().passthrough()).optional(),
            readme: z.string().optional(),
            release: z.enum(['ga', 'beta', 'experimental']).optional(),
            signature_path: z.string().optional(),
            source: z.object({ license: z.string() }).passthrough().optional(),
            status: z.string().optional(),
            title: z.string(),
            type: z
              .union([
                z.literal('integration'),
                z.literal('input'),
                z.literal('content'),
                z.string(),
              ])
              .optional(),
            vars: z.array(z.object({}).partial().passthrough()).optional(),
            version: z.string(),
          })
          .passthrough()
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/epm/packages',
    alias: 'post-fleet-epm-packages',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'ignoreMappingUpdateErrors',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'skipDataStreamRollover',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/epm/packages/_bulk',
    alias: 'post-fleet-epm-packages-bulk',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/_bulk&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_epm_packages_bulk_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'prerelease',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z.union([
          z.object({
            name: z.string(),
            result: z.object({
              assets: z
                .array(
                  z.union([
                    z.object({
                      id: z.string(),
                      originId: z.string().optional(),
                      type: z.union([
                        z.enum([
                          'dashboard',
                          'lens',
                          'visualization',
                          'search',
                          'index-pattern',
                          'map',
                          'ml-module',
                          'security-rule',
                          'csp-rule-template',
                          'osquery-pack-asset',
                          'osquery-saved-query',
                          'tag',
                        ]),
                        z.string(),
                      ]),
                    }),
                    z.object({
                      deferred: z.boolean().optional(),
                      id: z.string(),
                      type: z.enum([
                        'index',
                        'index_template',
                        'component_template',
                        'ingest_pipeline',
                        'ilm_policy',
                        'data_stream_ilm_policy',
                        'transform',
                        'ml_model',
                      ]),
                      version: z.string().optional(),
                    }),
                  ])
                )
                .optional(),
              error: z.unknown(),
              installSource: z.string().optional(),
              installType: z.string(),
              status: z.enum(['installed', 'already_installed']).optional(),
            }),
            version: z.string(),
          }),
          z.object({
            error: z.union([z.string(), z.unknown()]),
            name: z.string(),
            statusCode: z.number(),
          }),
        ])
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/epm/packages/_bulk_uninstall',
    alias: 'post-fleet-epm-packages-bulk-uninstall',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/_bulk_uninstall&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_epm_packages_bulk_uninstall_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ taskId: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/packages/_bulk_uninstall/:taskId',
    alias: 'get-fleet-epm-packages-bulk-uninstall-taskid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/_bulk_uninstall/{taskId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'taskId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      error: z.object({ message: z.string() }).optional(),
      results: z
        .array(
          z.object({
            error: z.object({ message: z.string() }).optional(),
            name: z.string(),
            success: z.boolean(),
          })
        )
        .optional(),
      status: z.string(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/epm/packages/_bulk_upgrade',
    alias: 'post-fleet-epm-packages-bulk-upgrade',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/_bulk_upgrade&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_epm_packages_bulk_upgrade_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ taskId: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/packages/_bulk_upgrade/:taskId',
    alias: 'get-fleet-epm-packages-bulk-upgrade-taskid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/_bulk_upgrade/{taskId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'taskId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      error: z.object({ message: z.string() }).optional(),
      results: z
        .array(
          z.object({
            error: z.object({ message: z.string() }).optional(),
            name: z.string(),
            success: z.boolean(),
          })
        )
        .optional(),
      status: z.string(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/epm/packages/:pkgName/:pkgVersion',
    alias: 'delete-fleet-epm-packages-pkgname-pkgversion',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/{pkgName}/{pkgVersion}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'pkgVersion',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'force',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z.union([
          z.object({
            id: z.string(),
            originId: z.string().optional(),
            type: z.union([
              z.enum([
                'dashboard',
                'lens',
                'visualization',
                'search',
                'index-pattern',
                'map',
                'ml-module',
                'security-rule',
                'csp-rule-template',
                'osquery-pack-asset',
                'osquery-saved-query',
                'tag',
              ]),
              z.string(),
            ]),
          }),
          z.object({
            deferred: z.boolean().optional(),
            id: z.string(),
            type: z.enum([
              'index',
              'index_template',
              'component_template',
              'ingest_pipeline',
              'ilm_policy',
              'data_stream_ilm_policy',
              'transform',
              'ml_model',
            ]),
            version: z.string().optional(),
          }),
        ])
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/packages/:pkgName/:pkgVersion',
    alias: 'get-fleet-epm-packages-pkgname-pkgversion',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/{pkgName}/{pkgVersion}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'pkgVersion',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'ignoreUnverified',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'prerelease',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'full',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'withMetadata',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({
      item: z
        .object({
          agent: z
            .object({ privileges: z.object({ root: z.boolean() }).partial() })
            .partial()
            .optional(),
          asset_tags: z
            .array(
              z.object({
                asset_ids: z.array(z.string()).optional(),
                asset_types: z.array(z.string()).optional(),
                text: z.string(),
              })
            )
            .optional(),
          assets: z.object({}).partial().passthrough(),
          categories: z.array(z.string()).optional(),
          conditions: z
            .object({
              elastic: z
                .object({ capabilities: z.array(z.string()), subscription: z.string() })
                .partial()
                .passthrough(),
              kibana: z.object({ version: z.string() }).partial().passthrough(),
            })
            .partial()
            .passthrough()
            .optional(),
          data_streams: z.array(z.object({}).partial().passthrough()).optional(),
          description: z.string().optional(),
          discovery: z
            .object({
              datasets: z.array(z.object({ name: z.string() }).passthrough()),
              fields: z.array(z.object({ name: z.string() }).passthrough()),
            })
            .partial()
            .passthrough()
            .optional(),
          download: z.string().optional(),
          elasticsearch: z.object({}).partial().passthrough().optional(),
          format_version: z.string().optional(),
          icons: z
            .array(
              z
                .object({
                  dark_mode: z.boolean().optional(),
                  path: z.string().optional(),
                  size: z.string().optional(),
                  src: z.string(),
                  title: z.string().optional(),
                  type: z.string().optional(),
                })
                .passthrough()
            )
            .optional(),
          installationInfo: z
            .object({
              additional_spaces_installed_kibana: z
                .record(
                  z.array(
                    z
                      .object({
                        id: z.string(),
                        originId: z.string().optional(),
                        type: z.union([
                          z.enum([
                            'dashboard',
                            'lens',
                            'visualization',
                            'search',
                            'index-pattern',
                            'map',
                            'ml-module',
                            'security-rule',
                            'csp-rule-template',
                            'osquery-pack-asset',
                            'osquery-saved-query',
                            'tag',
                          ]),
                          z.string(),
                        ]),
                      })
                      .passthrough()
                  )
                )
                .optional(),
              created_at: z.string().optional(),
              experimental_data_stream_features: z
                .array(
                  z
                    .object({
                      data_stream: z.string(),
                      features: z
                        .object({
                          doc_value_only_numeric: z.boolean(),
                          doc_value_only_other: z.boolean(),
                          synthetic_source: z.boolean(),
                          tsdb: z.boolean(),
                        })
                        .partial()
                        .passthrough(),
                    })
                    .passthrough()
                )
                .optional(),
              install_format_schema_version: z.string().optional(),
              install_source: z.enum(['registry', 'upload', 'bundled', 'custom']),
              install_status: z.enum(['installed', 'installing', 'install_failed']),
              installed_es: z.array(
                z
                  .object({
                    deferred: z.boolean().optional(),
                    id: z.string(),
                    type: z.enum([
                      'index',
                      'index_template',
                      'component_template',
                      'ingest_pipeline',
                      'ilm_policy',
                      'data_stream_ilm_policy',
                      'transform',
                      'ml_model',
                    ]),
                    version: z.string().optional(),
                  })
                  .passthrough()
              ),
              installed_kibana: z.array(
                z
                  .object({
                    id: z.string(),
                    originId: z.string().optional(),
                    type: z.union([
                      z.enum([
                        'dashboard',
                        'lens',
                        'visualization',
                        'search',
                        'index-pattern',
                        'map',
                        'ml-module',
                        'security-rule',
                        'csp-rule-template',
                        'osquery-pack-asset',
                        'osquery-saved-query',
                        'tag',
                      ]),
                      z.string(),
                    ]),
                  })
                  .passthrough()
              ),
              installed_kibana_space_id: z.string().optional(),
              latest_executed_state: z
                .object({ error: z.string(), name: z.string(), started_at: z.string() })
                .partial()
                .passthrough()
                .optional(),
              latest_install_failed_attempts: z
                .array(
                  z
                    .object({
                      created_at: z.string(),
                      error: z
                        .object({
                          message: z.string(),
                          name: z.string(),
                          stack: z.string().optional(),
                        })
                        .passthrough(),
                      target_version: z.string(),
                    })
                    .passthrough()
                )
                .optional(),
              name: z.string(),
              namespaces: z.array(z.string()).optional(),
              type: z.string(),
              updated_at: z.string().optional(),
              verification_key_id: z.string().nullish(),
              verification_status: z.enum(['unverified', 'verified', 'unknown']),
              version: z.string(),
            })
            .passthrough()
            .optional(),
          internal: z.boolean().optional(),
          keepPoliciesUpToDate: z.boolean().optional(),
          latestVersion: z.string().optional(),
          license: z.string().optional(),
          licensePath: z.string().optional(),
          name: z.string(),
          notice: z.string().optional(),
          owner: z
            .object({ github: z.string(), type: z.enum(['elastic', 'partner', 'community']) })
            .partial()
            .passthrough()
            .optional(),
          path: z.string().optional(),
          policy_templates: z.array(z.object({}).partial().passthrough()).optional(),
          readme: z.string().optional(),
          release: z.enum(['ga', 'beta', 'experimental']).optional(),
          screenshots: z
            .array(
              z.object({
                dark_mode: z.boolean().optional(),
                path: z.string().optional(),
                size: z.string().optional(),
                src: z.string(),
                title: z.string().optional(),
                type: z.string().optional(),
              })
            )
            .optional(),
          signature_path: z.string().optional(),
          source: z.object({ license: z.string() }).passthrough().optional(),
          status: z.string().optional(),
          title: z.string(),
          type: z
            .union([z.literal('integration'), z.literal('input'), z.literal('content'), z.string()])
            .optional(),
          vars: z.array(z.object({}).partial().passthrough()).optional(),
          version: z.string(),
        })
        .passthrough(),
      metadata: z.object({ has_policies: z.boolean() }).optional(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/epm/packages/:pkgName/:pkgVersion',
    alias: 'post-fleet-epm-packages-pkgname-pkgversion',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/{pkgName}/{pkgVersion}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_epm_packages_pkgname_pkgversion_Body.nullable(),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'pkgVersion',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'prerelease',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'ignoreMappingUpdateErrors',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'skipDataStreamRollover',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({
      _meta: z.object({ install_source: z.string(), name: z.string() }),
      items: z.array(
        z.union([
          z.object({
            id: z.string(),
            originId: z.string().optional(),
            type: z.union([
              z.enum([
                'dashboard',
                'lens',
                'visualization',
                'search',
                'index-pattern',
                'map',
                'ml-module',
                'security-rule',
                'csp-rule-template',
                'osquery-pack-asset',
                'osquery-saved-query',
                'tag',
              ]),
              z.string(),
            ]),
          }),
          z.object({
            deferred: z.boolean().optional(),
            id: z.string(),
            type: z.enum([
              'index',
              'index_template',
              'component_template',
              'ingest_pipeline',
              'ilm_policy',
              'data_stream_ilm_policy',
              'transform',
              'ml_model',
            ]),
            version: z.string().optional(),
          }),
        ])
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/fleet/epm/packages/:pkgName/:pkgVersion',
    alias: 'put-fleet-epm-packages-pkgname-pkgversion',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/{pkgName}/{pkgVersion}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ keepPoliciesUpToDate: z.boolean() }),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'pkgVersion',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z
        .object({
          agent: z
            .object({ privileges: z.object({ root: z.boolean() }).partial() })
            .partial()
            .optional(),
          asset_tags: z
            .array(
              z.object({
                asset_ids: z.array(z.string()).optional(),
                asset_types: z.array(z.string()).optional(),
                text: z.string(),
              })
            )
            .optional(),
          assets: z.object({}).partial().passthrough(),
          categories: z.array(z.string()).optional(),
          conditions: z
            .object({
              elastic: z
                .object({ capabilities: z.array(z.string()), subscription: z.string() })
                .partial()
                .passthrough(),
              kibana: z.object({ version: z.string() }).partial().passthrough(),
            })
            .partial()
            .passthrough()
            .optional(),
          data_streams: z.array(z.object({}).partial().passthrough()).optional(),
          description: z.string().optional(),
          discovery: z
            .object({
              datasets: z.array(z.object({ name: z.string() }).passthrough()),
              fields: z.array(z.object({ name: z.string() }).passthrough()),
            })
            .partial()
            .passthrough()
            .optional(),
          download: z.string().optional(),
          elasticsearch: z.object({}).partial().passthrough().optional(),
          format_version: z.string().optional(),
          icons: z
            .array(
              z
                .object({
                  dark_mode: z.boolean().optional(),
                  path: z.string().optional(),
                  size: z.string().optional(),
                  src: z.string(),
                  title: z.string().optional(),
                  type: z.string().optional(),
                })
                .passthrough()
            )
            .optional(),
          installationInfo: z
            .object({
              additional_spaces_installed_kibana: z
                .record(
                  z.array(
                    z
                      .object({
                        id: z.string(),
                        originId: z.string().optional(),
                        type: z.union([
                          z.enum([
                            'dashboard',
                            'lens',
                            'visualization',
                            'search',
                            'index-pattern',
                            'map',
                            'ml-module',
                            'security-rule',
                            'csp-rule-template',
                            'osquery-pack-asset',
                            'osquery-saved-query',
                            'tag',
                          ]),
                          z.string(),
                        ]),
                      })
                      .passthrough()
                  )
                )
                .optional(),
              created_at: z.string().optional(),
              experimental_data_stream_features: z
                .array(
                  z
                    .object({
                      data_stream: z.string(),
                      features: z
                        .object({
                          doc_value_only_numeric: z.boolean(),
                          doc_value_only_other: z.boolean(),
                          synthetic_source: z.boolean(),
                          tsdb: z.boolean(),
                        })
                        .partial()
                        .passthrough(),
                    })
                    .passthrough()
                )
                .optional(),
              install_format_schema_version: z.string().optional(),
              install_source: z.enum(['registry', 'upload', 'bundled', 'custom']),
              install_status: z.enum(['installed', 'installing', 'install_failed']),
              installed_es: z.array(
                z
                  .object({
                    deferred: z.boolean().optional(),
                    id: z.string(),
                    type: z.enum([
                      'index',
                      'index_template',
                      'component_template',
                      'ingest_pipeline',
                      'ilm_policy',
                      'data_stream_ilm_policy',
                      'transform',
                      'ml_model',
                    ]),
                    version: z.string().optional(),
                  })
                  .passthrough()
              ),
              installed_kibana: z.array(
                z
                  .object({
                    id: z.string(),
                    originId: z.string().optional(),
                    type: z.union([
                      z.enum([
                        'dashboard',
                        'lens',
                        'visualization',
                        'search',
                        'index-pattern',
                        'map',
                        'ml-module',
                        'security-rule',
                        'csp-rule-template',
                        'osquery-pack-asset',
                        'osquery-saved-query',
                        'tag',
                      ]),
                      z.string(),
                    ]),
                  })
                  .passthrough()
              ),
              installed_kibana_space_id: z.string().optional(),
              latest_executed_state: z
                .object({ error: z.string(), name: z.string(), started_at: z.string() })
                .partial()
                .passthrough()
                .optional(),
              latest_install_failed_attempts: z
                .array(
                  z
                    .object({
                      created_at: z.string(),
                      error: z
                        .object({
                          message: z.string(),
                          name: z.string(),
                          stack: z.string().optional(),
                        })
                        .passthrough(),
                      target_version: z.string(),
                    })
                    .passthrough()
                )
                .optional(),
              name: z.string(),
              namespaces: z.array(z.string()).optional(),
              type: z.string(),
              updated_at: z.string().optional(),
              verification_key_id: z.string().nullish(),
              verification_status: z.enum(['unverified', 'verified', 'unknown']),
              version: z.string(),
            })
            .passthrough()
            .optional(),
          internal: z.boolean().optional(),
          keepPoliciesUpToDate: z.boolean().optional(),
          latestVersion: z.string().optional(),
          license: z.string().optional(),
          licensePath: z.string().optional(),
          name: z.string(),
          notice: z.string().optional(),
          owner: z
            .object({ github: z.string(), type: z.enum(['elastic', 'partner', 'community']) })
            .partial()
            .passthrough()
            .optional(),
          path: z.string().optional(),
          policy_templates: z.array(z.object({}).partial().passthrough()).optional(),
          readme: z.string().optional(),
          release: z.enum(['ga', 'beta', 'experimental']).optional(),
          screenshots: z
            .array(
              z.object({
                dark_mode: z.boolean().optional(),
                path: z.string().optional(),
                size: z.string().optional(),
                src: z.string(),
                title: z.string().optional(),
                type: z.string().optional(),
              })
            )
            .optional(),
          signature_path: z.string().optional(),
          source: z.object({ license: z.string() }).passthrough().optional(),
          status: z.string().optional(),
          title: z.string(),
          type: z
            .union([z.literal('integration'), z.literal('input'), z.literal('content'), z.string()])
            .optional(),
          vars: z.array(z.object({}).partial().passthrough()).optional(),
          version: z.string(),
        })
        .passthrough(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/packages/:pkgName/:pkgVersion/:filePath',
    alias: 'get-fleet-epm-packages-pkgname-pkgversion-filepath',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/{pkgName}/{pkgVersion}/{filePath}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-read OR fleet-setup OR fleet-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'pkgVersion',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'filePath',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.unknown(),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/epm/packages/:pkgName/:pkgVersion/datastream_assets',
    alias: 'delete-fleet-epm-packages-pkgname-pkgversion-datastream-assets',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/{pkgName}/{pkgVersion}/datastream_assets&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'pkgVersion',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'packagePolicyId',
        type: 'Query',
        schema: z.string(),
      },
    ],
    response: z.object({ success: z.boolean() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/epm/packages/:pkgName/:pkgVersion/kibana_assets',
    alias: 'delete-fleet-epm-packages-pkgname-pkgversion-kibana-assets',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/{pkgName}/{pkgVersion}/kibana_assets&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'pkgVersion',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ success: z.boolean() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/epm/packages/:pkgName/:pkgVersion/kibana_assets',
    alias: 'post-fleet-epm-packages-pkgname-pkgversion-kibana-assets',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/{pkgName}/{pkgVersion}/kibana_assets&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-all AND fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_epm_packages_pkgname_pkgversion_kibana_assets_Body.nullable(),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'pkgVersion',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ success: z.boolean() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/epm/packages/:pkgName/:pkgVersion/transforms/authorize',
    alias: 'post-fleet-epm-packages-pkgname-pkgversion-transforms-authorize',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/{pkgName}/{pkgVersion}/transforms/authorize&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_epm_packages_pkgname_pkgversion_transforms_authorize_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'pkgVersion',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'prerelease',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.array(
      z.object({ error: z.unknown().nullable(), success: z.boolean(), transformId: z.string() })
    ),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/packages/:pkgName/stats',
    alias: 'get-fleet-epm-packages-pkgname-stats',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/{pkgName}/stats&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-read OR fleet-setup OR fleet-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      response: z.object({ agent_policy_count: z.number(), package_policy_count: z.number() }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/packages/installed',
    alias: 'get-fleet-epm-packages-installed',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/installed&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-read OR fleet-setup OR fleet-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'dataStreamType',
        type: 'Query',
        schema: z.enum(['logs', 'metrics', 'traces', 'synthetics', 'profiling']).optional(),
      },
      {
        name: 'showOnlyActiveDataStreams',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'nameQuery',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'searchAfter',
        type: 'Query',
        schema: searchAfter,
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().optional().default(15),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional().default('asc'),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          dataStreams: z.array(z.object({ name: z.string(), title: z.string() })),
          description: z.string().optional(),
          icons: z
            .array(
              z.object({
                dark_mode: z.boolean().optional(),
                path: z.string().optional(),
                size: z.string().optional(),
                src: z.string(),
                title: z.string().optional(),
                type: z.string().optional(),
              })
            )
            .optional(),
          name: z.string(),
          status: z.string(),
          title: z.string().optional(),
          version: z.string(),
        })
      ),
      searchAfter: z
        .array(z.union([z.string(), z.number(), z.boolean(), z.unknown(), z.unknown()]))
        .optional(),
      total: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/packages/limited',
    alias: 'get-fleet-epm-packages-limited',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/packages/limited&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-read OR fleet-setup OR fleet-all.`,
    requestFormat: 'json',
    response: z.object({ items: z.array(z.string()) }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/templates/:pkgName/:pkgVersion/inputs',
    alias: 'get-fleet-epm-templates-pkgname-pkgversion-inputs',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/templates/{pkgName}/{pkgVersion}/inputs&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-read OR fleet-setup OR fleet-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'pkgName',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'pkgVersion',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['json', 'yml', 'yaml']).optional().default('json'),
      },
      {
        name: 'prerelease',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'ignoreUnverified',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.union([
      z.string(),
      z.object({
        inputs: z.array(
          z.object({
            id: z.string(),
            streams: z
              .array(
                z
                  .object({
                    data_stream: z
                      .object({ dataset: z.string(), type: z.string().optional() })
                      .passthrough(),
                    id: z.string(),
                  })
                  .passthrough()
              )
              .optional(),
            type: z.string(),
          })
        ),
      }),
    ]),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/epm/verification_key_id',
    alias: 'get-fleet-epm-verification-key-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/epm/verification_key_id&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: integrations-read OR fleet-setup OR fleet-all.`,
    requestFormat: 'json',
    response: z.object({ id: z.string().nullable() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/fleet_server_hosts',
    alias: 'get-fleet-fleet-server-hosts',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/fleet_server_hosts&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all OR fleet-settings-read.`,
    requestFormat: 'json',
    response: z.object({
      items: z.array(
        z.object({
          host_urls: z.array(z.string()).min(1),
          id: z.string(),
          is_default: z.boolean().optional().default(false),
          is_internal: z.boolean().optional(),
          is_preconfigured: z.boolean().optional().default(false),
          name: z.string(),
          proxy_id: z.string().nullish(),
          secrets: z
            .object({
              ssl: z
                .object({
                  es_key: z.union([z.object({ id: z.string() }), z.string()]),
                  key: z.union([z.object({ id: z.string() }), z.string()]),
                })
                .partial(),
            })
            .partial()
            .optional(),
          ssl: z
            .object({
              certificate: z.string(),
              certificate_authorities: z.array(z.string()),
              client_auth: z.enum(['optional', 'required', 'none']),
              es_certificate: z.string(),
              es_certificate_authorities: z.array(z.string()),
              es_key: z.string(),
              key: z.string(),
            })
            .partial()
            .nullish(),
        })
      ),
      page: z.number(),
      perPage: z.number(),
      total: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/fleet_server_hosts',
    alias: 'post-fleet-fleet-server-hosts',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/fleet_server_hosts&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_fleet_server_hosts_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        host_urls: z.array(z.string()).min(1),
        id: z.string(),
        is_default: z.boolean().optional().default(false),
        is_internal: z.boolean().optional(),
        is_preconfigured: z.boolean().optional().default(false),
        name: z.string(),
        proxy_id: z.string().nullish(),
        secrets: z
          .object({
            ssl: z
              .object({
                es_key: z.union([z.object({ id: z.string() }), z.string()]),
                key: z.union([z.object({ id: z.string() }), z.string()]),
              })
              .partial(),
          })
          .partial()
          .optional(),
        ssl: z
          .object({
            certificate: z.string(),
            certificate_authorities: z.array(z.string()),
            client_auth: z.enum(['optional', 'required', 'none']),
            es_certificate: z.string(),
            es_certificate_authorities: z.array(z.string()),
            es_key: z.string(),
            key: z.string(),
          })
          .partial()
          .nullish(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/fleet_server_hosts/:itemId',
    alias: 'delete-fleet-fleet-server-hosts-itemid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/fleet_server_hosts/{itemId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a Fleet Server host by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'itemId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ id: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/fleet_server_hosts/:itemId',
    alias: 'get-fleet-fleet-server-hosts-itemid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/fleet_server_hosts/{itemId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a Fleet Server host by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'itemId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        host_urls: z.array(z.string()).min(1),
        id: z.string(),
        is_default: z.boolean().optional().default(false),
        is_internal: z.boolean().optional(),
        is_preconfigured: z.boolean().optional().default(false),
        name: z.string(),
        proxy_id: z.string().nullish(),
        secrets: z
          .object({
            ssl: z
              .object({
                es_key: z.union([z.object({ id: z.string() }), z.string()]),
                key: z.union([z.object({ id: z.string() }), z.string()]),
              })
              .partial(),
          })
          .partial()
          .optional(),
        ssl: z
          .object({
            certificate: z.string(),
            certificate_authorities: z.array(z.string()),
            client_auth: z.enum(['optional', 'required', 'none']),
            es_certificate: z.string(),
            es_certificate_authorities: z.array(z.string()),
            es_key: z.string(),
            key: z.string(),
          })
          .partial()
          .nullish(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/fleet/fleet_server_hosts/:itemId',
    alias: 'put-fleet-fleet-server-hosts-itemid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/fleet_server_hosts/{itemId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update a Fleet Server host by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_fleet_fleet_server_hosts_itemid_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'itemId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        host_urls: z.array(z.string()).min(1),
        id: z.string(),
        is_default: z.boolean().optional().default(false),
        is_internal: z.boolean().optional(),
        is_preconfigured: z.boolean().optional().default(false),
        name: z.string(),
        proxy_id: z.string().nullish(),
        secrets: z
          .object({
            ssl: z
              .object({
                es_key: z.union([z.object({ id: z.string() }), z.string()]),
                key: z.union([z.object({ id: z.string() }), z.string()]),
              })
              .partial(),
          })
          .partial()
          .optional(),
        ssl: z
          .object({
            certificate: z.string(),
            certificate_authorities: z.array(z.string()),
            client_auth: z.enum(['optional', 'required', 'none']),
            es_certificate: z.string(),
            es_certificate_authorities: z.array(z.string()),
            es_key: z.string(),
            key: z.string(),
          })
          .partial()
          .nullish(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/health_check',
    alias: 'post-fleet-health-check',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/health_check&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ id: z.string() }),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      host_id: z.string().optional(),
      name: z.string().optional(),
      status: z.string(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 404,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/kubernetes',
    alias: 'get-fleet-kubernetes',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/kubernetes&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agent-policies-read AND fleet-setup.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'download',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'fleetServer',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'enrolToken',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z.object({ item: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/kubernetes/download',
    alias: 'get-fleet-kubernetes-download',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/kubernetes/download&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agent-policies-read AND fleet-setup.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'download',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'fleetServer',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'enrolToken',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z.string(),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 404,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/logstash_api_keys',
    alias: 'post-fleet-logstash-api-keys',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/logstash_api_keys&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ api_key: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/message_signing_service/rotate_key_pair',
    alias: 'post-fleet-message-signing-service-rotate-key-pair',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/message_signing_service/rotate_key_pair&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all AND fleet-agent-policies-all AND fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'acknowledge',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({ message: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 500,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/outputs',
    alias: 'get-fleet-outputs',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/outputs&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-read OR fleet-agent-policies-read.`,
    requestFormat: 'json',
    response: z.object({
      items: z.array(
        z.union([
          z
            .object({
              allow_edit: z.array(z.string()).optional(),
              ca_sha256: z.string().nullish(),
              ca_trusted_fingerprint: z.string().nullish(),
              config_yaml: z.string().nullish(),
              hosts: z.array(z.string().url()).min(1),
              id: z.string().optional(),
              is_default: z.boolean().optional().default(false),
              is_default_monitoring: z.boolean().optional().default(false),
              is_internal: z.boolean().optional(),
              is_preconfigured: z.boolean().optional(),
              name: z.string(),
              preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']).optional(),
              proxy_id: z.string().nullish(),
              secrets: z
                .object({
                  ssl: z
                    .object({
                      key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                    })
                    .partial()
                    .passthrough(),
                })
                .partial()
                .passthrough()
                .optional(),
              shipper: z
                .object({
                  compression_level: z.number().nullable(),
                  disk_queue_compression_enabled: z.boolean().nullable(),
                  disk_queue_enabled: z.boolean().nullish().default(false),
                  disk_queue_encryption_enabled: z.boolean().nullable(),
                  disk_queue_max_size: z.number().nullable(),
                  disk_queue_path: z.string().nullable(),
                  loadbalance: z.boolean().nullable(),
                  max_batch_bytes: z.number().nullable(),
                  mem_queue_events: z.number().nullable(),
                  queue_flush_timeout: z.number().nullable(),
                })
                .passthrough()
                .nullish(),
              ssl: z
                .object({
                  certificate: z.string(),
                  certificate_authorities: z.array(z.string()),
                  key: z.string(),
                  verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
                })
                .partial()
                .passthrough()
                .nullish(),
              type: z.literal('elasticsearch'),
              write_to_logs_streams: z.boolean().optional(),
            })
            .passthrough(),
          z
            .object({
              allow_edit: z.array(z.string()).optional(),
              ca_sha256: z.string().nullish(),
              ca_trusted_fingerprint: z.string().nullish(),
              config_yaml: z.string().nullish(),
              hosts: z.array(z.string().url()).min(1),
              id: z.string().optional(),
              is_default: z.boolean().optional().default(false),
              is_default_monitoring: z.boolean().optional().default(false),
              is_internal: z.boolean().optional(),
              is_preconfigured: z.boolean().optional(),
              kibana_api_key: z.string().nullish(),
              kibana_url: z.string().nullish(),
              name: z.string(),
              preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']).optional(),
              proxy_id: z.string().nullish(),
              secrets: z
                .object({
                  service_token: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  ssl: z
                    .object({
                      key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                    })
                    .partial()
                    .passthrough(),
                })
                .partial()
                .passthrough()
                .optional(),
              service_token: z.string().nullish(),
              shipper: z
                .object({
                  compression_level: z.number().nullable(),
                  disk_queue_compression_enabled: z.boolean().nullable(),
                  disk_queue_enabled: z.boolean().nullish().default(false),
                  disk_queue_encryption_enabled: z.boolean().nullable(),
                  disk_queue_max_size: z.number().nullable(),
                  disk_queue_path: z.string().nullable(),
                  loadbalance: z.boolean().nullable(),
                  max_batch_bytes: z.number().nullable(),
                  mem_queue_events: z.number().nullable(),
                  queue_flush_timeout: z.number().nullable(),
                })
                .passthrough()
                .nullish(),
              ssl: z
                .object({
                  certificate: z.string(),
                  certificate_authorities: z.array(z.string()),
                  key: z.string(),
                  verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
                })
                .partial()
                .passthrough()
                .nullish(),
              sync_integrations: z.boolean().optional(),
              sync_uninstalled_integrations: z.boolean().optional(),
              type: z.literal('remote_elasticsearch'),
              write_to_logs_streams: z.boolean().optional(),
            })
            .passthrough(),
          z
            .object({
              allow_edit: z.array(z.string()).optional(),
              ca_sha256: z.string().nullish(),
              ca_trusted_fingerprint: z.string().nullish(),
              config_yaml: z.string().nullish(),
              hosts: z.array(z.string()).min(1),
              id: z.string().optional(),
              is_default: z.boolean().optional().default(false),
              is_default_monitoring: z.boolean().optional().default(false),
              is_internal: z.boolean().optional(),
              is_preconfigured: z.boolean().optional(),
              name: z.string(),
              proxy_id: z.string().nullish(),
              secrets: z
                .object({
                  ssl: z
                    .object({
                      key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                    })
                    .partial()
                    .passthrough(),
                })
                .partial()
                .passthrough()
                .optional(),
              shipper: z
                .object({
                  compression_level: z.number().nullable(),
                  disk_queue_compression_enabled: z.boolean().nullable(),
                  disk_queue_enabled: z.boolean().nullish().default(false),
                  disk_queue_encryption_enabled: z.boolean().nullable(),
                  disk_queue_max_size: z.number().nullable(),
                  disk_queue_path: z.string().nullable(),
                  loadbalance: z.boolean().nullable(),
                  max_batch_bytes: z.number().nullable(),
                  mem_queue_events: z.number().nullable(),
                  queue_flush_timeout: z.number().nullable(),
                })
                .passthrough()
                .nullish(),
              ssl: z
                .object({
                  certificate: z.string(),
                  certificate_authorities: z.array(z.string()),
                  key: z.string(),
                  verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
                })
                .partial()
                .passthrough()
                .nullish(),
              type: z.literal('logstash'),
              write_to_logs_streams: z.boolean().optional(),
            })
            .passthrough(),
          z
            .object({
              allow_edit: z.array(z.string()).optional(),
              auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']),
              broker_timeout: z.number().optional(),
              ca_sha256: z.string().nullish(),
              ca_trusted_fingerprint: z.string().nullish(),
              client_id: z.string().optional(),
              compression: z.enum(['gzip', 'snappy', 'lz4', 'none']).optional(),
              compression_level: z.union([z.number(), z.unknown()]).nullable(),
              config_yaml: z.string().nullish(),
              connection_type: z
                .union([z.enum(['plaintext', 'encryption']), z.unknown()])
                .nullable(),
              hash: z
                .object({ hash: z.string(), random: z.boolean() })
                .partial()
                .passthrough()
                .optional(),
              headers: z
                .array(z.object({ key: z.string(), value: z.string() }).passthrough())
                .optional(),
              hosts: z.array(z.string()).min(1),
              id: z.string().optional(),
              is_default: z.boolean().optional().default(false),
              is_default_monitoring: z.boolean().optional().default(false),
              is_internal: z.boolean().optional(),
              is_preconfigured: z.boolean().optional(),
              key: z.string().optional(),
              name: z.string(),
              partition: z.enum(['random', 'round_robin', 'hash']).optional(),
              password: z.union([z.unknown(), z.union([z.string(), z.unknown()])]).nullable(),
              proxy_id: z.string().nullish(),
              random: z.object({ group_events: z.number() }).partial().passthrough().optional(),
              required_acks: z.union([z.literal(1), z.literal(0), z.literal(-1)]).optional(),
              round_robin: z
                .object({ group_events: z.number() })
                .partial()
                .passthrough()
                .optional(),
              sasl: z
                .object({ mechanism: z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512']) })
                .partial()
                .passthrough()
                .nullish(),
              secrets: z
                .object({
                  password: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  ssl: z
                    .object({
                      key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                    })
                    .passthrough(),
                })
                .partial()
                .passthrough()
                .optional(),
              shipper: z
                .object({
                  compression_level: z.number().nullable(),
                  disk_queue_compression_enabled: z.boolean().nullable(),
                  disk_queue_enabled: z.boolean().nullish().default(false),
                  disk_queue_encryption_enabled: z.boolean().nullable(),
                  disk_queue_max_size: z.number().nullable(),
                  disk_queue_path: z.string().nullable(),
                  loadbalance: z.boolean().nullable(),
                  max_batch_bytes: z.number().nullable(),
                  mem_queue_events: z.number().nullable(),
                  queue_flush_timeout: z.number().nullable(),
                })
                .passthrough()
                .nullish(),
              ssl: z
                .object({
                  certificate: z.string(),
                  certificate_authorities: z.array(z.string()),
                  key: z.string(),
                  verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
                })
                .partial()
                .passthrough()
                .nullish(),
              timeout: z.number().optional(),
              topic: z.string().optional(),
              type: z.literal('kafka'),
              username: z.union([z.string(), z.unknown()]).nullable(),
              version: z.string().optional(),
              write_to_logs_streams: z.boolean().optional(),
            })
            .passthrough(),
        ])
      ),
      page: z.number(),
      perPage: z.number(),
      total: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/outputs',
    alias: 'post-fleet-outputs',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/outputs&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_outputs_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.union([
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            config_yaml: z.string().nullish(),
            hosts: z.array(z.string().url()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            name: z.string(),
            preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']).optional(),
            proxy_id: z.string().nullish(),
            secrets: z
              .object({
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .partial()
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            type: z.literal('elasticsearch'),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            config_yaml: z.string().nullish(),
            hosts: z.array(z.string().url()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            kibana_api_key: z.string().nullish(),
            kibana_url: z.string().nullish(),
            name: z.string(),
            preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']).optional(),
            proxy_id: z.string().nullish(),
            secrets: z
              .object({
                service_token: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .partial()
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            service_token: z.string().nullish(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            sync_integrations: z.boolean().optional(),
            sync_uninstalled_integrations: z.boolean().optional(),
            type: z.literal('remote_elasticsearch'),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            config_yaml: z.string().nullish(),
            hosts: z.array(z.string()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            name: z.string(),
            proxy_id: z.string().nullish(),
            secrets: z
              .object({
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .partial()
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            type: z.literal('logstash'),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']),
            broker_timeout: z.number().optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            client_id: z.string().optional(),
            compression: z.enum(['gzip', 'snappy', 'lz4', 'none']).optional(),
            compression_level: z.union([z.number(), z.unknown()]).nullable(),
            config_yaml: z.string().nullish(),
            connection_type: z.union([z.enum(['plaintext', 'encryption']), z.unknown()]).nullable(),
            hash: z
              .object({ hash: z.string(), random: z.boolean() })
              .partial()
              .passthrough()
              .optional(),
            headers: z
              .array(z.object({ key: z.string(), value: z.string() }).passthrough())
              .optional(),
            hosts: z.array(z.string()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            key: z.string().optional(),
            name: z.string(),
            partition: z.enum(['random', 'round_robin', 'hash']).optional(),
            password: z.union([z.unknown(), z.union([z.string(), z.unknown()])]).nullable(),
            proxy_id: z.string().nullish(),
            random: z.object({ group_events: z.number() }).partial().passthrough().optional(),
            required_acks: z.union([z.literal(1), z.literal(0), z.literal(-1)]).optional(),
            round_robin: z.object({ group_events: z.number() }).partial().passthrough().optional(),
            sasl: z
              .object({ mechanism: z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512']) })
              .partial()
              .passthrough()
              .nullish(),
            secrets: z
              .object({
                password: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            timeout: z.number().optional(),
            topic: z.string().optional(),
            type: z.literal('kafka'),
            username: z.union([z.string(), z.unknown()]).nullable(),
            version: z.string().optional(),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
      ]),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/outputs/:outputId',
    alias: 'delete-fleet-outputs-outputid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/outputs/{outputId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete output by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'outputId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ id: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 404,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/outputs/:outputId',
    alias: 'get-fleet-outputs-outputid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/outputs/{outputId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get output by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-read OR fleet-agent-policies-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'outputId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.union([
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            config_yaml: z.string().nullish(),
            hosts: z.array(z.string().url()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            name: z.string(),
            preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']).optional(),
            proxy_id: z.string().nullish(),
            secrets: z
              .object({
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .partial()
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            type: z.literal('elasticsearch'),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            config_yaml: z.string().nullish(),
            hosts: z.array(z.string().url()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            kibana_api_key: z.string().nullish(),
            kibana_url: z.string().nullish(),
            name: z.string(),
            preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']).optional(),
            proxy_id: z.string().nullish(),
            secrets: z
              .object({
                service_token: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .partial()
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            service_token: z.string().nullish(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            sync_integrations: z.boolean().optional(),
            sync_uninstalled_integrations: z.boolean().optional(),
            type: z.literal('remote_elasticsearch'),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            config_yaml: z.string().nullish(),
            hosts: z.array(z.string()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            name: z.string(),
            proxy_id: z.string().nullish(),
            secrets: z
              .object({
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .partial()
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            type: z.literal('logstash'),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']),
            broker_timeout: z.number().optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            client_id: z.string().optional(),
            compression: z.enum(['gzip', 'snappy', 'lz4', 'none']).optional(),
            compression_level: z.union([z.number(), z.unknown()]).nullable(),
            config_yaml: z.string().nullish(),
            connection_type: z.union([z.enum(['plaintext', 'encryption']), z.unknown()]).nullable(),
            hash: z
              .object({ hash: z.string(), random: z.boolean() })
              .partial()
              .passthrough()
              .optional(),
            headers: z
              .array(z.object({ key: z.string(), value: z.string() }).passthrough())
              .optional(),
            hosts: z.array(z.string()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            key: z.string().optional(),
            name: z.string(),
            partition: z.enum(['random', 'round_robin', 'hash']).optional(),
            password: z.union([z.unknown(), z.union([z.string(), z.unknown()])]).nullable(),
            proxy_id: z.string().nullish(),
            random: z.object({ group_events: z.number() }).partial().passthrough().optional(),
            required_acks: z.union([z.literal(1), z.literal(0), z.literal(-1)]).optional(),
            round_robin: z.object({ group_events: z.number() }).partial().passthrough().optional(),
            sasl: z
              .object({ mechanism: z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512']) })
              .partial()
              .passthrough()
              .nullish(),
            secrets: z
              .object({
                password: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            timeout: z.number().optional(),
            topic: z.string().optional(),
            type: z.literal('kafka'),
            username: z.union([z.string(), z.unknown()]).nullable(),
            version: z.string().optional(),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
      ]),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/fleet/outputs/:outputId',
    alias: 'put-fleet-outputs-outputid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/outputs/{outputId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update output by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-all OR fleet-agent-policies-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_fleet_outputs_outputid_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'outputId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.union([
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            config_yaml: z.string().nullish(),
            hosts: z.array(z.string().url()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            name: z.string(),
            preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']).optional(),
            proxy_id: z.string().nullish(),
            secrets: z
              .object({
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .partial()
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            type: z.literal('elasticsearch'),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            config_yaml: z.string().nullish(),
            hosts: z.array(z.string().url()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            kibana_api_key: z.string().nullish(),
            kibana_url: z.string().nullish(),
            name: z.string(),
            preset: z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency']).optional(),
            proxy_id: z.string().nullish(),
            secrets: z
              .object({
                service_token: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .partial()
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            service_token: z.string().nullish(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            sync_integrations: z.boolean().optional(),
            sync_uninstalled_integrations: z.boolean().optional(),
            type: z.literal('remote_elasticsearch'),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            config_yaml: z.string().nullish(),
            hosts: z.array(z.string()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            name: z.string(),
            proxy_id: z.string().nullish(),
            secrets: z
              .object({
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .partial()
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            type: z.literal('logstash'),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
        z
          .object({
            allow_edit: z.array(z.string()).optional(),
            auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']),
            broker_timeout: z.number().optional(),
            ca_sha256: z.string().nullish(),
            ca_trusted_fingerprint: z.string().nullish(),
            client_id: z.string().optional(),
            compression: z.enum(['gzip', 'snappy', 'lz4', 'none']).optional(),
            compression_level: z.union([z.number(), z.unknown()]).nullable(),
            config_yaml: z.string().nullish(),
            connection_type: z.union([z.enum(['plaintext', 'encryption']), z.unknown()]).nullable(),
            hash: z
              .object({ hash: z.string(), random: z.boolean() })
              .partial()
              .passthrough()
              .optional(),
            headers: z
              .array(z.object({ key: z.string(), value: z.string() }).passthrough())
              .optional(),
            hosts: z.array(z.string()).min(1),
            id: z.string().optional(),
            is_default: z.boolean().optional().default(false),
            is_default_monitoring: z.boolean().optional().default(false),
            is_internal: z.boolean().optional(),
            is_preconfigured: z.boolean().optional(),
            key: z.string().optional(),
            name: z.string(),
            partition: z.enum(['random', 'round_robin', 'hash']).optional(),
            password: z.union([z.unknown(), z.union([z.string(), z.unknown()])]).nullable(),
            proxy_id: z.string().nullish(),
            random: z.object({ group_events: z.number() }).partial().passthrough().optional(),
            required_acks: z.union([z.literal(1), z.literal(0), z.literal(-1)]).optional(),
            round_robin: z.object({ group_events: z.number() }).partial().passthrough().optional(),
            sasl: z
              .object({ mechanism: z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512']) })
              .partial()
              .passthrough()
              .nullish(),
            secrets: z
              .object({
                password: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                ssl: z
                  .object({
                    key: z.union([z.object({ id: z.string() }).passthrough(), z.string()]),
                  })
                  .passthrough(),
              })
              .partial()
              .passthrough()
              .optional(),
            shipper: z
              .object({
                compression_level: z.number().nullable(),
                disk_queue_compression_enabled: z.boolean().nullable(),
                disk_queue_enabled: z.boolean().nullish().default(false),
                disk_queue_encryption_enabled: z.boolean().nullable(),
                disk_queue_max_size: z.number().nullable(),
                disk_queue_path: z.string().nullable(),
                loadbalance: z.boolean().nullable(),
                max_batch_bytes: z.number().nullable(),
                mem_queue_events: z.number().nullable(),
                queue_flush_timeout: z.number().nullable(),
              })
              .passthrough()
              .nullish(),
            ssl: z
              .object({
                certificate: z.string(),
                certificate_authorities: z.array(z.string()),
                key: z.string(),
                verification_mode: z.enum(['full', 'none', 'certificate', 'strict']),
              })
              .partial()
              .passthrough()
              .nullish(),
            timeout: z.number().optional(),
            topic: z.string().optional(),
            type: z.literal('kafka'),
            username: z.union([z.string(), z.unknown()]).nullable(),
            version: z.string().optional(),
            write_to_logs_streams: z.boolean().optional(),
          })
          .passthrough(),
      ]),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/outputs/:outputId/health',
    alias: 'get-fleet-outputs-outputid-health',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/outputs/{outputId}/health&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'outputId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ message: z.string(), state: z.string(), timestamp: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/package_policies',
    alias: 'get-fleet-package-policies',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/package_policies&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'page',
        type: 'Query',
        schema: z.number().optional(),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().optional(),
      },
      {
        name: 'sortField',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['desc', 'asc']).optional(),
      },
      {
        name: 'showUpgradeable',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'kuery',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['simplified', 'legacy']).optional(),
      },
      {
        name: 'withAgentCount',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          additional_datastreams_permissions: z.array(z.string()).nullish(),
          agents: z.number().optional(),
          created_at: z.string(),
          created_by: z.string(),
          description: z.string().optional(),
          elasticsearch: z
            .object({
              privileges: z
                .object({ cluster: z.array(z.string()) })
                .partial()
                .passthrough(),
            })
            .partial()
            .passthrough()
            .optional(),
          enabled: z.boolean(),
          id: z.string(),
          inputs: z.union([
            z.array(
              z.object({
                compiled_input: z.unknown(),
                config: z
                  .record(
                    z.object({
                      frozen: z.boolean().optional(),
                      type: z.string().optional(),
                      value: z.unknown(),
                    })
                  )
                  .optional(),
                enabled: z.boolean(),
                id: z.string().optional(),
                keep_enabled: z.boolean().optional(),
                policy_template: z.string().optional(),
                streams: z.array(
                  z.object({
                    compiled_stream: z.unknown(),
                    config: z
                      .record(
                        z.object({
                          frozen: z.boolean().optional(),
                          type: z.string().optional(),
                          value: z.unknown(),
                        })
                      )
                      .optional(),
                    data_stream: z.object({
                      dataset: z.string(),
                      elasticsearch: z
                        .object({
                          dynamic_dataset: z.boolean(),
                          dynamic_namespace: z.boolean(),
                          privileges: z.object({ indices: z.array(z.string()) }).partial(),
                        })
                        .partial()
                        .optional(),
                      type: z.string(),
                    }),
                    enabled: z.boolean(),
                    id: z.string().optional(),
                    keep_enabled: z.boolean().optional(),
                    release: z.enum(['ga', 'beta', 'experimental']).optional(),
                    vars: z
                      .record(
                        z.object({
                          frozen: z.boolean().optional(),
                          type: z.string().optional(),
                          value: z.unknown(),
                        })
                      )
                      .optional(),
                  })
                ),
                type: z.string(),
                vars: z
                  .record(
                    z.object({
                      frozen: z.boolean().optional(),
                      type: z.string().optional(),
                      value: z.unknown(),
                    })
                  )
                  .optional(),
              })
            ),
            z.record(
              z
                .object({
                  enabled: z.boolean(),
                  streams: z.record(
                    z
                      .object({
                        enabled: z.boolean(),
                        vars: z.record(
                          z
                            .union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({ id: z.string(), isSecretRef: z.boolean() }),
                            ])
                            .nullable()
                        ),
                      })
                      .partial()
                  ),
                  vars: z.record(
                    z
                      .union([
                        z.boolean(),
                        z.string(),
                        z.number(),
                        z.array(z.string()),
                        z.array(z.number()),
                        z.object({ id: z.string(), isSecretRef: z.boolean() }),
                      ])
                      .nullable()
                  ),
                })
                .partial()
            ),
          ]),
          is_managed: z.boolean().optional(),
          name: z.string(),
          namespace: z.string().optional(),
          output_id: z.string().nullish(),
          overrides: z
            .object({ inputs: z.object({}).partial().passthrough() })
            .partial()
            .nullish(),
          package: z
            .object({
              experimental_data_stream_features: z
                .array(
                  z.object({
                    data_stream: z.string(),
                    features: z
                      .object({
                        doc_value_only_numeric: z.boolean(),
                        doc_value_only_other: z.boolean(),
                        synthetic_source: z.boolean(),
                        tsdb: z.boolean(),
                      })
                      .partial(),
                  })
                )
                .optional(),
              name: z.string(),
              requires_root: z.boolean().optional(),
              title: z.string().optional(),
              version: z.string(),
            })
            .optional(),
          policy_id: z.string().nullish(),
          policy_ids: z.array(z.string()).optional(),
          revision: z.number(),
          secret_references: z.array(z.object({ id: z.string() })).optional(),
          spaceIds: z.array(z.string()).optional(),
          supports_agentless: z.boolean().nullish().default(false),
          updated_at: z.string(),
          updated_by: z.string(),
          vars: z
            .union([
              z.record(
                z.object({
                  frozen: z.boolean().optional(),
                  type: z.string().optional(),
                  value: z.unknown(),
                })
              ),
              z.record(
                z
                  .union([
                    z.boolean(),
                    z.string(),
                    z.number(),
                    z.array(z.string()),
                    z.array(z.number()),
                    z.object({ id: z.string(), isSecretRef: z.boolean() }),
                  ])
                  .nullable()
              ),
            ])
            .optional(),
          version: z.string().optional(),
        })
      ),
      page: z.number(),
      perPage: z.number(),
      total: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/package_policies',
    alias: 'post-fleet-package-policies',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/package_policies&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_package_policies_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['simplified', 'legacy']).optional(),
      },
    ],
    response: z.object({
      item: z.object({
        additional_datastreams_permissions: z.array(z.string()).nullish(),
        agents: z.number().optional(),
        created_at: z.string(),
        created_by: z.string(),
        description: z.string().optional(),
        elasticsearch: z
          .object({
            privileges: z
              .object({ cluster: z.array(z.string()) })
              .partial()
              .passthrough(),
          })
          .partial()
          .passthrough()
          .optional(),
        enabled: z.boolean(),
        id: z.string(),
        inputs: z.union([
          z.array(
            z.object({
              compiled_input: z.unknown(),
              config: z
                .record(
                  z.object({
                    frozen: z.boolean().optional(),
                    type: z.string().optional(),
                    value: z.unknown(),
                  })
                )
                .optional(),
              enabled: z.boolean(),
              id: z.string().optional(),
              keep_enabled: z.boolean().optional(),
              policy_template: z.string().optional(),
              streams: z.array(
                z.object({
                  compiled_stream: z.unknown(),
                  config: z
                    .record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    )
                    .optional(),
                  data_stream: z.object({
                    dataset: z.string(),
                    elasticsearch: z
                      .object({
                        dynamic_dataset: z.boolean(),
                        dynamic_namespace: z.boolean(),
                        privileges: z.object({ indices: z.array(z.string()) }).partial(),
                      })
                      .partial()
                      .optional(),
                    type: z.string(),
                  }),
                  enabled: z.boolean(),
                  id: z.string().optional(),
                  keep_enabled: z.boolean().optional(),
                  release: z.enum(['ga', 'beta', 'experimental']).optional(),
                  vars: z
                    .record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    )
                    .optional(),
                })
              ),
              type: z.string(),
              vars: z
                .record(
                  z.object({
                    frozen: z.boolean().optional(),
                    type: z.string().optional(),
                    value: z.unknown(),
                  })
                )
                .optional(),
            })
          ),
          z.record(
            z
              .object({
                enabled: z.boolean(),
                streams: z.record(
                  z
                    .object({
                      enabled: z.boolean(),
                      vars: z.record(
                        z
                          .union([
                            z.boolean(),
                            z.string(),
                            z.number(),
                            z.array(z.string()),
                            z.array(z.number()),
                            z.object({ id: z.string(), isSecretRef: z.boolean() }),
                          ])
                          .nullable()
                      ),
                    })
                    .partial()
                ),
                vars: z.record(
                  z
                    .union([
                      z.boolean(),
                      z.string(),
                      z.number(),
                      z.array(z.string()),
                      z.array(z.number()),
                      z.object({ id: z.string(), isSecretRef: z.boolean() }),
                    ])
                    .nullable()
                ),
              })
              .partial()
          ),
        ]),
        is_managed: z.boolean().optional(),
        name: z.string(),
        namespace: z.string().optional(),
        output_id: z.string().nullish(),
        overrides: z
          .object({ inputs: z.object({}).partial().passthrough() })
          .partial()
          .nullish(),
        package: z
          .object({
            experimental_data_stream_features: z
              .array(
                z.object({
                  data_stream: z.string(),
                  features: z
                    .object({
                      doc_value_only_numeric: z.boolean(),
                      doc_value_only_other: z.boolean(),
                      synthetic_source: z.boolean(),
                      tsdb: z.boolean(),
                    })
                    .partial(),
                })
              )
              .optional(),
            name: z.string(),
            requires_root: z.boolean().optional(),
            title: z.string().optional(),
            version: z.string(),
          })
          .optional(),
        policy_id: z.string().nullish(),
        policy_ids: z.array(z.string()).optional(),
        revision: z.number(),
        secret_references: z.array(z.object({ id: z.string() })).optional(),
        spaceIds: z.array(z.string()).optional(),
        supports_agentless: z.boolean().nullish().default(false),
        updated_at: z.string(),
        updated_by: z.string(),
        vars: z
          .union([
            z.record(
              z.object({
                frozen: z.boolean().optional(),
                type: z.string().optional(),
                value: z.unknown(),
              })
            ),
            z.record(
              z
                .union([
                  z.boolean(),
                  z.string(),
                  z.number(),
                  z.array(z.string()),
                  z.array(z.number()),
                  z.object({ id: z.string(), isSecretRef: z.boolean() }),
                ])
                .nullable()
            ),
          ])
          .optional(),
        version: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 409,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/package_policies/_bulk_get',
    alias: 'post-fleet-package-policies-bulk-get',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/package_policies/_bulk_get&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_package_policies_bulk_get_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['simplified', 'legacy']).optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          additional_datastreams_permissions: z.array(z.string()).nullish(),
          agents: z.number().optional(),
          created_at: z.string(),
          created_by: z.string(),
          description: z.string().optional(),
          elasticsearch: z
            .object({
              privileges: z
                .object({ cluster: z.array(z.string()) })
                .partial()
                .passthrough(),
            })
            .partial()
            .passthrough()
            .optional(),
          enabled: z.boolean(),
          id: z.string(),
          inputs: z.union([
            z.array(
              z.object({
                compiled_input: z.unknown(),
                config: z
                  .record(
                    z.object({
                      frozen: z.boolean().optional(),
                      type: z.string().optional(),
                      value: z.unknown(),
                    })
                  )
                  .optional(),
                enabled: z.boolean(),
                id: z.string().optional(),
                keep_enabled: z.boolean().optional(),
                policy_template: z.string().optional(),
                streams: z.array(
                  z.object({
                    compiled_stream: z.unknown(),
                    config: z
                      .record(
                        z.object({
                          frozen: z.boolean().optional(),
                          type: z.string().optional(),
                          value: z.unknown(),
                        })
                      )
                      .optional(),
                    data_stream: z.object({
                      dataset: z.string(),
                      elasticsearch: z
                        .object({
                          dynamic_dataset: z.boolean(),
                          dynamic_namespace: z.boolean(),
                          privileges: z.object({ indices: z.array(z.string()) }).partial(),
                        })
                        .partial()
                        .optional(),
                      type: z.string(),
                    }),
                    enabled: z.boolean(),
                    id: z.string().optional(),
                    keep_enabled: z.boolean().optional(),
                    release: z.enum(['ga', 'beta', 'experimental']).optional(),
                    vars: z
                      .record(
                        z.object({
                          frozen: z.boolean().optional(),
                          type: z.string().optional(),
                          value: z.unknown(),
                        })
                      )
                      .optional(),
                  })
                ),
                type: z.string(),
                vars: z
                  .record(
                    z.object({
                      frozen: z.boolean().optional(),
                      type: z.string().optional(),
                      value: z.unknown(),
                    })
                  )
                  .optional(),
              })
            ),
            z.record(
              z
                .object({
                  enabled: z.boolean(),
                  streams: z.record(
                    z
                      .object({
                        enabled: z.boolean(),
                        vars: z.record(
                          z
                            .union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({ id: z.string(), isSecretRef: z.boolean() }),
                            ])
                            .nullable()
                        ),
                      })
                      .partial()
                  ),
                  vars: z.record(
                    z
                      .union([
                        z.boolean(),
                        z.string(),
                        z.number(),
                        z.array(z.string()),
                        z.array(z.number()),
                        z.object({ id: z.string(), isSecretRef: z.boolean() }),
                      ])
                      .nullable()
                  ),
                })
                .partial()
            ),
          ]),
          is_managed: z.boolean().optional(),
          name: z.string(),
          namespace: z.string().optional(),
          output_id: z.string().nullish(),
          overrides: z
            .object({ inputs: z.object({}).partial().passthrough() })
            .partial()
            .nullish(),
          package: z
            .object({
              experimental_data_stream_features: z
                .array(
                  z.object({
                    data_stream: z.string(),
                    features: z
                      .object({
                        doc_value_only_numeric: z.boolean(),
                        doc_value_only_other: z.boolean(),
                        synthetic_source: z.boolean(),
                        tsdb: z.boolean(),
                      })
                      .partial(),
                  })
                )
                .optional(),
              name: z.string(),
              requires_root: z.boolean().optional(),
              title: z.string().optional(),
              version: z.string(),
            })
            .optional(),
          policy_id: z.string().nullish(),
          policy_ids: z.array(z.string()).optional(),
          revision: z.number(),
          secret_references: z.array(z.object({ id: z.string() })).optional(),
          spaceIds: z.array(z.string()).optional(),
          supports_agentless: z.boolean().nullish().default(false),
          updated_at: z.string(),
          updated_by: z.string(),
          vars: z
            .union([
              z.record(
                z.object({
                  frozen: z.boolean().optional(),
                  type: z.string().optional(),
                  value: z.unknown(),
                })
              ),
              z.record(
                z
                  .union([
                    z.boolean(),
                    z.string(),
                    z.number(),
                    z.array(z.string()),
                    z.array(z.number()),
                    z.object({ id: z.string(), isSecretRef: z.boolean() }),
                  ])
                  .nullable()
              ),
            ])
            .optional(),
          version: z.string().optional(),
        })
      ),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 404,
        schema: z.object({ message: z.string() }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/package_policies/:packagePolicyId',
    alias: 'delete-fleet-package-policies-packagepolicyid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/package_policies/{packagePolicyId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a package policy by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-all AND integrations-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'packagePolicyId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'force',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.object({ id: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/package_policies/:packagePolicyId',
    alias: 'get-fleet-package-policies-packagepolicyid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/package_policies/{packagePolicyId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a package policy by ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'packagePolicyId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['simplified', 'legacy']).optional(),
      },
    ],
    response: z.object({
      item: z.object({
        additional_datastreams_permissions: z.array(z.string()).nullish(),
        agents: z.number().optional(),
        created_at: z.string(),
        created_by: z.string(),
        description: z.string().optional(),
        elasticsearch: z
          .object({
            privileges: z
              .object({ cluster: z.array(z.string()) })
              .partial()
              .passthrough(),
          })
          .partial()
          .passthrough()
          .optional(),
        enabled: z.boolean(),
        id: z.string(),
        inputs: z.union([
          z.array(
            z.object({
              compiled_input: z.unknown(),
              config: z
                .record(
                  z.object({
                    frozen: z.boolean().optional(),
                    type: z.string().optional(),
                    value: z.unknown(),
                  })
                )
                .optional(),
              enabled: z.boolean(),
              id: z.string().optional(),
              keep_enabled: z.boolean().optional(),
              policy_template: z.string().optional(),
              streams: z.array(
                z.object({
                  compiled_stream: z.unknown(),
                  config: z
                    .record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    )
                    .optional(),
                  data_stream: z.object({
                    dataset: z.string(),
                    elasticsearch: z
                      .object({
                        dynamic_dataset: z.boolean(),
                        dynamic_namespace: z.boolean(),
                        privileges: z.object({ indices: z.array(z.string()) }).partial(),
                      })
                      .partial()
                      .optional(),
                    type: z.string(),
                  }),
                  enabled: z.boolean(),
                  id: z.string().optional(),
                  keep_enabled: z.boolean().optional(),
                  release: z.enum(['ga', 'beta', 'experimental']).optional(),
                  vars: z
                    .record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    )
                    .optional(),
                })
              ),
              type: z.string(),
              vars: z
                .record(
                  z.object({
                    frozen: z.boolean().optional(),
                    type: z.string().optional(),
                    value: z.unknown(),
                  })
                )
                .optional(),
            })
          ),
          z.record(
            z
              .object({
                enabled: z.boolean(),
                streams: z.record(
                  z
                    .object({
                      enabled: z.boolean(),
                      vars: z.record(
                        z
                          .union([
                            z.boolean(),
                            z.string(),
                            z.number(),
                            z.array(z.string()),
                            z.array(z.number()),
                            z.object({ id: z.string(), isSecretRef: z.boolean() }),
                          ])
                          .nullable()
                      ),
                    })
                    .partial()
                ),
                vars: z.record(
                  z
                    .union([
                      z.boolean(),
                      z.string(),
                      z.number(),
                      z.array(z.string()),
                      z.array(z.number()),
                      z.object({ id: z.string(), isSecretRef: z.boolean() }),
                    ])
                    .nullable()
                ),
              })
              .partial()
          ),
        ]),
        is_managed: z.boolean().optional(),
        name: z.string(),
        namespace: z.string().optional(),
        output_id: z.string().nullish(),
        overrides: z
          .object({ inputs: z.object({}).partial().passthrough() })
          .partial()
          .nullish(),
        package: z
          .object({
            experimental_data_stream_features: z
              .array(
                z.object({
                  data_stream: z.string(),
                  features: z
                    .object({
                      doc_value_only_numeric: z.boolean(),
                      doc_value_only_other: z.boolean(),
                      synthetic_source: z.boolean(),
                      tsdb: z.boolean(),
                    })
                    .partial(),
                })
              )
              .optional(),
            name: z.string(),
            requires_root: z.boolean().optional(),
            title: z.string().optional(),
            version: z.string(),
          })
          .optional(),
        policy_id: z.string().nullish(),
        policy_ids: z.array(z.string()).optional(),
        revision: z.number(),
        secret_references: z.array(z.object({ id: z.string() })).optional(),
        spaceIds: z.array(z.string()).optional(),
        supports_agentless: z.boolean().nullish().default(false),
        updated_at: z.string(),
        updated_by: z.string(),
        vars: z
          .union([
            z.record(
              z.object({
                frozen: z.boolean().optional(),
                type: z.string().optional(),
                value: z.unknown(),
              })
            ),
            z.record(
              z
                .union([
                  z.boolean(),
                  z.string(),
                  z.number(),
                  z.array(z.string()),
                  z.array(z.number()),
                  z.object({ id: z.string(), isSecretRef: z.boolean() }),
                ])
                .nullable()
            ),
          ])
          .optional(),
        version: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 404,
        schema: z.object({ message: z.string() }),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/fleet/package_policies/:packagePolicyId',
    alias: 'put-fleet-package-policies-packagepolicyid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/package_policies/{packagePolicyId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update a package policy by ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_fleet_package_policies_packagepolicyid_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'packagePolicyId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'format',
        type: 'Query',
        schema: z.enum(['simplified', 'legacy']).optional(),
      },
    ],
    response: z.object({
      item: z.object({
        additional_datastreams_permissions: z.array(z.string()).nullish(),
        agents: z.number().optional(),
        created_at: z.string(),
        created_by: z.string(),
        description: z.string().optional(),
        elasticsearch: z
          .object({
            privileges: z
              .object({ cluster: z.array(z.string()) })
              .partial()
              .passthrough(),
          })
          .partial()
          .passthrough()
          .optional(),
        enabled: z.boolean(),
        id: z.string(),
        inputs: z.union([
          z.array(
            z.object({
              compiled_input: z.unknown(),
              config: z
                .record(
                  z.object({
                    frozen: z.boolean().optional(),
                    type: z.string().optional(),
                    value: z.unknown(),
                  })
                )
                .optional(),
              enabled: z.boolean(),
              id: z.string().optional(),
              keep_enabled: z.boolean().optional(),
              policy_template: z.string().optional(),
              streams: z.array(
                z.object({
                  compiled_stream: z.unknown(),
                  config: z
                    .record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    )
                    .optional(),
                  data_stream: z.object({
                    dataset: z.string(),
                    elasticsearch: z
                      .object({
                        dynamic_dataset: z.boolean(),
                        dynamic_namespace: z.boolean(),
                        privileges: z.object({ indices: z.array(z.string()) }).partial(),
                      })
                      .partial()
                      .optional(),
                    type: z.string(),
                  }),
                  enabled: z.boolean(),
                  id: z.string().optional(),
                  keep_enabled: z.boolean().optional(),
                  release: z.enum(['ga', 'beta', 'experimental']).optional(),
                  vars: z
                    .record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    )
                    .optional(),
                })
              ),
              type: z.string(),
              vars: z
                .record(
                  z.object({
                    frozen: z.boolean().optional(),
                    type: z.string().optional(),
                    value: z.unknown(),
                  })
                )
                .optional(),
            })
          ),
          z.record(
            z
              .object({
                enabled: z.boolean(),
                streams: z.record(
                  z
                    .object({
                      enabled: z.boolean(),
                      vars: z.record(
                        z
                          .union([
                            z.boolean(),
                            z.string(),
                            z.number(),
                            z.array(z.string()),
                            z.array(z.number()),
                            z.object({ id: z.string(), isSecretRef: z.boolean() }),
                          ])
                          .nullable()
                      ),
                    })
                    .partial()
                ),
                vars: z.record(
                  z
                    .union([
                      z.boolean(),
                      z.string(),
                      z.number(),
                      z.array(z.string()),
                      z.array(z.number()),
                      z.object({ id: z.string(), isSecretRef: z.boolean() }),
                    ])
                    .nullable()
                ),
              })
              .partial()
          ),
        ]),
        is_managed: z.boolean().optional(),
        name: z.string(),
        namespace: z.string().optional(),
        output_id: z.string().nullish(),
        overrides: z
          .object({ inputs: z.object({}).partial().passthrough() })
          .partial()
          .nullish(),
        package: z
          .object({
            experimental_data_stream_features: z
              .array(
                z.object({
                  data_stream: z.string(),
                  features: z
                    .object({
                      doc_value_only_numeric: z.boolean(),
                      doc_value_only_other: z.boolean(),
                      synthetic_source: z.boolean(),
                      tsdb: z.boolean(),
                    })
                    .partial(),
                })
              )
              .optional(),
            name: z.string(),
            requires_root: z.boolean().optional(),
            title: z.string().optional(),
            version: z.string(),
          })
          .optional(),
        policy_id: z.string().nullish(),
        policy_ids: z.array(z.string()).optional(),
        revision: z.number(),
        secret_references: z.array(z.object({ id: z.string() })).optional(),
        spaceIds: z.array(z.string()).optional(),
        supports_agentless: z.boolean().nullish().default(false),
        updated_at: z.string(),
        updated_by: z.string(),
        vars: z
          .union([
            z.record(
              z.object({
                frozen: z.boolean().optional(),
                type: z.string().optional(),
                value: z.unknown(),
              })
            ),
            z.record(
              z
                .union([
                  z.boolean(),
                  z.string(),
                  z.number(),
                  z.array(z.string()),
                  z.array(z.number()),
                  z.object({ id: z.string(), isSecretRef: z.boolean() }),
                ])
                .nullable()
            ),
          ])
          .optional(),
        version: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 403,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/package_policies/delete',
    alias: 'post-fleet-package-policies-delete',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/package_policies/delete&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agent-policies-all AND integrations-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_package_policies_delete_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.array(
      z.object({
        body: z.object({ message: z.string() }).optional(),
        id: z.string(),
        name: z.string().optional(),
        output_id: z.string().nullish(),
        package: z.object({
          experimental_data_stream_features: z
            .array(
              z.object({
                data_stream: z.string(),
                features: z
                  .object({
                    doc_value_only_numeric: z.boolean(),
                    doc_value_only_other: z.boolean(),
                    synthetic_source: z.boolean(),
                    tsdb: z.boolean(),
                  })
                  .partial(),
              })
            )
            .optional(),
          name: z.string(),
          requires_root: z.boolean().optional(),
          title: z.string().optional(),
          version: z.string(),
        }),
        policy_id: z.string().nullish(),
        policy_ids: z.array(z.string()),
        statusCode: z.number().optional(),
        success: z.boolean(),
      })
    ),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/package_policies/upgrade',
    alias: 'post-fleet-package-policies-upgrade',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/package_policies/upgrade&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Upgrade a package policy to a newer package version.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agent-policies-all AND integrations-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_package_policies_upgrade_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.array(
      z.object({
        body: z.object({ message: z.string() }).optional(),
        id: z.string(),
        name: z.string().optional(),
        statusCode: z.number().optional(),
        success: z.boolean(),
      })
    ),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/package_policies/upgrade/dryrun',
    alias: 'post-fleet-package-policies-upgrade-dryrun',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/package_policies/upgrade/dryrun&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agent-policies-read AND integrations-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_package_policies_upgrade_dryrun_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.array(
      z.object({
        agent_diff: z
          .array(
            z.array(
              z
                .object({
                  data_stream: z.object({ namespace: z.string() }).passthrough(),
                  id: z.string(),
                  meta: z
                    .object({
                      package: z.object({ name: z.string(), version: z.string() }).passthrough(),
                    })
                    .passthrough()
                    .optional(),
                  name: z.string(),
                  package_policy_id: z.string(),
                  processors: z
                    .array(
                      z
                        .object({
                          add_fields: z
                            .object({
                              fields: z.record(z.union([z.string(), z.number()])),
                              target: z.string(),
                            })
                            .passthrough(),
                        })
                        .passthrough()
                    )
                    .optional(),
                  revision: z.number(),
                  streams: z
                    .array(
                      z
                        .object({
                          data_stream: z
                            .object({ dataset: z.string(), type: z.string().optional() })
                            .passthrough(),
                          id: z.string().optional(),
                        })
                        .passthrough()
                    )
                    .optional(),
                  type: z.string(),
                  use_output: z.string(),
                })
                .passthrough()
            )
          )
          .optional(),
        body: z.object({ message: z.string() }).optional(),
        diff: z
          .array(
            z.union([
              z.object({
                additional_datastreams_permissions: z.array(z.string()).nullish(),
                agents: z.number().optional(),
                created_at: z.string(),
                created_by: z.string(),
                description: z.string().optional(),
                elasticsearch: z
                  .object({
                    privileges: z
                      .object({ cluster: z.array(z.string()) })
                      .partial()
                      .passthrough(),
                  })
                  .partial()
                  .passthrough()
                  .optional(),
                enabled: z.boolean(),
                id: z.string().optional(),
                inputs: z.union([
                  z.array(
                    z.object({
                      compiled_input: z.unknown(),
                      config: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                      enabled: z.boolean(),
                      id: z.string().optional(),
                      keep_enabled: z.boolean().optional(),
                      policy_template: z.string().optional(),
                      streams: z.array(
                        z.object({
                          compiled_stream: z.unknown(),
                          config: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                          data_stream: z.object({
                            dataset: z.string(),
                            elasticsearch: z
                              .object({
                                dynamic_dataset: z.boolean(),
                                dynamic_namespace: z.boolean(),
                                privileges: z.object({ indices: z.array(z.string()) }).partial(),
                              })
                              .partial()
                              .optional(),
                            type: z.string(),
                          }),
                          enabled: z.boolean(),
                          id: z.string().optional(),
                          keep_enabled: z.boolean().optional(),
                          release: z.enum(['ga', 'beta', 'experimental']).optional(),
                          vars: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                        })
                      ),
                      type: z.string(),
                      vars: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                    })
                  ),
                  z.record(
                    z
                      .object({
                        enabled: z.boolean(),
                        streams: z.record(
                          z
                            .object({
                              enabled: z.boolean(),
                              vars: z.record(
                                z
                                  .union([
                                    z.boolean(),
                                    z.string(),
                                    z.number(),
                                    z.array(z.string()),
                                    z.array(z.number()),
                                    z.object({ id: z.string(), isSecretRef: z.boolean() }),
                                  ])
                                  .nullable()
                              ),
                            })
                            .partial()
                        ),
                        vars: z.record(
                          z
                            .union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({ id: z.string(), isSecretRef: z.boolean() }),
                            ])
                            .nullable()
                        ),
                      })
                      .partial()
                  ),
                ]),
                is_managed: z.boolean().optional(),
                name: z.string(),
                namespace: z.string().optional(),
                output_id: z.string().nullish(),
                overrides: z
                  .object({ inputs: z.object({}).partial().passthrough() })
                  .partial()
                  .nullish(),
                package: z
                  .object({
                    experimental_data_stream_features: z
                      .array(
                        z.object({
                          data_stream: z.string(),
                          features: z
                            .object({
                              doc_value_only_numeric: z.boolean(),
                              doc_value_only_other: z.boolean(),
                              synthetic_source: z.boolean(),
                              tsdb: z.boolean(),
                            })
                            .partial(),
                        })
                      )
                      .optional(),
                    name: z.string(),
                    requires_root: z.boolean().optional(),
                    title: z.string().optional(),
                    version: z.string(),
                  })
                  .optional(),
                policy_id: z.string().nullish(),
                policy_ids: z.array(z.string()).optional(),
                revision: z.number(),
                secret_references: z.array(z.object({ id: z.string() })).optional(),
                spaceIds: z.array(z.string()).optional(),
                supports_agentless: z.boolean().nullish().default(false),
                updated_at: z.string(),
                updated_by: z.string(),
                vars: z
                  .union([
                    z.record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    ),
                    z.record(
                      z
                        .union([
                          z.boolean(),
                          z.string(),
                          z.number(),
                          z.array(z.string()),
                          z.array(z.number()),
                          z.object({ id: z.string(), isSecretRef: z.boolean() }),
                        ])
                        .nullable()
                    ),
                  ])
                  .optional(),
                version: z.string().optional(),
              }),
              z
                .object({
                  additional_datastreams_permissions: z.array(z.string()).nullish(),
                  created_at: z.string().optional(),
                  created_by: z.string().optional(),
                  description: z.string().optional(),
                  elasticsearch: z
                    .object({
                      privileges: z
                        .object({ cluster: z.array(z.string()) })
                        .partial()
                        .passthrough(),
                    })
                    .partial()
                    .passthrough()
                    .optional(),
                  enabled: z.boolean(),
                  errors: z
                    .array(z.object({ key: z.string().optional(), message: z.string() }))
                    .optional(),
                  force: z.boolean().optional(),
                  id: z.string().optional(),
                  inputs: z.array(
                    z.object({
                      compiled_input: z.unknown(),
                      config: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                      enabled: z.boolean(),
                      id: z.string().optional(),
                      keep_enabled: z.boolean().optional(),
                      policy_template: z.string().optional(),
                      streams: z.array(
                        z.object({
                          compiled_stream: z.unknown(),
                          config: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                          data_stream: z.object({
                            dataset: z.string(),
                            elasticsearch: z
                              .object({
                                dynamic_dataset: z.boolean(),
                                dynamic_namespace: z.boolean(),
                                privileges: z.object({ indices: z.array(z.string()) }).partial(),
                              })
                              .partial()
                              .optional(),
                            type: z.string(),
                          }),
                          enabled: z.boolean(),
                          id: z.string().optional(),
                          keep_enabled: z.boolean().optional(),
                          release: z.enum(['ga', 'beta', 'experimental']).optional(),
                          vars: z
                            .record(
                              z.object({
                                frozen: z.boolean().optional(),
                                type: z.string().optional(),
                                value: z.unknown(),
                              })
                            )
                            .optional(),
                        })
                      ),
                      type: z.string(),
                      vars: z
                        .record(
                          z.object({
                            frozen: z.boolean().optional(),
                            type: z.string().optional(),
                            value: z.unknown(),
                          })
                        )
                        .optional(),
                    })
                  ),
                  is_managed: z.boolean().optional(),
                  missingVars: z.array(z.string()).optional(),
                  name: z.string(),
                  namespace: z.string().optional(),
                  output_id: z.string().nullish(),
                  overrides: z
                    .object({ inputs: z.object({}).partial().passthrough() })
                    .partial()
                    .nullish(),
                  package: z
                    .object({
                      experimental_data_stream_features: z
                        .array(
                          z.object({
                            data_stream: z.string(),
                            features: z
                              .object({
                                doc_value_only_numeric: z.boolean(),
                                doc_value_only_other: z.boolean(),
                                synthetic_source: z.boolean(),
                                tsdb: z.boolean(),
                              })
                              .partial(),
                          })
                        )
                        .optional(),
                      name: z.string(),
                      requires_root: z.boolean().optional(),
                      title: z.string().optional(),
                      version: z.string(),
                    })
                    .optional(),
                  policy_id: z.string().nullish(),
                  policy_ids: z.array(z.string()).optional(),
                  revision: z.number().optional(),
                  secret_references: z.array(z.object({ id: z.string() })).optional(),
                  supports_agentless: z.boolean().nullish().default(false),
                  updated_at: z.string().optional(),
                  updated_by: z.string().optional(),
                  vars: z
                    .record(
                      z.object({
                        frozen: z.boolean().optional(),
                        type: z.string().optional(),
                        value: z.unknown(),
                      })
                    )
                    .optional(),
                  version: z.string().optional(),
                })
                .passthrough(),
            ])
          )
          .optional(),
        hasErrors: z.boolean(),
        name: z.string().optional(),
        statusCode: z.number().optional(),
      })
    ),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/proxies',
    alias: 'get-fleet-proxies',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/proxies&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-read.`,
    requestFormat: 'json',
    response: z.object({
      items: z.array(
        z.object({
          certificate: z.string().nullish(),
          certificate_authorities: z.string().nullish(),
          certificate_key: z.string().nullish(),
          id: z.string(),
          is_preconfigured: z.boolean().optional().default(false),
          name: z.string(),
          proxy_headers: z.record(z.union([z.string(), z.boolean(), z.number()])).nullish(),
          url: z.string(),
        })
      ),
      page: z.number(),
      perPage: z.number(),
      total: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/proxies',
    alias: 'post-fleet-proxies',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/proxies&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_fleet_proxies_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        certificate: z.string().nullish(),
        certificate_authorities: z.string().nullish(),
        certificate_key: z.string().nullish(),
        id: z.string(),
        is_preconfigured: z.boolean().optional().default(false),
        name: z.string(),
        proxy_headers: z.record(z.union([z.string(), z.boolean(), z.number()])).nullish(),
        url: z.string(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/fleet/proxies/:itemId',
    alias: 'delete-fleet-proxies-itemid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/proxies/{itemId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a proxy by ID&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'itemId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ id: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/proxies/:itemId',
    alias: 'get-fleet-proxies-itemid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/proxies/{itemId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a proxy by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'itemId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        certificate: z.string().nullish(),
        certificate_authorities: z.string().nullish(),
        certificate_key: z.string().nullish(),
        id: z.string(),
        is_preconfigured: z.boolean().optional().default(false),
        name: z.string(),
        proxy_headers: z.record(z.union([z.string(), z.boolean(), z.number()])).nullish(),
        url: z.string(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/fleet/proxies/:itemId',
    alias: 'put-fleet-proxies-itemid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/proxies/{itemId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update a proxy by ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_fleet_proxies_itemid_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'itemId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        certificate: z.string().nullish(),
        certificate_authorities: z.string().nullish(),
        certificate_key: z.string().nullish(),
        id: z.string(),
        is_preconfigured: z.boolean().optional().default(false),
        name: z.string(),
        proxy_headers: z.record(z.union([z.string(), z.boolean(), z.number()])).nullish(),
        url: z.string(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/remote_synced_integrations/:outputId/remote_status',
    alias: 'get-fleet-remote-synced-integrations-outputid-remote-status',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/remote_synced_integrations/{outputId}/remote_status&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-read AND integrations-read.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'outputId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      custom_assets: z
        .record(
          z.object({
            error: z.string().optional(),
            is_deleted: z.boolean().optional(),
            name: z.string(),
            package_name: z.string(),
            package_version: z.string(),
            sync_status: z.enum(['completed', 'synchronizing', 'failed', 'warning']),
            type: z.string(),
          })
        )
        .optional(),
      error: z.string().optional(),
      integrations: z.array(
        z.object({
          error: z.string().optional(),
          id: z.string().optional(),
          install_status: z.object({ main: z.string(), remote: z.string().optional() }),
          package_name: z.string().optional(),
          package_version: z.string().optional(),
          sync_status: z.enum(['completed', 'synchronizing', 'failed', 'warning']),
          updated_at: z.string().optional(),
          warning: z.object({ message: z.string().optional(), title: z.string() }).optional(),
        })
      ),
      warning: z.object({ message: z.string().optional(), title: z.string() }).optional(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/remote_synced_integrations/status',
    alias: 'get-fleet-remote-synced-integrations-status',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/remote_synced_integrations/status&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-read AND integrations-read.`,
    requestFormat: 'json',
    response: z.object({
      custom_assets: z
        .record(
          z.object({
            error: z.string().optional(),
            is_deleted: z.boolean().optional(),
            name: z.string(),
            package_name: z.string(),
            package_version: z.string(),
            sync_status: z.enum(['completed', 'synchronizing', 'failed', 'warning']),
            type: z.string(),
          })
        )
        .optional(),
      error: z.string().optional(),
      integrations: z.array(
        z.object({
          error: z.string().optional(),
          id: z.string().optional(),
          install_status: z.object({ main: z.string(), remote: z.string().optional() }),
          package_name: z.string().optional(),
          package_version: z.string().optional(),
          sync_status: z.enum(['completed', 'synchronizing', 'failed', 'warning']),
          updated_at: z.string().optional(),
          warning: z.object({ message: z.string().optional(), title: z.string() }).optional(),
        })
      ),
      warning: z.object({ message: z.string().optional(), title: z.string() }).optional(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/service_tokens',
    alias: 'post-fleet-service-tokens',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/service_tokens&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z
          .object({ remote: z.boolean().default(false) })
          .partial()
          .nullable(),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ name: z.string(), value: z.string() }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/settings',
    alias: 'get-fleet-settings',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/settings&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-read.`,
    requestFormat: 'json',
    response: z.object({
      item: z.object({
        delete_unenrolled_agents: z
          .object({ enabled: z.boolean(), is_preconfigured: z.boolean() })
          .optional(),
        has_seen_add_data_notice: z.boolean().optional(),
        id: z.string(),
        output_secret_storage_requirements_met: z.boolean().optional(),
        preconfigured_fields: z.array(z.literal('fleet_server_hosts')).optional(),
        prerelease_integrations_enabled: z.boolean().optional(),
        secret_storage_requirements_met: z.boolean().optional(),
        use_space_awareness_migration_started_at: z.string().nullish(),
        use_space_awareness_migration_status: z.enum(['pending', 'success', 'error']).optional(),
        version: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 404,
        schema: z.object({ message: z.string() }),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/fleet/settings',
    alias: 'put-fleet-settings',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/settings&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_fleet_settings_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        delete_unenrolled_agents: z
          .object({ enabled: z.boolean(), is_preconfigured: z.boolean() })
          .optional(),
        has_seen_add_data_notice: z.boolean().optional(),
        id: z.string(),
        output_secret_storage_requirements_met: z.boolean().optional(),
        preconfigured_fields: z.array(z.literal('fleet_server_hosts')).optional(),
        prerelease_integrations_enabled: z.boolean().optional(),
        secret_storage_requirements_met: z.boolean().optional(),
        use_space_awareness_migration_started_at: z.string().nullish(),
        use_space_awareness_migration_status: z.enum(['pending', 'success', 'error']).optional(),
        version: z.string().optional(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 404,
        schema: z.object({ message: z.string() }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/fleet/setup',
    alias: 'post-fleet-setup',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/setup&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-agents-read OR fleet-agent-policies-read OR fleet-settings-read OR fleet-setup.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      isInitialized: z.boolean(),
      nonFatalErrors: z.array(z.object({ message: z.string(), name: z.string() })),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
      {
        status: 500,
        schema: z.object({ message: z.string() }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/space_settings',
    alias: 'get-fleet-space-settings',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/space_settings&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z.object({
      item: z.object({
        allowed_namespace_prefixes: z.array(z.string()),
        managed_by: z.string().optional(),
      }),
    }),
  },
  {
    method: 'put',
    path: '/api/fleet/space_settings',
    alias: 'put-fleet-space-settings',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/space_settings&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: fleet-settings-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_fleet_space_settings_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        allowed_namespace_prefixes: z.array(z.string()),
        managed_by: z.string().optional(),
      }),
    }),
  },
  {
    method: 'get',
    path: '/api/fleet/uninstall_tokens',
    alias: 'get-fleet-uninstall-tokens',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/uninstall_tokens&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

List the metadata for the latest uninstall tokens per agent policy.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'policyId',
        type: 'Query',
        schema: z.string().max(50).optional(),
      },
      {
        name: 'search',
        type: 'Query',
        schema: z.string().max(50).optional(),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().gte(5).optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().gte(1).optional(),
      },
    ],
    response: z.object({
      items: z.array(
        z.object({
          created_at: z.string(),
          id: z.string(),
          namespaces: z.array(z.string()).optional(),
          policy_id: z.string(),
          policy_name: z.string().nullish(),
        })
      ),
      page: z.number(),
      perPage: z.number(),
      total: z.number(),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/fleet/uninstall_tokens/:uninstallTokenId',
    alias: 'get-fleet-uninstall-tokens-uninstalltokenid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/fleet/uninstall_tokens/{uninstallTokenId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get one decrypted uninstall token by its ID.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: fleet-agents-all.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'uninstallTokenId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      item: z.object({
        created_at: z.string(),
        id: z.string(),
        namespaces: z.array(z.string()).optional(),
        policy_id: z.string(),
        policy_name: z.string().nullish(),
        token: z.string(),
      }),
    }),
    errors: [
      {
        status: 400,
        schema: z.object({
          attributes: z.unknown(),
          error: z.string().optional(),
          errorType: z.string().optional(),
          message: z.string(),
          statusCode: z.number().optional(),
        }),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/lists',
    alias: 'DeleteList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a value list using the list ID.
&gt; info
&gt; When you delete a list, all of its list items are also deleted.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1),
      },
      {
        name: 'deleteReferences',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'ignoreReferences',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: Security_Lists_API_List,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/lists',
    alias: 'ReadList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of a value list using the list ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1),
      },
    ],
    response: Security_Lists_API_List,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'patch',
    path: '/api/lists',
    alias: 'PatchList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update specific fields of an existing list using the list &#x60;id&#x60;.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Value list&#x27;s properties`,
        type: 'Body',
        schema: PatchList_Body,
      },
    ],
    response: Security_Lists_API_List,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/lists',
    alias: 'CreateList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a new value list.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Value list&#x27;s properties`,
        type: 'Body',
        schema: CreateList_Body,
      },
    ],
    response: Security_Lists_API_List,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 409,
        description: `List already exists response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'put',
    path: '/api/lists',
    alias: 'UpdateList',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update a value list using the list &#x60;id&#x60;. The original list is replaced, and all unspecified fields are deleted.
&gt; info
&gt; You cannot modify the &#x60;id&#x60; value.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Value list&#x27;s properties`,
        type: 'Body',
        schema: UpdateList_Body,
      },
    ],
    response: Security_Lists_API_List,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/lists/_find',
    alias: 'FindLists',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a paginated subset of value lists. By default, the first page is returned, with 20 results per page.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().optional(),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['desc', 'asc']).optional(),
      },
      {
        name: 'cursor',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z
      .object({
        cursor: Security_Lists_API_FindListsCursor.min(1),
        data: z.array(Security_Lists_API_List),
        page: z.number().int().gte(0),
        per_page: z.number().int().gte(0),
        total: z.number().int().gte(0),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/lists/index',
    alias: 'DeleteListIndex',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/index&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete the &#x60;.lists&#x60; and &#x60;.items&#x60; data streams.`,
    requestFormat: 'json',
    response: z.object({ acknowledged: z.boolean() }).passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List data stream not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/lists/index',
    alias: 'ReadListIndex',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/index&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Verify that &#x60;.lists&#x60; and &#x60;.items&#x60; data streams exist.`,
    requestFormat: 'json',
    response: z.object({ list_index: z.boolean(), list_item_index: z.boolean() }).passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List data stream(s) not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/lists/index',
    alias: 'CreateListIndex',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/index&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create &#x60;.lists&#x60; and &#x60;.items&#x60; data streams in the relevant space.`,
    requestFormat: 'json',
    response: z.object({ acknowledged: z.boolean() }).passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 409,
        description: `List data stream exists response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/lists/items',
    alias: 'DeleteListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a value list item using its &#x60;id&#x60;, or its &#x60;list_id&#x60; and &#x60;value&#x60; fields.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'list_id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'value',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'refresh',
        type: 'Query',
        schema: z.enum(['true', 'false', 'wait_for']).optional().default('false'),
      },
    ],
    response: z.union([Security_Lists_API_ListItem, z.array(Security_Lists_API_ListItem)]),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List item not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/lists/items',
    alias: 'ReadListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of a value list item.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'list_id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'value',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z.union([Security_Lists_API_ListItem, z.array(Security_Lists_API_ListItem)]),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List item not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'patch',
    path: '/api/lists/items',
    alias: 'PatchListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update specific fields of an existing value list item using the item &#x60;id&#x60;.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Value list item&#x27;s properties`,
        type: 'Body',
        schema: PatchListItem_Body,
      },
    ],
    response: Security_Lists_API_ListItem,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List item not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/lists/items',
    alias: 'CreateListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a value list item and associate it with the specified value list.

All value list items in the same list must be the same type. For example, each list item in an &#x60;ip&#x60; list must define a specific IP address.
&gt; info
&gt; Before creating a list item, you must create a list.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Value list item&#x27;s properties`,
        type: 'Body',
        schema: CreateListItem_Body,
      },
    ],
    response: Security_Lists_API_ListItem,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 409,
        description: `List item already exists response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'put',
    path: '/api/lists/items',
    alias: 'UpdateListItem',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/items&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update a value list item using the list item ID. The original list item is replaced, and all unspecified fields are deleted.
&gt; info
&gt; You cannot modify the &#x60;id&#x60; value.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `Value list item&#x27;s properties`,
        type: 'Body',
        schema: UpdateListItem_Body,
      },
    ],
    response: Security_Lists_API_ListItem,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List item not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/lists/items/_export',
    alias: 'ExportListItems',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/items/_export&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Export list item values from the specified value list.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'list_id',
        type: 'Query',
        schema: z.string().min(1),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 404,
        description: `List not found response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/lists/items/_find',
    alias: 'FindListItems',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/items/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get all value list items in the specified list.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'list_id',
        type: 'Query',
        schema: z.string().min(1),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().optional(),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['desc', 'asc']).optional(),
      },
      {
        name: 'cursor',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z
      .object({
        cursor: Security_Lists_API_FindListItemsCursor.min(1),
        data: z.array(Security_Lists_API_ListItem),
        page: z.number().int().gte(0),
        per_page: z.number().int().gte(0),
        total: z.number().int().gte(0),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/lists/items/_import',
    alias: 'ImportListItems',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/items/_import&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Import value list items from a TXT or CSV file. The maximum file size is 9 million bytes.

You can import items to a new or existing list.
`,
    requestFormat: 'form-data',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z
          .object({ file: z.instanceof(File) })
          .partial()
          .passthrough(),
      },
      {
        name: 'list_id',
        type: 'Query',
        schema: z.string().min(1).optional(),
      },
      {
        name: 'type',
        type: 'Query',
        schema: z
          .enum([
            'binary',
            'boolean',
            'byte',
            'date',
            'date_nanos',
            'date_range',
            'double',
            'double_range',
            'float',
            'float_range',
            'geo_point',
            'geo_shape',
            'half_float',
            'integer',
            'integer_range',
            'ip',
            'ip_range',
            'keyword',
            'long',
            'long_range',
            'shape',
            'short',
            'text',
          ])
          .optional(),
      },
      {
        name: 'serializer',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'deserializer',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'refresh',
        type: 'Query',
        schema: z.enum(['true', 'false', 'wait_for']).optional(),
      },
    ],
    response: Security_Lists_API_List,
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 409,
        description: `List with specified list_id does not exist response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/lists/privileges',
    alias: 'ReadListPrivileges',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/lists/privileges&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    response: z
      .object({
        is_authenticated: z.boolean(),
        listItems: Security_Lists_API_ListItemPrivileges,
        lists: Security_Lists_API_ListPrivileges,
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid input data response`,
        schema: z.union([
          Security_Lists_API_PlatformErrorResponse,
          Security_Lists_API_SiemErrorResponse,
        ]),
      },
      {
        status: 401,
        description: `Unsuccessful authentication response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 403,
        description: `Not enough privileges response`,
        schema: Security_Lists_API_PlatformErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error response`,
        schema: Security_Lists_API_SiemErrorResponse,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/logstash/pipeline/:id',
    alias: 'delete-logstash-pipeline',
    description: `Delete a centrally-managed Logstash pipeline.
If your Elasticsearch cluster is protected with basic authentication, you must have either the &#x60;logstash_admin&#x60; built-in role or a customized Logstash writer role.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/logstash/pipeline/:id',
    alias: 'get-logstash-pipeline',
    description: `Get information for a centrally-managed Logstash pipeline.
To use this API, you must have either the &#x60;logstash_admin&#x60; built-in role or a customized Logstash reader role.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'put',
    path: '/api/logstash/pipeline/:id',
    alias: 'put-logstash-pipeline',
    description: `Create a centrally-managed Logstash pipeline or update a pipeline.
To use this API, you must have either the &#x60;logstash_admin&#x60; built-in role or a customized Logstash writer role.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_logstash_pipeline_Body,
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/logstash/pipelines',
    alias: 'get-logstash-pipelines',
    description: `Get a list of all centrally-managed Logstash pipelines.

To use this API, you must have either the &#x60;logstash_admin&#x60; built-in role or a customized Logstash reader role.
&gt; info
&gt; Limit the number of pipelines to 10,000 or fewer. As the number of pipelines nears and surpasses 10,000, you may see performance issues on Kibana.

The &#x60;username&#x60; property appears in the response when security is enabled and depends on when the pipeline was created or last updated.
`,
    requestFormat: 'json',
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/maintenance_window',
    alias: 'post-maintenance-window',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/maintenance_window&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: write-maintenance-window.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_maintenance_window_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({
      created_at: z.string(),
      created_by: z.string().nullable(),
      enabled: z.boolean(),
      id: z.string(),
      schedule: z.object({
        custom: z.object({
          duration: z.string(),
          recurring: z
            .object({
              end: z.string(),
              every: z.string(),
              occurrences: z.number(),
              onMonth: z.array(z.number()),
              onMonthDay: z.array(z.number()),
              onWeekDay: z.array(z.string()),
            })
            .partial()
            .optional(),
          start: z.string(),
          timezone: z.string().optional(),
        }),
      }),
      scope: z.object({ alerting: z.object({ query: z.object({ kql: z.string() }) }) }).optional(),
      status: z.enum(['running', 'upcoming', 'finished', 'archived']),
      title: z.string(),
      updated_at: z.string(),
      updated_by: z.string().nullable(),
    }),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/maintenance_window/:id',
    alias: 'delete-maintenance-window-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/maintenance_window/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: write-maintenance-window.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a maintenance window with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/maintenance_window/:id',
    alias: 'get-maintenance-window-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/maintenance_window/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: read-maintenance-window.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      created_at: z.string(),
      created_by: z.string().nullable(),
      enabled: z.boolean(),
      id: z.string(),
      schedule: z.object({
        custom: z.object({
          duration: z.string(),
          recurring: z
            .object({
              end: z.string(),
              every: z.string(),
              occurrences: z.number(),
              onMonth: z.array(z.number()),
              onMonthDay: z.array(z.number()),
              onWeekDay: z.array(z.string()),
            })
            .partial()
            .optional(),
          start: z.string(),
          timezone: z.string().optional(),
        }),
      }),
      scope: z.object({ alerting: z.object({ query: z.object({ kql: z.string() }) }) }).optional(),
      status: z.enum(['running', 'upcoming', 'finished', 'archived']),
      title: z.string(),
      updated_at: z.string(),
      updated_by: z.string().nullable(),
    }),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a maintenance window with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'patch',
    path: '/api/maintenance_window/:id',
    alias: 'patch-maintenance-window-id',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/maintenance_window/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: write-maintenance-window.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: patch_maintenance_window_id_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      created_at: z.string(),
      created_by: z.string().nullable(),
      enabled: z.boolean(),
      id: z.string(),
      schedule: z.object({
        custom: z.object({
          duration: z.string(),
          recurring: z
            .object({
              end: z.string(),
              every: z.string(),
              occurrences: z.number(),
              onMonth: z.array(z.number()),
              onMonthDay: z.array(z.number()),
              onWeekDay: z.array(z.string()),
            })
            .partial()
            .optional(),
          start: z.string(),
          timezone: z.string().optional(),
        }),
      }),
      scope: z.object({ alerting: z.object({ query: z.object({ kql: z.string() }) }) }).optional(),
      status: z.enum(['running', 'upcoming', 'finished', 'archived']),
      title: z.string(),
      updated_at: z.string(),
      updated_by: z.string().nullable(),
    }),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a maintenance window with the given ID does not exist.`,
        schema: z.void(),
      },
      {
        status: 409,
        description: `Indicates that the maintenance window has already been updated by another user.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/maintenance_window/:id/_archive',
    alias: 'post-maintenance-window-id-archive',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/maintenance_window/{id}/_archive&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: write-maintenance-window.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      created_at: z.string(),
      created_by: z.string().nullable(),
      enabled: z.boolean(),
      id: z.string(),
      schedule: z.object({
        custom: z.object({
          duration: z.string(),
          recurring: z
            .object({
              end: z.string(),
              every: z.string(),
              occurrences: z.number(),
              onMonth: z.array(z.number()),
              onMonthDay: z.array(z.number()),
              onWeekDay: z.array(z.string()),
            })
            .partial()
            .optional(),
          start: z.string(),
          timezone: z.string().optional(),
        }),
      }),
      scope: z.object({ alerting: z.object({ query: z.object({ kql: z.string() }) }) }).optional(),
      status: z.enum(['running', 'upcoming', 'finished', 'archived']),
      title: z.string(),
      updated_at: z.string(),
      updated_by: z.string().nullable(),
    }),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a maintenance window with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/maintenance_window/:id/_unarchive',
    alias: 'post-maintenance-window-id-unarchive',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/maintenance_window/{id}/_unarchive&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

[Required authorization] Route required privileges: write-maintenance-window.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({
      created_at: z.string(),
      created_by: z.string().nullable(),
      enabled: z.boolean(),
      id: z.string(),
      schedule: z.object({
        custom: z.object({
          duration: z.string(),
          recurring: z
            .object({
              end: z.string(),
              every: z.string(),
              occurrences: z.number(),
              onMonth: z.array(z.number()),
              onMonthDay: z.array(z.number()),
              onWeekDay: z.array(z.string()),
            })
            .partial()
            .optional(),
          start: z.string(),
          timezone: z.string().optional(),
        }),
      }),
      scope: z.object({ alerting: z.object({ query: z.object({ kql: z.string() }) }) }).optional(),
      status: z.enum(['running', 'upcoming', 'finished', 'archived']),
      title: z.string(),
      updated_at: z.string(),
      updated_by: z.string().nullable(),
    }),
    errors: [
      {
        status: 400,
        description: `Indicates an invalid schema or parameters.`,
        schema: z.void(),
      },
      {
        status: 403,
        description: `Indicates that this call is forbidden.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Indicates a maintenance window with the given ID does not exist.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/ml/saved_objects/sync',
    alias: 'mlSync',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/ml/saved_objects/sync&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Synchronizes Kibana saved objects for machine learning jobs and trained models in the default space. You must have &#x60;all&#x60; privileges for the **Machine Learning** feature in the **Analytics** section of the Kibana feature privileges. This API runs automatically when you start Kibana and periodically thereafter.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'simulate',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: Machine_learning_APIs_mlSync200Response,
    errors: [
      {
        status: 401,
        description: `Authorization information is missing or invalid.`,
        schema: Machine_learning_APIs_mlSync4xxResponse,
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/note',
    alias: 'DeleteNote',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/note&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a note from a Timeline using the note ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The ID of the note to delete.`,
        type: 'Body',
        schema: DeleteNote_Body,
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/note',
    alias: 'GetNotes',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/note&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get all notes for a given document.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'documentIds',
        type: 'Query',
        schema: search_fields,
      },
      {
        name: 'savedObjectIds',
        type: 'Query',
        schema: search_fields,
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'search',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'sortField',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'createdByFilter',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'associatedFilter',
        type: 'Query',
        schema: z
          .enum([
            'all',
            'document_only',
            'saved_object_only',
            'document_and_saved_object',
            'orphan',
          ])
          .optional(),
      },
    ],
    response: Security_Timeline_API_GetNotesResult,
  },
  {
    method: 'patch',
    path: '/api/note',
    alias: 'PersistNoteRoute',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/note&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Add a note to a Timeline or update an existing note.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The note to add or update, along with additional metadata.`,
        type: 'Body',
        schema: PersistNoteRoute_Body,
      },
    ],
    response: Security_Timeline_API_ResponseNote,
  },
  {
    method: 'post',
    path: '/api/observability_ai_assistant/chat/complete',
    alias: 'observability-ai-assistant-chat-complete',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/observability_ai_assistant/chat/complete&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a new chat completion by using the Observability AI Assistant. 

The API returns the model&#x27;s response based on the current conversation context. 

It also handles any tool requests within the conversation, which may trigger multiple calls to the underlying large language model (LLM). 

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: observability_ai_assistant_chat_complete_Body,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/osquery/live_queries',
    alias: 'OsqueryFindLiveQueries',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/live_queries&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all live queries.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kuery',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().nullish(),
      },
      {
        name: 'pageSize',
        type: 'Query',
        schema: z.number().int().nullish(),
      },
      {
        name: 'sort',
        type: 'Query',
        schema: z.string().nullish().default('createdAt'),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/osquery/live_queries',
    alias: 'OsqueryCreateLiveQuery',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/live_queries&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create and run a live query.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Osquery_API_CreateLiveQueryRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/osquery/live_queries/:id',
    alias: 'OsqueryGetLiveQueryDetails',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/live_queries/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of a live query using the query ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/osquery/live_queries/:id/results/:actionId',
    alias: 'OsqueryGetLiveQueryResults',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/live_queries/{id}/results/{actionId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the results of a live query using the query action ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'actionId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'kuery',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().nullish(),
      },
      {
        name: 'pageSize',
        type: 'Query',
        schema: z.number().int().nullish(),
      },
      {
        name: 'sort',
        type: 'Query',
        schema: z.string().nullish().default('createdAt'),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/osquery/packs',
    alias: 'OsqueryFindPacks',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/packs&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all query packs.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().nullish(),
      },
      {
        name: 'pageSize',
        type: 'Query',
        schema: z.number().int().nullish(),
      },
      {
        name: 'sort',
        type: 'Query',
        schema: z.string().nullish().default('createdAt'),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/osquery/packs',
    alias: 'OsqueryCreatePacks',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/packs&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a query pack.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Osquery_API_CreatePacksRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'delete',
    path: '/api/osquery/packs/:id',
    alias: 'OsqueryDeletePacks',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/packs/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a query pack using the pack ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/osquery/packs/:id',
    alias: 'OsqueryGetPacksDetails',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/packs/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of a query pack using the pack ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'put',
    path: '/api/osquery/packs/:id',
    alias: 'OsqueryUpdatePacks',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/packs/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update a query pack using the pack ID.
&gt; info
&gt; You cannot update a prebuilt pack.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Osquery_API_UpdatePacksRequestBody,
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/osquery/saved_queries',
    alias: 'OsqueryFindSavedQueries',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/saved_queries&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all saved queries.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().nullish(),
      },
      {
        name: 'pageSize',
        type: 'Query',
        schema: z.number().int().nullish(),
      },
      {
        name: 'sort',
        type: 'Query',
        schema: z.string().nullish().default('createdAt'),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/osquery/saved_queries',
    alias: 'OsqueryCreateSavedQuery',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/saved_queries&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create and run a saved query.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Osquery_API_CreateSavedQueryRequestBody,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'delete',
    path: '/api/osquery/saved_queries/:id',
    alias: 'OsqueryDeleteSavedQuery',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/saved_queries/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a saved query using the query ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/osquery/saved_queries/:id',
    alias: 'OsqueryGetSavedQueryDetails',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/saved_queries/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of a saved query using the query ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'put',
    path: '/api/osquery/saved_queries/:id',
    alias: 'OsqueryUpdateSavedQuery',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/osquery/saved_queries/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update a saved query using the query ID.
&gt; info
&gt; You cannot update a prebuilt saved query.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_Osquery_API_UpdateSavedQueryRequestBody,
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'patch',
    path: '/api/pinned_event',
    alias: 'PersistPinnedEventRoute',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/pinned_event&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Pin/unpin an event to/from an existing Timeline.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The pinned event to add or unpin, along with additional metadata.`,
        type: 'Body',
        schema: PersistPinnedEventRoute_Body,
      },
    ],
    response: Security_Timeline_API_PersistPinnedEventResponse,
  },
  {
    method: 'delete',
    path: '/api/risk_score/engine/dangerously_delete_data',
    alias: 'CleanUpRiskEngine',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/risk_score/engine/dangerously_delete_data&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Cleaning up the the Risk Engine by removing the indices, mapping and transforms`,
    requestFormat: 'json',
    response: z.object({ cleanup_successful: z.boolean() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Task manager is unavailable`,
        schema: Security_Entity_Analytics_API_TaskManagerUnavailableResponse,
      },
    ],
  },
  {
    method: 'patch',
    path: '/api/risk_score/engine/saved_object/configure',
    alias: 'ConfigureRiskEngineSavedObject',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/risk_score/engine/saved_object/configure&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Configuring the Risk Engine Saved Object`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: ConfigureRiskEngineSavedObject_Body,
      },
    ],
    response: z
      .object({ risk_engine_saved_object_configured: z.boolean() })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Task manager is unavailable`,
        schema: Security_Entity_Analytics_API_TaskManagerUnavailableResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/risk_score/engine/schedule_now',
    alias: 'ScheduleRiskEngineNow',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/risk_score/engine/schedule_now&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Schedule the risk scoring engine to run as soon as possible. You can use this to recalculate entity risk scores after updating their asset criticality.`,
    requestFormat: 'json',
    response: z.object({ success: z.boolean() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Task manager is unavailable`,
        schema: Security_Entity_Analytics_API_TaskManagerUnavailableResponse,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/saved_objects/_export',
    alias: 'post-saved-objects-export',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/saved_objects/_export&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Retrieve sets of saved objects that you want to import into Kibana. You must include &#x60;type&#x60; or &#x60;objects&#x60; in the request body. The output of exporting saved objects must be treated as opaque. Tampering with exported data risks introducing unspecified errors and data loss.

Exported saved objects are not backwards compatible and cannot be imported into an older version of Kibana.

NOTE: The &#x60;savedObjects.maxImportExportSize&#x60; configuration setting limits the number of saved objects which may be exported.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_saved_objects_export_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Bad request.`,
        schema: z.object({ error: z.string(), message: z.string(), statusCode: z.literal(400) }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/saved_objects/_import',
    alias: 'post-saved-objects-import',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/saved_objects/_import&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create sets of Kibana saved objects from a file created by the export API. Saved objects can only be imported into the same version, a newer minor on the same major, or the next major. Tampering with exported data risks introducing unspecified errors and data loss.

Exported saved objects are not backwards compatible and cannot be imported into an older version of Kibana.`,
    requestFormat: 'form-data',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ file: z.object({}).partial().passthrough() }),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'overwrite',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'createNewCopies',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
      {
        name: 'compatibilityMode',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({
      errors: z.array(z.object({}).partial().passthrough()),
      success: z.boolean(),
      successCount: z.number(),
      successResults: z.array(z.object({}).partial().passthrough()),
    }),
    errors: [
      {
        status: 400,
        description: `Bad request.`,
        schema: z.object({ error: z.string(), message: z.string(), statusCode: z.literal(400) }),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/saved_objects/_resolve_import_errors',
    alias: 'resolveImportErrors',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/saved_objects/_resolve_import_errors&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

To resolve errors from the Import objects API, you can:

* Retry certain saved objects
* Overwrite specific saved objects
* Change references to different saved objects
`,
    requestFormat: 'form-data',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: resolveImportErrors_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'compatibilityMode',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'createNewCopies',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z
      .object({
        errors: z.array(z.object({}).partial().passthrough()),
        success: z.boolean(),
        successCount: z.number(),
        successResults: z.array(z.object({}).partial().passthrough()),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request.`,
        schema: Saved_objects_400_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/security_ai_assistant/anonymization_fields/_bulk_action',
    alias: 'PerformAnonymizationFieldsBulkAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/anonymization_fields/_bulk_action&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Apply a bulk action to multiple anonymization fields. The bulk action is applied to all anonymization fields that match the filter or to the list of anonymization fields by their IDs.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: PerformAnonymizationFieldsBulkAction_Body,
      },
    ],
    response: Security_AI_Assistant_API_AnonymizationFieldsBulkCrudActionResponse,
    errors: [
      {
        status: 400,
        description: `Generic Error`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/security_ai_assistant/anonymization_fields/_find',
    alias: 'FindAnonymizationFields',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/anonymization_fields/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all anonymization fields.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'fields',
        type: 'Query',
        schema: z.array(z.string()).optional(),
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.enum(['created_at', 'anonymized', 'allowed', 'field', 'updated_at']).optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(1).optional().default(1),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().gte(0).optional().default(20),
      },
      {
        name: 'all_data',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z
      .object({
        aggregations: z
          .object({
            field_status: z
              .object({
                buckets: z
                  .object({
                    allowed: z
                      .object({ doc_count: z.number().int().default(0) })
                      .partial()
                      .passthrough(),
                    anonymized: z
                      .object({ doc_count: z.number().int().default(0) })
                      .partial()
                      .passthrough(),
                    denied: z
                      .object({ doc_count: z.number().int().default(0) })
                      .partial()
                      .passthrough(),
                  })
                  .partial()
                  .passthrough(),
              })
              .partial()
              .passthrough(),
          })
          .partial()
          .passthrough()
          .optional(),
        all: z.array(Security_AI_Assistant_API_AnonymizationFieldResponse).optional(),
        data: z.array(Security_AI_Assistant_API_AnonymizationFieldResponse),
        page: z.number().int(),
        perPage: z.number().int(),
        total: z.number().int(),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Generic Error`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/security_ai_assistant/chat/complete',
    alias: 'ChatComplete',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/chat/complete&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a model response for the given chat conversation.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_AI_Assistant_API_ChatCompleteProps,
      },
      {
        name: 'content_references_disabled',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Generic Error`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/security_ai_assistant/current_user/conversations',
    alias: 'DeleteAllConversations',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/current_user/conversations&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

This endpoint allows users to permanently delete all conversations.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: DeleteAllConversations_Body.optional(),
      },
    ],
    response: z
      .object({ failures: z.array(z.string()), success: z.boolean(), totalDeleted: z.number() })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Generic Error. This response indicates an issue with the request.`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/security_ai_assistant/current_user/conversations',
    alias: 'CreateConversation',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/current_user/conversations&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a new Security AI Assistant conversation. This endpoint allows the user to initiate a conversation with the Security AI Assistant by providing the required parameters.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_AI_Assistant_API_ConversationCreateProps,
      },
    ],
    response: Security_AI_Assistant_API_ConversationResponse,
    errors: [
      {
        status: 400,
        description: `Generic Error. This response indicates an issue with the request, such as missing required parameters or incorrect data.`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/security_ai_assistant/current_user/conversations/_find',
    alias: 'FindConversations',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/current_user/conversations/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all conversations for the current user. This endpoint allows users to search, filter, sort, and paginate through their conversations.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'fields',
        type: 'Query',
        schema: z.array(z.string()).optional(),
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.enum(['created_at', 'title', 'updated_at']).optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(1).optional().default(1),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().gte(0).optional().default(20),
      },
      {
        name: 'is_owner',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z
      .object({
        data: z.array(Security_AI_Assistant_API_ConversationResponse),
        page: z.number().int(),
        perPage: z.number().int(),
        total: z.number().int(),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Generic Error. The request could not be processed due to an invalid query parameter or other issue.`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/security_ai_assistant/current_user/conversations/:id',
    alias: 'DeleteConversation',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/current_user/conversations/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete an existing conversation using the conversation ID. This endpoint allows users to permanently delete a conversation.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string().min(1),
      },
    ],
    response: Security_AI_Assistant_API_ConversationResponse,
    errors: [
      {
        status: 400,
        description: `Generic Error. This response indicates an issue with the request.`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/security_ai_assistant/current_user/conversations/:id',
    alias: 'ReadConversation',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/current_user/conversations/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of an existing conversation using the conversation ID. This allows users to fetch the specific conversation data by its unique ID.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string().min(1),
      },
    ],
    response: Security_AI_Assistant_API_ConversationResponse,
    errors: [
      {
        status: 400,
        description: `Generic Error. The request could not be processed due to an error.`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/security_ai_assistant/current_user/conversations/:id',
    alias: 'UpdateConversation',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/current_user/conversations/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update an existing conversation using the conversation ID. This endpoint allows users to modify the details of an existing conversation.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_AI_Assistant_API_ConversationUpdateProps,
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string().min(1),
      },
    ],
    response: Security_AI_Assistant_API_ConversationResponse,
    errors: [
      {
        status: 400,
        description: `Generic Error. This response indicates an issue with the request, such as missing required parameters or incorrect data.`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/security_ai_assistant/knowledge_base/:resource',
    alias: 'ReadKnowledgeBase',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/knowledge_base/{resource}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Read a single KB`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'resource',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z
      .object({
        elser_exists: z.boolean(),
        is_setup_available: z.boolean(),
        is_setup_in_progress: z.boolean(),
        product_documentation_status: z.string(),
        security_labs_exists: z.boolean(),
        user_data_exists: z.boolean(),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Generic Error`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/security_ai_assistant/knowledge_base/:resource',
    alias: 'CreateKnowledgeBase',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/knowledge_base/{resource}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a KnowledgeBase`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'resource',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'modelId',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'ignoreSecurityLabs',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.object({ success: z.boolean() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Generic Error`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/security_ai_assistant/knowledge_base/entries',
    alias: 'CreateKnowledgeBaseEntry',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/knowledge_base/entries&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a Knowledge Base Entry`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_AI_Assistant_API_KnowledgeBaseEntryCreateProps,
      },
    ],
    response: Security_AI_Assistant_API_KnowledgeBaseEntryResponse,
    errors: [
      {
        status: 400,
        description: `A generic error occurred, such as invalid input or missing required fields.`,
        schema: Security_AI_Assistant_API_KnowledgeBaseEntryErrorSchema,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/security_ai_assistant/knowledge_base/entries/_bulk_action',
    alias: 'PerformKnowledgeBaseEntryBulkAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/knowledge_base/entries/_bulk_action&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

The bulk action is applied to all Knowledge Base Entries that match the filter or to the list of Knowledge Base Entries by their IDs.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: PerformKnowledgeBaseEntryBulkAction_Body,
      },
    ],
    response: Security_AI_Assistant_API_KnowledgeBaseEntryBulkCrudActionResponse,
    errors: [
      {
        status: 400,
        description: `Generic Error`,
        schema: Security_AI_Assistant_API_KnowledgeBaseEntryErrorSchema,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/security_ai_assistant/knowledge_base/entries/_find',
    alias: 'FindKnowledgeBaseEntries',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/knowledge_base/entries/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Finds Knowledge Base Entries that match the given query.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'fields',
        type: 'Query',
        schema: z.array(z.string()).optional(),
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.enum(['created_at', 'is_default', 'title', 'updated_at']).optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(1).optional().default(1),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().gte(0).optional().default(20),
      },
    ],
    response: z
      .object({
        data: z.array(Security_AI_Assistant_API_KnowledgeBaseEntryResponse),
        page: z.number().int(),
        perPage: z.number().int(),
        total: z.number().int(),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Generic Error indicating an issue with the request.`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/security_ai_assistant/knowledge_base/entries/:id',
    alias: 'DeleteKnowledgeBaseEntry',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/knowledge_base/entries/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a Knowledge Base Entry by its unique &#x60;id&#x60;.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string().min(1),
      },
    ],
    response: Security_AI_Assistant_API_DeleteResponseFields,
    errors: [
      {
        status: 400,
        description: `A generic error occurred, such as an invalid &#x60;id&#x60; or the entry not being found.`,
        schema: Security_AI_Assistant_API_KnowledgeBaseEntryErrorSchema,
      },
    ],
  },
  {
    method: 'get',
    path: '/api/security_ai_assistant/knowledge_base/entries/:id',
    alias: 'ReadKnowledgeBaseEntry',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/knowledge_base/entries/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Retrieve a Knowledge Base Entry by its unique &#x60;id&#x60;.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string().min(1),
      },
    ],
    response: Security_AI_Assistant_API_KnowledgeBaseEntryResponse,
    errors: [
      {
        status: 400,
        description: `A generic error occurred, such as an invalid &#x60;id&#x60; or the entry not being found.`,
        schema: Security_AI_Assistant_API_KnowledgeBaseEntryErrorSchema,
      },
    ],
  },
  {
    method: 'put',
    path: '/api/security_ai_assistant/knowledge_base/entries/:id',
    alias: 'UpdateKnowledgeBaseEntry',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/knowledge_base/entries/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update an existing Knowledge Base Entry by its unique &#x60;id&#x60;.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: Security_AI_Assistant_API_KnowledgeBaseEntryUpdateRouteProps,
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string().min(1),
      },
    ],
    response: Security_AI_Assistant_API_KnowledgeBaseEntryResponse,
    errors: [
      {
        status: 400,
        description: `A generic error occurred, such as invalid input or the entry not being found.`,
        schema: Security_AI_Assistant_API_KnowledgeBaseEntryErrorSchema,
      },
    ],
  },
  {
    method: 'post',
    path: '/api/security_ai_assistant/prompts/_bulk_action',
    alias: 'PerformPromptsBulkAction',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/prompts/_bulk_action&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Apply a bulk action to multiple prompts. The bulk action is applied to all prompts that match the filter or to the list of prompts by their IDs. This action allows for bulk create, update, or delete operations.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: PerformPromptsBulkAction_Body,
      },
    ],
    response: Security_AI_Assistant_API_PromptsBulkCrudActionResponse,
    errors: [
      {
        status: 400,
        description: `Indicates a generic error due to a bad request.`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/security_ai_assistant/prompts/_find',
    alias: 'FindPrompts',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/security_ai_assistant/prompts/_find&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all prompts based on optional filters, sorting, and pagination.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'fields',
        type: 'Query',
        schema: z.array(z.string()).optional(),
      },
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.enum(['created_at', 'is_default', 'name', 'updated_at']).optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().gte(1).optional().default(1),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().gte(0).optional().default(20),
      },
    ],
    response: z
      .object({
        data: z.array(Security_AI_Assistant_API_PromptResponse),
        page: z.number().int(),
        perPage: z.number().int(),
        total: z.number().int(),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request due to invalid parameters or malformed query.`,
        schema: z
          .object({ error: z.string(), message: z.string(), statusCode: z.number() })
          .partial()
          .passthrough(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/security/role',
    alias: 'get-security-role',
    requestFormat: 'json',
    parameters: [
      {
        name: 'replaceDeprecatedPrivileges',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/security/role/_query',
    alias: 'post-security-role-query',
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_security_role_query_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'delete',
    path: '/api/security/role/:name',
    alias: 'delete-security-role-name',
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string().min(1),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/security/role/:name',
    alias: 'get-security-role-name',
    requestFormat: 'json',
    parameters: [
      {
        name: 'name',
        type: 'Path',
        schema: z.string().min(1),
      },
      {
        name: 'replaceDeprecatedPrivileges',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'put',
    path: '/api/security/role/:name',
    alias: 'put-security-role-name',
    description: `Create a new Kibana role or update the attributes of an existing role. Kibana roles are stored in the Elasticsearch native realm.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_security_role_name_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string().min(1).max(1024),
      },
      {
        name: 'createOnly',
        type: 'Query',
        schema: z.boolean().optional().default(false),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/security/roles',
    alias: 'post-security-roles',
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_security_roles_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/security/session/_invalidate',
    alias: 'post-security-session-invalidate',
    description: `Invalidate user sessions that match a query. To use this API, you must be a superuser.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_security_session_invalidate_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.object({ total: z.number().int() }).partial().passthrough(),
    errors: [
      {
        status: 403,
        description: `Indicates that the user may not be authorized to invalidate sessions for other users.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/short_url',
    alias: 'post-url',
    description: `Kibana URLs may be long and cumbersome, short URLs are much easier to remember and share.
Short URLs are created by specifying the locator ID and locator parameters. When a short URL is resolved, the locator ID and locator parameters are used to redirect user to the right Kibana page.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_url_Body,
      },
    ],
    response: Short_URL_APIs_urlResponse,
  },
  {
    method: 'get',
    path: '/api/short_url/_slug/:slug',
    alias: 'resolve-url',
    description: `Resolve a Kibana short URL by its slug.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'slug',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: Short_URL_APIs_urlResponse,
  },
  {
    method: 'delete',
    path: '/api/short_url/:id',
    alias: 'delete-url',
    description: `Delete a Kibana short URL.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/short_url/:id',
    alias: 'get-url',
    description: `Get a single Kibana short URL.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: Short_URL_APIs_urlResponse,
  },
  {
    method: 'post',
    path: '/api/spaces/_copy_saved_objects',
    alias: 'post-spaces-copy-saved-objects',
    description: `It also allows you to automatically copy related objects, so when you copy a dashboard, this can automatically copy over the associated visualizations, data views, and saved Discover sessions, as required. You can request to overwrite any objects that already exist in the target space if they share an identifier or you can use the resolve copy saved objects conflicts API to do this on a per-object basis.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: copySavedObjectsToSpaces.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_spaces_copy_saved_objects_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/spaces/_disable_legacy_url_aliases',
    alias: 'post-spaces-disable-legacy-url-aliases',
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_spaces_disable_legacy_url_aliases_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/spaces/_get_shareable_references',
    alias: 'post-spaces-get-shareable-references',
    description: `Collect references and space contexts for saved objects.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_spaces_get_shareable_references_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/spaces/_resolve_copy_saved_objects_errors',
    alias: 'post-spaces-resolve-copy-saved-objects-errors',
    description: `Overwrite saved objects that are returned as errors from the copy saved objects to space API.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: copySavedObjectsToSpaces.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_spaces_resolve_copy_saved_objects_errors_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/spaces/_update_objects_spaces',
    alias: 'post-spaces-update-objects-spaces',
    description: `Update one or more saved objects to add or remove them from some spaces.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_spaces_update_objects_spaces_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/spaces/space',
    alias: 'get-spaces-space',
    requestFormat: 'json',
    parameters: [
      {
        name: 'purpose',
        type: 'Query',
        schema: z
          .enum(['any', 'copySavedObjectsIntoSpace', 'shareSavedObjectsIntoSpace'])
          .optional(),
      },
      {
        name: 'include_authorized_purposes',
        type: 'Query',
        schema: include_authorized_purposes,
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/spaces/space',
    alias: 'post-spaces-space',
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_spaces_space_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'delete',
    path: '/api/spaces/space/:id',
    alias: 'delete-spaces-space-id',
    description: `When you delete a space, all saved objects that belong to the space are automatically deleted, which is permanent and cannot be undone.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 404,
        description: `Indicates that the request failed.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/spaces/space/:id',
    alias: 'get-spaces-space-id',
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'put',
    path: '/api/spaces/space/:id',
    alias: 'put-spaces-space-id',
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_spaces_space_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/status',
    alias: 'get-status',
    requestFormat: 'json',
    parameters: [
      {
        name: 'v7format',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'v8format',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: z.union([
      Kibana_HTTP_APIs_core_status_response,
      Kibana_HTTP_APIs_core_status_redactedResponse,
    ]),
    errors: [
      {
        status: 503,
        description: `Kibana or some of it&#x27;s essential services are unavailable. Kibana may be degraded or unavailable.`,
        schema: z.union([
          Kibana_HTTP_APIs_core_status_response,
          Kibana_HTTP_APIs_core_status_redactedResponse,
        ]),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/streams',
    alias: 'get-streams',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Fetches list of all streams&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: read_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/streams/_disable',
    alias: 'post-streams-disable',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/_disable&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Disables wired streams and deletes all existing stream definitions. The data of wired streams is deleted, but the data of classic streams is preserved.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/streams/_enable',
    alias: 'post-streams-enable',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/_enable&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Enables wired streams&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/streams/_resync',
    alias: 'post-streams-resync',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/_resync&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Resyncs all streams, making sure that Elasticsearch assets are up to date&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'delete',
    path: '/api/streams/:name',
    alias: 'delete-streams-name',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Deletes a stream definition and the underlying data stream&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/streams/:name',
    alias: 'get-streams-name',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Fetches a stream definition and associated dashboards&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: read_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'put',
    path: '/api/streams/:name',
    alias: 'put-streams-name',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Creates or updates a stream definition. Classic streams can not be created through this API, only updated&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_streams_name_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/streams/:name/_fork',
    alias: 'post-streams-name-fork',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/_fork&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Forks a wired stream and creates a child stream&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_streams_name_fork_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/streams/:name/_group',
    alias: 'get-streams-name-group',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/_group&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Fetches the group settings of a group stream definition&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: read_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'put',
    path: '/api/streams/:name/_group',
    alias: 'put-streams-name-group',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/_group&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Upserts the group settings of a group stream definition&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_streams_name_group_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/streams/:name/_ingest',
    alias: 'get-streams-name-ingest',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/_ingest&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Fetches the ingest settings of an ingest stream definition&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: read_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'put',
    path: '/api/streams/:name/_ingest',
    alias: 'put-streams-name-ingest',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/_ingest&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Upserts the ingest settings of an ingest stream definition&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_streams_name_ingest_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/streams/:name/content/export',
    alias: 'post-streams-name-content-export',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/content/export&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Exports the content associated to a stream.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_streams_name_content_export_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/streams/:name/content/import',
    alias: 'post-streams-name-content-import',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/content/import&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Links content objects to a stream.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'form-data',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ content: z.unknown(), include: z.string() }),
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/streams/:name/dashboards',
    alias: 'get-streams-name-dashboards',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/dashboards&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Fetches all dashboards linked to a stream that are visible to the current user in the current space.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: read_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/streams/:name/dashboards/_bulk',
    alias: 'post-streams-name-dashboards-bulk',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/dashboards/_bulk&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Bulk update dashboards linked to a stream. Can link new dashboards and delete existing ones.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_streams_name_dashboards_bulk_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'delete',
    path: '/api/streams/:name/dashboards/:dashboardId',
    alias: 'delete-streams-name-dashboards-dashboardid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/dashboards/{dashboardId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Unlinks a dashboard from a stream. Noop if the dashboard is not linked to the stream.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'dashboardId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'put',
    path: '/api/streams/:name/dashboards/:dashboardId',
    alias: 'put-streams-name-dashboards-dashboardid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/dashboards/{dashboardId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Links a dashboard to a stream. Noop if the dashboard is already linked to the stream.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'dashboardId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/streams/:name/queries',
    alias: 'get-streams-name-queries',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/queries&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Fetches all queries linked to a stream that are visible to the current user in the current space.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: read_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/streams/:name/queries/_bulk',
    alias: 'post-streams-name-queries-bulk',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/queries/_bulk&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Bulk update queries of a stream. Can add new queries and delete existing ones.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_streams_name_queries_bulk_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'delete',
    path: '/api/streams/:name/queries/:queryId',
    alias: 'delete-streams-name-queries-queryid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/queries/{queryId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Remove a query from a stream. Noop if the query is not found on the stream.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'queryId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'put',
    path: '/api/streams/:name/queries/:queryId',
    alias: 'put-streams-name-queries-queryid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/queries/{queryId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Adds a query to a stream. Noop if the query is already present on the stream.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_streams_name_queries_queryid_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'queryId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/streams/:name/rules',
    alias: 'get-streams-name-rules',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/rules&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Fetches all rules linked to a stream that are visible to the current user in the current space.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: read_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'delete',
    path: '/api/streams/:name/rules/:ruleId',
    alias: 'delete-streams-name-rules-ruleid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/rules/{ruleId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Unlinks a rule from a stream. Noop if the rule is not linked to the stream.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'ruleId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'put',
    path: '/api/streams/:name/rules/:ruleId',
    alias: 'put-streams-name-rules-ruleid',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/rules/{ruleId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Links a rule to a stream. Noop if the rule is already linked to the stream.&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: manage_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'ruleId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/streams/:name/significant_events',
    alias: 'get-streams-name-significant-events',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/significant_events&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Read the significant events&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: read_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'from',
        type: 'Query',
        schema: z.string(),
      },
      {
        name: 'to',
        type: 'Query',
        schema: z.string(),
      },
      {
        name: 'bucketSize',
        type: 'Query',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/streams/:name/significant_events/_generate',
    alias: 'get-streams-name-significant-events-generate',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/significant_events/_generate&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Generate significant events queries based on the stream data&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: read_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: get_streams_Body,
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'connectorId',
        type: 'Query',
        schema: z.string(),
      },
      {
        name: 'currentDate',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'shortLookback',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'longLookback',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/streams/:name/significant_events/_preview',
    alias: 'post-streams-name-significant-events-preview',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/streams/{name}/significant_events/_preview&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Preview significant event results based on a given query&lt;br/&gt;&lt;br/&gt;[Required authorization] Route required privileges: read_stream.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_streams_name_significant_events_preview_Body,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'name',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'from',
        type: 'Query',
        schema: z.string(),
      },
      {
        name: 'to',
        type: 'Query',
        schema: z.string(),
      },
      {
        name: 'bucketSize',
        type: 'Query',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/synthetics/monitor/test/:monitorId',
    alias: 'post-synthetics-monitor-test',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/monitor/test/{monitorId}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Trigger an immediate test execution for the specified monitor. The response includes the generated &#x60;testRunId&#x60;. If the test encounters issues in one or more service locations, an &#x60;errors&#x60; array is also returned with details about the failures.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'monitorId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z
      .object({
        errors: z
          .array(
            z
              .object({
                error: z
                  .object({
                    failed_monitors: z.array(z.object({}).partial().passthrough()).nullable(),
                    reason: z.string(),
                    status: z.number().int(),
                  })
                  .passthrough(),
                locationId: z.string(),
              })
              .passthrough()
          )
          .optional(),
        testRunId: z.string(),
      })
      .passthrough(),
    errors: [
      {
        status: 404,
        description: `Monitor not found.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/synthetics/monitors',
    alias: 'get-synthetic-monitors',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/monitors&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of monitors.
You must have &#x60;read&#x60; privileges for the Synthetics feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'filter',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'locations',
        type: 'Query',
        schema: locations,
      },
      {
        name: 'monitorTypes',
        type: 'Query',
        schema: monitorTypes,
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().optional(),
      },
      {
        name: 'per_page',
        type: 'Query',
        schema: z.number().int().optional(),
      },
      {
        name: 'projects',
        type: 'Query',
        schema: locations,
      },
      {
        name: 'query',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'schedules',
        type: 'Query',
        schema: schedules,
      },
      {
        name: 'sortField',
        type: 'Query',
        schema: z.enum(['name', 'createdAt', 'updatedAt', 'status']).optional(),
      },
      {
        name: 'sortOrder',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'status',
        type: 'Query',
        schema: schedules,
      },
      {
        name: 'tags',
        type: 'Query',
        schema: locations,
      },
      {
        name: 'useLogicalAndFor',
        type: 'Query',
        schema: useLogicalAndFor,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'post',
    path: '/api/synthetics/monitors',
    alias: 'post-synthetic-monitors',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/monitors&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a new monitor with the specified attributes. A monitor can be one of the following types: HTTP, TCP, ICMP, or Browser. The required and default fields may vary based on the monitor type.
You must have &#x60;all&#x60; privileges for the Synthetics feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_synthetic_monitors_Body,
      },
    ],
    response: z.void(),
  },
  {
    method: 'post',
    path: '/api/synthetics/monitors/_bulk_delete',
    alias: 'delete-synthetic-monitors',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/monitors/_bulk_delete&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete multiple monitors by sending a list of config IDs.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: delete_synthetic_monitors_Body,
      },
    ],
    response: z.array(z.object({ deleted: z.boolean(), ids: z.string() }).partial().passthrough()),
  },
  {
    method: 'delete',
    path: '/api/synthetics/monitors/:id',
    alias: 'delete-synthetic-monitor',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/monitors/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a monitor from the Synthetics app.
You must have &#x60;all&#x60; privileges for the Synthetics feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/synthetics/monitors/:id',
    alias: 'get-synthetic-monitor',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/monitors/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
    errors: [
      {
        status: 404,
        description: `If the monitor is not found, the API returns a 404 error.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'put',
    path: '/api/synthetics/monitors/:id',
    alias: 'put-synthetic-monitor',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/monitors/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update a monitor with the specified attributes. The required and default fields may vary based on the monitor type.
You must have &#x60;all&#x60; privileges for the Synthetics feature in the Observability section of the Kibana feature privileges.
You can also partially update a monitor. This will only update the fields that are specified in the request body. All other fields are left unchanged. The specified fields should conform to the monitor type. For example, you can&#x27;t update the &#x60;inline_scipt&#x60; field of a HTTP monitor.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_synthetic_monitors_Body,
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/synthetics/params',
    alias: 'get-parameters',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/params&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all parameters. You must have &#x60;read&#x60; privileges for the Synthetics feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    response: z.array(Synthetics_getParameterResponse),
  },
  {
    method: 'post',
    path: '/api/synthetics/params',
    alias: 'post-parameters',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/params&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Add one or more parameters to the Synthetics app.
You must have &#x60;all&#x60; privileges for the Synthetics feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The request body can contain either a single parameter object or an array of parameter objects.`,
        type: 'Body',
        schema: post_parameters_Body,
      },
    ],
    response: z.union([
      z.array(Synthetics_postParameterResponse),
      Synthetics_postParameterResponse,
    ]),
  },
  {
    method: 'delete',
    path: '/api/synthetics/params/_bulk_delete',
    alias: 'delete-parameters',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/params/_bulk_delete&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete parameters from the Synthetics app.
You must have &#x60;all&#x60; privileges for the Synthetics feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({}).partial().passthrough(),
      },
    ],
    response: z.array(z.object({ deleted: z.boolean(), id: z.string() }).partial().passthrough()),
  },
  {
    method: 'delete',
    path: '/api/synthetics/params/:id',
    alias: 'delete-parameter',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/params/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete a parameter from the Synthetics app.
You must have &#x60;all&#x60; privileges for the Synthetics feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/synthetics/params/:id',
    alias: 'get-parameter',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/params/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a parameter from the Synthetics app.
You must have &#x60;read&#x60; privileges for the Synthetics feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: Synthetics_getParameterResponse,
  },
  {
    method: 'put',
    path: '/api/synthetics/params/:id',
    alias: 'put-parameter',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/params/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update a parameter in the Synthetics app.
You must have &#x60;all&#x60; privileges for the Synthetics feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The request body cannot be empty; at least one attribute is required.`,
        type: 'Body',
        schema: put_parameter_Body,
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/api/synthetics/private_locations',
    alias: 'get-private-locations',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/private_locations&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of private locations.
You must have &#x60;read&#x60; privileges for the Synthetics and Uptime feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    response: z.array(Synthetics_getPrivateLocation),
  },
  {
    method: 'post',
    path: '/api/synthetics/private_locations',
    alias: 'post-private-location',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/private_locations&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;all&#x60; privileges for the Synthetics and Uptime feature in the Observability section of the Kibana feature privileges.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: post_private_location_Body,
      },
    ],
    response: z.object({}).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `If the &#x60;agentPolicyId&#x60; is already used by an existing private location or if the &#x60;label&#x60; already exists, the API will return a 400 Bad Request response with a corresponding error message.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'delete',
    path: '/api/synthetics/private_locations/:id',
    alias: 'delete-private-location',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/private_locations/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;all&#x60; privileges for the Synthetics and Uptime feature in the Observability section of the Kibana feature privileges.
The API does not return a response body for deletion, but it will return an appropriate status code upon successful deletion.
A location cannot be deleted if it has associated monitors in use. You must delete all monitors associated with the location before deleting the location.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string().min(1).max(1024),
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/synthetics/private_locations/:id',
    alias: 'get-private-location',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/private_locations/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;read&#x60; privileges for the Synthetics and Uptime feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z
      .object({
        agentPolicyId: z.string(),
        geo: z.object({ lat: z.number(), lon: z.number() }).passthrough(),
        id: z.string(),
        isInvalid: z.boolean(),
        label: z.string(),
        namespace: z.string(),
      })
      .partial()
      .passthrough(),
  },
  {
    method: 'put',
    path: '/api/synthetics/private_locations/:id',
    alias: 'put-private-location',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/synthetics/private_locations/{id}&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update an existing private location&#x27;s label.
You must have &#x60;all&#x60; privileges for the Synthetics and Uptime feature in the Observability section of the Kibana feature privileges.
When a private location&#x27;s label is updated, all monitors using this location will also be updated to maintain data consistency.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: z.object({ label: z.string().min(1) }).passthrough(),
      },
      {
        name: 'id',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z
      .object({
        agentPolicyId: z.string(),
        geo: z.object({ lat: z.number(), lon: z.number() }).passthrough(),
        id: z.string(),
        isInvalid: z.boolean(),
        label: z.string(),
        namespace: z.string(),
      })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `If the &#x60;label&#x60; is shorter than 1 character the API will return a 400 Bad Request response with a corresponding error message.`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `If the private location with the specified ID does not exist, the API will return a 404 Not Found response.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/task_manager/_health',
    alias: 'task-manager-health',
    description: `Get the health status of the Kibana task manager.
`,
    requestFormat: 'json',
    response: Task_manager_health_APIs_health_response,
  },
  {
    method: 'delete',
    path: '/api/timeline',
    alias: 'DeleteTimelines',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb delete&quot;&gt;delete&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Delete one or more Timelines or Timeline templates.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The IDs of the Timelines or Timeline templates to delete.`,
        type: 'Body',
        schema: DeleteTimelines_Body,
      },
    ],
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/timeline',
    alias: 'GetTimeline',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of an existing saved Timeline or Timeline template.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'template_timeline_id',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'id',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: Security_Timeline_API_TimelineResponse,
  },
  {
    method: 'patch',
    path: '/api/timeline',
    alias: 'PatchTimeline',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update an existing Timeline. You can update the title, description, date range, pinned events, pinned queries, and/or pinned saved queries of an existing Timeline.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The Timeline updates, along with the Timeline ID and version.`,
        type: 'Body',
        schema: PatchTimeline_Body,
      },
    ],
    response: Security_Timeline_API_TimelineResponse,
    errors: [
      {
        status: 405,
        description: `Indicates that the user does not have the required access to create a Timeline.`,
        schema: z.object({ body: z.string(), statusCode: z.number() }).partial().passthrough(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/timeline',
    alias: 'CreateTimelines',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a new Timeline or Timeline template.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The required Timeline fields used to create a new Timeline, along with optional fields that will be created if not provided.`,
        type: 'Body',
        schema: CreateTimelines_Body,
      },
    ],
    response: Security_Timeline_API_TimelineResponse,
    errors: [
      {
        status: 405,
        description: `Indicates that there was an error in the Timeline creation.`,
        schema: z.object({ body: z.string(), statusCode: z.number() }).partial().passthrough(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/timeline/_copy',
    alias: 'CopyTimeline',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline/_copy&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Copies and returns a timeline or timeline template.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: CopyTimeline_Body,
      },
    ],
    response: Security_Timeline_API_TimelineResponse,
  },
  {
    method: 'get',
    path: '/api/timeline/_draft',
    alias: 'GetDraftTimelines',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline/_draft&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get the details of the draft Timeline  or Timeline template for the current user. If the user doesn&#x27;t have a draft Timeline, an empty Timeline is returned.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'timelineType',
        type: 'Query',
        schema: z.enum(['default', 'template']),
      },
    ],
    response: Security_Timeline_API_TimelineResponse,
    errors: [
      {
        status: 403,
        description: `If a draft Timeline was not found and we attempted to create one, it indicates that the user does not have the required permissions to create a draft Timeline.`,
        schema: z.void(),
      },
      {
        status: 409,
        description: `This should never happen, but if a draft Timeline was not found and we attempted to create one, it indicates that there is already a draft Timeline with the given &#x60;timelineId&#x60;.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/timeline/_draft',
    alias: 'CleanDraftTimelines',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline/_draft&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Create a clean draft Timeline or Timeline template for the current user.
&gt; info
&gt; If the user already has a draft Timeline, the existing draft Timeline is cleared and returned.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The type of Timeline to create. Valid values are &#x60;default&#x60; and &#x60;template&#x60;.`,
        type: 'Body',
        schema: CleanDraftTimelines_Body,
      },
    ],
    response: Security_Timeline_API_TimelineResponse,
    errors: [
      {
        status: 403,
        description: `Indicates that the user does not have the required permissions to create a draft Timeline.`,
        schema: z.void(),
      },
      {
        status: 409,
        description: `Indicates that there is already a draft Timeline with the given &#x60;timelineId&#x60;.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/timeline/_export',
    alias: 'ExportTimelines',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline/_export&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Export Timelines as an NDJSON file.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The IDs of the Timelines to export.`,
        type: 'Body',
        schema: ExportTimelines_Body,
      },
      {
        name: 'file_name',
        type: 'Query',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Indicates that the export size limit was exceeded.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'patch',
    path: '/api/timeline/_favorite',
    alias: 'PersistFavoriteRoute',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb patch&quot;&gt;patch&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline/_favorite&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Favorite a Timeline or Timeline template for the current user.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The required fields used to favorite a (template) Timeline.`,
        type: 'Body',
        schema: PersistFavoriteRoute_Body,
      },
    ],
    response: Security_Timeline_API_FavoriteTimelineResponse,
    errors: [
      {
        status: 403,
        description: `Indicates the user does not have the required permissions to persist the favorite status.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/timeline/_import',
    alias: 'ImportTimelines',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline/_import&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Import Timelines.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The Timelines to import as a readable stream.`,
        type: 'Body',
        schema: ImportTimelines_Body,
      },
    ],
    response: Security_Timeline_API_ImportTimelineResult,
    errors: [
      {
        status: 400,
        description: `Indicates the import of Timelines was unsuccessful because of an invalid file extension.`,
        schema: z.object({ body: z.string(), statusCode: z.number() }).partial().passthrough(),
      },
      {
        status: 404,
        description: `Indicates that we were unable to locate the saved object client necessary to handle the import.`,
        schema: z.object({ body: z.string(), statusCode: z.number() }).partial().passthrough(),
      },
      {
        status: 409,
        description: `Indicates the import of Timelines was unsuccessful.`,
        schema: z.object({ body: z.string(), statusCode: z.number() }).partial().passthrough(),
      },
    ],
  },
  {
    method: 'post',
    path: '/api/timeline/_prepackaged',
    alias: 'InstallPrepackedTimelines',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb post&quot;&gt;post&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline/_prepackaged&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Install or update prepackaged Timelines.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        description: `The Timelines to install or update.`,
        type: 'Body',
        schema: InstallPrepackedTimelines_Body,
      },
    ],
    response: Security_Timeline_API_ImportTimelineResult,
    errors: [
      {
        status: 500,
        description: `Indicates the installation of prepackaged Timelines was unsuccessful.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/timeline/resolve',
    alias: 'ResolveTimeline',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timeline/resolve&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'template_timeline_id',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'id',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: Security_Timeline_API_ResolvedTimeline,
    errors: [
      {
        status: 400,
        description: `The request is missing parameters`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `The (template) Timeline was not found`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/timelines',
    alias: 'GetTimelines',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/timelines&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Get a list of all saved Timelines or Timeline templates.`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'only_user_favorite',
        type: 'Query',
        schema: z.enum(['true', 'false']).nullish(),
      },
      {
        name: 'timeline_type',
        type: 'Query',
        schema: z.enum(['default', 'template']).optional(),
      },
      {
        name: 'sort_field',
        type: 'Query',
        schema: z.enum(['title', 'description', 'updated', 'created']).optional(),
      },
      {
        name: 'sort_order',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional(),
      },
      {
        name: 'page_size',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'page_index',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'search',
        type: 'Query',
        schema: z.string().nullish(),
      },
      {
        name: 'status',
        type: 'Query',
        schema: z.enum(['active', 'draft', 'immutable']).optional(),
      },
    ],
    response: z
      .object({
        customTemplateTimelineCount: z.number().optional(),
        defaultTimelineCount: z.number().optional(),
        elasticTemplateTimelineCount: z.number().optional(),
        favoriteCount: z.number().optional(),
        templateTimelineCount: z.number().optional(),
        timeline: z.array(Security_Timeline_API_TimelineResponse),
        totalCount: z.number(),
      })
      .passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request. The user supplied invalid data.`,
        schema: z.void(),
      },
    ],
  },
  {
    method: 'get',
    path: '/api/upgrade_assistant/status',
    alias: 'get-upgrade-status',
    description: `Check the status of your cluster.`,
    requestFormat: 'json',
    response: z.void(),
  },
  {
    method: 'get',
    path: '/api/uptime/settings',
    alias: 'get-uptime-settings',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb get&quot;&gt;get&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/uptime/settings&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

You must have &#x60;read&#x60; privileges for the uptime feature in the Observability section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'put',
    path: '/api/uptime/settings',
    alias: 'put-uptime-settings',
    description: `**Spaces method and path for this operation:**

&lt;div&gt;&lt;span class&#x3D;&quot;operation-verb put&quot;&gt;put&lt;/span&gt;&amp;nbsp;&lt;span class&#x3D;&quot;operation-path&quot;&gt;/s/{space_id}/api/uptime/settings&lt;/span&gt;&lt;/div&gt;

Refer to [Spaces](https://www.elastic.co/docs/deploy-manage/manage-spaces) for more information.

Update uptime setting attributes like &#x60;heartbeatIndices&#x60;, &#x60;certExpirationThreshold&#x60;, &#x60;certAgeThreshold&#x60;, &#x60;defaultConnectors&#x60;, or &#x60;defaultEmail&#x60;. You must have &#x60;all&#x60; privileges for the uptime feature in the Observability section of the Kibana feature privileges. A partial update is supported, provided settings keys will be merged with existing settings.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: put_uptime_settings_Body,
      },
    ],
    response: z.object({}).partial().passthrough(),
  },
  {
    method: 'get',
    path: '/s/:spaceId/api/observability/slos',
    alias: 'findSlosOp',
    description: `You must have the &#x60;read&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'kqlQuery',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'size',
        type: 'Query',
        schema: z.number().int().optional().default(1),
      },
      {
        name: 'searchAfter',
        type: 'Query',
        schema: z.array(z.string()).optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().int().optional().default(1),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().int().lte(5000).optional().default(25),
      },
      {
        name: 'sortBy',
        type: 'Query',
        schema: z
          .enum(['sli_value', 'status', 'error_budget_consumed', 'error_budget_remaining'])
          .optional()
          .default('status'),
      },
      {
        name: 'sortDirection',
        type: 'Query',
        schema: z.enum(['asc', 'desc']).optional().default('asc'),
      },
      {
        name: 'hideStale',
        type: 'Query',
        schema: z.boolean().optional(),
      },
    ],
    response: SLOs_find_slo_response,
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: SLOs_404_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/s/:spaceId/api/observability/slos',
    alias: 'createSloOp',
    description: `You must have &#x60;all&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: SLOs_create_slo_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ id: z.string() }).passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
      {
        status: 409,
        description: `Conflict - The SLO id already exists`,
        schema: SLOs_409_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/s/:spaceId/api/observability/slos/_bulk_delete',
    alias: 'bulkDeleteOp',
    description: `Bulk delete SLO definitions and their associated summary and rollup data.  This endpoint initiates a bulk deletion operation for SLOs, which may take some time to complete.  The status of the operation can be checked using the &#x60;GET /api/slo/_bulk_delete/{taskId}&#x60; endpoint.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: SLOs_bulk_delete_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ taskId: z.string() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/s/:spaceId/api/observability/slos/_bulk_delete/:taskId',
    alias: 'bulkDeleteStatusOp',
    description: `Retrieve the status of the bulk deletion operation for SLOs.  This endpoint returns the status of the bulk deletion operation, including whether it is completed and the results of the operation.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'taskId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: SLOs_bulk_delete_status_response,
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/s/:spaceId/api/observability/slos/_bulk_purge_rollup',
    alias: 'deleteRollupDataOp',
    description: `The deletion occurs for the specified list of &#x60;sloId&#x60;. You must have &#x60;all&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: SLOs_bulk_purge_rollup_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.object({ taskId: z.string() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/s/:spaceId/api/observability/slos/_delete_instances',
    alias: 'deleteSloInstancesOp',
    description: `The deletion occurs for the specified list of &#x60;sloId&#x60; and &#x60;instanceId&#x60;. You must have &#x60;all&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: SLOs_delete_slo_instances_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
    ],
  },
  {
    method: 'delete',
    path: '/s/:spaceId/api/observability/slos/:sloId',
    alias: 'deleteSloOp',
    description: `You must have the &#x60;write&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'sloId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: SLOs_404_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/s/:spaceId/api/observability/slos/:sloId',
    alias: 'getSloOp',
    description: `You must have the &#x60;read&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'sloId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'instanceId',
        type: 'Query',
        schema: z.string().optional(),
      },
    ],
    response: SLOs_slo_with_summary_response,
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: SLOs_404_response,
      },
    ],
  },
  {
    method: 'put',
    path: '/s/:spaceId/api/observability/slos/:sloId',
    alias: 'updateSloOp',
    description: `You must have the &#x60;write&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'body',
        type: 'Body',
        schema: SLOs_update_slo_request,
      },
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'sloId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: SLOs_slo_definition_response,
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: SLOs_404_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/s/:spaceId/api/observability/slos/:sloId/_reset',
    alias: 'resetSloOp',
    description: `You must have the &#x60;write&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'sloId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: SLOs_slo_definition_response,
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: SLOs_404_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/s/:spaceId/api/observability/slos/:sloId/disable',
    alias: 'disableSloOp',
    description: `You must have the &#x60;write&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'sloId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: SLOs_404_response,
      },
    ],
  },
  {
    method: 'post',
    path: '/s/:spaceId/api/observability/slos/:sloId/enable',
    alias: 'enableSloOp',
    description: `You must have the &#x60;write&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'sloId',
        type: 'Path',
        schema: z.string(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
      {
        status: 404,
        description: `Not found response`,
        schema: SLOs_404_response,
      },
    ],
  },
  {
    method: 'get',
    path: '/s/:spaceId/internal/observability/slos/_definitions',
    alias: 'getDefinitionsOp',
    description: `You must have the &#x60;read&#x60; privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.
`,
    requestFormat: 'json',
    parameters: [
      {
        name: 'kbn-xsrf',
        type: 'Header',
        schema: z.string(),
      },
      {
        name: 'spaceId',
        type: 'Path',
        schema: z.string(),
      },
      {
        name: 'includeOutdatedOnly',
        type: 'Query',
        schema: z.boolean().optional(),
      },
      {
        name: 'tags',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'search',
        type: 'Query',
        schema: z.string().optional(),
      },
      {
        name: 'page',
        type: 'Query',
        schema: z.number().optional(),
      },
      {
        name: 'perPage',
        type: 'Query',
        schema: z.number().int().lte(1000).optional().default(100),
      },
    ],
    response: SLOs_find_slo_definitions_response,
    errors: [
      {
        status: 400,
        description: `Bad request`,
        schema: SLOs_400_response,
      },
      {
        status: 401,
        description: `Unauthorized response`,
        schema: SLOs_401_response,
      },
      {
        status: 403,
        description: `Unauthorized response`,
        schema: SLOs_403_response,
      },
    ],
  },
]);

export const api = new Zodios(endpoints);

export function createApiClient(baseUrl: string, options?: ZodiosOptions) {
  return new Zodios(baseUrl, endpoints, options);
}
