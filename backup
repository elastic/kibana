/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import type { Scalar } from 'yaml';
import { YAMLParseError, isScalar, parseDocument } from 'yaml';
import { monaco } from '@kbn/monaco';
import { z } from '@kbn/zod';
import { getWorkflowGraph } from '../../../entities/workflows/lib/get_workflow_graph';
import { getCurrentPath, parseWorkflowYamlToJSON } from '../../../../common/lib/yaml_utils';
import { getContextSchemaForPath } from '../../../features/workflow_context/lib/get_context_for_path';
import { getAllConnectors } from '../../../../common/schema';
import {
  MUSTACHE_REGEX_GLOBAL,
  PROPERTY_PATH_REGEX,
  UNFINISHED_MUSTACHE_REGEX_GLOBAL,
} from '../../../../common/lib/regex';
import { getSchemaAtPath, getZodTypeName, parsePath } from '../../../../common/lib/zod_utils';

export interface LineParseResult {
  fullKey: string;
  pathSegments: string[] | null;
  matchType: 'at' | 'bracket-unfinished' | 'mustache-complete' | 'mustache-unfinished' | null;
  match: RegExpMatchArray | null;
}

function cleanKey(key: string) {
  if (key === '.') {
    // special expression in mustache for current object
    return key;
  }
  // remove trailing dot if it exists
  return key.endsWith('.') ? key.slice(0, -1) : key;
}

export function parseLineForCompletion(lineUpToCursor: string): LineParseResult {
  // Try @ trigger first (e.g., "@const" or "@steps.step1")
  const atMatch = [...lineUpToCursor.matchAll(/@(?<key>\S+?)?\.?(?=\s|$)/g)].pop();
  if (atMatch) {
    const fullKey = cleanKey(atMatch.groups?.key ?? '');
    return {
      fullKey,
      pathSegments: parsePath(fullKey),
      matchType: 'at',
      match: atMatch,
    };
  }

  // Try unfinished mustache (e.g., "{{ consts.api" at end of line)
  const unfinishedMatch = [...lineUpToCursor.matchAll(UNFINISHED_MUSTACHE_REGEX_GLOBAL)].pop();
  if (unfinishedMatch) {
    const fullKey = cleanKey(unfinishedMatch.groups?.key ?? '');
    return {
      fullKey,
      pathSegments: parsePath(fullKey),
      matchType: 'mustache-unfinished',
      match: unfinishedMatch,
    };
  }

  // Try complete mustache (e.g., "{{ consts.apiUrl }}")
  const completeMatch = [...lineUpToCursor.matchAll(MUSTACHE_REGEX_GLOBAL)].pop();
  if (completeMatch) {
    const fullKey = cleanKey(completeMatch.groups?.key ?? '');
    return {
      fullKey,
      pathSegments: parsePath(fullKey),
      matchType: 'mustache-complete',
      match: completeMatch,
    };
  }

  return {
    fullKey: '',
    pathSegments: [],
    matchType: null,
    match: null,
  };
}

/**
 * Generate a snippet template for a connector type with required parameters
 */
function generateConnectorSnippet(connectorType: string, shouldBeQuoted: boolean): string {
  const quotedType = shouldBeQuoted ? `"${connectorType}"` : connectorType;
  
  // Get required parameters for this connector type
  const requiredParams = getRequiredParamsForConnector(connectorType);
  
  // console.log('üîß Generating snippet', { connectorType, shouldBeQuoted, quotedType, requiredParams });
  
  if (requiredParams.length === 0) {
    // No required params, just add empty with block with a placeholder
    const snippet = `${quotedType}\nwith:\n  \${1:# Add parameters here}`;
    // console.log('üìù Generated snippet (no params)', snippet);
    return snippet;
  }
  
  // Create with block with required parameters as placeholders
  let withBlock = `${quotedType}\nwith:`;
  requiredParams.forEach((param, index) => {
    const placeholder = param.example || param.defaultValue || '';
    withBlock += `\n  ${param.name}: \${${index + 1}:${placeholder}}`;
  });
  
  // console.log('üìù Generated snippet (with params)', withBlock);
  return withBlock;
}

/**
 * Extract required parameters from a Zod schema
 */
function extractRequiredParamsFromSchema(schema: z.ZodType): Array<{name: string, example?: string, defaultValue?: string, required: boolean}> {
  const params: Array<{name: string, example?: string, defaultValue?: string, required: boolean}> = [];
  
  if (schema instanceof z.ZodObject) {
    const shape = schema.shape;
    for (const [key, fieldSchema] of Object.entries(shape)) {
      const zodField = fieldSchema as z.ZodType;
      
      // Skip common non-parameter fields
      if (['pretty', 'human', 'error_trace', 'source', 'filter_path'].includes(key)) {
        continue;
      }
      
      // Check if field is required (not optional)
      const isOptional = zodField instanceof z.ZodOptional;
      const isRequired = !isOptional;
      
      // Extract description for examples
      let description = '';
      let example = '';
      
      if ('description' in zodField && typeof zodField.description === 'string') {
        description = zodField.description;
        // Try to extract example from description
        const exampleMatch = description.match(/example[:\s]+['"]*([^'"]+)['"]*|default[:\s]+['"]*([^'"]+)['"]*/i);
        if (exampleMatch) {
          example = exampleMatch[1] || exampleMatch[2] || '';
        }
      }
      
      // Add some default examples based on common parameter names
      if (!example) {
        if (key === 'index') {
          example = 'my-index';
        } else if (key === 'id') {
          example = 'doc-id';
        } else if (key === 'body') {
          example = '{}';
        } else if (key === 'query') {
          example = '{}';
        } else if (key.includes('name')) {
          example = 'my-name';
        }
      }
      
      // Only include required parameters or very common ones
      if (isRequired || ['index', 'id', 'body'].includes(key)) {
        params.push({
          name: key,
          example,
          required: isRequired
        });
      }
    }
  }
  
  return params;
}

/**
 * Get required parameters for a connector type from generated schemas
 */
function getRequiredParamsForConnector(connectorType: string): Array<{name: string, example?: string, defaultValue?: string}> {
  // Get all connectors (both static and generated)
  const allConnectors = getAllConnectors();
  
  // Find the connector by type
  const connector = allConnectors.find((c: any) => c.type === connectorType);
  
  if (connector && connector.paramsSchema) {
    try {
      // Extract required parameters from the actual Zod schema
      const params = extractRequiredParamsFromSchema(connector.paramsSchema);
      
      // Return only required parameters, or most important ones if no required ones
      const requiredParams = params.filter(p => p.required);
      if (requiredParams.length > 0) {
        return requiredParams.map(p => ({ name: p.name, example: p.example }));
      }
      
      // If no required params, return the most important ones (index, id, body)
      const importantParams = params.filter(p => ['index', 'id', 'body'].includes(p.name));
      if (importantParams.length > 0) {
        return importantParams.slice(0, 3).map(p => ({ name: p.name, example: p.example }));
      }
      
    } catch (error) {
      console.warn('Failed to extract parameters from schema for', connectorType, error);
    }
  }
  
  // Fallback to basic hardcoded ones for non-ES connectors
  const basicConnectorParams: Record<string, Array<{name: string, example?: string}>> = {
    'console': [{ name: 'message', example: 'Hello World' }],
    'slack': [{ name: 'message', example: 'Hello Slack' }],
    'http': [
      { name: 'url', example: 'https://api.example.com' },
      { name: 'method', example: 'GET' }
    ],
    'wait': [{ name: 'duration', example: '5s' }],
    'kibana.cases.create': [
      { name: 'title', example: 'Case Title' },
      { name: 'description', example: 'Case description' }
    ],
    'kibana.request': [
      { name: 'method', example: 'GET' },
      { name: 'path', example: '/api/status' }
    ]
  };
  
  return basicConnectorParams[connectorType] || [];
}

/**
 * Get connector type suggestions with better grouping and filtering
 */
function getConnectorTypeSuggestions(
  typePrefix: string,
  range: monaco.IRange,
  context: monaco.languages.CompletionContext,
  scalarType: Scalar.Type | null,
  shouldBeQuoted: boolean
): monaco.languages.CompletionItem[] {
  const suggestions: monaco.languages.CompletionItem[] = [];
  
  // Get dynamic connector counts
  const allConnectors = getAllConnectors();
  const esCount = allConnectors.filter((c: any) => c.type.startsWith('elasticsearch.')).length;
  const kibanaCount = allConnectors.filter((c: any) => c.type.startsWith('kibana.')).length;
  
  // Define connector type groups with dynamic counts
  const connectorGroups = [
    {
      prefix: '',
      types: ['console', 'slack', 'wait', 'http'],
      label: 'Basic Connectors',
      description: 'Basic workflow connectors'
    },
    {
      prefix: 'elasticsearch.',
      types: ['search', 'indices.create', 'indices.delete', 'bulk', 'cluster.health', 'cluster.stats'],
      label: 'Elasticsearch APIs',
      description: `Elasticsearch operations (${esCount} available)`
    },
    {
      prefix: 'kibana.',
      types: ['cases.create', 'request'],
      label: 'Kibana APIs', 
      description: `Kibana operations (${kibanaCount} available)`
    },
    {
      prefix: 'inference.',
      types: ['unified_completion', 'completion'],
      label: 'AI/ML Inference',
      description: 'AI and ML inference connectors'
    }
  ];
  
  // If user is typing a prefix like "elasticsearch.", show filtered suggestions
  if (typePrefix.includes('.')) {
    const [namespace] = typePrefix.split('.');
    const namespacePrefix = `${namespace}.`;
    
    if (namespacePrefix === 'elasticsearch.') {
      // Get ALL Elasticsearch APIs from generated connectors
      const allConnectors = getAllConnectors();
      const allEsAPIs = allConnectors
        .filter((c: any) => c.type.startsWith('elasticsearch.'))
        .map((c: any) => c.type);
      
      // Show filtered Elasticsearch APIs based on what user is typing
      const matchingEsAPIs = allEsAPIs.filter((api: string) => 
        api.toLowerCase().includes(typePrefix.toLowerCase())
      );
      
      // For performance, limit to first 50 matches for dropdown (increased from 20)
      const esAPIs = matchingEsAPIs.slice(0, 50);
      
      console.log('üìã ES APIs to process:', esAPIs.length, 'first few:', esAPIs.slice(0, 3));
      
      esAPIs.forEach(api => {
        console.log('üîß Processing API:', api);
        const snippetText = generateConnectorSnippet(api, shouldBeQuoted);
        console.log('üìù Generated snippet for', api, ':', snippetText.substring(0, 50) + '...');
        
        // Convert snippet placeholders to simple text for Monaco YAML compatibility
        const simpleText = snippetText.replace(/\$\{(\d+):([^}]*)\}/g, '$2');
        
        console.log('üîç Monaco kind constants:', {
          Value: monaco.languages.CompletionItemKind.Value,
          Snippet: monaco.languages.CompletionItemKind.Snippet,
          Text: monaco.languages.CompletionItemKind.Text
        });
        
        // For multi-line insertion, we need to extend the range to the end of the line
        const extendedRange = {
          startLineNumber: range.startLineNumber,
          endLineNumber: range.endLineNumber,
          startColumn: range.startColumn,
          endColumn: Math.max(range.endColumn, 1000), // Extend to end of line for multi-line insertion
        };
        
        const suggestion = {
          label: api,
          kind: 12, // Hardcode CompletionItemKind.Value to force it
          insertText: simpleText,
          range: extendedRange,
          documentation: `Elasticsearch API - ${api.replace('elasticsearch.', '')}`,
          filterText: api,
          sortText: api,
          detail: 'Insert connector with parameters'
        };
        
        console.log('‚úÖ Created suggestion:', {
          label: suggestion.label,
          kind: suggestion.kind,
          hasInsertText: !!suggestion.insertText,
          insertTextLength: suggestion.insertText?.length
        });
        
        suggestions.push(suggestion);
      });
      
      // Instead of showing "... and X more", we now show more suggestions (50 instead of 20)
      // If there are still more, users can type more characters to filter further
      
    } else if (namespacePrefix === 'kibana.') {
      // Get ALL Kibana APIs from connectors
      const allConnectors = getAllConnectors();
      const kibanaAPIs = allConnectors
        .filter((c: any) => c.type.startsWith('kibana.'))
        .map((c: any) => c.type)
        .filter((api: string) => api.toLowerCase().includes(typePrefix.toLowerCase()));
        
      kibanaAPIs.forEach(api => {
        const snippetText = generateConnectorSnippet(api, shouldBeQuoted);
        // Convert snippet placeholders to simple text for Monaco YAML compatibility
        const simpleText = snippetText.replace(/\$\{(\d+):([^}]*)\}/g, '$2');
        
        // For multi-line insertion, we need to extend the range to the end of the line
        const extendedRange = {
          startLineNumber: range.startLineNumber,
          endLineNumber: range.endLineNumber,
          startColumn: range.startColumn,
          endColumn: Math.max(range.endColumn, 1000), // Extend to end of line for multi-line insertion
        };
        
        suggestions.push({
          label: api,
          kind: 12, // Hardcode CompletionItemKind.Value to force it
          insertText: simpleText,
          range: extendedRange,
          documentation: `Kibana API - ${api.replace('kibana.', '')}`,
          filterText: api,
          sortText: api,
          detail: 'Insert connector with parameters'
        });
      });
    }
  } else {
    // Show ALL connector suggestions (not grouped by namespace)
    const allConnectors = getAllConnectors();
    const allConnectorTypes = allConnectors.map((c: any) => c.type);
    
    // Filter connectors that match the typePrefix
    const matchingConnectors = allConnectorTypes.filter((connectorType: string) =>
      connectorType.toLowerCase().includes(typePrefix.toLowerCase())
    );
    
    // Limit to first 50 for performance (increased from 20)
    const limitedConnectors = matchingConnectors.slice(0, 50);
    
    console.log('üåü All connector suggestions:', {
      totalConnectors: allConnectorTypes.length,
      matchingConnectors: matchingConnectors.length,
      showingFirst: limitedConnectors.length,
      typePrefix,
      firstFew: limitedConnectors.slice(0, 3)
    });
    
    limitedConnectors.forEach(connectorType => {
      console.log('üîÑ Processing connector:', connectorType);
      const snippetText = generateConnectorSnippet(connectorType, shouldBeQuoted);
      // Convert snippet placeholders to simple text for Monaco YAML compatibility
      const simpleText = snippetText.replace(/\$\{(\d+):([^}]*)\}/g, '$2'); // ${1:example} -> example
      
      console.log('üîç Monaco kind constants (general):', {
        Value: monaco.languages.CompletionItemKind.Value,
        Snippet: monaco.languages.CompletionItemKind.Snippet
      });
      
      // For multi-line insertion, we need to extend the range to the end of the line
      const extendedRange = {
        startLineNumber: range.startLineNumber,
        endLineNumber: range.endLineNumber,
        startColumn: range.startColumn,
        endColumn: Math.max(range.endColumn, 1000), // Extend to end of line for multi-line insertion
      };
      
      const suggestion = {
        label: connectorType,
        kind: 12, // Hardcode CompletionItemKind.Value to force it
        insertText: simpleText,
        range: extendedRange,
        documentation: `Workflow connector - ${connectorType}`,
        filterText: connectorType,
        sortText: connectorType,
        detail: 'Insert connector with parameters'
      };
      
      console.log('‚úÖ Created general suggestion:', {
        label: suggestion.label,
        kind: suggestion.kind,
        insertTextLength: suggestion.insertText?.length,
        range: suggestion.range,
        hasMultiline: suggestion.insertText?.includes('\n')
      });
      
      suggestions.push(suggestion);
    });
    
    // Add namespace hints
    if (typePrefix.length === 0 || 'elasticsearch'.startsWith(typePrefix.toLowerCase())) {
      suggestions.push({
        label: 'elasticsearch.*',
        kind: monaco.languages.CompletionItemKind.Module,
        insertText: shouldBeQuoted ? '"elasticsearch."' : 'elasticsearch.',
        range,
        documentation: 'Elasticsearch APIs (568 available) - type more to filter',
        command: { id: 'editor.action.triggerSuggest', title: 'Trigger Suggest' },
      });
    }
    
    if (typePrefix.length === 0 || 'kibana'.startsWith(typePrefix.toLowerCase())) {
      suggestions.push({
        label: 'kibana.*',
        kind: monaco.languages.CompletionItemKind.Module,
        insertText: shouldBeQuoted ? '"kibana."' : 'kibana.',
        range,
        documentation: 'Kibana APIs - type more to filter',
        command: { id: 'editor.action.triggerSuggest', title: 'Trigger Suggest' },
      });
    }
  }
  
  return suggestions;
}

export function getSuggestion(
  key: string,
  context: monaco.languages.CompletionContext,
  range: monaco.IRange,
  scalarType: Scalar.Type | null,
  shouldBeQuoted: boolean,
  type: string,
  description?: string
): monaco.languages.CompletionItem {
  let keyToInsert = key;
  const isAt = context.triggerCharacter === '@';
  const keyCouldAccessedByDot = PROPERTY_PATH_REGEX.test(key);
  const removeDot = isAt || !keyCouldAccessedByDot;

  if (!keyCouldAccessedByDot) {
    // we need to use opposite quote type if we are in a string
    const q = scalarType === 'QUOTE_DOUBLE' ? "'" : '"';
    keyToInsert = `[${q}${key}${q}]`;
  }

  let insertText = keyToInsert;
  let insertTextRules = monaco.languages.CompletionItemInsertTextRule.None;
  if (isAt) {
    insertText = `{{ ${key}$0 }}`;
    insertTextRules = monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet;
  }
  if (shouldBeQuoted) {
    insertText = `"${insertText}"`;
  }
  // $0 is the cursor position
  return {
    label: key,
    kind: monaco.languages.CompletionItemKind.Field,
    range,
    insertText,
    detail: `${type}` + (description ? `: ${description}` : ''),
    insertTextRules,
    additionalTextEdits: removeDot
      ? [
          {
            // remove the @
            range: {
              startLineNumber: range.startLineNumber,
              endLineNumber: range.endLineNumber,
              startColumn: range.startColumn - 1,
              endColumn: range.endColumn,
            },
            text: '',
          },
        ]
      : [],
  };
}

export function getCompletionItemProvider(
  workflowYamlSchema: z.ZodSchema
): monaco.languages.CompletionItemProvider {
  return {
    triggerCharacters: ['@', '.'],
    provideCompletionItems: (model, position, completionContext) => {
      try {
        const { lineNumber } = position;
        const line = model.getLineContent(lineNumber);
        const wordUntil = model.getWordUntilPosition(position);
        const word = model.getWordAtPosition(position) || wordUntil;
        const { startColumn, endColumn } = word;
        
              // console.log('üîç Workflow completion triggered', { position, line, lineNumber, column: position.column });
        const range = {
          startLineNumber: lineNumber,
          endLineNumber: lineNumber,
          startColumn,
          endColumn,
        };
        const absolutePosition = model.getOffsetAt(position);
        const suggestions: monaco.languages.CompletionItem[] = [];
        const value = model.getValue();
        
        console.log('üìÑ Model value:', { 
          value: value.substring(0, 200) + (value.length > 200 ? '...' : ''),
          absolutePosition 
        });
        
        const yamlDocument = parseDocument(value);
        console.log('üìã YAML Document parsed', { 
          hasErrors: yamlDocument.errors.length > 0,
          errors: yamlDocument.errors
        });
        
        // Try to parse with the strict schema first
        const result = parseWorkflowYamlToJSON(value, workflowYamlSchema);
        console.log('üîç Workflow parsing result', { 
          hasError: !!result.error,
          error: result.error?.message,
          success: 'success' in result ? result.success : false
        });
        
        // If strict parsing fails, try with a more lenient approach for completion
        let workflowData = 'success' in result && result.success ? result.data : null;
        if (result.error) {
          console.log('‚ö†Ô∏è Strict parsing failed, trying lenient parsing for completion');
          
          // Try to parse the YAML as-is without strict schema validation
          try {
            const parsedYaml = yamlDocument.toJS();
            console.log('üìù Raw YAML parsing', { parsedYaml });
            
            // If we have basic workflow structure, use it for completion context
            if (parsedYaml && typeof parsedYaml === 'object' && 'steps' in parsedYaml) {
              console.log('‚úÖ Found workflow structure for completion');
              workflowData = parsedYaml;
            } else {
              console.log('‚ùå No valid workflow structure found, skipping suggestions');
              return {
                suggestions: [],
              };
            }
          } catch (yamlError) {
            console.log('‚ùå Even lenient YAML parsing failed', yamlError);
            return {
              suggestions: [],
            };
          }
        }
        const workflowGraph = getWorkflowGraph(workflowData);
        const path = getCurrentPath(yamlDocument, absolutePosition);
        const yamlNode = yamlDocument.getIn(path, true);
        const scalarType = isScalar(yamlNode) ? yamlNode.type ?? null : null;
        
        // DEBUG: Log path and context
        console.log('üìç YAML Path analysis', {
          path,
          yamlNode: yamlNode?.toString(),
          scalarType,
          absolutePosition
        });
        // if we are in a plain scalar which starts with { or @, we need to add quotes otherwise template expression will break yaml
        const shouldBeQuoted =
          isScalar(yamlNode) &&
          scalarType === 'PLAIN' &&
          ((yamlNode?.value as string)?.startsWith('{') ||
            (yamlNode?.value as string)?.startsWith('@'));

        let context: z.ZodType;
        try {
          context = getContextSchemaForPath(workflowData, workflowGraph, path);
          console.log('‚úÖ Got context schema from path');
        } catch (contextError) {
          console.log('‚ö†Ô∏è Context schema failed, using workflow schema directly', contextError);
          // Fallback to the main workflow schema if context detection fails
          context = workflowYamlSchema;
        }

        const lineUpToCursor = line.substring(0, position.column - 1);
        const parseResult = parseLineForCompletion(lineUpToCursor);
        const lastPathSegment = lineUpToCursor.endsWith('.')
          ? null
          : parseResult.pathSegments?.pop() ?? null;

        if (parseResult.fullKey) {
          const schemaAtPath = getSchemaAtPath(context, parseResult.fullKey, { partial: true });
          if (schemaAtPath) {
            context = schemaAtPath;
          }
        }

        // SPECIAL CASE: Direct type completion in steps
        // Check if we're trying to complete a type field in a step, regardless of schema validation
        const typeCompletionMatch = lineUpToCursor.match(/^\s*-?\s*(?:name:\s*\w+\s*)?type:\s*(.*)$/i);
        // console.log('üîç Direct type completion check', { lineUpToCursor, hasMatch: !!typeCompletionMatch });
        
        if (typeCompletionMatch) {
          console.log('üéØ Direct type field completion detected', { 
            lineUpToCursor, 
            match: typeCompletionMatch,
            typePrefix: typeCompletionMatch[1]
          });
          
          const typePrefix = typeCompletionMatch[1].replace(/['"]/g, '').trim();
          
          // For snippets, we need to replace from the start of the type value to the end of the line
          // and allow Monaco to insert multiple lines
          const typeValueStartColumn = lineUpToCursor.indexOf(typeCompletionMatch[1]) + 1;
          const adjustedRange = {
            startLineNumber: range.startLineNumber,
            endLineNumber: range.endLineNumber,
            startColumn: typeValueStartColumn,
            endColumn: line.length + 1, // Go to end of line to allow multi-line insertion
          };
          
          console.log('üìê Snippet range calculation', { 
            originalRange: range,
            adjustedRange,
            lineLength: line.length,
            typeValueStartColumn,
            lineUpToCursor,
            fullLine: line
          });
          
          const typeSuggestions = getConnectorTypeSuggestions(typePrefix, adjustedRange, completionContext, scalarType, shouldBeQuoted);
          console.log('üìã Direct type suggestions generated', { 
            count: typeSuggestions.length,
            firstFew: typeSuggestions.slice(0, 3).map(s => ({ 
              label: s.label, 
              kind: s.kind,
              insertText: s.insertText?.substring(0, 50) + (s.insertText && s.insertText.length > 50 ? '...' : ''),
              insertTextRules: s.insertTextRules,
              range: s.range
            }))
          });
          
          return {
            suggestions: typeSuggestions,
          };
        }

        // currently, we only suggest properties for objects
        console.log('üèóÔ∏è Context schema check', { 
          isZodObject: context instanceof z.ZodObject,
          contextType: context.constructor.name,
          contextKeys: context instanceof z.ZodObject ? Object.keys(context.shape) : 'not an object'
        });
        
        if (!(context instanceof z.ZodObject)) {
          console.log('‚ùå Context is not ZodObject, skipping suggestions');
          return {
            suggestions: [],
          };
        }

        for (const [key, currentSchema] of Object.entries(context.shape) as [string, z.ZodType][]) {
          if (lastPathSegment && !key.startsWith(lastPathSegment)) {
            continue;
          }
          
          // Special handling for the 'type' field to provide better suggestions
          if (key === 'type' && path.length > 0 && path[path.length - 1] === 'steps') {
            console.log('üéØ Type field detected in steps', { key, path, lineUpToCursor });
            
            // Check if we're completing the value after "type: "
            const typeValueMatch = lineUpToCursor.match(/type:\s*(.*)$/i);
            console.log('üîç Type value match attempt', { typeValueMatch, lineUpToCursor });
            
            if (typeValueMatch) {
              const typePrefix = typeValueMatch[1].replace(/['"]/g, '').trim();
              
              console.log('‚úÖ Type completion detected', { 
                typePrefix, 
                originalMatch: typeValueMatch[1],
                lineUpToCursor 
              });
              
              // Adjust range to replace the entire value after "type: "
              const adjustedRange = {
                startLineNumber: range.startLineNumber,
                endLineNumber: range.endLineNumber,
                startColumn: lineUpToCursor.indexOf(typeValueMatch[1]) + 1,
                endColumn: range.endColumn,
              };
              
              console.log('üìê Range adjustment', { originalRange: range, adjustedRange });
              
              const typeSuggestions = getConnectorTypeSuggestions(typePrefix, adjustedRange, completionContext, scalarType, shouldBeQuoted);
              console.log('üìã Generated type suggestions', { 
                count: typeSuggestions.length,
                firstFew: typeSuggestions.slice(0, 3).map(s => s.label)
              });
              
              suggestions.push(...typeSuggestions);
            } else {
              // Even if there's no value after "type:", still show connector suggestions
              console.log('üìù Type field without value - showing all connector suggestions');
              
              // Create extended range to allow multi-line insertion
              const extendedRange = {
                startLineNumber: range.startLineNumber,
                endLineNumber: range.endLineNumber,
                startColumn: range.startColumn,
                endColumn: Math.max(range.endColumn, 1000),
              };
              
              const typeSuggestions = getConnectorTypeSuggestions('', extendedRange, completionContext, scalarType, shouldBeQuoted);
              console.log('üìã Generated all type suggestions', { 
                count: typeSuggestions.length,
                firstFew: typeSuggestions.slice(0, 3).map(s => s.label)
              });
              
              suggestions.push(...typeSuggestions);
            }
          } else {
            const propertyTypeName = getZodTypeName(currentSchema);
            suggestions.push(
              getSuggestion(
                key,
                completionContext,
                range,
                scalarType,
                shouldBeQuoted,
                propertyTypeName,
                currentSchema?.description
              )
            );
          }
        }

        // DEBUG: Final suggestions summary
        console.log('üéØ Final suggestions summary', {
          totalSuggestions: suggestions.length,
          suggestionTypes: suggestions.map(s => ({ label: s.label, kind: s.kind })).slice(0, 5)
        });

        return {
          suggestions,
        };
      } catch (error) {
        if (error instanceof YAMLParseError) {
          // Failed to parse YAML, skip suggestions
          return {
            suggestions: [],
          };
        }
        throw error;
      }
    },
  };
}
