/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import Fsp from 'fs/promises';

import { Path } from '@kbn/type-summarizer-core';
import { summarizePackage } from '@kbn/type-summarizer';

import { parseCliConfig, findRepoRoot } from './cli_config';

import { run } from './run';

const HELP = `
Script called from bazel to create the summarized version of a package. When called by Bazel
config is passed as a JSON encoded object. To build config locally you can just pass a path to
a package directory.

Usage:

  node scripts/type_summarizer <pathToPackageDir>

Flags:
  --dump         Create a debug directory that includes the source maps and the source files to stick
                  into https://sokra.github.io/source-map-visualization/
`;

run(
  async ({ argv, log }) => {
    const { packageName, outputDir, inputPath, repoRelativePackageDir, tsconfigPath } =
      parseCliConfig(argv);

    try {
      await Fsp.rm(outputDir, { recursive: true });
    } catch (error) {
      if (error && error.code !== 'ENOENT') {
        throw error;
      }
    }

    await Fsp.mkdir(outputDir, { recursive: true });

    // generate pkg json output
    await Fsp.writeFile(
      Path.join(outputDir, 'package.json'),
      JSON.stringify(
        {
          name: `@types/${packageName.replaceAll('@', '').replaceAll('/', '__')}`,
          description: 'Generated by @kbn/type-summarizer',
          types: './index.d.ts',
          private: true,
          license: 'MIT',
          version: '1.1.0',
        },
        null,
        2
      )
    );

    const sourceNode = await summarizePackage(log, {
      dtsDir: Path.dirname(inputPath),
      inputPath,
      tsconfigPath,
      repoRelativePackageDir,
    });

    const source = sourceNode.toStringWithSourceMap({
      file: 'index.d.ts',
      sourceRoot: `../../../${Path.toNormal(repoRelativePackageDir)}`,
    });

    const code = `${source.code}${
      source.code.endsWith('\n') ? '' : '\n'
    }//# sourceMappingURL=index.d.ts.map`;

    await Fsp.writeFile(Path.join(outputDir, 'index.d.ts'), code);
    await Fsp.writeFile(Path.join(outputDir, 'index.d.ts.map'), JSON.stringify(source.map));

    if (argv.includes('--dump')) {
      const dbg = Path.join(outputDir, '__debug__');
      await Fsp.mkdir(dbg);
      await Fsp.writeFile(Path.join(dbg, 'index.d.ts'), code);

      const map = source.map.toJSON();

      const sourceRoot = Path.join(findRepoRoot(), repoRelativePackageDir);
      map.sources = await Promise.all(
        map.sources.map(async (src) => {
          const name = src.split('/').join('_');
          const path = Path.join(dbg, name);
          await Fsp.writeFile(path, await Fsp.readFile(Path.join(sourceRoot, src), 'utf8'));
          return name;
        })
      );

      await Fsp.writeFile(
        Path.join(dbg, 'index.d.ts.map'),
        JSON.stringify({ ...map, sourceRoot: '.' })
      );
    }

    log.success('type summary created for', packageName);
  },
  {
    helpText: HELP,
    defaultLogLevel: 'quiet',
  }
);
