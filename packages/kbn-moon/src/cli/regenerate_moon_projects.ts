/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import path from 'path';
import fs from 'fs';

import yaml from 'js-yaml';

import merge from 'lodash/merge';

import { REPO_ROOT } from '@kbn/repo-info';
import { run } from '@kbn/dev-cli-runner';
import type { Package } from '@kbn/repo-packages';
import { getPackages } from '@kbn/repo-packages';
import type { ToolingLog } from '@kbn/tooling-log';

const EXTENSION_FILE_NAME = 'moon.extend.yml';
const MOON_CONFIG_FILE_NAME = 'moon.yml';

const getGeneratedPreambleForProject = (projectId: string) =>
  [
    '# This file is generated by the @kbn/moon package. Any manual edits will be erased!',
    `#  To extend this, write your extensions/overrides to '${EXTENSION_FILE_NAME}'`,
    `#  then regenerate this file with: 'node scripts/regenerate_moon_projects --update --filter ${projectId}'`,
  ].join('\n');

const readFile = (filePath: string) => fs.readFileSync(filePath, 'utf-8');
const writeYaml = (filePath: string, obj: any, preamble: string | null = null) => {
  let fileContent = yaml.dump(obj, {
    noRefs: true,
  });

  if (preamble) {
    fileContent = preamble + '\n\n' + fileContent;
  }

  if (fs.existsSync(filePath) && readFile(filePath) === fileContent) {
    return false;
  } else {
    fs.writeFileSync(filePath, fileContent);
    return true;
  }
};

function generateProjectConfig(projectConfigTemplate: string, pkg: Package, kibanaJsonc: any) {
  const projectConfig: any = yaml.load(projectConfigTemplate);
  projectConfig.id = pkg.name;
  projectConfig.type = 'unknown';

  const owner = Array.isArray(kibanaJsonc.owner) ? kibanaJsonc.owner[0] : kibanaJsonc.owner;

  projectConfig.owners = {
    defaultOwner: owner,
  };

  projectConfig.toolchain = {
    default: 'node',
  };

  projectConfig.project = {
    name: pkg.name,
    description: `Moon project for ${pkg.name}`,
    channel: '',
    owner,
    metadata: {
      // is not a moon config, but it's useful to have at hand
      sourceRoot: pkg.normalizedRepoRelativeDir,
    },
  };

  projectConfig.tags = [pkg.getGroup(), kibanaJsonc.type, kibanaJsonc.devOnly ? 'dev' : 'prod'];

  return projectConfig;
}

function updateFieldsFromTsConfig(
  projectConfig: any,
  {
    log,
    tsConfigPath,
    implicitDependencies,
    allPackageIds,
  }: {
    tsConfigPath: string;
    implicitDependencies: boolean;
    log: ToolingLog;
    allPackageIds: string[];
  }
) {
  log.verbose(`Reading tsconfig from ${tsConfigPath}`);

  // this is how we can read a JSON file that may contain comments
  // eslint-disable-next-line no-eval
  const tsConfig = eval('0,' + readFile(tsConfigPath));

  const rootRelativeTypings = path.join(
    path.relative(projectConfig.project.metadata.sourceRoot, REPO_ROOT),
    'typings'
  );

  const tsInclude = (tsConfig.include || []).map((e: string) => `${e}`);
  const tsExclude = (tsConfig.exclude || []).map((e: string) => `!${e}`);
  const src = tsInclude
    .concat(tsExclude)
    .map((e: string) => e.replace(/.*typings/, rootRelativeTypings))
    .filter((e: string) => !e.startsWith('..')); // in Moon, parent-relative file deps are not allowed
  projectConfig.fileGroups = {
    src,
  };

  const dependencies = tsConfig.kbn_references;
  if (implicitDependencies && dependencies) {
    // TODO: some dependencies are referenced as objects
    projectConfig.dependsOn = dependencies
      .filter((e: any) => typeof e === 'string')
      .filter((e: string) => allPackageIds.includes(e));
  }
}

async function updateProjectJestConfig(projectConfig: any, params: { log: ToolingLog }) {
  const { log } = params;

  const jestConfigName = findAny(projectConfig.project.metadata.sourceRoot, [
    'jest.config.js',
    'jest.config.cjs',
    'jest.config.json',
  ]);

  if (!jestConfigName) {
    log.warning(
      `Could not find jest config for ${projectConfig.name} @ ${projectConfig.project.metadata.sourceRoot}`
    );
  } else {
    projectConfig.tags = (projectConfig.tags || []).concat(['jest-unit-tests']);
    projectConfig.tasks.jest = {
      args: ['--config', `$projectRoot/${jestConfigName}`],
      inputs: ['@group(src)'],
    };
    projectConfig.tasks.jestCI = {
      args: ['--config', `$projectRoot/${jestConfigName}`],
      inputs: ['@group(src)'],
    };
  }
}

async function updateProjectLintConfig(
  projectConfig: any,
  params: { log: ToolingLog; eslintIgnore: string }
) {
  const { log, eslintIgnore } = params;
  if (eslintIgnore.split('\n').includes('/' + projectConfig.project.metadata.sourceRoot)) {
    log.info(
      `Skipping lint task for project ${projectConfig.name}. It's explicitly ignored in .eslintignore`
    );
    delete projectConfig.tasks.lint;
    return;
  }

  const eslintConfigName = findAny(projectConfig.project.metadata.sourceRoot, [
    '.eslintrc.js',
    '.eslintrc.json',
  ]);

  if (eslintConfigName) {
    projectConfig.tasks.lint = {
      // options: {
      //   eslintConfig: `{projectRoot}/${eslintConfigName}`,
      // },
    };
  } else {
    // go with the default, which is {workspaceRoot}/.eslintrc.js
  }
}

export function regenerateMoonProjects() {
  return run(
    async ({ log, flags }) => {
      const filter: string | string[] | undefined =
        (flags.filter as string | string[]) || undefined;
      const update = flags.update as boolean | undefined;
      const dryRun = flags['dry-run'] as boolean | undefined;
      const clear = flags.clear as boolean | undefined;

      const implicitDependencies = !!flags.dependencies;

      const template = readFile(path.resolve(__dirname, './moon.template.yml'));

      const allPackages: Package[] = getPackages(REPO_ROOT);

      const filteredPackages = filter ? filterPackages(allPackages, filter) : allPackages;

      const projectResults: Record<ProjectCreationResult, string[]> = {
        create: [],
        update: [],
        intact: [],
        delete: [],
        skip: [],
      };

      const eslintIgnore = readFile(path.resolve(REPO_ROOT, '.eslintignore'));

      const allPackageIds = filteredPackages.map((pkg) => pkg.name);

      for (const pkg of filteredPackages) {
        log.verbose(`Generating project configuration for ${pkg.name}`);
        const kibanaJsonc = readJsonc(path.resolve(pkg.normalizedRepoRelativeDir, 'kibana.jsonc'));
        const projectConfig = generateProjectConfig(template, pkg, kibanaJsonc);

        const tsConfigPath = path.resolve(pkg.normalizedRepoRelativeDir, 'tsconfig.json');
        if (fs.existsSync(tsConfigPath)) {
          updateFieldsFromTsConfig(projectConfig, {
            tsConfigPath,
            implicitDependencies,
            log,
            allPackageIds,
          });
        } else {
          projectConfig.language = 'javascript';
          log.warning(`Skipping ${pkg.name} - no tsconfig.json found.`);
        }

        await updateProjectJestConfig(projectConfig, {
          log,
        });

        await updateProjectLintConfig(projectConfig, {
          eslintIgnore,
          log,
        });

        updateProjectWithDevOverrides(projectConfig, {
          log,
          devOverridesPath: path.resolve(pkg.normalizedRepoRelativeDir, EXTENSION_FILE_NAME),
        });

        const targetPath = path.resolve(pkg.normalizedRepoRelativeDir, MOON_CONFIG_FILE_NAME);

        const result = createOrUpdateConfig(targetPath, projectConfig, {
          update,
          clear,
          dryRun,
          log,
        });
        projectResults[result].push(pkg.name);
      }

      log.success(
        [
          `ðŸŽ‰ Moon project configuration successful:`,
          ` ${projectResults.create.length} created`,
          ` ${projectResults.delete.length} deleted`,
          ` ${projectResults.update.length} updated`,
          ` ${projectResults.intact.length} already up to date`,
          ` ${projectResults.skip.length} exists (use --update to update)`,
        ].join('\n')
      );
    },
    {
      usage: `node ${path.relative(REPO_ROOT, process.argv[1])}`,
      description: `
        Generates Moon project configuration for a package/plugin from available hints around the package/plugin.
      `,
      flags: {
        string: ['filter'],
        boolean: ['dry-run', 'update', 'dependencies', 'clear'],
        default: {},
        alias: {},
        help: `
          --filter                    Filter packages by name or directory
          --update                    Update existing project configuration(s)
          --dependencies     Include dependsOn section in the project configuration
          --dry-run                   Do not write to disk
        `,
      },
    }
  );
}

type ProjectCreationResult = 'create' | 'update' | 'intact' | 'delete' | 'skip';
function createOrUpdateConfig(
  targetPath: string,
  projectConfig: any,
  {
    clear,
    update,
    dryRun,
    log,
  }: {
    clear?: boolean;
    update?: boolean;
    dryRun?: boolean;
    log: ToolingLog;
  }
): ProjectCreationResult {
  sortKeys(projectConfig);
  const name = projectConfig.id;
  const projectExists = fs.existsSync(targetPath);
  if (projectExists) {
    if (update) {
      if (dryRun) {
        log.info(`Would update ${name} project configuration.`);
      } else {
        const didUpdate = writeYaml(
          targetPath,
          projectConfig,
          getGeneratedPreambleForProject(projectConfig.id)
        );
        log.info(`Updated ${name} project configuration.`);
        if (!didUpdate) {
          return 'intact';
        }
      }
      return 'update';
    } else if (clear) {
      if (dryRun) {
        log.info(`Would clear ${name} project configuration.`);
      } else {
        log.info(`Deleting ${name} project configuration @ ${targetPath}`);
        fs.unlinkSync(targetPath);
      }
      return 'delete';
    } else {
      log.info(`'${MOON_CONFIG_FILE_NAME}' already exists at ${targetPath} - skipping creation.`);
      return 'skip';
    }
  } else if (!clear) {
    if (dryRun) {
      log.info(`Would create ${name} project configuration.`);
    } else {
      log.info(`Creating ${name} project configuration @ ${targetPath}`);
      writeYaml(targetPath, projectConfig, getGeneratedPreambleForProject(projectConfig.id));
    }
    return 'create';
  } else {
    return 'intact';
  }
}

function filterPackages(allPackages: Package[], filter: string | string[]): Package[] {
  return allPackages.filter((pkg) => {
    if (!filter) {
      return true;
    }

    if (typeof filter === 'string') {
      return pkg.name.includes(filter) || pkg.normalizedRepoRelativeDir.includes(filter);
    }

    if (Array.isArray(filter)) {
      return filter.some((f) => pkg.name.includes(f) || pkg.normalizedRepoRelativeDir.includes(f));
    }
    return false;
  });
}

function findAny(dir: string, files: string[]) {
  return files.find((f) => fs.existsSync(path.resolve(dir, f)));
}

function readJsonc(filePath: string) {
  let fileCleaned;
  try {
    const file = readFile(filePath);
    fileCleaned = file
      .split('\n')
      .filter((l) => !l.match(/^\s*\/\//))
      .map((l) => l.replace(/\/\/.*/g, ''))
      .join('')
      .replace(/(\s)*/g, '')
      .replace(/,([}\]])/g, '$1');
    return JSON.parse(fileCleaned);
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error(`Failed to read ${filePath}: `, fileCleaned);
    throw e;
  }
}

const KEY_PRIORITY = [
  '$schema',
  'id',
  'type',
  'owners',
  'toolchain',
  '*', // everything else
  'tags',
  'fileGroups',
  'tasks',
];

function sortKeys(obj: any) {
  const kvPairs = Object.entries(obj);
  kvPairs.sort(([a], [b]) => {
    const aIdx =
      KEY_PRIORITY.indexOf(a) === -1 ? KEY_PRIORITY.indexOf('*') : KEY_PRIORITY.indexOf(a);
    const bIdx =
      KEY_PRIORITY.indexOf(b) === -1 ? KEY_PRIORITY.indexOf('*') : KEY_PRIORITY.indexOf(b);
    return aIdx - bIdx;
  });
  for (const [k] of kvPairs) {
    delete obj[k];
  }
  for (const [k, v] of kvPairs) {
    obj[k] = v;
  }
}

if (module.parent === null) {
  regenerateMoonProjects();
}

function updateProjectWithDevOverrides(
  projectConfig: any,
  { log, devOverridesPath }: { log: ToolingLog; devOverridesPath: string }
) {
  if (fs.existsSync(devOverridesPath)) {
    log.info(`Applying development overrides from ${path.relative(REPO_ROOT, devOverridesPath)}`);
    try {
      const devOverrides = yaml.load(readFile(devOverridesPath));
      merge(projectConfig, devOverrides);
    } catch (e) {
      log.error(
        `Failed to apply development overrides from ${path.relative(
          REPO_ROOT,
          devOverridesPath
        )}: ${e.message}`
      );
      throw e;
    }
  }
}
