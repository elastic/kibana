/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import { CharStreams, type Token } from 'antlr4';
import { CommonTokenStream, type CharStream, type ErrorListener } from 'antlr4';
import { ESQLErrorListener } from './esql_error_listener';
import { ESQLAstBuilderListener } from './esql_ast_builder_listener';
import { GRAMMAR_ROOT_RULE } from './constants';
import { attachDecorations, collectDecorations } from './formatting';
import type { ESQLAst, ESQLAstQueryExpression, EditorError } from '../types';
import { Builder } from '../builder';
import { default as ESQLLexer } from '../antlr/esql_lexer';
import { default as ESQLParser } from '../antlr/esql_parser';
import { default as ESQLParserListener } from '../antlr/esql_parser_listener';

export const getLexer = (inputStream: CharStream, errorListener: ErrorListener<any>) => {
  const lexer = new ESQLLexer(inputStream);

  lexer.removeErrorListeners();
  lexer.addErrorListener(errorListener);

  return lexer;
};

export const getParser = (
  inputStream: CharStream,
  errorListener: ErrorListener<any>,
  parseListener?: ESQLParserListener
) => {
  const lexer = getLexer(inputStream, errorListener);
  const tokens = new CommonTokenStream(lexer);
  const parser = new ESQLParser(tokens);

  // lexer.symbolicNames

  parser.removeErrorListeners();
  parser.addErrorListener(errorListener);

  if (parseListener) {
    // @ts-expect-error the addParseListener API does exist and is documented here
    // https://github.com/antlr/antlr4/blob/dev/doc/listeners.md
    parser.addParseListener(parseListener);
  }

  return {
    lexer,
    tokens,
    parser,
  };
};

export const createParser = (text: string) => {
  const errorListener = new ESQLErrorListener();
  const parseListener = new ESQLAstBuilderListener();

  return getParser(CharStreams.fromString(text), errorListener, parseListener);
};

// These will need to be manually updated whenever the relevant grammar changes.
const SYNTAX_ERRORS_TO_IGNORE = [
  `SyntaxError: mismatched input '<EOF>' expecting {'explain', 'from', 'meta', 'row', 'show'}`,
];

export interface ParseOptions {
  /**
   * Whether to collect and attach to AST nodes user's custom formatting:
   * comments and whitespace.
   */
  withFormatting?: boolean;
}

export interface ParseResult {
  /**
   * The root *QueryExpression* node of the parsed tree.
   */
  root: ESQLAstQueryExpression;

  /**
   * List of parsed commands.
   *
   * @deprecated Use `root` instead.
   */
  ast: ESQLAst;

  /**
   * List of ANTLR tokens generated by the lexer.
   */
  tokens: Token[];

  /**
   * List of parsing errors.
   */
  errors: EditorError[];
}

export const parse = (text: string | undefined, options: ParseOptions = {}): ParseResult => {
  if (text == null) {
    const commands: ESQLAstQueryExpression['commands'] = [];
    return { ast: commands, root: Builder.expression.query(commands), errors: [], tokens: [] };
  }
  const errorListener = new ESQLErrorListener();
  const parseListener = new ESQLAstBuilderListener();
  const { tokens, parser } = getParser(CharStreams.fromString(text), errorListener, parseListener);

  parser[GRAMMAR_ROOT_RULE]();

  const errors = errorListener.getErrors().filter((error) => {
    return !SYNTAX_ERRORS_TO_IGNORE.includes(error.message);
  });
  const { ast: commands } = parseListener.getAst();
  const root = Builder.expression.query(commands, {
    location: {
      min: 0,
      max: text.length - 1,
    },
  });

  if (options.withFormatting) {
    const decorations = collectDecorations(tokens);
    attachDecorations(root, tokens.tokens, decorations.lines);
  }

  return { root, ast: commands, errors, tokens: tokens.tokens };
};

export const parseErrors = (text: string) => {
  const errorListener = new ESQLErrorListener();
  const { parser } = getParser(CharStreams.fromString(text), errorListener);

  parser[GRAMMAR_ROOT_RULE]();

  return errorListener.getErrors();
};
