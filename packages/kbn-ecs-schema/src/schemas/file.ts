/*
* Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
* or more contributor license agreements. Licensed under the Elastic License
* 2.0 and the Server Side Public License, v 1; you may not use this file except
* in compliance with, at your election, the Elastic License 2.0 or the Server
* Side Public License, v 1.
*/

/* eslint-disable */
export const fileEcs = {
  accessed: {
    dashed_name: 'file-accessed',
    description: 'Last time the file was accessed.\n' +
      'Note that not all filesystems keep track of access time.',
    flat_name: 'file.accessed',
    level: 'extended',
    name: 'accessed',
    normalize: [],
    short: 'Last time the file was accessed.',
    type: 'date'
  },
  attributes: {
    dashed_name: 'file-attributes',
    description: 'Array of file attributes.\n' +
      "Attributes names will vary by platform. Here's a non-exhaustive list of values that are expected in this field: archive, compressed, directory, encrypted, execute, hidden, read, readonly, system, write.",
    example: '["readonly", "system"]',
    flat_name: 'file.attributes',
    ignore_above: 1024,
    level: 'extended',
    name: 'attributes',
    normalize: [ 'array' ],
    short: 'Array of file attributes.',
    type: 'keyword'
  },
  code_signature: {
    digest_algorithm: {
      dashed_name: 'file-code-signature-digest-algorithm',
      description: 'The hashing algorithm used to sign the process.\n' +
        'This value can distinguish signatures when a file is signed multiple times by the same signer but with a different digest algorithm.',
      example: 'sha256',
      flat_name: 'file.code_signature.digest_algorithm',
      ignore_above: 1024,
      level: 'extended',
      name: 'digest_algorithm',
      normalize: [],
      original_fieldset: 'code_signature',
      short: 'Hashing algorithm used to sign the process.',
      type: 'keyword'
    },
    exists: {
      dashed_name: 'file-code-signature-exists',
      description: 'Boolean to capture if a signature is present.',
      example: 'true',
      flat_name: 'file.code_signature.exists',
      level: 'core',
      name: 'exists',
      normalize: [],
      original_fieldset: 'code_signature',
      short: 'Boolean to capture if a signature is present.',
      type: 'boolean'
    },
    signing_id: {
      dashed_name: 'file-code-signature-signing-id',
      description: 'The identifier used to sign the process.\n' +
        'This is used to identify the application manufactured by a software vendor. The field is relevant to Apple *OS only.',
      example: 'com.apple.xpc.proxy',
      flat_name: 'file.code_signature.signing_id',
      ignore_above: 1024,
      level: 'extended',
      name: 'signing_id',
      normalize: [],
      original_fieldset: 'code_signature',
      short: 'The identifier used to sign the process.',
      type: 'keyword'
    },
    status: {
      dashed_name: 'file-code-signature-status',
      description: 'Additional information about the certificate status.\n' +
        'This is useful for logging cryptographic errors with the certificate validity or trust status. Leave unpopulated if the validity or trust of the certificate was unchecked.',
      example: 'ERROR_UNTRUSTED_ROOT',
      flat_name: 'file.code_signature.status',
      ignore_above: 1024,
      level: 'extended',
      name: 'status',
      normalize: [],
      original_fieldset: 'code_signature',
      short: 'Additional information about the certificate status.',
      type: 'keyword'
    },
    subject_name: {
      dashed_name: 'file-code-signature-subject-name',
      description: 'Subject name of the code signer',
      example: 'Microsoft Corporation',
      flat_name: 'file.code_signature.subject_name',
      ignore_above: 1024,
      level: 'core',
      name: 'subject_name',
      normalize: [],
      original_fieldset: 'code_signature',
      short: 'Subject name of the code signer',
      type: 'keyword'
    },
    team_id: {
      dashed_name: 'file-code-signature-team-id',
      description: 'The team identifier used to sign the process.\n' +
        'This is used to identify the team or vendor of a software product. The field is relevant to Apple *OS only.',
      example: 'EQHXZ8M8AV',
      flat_name: 'file.code_signature.team_id',
      ignore_above: 1024,
      level: 'extended',
      name: 'team_id',
      normalize: [],
      original_fieldset: 'code_signature',
      short: 'The team identifier used to sign the process.',
      type: 'keyword'
    },
    timestamp: {
      dashed_name: 'file-code-signature-timestamp',
      description: 'Date and time when the code signature was generated and signed.',
      example: '2021-01-01T12:10:30Z',
      flat_name: 'file.code_signature.timestamp',
      level: 'extended',
      name: 'timestamp',
      normalize: [],
      original_fieldset: 'code_signature',
      short: 'When the signature was generated and signed.',
      type: 'date'
    },
    trusted: {
      dashed_name: 'file-code-signature-trusted',
      description: 'Stores the trust status of the certificate chain.\n' +
        'Validating the trust of the certificate chain may be complicated, and this field should only be populated by tools that actively check the status.',
      example: 'true',
      flat_name: 'file.code_signature.trusted',
      level: 'extended',
      name: 'trusted',
      normalize: [],
      original_fieldset: 'code_signature',
      short: 'Stores the trust status of the certificate chain.',
      type: 'boolean'
    },
    valid: {
      dashed_name: 'file-code-signature-valid',
      description: 'Boolean to capture if the digital signature is verified against the binary content.\n' +
        'Leave unpopulated if a certificate was unchecked.',
      example: 'true',
      flat_name: 'file.code_signature.valid',
      level: 'extended',
      name: 'valid',
      normalize: [],
      original_fieldset: 'code_signature',
      short: 'Boolean to capture if the digital signature is verified against the binary content.',
      type: 'boolean'
    }
  },
  created: {
    dashed_name: 'file-created',
    description: 'File creation time.\n' +
      'Note that not all filesystems store the creation time.',
    flat_name: 'file.created',
    level: 'extended',
    name: 'created',
    normalize: [],
    short: 'File creation time.',
    type: 'date'
  },
  ctime: {
    dashed_name: 'file-ctime',
    description: 'Last time the file attributes or metadata changed.\n' +
      'Note that changes to the file content will update `mtime`. This implies `ctime` will be adjusted at the same time, since `mtime` is an attribute of the file.',
    flat_name: 'file.ctime',
    level: 'extended',
    name: 'ctime',
    normalize: [],
    short: 'Last time the file attributes or metadata changed.',
    type: 'date'
  },
  device: {
    dashed_name: 'file-device',
    description: 'Device that is the source of the file.',
    example: 'sda',
    flat_name: 'file.device',
    ignore_above: 1024,
    level: 'extended',
    name: 'device',
    normalize: [],
    short: 'Device that is the source of the file.',
    type: 'keyword'
  },
  directory: {
    dashed_name: 'file-directory',
    description: 'Directory where the file is located. It should include the drive letter, when appropriate.',
    example: '/home/alice',
    flat_name: 'file.directory',
    ignore_above: 1024,
    level: 'extended',
    name: 'directory',
    normalize: [],
    short: 'Directory where the file is located.',
    type: 'keyword'
  },
  drive_letter: {
    dashed_name: 'file-drive-letter',
    description: 'Drive letter where the file is located. This field is only relevant on Windows.\n' +
      'The value should be uppercase, and not include the colon.',
    example: 'C',
    flat_name: 'file.drive_letter',
    ignore_above: 1,
    level: 'extended',
    name: 'drive_letter',
    normalize: [],
    short: 'Drive letter where the file is located.',
    type: 'keyword'
  },
  elf: {
    architecture: {
      dashed_name: 'file-elf-architecture',
      description: 'Machine architecture of the ELF file.',
      example: 'x86-64',
      flat_name: 'file.elf.architecture',
      ignore_above: 1024,
      level: 'extended',
      name: 'architecture',
      normalize: [],
      original_fieldset: 'elf',
      short: 'Machine architecture of the ELF file.',
      type: 'keyword'
    },
    byte_order: {
      dashed_name: 'file-elf-byte-order',
      description: 'Byte sequence of ELF file.',
      example: 'Little Endian',
      flat_name: 'file.elf.byte_order',
      ignore_above: 1024,
      level: 'extended',
      name: 'byte_order',
      normalize: [],
      original_fieldset: 'elf',
      short: 'Byte sequence of ELF file.',
      type: 'keyword'
    },
    cpu_type: {
      dashed_name: 'file-elf-cpu-type',
      description: 'CPU type of the ELF file.',
      example: 'Intel',
      flat_name: 'file.elf.cpu_type',
      ignore_above: 1024,
      level: 'extended',
      name: 'cpu_type',
      normalize: [],
      original_fieldset: 'elf',
      short: 'CPU type of the ELF file.',
      type: 'keyword'
    },
    creation_date: {
      dashed_name: 'file-elf-creation-date',
      description: "Extracted when possible from the file's metadata. Indicates when it was built or compiled. It can also be faked by malware creators.",
      flat_name: 'file.elf.creation_date',
      level: 'extended',
      name: 'creation_date',
      normalize: [],
      original_fieldset: 'elf',
      short: 'Build or compile date.',
      type: 'date'
    },
    exports: {
      dashed_name: 'file-elf-exports',
      description: 'List of exported element names and types.',
      flat_name: 'file.elf.exports',
      level: 'extended',
      name: 'exports',
      normalize: [ 'array' ],
      original_fieldset: 'elf',
      short: 'List of exported element names and types.',
      type: 'flattened'
    },
    header: {
      abi_version: {
        dashed_name: 'file-elf-header-abi-version',
        description: 'Version of the ELF Application Binary Interface (ABI).',
        flat_name: 'file.elf.header.abi_version',
        ignore_above: 1024,
        level: 'extended',
        name: 'header.abi_version',
        normalize: [],
        original_fieldset: 'elf',
        short: 'Version of the ELF Application Binary Interface (ABI).',
        type: 'keyword'
      },
      class: {
        dashed_name: 'file-elf-header-class',
        description: 'Header class of the ELF file.',
        flat_name: 'file.elf.header.class',
        ignore_above: 1024,
        level: 'extended',
        name: 'header.class',
        normalize: [],
        original_fieldset: 'elf',
        short: 'Header class of the ELF file.',
        type: 'keyword'
      },
      data: {
        dashed_name: 'file-elf-header-data',
        description: 'Data table of the ELF header.',
        flat_name: 'file.elf.header.data',
        ignore_above: 1024,
        level: 'extended',
        name: 'header.data',
        normalize: [],
        original_fieldset: 'elf',
        short: 'Data table of the ELF header.',
        type: 'keyword'
      },
      entrypoint: {
        dashed_name: 'file-elf-header-entrypoint',
        description: 'Header entrypoint of the ELF file.',
        flat_name: 'file.elf.header.entrypoint',
        format: 'string',
        level: 'extended',
        name: 'header.entrypoint',
        normalize: [],
        original_fieldset: 'elf',
        short: 'Header entrypoint of the ELF file.',
        type: 'long'
      },
      object_version: {
        dashed_name: 'file-elf-header-object-version',
        description: '"0x1" for original ELF files.',
        flat_name: 'file.elf.header.object_version',
        ignore_above: 1024,
        level: 'extended',
        name: 'header.object_version',
        normalize: [],
        original_fieldset: 'elf',
        short: '"0x1" for original ELF files.',
        type: 'keyword'
      },
      os_abi: {
        dashed_name: 'file-elf-header-os-abi',
        description: 'Application Binary Interface (ABI) of the Linux OS.',
        flat_name: 'file.elf.header.os_abi',
        ignore_above: 1024,
        level: 'extended',
        name: 'header.os_abi',
        normalize: [],
        original_fieldset: 'elf',
        short: 'Application Binary Interface (ABI) of the Linux OS.',
        type: 'keyword'
      },
      type: {
        dashed_name: 'file-elf-header-type',
        description: 'Header type of the ELF file.',
        flat_name: 'file.elf.header.type',
        ignore_above: 1024,
        level: 'extended',
        name: 'header.type',
        normalize: [],
        original_fieldset: 'elf',
        short: 'Header type of the ELF file.',
        type: 'keyword'
      },
      version: {
        dashed_name: 'file-elf-header-version',
        description: 'Version of the ELF header.',
        flat_name: 'file.elf.header.version',
        ignore_above: 1024,
        level: 'extended',
        name: 'header.version',
        normalize: [],
        original_fieldset: 'elf',
        short: 'Version of the ELF header.',
        type: 'keyword'
      }
    },
    imports: {
      dashed_name: 'file-elf-imports',
      description: 'List of imported element names and types.',
      flat_name: 'file.elf.imports',
      level: 'extended',
      name: 'imports',
      normalize: [ 'array' ],
      original_fieldset: 'elf',
      short: 'List of imported element names and types.',
      type: 'flattened'
    },
    sections: {
      dashed_name: 'file-elf-sections',
      description: 'An array containing an object for each section of the ELF file.\n' +
        'The keys that should be present in these objects are defined by sub-fields underneath `elf.sections.*`.',
      flat_name: 'file.elf.sections',
      level: 'extended',
      name: {
        dashed_name: 'file-elf-sections-name',
        description: 'ELF Section List name.',
        flat_name: 'file.elf.sections.name',
        ignore_above: 1024,
        level: 'extended',
        name: 'sections.name',
        normalize: [],
        original_fieldset: 'elf',
        short: 'ELF Section List name.',
        type: 'keyword'
      },
      normalize: [ 'array' ],
      original_fieldset: 'elf',
      short: 'Section information of the ELF file.',
      type: {
        dashed_name: 'file-elf-sections-type',
        description: 'ELF Section List type.',
        flat_name: 'file.elf.sections.type',
        ignore_above: 1024,
        level: 'extended',
        name: 'sections.type',
        normalize: [],
        original_fieldset: 'elf',
        short: 'ELF Section List type.',
        type: 'keyword'
      },
      chi2: {
        dashed_name: 'file-elf-sections-chi2',
        description: 'Chi-square probability distribution of the section.',
        flat_name: 'file.elf.sections.chi2',
        format: 'number',
        level: 'extended',
        name: 'sections.chi2',
        normalize: [],
        original_fieldset: 'elf',
        short: 'Chi-square probability distribution of the section.',
        type: 'long'
      },
      entropy: {
        dashed_name: 'file-elf-sections-entropy',
        description: 'Shannon entropy calculation from the section.',
        flat_name: 'file.elf.sections.entropy',
        format: 'number',
        level: 'extended',
        name: 'sections.entropy',
        normalize: [],
        original_fieldset: 'elf',
        short: 'Shannon entropy calculation from the section.',
        type: 'long'
      },
      flags: {
        dashed_name: 'file-elf-sections-flags',
        description: 'ELF Section List flags.',
        flat_name: 'file.elf.sections.flags',
        ignore_above: 1024,
        level: 'extended',
        name: 'sections.flags',
        normalize: [],
        original_fieldset: 'elf',
        short: 'ELF Section List flags.',
        type: 'keyword'
      },
      physical_offset: {
        dashed_name: 'file-elf-sections-physical-offset',
        description: 'ELF Section List offset.',
        flat_name: 'file.elf.sections.physical_offset',
        ignore_above: 1024,
        level: 'extended',
        name: 'sections.physical_offset',
        normalize: [],
        original_fieldset: 'elf',
        short: 'ELF Section List offset.',
        type: 'keyword'
      },
      physical_size: {
        dashed_name: 'file-elf-sections-physical-size',
        description: 'ELF Section List physical size.',
        flat_name: 'file.elf.sections.physical_size',
        format: 'bytes',
        level: 'extended',
        name: 'sections.physical_size',
        normalize: [],
        original_fieldset: 'elf',
        short: 'ELF Section List physical size.',
        type: 'long'
      },
      virtual_address: {
        dashed_name: 'file-elf-sections-virtual-address',
        description: 'ELF Section List virtual address.',
        flat_name: 'file.elf.sections.virtual_address',
        format: 'string',
        level: 'extended',
        name: 'sections.virtual_address',
        normalize: [],
        original_fieldset: 'elf',
        short: 'ELF Section List virtual address.',
        type: 'long'
      },
      virtual_size: {
        dashed_name: 'file-elf-sections-virtual-size',
        description: 'ELF Section List virtual size.',
        flat_name: 'file.elf.sections.virtual_size',
        format: 'string',
        level: 'extended',
        name: 'sections.virtual_size',
        normalize: [],
        original_fieldset: 'elf',
        short: 'ELF Section List virtual size.',
        type: 'long'
      }
    },
    segments: {
      dashed_name: 'file-elf-segments',
      description: 'An array containing an object for each segment of the ELF file.\n' +
        'The keys that should be present in these objects are defined by sub-fields underneath `elf.segments.*`.',
      flat_name: 'file.elf.segments',
      level: 'extended',
      name: 'segments',
      normalize: [ 'array' ],
      original_fieldset: 'elf',
      short: 'ELF object segment list.',
      type: {
        dashed_name: 'file-elf-segments-type',
        description: 'ELF object segment type.',
        flat_name: 'file.elf.segments.type',
        ignore_above: 1024,
        level: 'extended',
        name: 'segments.type',
        normalize: [],
        original_fieldset: 'elf',
        short: 'ELF object segment type.',
        type: 'keyword'
      },
      sections: {
        dashed_name: 'file-elf-segments-sections',
        description: 'ELF object segment sections.',
        flat_name: 'file.elf.segments.sections',
        ignore_above: 1024,
        level: 'extended',
        name: 'segments.sections',
        normalize: [],
        original_fieldset: 'elf',
        short: 'ELF object segment sections.',
        type: 'keyword'
      }
    },
    shared_libraries: {
      dashed_name: 'file-elf-shared-libraries',
      description: 'List of shared libraries used by this ELF object.',
      flat_name: 'file.elf.shared_libraries',
      ignore_above: 1024,
      level: 'extended',
      name: 'shared_libraries',
      normalize: [ 'array' ],
      original_fieldset: 'elf',
      short: 'List of shared libraries used by this ELF object.',
      type: 'keyword'
    },
    telfhash: {
      dashed_name: 'file-elf-telfhash',
      description: 'telfhash symbol hash for ELF file.',
      flat_name: 'file.elf.telfhash',
      ignore_above: 1024,
      level: 'extended',
      name: 'telfhash',
      normalize: [],
      original_fieldset: 'elf',
      short: 'telfhash hash for ELF file.',
      type: 'keyword'
    }
  },
  extension: {
    dashed_name: 'file-extension',
    description: 'File extension, excluding the leading dot.\n' +
      'Note that when the file name has multiple extensions (example.tar.gz), only the last one should be captured ("gz", not "tar.gz").',
    example: 'png',
    flat_name: 'file.extension',
    ignore_above: 1024,
    level: 'extended',
    name: 'extension',
    normalize: [],
    short: 'File extension, excluding the leading dot.',
    type: 'keyword'
  },
  fork_name: {
    dashed_name: 'file-fork-name',
    description: 'A fork is additional data associated with a filesystem object.\n' +
      'On Linux, a resource fork is used to store additional data with a filesystem object. A file always has at least one fork for the data portion, and additional forks may exist.\n' +
      'On NTFS, this is analogous to an Alternate Data Stream (ADS), and the default data stream for a file is just called $DATA. Zone.Identifier is commonly used by Windows to track contents downloaded from the Internet. An ADS is typically of the form: `C:\\path\\to\\filename.extension:some_fork_name`, and `some_fork_name` is the value that should populate `fork_name`. `filename.extension` should populate `file.name`, and `extension` should populate `file.extension`. The full path, `file.path`, will include the fork name.',
    example: 'Zone.Identifer',
    flat_name: 'file.fork_name',
    ignore_above: 1024,
    level: 'extended',
    name: 'fork_name',
    normalize: [],
    short: 'A fork is additional data associated with a filesystem object.',
    type: 'keyword'
  },
  gid: {
    dashed_name: 'file-gid',
    description: 'Primary group ID (GID) of the file.',
    example: '1001',
    flat_name: 'file.gid',
    ignore_above: 1024,
    level: 'extended',
    name: 'gid',
    normalize: [],
    short: 'Primary group ID (GID) of the file.',
    type: 'keyword'
  },
  group: {
    dashed_name: 'file-group',
    description: 'Primary group name of the file.',
    example: 'alice',
    flat_name: 'file.group',
    ignore_above: 1024,
    level: 'extended',
    name: 'group',
    normalize: [],
    short: 'Primary group name of the file.',
    type: 'keyword'
  },
  hash: {
    md5: {
      dashed_name: 'file-hash-md5',
      description: 'MD5 hash.',
      flat_name: 'file.hash.md5',
      ignore_above: 1024,
      level: 'extended',
      name: 'md5',
      normalize: [],
      original_fieldset: 'hash',
      short: 'MD5 hash.',
      type: 'keyword'
    },
    sha1: {
      dashed_name: 'file-hash-sha1',
      description: 'SHA1 hash.',
      flat_name: 'file.hash.sha1',
      ignore_above: 1024,
      level: 'extended',
      name: 'sha1',
      normalize: [],
      original_fieldset: 'hash',
      short: 'SHA1 hash.',
      type: 'keyword'
    },
    sha256: {
      dashed_name: 'file-hash-sha256',
      description: 'SHA256 hash.',
      flat_name: 'file.hash.sha256',
      ignore_above: 1024,
      level: 'extended',
      name: 'sha256',
      normalize: [],
      original_fieldset: 'hash',
      short: 'SHA256 hash.',
      type: 'keyword'
    },
    sha384: {
      dashed_name: 'file-hash-sha384',
      description: 'SHA384 hash.',
      flat_name: 'file.hash.sha384',
      ignore_above: 1024,
      level: 'extended',
      name: 'sha384',
      normalize: [],
      original_fieldset: 'hash',
      short: 'SHA384 hash.',
      type: 'keyword'
    },
    sha512: {
      dashed_name: 'file-hash-sha512',
      description: 'SHA512 hash.',
      flat_name: 'file.hash.sha512',
      ignore_above: 1024,
      level: 'extended',
      name: 'sha512',
      normalize: [],
      original_fieldset: 'hash',
      short: 'SHA512 hash.',
      type: 'keyword'
    },
    ssdeep: {
      dashed_name: 'file-hash-ssdeep',
      description: 'SSDEEP hash.',
      flat_name: 'file.hash.ssdeep',
      ignore_above: 1024,
      level: 'extended',
      name: 'ssdeep',
      normalize: [],
      original_fieldset: 'hash',
      short: 'SSDEEP hash.',
      type: 'keyword'
    },
    tlsh: {
      dashed_name: 'file-hash-tlsh',
      description: 'TLSH hash.',
      flat_name: 'file.hash.tlsh',
      ignore_above: 1024,
      level: 'extended',
      name: 'tlsh',
      normalize: [],
      original_fieldset: 'hash',
      short: 'TLSH hash.',
      type: 'keyword'
    }
  },
  inode: {
    dashed_name: 'file-inode',
    description: 'Inode representing the file in the filesystem.',
    example: '256383',
    flat_name: 'file.inode',
    ignore_above: 1024,
    level: 'extended',
    name: 'inode',
    normalize: [],
    short: 'Inode representing the file in the filesystem.',
    type: 'keyword'
  },
  mime_type: {
    dashed_name: 'file-mime-type',
    description: 'MIME type should identify the format of the file or stream of bytes using https://www.iana.org/assignments/media-types/media-types.xhtml[IANA official types], where possible. When more than one type is applicable, the most specific type should be used.',
    flat_name: 'file.mime_type',
    ignore_above: 1024,
    level: 'extended',
    name: 'mime_type',
    normalize: [],
    short: 'Media type of file, document, or arrangement of bytes.',
    type: 'keyword'
  },
  mode: {
    dashed_name: 'file-mode',
    description: 'Mode of the file in octal representation.',
    example: '0640',
    flat_name: 'file.mode',
    ignore_above: 1024,
    level: 'extended',
    name: 'mode',
    normalize: [],
    short: 'Mode of the file in octal representation.',
    type: 'keyword'
  },
  mtime: {
    dashed_name: 'file-mtime',
    description: 'Last time the file content was modified.',
    flat_name: 'file.mtime',
    level: 'extended',
    name: 'mtime',
    normalize: [],
    short: 'Last time the file content was modified.',
    type: 'date'
  },
  name: {
    dashed_name: 'file-name',
    description: 'Name of the file including the extension, without the directory.',
    example: 'example.png',
    flat_name: 'file.name',
    ignore_above: 1024,
    level: 'extended',
    name: 'name',
    normalize: [],
    short: 'Name of the file including the extension, without the directory.',
    type: 'keyword'
  },
  owner: {
    dashed_name: 'file-owner',
    description: "File owner's username.",
    example: 'alice',
    flat_name: 'file.owner',
    ignore_above: 1024,
    level: 'extended',
    name: 'owner',
    normalize: [],
    short: "File owner's username.",
    type: 'keyword'
  },
  path: {
    dashed_name: 'file-path',
    description: 'Full path to the file, including the file name. It should include the drive letter, when appropriate.',
    example: '/home/alice/example.png',
    flat_name: 'file.path',
    ignore_above: 1024,
    level: 'extended',
    multi_fields: [
      {
        flat_name: 'file.path.text',
        name: 'text',
        type: 'match_only_text'
      }
    ],
    name: 'path',
    normalize: [],
    short: 'Full path to the file, including the file name.',
    type: 'keyword'
  },
  pe: {
    architecture: {
      dashed_name: 'file-pe-architecture',
      description: 'CPU architecture target for the file.',
      example: 'x64',
      flat_name: 'file.pe.architecture',
      ignore_above: 1024,
      level: 'extended',
      name: 'architecture',
      normalize: [],
      original_fieldset: 'pe',
      short: 'CPU architecture target for the file.',
      type: 'keyword'
    },
    company: {
      dashed_name: 'file-pe-company',
      description: 'Internal company name of the file, provided at compile-time.',
      example: 'Microsoft Corporation',
      flat_name: 'file.pe.company',
      ignore_above: 1024,
      level: 'extended',
      name: 'company',
      normalize: [],
      original_fieldset: 'pe',
      short: 'Internal company name of the file, provided at compile-time.',
      type: 'keyword'
    },
    description: {
      dashed_name: 'file-pe-description',
      description: 'Internal description of the file, provided at compile-time.',
      example: 'Paint',
      flat_name: 'file.pe.description',
      ignore_above: 1024,
      level: 'extended',
      name: 'description',
      normalize: [],
      original_fieldset: 'pe',
      short: 'Internal description of the file, provided at compile-time.',
      type: 'keyword'
    },
    file_version: {
      dashed_name: 'file-pe-file-version',
      description: 'Internal version of the file, provided at compile-time.',
      example: '6.3.9600.17415',
      flat_name: 'file.pe.file_version',
      ignore_above: 1024,
      level: 'extended',
      name: 'file_version',
      normalize: [],
      original_fieldset: 'pe',
      short: 'Process name.',
      type: 'keyword'
    },
    imphash: {
      dashed_name: 'file-pe-imphash',
      description: 'A hash of the imports in a PE file. An imphash -- or import hash -- can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\n' +
        'Learn more at https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html.',
      example: '0c6803c4e922103c4dca5963aad36ddf',
      flat_name: 'file.pe.imphash',
      ignore_above: 1024,
      level: 'extended',
      name: 'imphash',
      normalize: [],
      original_fieldset: 'pe',
      short: 'A hash of the imports in a PE file.',
      type: 'keyword'
    },
    original_file_name: {
      dashed_name: 'file-pe-original-file-name',
      description: 'Internal name of the file, provided at compile-time.',
      example: 'MSPAINT.EXE',
      flat_name: 'file.pe.original_file_name',
      ignore_above: 1024,
      level: 'extended',
      name: 'original_file_name',
      normalize: [],
      original_fieldset: 'pe',
      short: 'Internal name of the file, provided at compile-time.',
      type: 'keyword'
    },
    pehash: {
      dashed_name: 'file-pe-pehash',
      description: 'A hash of the PE header and data from one or more PE sections. An pehash can be used to cluster files by transforming structural information about a file into a hash value.\n' +
        'Learn more at https://www.usenix.org/legacy/events/leet09/tech/full_papers/wicherski/wicherski_html/index.html.',
      example: '73ff189b63cd6be375a7ff25179a38d347651975',
      flat_name: 'file.pe.pehash',
      ignore_above: 1024,
      level: 'extended',
      name: 'pehash',
      normalize: [],
      original_fieldset: 'pe',
      short: 'A hash of the PE header and data from one or more PE sections.',
      type: 'keyword'
    },
    product: {
      dashed_name: 'file-pe-product',
      description: 'Internal product name of the file, provided at compile-time.',
      example: 'Microsoft® Windows® Operating System',
      flat_name: 'file.pe.product',
      ignore_above: 1024,
      level: 'extended',
      name: 'product',
      normalize: [],
      original_fieldset: 'pe',
      short: 'Internal product name of the file, provided at compile-time.',
      type: 'keyword'
    }
  },
  size: {
    dashed_name: 'file-size',
    description: 'File size in bytes.\nOnly relevant when `file.type` is "file".',
    example: 16384,
    flat_name: 'file.size',
    level: 'extended',
    name: 'size',
    normalize: [],
    short: 'File size in bytes.',
    type: 'long'
  },
  target_path: {
    dashed_name: 'file-target-path',
    description: 'Target path for symlinks.',
    flat_name: 'file.target_path',
    ignore_above: 1024,
    level: 'extended',
    multi_fields: [
      {
        flat_name: 'file.target_path.text',
        name: 'text',
        type: 'match_only_text'
      }
    ],
    name: 'target_path',
    normalize: [],
    short: 'Target path for symlinks.',
    type: 'keyword'
  },
  type: {
    dashed_name: 'file-type',
    description: 'File type (file, dir, or symlink).',
    example: 'file',
    flat_name: 'file.type',
    ignore_above: 1024,
    level: 'extended',
    name: 'type',
    normalize: [],
    short: 'File type (file, dir, or symlink).',
    type: 'keyword'
  },
  uid: {
    dashed_name: 'file-uid',
    description: 'The user ID (UID) or security identifier (SID) of the file owner.',
    example: '1001',
    flat_name: 'file.uid',
    ignore_above: 1024,
    level: 'extended',
    name: 'uid',
    normalize: [],
    short: 'The user ID (UID) or security identifier (SID) of the file owner.',
    type: 'keyword'
  },
  x509: {
    alternative_names: {
      dashed_name: 'file-x509-alternative-names',
      description: 'List of subject alternative names (SAN). Name types vary by certificate authority and certificate type but commonly contain IP addresses, DNS names (and wildcards), and email addresses.',
      example: '*.elastic.co',
      flat_name: 'file.x509.alternative_names',
      ignore_above: 1024,
      level: 'extended',
      name: 'alternative_names',
      normalize: [ 'array' ],
      original_fieldset: 'x509',
      short: 'List of subject alternative names (SAN).',
      type: 'keyword'
    },
    issuer: {
      common_name: {
        dashed_name: 'file-x509-issuer-common-name',
        description: 'List of common name (CN) of issuing certificate authority.',
        example: 'Example SHA2 High Assurance Server CA',
        flat_name: 'file.x509.issuer.common_name',
        ignore_above: 1024,
        level: 'extended',
        name: 'issuer.common_name',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of common name (CN) of issuing certificate authority.',
        type: 'keyword'
      },
      country: {
        dashed_name: 'file-x509-issuer-country',
        description: 'List of country (C) codes',
        example: 'US',
        flat_name: 'file.x509.issuer.country',
        ignore_above: 1024,
        level: 'extended',
        name: 'issuer.country',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of country (C) codes',
        type: 'keyword'
      },
      distinguished_name: {
        dashed_name: 'file-x509-issuer-distinguished-name',
        description: 'Distinguished name (DN) of issuing certificate authority.',
        example: 'C=US, O=Example Inc, OU=www.example.com, CN=Example SHA2 High Assurance Server CA',
        flat_name: 'file.x509.issuer.distinguished_name',
        ignore_above: 1024,
        level: 'extended',
        name: 'issuer.distinguished_name',
        normalize: [],
        original_fieldset: 'x509',
        short: 'Distinguished name (DN) of issuing certificate authority.',
        type: 'keyword'
      },
      locality: {
        dashed_name: 'file-x509-issuer-locality',
        description: 'List of locality names (L)',
        example: 'Mountain View',
        flat_name: 'file.x509.issuer.locality',
        ignore_above: 1024,
        level: 'extended',
        name: 'issuer.locality',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of locality names (L)',
        type: 'keyword'
      },
      organization: {
        dashed_name: 'file-x509-issuer-organization',
        description: 'List of organizations (O) of issuing certificate authority.',
        example: 'Example Inc',
        flat_name: 'file.x509.issuer.organization',
        ignore_above: 1024,
        level: 'extended',
        name: 'issuer.organization',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of organizations (O) of issuing certificate authority.',
        type: 'keyword'
      },
      organizational_unit: {
        dashed_name: 'file-x509-issuer-organizational-unit',
        description: 'List of organizational units (OU) of issuing certificate authority.',
        example: 'www.example.com',
        flat_name: 'file.x509.issuer.organizational_unit',
        ignore_above: 1024,
        level: 'extended',
        name: 'issuer.organizational_unit',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of organizational units (OU) of issuing certificate authority.',
        type: 'keyword'
      },
      state_or_province: {
        dashed_name: 'file-x509-issuer-state-or-province',
        description: 'List of state or province names (ST, S, or P)',
        example: 'California',
        flat_name: 'file.x509.issuer.state_or_province',
        ignore_above: 1024,
        level: 'extended',
        name: 'issuer.state_or_province',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of state or province names (ST, S, or P)',
        type: 'keyword'
      }
    },
    not_after: {
      dashed_name: 'file-x509-not-after',
      description: 'Time at which the certificate is no longer considered valid.',
      example: '2020-07-16T03:15:39Z',
      flat_name: 'file.x509.not_after',
      level: 'extended',
      name: 'not_after',
      normalize: [],
      original_fieldset: 'x509',
      short: 'Time at which the certificate is no longer considered valid.',
      type: 'date'
    },
    not_before: {
      dashed_name: 'file-x509-not-before',
      description: 'Time at which the certificate is first considered valid.',
      example: '2019-08-16T01:40:25Z',
      flat_name: 'file.x509.not_before',
      level: 'extended',
      name: 'not_before',
      normalize: [],
      original_fieldset: 'x509',
      short: 'Time at which the certificate is first considered valid.',
      type: 'date'
    },
    public_key_algorithm: {
      dashed_name: 'file-x509-public-key-algorithm',
      description: 'Algorithm used to generate the public key.',
      example: 'RSA',
      flat_name: 'file.x509.public_key_algorithm',
      ignore_above: 1024,
      level: 'extended',
      name: 'public_key_algorithm',
      normalize: [],
      original_fieldset: 'x509',
      short: 'Algorithm used to generate the public key.',
      type: 'keyword'
    },
    public_key_curve: {
      dashed_name: 'file-x509-public-key-curve',
      description: 'The curve used by the elliptic curve public key algorithm. This is algorithm specific.',
      example: 'nistp521',
      flat_name: 'file.x509.public_key_curve',
      ignore_above: 1024,
      level: 'extended',
      name: 'public_key_curve',
      normalize: [],
      original_fieldset: 'x509',
      short: 'The curve used by the elliptic curve public key algorithm. This is algorithm specific.',
      type: 'keyword'
    },
    public_key_exponent: {
      dashed_name: 'file-x509-public-key-exponent',
      description: 'Exponent used to derive the public key. This is algorithm specific.',
      doc_values: false,
      example: 65537,
      flat_name: 'file.x509.public_key_exponent',
      index: false,
      level: 'extended',
      name: 'public_key_exponent',
      normalize: [],
      original_fieldset: 'x509',
      short: 'Exponent used to derive the public key. This is algorithm specific.',
      type: 'long'
    },
    public_key_size: {
      dashed_name: 'file-x509-public-key-size',
      description: 'The size of the public key space in bits.',
      example: 2048,
      flat_name: 'file.x509.public_key_size',
      level: 'extended',
      name: 'public_key_size',
      normalize: [],
      original_fieldset: 'x509',
      short: 'The size of the public key space in bits.',
      type: 'long'
    },
    serial_number: {
      dashed_name: 'file-x509-serial-number',
      description: 'Unique serial number issued by the certificate authority. For consistency, if this value is alphanumeric, it should be formatted without colons and uppercase characters.',
      example: '55FBB9C7DEBF09809D12CCAA',
      flat_name: 'file.x509.serial_number',
      ignore_above: 1024,
      level: 'extended',
      name: 'serial_number',
      normalize: [],
      original_fieldset: 'x509',
      short: 'Unique serial number issued by the certificate authority.',
      type: 'keyword'
    },
    signature_algorithm: {
      dashed_name: 'file-x509-signature-algorithm',
      description: 'Identifier for certificate signature algorithm. We recommend using names found in Go Lang Crypto library. See https://github.com/golang/go/blob/go1.14/src/crypto/x509/x509.go#L337-L353.',
      example: 'SHA256-RSA',
      flat_name: 'file.x509.signature_algorithm',
      ignore_above: 1024,
      level: 'extended',
      name: 'signature_algorithm',
      normalize: [],
      original_fieldset: 'x509',
      short: 'Identifier for certificate signature algorithm.',
      type: 'keyword'
    },
    subject: {
      common_name: {
        dashed_name: 'file-x509-subject-common-name',
        description: 'List of common names (CN) of subject.',
        example: 'shared.global.example.net',
        flat_name: 'file.x509.subject.common_name',
        ignore_above: 1024,
        level: 'extended',
        name: 'subject.common_name',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of common names (CN) of subject.',
        type: 'keyword'
      },
      country: {
        dashed_name: 'file-x509-subject-country',
        description: 'List of country (C) code',
        example: 'US',
        flat_name: 'file.x509.subject.country',
        ignore_above: 1024,
        level: 'extended',
        name: 'subject.country',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of country (C) code',
        type: 'keyword'
      },
      distinguished_name: {
        dashed_name: 'file-x509-subject-distinguished-name',
        description: 'Distinguished name (DN) of the certificate subject entity.',
        example: 'C=US, ST=California, L=San Francisco, O=Example, Inc., CN=shared.global.example.net',
        flat_name: 'file.x509.subject.distinguished_name',
        ignore_above: 1024,
        level: 'extended',
        name: 'subject.distinguished_name',
        normalize: [],
        original_fieldset: 'x509',
        short: 'Distinguished name (DN) of the certificate subject entity.',
        type: 'keyword'
      },
      locality: {
        dashed_name: 'file-x509-subject-locality',
        description: 'List of locality names (L)',
        example: 'San Francisco',
        flat_name: 'file.x509.subject.locality',
        ignore_above: 1024,
        level: 'extended',
        name: 'subject.locality',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of locality names (L)',
        type: 'keyword'
      },
      organization: {
        dashed_name: 'file-x509-subject-organization',
        description: 'List of organizations (O) of subject.',
        example: 'Example, Inc.',
        flat_name: 'file.x509.subject.organization',
        ignore_above: 1024,
        level: 'extended',
        name: 'subject.organization',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of organizations (O) of subject.',
        type: 'keyword'
      },
      organizational_unit: {
        dashed_name: 'file-x509-subject-organizational-unit',
        description: 'List of organizational units (OU) of subject.',
        flat_name: 'file.x509.subject.organizational_unit',
        ignore_above: 1024,
        level: 'extended',
        name: 'subject.organizational_unit',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of organizational units (OU) of subject.',
        type: 'keyword'
      },
      state_or_province: {
        dashed_name: 'file-x509-subject-state-or-province',
        description: 'List of state or province names (ST, S, or P)',
        example: 'California',
        flat_name: 'file.x509.subject.state_or_province',
        ignore_above: 1024,
        level: 'extended',
        name: 'subject.state_or_province',
        normalize: [ 'array' ],
        original_fieldset: 'x509',
        short: 'List of state or province names (ST, S, or P)',
        type: 'keyword'
      }
    },
    version_number: {
      dashed_name: 'file-x509-version-number',
      description: 'Version of x509 format.',
      example: 3,
      flat_name: 'file.x509.version_number',
      ignore_above: 1024,
      level: 'extended',
      name: 'version_number',
      normalize: [],
      original_fieldset: 'x509',
      short: 'Version of x509 format.',
      type: 'keyword'
    }
  }
}