# `@kbn/observable`

`@kbn/observable` is an observable library based on the [proposed
`Observable`][proposal] feature and ideas from [RxJS][rxjs].

Why build our own observable library? The main reason is that we don't want to
tie our plugin apis heavily to a large dependency, but rather expose something
that's much simpler and that we have control over ourselves.

In addition, `@kbn/observable` implements `System.observable` which enables
interop between observable libraries, which means plugins can use whatever
observable library they want if they don't want to rely on `@kbn/observable`.

## Example

```js
import { $of, map, last } from '@kbn/observable';

const source = $of(1, 2, 3);

source.pipe(map(i => 2017 + i), last()).subscribe(console.log); // logs 2020
```

## Just getting started with Observables?

If you are just getting started with observables, a great place to start is with
Andre Staltz' [The introduction to Reactive Programming you've been
missing][staltz-intro], which is a great introduction to the ideas and concepts.

The ideas in `@kbn/observable` are heavily based on [RxJS][rxjs], so the [RxJS
docs][rxjs-docs] are also a good source of introduction to observables and how
they work in this library.

**NOTE**: Do you know about good articles, videos or other resources that does a
great job at explaining observables? Add them here so it becomes easier for the
next person to learn about them!

## Factories

Factories take arguments and produce an observable. Different factories are
useful for different things, and many behave just like the static functions
attached to the `Rx.Observable` class in RxJS.

The available factories:

* `$bindCallback` - takes a function as a parameter, calls this function, and
  emits the value returned from it as its single emission
* `$bindNodeCallback` - Similar to `$bindCallback`, but specialized for the
  "error-first" type of callback functions found in Node.js.
* `$combineLatest` - when an item is emitted by either of two Observables,
  combine the latest item emitted by each Observable via a specified function
  and emit items based on the results of this function
* `$concat` - emit the emissions from two or more Observables without
  interleaving them
* `$error` - create an Observable that emits no items and terminates with an
  error
* `$fromIterable` - Converts an Iterator into an observable sequence
* `$fromObservable` - Converts any object that implements `Symbol.observable`
  into a `@kbn/observable`
* `$fromPromise` - Converts a Promise into an Observable, converting its resolve
  calls into `next` notifications, and its reject calls into `error`
  notifications.
* `$race` - Returns an Observable that mirrors the first source Observable to
  emit an item from the combination of this Observable and supplied Observables.
* `$of`

## Operators

Operators are functions that take some arguments and produce an operator
function. Most operators operate on an Observable and return an Observable. This
allows you to apply these operators one after the other, in a chain. Each
operator in the chain modifies the Observable that results from the operation of
the previous operator.

Some example operators:

```js
map(i => 2017 + i);

filter(i => i % 2 === 0);

reduce((acc, val) => {
  return acc + val;
}, 0);
```

With operators you often don't have to think about observables at all, as you
see in the examples above. There are other operators like `mergeMap` and
`switchMap` where you need to operate directly on observables.

A chain of Observable operators do not operate independently on the original
Observable that originates the chain, but they operate in turn, each one
operating on the Observable generated by the operator immediately previous in
the chain.

Multiple operator functions can be passed to `.pipe` and will be applied to the
input observable before returning the final observable with all modifications
applied, e.g.

```js
$of(1, 2, 3).pipe(map(i => 2017 + i), filter(i => i % 2 === 0));
```

The available operators:

* `filter` - emit only those items from an Observable that pass a predicate
  test.
* `first` - emit only the first item from an Observable
* `last` - emit only the last item emitted by an Observable
* `map` - transform the items emitted by an Observable by applying a function to
  each item
* `mergeMap` - transform the items emitted by an Observable into Observables,
  then flatten the emissions from those into a single Observable
* `reduce` - apply a function to each item emitted by an Observable,
  sequentially, and emit the final value
* `scan` - apply a function to each item emitted by an Observable, sequentially,
  and emit each successive value
* `shareLatestValue` - ensure that all observers share the latest emitted item,
  even if they subscribe after the Observable has begun emitting items
* `skipRepeats` - suppress duplicate items emitted by an Observable
* `switchMap` - convert an Observable that emits Observables into a single
  Observable that emits the items emitted by the most-recently-emitted of those
  Observables
* `toArray` - collect all items into an array and emit it when Observable is
  completed

## More advanced topics

This library contains implementations of both `Observable` and `Subject`. To
better understand the difference between them, it's important to understand the
difference between hot and cold observables. Ben Lesh's [Hot vs Cold
Observables][hot-vs-cold] is a great introduction to this topic.

**NOTE**: Do you know about good articles, videos or other resources that goes
deeper into Observables and related topics? Make sure we get them added to this
list!

## Why `@kbn/observable`?

While exploring how to handle observables in Kibana we went through multiple
PoCs and explorations. We initially used RxJS directly, but we hit a couple
setbacks. First, we didn't want to expose a large dependency like RxJS directly
in our plugin APIs because of our earlier experiences with exposing large
libraries. One problem with doing that is that we can't perform a major upgrade
of the library without changing the major version of Kibana since when the
library is directly exposed in our plugin API.

The second problem we hit is that having multiple instances of RxJS is not
supported, which means plugins must use the exact same version as Kibana core.
This means we need to find a way to share the dependency with a plugin.

In the end we decided to build our own small observable implementation that fits
the Kibana context but doesn't contain all bells and whistles required in a
general-purpose observable library.

## Underlying ideas

* Prefer to be explicit, not implicit. An example of this is having multiple
  `fromX` implementations instead of having a `from` that accepts multiple
  different types of input (iterable, promises, etc).
* Don't add any operators on the Observable prototype, but instead rely on
  `pipe` for operators.
* Solve the 80% use-case instead of creating very generic helpers. An example of
  this is our `shareLatestValue` implementation. It's not as generic as `share`
  or `shareReplay` in RxJS, but it solves most of the use-cases we have.

## Inspiration

This code is heavily inspired by and based on RxJS, which is licensed under the
Apache License, Version 2.0, see https://github.com/ReactiveX/rxjs.

## History behind this library

We built an initial version of `@kbn/observable` fully based on the [TC39
Observable proposal][proposal], and even used its implementation of the
`Observable` class. The reason we later changed to implementing our own
top-level `Observable` class is that the TC39 proposal haven't made progress in
the standardization track and there are clear indications it won't move forward
in its current shape.

There have been initial work on [standardizing observables through
WhatWG][whatwg-observable]. However as that is still in early stages where e.g.
details like `AbortSignal/AbortController` and `async/await` are discussed,
there are no implementations of observable that can be expected to go through
any standardization track without API changes at this point.

In the end we decided to implement our own `Observable` class and base our
implementation on `pipe` and staying away from the prototype, unless we had to
add a method on it.

Ideally in the long-term we will base `@kbn/observable` on a standardized
`Observable`.

[proposal]: https://github.com/tc39/proposal-observable
[rxjs]: http://reactivex.io/rxjs/
[rxjs-docs]: http://reactivex.io/rxjs/manual/index.html
[staltz-intro]: https://gist.github.com/staltz/868e7e9bc2a7b8c1f754
[whatwg-observable]: https://github.com/whatwg/dom/issues/544
[hot-vs-cold]: https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339
