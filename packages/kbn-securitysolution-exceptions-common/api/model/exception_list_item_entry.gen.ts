/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator, @kbn/openapi-generator.
 *
 * info:
 *   title: Common Exception List Item Entry Attributes
 *   version: not applicable
 */

import { z } from '@kbn/zod';

import { NonEmptyString } from '@kbn/openapi-common/schemas/primitives.gen';
import { ListId, ListType } from '@kbn/securitysolution-lists-common/api/model/list_common.gen';

export type ExceptionListItemEntryOperator = z.infer<typeof ExceptionListItemEntryOperator>;
export const ExceptionListItemEntryOperator = z.enum(['excluded', 'included']);
export type ExceptionListItemEntryOperatorEnum = typeof ExceptionListItemEntryOperator.enum;
export const ExceptionListItemEntryOperatorEnum = ExceptionListItemEntryOperator.enum;

export type ExceptionListItemEntryMatch = z.infer<typeof ExceptionListItemEntryMatch>;
export const ExceptionListItemEntryMatch = z.object({
  type: z.literal('match'),
  field: NonEmptyString,
  value: NonEmptyString,
  operator: ExceptionListItemEntryOperator,
});

export type ExceptionListItemEntryMatchAny = z.infer<typeof ExceptionListItemEntryMatchAny>;
export const ExceptionListItemEntryMatchAny = z.object({
  type: z.literal('match_any'),
  field: NonEmptyString,
  value: z.array(NonEmptyString).min(1),
  operator: ExceptionListItemEntryOperator,
});

export type ExceptionListItemEntryList = z.infer<typeof ExceptionListItemEntryList>;
export const ExceptionListItemEntryList = z.object({
  type: z.literal('list'),
  field: NonEmptyString,
  list: z.object({
    id: ListId,
    type: ListType,
  }),
  operator: ExceptionListItemEntryOperator,
});

export type ExceptionListItemEntryExists = z.infer<typeof ExceptionListItemEntryExists>;
export const ExceptionListItemEntryExists = z.object({
  type: z.literal('exists'),
  field: NonEmptyString,
  operator: ExceptionListItemEntryOperator,
});

export const ExceptionListItemEntryNestedEntryItemInternal = z.union([
  ExceptionListItemEntryMatch,
  ExceptionListItemEntryMatchAny,
  ExceptionListItemEntryExists,
]);

export type ExceptionListItemEntryNestedEntryItem = z.infer<
  typeof ExceptionListItemEntryNestedEntryItemInternal
>;
export const ExceptionListItemEntryNestedEntryItem =
  ExceptionListItemEntryNestedEntryItemInternal as z.ZodType<ExceptionListItemEntryNestedEntryItem>;

export type ExceptionListItemEntryNested = z.infer<typeof ExceptionListItemEntryNested>;
export const ExceptionListItemEntryNested = z.object({
  type: z.literal('nested'),
  field: NonEmptyString,
  entries: z.array(ExceptionListItemEntryNestedEntryItem).min(1),
});

export type ExceptionListItemEntryMatchWildcard = z.infer<
  typeof ExceptionListItemEntryMatchWildcard
>;
export const ExceptionListItemEntryMatchWildcard = z.object({
  type: z.literal('wildcard'),
  field: NonEmptyString,
  value: NonEmptyString,
  operator: ExceptionListItemEntryOperator,
});

export const ExceptionListItemEntryInternal = z.discriminatedUnion('type', [
  ExceptionListItemEntryMatch,
  ExceptionListItemEntryMatchAny,
  ExceptionListItemEntryList,
  ExceptionListItemEntryExists,
  ExceptionListItemEntryNested,
  ExceptionListItemEntryMatchWildcard,
]);

export type ExceptionListItemEntry = z.infer<typeof ExceptionListItemEntryInternal>;
export const ExceptionListItemEntry =
  ExceptionListItemEntryInternal as z.ZodType<ExceptionListItemEntry>;

export type ExceptionListItemEntryArray = z.infer<typeof ExceptionListItemEntryArray>;
export const ExceptionListItemEntryArray = z.array(ExceptionListItemEntry);
