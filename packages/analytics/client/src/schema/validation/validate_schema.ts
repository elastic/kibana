/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import type { Context, Type } from 'io-ts';
import { either } from 'fp-ts/lib/Either';

/**
 * Validates the event according to the schema validator generated by {@link convertSchemaToIoTs}.
 * @throws Error when the event does not comply with the schema.
 * @param validator The io-ts validator for the event.
 * @param payload The payload to validate.
 */
export function validateSchema<Payload>(
  sourceName: string,
  validator: Type<Payload>,
  payload: Payload
): void {
  // Run io-ts validation to the event
  const result = validator.decode(payload);

  either.mapLeft(result, (validationErrors) => {
    const humanFriendlyErrors = validationErrors
      .map(
        (err) => `[${getFullPathKey(err.context)}]: ${err.message ?? readableContext(err.context)}`
      )
      .filter((errMsg, idx, listOfErrMsgs) => listOfErrMsgs.indexOf(errMsg, idx + 1) === -1);
    throw new Error(
      `Failed to validate payload coming from "${sourceName}":\n\t- ${humanFriendlyErrors.join(
        '\n\t- '
      )}`
    );
  });
}

/**
 * Picks the relevant fields of the validation error's context
 * @param context The {@link Context} coming from the validation error
 */
function readableContext(context: Context) {
  // The information provided, the last context is good enough.
  // Otherwise, repeating the values for every nested key is too noisy.
  const last = context[context.length - 1];
  return JSON.stringify({
    expected: last.type.name,
    // Explicitly printing `undefined` to make it more obvious in the message
    actual: typeof last.actual,
    value: last.actual === undefined ? 'undefined' : last.actual,
  });
}

/**
 * Prints the full path to the key that raised the validation error.
 * @param context The {@link Context} coming from the validation error
 */
function getFullPathKey(context: Context): string {
  return (
    context
      // Remove the context provided by InterfaceType and PartialType because their keys are simply numeric indices
      .filter(
        (ctx) =>
          !['InterfaceType', 'PartialType'].includes(
            (ctx.type as Type<unknown> & { _tag: string })._tag
          )
      )
      .map(({ key }) => key)
      .filter(Boolean)
      .join('.')
  );
}
