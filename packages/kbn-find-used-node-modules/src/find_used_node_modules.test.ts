/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import { findUsedNodeModules } from './find_used_node_modules';
import { ImportResolver } from '@kbn/import-resolver';
import { ImportLocator } from '@kbn/import-locator';

jest.mock('./fs');

class MockResolver extends ImportResolver {
  constructor() {
    super('/', new Map());
  }

  resolve = jest.fn();
}

class MockLocator extends ImportLocator {
  read = jest.fn();
}

const REQS: Map<string, string[]> = new Map(
  Object.entries({
    '/foo.js': ['./bar.js'],
    '/bar.js': ['./box'],
    '/box.js': ['foo'],
  })
);

const RESOLVER = new MockResolver();
const LOCATOR = new MockLocator();

beforeEach(() => {
  jest.resetAllMocks();

  LOCATOR.read.mockImplementation(async (path: string) => {
    const reqs = REQS.get(path);
    if (reqs === undefined) {
      throw new Error('unexpected path passed to ImportLocator#read()');
    }
    return new Set(reqs);
  });
});

describe('findUsedNodeModules()', () => {
  it('excludes built-in modules', async () => {
    RESOLVER.resolve.mockImplementation(() => ({
      type: 'built-in',
    }));

    const results = await findUsedNodeModules({
      entryPaths: ['/foo.js'],
      locator: LOCATOR,
      resolver: RESOLVER,
      findUsedPeers: false,
    });

    expect(RESOLVER.resolve).toHaveBeenCalledTimes(1);
    expect(results).toEqual([]);
  });

  it('returns node_modules found in the source file', async () => {
    RESOLVER.resolve.mockImplementation((req) => {
      if (req === './bar.js') {
        return {
          type: 'file',
          nodeModule: '@foo/bar',
          absolute: '/bar.js',
        };
      }

      throw new Error('unexpected request');
    });

    const results = await findUsedNodeModules({
      entryPaths: ['/foo.js'],
      locator: LOCATOR,
      resolver: RESOLVER,
      findUsedPeers: false,
    });
    expect(RESOLVER.resolve).toHaveBeenCalledTimes(1);
    expect(results).toEqual(['@foo/bar']);
  });

  it('returns node_modules found in referenced files', async () => {
    RESOLVER.resolve.mockImplementation((req) => {
      if (req === './bar.js') {
        return {
          type: 'file',
          absolute: '/bar.js',
        };
      }

      if (req === './box') {
        return {
          type: 'file',
          nodeModule: '@foo/box',
          absolute: '/box.js',
        };
      }

      throw new Error('unexpected request');
    });

    const results = await findUsedNodeModules({
      entryPaths: ['/foo.js'],
      locator: LOCATOR,
      resolver: RESOLVER,
      findUsedPeers: false,
    });
    expect(RESOLVER.resolve).toHaveBeenCalledTimes(2);
    expect(results).toEqual(['@foo/box']);
  });

  it('does not traverse node_modules', async () => {
    RESOLVER.resolve.mockImplementation((req) => {
      if (req === './bar.js') {
        return {
          type: 'file',
          absolute: '/bar.js',
        };
      }

      if (req === './box') {
        return {
          type: 'file',
          nodeModule: '@foo/box',
          absolute: '/box.js',
        };
      }

      throw new Error('unexpected request');
    });

    const results = await findUsedNodeModules({
      entryPaths: ['/foo.js'],
      locator: LOCATOR,
      resolver: RESOLVER,
      findUsedPeers: false,
    });
    expect(results).toEqual(['@foo/box']);
    expect(RESOLVER.resolve).toHaveBeenCalledTimes(2);
    expect(LOCATOR.read).toHaveBeenCalledTimes(2);
  });

  it('does traverse node_modules which are also bazel packages', async () => {
    RESOLVER.resolve.mockImplementation((req) => {
      if (req === './bar.js') {
        return {
          type: 'file',
          absolute: '/bar.js',
        };
      }

      if (req === './box') {
        return {
          type: 'file',
          pkgId: '@foo/box',
          absolute: '/box.js',
        };
      }

      if (req === 'foo') {
        return {
          type: 'file',
          nodeModule: '@foo/core',
          absolute: '/non-existant',
        };
      }

      throw new Error('unexpected request');
    });

    const results = await findUsedNodeModules({
      entryPaths: ['/foo.js'],
      locator: LOCATOR,
      resolver: RESOLVER,
      findUsedPeers: false,
    });
    expect(RESOLVER.resolve).toHaveBeenCalledTimes(3);
    expect(LOCATOR.read).toHaveBeenCalledTimes(3);
    expect(results).toEqual(['@foo/box', '@foo/core']);
  });
});
