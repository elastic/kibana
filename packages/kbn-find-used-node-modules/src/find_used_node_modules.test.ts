/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import { findUsedNodeModules } from './find_used_node_modules';
import { ImportResolver } from '@kbn/import-resolver';

jest.mock('./fs');

const FILES: Record<string, string> = {
  '/foo.js': `
    require('./bar.js')
  `,
  '/bar.js': `
    require('./box')
  `,
  '/box.js': `
    require('foo')
  `,
};

class MockResolver extends ImportResolver {
  constructor() {
    super('/', new Map(), new Map());
  }

  isBazelPackage = jest.fn();
  resolve = jest.fn();
}

const RESOLVER = new MockResolver();

beforeEach(() => {
  jest.resetAllMocks();
  jest.requireMock('./fs').readFile.mockImplementation((path: string) => {
    if (Object.hasOwn(FILES, path)) {
      return FILES[path];
    }

    const error: any = new Error(`ENOENT, missing file [${path}]`);
    error.code = 'ENOENT';
    throw error;
  });
});

describe('findUsedNodeModules()', () => {
  it('excludes built-in modules', async () => {
    RESOLVER.resolve.mockImplementation(() => ({
      type: 'built-in',
    }));

    const results = await findUsedNodeModules({
      entryPaths: ['/foo.js'],
      resolver: RESOLVER,
      findUsedPeers: false,
    });

    expect(RESOLVER.resolve).toHaveBeenCalledTimes(1);
    expect(results).toEqual([]);
  });

  it('returns node_modules found in the source file', async () => {
    RESOLVER.resolve.mockImplementation((req) => {
      if (req === './bar.js') {
        return {
          type: 'file',
          nodeModule: '@foo/bar',
          absolute: '/bar.js',
        };
      }

      throw new Error('unexpected request');
    });

    const results = await findUsedNodeModules({
      entryPaths: ['/foo.js'],
      resolver: RESOLVER,
      findUsedPeers: false,
    });
    expect(RESOLVER.resolve).toHaveBeenCalledTimes(1);
    expect(results).toEqual(['@foo/bar']);
  });

  it('returns node_modules found in referenced files', async () => {
    RESOLVER.resolve.mockImplementation((req) => {
      if (req === './bar.js') {
        return {
          type: 'file',
          absolute: '/bar.js',
        };
      }

      if (req === './box') {
        return {
          type: 'file',
          nodeModule: '@foo/box',
          absolute: '/box.js',
        };
      }

      throw new Error('unexpected request');
    });

    const results = await findUsedNodeModules({
      entryPaths: ['/foo.js'],
      resolver: RESOLVER,
      findUsedPeers: false,
    });
    expect(RESOLVER.resolve).toHaveBeenCalledTimes(2);
    expect(results).toEqual(['@foo/box']);
  });

  it('does not traverse node_modules', async () => {
    RESOLVER.resolve.mockImplementation((req) => {
      if (req === './bar.js') {
        return {
          type: 'file',
          absolute: '/bar.js',
        };
      }

      if (req === './box') {
        return {
          type: 'file',
          nodeModule: '@foo/box',
          absolute: '/box.js',
        };
      }

      throw new Error('unexpected request');
    });

    const results = await findUsedNodeModules({
      entryPaths: ['/foo.js'],
      resolver: RESOLVER,
      findUsedPeers: false,
    });
    expect(RESOLVER.resolve).toHaveBeenCalledTimes(2);
    expect(results).toEqual(['@foo/box']);
  });

  it('does traverse node_modules which are also bazel packages', async () => {
    RESOLVER.resolve.mockImplementation((req) => {
      if (req === './bar.js') {
        return {
          type: 'file',
          absolute: '/bar.js',
        };
      }

      if (req === './box') {
        return {
          type: 'file',
          nodeModule: '@foo/box',
          absolute: '/box.js',
        };
      }

      if (req === 'foo') {
        return {
          type: 'file',
          nodeModule: '@foo/core',
          absolute: '/non-existant',
        };
      }

      throw new Error('unexpected request');
    });

    RESOLVER.isBazelPackage.mockImplementation((pkgId) => {
      return pkgId === '@foo/box';
    });

    const results = await findUsedNodeModules({
      entryPaths: ['/foo.js'],
      resolver: RESOLVER,
      findUsedPeers: false,
    });
    expect(RESOLVER.resolve).toHaveBeenCalledTimes(3);
    expect(results).toEqual(['@foo/box', '@foo/core']);
  });
});
