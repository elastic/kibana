/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import Path from 'path';
import Fs from 'fs';

import * as Rx from 'rxjs';
import type { ImportResolver } from '@kbn/import-resolver';
import type { ImportLocator } from '@kbn/import-locator';
import { REPO_ROOT } from '@kbn/repo-info';

import { readFile$ } from './fs';

function isObj(v: any): v is Record<string, unknown> {
  return typeof v === 'object' && v !== null;
}

function findPkgJsonUpDeep(path: string): string | null {
  const dir = Path.dirname(path);
  if (dir === '/' || dir === REPO_ROOT || dir === path) {
    return null;
  }

  const candidate = Path.resolve(dir, 'package.json');
  if (Fs.existsSync(candidate)) {
    return candidate;
  }

  return findPkgJsonUpDeep(dir);
}

function findPkgJson(dep: string, paths: Iterable<string>) {
  for (const path of paths) {
    const value = findPkgJsonUpDeep(path);
    if (value !== null) {
      return value;
    }
  }
  throw new Error(`Unable to find package.json file for ${dep}`);
}

interface Options {
  locator: ImportLocator;
  resolver: ImportResolver;
  entryPaths: string[];
  findUsedPeers: boolean;
  // if we are finding used modules in a node_module, this must be the name of the node_module
  // we should treat as "this module" rather than "another node module"
  thisNodeModule?: string;
}

/**
 * Parse a list of entry paths and find the node_modules which are required by them. If the
 * entry path requires/imports a non-node_module then that file is scanned too, deeply, until
 * all referenced files are scanned.
 *
 * Optionally, we can find the used peers of the used node_modules. This will keep track of all
 * the paths we use to enter a node_module and then traverse from those points, finding the
 * used modules and comparing those to the `peerDependencies` listed in the node_module's package.json
 * file. If a used dependeny is in the `peerDependencies` and is used by the node_module it will
 * be included in the results.
 *
 * This was implemented mostly for `@emotion/react` which is used by @elastic/eui but only listed
 * as a peerDependency. If we didn't keep it in the Kibana package.json then the package would not
 * be installed and cause an error on startup because `@emotion/react` can't be found. We used to
 * solve this by scanning the node_modules directory for all the packages which are used but that
 * was much slower and lead to extra entries in package.json.
 */

export async function findUsedNodeModules(options: Options) {
  const results = new Set<string>();
  const entryPathsIntoNodeModules = new Map<string, Set<string>>();

  const path$ = new Rx.Subject<string>();

  let inputs = 0;
  let outputs = 0;
  const promise = Rx.lastValueFrom(
    path$.pipe(
      Rx.filter((path) => Path.extname(path) === '.js'),
      Rx.distinct(),
      Rx.tap(() => {
        inputs += 1;
      }),
      Rx.mergeMap(async (path) => {
        const reqs = await options.locator.read(path);
        const dirname = Path.dirname(path);

        for (const req of reqs) {
          // resolve the request to it's actual file on disk
          const result = options.resolver.resolve(req, dirname);

          // ignore non-file resolution results, these represent files which aren't on
          // the file-system yet (like during the build) built-ins, explicitily ignored
          // files, and @types only imports
          if (result?.type !== 'file') {
            continue;
          }

          if (result.pkgId) {
            results.add(result.pkgId);
            path$.next(result.absolute);
            continue;
          }

          // if the result points to a node_module (or another node_module)...
          if (result.nodeModule && result.nodeModule !== options.thisNodeModule) {
            // add it to the results
            results.add(result.nodeModule);

            // record this absolute path as an entry path into the node module from our entries, if we
            // need to scan this node_module for used deps we need to know how we access it.
            const nmEntries = entryPathsIntoNodeModules.get(result.nodeModule);
            if (!nmEntries) {
              entryPathsIntoNodeModules.set(result.nodeModule, new Set([result.absolute]));
            } else {
              nmEntries.add(result.absolute);
            }
          }

          // no need to scan node_modules unless they're bazel packages
          if (
            !result.nodeModule ||
            result.nodeModule === options.thisNodeModule ||
            options.resolver.isRepoPkg(result.nodeModule)
          ) {
            path$.next(result.absolute);
            continue;
          }
        }
      }, 200),
      Rx.tap(() => {
        outputs += 1;
        if (inputs === outputs) {
          path$.complete();
        }
      })
    )
  );

  for (const path of options.entryPaths) {
    path$.next(path);
  }

  await promise;

  if (options.findUsedPeers) {
    await Rx.lastValueFrom(
      Rx.from(results).pipe(
        Rx.mergeMap((dep) => {
          const entryPaths = entryPathsIntoNodeModules.get(dep);
          if (!entryPaths?.size) {
            return Rx.EMPTY;
          }

          return readFile$(findPkgJson(dep, entryPaths), 'utf8').pipe(
            Rx.mergeMap((pkgJson) => {
              const pkg = JSON.parse(pkgJson);

              if (!isObj(pkg) || !isObj(pkg.peerDependencies)) {
                return Rx.EMPTY;
              }

              const peerDeps = Object.keys(pkg.peerDependencies);
              if (!peerDeps.length) {
                return Rx.EMPTY;
              }

              return Rx.of({ entryPaths, dep, peerDeps });
            })
          );
        }, 50),
        Rx.concatMap(async ({ entryPaths, dep, peerDeps }) => {
          const usedInside = await findUsedNodeModules({
            locator: options.locator,
            resolver: options.resolver,
            entryPaths: Array.from(entryPaths),
            findUsedPeers: false,
            thisNodeModule: dep,
          });

          for (const peer of peerDeps) {
            if (usedInside.includes(peer)) {
              results.add(peer);
            }
          }
        })
      )
    );
  }

  return Array.from(results).sort((a, b) => a.localeCompare(b));
}
