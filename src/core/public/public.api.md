## API Report File for "kibana"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Breadcrumb } from '@elastic/eui';
import { EuiButtonEmptyProps } from '@elastic/eui';
import { EuiGlobalToastListToast } from '@elastic/eui';
import { ExclusiveUnion } from '@elastic/eui';
import { IconType } from '@elastic/eui';
import { Observable } from 'rxjs';
import React from 'react';
import * as Rx from 'rxjs';
import { ShallowPromise } from '@kbn/utility-types';
import { UiSettingsParams as UiSettingsParams_2 } from 'src/core/server/types';
import { UserProvidedValues as UserProvidedValues_2 } from 'src/core/server/types';

// @public
export interface App extends AppBase {
    appRoute?: string;
    chromeless?: boolean;
    mount: AppMount | AppMountDeprecated;
}

// @public (undocumented)
export interface AppBase {
    capabilities?: Partial<Capabilities>;
    chromeless?: boolean;
    euiIconType?: string;
    icon?: string;
    id: string;
    // @internal
    legacy?: boolean;
    navLinkStatus?: AppNavLinkStatus;
    order?: number;
    status?: AppStatus;
    title: string;
    tooltip?: string;
    updater$?: Observable<AppUpdater>;
}

// @public (undocumented)
export interface ApplicationSetup {
    register(app: App): void;
    registerAppUpdater(appUpdater$: Observable<AppUpdater>): void;
    // @deprecated
    registerMountContext<T extends keyof AppMountContext>(contextName: T, provider: IContextProvider<AppMountDeprecated, T>): void;
}

// @public (undocumented)
export interface ApplicationStart {
    capabilities: RecursiveReadonly<Capabilities>;
    getUrlForApp(appId: string, options?: {
        path?: string;
    }): string;
    navigateToApp(appId: string, options?: {
        path?: string;
        state?: any;
    }): void;
    // @deprecated
    registerMountContext<T extends keyof AppMountContext>(contextName: T, provider: IContextProvider<AppMountDeprecated, T>): void;
}

// @public
export type AppMount = (params: AppMountParameters) => AppUnmount | Promise<AppUnmount>;

// @public @deprecated
export interface AppMountContext {
    core: {
        application: Pick<ApplicationStart, 'capabilities' | 'navigateToApp'>;
        chrome: ChromeStart;
        docLinks: DocLinksStart;
        http: HttpStart;
        i18n: I18nStart;
        notifications: NotificationsStart;
        overlays: OverlayStart;
        savedObjects: SavedObjectsStart;
        uiSettings: IUiSettingsClient;
        injectedMetadata: {
            getInjectedVar: (name: string, defaultValue?: any) => unknown;
        };
    };
}

// @public @deprecated
export type AppMountDeprecated = (context: AppMountContext, params: AppMountParameters) => AppUnmount | Promise<AppUnmount>;

// @public (undocumented)
export interface AppMountParameters {
    appBasePath: string;
    element: HTMLElement;
}

// @public
export enum AppNavLinkStatus {
    default = 0,
    disabled = 2,
    hidden = 3,
    visible = 1
}

// @public
export enum AppStatus {
    accessible = 0,
    inaccessible = 2
}

// @public
export type AppUnmount = () => void;

// @public
export type AppUpdatableFields = Pick<AppBase, 'status' | 'navLinkStatus' | 'tooltip'>;

// @public
export type AppUpdater = (app: AppBase) => Partial<AppUpdatableFields> | undefined;

// @public
export interface Capabilities {
    [key: string]: Record<string, boolean | Record<string, boolean>>;
    catalogue: Record<string, boolean>;
    management: {
        [sectionId: string]: Record<string, boolean>;
    };
    navLinks: Record<string, boolean>;
}

// @public (undocumented)
export interface ChromeBadge {
    // (undocumented)
    iconType?: IconType;
    // (undocumented)
    text: string;
    // (undocumented)
    tooltip: string;
}

// @public (undocumented)
export interface ChromeBrand {
    // (undocumented)
    logo?: string;
    // (undocumented)
    smallLogo?: string;
}

// @public (undocumented)
export type ChromeBreadcrumb = Breadcrumb;

// @public
export interface ChromeDocTitle {
    // @internal (undocumented)
    __legacy: {
        setBaseTitle(baseTitle: string): void;
    };
    change(newTitle: string | string[]): void;
    reset(): void;
}

// @public (undocumented)
export interface ChromeHelpExtension {
    appName: string;
    content?: (element: HTMLDivElement) => () => void;
    links?: ChromeHelpExtensionMenuLink[];
}

// @public (undocumented)
export type ChromeHelpExtensionMenuCustomLink = EuiButtonEmptyProps & {
    linkType: 'custom';
    content: React.ReactNode;
};

// @public (undocumented)
export type ChromeHelpExtensionMenuDiscussLink = EuiButtonEmptyProps & {
    linkType: 'discuss';
    href: string;
};

// @public (undocumented)
export type ChromeHelpExtensionMenuDocumentationLink = EuiButtonEmptyProps & {
    linkType: 'documentation';
    href: string;
};

// @public (undocumented)
export type ChromeHelpExtensionMenuGitHubLink = EuiButtonEmptyProps & {
    linkType: 'github';
    labels: string[];
    title?: string;
};

// @public (undocumented)
export type ChromeHelpExtensionMenuLink = ExclusiveUnion<ChromeHelpExtensionMenuGitHubLink, ExclusiveUnion<ChromeHelpExtensionMenuDiscussLink, ExclusiveUnion<ChromeHelpExtensionMenuDocumentationLink, ChromeHelpExtensionMenuCustomLink>>>;

// @public (undocumented)
export interface ChromeNavControl {
    // (undocumented)
    mount: MountPoint;
    // (undocumented)
    order?: number;
}

// @public
export interface ChromeNavControls {
    // @internal (undocumented)
    getLeft$(): Observable<ChromeNavControl[]>;
    // @internal (undocumented)
    getRight$(): Observable<ChromeNavControl[]>;
    registerLeft(navControl: ChromeNavControl): void;
    registerRight(navControl: ChromeNavControl): void;
}

// @public (undocumented)
export interface ChromeNavLink {
    // @deprecated
    readonly active?: boolean;
    readonly baseUrl: string;
    // @deprecated
    readonly disabled?: boolean;
    readonly euiIconType?: string;
    readonly hidden?: boolean;
    readonly icon?: string;
    readonly id: string;
    // @internal
    readonly legacy: boolean;
    // @deprecated
    readonly linkToLastSubUrl?: boolean;
    readonly order?: number;
    // @deprecated
    readonly subUrlBase?: string;
    readonly title: string;
    readonly tooltip?: string;
    // @deprecated
    readonly url?: string;
}

// @public
export interface ChromeNavLinks {
    enableForcedAppSwitcherNavigation(): void;
    get(id: string): ChromeNavLink | undefined;
    getAll(): Array<Readonly<ChromeNavLink>>;
    getForceAppSwitcherNavigation$(): Observable<boolean>;
    getNavLinks$(): Observable<Array<Readonly<ChromeNavLink>>>;
    has(id: string): boolean;
    showOnly(id: string): void;
    update(id: string, values: ChromeNavLinkUpdateableFields): ChromeNavLink | undefined;
}

// @public (undocumented)
export type ChromeNavLinkUpdateableFields = Partial<Pick<ChromeNavLink, 'active' | 'disabled' | 'hidden' | 'url' | 'subUrlBase'>>;

// @public
export interface ChromeRecentlyAccessed {
    // Warning: (ae-unresolved-link) The @link reference could not be resolved: No member was found with name "basePath"
    add(link: string, label: string, id: string): void;
    get$(): Observable<ChromeRecentlyAccessedHistoryItem[]>;
    get(): ChromeRecentlyAccessedHistoryItem[];
}

// @public (undocumented)
export interface ChromeRecentlyAccessedHistoryItem {
    // (undocumented)
    id: string;
    // (undocumented)
    label: string;
    // (undocumented)
    link: string;
}

// @public
export interface ChromeStart {
    addApplicationClass(className: string): void;
    docTitle: ChromeDocTitle;
    getApplicationClasses$(): Observable<string[]>;
    getBadge$(): Observable<ChromeBadge | undefined>;
    getBrand$(): Observable<ChromeBrand>;
    getBreadcrumbs$(): Observable<ChromeBreadcrumb[]>;
    getHelpExtension$(): Observable<ChromeHelpExtension | undefined>;
    getIsCollapsed$(): Observable<boolean>;
    getIsVisible$(): Observable<boolean>;
    navControls: ChromeNavControls;
    navLinks: ChromeNavLinks;
    recentlyAccessed: ChromeRecentlyAccessed;
    removeApplicationClass(className: string): void;
    setAppTitle(appTitle: string): void;
    setBadge(badge?: ChromeBadge): void;
    setBrand(brand: ChromeBrand): void;
    setBreadcrumbs(newBreadcrumbs: ChromeBreadcrumb[]): void;
    setHelpExtension(helpExtension?: ChromeHelpExtension): void;
    setHelpSupportUrl(url: string): void;
    setIsCollapsed(isCollapsed: boolean): void;
    setIsVisible(isVisible: boolean): void;
}

// @public
export interface ContextSetup {
    createContextContainer<THandler extends HandlerFunction<any>>(): IContextContainer<THandler>;
}

// @internal (undocumented)
export interface CoreContext {
    // Warning: (ae-forgotten-export) The symbol "CoreId" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    coreId: CoreId;
    // (undocumented)
    env: {
        mode: Readonly<EnvironmentMode>;
        packageInfo: Readonly<PackageInfo>;
    };
}

// @public
export interface CoreSetup<TPluginsStart extends object = object> {
    // (undocumented)
    application: ApplicationSetup;
    // @deprecated (undocumented)
    context: ContextSetup;
    // (undocumented)
    fatalErrors: FatalErrorsSetup;
    getStartServices(): Promise<[CoreStart, TPluginsStart]>;
    // (undocumented)
    http: HttpSetup;
    // @deprecated
    injectedMetadata: {
        getInjectedVar: (name: string, defaultValue?: any) => unknown;
    };
    // (undocumented)
    notifications: NotificationsSetup;
    // (undocumented)
    uiSettings: IUiSettingsClient;
}

// @public
export interface CoreStart {
    // (undocumented)
    application: ApplicationStart;
    // (undocumented)
    chrome: ChromeStart;
    // (undocumented)
    docLinks: DocLinksStart;
    // (undocumented)
    http: HttpStart;
    // (undocumented)
    i18n: I18nStart;
    // @deprecated
    injectedMetadata: {
        getInjectedVar: (name: string, defaultValue?: any) => unknown;
    };
    // (undocumented)
    notifications: NotificationsStart;
    // (undocumented)
    overlays: OverlayStart;
    // (undocumented)
    savedObjects: SavedObjectsStart;
    // (undocumented)
    uiSettings: IUiSettingsClient;
}

// @internal
export class CoreSystem {
    // Warning: (ae-forgotten-export) The symbol "Params" needs to be exported by the entry point index.d.ts
    constructor(params: Params);
    // (undocumented)
    setup(): Promise<{
        fatalErrors: FatalErrorsSetup;
    } | undefined>;
    // (undocumented)
    start(): Promise<void>;
    // (undocumented)
    stop(): void;
    }

// @public (undocumented)
export interface DocLinksStart {
    // (undocumented)
    readonly DOC_LINK_VERSION: string;
    // (undocumented)
    readonly ELASTIC_WEBSITE_URL: string;
    // (undocumented)
    readonly links: {
        readonly filebeat: {
            readonly base: string;
            readonly installation: string;
            readonly configuration: string;
            readonly elasticsearchOutput: string;
            readonly startup: string;
            readonly exportedFields: string;
        };
        readonly auditbeat: {
            readonly base: string;
        };
        readonly metricbeat: {
            readonly base: string;
        };
        readonly heartbeat: {
            readonly base: string;
        };
        readonly logstash: {
            readonly base: string;
        };
        readonly functionbeat: {
            readonly base: string;
        };
        readonly winlogbeat: {
            readonly base: string;
        };
        readonly aggs: {
            readonly date_histogram: string;
            readonly date_range: string;
            readonly filter: string;
            readonly filters: string;
            readonly geohash_grid: string;
            readonly histogram: string;
            readonly ip_range: string;
            readonly range: string;
            readonly significant_terms: string;
            readonly terms: string;
            readonly avg: string;
            readonly avg_bucket: string;
            readonly max_bucket: string;
            readonly min_bucket: string;
            readonly sum_bucket: string;
            readonly cardinality: string;
            readonly count: string;
            readonly cumulative_sum: string;
            readonly derivative: string;
            readonly geo_bounds: string;
            readonly geo_centroid: string;
            readonly max: string;
            readonly median: string;
            readonly min: string;
            readonly moving_avg: string;
            readonly percentile_ranks: string;
            readonly serial_diff: string;
            readonly std_dev: string;
            readonly sum: string;
            readonly top_hits: string;
        };
        readonly scriptedFields: {
            readonly scriptFields: string;
            readonly scriptAggs: string;
            readonly painless: string;
            readonly painlessApi: string;
            readonly painlessSyntax: string;
            readonly luceneExpressions: string;
        };
        readonly indexPatterns: {
            readonly loadingData: string;
            readonly introduction: string;
        };
        readonly kibana: string;
        readonly siem: string;
        readonly query: {
            readonly luceneQuerySyntax: string;
            readonly queryDsl: string;
            readonly kueryQuerySyntax: string;
        };
        readonly date: {
            readonly dateMath: string;
        };
    };
}

// @public (undocumented)
export interface EnvironmentMode {
    // (undocumented)
    dev: boolean;
    // (undocumented)
    name: 'development' | 'production';
    // (undocumented)
    prod: boolean;
}

// @public
export interface ErrorToastOptions {
    title: string;
    toastMessage?: string;
}

// @public
export interface FatalErrorInfo {
    // (undocumented)
    message: string;
    // (undocumented)
    stack: string | undefined;
}

// @public
export interface FatalErrorsSetup {
    add: (error: string | Error, source?: string) => never;
    get$: () => Rx.Observable<FatalErrorInfo>;
}

// @public
export type HandlerContextType<T extends HandlerFunction<any>> = T extends HandlerFunction<infer U> ? U : never;

// @public
export type HandlerFunction<T extends object> = (context: T, ...args: any[]) => any;

// @public
export type HandlerParameters<T extends HandlerFunction<any>> = T extends (context: any, ...args: infer U) => any ? U : never;

// @public (undocumented)
export interface HttpErrorRequest {
    // (undocumented)
    error: Error;
    // (undocumented)
    request: Request;
}

// @public (undocumented)
export interface HttpErrorResponse extends IHttpResponse {
    // (undocumented)
    error: Error | IHttpFetchError;
}

// @public
export interface HttpFetchOptions extends HttpRequestInit {
    asResponse?: boolean;
    headers?: HttpHeadersInit;
    prependBasePath?: boolean;
    query?: HttpFetchQuery;
}

// @public (undocumented)
export interface HttpFetchQuery {
    // (undocumented)
    [key: string]: string | number | boolean | undefined;
}

// @public
export interface HttpHandler {
    // (undocumented)
    <TResponseBody = any>(path: string, options: HttpFetchOptions & {
        asResponse: true;
    }): Promise<IHttpResponse<TResponseBody>>;
    // (undocumented)
    <TResponseBody = any>(path: string, options?: HttpFetchOptions): Promise<TResponseBody>;
}

// @public (undocumented)
export interface HttpHeadersInit {
    // (undocumented)
    [name: string]: any;
}

// @public
export interface HttpInterceptor {
    request?(request: Request, controller: IHttpInterceptController): Promise<Request> | Request | void;
    requestError?(httpErrorRequest: HttpErrorRequest, controller: IHttpInterceptController): Promise<Request> | Request | void;
    response?(httpResponse: IHttpResponse, controller: IHttpInterceptController): Promise<IHttpResponseInterceptorOverrides> | IHttpResponseInterceptorOverrides | void;
    responseError?(httpErrorResponse: HttpErrorResponse, controller: IHttpInterceptController): Promise<IHttpResponseInterceptorOverrides> | IHttpResponseInterceptorOverrides | void;
}

// @public
export interface HttpRequestInit {
    body?: BodyInit | null;
    cache?: RequestCache;
    credentials?: RequestCredentials;
    // (undocumented)
    headers?: HttpHeadersInit;
    integrity?: string;
    keepalive?: boolean;
    method?: string;
    mode?: RequestMode;
    redirect?: RequestRedirect;
    referrer?: string;
    referrerPolicy?: ReferrerPolicy;
    signal?: AbortSignal | null;
    window?: null;
}

// @public (undocumented)
export interface HttpSetup {
    addLoadingCountSource(countSource$: Observable<number>): void;
    anonymousPaths: IAnonymousPaths;
    basePath: IBasePath;
    delete: HttpHandler;
    fetch: HttpHandler;
    get: HttpHandler;
    getLoadingCount$(): Observable<number>;
    head: HttpHandler;
    intercept(interceptor: HttpInterceptor): () => void;
    options: HttpHandler;
    patch: HttpHandler;
    post: HttpHandler;
    put: HttpHandler;
}

// @public
export type HttpStart = HttpSetup;

// @public
export interface I18nStart {
    Context: ({ children }: {
        children: React.ReactNode;
    }) => JSX.Element;
}

// Warning: (ae-missing-release-tag) "IAnonymousPaths" is exported by the package, but it is missing a release tag (@alpha, @beta, @public, or @internal)
//
// @public
export interface IAnonymousPaths {
    isAnonymous(path: string): boolean;
    register(path: string): void;
}

// @public
export interface IBasePath {
    get: () => string;
    prepend: (url: string) => string;
    remove: (url: string) => string;
}

// @public
export interface IContextContainer<THandler extends HandlerFunction<any>> {
    createHandler(pluginOpaqueId: PluginOpaqueId, handler: THandler): (...rest: HandlerParameters<THandler>) => ShallowPromise<ReturnType<THandler>>;
    registerContext<TContextName extends keyof HandlerContextType<THandler>>(pluginOpaqueId: PluginOpaqueId, contextName: TContextName, provider: IContextProvider<THandler, TContextName>): this;
}

// @public
export type IContextProvider<THandler extends HandlerFunction<any>, TContextName extends keyof HandlerContextType<THandler>> = (context: Partial<HandlerContextType<THandler>>, ...rest: HandlerParameters<THandler>) => Promise<HandlerContextType<THandler>[TContextName]> | HandlerContextType<THandler>[TContextName];

// @public (undocumented)
export interface IHttpFetchError extends Error {
    // (undocumented)
    readonly body?: any;
    // @deprecated (undocumented)
    readonly req: Request;
    // (undocumented)
    readonly request: Request;
    // @deprecated (undocumented)
    readonly res?: Response;
    // (undocumented)
    readonly response?: Response;
}

// @public
export interface IHttpInterceptController {
    halt(): void;
    halted: boolean;
}

// @public (undocumented)
export interface IHttpResponse<TResponseBody = any> {
    readonly body?: TResponseBody;
    readonly request: Readonly<Request>;
    readonly response?: Readonly<Response>;
}

// @public
export interface IHttpResponseInterceptorOverrides<TResponseBody = any> {
    readonly body?: TResponseBody;
    readonly response?: Readonly<Response>;
}

// @public
export type IToasts = Pick<ToastsApi, 'get$' | 'add' | 'remove' | 'addSuccess' | 'addWarning' | 'addDanger' | 'addError'>;

// @public
export interface IUiSettingsClient {
    get$: <T = any>(key: string, defaultOverride?: T) => Observable<T>;
    get: <T = any>(key: string, defaultOverride?: T) => T;
    getAll: () => Readonly<Record<string, UiSettingsParams_2 & UserProvidedValues_2>>;
    getSaved$: <T = any>() => Observable<{
        key: string;
        newValue: T;
        oldValue: T;
    }>;
    getUpdate$: <T = any>() => Observable<{
        key: string;
        newValue: T;
        oldValue: T;
    }>;
    getUpdateErrors$: () => Observable<Error>;
    isCustom: (key: string) => boolean;
    isDeclared: (key: string) => boolean;
    isDefault: (key: string) => boolean;
    isOverridden: (key: string) => boolean;
    overrideLocalDefault: (key: string, newDefault: any) => void;
    remove: (key: string) => Promise<boolean>;
    set: (key: string, value: any) => Promise<boolean>;
}

// @public @deprecated
export interface LegacyCoreSetup extends CoreSetup<any> {
    // Warning: (ae-forgotten-export) The symbol "InjectedMetadataSetup" needs to be exported by the entry point index.d.ts
    //
    // @deprecated (undocumented)
    injectedMetadata: InjectedMetadataSetup;
}

// @public @deprecated
export interface LegacyCoreStart extends CoreStart {
    // Warning: (ae-forgotten-export) The symbol "InjectedMetadataStart" needs to be exported by the entry point index.d.ts
    //
    // @deprecated (undocumented)
    injectedMetadata: InjectedMetadataStart;
}

// @public (undocumented)
export interface LegacyNavLink {
    // (undocumented)
    euiIconType?: string;
    // (undocumented)
    icon?: string;
    // (undocumented)
    id: string;
    // (undocumented)
    order: number;
    // (undocumented)
    title: string;
    // (undocumented)
    url: string;
}

// @public
export type MountPoint<T extends HTMLElement = HTMLElement> = (element: T) => UnmountCallback;

// @public (undocumented)
export interface NotificationsSetup {
    // (undocumented)
    toasts: ToastsSetup;
}

// @public (undocumented)
export interface NotificationsStart {
    // (undocumented)
    toasts: ToastsStart;
}

// @public (undocumented)
export interface OverlayBannersStart {
    add(mount: MountPoint, priority?: number): string;
    // Warning: (ae-forgotten-export) The symbol "OverlayBanner" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    get$(): Observable<OverlayBanner[]>;
    // (undocumented)
    getComponent(): JSX.Element;
    remove(id: string): boolean;
    replace(id: string | undefined, mount: MountPoint, priority?: number): string;
}

// @public
export interface OverlayRef {
    close(): Promise<void>;
    onClose: Promise<void>;
}

// @public (undocumented)
export interface OverlayStart {
    // (undocumented)
    banners: OverlayBannersStart;
    // Warning: (ae-forgotten-export) The symbol "OverlayFlyoutStart" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    openFlyout: OverlayFlyoutStart['open'];
    // Warning: (ae-forgotten-export) The symbol "OverlayModalStart" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    openModal: OverlayModalStart['open'];
}

// @public (undocumented)
export interface PackageInfo {
    // (undocumented)
    branch: string;
    // (undocumented)
    buildNum: number;
    // (undocumented)
    buildSha: string;
    // (undocumented)
    dist: boolean;
    // (undocumented)
    version: string;
}

// @public
export interface Plugin<TSetup = void, TStart = void, TPluginsSetup extends object = object, TPluginsStart extends object = object> {
    // (undocumented)
    setup(core: CoreSetup<TPluginsStart>, plugins: TPluginsSetup): TSetup | Promise<TSetup>;
    // (undocumented)
    start(core: CoreStart, plugins: TPluginsStart): TStart | Promise<TStart>;
    // (undocumented)
    stop?(): void;
}

// @public
export type PluginInitializer<TSetup, TStart, TPluginsSetup extends object = object, TPluginsStart extends object = object> = (core: PluginInitializerContext) => Plugin<TSetup, TStart, TPluginsSetup, TPluginsStart>;

// @public
export interface PluginInitializerContext<ConfigSchema extends object = object> {
    // (undocumented)
    readonly config: {
        get: <T extends object = ConfigSchema>() => T;
    };
    // (undocumented)
    readonly env: {
        mode: Readonly<EnvironmentMode>;
        packageInfo: Readonly<PackageInfo>;
    };
    readonly opaqueId: PluginOpaqueId;
}

// @public (undocumented)
export type PluginOpaqueId = symbol;

// Warning: (ae-forgotten-export) The symbol "RecursiveReadonlyArray" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type RecursiveReadonly<T> = T extends (...args: any[]) => any ? T : T extends any[] ? RecursiveReadonlyArray<T[number]> : T extends object ? Readonly<{
    [K in keyof T]: RecursiveReadonly<T[K]>;
}> : T;

// @public (undocumented)
export interface SavedObject<T extends SavedObjectAttributes = any> {
    attributes: T;
    // (undocumented)
    error?: {
        message: string;
        statusCode: number;
    };
    id: string;
    migrationVersion?: SavedObjectsMigrationVersion;
    references: SavedObjectReference[];
    type: string;
    updated_at?: string;
    version?: string;
}

// @public
export type SavedObjectAttribute = SavedObjectAttributeSingle | SavedObjectAttributeSingle[];

// @public
export interface SavedObjectAttributes {
    // (undocumented)
    [key: string]: SavedObjectAttribute;
}

// @public
export type SavedObjectAttributeSingle = string | number | boolean | null | undefined | SavedObjectAttributes;

// @public
export interface SavedObjectReference {
    // (undocumented)
    id: string;
    // (undocumented)
    name: string;
    // (undocumented)
    type: string;
}

// @public (undocumented)
export interface SavedObjectsBaseOptions {
    namespace?: string;
}

// @public (undocumented)
export interface SavedObjectsBatchResponse<T extends SavedObjectAttributes = SavedObjectAttributes> {
    // (undocumented)
    savedObjects: Array<SimpleSavedObject<T>>;
}

// @public (undocumented)
export interface SavedObjectsBulkCreateObject<T extends SavedObjectAttributes = SavedObjectAttributes> extends SavedObjectsCreateOptions {
    // (undocumented)
    attributes: T;
    // (undocumented)
    type: string;
}

// @public (undocumented)
export interface SavedObjectsBulkCreateOptions {
    overwrite?: boolean;
}

// @public (undocumented)
export interface SavedObjectsBulkUpdateObject<T extends SavedObjectAttributes = SavedObjectAttributes> {
    // (undocumented)
    attributes: T;
    // (undocumented)
    id: string;
    // (undocumented)
    references?: SavedObjectReference[];
    // (undocumented)
    type: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface SavedObjectsBulkUpdateOptions {
    // (undocumented)
    namespace?: string;
}

// @public
export class SavedObjectsClient {
    // @internal
    constructor(http: HttpSetup);
    bulkCreate: (objects?: SavedObjectsBulkCreateObject<SavedObjectAttributes>[], options?: SavedObjectsBulkCreateOptions) => Promise<SavedObjectsBatchResponse<SavedObjectAttributes>>;
    bulkGet: (objects?: {
        id: string;
        type: string;
    }[]) => Promise<SavedObjectsBatchResponse<SavedObjectAttributes>>;
    bulkUpdate<T extends SavedObjectAttributes>(objects?: SavedObjectsBulkUpdateObject[]): Promise<SavedObjectsBatchResponse<SavedObjectAttributes>>;
    create: <T extends SavedObjectAttributes>(type: string, attributes: T, options?: SavedObjectsCreateOptions) => Promise<SimpleSavedObject<T>>;
    delete: (type: string, id: string) => Promise<{}>;
    find: <T extends SavedObjectAttributes>(options: Pick<SavedObjectsFindOptions, "search" | "filter" | "type" | "page" | "perPage" | "sortField" | "fields" | "searchFields" | "hasReference" | "defaultSearchOperator">) => Promise<SavedObjectsFindResponsePublic<T>>;
    get: <T extends SavedObjectAttributes>(type: string, id: string) => Promise<SimpleSavedObject<T>>;
    update<T extends SavedObjectAttributes>(type: string, id: string, attributes: T, { version, migrationVersion, references }?: SavedObjectsUpdateOptions): Promise<SimpleSavedObject<T>>;
}

// @public
export type SavedObjectsClientContract = PublicMethodsOf<SavedObjectsClient>;

// @public (undocumented)
export interface SavedObjectsCreateOptions {
    id?: string;
    migrationVersion?: SavedObjectsMigrationVersion;
    overwrite?: boolean;
    // (undocumented)
    references?: SavedObjectReference[];
}

// @public (undocumented)
export interface SavedObjectsFindOptions extends SavedObjectsBaseOptions {
    // (undocumented)
    defaultSearchOperator?: 'AND' | 'OR';
    fields?: string[];
    // (undocumented)
    filter?: string;
    // (undocumented)
    hasReference?: {
        type: string;
        id: string;
    };
    // (undocumented)
    page?: number;
    // (undocumented)
    perPage?: number;
    search?: string;
    searchFields?: string[];
    // (undocumented)
    sortField?: string;
    // (undocumented)
    sortOrder?: string;
    // (undocumented)
    type: string | string[];
}

// @public
export interface SavedObjectsFindResponsePublic<T extends SavedObjectAttributes = SavedObjectAttributes> extends SavedObjectsBatchResponse<T> {
    // (undocumented)
    page: number;
    // (undocumented)
    perPage: number;
    // (undocumented)
    total: number;
}

// @public
export interface SavedObjectsImportConflictError {
    // (undocumented)
    type: 'conflict';
}

// @public
export interface SavedObjectsImportError {
    // (undocumented)
    error: SavedObjectsImportConflictError | SavedObjectsImportUnsupportedTypeError | SavedObjectsImportMissingReferencesError | SavedObjectsImportUnknownError;
    // (undocumented)
    id: string;
    // (undocumented)
    title?: string;
    // (undocumented)
    type: string;
}

// @public
export interface SavedObjectsImportMissingReferencesError {
    // (undocumented)
    blocking: Array<{
        type: string;
        id: string;
    }>;
    // (undocumented)
    references: Array<{
        type: string;
        id: string;
    }>;
    // (undocumented)
    type: 'missing_references';
}

// @public
export interface SavedObjectsImportResponse {
    // (undocumented)
    errors?: SavedObjectsImportError[];
    // (undocumented)
    success: boolean;
    // (undocumented)
    successCount: number;
}

// @public
export interface SavedObjectsImportRetry {
    // (undocumented)
    id: string;
    // (undocumented)
    overwrite: boolean;
    // (undocumented)
    replaceReferences: Array<{
        type: string;
        from: string;
        to: string;
    }>;
    // (undocumented)
    type: string;
}

// @public
export interface SavedObjectsImportUnknownError {
    // (undocumented)
    message: string;
    // (undocumented)
    statusCode: number;
    // (undocumented)
    type: 'unknown';
}

// @public
export interface SavedObjectsImportUnsupportedTypeError {
    // (undocumented)
    type: 'unsupported_type';
}

// @public
export interface SavedObjectsMigrationVersion {
    // (undocumented)
    [pluginName: string]: string;
}

// @public (undocumented)
export interface SavedObjectsStart {
    // (undocumented)
    client: SavedObjectsClientContract;
}

// @public (undocumented)
export interface SavedObjectsUpdateOptions {
    migrationVersion?: SavedObjectsMigrationVersion;
    // (undocumented)
    references?: SavedObjectReference[];
    // (undocumented)
    version?: string;
}

// @public
export class SimpleSavedObject<T extends SavedObjectAttributes> {
    constructor(client: SavedObjectsClient, { id, type, version, attributes, error, references, migrationVersion }: SavedObject<T>);
    // (undocumented)
    attributes: T;
    // (undocumented)
    delete(): Promise<{}>;
    // (undocumented)
    error: SavedObject<T>['error'];
    // (undocumented)
    get(key: string): any;
    // (undocumented)
    has(key: string): boolean;
    // (undocumented)
    id: SavedObject<T>['id'];
    // (undocumented)
    migrationVersion: SavedObject<T>['migrationVersion'];
    // (undocumented)
    references: SavedObject<T>['references'];
    // (undocumented)
    save(): Promise<SimpleSavedObject<T>>;
    // (undocumented)
    set(key: string, value: any): T;
    // (undocumented)
    type: SavedObject<T>['type'];
    // (undocumented)
    _version?: SavedObject<T>['version'];
}

// Warning: (ae-missing-release-tag) "Toast" is exported by the package, but it is missing a release tag (@alpha, @beta, @public, or @internal)
//
// @public (undocumented)
export type Toast = ToastInputFields & {
    id: string;
};

// @public
export type ToastInput = string | ToastInputFields;

// @public
export type ToastInputFields = Pick<EuiGlobalToastListToast, Exclude<keyof EuiGlobalToastListToast, 'id' | 'text' | 'title'>> & {
    title?: string | MountPoint;
    text?: string | MountPoint;
};

// @public
export class ToastsApi implements IToasts {
    constructor(deps: {
        uiSettings: IUiSettingsClient;
    });
    add(toastOrTitle: ToastInput): Toast;
    addDanger(toastOrTitle: ToastInput): Toast;
    addError(error: Error, options: ErrorToastOptions): Toast;
    addSuccess(toastOrTitle: ToastInput): Toast;
    addWarning(toastOrTitle: ToastInput): Toast;
    get$(): Rx.Observable<Toast[]>;
    remove(toastOrId: Toast | string): void;
    // @internal (undocumented)
    start({ overlays, i18n }: {
        overlays: OverlayStart;
        i18n: I18nStart;
    }): void;
    }

// @public (undocumented)
export type ToastsSetup = IToasts;

// @public (undocumented)
export type ToastsStart = IToasts;

// @public (undocumented)
export interface UiSettingsState {
    // (undocumented)
    [key: string]: UiSettingsParams_2 & UserProvidedValues_2;
}

// @public
export type UnmountCallback = () => void;


```
