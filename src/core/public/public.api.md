## API Report File for "kibana"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IconType } from '@elastic/eui';
import { Observable } from 'rxjs';
import React from 'react';
import * as Rx from 'rxjs';
import { EuiGlobalToastListToast as Toast } from '@elastic/eui';

// @public (undocumented)
export interface ApplicationSetup {
    // Warning: (ae-forgotten-export) The symbol "App" needs to be exported by the entry point index.d.ts
    registerApp(app: App): void;
    // Warning: (ae-forgotten-export) The symbol "LegacyApp" needs to be exported by the entry point index.d.ts
    // 
    // @internal
    registerLegacyApp(app: LegacyApp): void;
}

// Warning: (ae-missing-release-tag) "ApplicationStart" is exported by the package, but it is missing a release tag (@alpha, @beta, @public, or @internal)
// 
// @public (undocumented)
export interface ApplicationStart {
    // Warning: (ae-forgotten-export) The symbol "CapabilitiesStart" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    availableApps: CapabilitiesStart['availableApps'];
    // (undocumented)
    capabilities: CapabilitiesStart['capabilities'];
    // (undocumented)
    mount: (mountHandler: Function) => void;
}

// @public
export interface Capabilities {
    [key: string]: Record<string, boolean | Record<string, boolean>>;
    catalogue: Record<string, boolean>;
    management: {
        [sectionId: string]: Record<string, boolean>;
    };
    navLinks: Record<string, boolean>;
}

// @public (undocumented)
export interface ChromeBadge {
    // (undocumented)
    iconType?: IconType;
    // (undocumented)
    text: string;
    // (undocumented)
    tooltip: string;
}

// @public (undocumented)
export interface ChromeBrand {
    // (undocumented)
    logo?: string;
    // (undocumented)
    smallLogo?: string;
}

// @public (undocumented)
export interface ChromeBreadcrumb {
    // (undocumented)
    'data-test-subj'?: string;
    // (undocumented)
    href?: string;
    // (undocumented)
    text: string;
}

// @public (undocumented)
export type ChromeHelpExtension = (element: HTMLDivElement) => () => void;

// @public (undocumented)
export interface ChromeNavControl {
    // (undocumented)
    mount(targetDomElement: HTMLElement): () => void;
    // (undocumented)
    order?: number;
}

// @public
export interface ChromeNavControls {
    // @internal (undocumented)
    getLeft$(): Observable<ChromeNavControl[]>;
    // @internal (undocumented)
    getRight$(): Observable<ChromeNavControl[]>;
    registerLeft(navControl: ChromeNavControl): void;
    registerRight(navControl: ChromeNavControl): void;
}

// @public (undocumented)
export interface ChromeNavLink {
    readonly active?: boolean;
    readonly baseUrl: string;
    readonly disabled?: boolean;
    readonly euiIconType?: string;
    readonly hidden?: boolean;
    readonly icon?: string;
    readonly id: string;
    readonly linkToLastSubUrl?: boolean;
    readonly order: number;
    readonly subUrlBase?: string;
    readonly title: string;
    readonly tooltip?: string;
    readonly url?: string;
}

// @public
export interface ChromeNavLinks {
    enableForcedAppSwitcherNavigation(): void;
    get(id: string): ChromeNavLink | undefined;
    getAll(): Array<Readonly<ChromeNavLink>>;
    getForceAppSwitcherNavigation$(): Observable<boolean>;
    getNavLinks$(): Observable<Array<Readonly<ChromeNavLink>>>;
    has(id: string): boolean;
    showOnly(id: string): void;
    update(id: string, values: ChromeNavLinkUpdateableFields): ChromeNavLink | undefined;
}

// @public (undocumented)
export type ChromeNavLinkUpdateableFields = Partial<Pick<ChromeNavLink, 'active' | 'disabled' | 'hidden' | 'url' | 'subUrlBase'>>;

// @public
export interface ChromeRecentlyAccessed {
    // Warning: (ae-unresolved-link) The @link reference could not be resolved: No member was found with name "basePath"
    add(link: string, label: string, id: string): void;
    get$(): Observable<ChromeRecentlyAccessedHistoryItem[]>;
    get(): ChromeRecentlyAccessedHistoryItem[];
}

// @public (undocumented)
export interface ChromeRecentlyAccessedHistoryItem {
    // (undocumented)
    id: string;
    // (undocumented)
    label: string;
    // (undocumented)
    link: string;
}

// @public
export interface ChromeStart {
    addApplicationClass(className: string): void;
    getApplicationClasses$(): Observable<string[]>;
    getBadge$(): Observable<ChromeBadge | undefined>;
    getBrand$(): Observable<ChromeBrand>;
    getBreadcrumbs$(): Observable<ChromeBreadcrumb[]>;
    getHelpExtension$(): Observable<ChromeHelpExtension | undefined>;
    getIsCollapsed$(): Observable<boolean>;
    getIsVisible$(): Observable<boolean>;
    navControls: ChromeNavControls;
    navLinks: ChromeNavLinks;
    recentlyAccessed: ChromeRecentlyAccessed;
    removeApplicationClass(className: string): void;
    setAppTitle(appTitle: string): void;
    setBadge(badge?: ChromeBadge): void;
    setBrand(brand: ChromeBrand): void;
    setBreadcrumbs(newBreadcrumbs: ChromeBreadcrumb[]): void;
    setHelpExtension(helpExtension?: ChromeHelpExtension): void;
    setIsCollapsed(isCollapsed: boolean): void;
    setIsVisible(isVisible: boolean): void;
}

// @internal (undocumented)
export interface CoreContext {
}

// @public
export interface CoreSetup {
    // (undocumented)
    fatalErrors: FatalErrorsSetup;
    // (undocumented)
    http: HttpSetup;
    // (undocumented)
    notifications: NotificationsSetup;
    // (undocumented)
    uiSettings: UiSettingsClientContract;
}

// @public
export interface CoreStart {
    // (undocumented)
    application: Pick<ApplicationStart, 'capabilities'>;
    // (undocumented)
    chrome: ChromeStart;
    // (undocumented)
    docLinks: DocLinksStart;
    // (undocumented)
    http: HttpStart;
    // (undocumented)
    i18n: I18nStart;
    // (undocumented)
    notifications: NotificationsStart;
    // (undocumented)
    overlays: OverlayStart;
    // (undocumented)
    uiSettings: UiSettingsClientContract;
}

// @internal
export class CoreSystem {
    // Warning: (ae-forgotten-export) The symbol "Params" needs to be exported by the entry point index.d.ts
    constructor(params: Params);
    // (undocumented)
    setup(): Promise<{
        fatalErrors: FatalErrorsSetup;
    } | undefined>;
    // (undocumented)
    start(): Promise<void>;
    // (undocumented)
    stop(): void;
    }

// @public (undocumented)
export interface DocLinksStart {
    // (undocumented)
    readonly DOC_LINK_VERSION: string;
    // (undocumented)
    readonly ELASTIC_WEBSITE_URL: string;
    // (undocumented)
    readonly links: {
        readonly filebeat: {
            readonly base: string;
            readonly installation: string;
            readonly configuration: string;
            readonly elasticsearchOutput: string;
            readonly startup: string;
            readonly exportedFields: string;
        };
        readonly auditbeat: {
            readonly base: string;
        };
        readonly metricbeat: {
            readonly base: string;
        };
        readonly heartbeat: {
            readonly base: string;
        };
        readonly logstash: {
            readonly base: string;
        };
        readonly functionbeat: {
            readonly base: string;
        };
        readonly winlogbeat: {
            readonly base: string;
        };
        readonly aggs: {
            readonly date_histogram: string;
            readonly date_range: string;
            readonly filter: string;
            readonly filters: string;
            readonly geohash_grid: string;
            readonly histogram: string;
            readonly ip_range: string;
            readonly range: string;
            readonly significant_terms: string;
            readonly terms: string;
            readonly avg: string;
            readonly avg_bucket: string;
            readonly max_bucket: string;
            readonly min_bucket: string;
            readonly sum_bucket: string;
            readonly cardinality: string;
            readonly count: string;
            readonly cumulative_sum: string;
            readonly derivative: string;
            readonly geo_bounds: string;
            readonly geo_centroid: string;
            readonly max: string;
            readonly median: string;
            readonly min: string;
            readonly moving_avg: string;
            readonly percentile_ranks: string;
            readonly serial_diff: string;
            readonly std_dev: string;
            readonly sum: string;
            readonly top_hits: string;
        };
        readonly scriptedFields: {
            readonly scriptFields: string;
            readonly scriptAggs: string;
            readonly painless: string;
            readonly painlessApi: string;
            readonly painlessSyntax: string;
            readonly luceneExpressions: string;
        };
        readonly indexPatterns: {
            readonly loadingData: string;
            readonly introduction: string;
        };
        readonly kibana: string;
        readonly siem: string;
        readonly query: {
            readonly luceneQuerySyntax: string;
            readonly queryDsl: string;
            readonly kueryQuerySyntax: string;
        };
        readonly date: {
            readonly dateMath: string;
        };
    };
}

// Warning: (ae-missing-release-tag) "ErrorToastOptions" is exported by the package, but it is missing a release tag (@alpha, @beta, @public, or @internal)
// 
// @public (undocumented)
export interface ErrorToastOptions {
    title: string;
    toastMessage?: string;
}

// @public
export interface FatalErrorInfo {
    // (undocumented)
    message: string;
    // (undocumented)
    stack: string | undefined;
}

// @public
export interface FatalErrorsSetup {
    add: (error: string | Error, source?: string) => never;
    get$: () => Rx.Observable<FatalErrorInfo>;
}

// @public (undocumented)
export type HttpBody = BodyInit | null | any;

// @public (undocumented)
export interface HttpErrorRequest {
    // (undocumented)
    error: Error;
    // (undocumented)
    request?: Request;
}

// @public (undocumented)
export interface HttpErrorResponse extends HttpResponse {
    // Warning: (ae-forgotten-export) The symbol "HttpFetchError" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    error: Error | HttpFetchError;
}

// @public (undocumented)
export interface HttpFetchOptions extends HttpRequestInit {
    // (undocumented)
    headers?: HttpHeadersInit;
    // (undocumented)
    prependBasePath?: boolean;
    // (undocumented)
    query?: HttpFetchQuery;
}

// @public (undocumented)
export interface HttpFetchQuery {
    // (undocumented)
    [key: string]: string | number | boolean | undefined;
}

// @public (undocumented)
export type HttpHandler = (path: string, options?: HttpFetchOptions) => Promise<HttpBody>;

// @public (undocumented)
export interface HttpHeadersInit {
    // (undocumented)
    [name: string]: any;
}

// @public (undocumented)
export interface HttpInterceptor {
    // Warning: (ae-forgotten-export) The symbol "HttpInterceptController" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    request?(request: Request, controller: HttpInterceptController): Promise<Request> | Request | void;
    // (undocumented)
    requestError?(httpErrorRequest: HttpErrorRequest, controller: HttpInterceptController): Promise<Request> | Request | void;
    // (undocumented)
    response?(httpResponse: HttpResponse, controller: HttpInterceptController): Promise<HttpResponse> | HttpResponse | void;
    // (undocumented)
    responseError?(httpErrorResponse: HttpErrorResponse, controller: HttpInterceptController): Promise<HttpResponse> | HttpResponse | void;
}

// @public (undocumented)
export interface HttpRequestInit {
    // (undocumented)
    body?: BodyInit | null;
    // (undocumented)
    cache?: RequestCache;
    // (undocumented)
    credentials?: RequestCredentials;
    // (undocumented)
    headers?: HttpHeadersInit;
    // (undocumented)
    integrity?: string;
    // (undocumented)
    keepalive?: boolean;
    // (undocumented)
    method?: string;
    // (undocumented)
    mode?: RequestMode;
    // (undocumented)
    redirect?: RequestRedirect;
    // (undocumented)
    referrer?: string;
    // (undocumented)
    referrerPolicy?: ReferrerPolicy;
    // (undocumented)
    signal?: AbortSignal | null;
    // (undocumented)
    window?: any;
}

// @public (undocumented)
export interface HttpResponse {
    // (undocumented)
    body?: HttpBody;
    // (undocumented)
    request: Request;
    // (undocumented)
    response?: Response;
}

// @public (undocumented)
export interface HttpServiceBase {
    // (undocumented)
    addLoadingCount(count$: Observable<number>): void;
    // (undocumented)
    basePath: {
        get: () => string;
        prepend: (url: string) => string;
        remove: (url: string) => string;
    };
    // (undocumented)
    delete: HttpHandler;
    // (undocumented)
    fetch: HttpHandler;
    // (undocumented)
    get: HttpHandler;
    // (undocumented)
    getLoadingCount$(): Observable<number>;
    // (undocumented)
    head: HttpHandler;
    // (undocumented)
    intercept(interceptor: HttpInterceptor): () => void;
    // (undocumented)
    options: HttpHandler;
    // (undocumented)
    patch: HttpHandler;
    // (undocumented)
    post: HttpHandler;
    // (undocumented)
    put: HttpHandler;
    // (undocumented)
    removeAllInterceptors(): void;
    // (undocumented)
    stop(): void;
}

// @public (undocumented)
export type HttpSetup = HttpServiceBase;

// @public (undocumented)
export type HttpStart = HttpServiceBase;

// @public
export interface I18nStart {
    Context: ({ children }: {
        children: React.ReactNode;
    }) => JSX.Element;
}

// @internal (undocumented)
export interface InternalCoreSetup extends CoreSetup {
    // (undocumented)
    application: ApplicationSetup;
    // Warning: (ae-forgotten-export) The symbol "InjectedMetadataSetup" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    injectedMetadata: InjectedMetadataSetup;
}

// @internal (undocumented)
export interface InternalCoreStart extends CoreStart {
    // (undocumented)
    application: ApplicationStart;
    // Warning: (ae-forgotten-export) The symbol "InjectedMetadataStart" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    injectedMetadata: InjectedMetadataStart;
}

// @public (undocumented)
export interface LegacyNavLink {
    // (undocumented)
    euiIconType?: string;
    // (undocumented)
    icon?: string;
    // (undocumented)
    id: string;
    // (undocumented)
    order: number;
    // (undocumented)
    title: string;
    // (undocumented)
    url: string;
}

// @public (undocumented)
export interface NotificationsSetup {
    // Warning: (ae-forgotten-export) The symbol "ToastsSetup" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    toasts: ToastsSetup;
}

// @public (undocumented)
export interface NotificationsStart {
    // Warning: (ae-forgotten-export) The symbol "ToastsStart" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    toasts: ToastsStart;
}

// Warning: (ae-missing-release-tag) "OverlayRef" is exported by the package, but it is missing a release tag (@alpha, @beta, @public, or @internal)
// 
// @public (undocumented)
export interface OverlayRef {
    close(): Promise<void>;
    onClose: Promise<void>;
}

// @public (undocumented)
export interface OverlayStart {
    // (undocumented)
    openFlyout: (flyoutChildren: React.ReactNode, flyoutProps?: {
        closeButtonAriaLabel?: string;
        'data-test-subj'?: string;
    }) => OverlayRef;
    // (undocumented)
    openModal: (modalChildren: React.ReactNode, modalProps?: {
        closeButtonAriaLabel?: string;
        'data-test-subj'?: string;
    }) => OverlayRef;
}

// @public
export interface Plugin<TSetup = void, TStart = void, TPluginsSetup extends object = object, TPluginsStart extends object = object> {
    // (undocumented)
    setup(core: CoreSetup, plugins: TPluginsSetup): TSetup | Promise<TSetup>;
    // (undocumented)
    start(core: CoreStart, plugins: TPluginsStart): TStart | Promise<TStart>;
    // (undocumented)
    stop?(): void;
}

// @public
export type PluginInitializer<TSetup, TStart, TPluginsSetup extends object = object, TPluginsStart extends object = object> = (core: PluginInitializerContext) => Plugin<TSetup, TStart, TPluginsSetup, TPluginsStart>;

// @public
export interface PluginInitializerContext {
}

// Warning: (ae-forgotten-export) The symbol "RecursiveReadonlyArray" needs to be exported by the entry point index.d.ts
// 
// @public (undocumented)
export type RecursiveReadonly<T> = T extends (...args: any[]) => any ? T : T extends any[] ? RecursiveReadonlyArray<T[number]> : T extends object ? Readonly<{
    [K in keyof T]: RecursiveReadonly<T[K]>;
}> : T;

export { Toast }

// Warning: (ae-forgotten-export) The symbol "ToastInputFields" needs to be exported by the entry point index.d.ts
// 
// @public (undocumented)
export type ToastInput = string | ToastInputFields | Promise<ToastInputFields>;

// @public (undocumented)
export class ToastsApi {
    constructor(deps: {
        uiSettings: UiSettingsClientContract;
    });
    // (undocumented)
    add(toastOrTitle: ToastInput): Toast;
    // (undocumented)
    addDanger(toastOrTitle: ToastInput): Toast;
    // (undocumented)
    addError(error: Error, options: ErrorToastOptions): Toast;
    // (undocumented)
    addSuccess(toastOrTitle: ToastInput): Toast;
    // (undocumented)
    addWarning(toastOrTitle: ToastInput): Toast;
    // (undocumented)
    get$(): Rx.Observable<Toast[]>;
    // (undocumented)
    registerOverlays(overlays: OverlayStart): void;
    // (undocumented)
    remove(toast: Toast): void;
    }

// @public (undocumented)
export class UiSettingsClient {
    // Warning: (ae-forgotten-export) The symbol "UiSettingsClientParams" needs to be exported by the entry point index.d.ts
    constructor(params: UiSettingsClientParams);
    get$(key: string, defaultOverride?: any): Rx.Observable<any>;
    get(key: string, defaultOverride?: any): any;
    getAll(): UiSettingsState;
    getSaved$(): Rx.Observable<{
        key: string;
        newValue: any;
        oldValue: any;
    }>;
    getUpdate$(): Rx.Observable<{
        key: string;
        newValue: any;
        oldValue: any;
    }>;
    getUpdateErrors$(): Rx.Observable<Error>;
    isCustom(key: string): boolean;
    isDeclared(key: string): boolean;
    isDefault(key: string): boolean;
    isOverridden(key: string): boolean;
    overrideLocalDefault(key: string, newDefault: any): void;
    remove(key: string): Promise<boolean>;
    set(key: string, val: any): Promise<boolean>;
    stop(): void;
    }

// @public (undocumented)
export type UiSettingsClientContract = PublicMethodsOf<UiSettingsClient>;

// @public (undocumented)
export interface UiSettingsState {
    // Warning: (ae-forgotten-export) The symbol "InjectedUiSettingsDefault" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "InjectedUiSettingsUser" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    [key: string]: InjectedUiSettingsDefault & InjectedUiSettingsUser;
}


```
