/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import { v4 as uuidv4 } from 'uuid';
import { SavedObject, SavedObjectsClientContract, SavedObjectsImportError } from '../types';
import { extractErrors } from './extract_errors';

interface CreateSavedObjectsOptions {
  savedObjectsClient: SavedObjectsClientContract;
  importIdMap: Map<string, { id: string }>;
  namespace?: string;
  overwrite?: boolean;
}
interface CreateSavedObjectsResult<T> {
  createdObjects: Array<SavedObject<T> & { newId?: string }>;
  errors: SavedObjectsImportError[];
}

interface UnresolvableConflict<T> {
  retryIndex: number;
  retryObject: SavedObject<T>;
}
interface Left<T> {
  tag: 'left';
  value: UnresolvableConflict<T>;
}
interface Right<T> {
  tag: 'right';
  value: SavedObject<T>;
}
type Either<T> = Left<T> | Right<T>;
const isLeft = <T>(object: Either<T>): object is Left<T> => object.tag === 'left';
const isRight = <T>(object: Either<T>): object is Right<T> => object.tag === 'right';

const isUnresolvableConflict = (object: SavedObject<unknown>) =>
  object.error?.statusCode === 409 && object.error?.metadata?.isNotOverwritable;

/**
 * This function abstracts the bulk creation of import objects for two purposes:
 *  1. The import ID map that was generated by the `checkConflicts` function should dictate the IDs of the objects we create.
 *  2. Any object create attempt that results in an unresolvable conflict should have its ID regenerated and retry create. This way, when an
 *     object with a "multi-namespace" type is exported from one namespace and imported to another, it does not result in an error, but
 *     instead a new object is created.
 */
export const createSavedObjects = async <T>(
  objects: Array<SavedObject<T>>,
  options: CreateSavedObjectsOptions
): Promise<CreateSavedObjectsResult<T>> => {
  // exit early if there are no objects to create
  if (objects.length === 0) {
    return { createdObjects: [], errors: [] };
  }

  const { savedObjectsClient, importIdMap, namespace, overwrite } = options;

  // generate a map of the raw object IDs
  const objectIdMap = objects.reduce(
    (map, object) => map.set(`${object.type}:${object.id}`, object),
    new Map<string, SavedObject<T>>()
  );

  // use the import ID map from the `checkConflicts` or `getImportIdMapForRetries` function to ensure that each object is being created with
  // the correct ID also, ensure that the `originId` is set on the created object if it did not have one
  const objectsToCreate = objects.map((object) => {
    const importIdEntry = importIdMap.get(`${object.type}:${object.id}`);
    if (importIdEntry) {
      objectIdMap.set(`${object.type}:${importIdEntry.id}`, object);
      const originId = object.originId ?? object.id;
      return { ...object, id: importIdEntry.id, originId };
    }
    return object;
  });
  const bulkCreateResponse = await savedObjectsClient.bulkCreate(objectsToCreate, {
    namespace,
    overwrite,
  });

  // retry bulkCreate for multi-namespace saved objects that had an unresolvable conflict
  // note: by definition, only multi-namespace saved objects can have an unresolvable conflict
  let retryIndexCounter = 0;
  const bulkCreateResults: Array<Either<T>> = bulkCreateResponse.saved_objects.map((result) => {
    const object = objectIdMap.get(`${result.type}:${result.id}`)!;
    if (isUnresolvableConflict(result)) {
      const id = uuidv4();
      const originId = object.originId || object.id;
      const retryObject = { ...object, id, originId };
      objectIdMap.set(`${retryObject.type}:${retryObject.id}`, object);
      return { tag: 'left', value: { retryIndex: retryIndexCounter++, retryObject } };
    }
    return { tag: 'right', value: result };
  });

  // note: this is unrelated to "retries" that are passed into the `resolveSavedObjectsImportErrors` function
  const retries = bulkCreateResults.filter(isLeft).map((x) => x.value.retryObject);
  const retryResults =
    retries.length > 0
      ? (await savedObjectsClient.bulkCreate(retries, { namespace, overwrite })).saved_objects
      : [];

  const results: Array<SavedObject<T>> = [];
  bulkCreateResults.forEach((result) => {
    if (isLeft(result)) {
      const { retryIndex } = result.value;
      results.push(retryResults[retryIndex]);
    } else if (isRight(result)) {
      results.push(result.value);
    }
  });

  // remap results to reflect the object IDs that were submitted for import
  // this ensures that consumers understand the results
  const remappedResults = results.map<SavedObject<T> & { newId?: string }>((result) => {
    const { id } = objectIdMap.get(`${result.type}:${result.id}`)!;
    // also, include a `newId` field if the object create attempt was made with a different ID
    return { ...result, id, ...(id !== result.id && { newId: result.id }) };
  });

  return {
    createdObjects: remappedResults.filter((obj) => !obj.error),
    errors: extractErrors(remappedResults, objects),
  };
};
