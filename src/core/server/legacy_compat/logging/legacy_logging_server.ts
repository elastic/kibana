/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import { ServerExtType } from 'hapi';
import Podium from 'podium';
// @ts-ignore: implicit any for JS file
import { Config, transformDeprecations } from '../../../../server/config';
// @ts-ignore: implicit any for JS file
import { setupLogging } from '../../../../server/logging';
import { LogRecord } from '../../logging/log_record';

interface PluginRegisterParams {
  plugin: {
    register: (
      server: LegacyLoggingServer,
      options: PluginRegisterParams['options']
    ) => Promise<void>;
  };
  options: Record<string, any>;
}

/**
 *  The "legacy" Kibana uses Hapi server + even-better plugin to log, so we should
 *  use the same approach here to make log records generated by the core to look the
 *  same as the rest of the records generated by the "legacy" Kibana. But to reduce
 *  overhead of having full blown Hapi server instance we create our own "light" version.
 */
export class LegacyLoggingServer {
  public connections = [];
  // Emulates Hapi's usage of the podium event bus.
  public events: Podium = new Podium();
  private onPreStartCallbacks: Array<() => void> = [];
  private onPostStopCallbacks: Array<() => void> = [];

  constructor(legacyLoggingConfig: Readonly<Record<string, any>>) {
    // Tell our podium instance about the events we'll be using.
    this.events.registerEvent('log');
    // We don't actually forward these events, but we have to register them with Podium
    // in order for the plugin to be able to setup.
    this.events.registerEvent('response');
    this.events.registerEvent('request');

    // We set `ops.interval` to max allowed number and `ops` filter to value
    // that doesn't exist to avoid logging of ops at all, if turned on it will be
    // logged by the "legacy" Kibana.
    const config = {
      logging: {
        ...legacyLoggingConfig,
        events: {
          ...legacyLoggingConfig.events,
          ops: '__no-ops__',
        },
      },
      ops: { interval: 2147483647 },
    };

    setupLogging(this, Config.withDefaultSchema(transformDeprecations(config))).then(() => {
      // Tell the plugin we're starting.
      this.onPreStartCallbacks.forEach(callback => callback());
    });
  }

  public register({ plugin: { register }, options }: PluginRegisterParams): Promise<void> {
    return register(this, options);
  }

  public log({ level, context, message, error, timestamp, meta = {} }: LogRecord) {
    this.events.emit('log', {
      data: error || message,
      tags: [level.id.toLowerCase(), ...context.split('.'), ...(meta.tags || [])],
      timestamp: timestamp.getMilliseconds(),
    });
  }

  public stop() {
    // Tell the plugin we're stopping.
    this.onPostStopCallbacks.forEach(callback => callback());
  }

  public ext(eventName: ServerExtType, callback: () => void) {
    // method is called by plugin that's being registered.
    if (eventName === 'onPreStart') {
      this.onPreStartCallbacks.push(callback);
    } else if (eventName === 'onPostStop') {
      this.onPostStopCallbacks.push(callback);
    } else {
      // We don't care about any others the plugin resgisters
    }
  }

  public expose() {
    // method is called by plugin that's being registered.
  }
}
