/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import { EventEmitter } from 'events';
// @ts-ignore: implicit any for JS file
import { Config, transformDeprecations } from '../../../../server/config';
// @ts-ignore: implicit any for JS file
import { setupLogging } from '../../../../server/logging';
import { LogRecord } from '../../logging/log_record';

interface PluginRegisterParams {
  register: {
    register: (
      server: LegacyLoggingServer,
      options: PluginRegisterParams['options'],
      cb: () => void
    ) => void;
  };
  options: Record<string, any>;
}

/**
 *  The "legacy" Kibana uses Hapi server + even-better plugin to log, so we should
 *  use the same approach here to make log records generated by the core to look the
 *  same as the rest of the records generated by the "legacy" Kibana. But to reduce
 *  overhead of having full blown Hapi server instance we create our own "light" version.
 */
export class LegacyLoggingServer extends EventEmitter {
  public connections = [];

  constructor(legacyLoggingConfig: Readonly<Record<string, any>>) {
    super();

    // We set `ops.interval` to max allowed number and `ops` filter to value
    // that doesn't exist to avoid logging of ops at all, if turned on it will be
    // logged by the "legacy" Kibana.
    const config = {
      logging: {
        ...legacyLoggingConfig,
        events: {
          ...legacyLoggingConfig.events,
          ops: '__no-ops__',
        },
      },
      ops: { interval: 2147483647 },
    };

    setupLogging(this, Config.withDefaultSchema(transformDeprecations(config)));
  }

  public register({ register: plugin, options }: PluginRegisterParams, cb: () => void) {
    plugin.register(this, options, cb);
  }

  public log({ level, context, message, error, timestamp, meta = {} }: LogRecord) {
    this.emit('log', {
      data: error || message,
      tags: [level.id.toLowerCase(), ...context.split('.'), ...(meta.tags || [])],
      timestamp: timestamp.getMilliseconds(),
    });
  }

  public stop() {
    this.emit('stop');
  }

  public expose() {
    // method is called by plugin that's being registered.
  }
}
