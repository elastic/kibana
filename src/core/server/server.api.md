## API Report File for "kibana"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ConfigOptions } from 'elasticsearch';
import { Duration } from 'moment';
import { ObjectType } from '@kbn/config-schema';
import { Observable } from 'rxjs';
import { Request } from 'hapi';
import { ResponseObject } from 'hapi';
import { ResponseToolkit } from 'hapi';
import { Schema } from '@kbn/config-schema';
import { Server } from 'hapi';
import { ServerOptions } from 'hapi';
import { Type } from '@kbn/config-schema';
import { TypeOf } from '@kbn/config-schema';

// @public (undocumented)
export type APICaller = (endpoint: string, clientParams: Record<string, unknown>, options?: CallAPIOptions) => Promise<unknown>;

// @public (undocumented)
export type AuthenticationHandler<T> = (request: Request, sessionStorage: SessionStorage<T>, t: AuthToolkit) => Promise<AuthResult>;

// @public
export interface AuthToolkit {
    authenticated: (credentials: any) => AuthResult;
    redirected: (url: string) => AuthResult;
    rejected: (error: Error, options?: {
        statusCode?: number;
    }) => AuthResult;
}

// @internal (undocumented)
export function bootstrap({ configs, cliArgs, applyConfigOverrides, features, }: BootstrapArgs): Promise<void>;

// @public
export interface CallAPIOptions {
    wrap401Errors: boolean;
}

// @public
export class ClusterClient {
    constructor(config: ElasticsearchClientConfig, log: Logger);
    asScoped(req?: {
        headers?: Headers;
    }): ScopedClusterClient;
    callAsInternalUser: (endpoint: string, clientParams?: Record<string, unknown>, options?: CallAPIOptions | undefined) => Promise<any>;
    close(): void;
    }

// @public (undocumented)
export class ConfigService {
    constructor(config$: Observable<Config>, env: Env, logger: LoggerFactory);
    atPath<TSchema extends Type<any>, TConfig>(path: ConfigPath, ConfigClass: ConfigWithSchema<TSchema, TConfig>): Observable<TConfig>;
    getConfig$(): Observable<Config>;
    // (undocumented)
    getUnusedPaths(): Promise<string[]>;
    // (undocumented)
    getUsedPaths(): Promise<string[]>;
    // (undocumented)
    isEnabledAtPath(path: ConfigPath): Promise<boolean>;
    optionalAtPath<TSchema extends Type<any>, TConfig>(path: ConfigPath, ConfigClass: ConfigWithSchema<TSchema, TConfig>): Observable<TConfig | undefined>;
}

// @public (undocumented)
export interface CoreSetup {
    // (undocumented)
    elasticsearch: ElasticsearchServiceSetup;
    // (undocumented)
    http: HttpServiceSetup;
    // (undocumented)
    plugins: PluginsServiceSetup;
}

// @internal
export interface DiscoveredPlugin {
    readonly configPath: ConfigPath;
    readonly id: PluginName;
    readonly optionalPlugins: ReadonlyArray<PluginName>;
    readonly requiredPlugins: ReadonlyArray<PluginName>;
}

// @public (undocumented)
export type ElasticsearchClientConfig = Pick<ConfigOptions, 'keepAlive' | 'log' | 'plugins'> & Pick<ElasticsearchConfig, 'apiVersion' | 'customHeaders' | 'logQueries' | 'requestHeadersWhitelist' | 'sniffOnStart' | 'sniffOnConnectionFault' | 'hosts' | 'username' | 'password'> & {
    pingTimeout?: ElasticsearchConfig['pingTimeout'] | ConfigOptions['pingTimeout'];
    requestTimeout?: ElasticsearchConfig['requestTimeout'] | ConfigOptions['requestTimeout'];
    sniffInterval?: ElasticsearchConfig['sniffInterval'] | ConfigOptions['sniffInterval'];
    ssl?: Partial<ElasticsearchConfig['ssl']>;
};

// @public (undocumented)
export interface ElasticsearchServiceSetup {
    // (undocumented)
    readonly adminClient$: Observable<ClusterClient>;
    // (undocumented)
    readonly createClient: (type: string, config: ElasticsearchClientConfig) => ClusterClient;
    // (undocumented)
    readonly dataClient$: Observable<ClusterClient>;
    // (undocumented)
    readonly legacy: {
        readonly config$: Observable<ElasticsearchConfig>;
    };
}

// @public (undocumented)
export type Headers = Record<string, string | string[] | undefined>;

// @public (undocumented)
export type HttpServiceSetup = HttpServerInfo;

// @public (undocumented)
export class KibanaRequest<Params, Query, Body> {
    constructor(req: Request, params: Params, query: Query, body: Body);
    // (undocumented)
    readonly body: Body;
    static from<P extends ObjectType, Q extends ObjectType, B extends ObjectType>(req: Request, routeSchemas: RouteSchemas<P, Q, B> | undefined): KibanaRequest<P["type"], Q["type"], B["type"]>;
    // (undocumented)
    getFilteredHeaders(headersToKeep: string[]): Pick<Record<string, string | string[] | undefined>, string>;
    // (undocumented)
    readonly headers: Headers;
    // (undocumented)
    readonly params: Params;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly query: Query;
    }

// @public
export interface Logger {
    debug(message: string, meta?: LogMeta): void;
    error(errorOrMessage: string | Error, meta?: LogMeta): void;
    fatal(errorOrMessage: string | Error, meta?: LogMeta): void;
    info(message: string, meta?: LogMeta): void;
    // @internal (undocumented)
    log(record: LogRecord): void;
    trace(message: string, meta?: LogMeta): void;
    warn(errorOrMessage: string | Error, meta?: LogMeta): void;
}

// @public
export interface LoggerFactory {
    get(...contextParts: string[]): Logger;
}

// @internal
export class LogLevel {
    // (undocumented)
    static readonly All: LogLevel;
    // (undocumented)
    static readonly Debug: LogLevel;
    // (undocumented)
    static readonly Error: LogLevel;
    // (undocumented)
    static readonly Fatal: LogLevel;
    static fromId(level: LogLevelId): LogLevel;
    // (undocumented)
    readonly id: LogLevelId;
    // (undocumented)
    static readonly Info: LogLevel;
    // (undocumented)
    static readonly Off: LogLevel;
    supports(level: LogLevel): boolean;
    // (undocumented)
    static readonly Trace: LogLevel;
    // (undocumented)
    readonly value: number;
    // (undocumented)
    static readonly Warn: LogLevel;
}

// @public
export interface LogMeta {
    // (undocumented)
    [key: string]: any;
}

// @internal
export interface LogRecord {
    // (undocumented)
    context: string;
    // (undocumented)
    error?: Error;
    // (undocumented)
    level: LogLevel;
    // (undocumented)
    message: string;
    // (undocumented)
    meta?: {
        [name: string]: any;
    };
    // (undocumented)
    timestamp: Date;
}

// @public (undocumented)
export type OnRequestHandler<Params = any, Query = any, Body = any> = (req: KibanaRequest<Params, Query, Body>, t: OnRequestToolkit) => OnRequestResult | Promise<OnRequestResult>;

// @public
export interface OnRequestToolkit {
    next: () => OnRequestResult;
    redirected: (url: string) => OnRequestResult;
    rejected: (error: Error, options?: {
        statusCode?: number;
    }) => OnRequestResult;
}

// @public
export interface Plugin<TSetup, TPluginsSetup extends Record<PluginName, unknown> = {}> {
    // (undocumented)
    setup: (pluginSetupContext: PluginSetupContext, plugins: TPluginsSetup) => TSetup | Promise<TSetup>;
    // (undocumented)
    stop?: () => void;
}

// @public
export type PluginInitializer<TSetup, TPluginsSetup extends Record<PluginName, unknown> = {}> = (coreContext: PluginInitializerContext) => Plugin<TSetup, TPluginsSetup>;

// @public
export interface PluginInitializerContext {
    // (undocumented)
    config: {
        create: <Schema extends Type<any>, Config>(ConfigClass: ConfigWithSchema<Schema, Config>) => Observable<Config>;
        createIfExists: <Schema extends Type<any>, Config>(ConfigClass: ConfigWithSchema<Schema, Config>) => Observable<Config | undefined>;
    };
    // (undocumented)
    env: {
        mode: EnvironmentMode;
    };
    // (undocumented)
    logger: LoggerFactory;
}

// @public
export type PluginName = string;

// @public
export interface PluginSetupContext {
    // (undocumented)
    elasticsearch: {
        adminClient$: Observable<ClusterClient>;
        dataClient$: Observable<ClusterClient>;
    };
    // (undocumented)
    http: {
        registerAuth: HttpServiceSetup['registerAuth'];
        registerOnRequest: HttpServiceSetup['registerOnRequest'];
    };
}

// @internal (undocumented)
export interface PluginsServiceSetup {
    // (undocumented)
    contracts: Map<PluginName, unknown>;
    // (undocumented)
    uiPlugins: {
        public: Map<PluginName, DiscoveredPlugin>;
        internal: Map<PluginName, DiscoveredPluginInternal>;
    };
}

// @public (undocumented)
export class Router {
    constructor(path: string);
    delete<P extends ObjectType, Q extends ObjectType, B extends ObjectType>(route: RouteConfig<P, Q, B>, handler: RequestHandler<P, Q, B>): void;
    get<P extends ObjectType, Q extends ObjectType, B extends ObjectType>(route: RouteConfig<P, Q, B>, handler: RequestHandler<P, Q, B>): void;
    getRoutes(): Readonly<RouterRoute>[];
    // (undocumented)
    readonly path: string;
    post<P extends ObjectType, Q extends ObjectType, B extends ObjectType>(route: RouteConfig<P, Q, B>, handler: RequestHandler<P, Q, B>): void;
    put<P extends ObjectType, Q extends ObjectType, B extends ObjectType>(route: RouteConfig<P, Q, B>, handler: RequestHandler<P, Q, B>): void;
    // (undocumented)
    routes: Array<Readonly<RouterRoute>>;
    }

// @public
export class ScopedClusterClient {
    constructor(internalAPICaller: APICaller, scopedAPICaller: APICaller, headers?: Record<string, string | string[] | undefined> | undefined);
    callAsCurrentUser(endpoint: string, clientParams?: Record<string, unknown>, options?: CallAPIOptions): Promise<unknown>;
    callAsInternalUser(endpoint: string, clientParams?: Record<string, unknown>, options?: CallAPIOptions): Promise<unknown>;
    }


// (No @packageDocumentation comment for this package)

```
