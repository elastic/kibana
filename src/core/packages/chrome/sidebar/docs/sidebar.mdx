---
id: kibDevDocsChromeSidebar
slug: /kibana-dev-docs/chrome/sidebar
title: Chrome Sidebar
description: Build sidebar apps with the Chrome sidebar service.
date: 2026-01-29
tags: ['kibana', 'dev', 'contributor', 'chrome', 'shared-ux']
---

## Introduction

Chrome Sidebar lets plugins provide supplemental tools without disrupting the main app content.
Sidebar apps are global and can stay open across navigation and page reloads.

![Chrome sidebar](./sidebar.png)

## Register a sidebar app

Register apps during the plugin `setup()` phase. Each app provides an async component loader and can optionally define a Zod params schema for persisted state.

Before registering, confirm the `appId` is allowed. Valid app ids are restricted and new ones should be added only after discussing with the UX team.

```tsx
import { z } from '@kbn/zod/v4';

core.chrome.sidebar.registerApp({
  appId: 'mySidebarApp',
  getParamsSchema: () =>
    z.object({
      userName: z.string().default(''),
      count: z.number().default(0),
    }),
  loadComponent: () => import('./my_sidebar_app').then((m) => m.MySidebarApp),
  status: 'accessible',
});
```

Required fields:
- `appId`: Unique identifier for the sidebar app. It must be a valid sidebar app id.
- `loadComponent`: Async function that resolves the sidebar React component.

Optional fields:
- `getParamsSchema`: Zod schema for params (persisted state). If omitted, `params` is `{}` and `setParams()` throws.
- `status`: Accessibility status (defaults to `accessible`).
- `restoreOnReload`: Whether the app auto-reopens on page reload (defaults to `true`).

## Build a sidebar app component

Sidebar components receive `params`, `setParams`, and `onClose`.
Use the shared layout components to align with Kibana styling.

```tsx
import { z } from '@kbn/zod/v4';
import type { SidebarComponentProps } from '@kbn/core-chrome-sidebar';
import { SidebarHeader, SidebarBody } from '@kbn/core-chrome-sidebar-components';

const getMyParamsSchema = () =>
  z.object({
    count: z.number().default(0),
  });

type MyParams = z.infer<ReturnType<typeof getMyParamsSchema>>;

export function MySidebarApp({
  params,
  setParams,
  onClose,
}: SidebarComponentProps<MyParams>) {
  return (
    <>
      <SidebarHeader title="My App" onClose={onClose} />
      <SidebarBody>
        <button onClick={() => setParams({ count: params.count + 1 })}>
          Count: {params.count}
        </button>
      </SidebarBody>
    </>
  );
}
```

For apps without params, omit `getParamsSchema` and use internal React state instead. If you do that, consider `restoreOnReload: false`.

## Params system (optional)

Params are a persisted, validated state layer:
- Persisted to `localStorage` and restored on reload.
- Accessible outside the sidebar component via the app-bound API.
- Validated and typed through Zod.

```tsx
const myApp = core.chrome.sidebar.getApp('mySidebarApp');

myApp.open({ userName: 'John' });
myApp.setParams({ count: 5 });

const params = myApp.getParams();
myApp.getParams$().subscribe((next) => {
  console.log('Params changed:', next);
});
```

## Open and close the sidebar

Use the app-bound API during the plugin `start()` phase.

```tsx
const myApp = core.chrome.sidebar.getApp('mySidebarApp');

myApp.open({ userName: 'John' });
myApp.close();

const isOpen = core.chrome.sidebar.isOpen();
const currentAppId = core.chrome.sidebar.getCurrentAppId();
```

From React components, use hooks from `@kbn/core-chrome-sidebar-components`:

```tsx
import { useSidebar, useSidebarApp } from '@kbn/core-chrome-sidebar-components';

function MyToolbarButton() {
  const { close, isOpen } = useSidebar();
  const myApp = useSidebarApp('mySidebarApp');

  return (
    <>
      <button onClick={() => myApp.open({ userName: 'John' })}>
        Open sidebar
      </button>
      {isOpen && <button onClick={close}>Close sidebar</button>}
    </>
  );
}
```

## Manage app status

Use `status: 'inaccessible'` when the app depends on async checks (license, permissions).

```tsx
const updateMySidebarApp = core.chrome.sidebar.registerApp({
  appId: 'mySidebarApp',
  loadComponent: () => import('./my_sidebar_app').then((m) => m.MySidebarApp),
  status: 'inaccessible',
});

// Later in start
updateMySidebarApp({ status: 'accessible' });
```

## Control sidebar width

```tsx
core.chrome.sidebar.setWidth(400);
const width = core.chrome.sidebar.getWidth();
```

```tsx
import { useSidebarWidth } from '@kbn/core-chrome-sidebar-components';

const width = useSidebarWidth();
```

## Testing

Use `@kbn/core-chrome-sidebar-mocks` to mock setup/start contracts in Jest tests.

```tsx
import { sidebarServiceMock } from '@kbn/core-chrome-sidebar-mocks';

const setupMock = sidebarServiceMock.createSetupContract();
const startMock = sidebarServiceMock.createStartContract();
```

## Accessibility

The sidebar renders as an `<aside>` landmark. `SidebarHeader` and `SidebarBody` handle most a11y concerns automatically, but apps must follow a few rules.

### Panel label

The sidebar panel uses `aria-labelledby` to link the `<aside>` landmark to the heading rendered by `SidebarHeader`. This happens automatically — `SidebarHeader` places the shared heading ID on its `<h2>`, and the panel references it. A fallback `aria-label="Side panel"` is used when no heading is present.

`SidebarHeader` requires a `title` prop. It renders as an `<h2>` heading that labels the panel. When using custom header content via `children`, `title` is still required — it renders as a visually hidden heading so `aria-labelledby` always works:

```tsx
<SidebarHeader title="My App" onClose={onClose}>
  <CustomHeaderContent />
</SidebarHeader>
```

If you don't use `SidebarHeader` at all (fully custom header), you must place the heading ID on your own heading element via `useSidebarPanel`:

```tsx
import { useSidebarPanel } from '@kbn/core-chrome-sidebar-components';

const { headingId } = useSidebarPanel();

return <h2 id={headingId}>My App</h2>;
```

### Focus rescue

When the sidebar closes while focus is inside, focus is automatically moved to the main content area. Apps can override this with a custom callback via `useSidebarPanel`:

```tsx
import { useSidebarPanel } from '@kbn/core-chrome-sidebar-components';

const { setOnFocusRescue } = useSidebarPanel();

useEffect(() => {
  setOnFocusRescue(() => triggerButtonRef.current?.focus());
}, [setOnFocusRescue]);
```

### Scrollable body

Pass `scrollable` to make `SidebarBody` keyboard-scrollable (`tabIndex={0}`) and announce it as a region to screen readers:

```tsx
<SidebarBody scrollable>
  {/* long content */}
</SidebarBody>
```

## Best practices

- Wrap sidebar operations in your plugin contract or a custom hook, instead of exposing the raw sidebar API.
- Use params for state that must survive navigation or reloads; use component state for ephemeral UI.
- Prefer `SidebarHeader` and `SidebarBody` for consistent layout and spacing.
