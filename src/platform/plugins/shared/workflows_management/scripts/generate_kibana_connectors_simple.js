#!/usr/bin/env node

/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/*
 * Simple script to generate Kibana connectors from openapi-zod-client output
 * Uses the generated client directly instead of trying to parse it
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Paths
const KIBANA_OPENAPI_PATH = './oas_docs/output/kibana.yaml';
const TEMP_CLIENT_PATH = './temp_kibana_client.ts';
const OUTPUT_PATH = path.resolve(__dirname, '../common/generated_kibana_connectors.ts');

console.log('üîß Generating Kibana connectors using openapi-zod-client...');

/**
 * Generate the client using openapi-zod-client
 */
function generateZodClient() {
  console.log('üì¶ Running openapi-zod-client...');
  
  try {
    execSync(`npx openapi-zod-client "${KIBANA_OPENAPI_PATH}" -o "${TEMP_CLIENT_PATH}"`, {
      stdio: 'inherit'
    });
    console.log('‚úÖ Generated Zod client successfully');
    return true;
  } catch (error) {
    console.error('‚ùå Failed to generate Zod client:', error.message);
    return false;
  }
}

/**
 * Transform the generated client into our ConnectorContract format
 */
function transformClient() {
  console.log('üîÑ Transforming client to ConnectorContract format...');
  
  if (!fs.existsSync(TEMP_CLIENT_PATH)) {
    console.error('‚ùå Generated client file not found');
    return false;
  }
  
  try {
    let clientContent = fs.readFileSync(TEMP_CLIENT_PATH, 'utf8');
    
    // Extract the endpoints array from: const endpoints = makeApi([...]);
    const endpointsMatch = clientContent.match(/const endpoints = makeApi\(\[([\s\S]*?)\]\);/);
    
    if (!endpointsMatch) {
      console.error('‚ùå Could not find endpoints array in generated client');
      return false;
    }
    
    const endpointsContent = endpointsMatch[1];
    
    // Replace the endpoints array with our ConnectorContract format
    let connectorDefinitions = [];
    
    // Split endpoints by top-level objects
    const endpoints = parseEndpointsArray(endpointsContent);
    
    for (const endpoint of endpoints) {
      const connector = transformEndpointToConnector(endpoint);
      if (connector) {
        connectorDefinitions.push(connector);
      }
    }
    
    // Get all the schema definitions (everything before the endpoints)
    const beforeEndpoints = clientContent.substring(0, clientContent.indexOf('const endpoints = makeApi'));
    
    // Create the final file content
    const fileContent = `/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/*
 * GENERATED FILE - DO NOT EDIT
 * 
 * This file is automatically generated from Kibana's OpenAPI specifications.
 * To update it, run: node src/platform/plugins/shared/workflows_management/scripts/generate_kibana_connectors_simple.js
 */

import { z } from '@kbn/zod';
import type { ConnectorContract } from '@kbn/workflows';

// Schema definitions from openapi-zod-client
${beforeEndpoints}

export const GENERATED_KIBANA_CONNECTORS: ConnectorContract[] = [
${connectorDefinitions.join(',\n')}
];

export const KIBANA_CONNECTOR_COUNT = ${connectorDefinitions.length};
`;

    fs.writeFileSync(OUTPUT_PATH, fileContent);
    console.log(`‚úÖ Generated ${OUTPUT_PATH}`);
    console.log(`üéâ Successfully generated ${connectorDefinitions.length} Kibana connectors!`);
    return true;
    
  } catch (error) {
    console.error('‚ùå Failed to transform client:', error.message);
    return false;
  }
}

/**
 * Parse the endpoints array string into individual endpoint objects
 */
function parseEndpointsArray(endpointsContent) {
  const endpoints = [];
  let braceCount = 0;
  let currentEndpoint = '';
  let inEndpoint = false;
  
  for (let i = 0; i < endpointsContent.length; i++) {
    const char = endpointsContent[i];
    
    if (char === '{') {
      if (!inEndpoint) {
        inEndpoint = true;
        currentEndpoint = '';
      }
      braceCount++;
    }
    
    if (inEndpoint) {
      currentEndpoint += char;
    }
    
    if (char === '}') {
      braceCount--;
      if (braceCount === 0 && inEndpoint) {
        endpoints.push(currentEndpoint);
        inEndpoint = false;
        currentEndpoint = '';
      }
    }
  }
  
  return endpoints;
}

/**
 * Transform an endpoint object to ConnectorContract format
 */
function transformEndpointToConnector(endpointStr) {
  try {
    // Extract basic info
    const methodMatch = endpointStr.match(/method:\s*['"](\w+)['"]/);
    const pathMatch = endpointStr.match(/path:\s*['"]([^'"]+)['"]/);
    const aliasMatch = endpointStr.match(/alias:\s*['"]([^'"]+)['"]/);
    
    if (!methodMatch || !pathMatch || !aliasMatch) {
      return null;
    }
    
    const method = methodMatch[1].toUpperCase();
    const path = pathMatch[1];
    const operationId = aliasMatch[1];
    const type = `kibana.${operationId}`;
    
    // Build parameters schema from all parameters
    let paramsSchemaContent = 'z.object({})';
    
    // Look for parameters array
    const parametersMatch = endpointStr.match(/parameters:\s*\[([\s\S]*?)\]/);
    if (parametersMatch) {
      const paramFields = [];
      const parametersContent = parametersMatch[1];
      
      // Find all parameter objects
      const paramRegex = /\{\s*name:\s*['"]([^'"]+)['"],\s*type:\s*['"]([^'"]+)['"],\s*schema:\s*([^,\}]+)/g;
      let paramMatch;
      
      while ((paramMatch = paramRegex.exec(parametersContent)) !== null) {
        const paramName = paramMatch[1];
        const paramType = paramMatch[2];
        const paramSchema = paramMatch[3].trim();
        
        // Skip internal headers but include query and path params
        if (paramType === 'Query' || paramType === 'Path') {
          // Quote parameter names that need it
          const quotedName = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(paramName) ? paramName : `"${paramName}"`;
          paramFields.push(`${quotedName}: ${paramSchema}`);
        } else if (paramType === 'Body') {
          // For body parameters, use the schema directly as paramsSchema
          paramsSchemaContent = paramSchema;
        }
      }
      
      // If we have query/path params, create an object schema
      if (paramFields.length > 0 && paramsSchemaContent === 'z.object({})') {
        paramsSchemaContent = `z.object({ ${paramFields.join(', ')} })`;
      }
    }
    
    const description = `API endpoint: ${method} ${path}`;
    
    return `  {
    type: '${type}',
    connectorIdRequired: false,
    paramsSchema: ${paramsSchemaContent},
    outputSchema: z.any().describe('${description}'),
  }`;
    
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Failed to transform endpoint: ${error.message}`);
    return null;
  }
}

/**
 * Clean up temporary files
 */
function cleanup() {
  if (fs.existsSync(TEMP_CLIENT_PATH)) {
    fs.unlinkSync(TEMP_CLIENT_PATH);
    console.log('üßπ Cleaned up temporary files');
  }
}

/**
 * Main function
 */
function main() {
  try {
    // Step 1: Generate the Zod client
    if (!generateZodClient()) {
      return;
    }
    
    // Step 2: Transform to our format
    if (!transformClient()) {
      return;
    }
    
    // Step 3: Clean up
    cleanup();
    
  } catch (error) {
    console.error('‚ùå Failed to generate connectors:', error);
    cleanup();
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { main };
