#!/usr/bin/env node

/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/*
 * Generate Kibana connectors by using openapi-zod-client and converting the output
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Paths
const KIBANA_OPENAPI_PATH = './oas_docs/output/kibana.yaml';
const TEMP_CLIENT_PATH = './temp_kibana_client.ts';
const OUTPUT_PATH = path.resolve(__dirname, '../common/generated_kibana_connectors.ts');

console.log('üîß Generating Kibana connectors using openapi-zod-client...');

/**
 * Main function - generate client and convert to our format
 */
function main() {
  try {
    // Step 1: Generate the openapi-zod-client
    console.log('üì¶ Running openapi-zod-client...');
    execSync(`npx openapi-zod-client "${KIBANA_OPENAPI_PATH}" -o "${TEMP_CLIENT_PATH}"`, {
      stdio: 'inherit'
    });
    
    // Step 2: Read the generated client
    console.log('üìñ Reading generated client...');
    const clientContent = fs.readFileSync(TEMP_CLIENT_PATH, 'utf8');
    
    // Step 3: Extract the imports and schemas (everything before 'const endpoints = makeApi')
    const endpointsIndex = clientContent.indexOf('const endpoints = makeApi');
    if (endpointsIndex === -1) {
      throw new Error('Could not find endpoints definition in generated client');
    }
    
    const schemasSection = clientContent.substring(0, endpointsIndex);
    
    // Step 4: Extract just the endpoints array content
    const endpointsMatch = clientContent.match(/const endpoints = makeApi\(\[([\s\S]*?)\]\);/);
    if (!endpointsMatch) {
      throw new Error('Could not extract endpoints array');
    }
    
    const endpointsArrayContent = endpointsMatch[1];
    
    // Step 5: Convert endpoints to ConnectorContract format
    console.log('üîÑ Converting to ConnectorContract format...');
    const connectorDefinitions = [];
    
    // Split endpoints by looking for complete objects
    const endpoints = splitEndpoints(endpointsArrayContent);
    console.log(`üìã Found ${endpoints.length} endpoints`);
    
    for (const endpoint of endpoints) {
      const connector = convertToConnectorContract(endpoint);
      if (connector) {
        connectorDefinitions.push(connector);
      }
    }
    
    // Step 6: Generate the final file
    const fileContent = `/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/*
 * GENERATED FILE - DO NOT EDIT
 * 
 * This file is automatically generated from Kibana's OpenAPI specifications.
 * To update it, run: node src/platform/plugins/shared/workflows_management/scripts/generate_kibana_connectors_final.js
 */

import { z } from '@kbn/zod';
import type { ConnectorContract } from '@kbn/workflows';

${schemasSection}
export const GENERATED_KIBANA_CONNECTORS: ConnectorContract[] = [
${connectorDefinitions.join(',\n')}
];

export const KIBANA_CONNECTOR_COUNT = ${connectorDefinitions.length};
`;

    fs.writeFileSync(OUTPUT_PATH, fileContent);
    console.log(`‚úÖ Generated ${OUTPUT_PATH}`);
    console.log(`üéâ Successfully generated ${connectorDefinitions.length} Kibana connectors!`);
    
    // Cleanup
    if (fs.existsSync(TEMP_CLIENT_PATH)) {
      fs.unlinkSync(TEMP_CLIENT_PATH);
    }
    
  } catch (error) {
    console.error('‚ùå Failed to generate connectors:', error.message);
    
    // Cleanup on error
    if (fs.existsSync(TEMP_CLIENT_PATH)) {
      fs.unlinkSync(TEMP_CLIENT_PATH);
    }
    
    process.exit(1);
  }
}

/**
 * Split the endpoints array content into individual endpoint objects
 */
function splitEndpoints(content) {
  const endpoints = [];
  let depth = 0;
  let start = 0;
  let inString = false;
  let stringChar = '';
  
  for (let i = 0; i < content.length; i++) {
    const char = content[i];
    const prevChar = i > 0 ? content[i - 1] : '';
    
    // Handle string literals
    if ((char === '"' || char === "'") && prevChar !== '\\') {
      if (!inString) {
        inString = true;
        stringChar = char;
      } else if (char === stringChar) {
        inString = false;
      }
    }
    
    if (!inString) {
      if (char === '{') {
        if (depth === 0) {
          start = i;
        }
        depth++;
      } else if (char === '}') {
        depth--;
        if (depth === 0) {
          const endpoint = content.substring(start, i + 1).trim();
          if (endpoint) {
            endpoints.push(endpoint);
          }
        }
      }
    }
  }
  
  return endpoints;
}

/**
 * Convert an endpoint object to ConnectorContract format
 */
function convertToConnectorContract(endpointStr) {
  try {
    // Extract basic properties
    const methodMatch = endpointStr.match(/method:\s*["'](\w+)["']/);
    const pathMatch = endpointStr.match(/path:\s*["']([^"']+)["']/);
    const aliasMatch = endpointStr.match(/alias:\s*["']([^"']+)["']/);
    
    if (!methodMatch || !pathMatch || !aliasMatch) {
      console.warn('‚ö†Ô∏è  Could not extract basic properties from endpoint');
      return null;
    }
    
    const method = methodMatch[1].toUpperCase();
    const path = pathMatch[1];
    const alias = aliasMatch[1];
    const type = `kibana.${alias}`;
    
    // Extract parameters for the schema
    let paramsSchema = 'z.object({})';
    
    const parametersMatch = endpointStr.match(/parameters:\s*\[([\s\S]*?)\]/);
    if (parametersMatch) {
      const params = [];
      const parametersContent = parametersMatch[1];
      
      // Look for each parameter object
      const paramObjects = extractParameterObjects(parametersContent);
      
      for (const paramObj of paramObjects) {
        const nameMatch = paramObj.match(/name:\s*["']([^"']+)["']/);
        const typeMatch = paramObj.match(/type:\s*["']([^"']+)["']/);
        const schemaMatch = paramObj.match(/schema:\s*([^,}]+)/);
        
        if (nameMatch && typeMatch && schemaMatch) {
          const paramName = nameMatch[1];
          const paramType = typeMatch[1];
          const paramSchema = schemaMatch[1].trim();
          
          // Include Query, Path, and Body parameters
          if (paramType === 'Body') {
            // For body parameters, use the schema directly
            paramsSchema = paramSchema;
            break; // Body takes precedence
          } else if (paramType === 'Query' || paramType === 'Path') {
            // Quote parameter names that aren't valid identifiers
            const quotedName = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(paramName) ? paramName : `"${paramName}"`;
            params.push(`${quotedName}: ${paramSchema}`);
          }
        }
      }
      
      // If we have query/path params and no body, create object schema
      if (params.length > 0 && paramsSchema === 'z.object({})') {
        paramsSchema = `z.object({ ${params.join(', ')} })`;
      }
    }
    
    const description = `API endpoint: ${method} ${path}`;
    
    return `  {
    type: '${type}',
    connectorIdRequired: false,
    paramsSchema: ${paramsSchema},
    outputSchema: z.any().describe('${description}'),
  }`;
    
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Failed to convert endpoint: ${error.message}`);
    return null;
  }
}

/**
 * Extract individual parameter objects from parameters array content
 */
function extractParameterObjects(parametersContent) {
  const objects = [];
  let depth = 0;
  let start = 0;
  let inString = false;
  let stringChar = '';
  
  for (let i = 0; i < parametersContent.length; i++) {
    const char = parametersContent[i];
    const prevChar = i > 0 ? parametersContent[i - 1] : '';
    
    // Handle string literals
    if ((char === '"' || char === "'") && prevChar !== '\\') {
      if (!inString) {
        inString = true;
        stringChar = char;
      } else if (char === stringChar) {
        inString = false;
      }
    }
    
    if (!inString) {
      if (char === '{') {
        if (depth === 0) {
          start = i;
        }
        depth++;
      } else if (char === '}') {
        depth--;
        if (depth === 0) {
          const obj = parametersContent.substring(start, i + 1).trim();
          if (obj) {
            objects.push(obj);
          }
        }
      }
    }
  }
  
  return objects;
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { main };
