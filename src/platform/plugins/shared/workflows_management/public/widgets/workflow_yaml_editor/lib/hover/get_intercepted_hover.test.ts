/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import { monaco } from '@kbn/monaco';
import { getInterceptedHover } from './get_intercepted_hover';

const mockedMonacoYamlHoverProvideHover = jest.fn();

jest.mock('./intercept_monaco_yaml_hover_provider', () => ({
  getAllYamlHoverProviders: jest.fn(),
}));

const { getAllYamlHoverProviders } = jest.requireMock('./intercept_monaco_yaml_hover_provider');

describe('useEnhancedMonacoYamlHoverProvider', () => {
  beforeEach(() => {
    getAllYamlHoverProviders.mockReturnValue([{ provideHover: mockedMonacoYamlHoverProvideHover }]);
  });

  it('should remove "Source: ....json" from the end of the hover content generated by monaco-yaml', async () => {
    mockedMonacoYamlHoverProvideHover.mockResolvedValue({
      contents: [{ value: 'Some hover content\n Source: workflow-schema.json' }],
    });
    const hover = await getInterceptedHover(
      null as unknown as monaco.editor.ITextModel,
      new monaco.Position(1, 1),
      null as any
    );
    expect(hover?.contents[0].value).not.toContain('Source:');
    expect(hover?.contents[0].value).toContain('Some hover content');
  });

  it('should not remove "Source: ....json" from the hover content if it is not at the end', async () => {
    const hoverContent = 'Some hover content\nSource: workflow-schema.json\n Some other content';
    mockedMonacoYamlHoverProvideHover.mockResolvedValue({ contents: [{ value: hoverContent }] });
    const hover = await getInterceptedHover(
      null as unknown as monaco.editor.ITextModel,
      new monaco.Position(1, 1),
      null as unknown as monaco.CancellationToken
    );
    expect(hover?.contents[0].value).toBe(hoverContent);
  });
});
