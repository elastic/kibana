/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import type { Logger, CoreStart, SavedObjectsClientContract } from '@kbn/core/server';
import type { UserProfileAvatarData } from '@kbn/user-profile-components';
import type { UserInfo, DistinctCreatorsAggResult, ResolveCreatedByResult } from './types';
import { getCachedUserProfiles, setCachedUserProfiles } from './user_profile_cache';

/**
 * Regular expression to validate user profile IDs as generated by Elasticsearch.
 * User profile IDs are expected to be in the format "u_<principal>_<version>".
 *
 * Note: This pattern is duplicated from:
 * `src/core/packages/saved-objects/api-server-internal/src/lib/apis/internals/change_object_access_control.ts`
 * Consider extracting to a shared utility if needed elsewhere.
 */
const USER_PROFILE_UID_REGEX = /^u_.+_.+$/;

/**
 * Sentinel value representing items with no creator.
 * When used in createdBy filter, matches items where `created_by` is not set.
 * Matches the constant used in `kbn-content-list-toolbar` and `table_list_view_table`.
 */
export const NULL_USER = 'no-user';

/**
 * Checks if a value matches the user profile UID format.
 *
 * User profile UIDs are generated by Elasticsearch and follow the pattern `u_{principal}_{version}`.
 * This function validates the format but does not verify the UID exists in the system.
 *
 * @param value - The string value to check.
 * @returns `true` if the value matches the UID format, `false` otherwise.
 *
 * @example
 * isUserProfileUid('u_mleNGqn5T0Cqv49nPpHfLA_0'); // true
 * isUserProfileUid('john.doe'); // false
 * isUserProfileUid('u_incomplete'); // false (missing version suffix)
 */
export const isUserProfileUid = (value: string): boolean => {
  return USER_PROFILE_UID_REGEX.test(value);
};

/**
 * Fetches distinct `created_by` user profile UIDs from saved objects of the given type.
 *
 * Uses a terms aggregation on the `created_by` field to collect unique creator UIDs
 * from documents the user has access to. The aggregation respects saved object security
 * by using the provided client's authorization context.
 *
 * @param savedObjectsClient - Saved objects client with `search` capability (typically the user's scoped client).
 * @param type - Saved object type or array of types to search.
 * @param namespaces - Array of namespace strings to search within.
 * @param logger - Logger instance for error reporting.
 * @returns Array of unique `created_by` UIDs, or empty array if aggregation fails.
 *
 * @example
 * const creators = await getDistinctCreators(
 *   savedObjectsClient,
 *   ['dashboard', 'visualization'],
 *   ['default'],
 *   logger
 * );
 * // Returns: ['u_abc123', 'u_def456', ...]
 */
export const getDistinctCreators = async (
  savedObjectsClient: Pick<SavedObjectsClientContract, 'search'>,
  type: string | string[],
  namespaces: string[],
  logger: Logger
): Promise<string[]> => {
  try {
    const result = await savedObjectsClient.search({
      type,
      namespaces,
      query: { match_all: {} },
      size: 0, // We only want aggregation results, not documents.
      aggs: {
        unique_creators: {
          terms: {
            field: 'created_by',
            size: 1000, // Reasonable limit for distinct creators.
            // NOTE: We intentionally do NOT set min_doc_count: 0
            // Default min_doc_count: 1 ensures we only get values from matching docs (security safe).
          },
        },
      },
    });

    const aggs = result.aggregations as DistinctCreatorsAggResult | undefined;
    if (!aggs?.unique_creators?.buckets) {
      return [];
    }

    return aggs.unique_creators.buckets.map((bucket) => bucket.key);
  } catch (e) {
    logger.warn(`Failed to get distinct creators: ${e.message}`);
    return [];
  }
};

/**
 * Resolves createdBy filter values to user profile UIDs.
 *
 * Accepts a mix of:
 * - User profile UIDs (e.g., 'u_mleNGqn5T0Cqv49nPpHfLA') - passed through as-is
 * - Usernames (e.g., 'john.doe') - resolved by querying distinct creators and matching profiles
 * - Email addresses (e.g., 'john@elastic.co') - resolved by querying distinct creators and matching profiles
 *
 * This approach uses bulkGet instead of suggest API, which may work on licenses
 * that don't support user profile collaboration APIs.
 *
 * @param values - Array of UIDs, usernames, or emails to resolve.
 * @param distinctCreatorUids - Array of all distinct created_by UIDs from the index.
 * @param coreStart - CoreStart instance for accessing userProfile API.
 * @param logger - Logger instance.
 * @returns Object containing resolved UIDs and input-to-UID mapping.
 */
export const resolveCreatedByFilter = async (
  values: string[],
  distinctCreatorUids: string[],
  coreStart: CoreStart,
  logger: Logger
): Promise<ResolveCreatedByResult> => {
  const result: ResolveCreatedByResult = {
    uids: [],
    inputToUidMap: {},
  };

  if (values.length === 0) {
    return result;
  }

  const namesToResolve: string[] = [];
  const originalInputs: Record<string, string> = {}; // Maps lowercase name to original input.

  // Separate UIDs from names/emails that need resolution.
  for (const value of values) {
    // Handle the special "no-user" sentinel value - pass through unchanged.
    if (value === NULL_USER) {
      result.uids.push(NULL_USER);
      result.inputToUidMap[value] = value;
    } else if (isUserProfileUid(value)) {
      result.uids.push(value);
      // UID maps to itself.
      result.inputToUidMap[value] = value;
    } else {
      const lowerValue = value.toLowerCase();
      namesToResolve.push(lowerValue);
      originalInputs[lowerValue] = value; // Keep original casing for the mapping key.
    }
  }

  // If there are no names to resolve, return early.
  if (namesToResolve.length === 0) {
    return result;
  }

  // If no distinct creators exist, we can't resolve names.
  if (distinctCreatorUids.length === 0) {
    logger.debug(`createdBy filter: cannot resolve names - no creators in index`);
    return result;
  }

  try {
    // Fetch user profiles for all distinct creators using bulkGet.
    logger.debug(
      `createdBy filter: fetching profiles for ${distinctCreatorUids.length} distinct creators`
    );

    const profiles = await coreStart.userProfile.bulkGet<{ avatar?: UserProfileAvatarData }>({
      uids: new Set(distinctCreatorUids),
      dataPath: 'avatar',
    });

    logger.debug(`createdBy filter: bulkGet returned ${profiles.length} profiles`);

    // Build a lookup map: lowercase username/email -> uid
    const nameToUidMap = new Map<string, string>();
    for (const profile of profiles) {
      const { username, email } = profile.user;
      nameToUidMap.set(username.toLowerCase(), profile.uid);
      if (email) {
        nameToUidMap.set(email.toLowerCase(), profile.uid);
      }
    }

    // Resolve each name to a UID.
    for (const name of namesToResolve) {
      const originalInput = originalInputs[name];
      const uid = nameToUidMap.get(name);
      if (uid) {
        result.uids.push(uid);
        result.inputToUidMap[originalInput] = uid;
        logger.debug(`createdBy filter: resolved '${name}' -> ${uid}`);
      } else {
        logger.debug(`createdBy filter: no match found for '${name}'`);
      }
    }
  } catch (e) {
    logger.warn(`Failed to resolve createdBy filter values: ${e.message}`);
    // Return what we have so far.
  }

  return result;
};

/**
 * Fetches user profiles for the given UIDs and returns a map of UID to user info.
 *
 * Uses a module-level LRU cache to avoid redundant API calls. Cached profiles are
 * returned immediately; only uncached UIDs are fetched from the Kibana user profile
 * `bulkGet` API. Fetched profiles are then cached for future requests.
 *
 * Failed lookups are logged as warnings but don't fail the operationâ€”the returned
 * map will simply be missing entries for failed UIDs.
 *
 * @param uids - Array of user profile UIDs to fetch.
 * @param coreStart - CoreStart instance providing access to the userProfile API.
 * @param logger - Logger instance for error reporting.
 * @returns Map of user profile UID to user info object.
 *
 * @example
 * const userInfoMap = await fetchUserProfiles(
 *   ['u_abc123', 'u_def456'],
 *   coreStart,
 *   logger
 * );
 * const userInfo = userInfoMap.get('u_abc123');
 * // Returns: { username: 'john.doe', email: 'john@example.com', fullName: 'John Doe', avatar: {...} }
 */
export const fetchUserProfiles = async (
  uids: string[],
  coreStart: CoreStart,
  logger: Logger
): Promise<Map<string, UserInfo>> => {
  if (uids.length === 0) {
    return new Map<string, UserInfo>();
  }

  // Check cache first to get already-cached profiles.
  const cachedProfiles = getCachedUserProfiles(uids);
  const uncachedUids = uids.filter((uid) => !cachedProfiles.has(uid));

  // If all profiles are cached, return immediately.
  if (uncachedUids.length === 0) {
    logger.debug(`User profile cache hit for all ${uids.length} UIDs`);
    return cachedProfiles;
  }

  logger.debug(
    `User profile cache: ${cachedProfiles.size} hits, ${uncachedUids.length} misses (fetching)`
  );

  // Fetch only uncached profiles from the API.
  const fetchedProfiles = new Map<string, UserInfo>();
  try {
    const profiles = await coreStart.userProfile.bulkGet<{ avatar?: UserProfileAvatarData }>({
      uids: new Set(uncachedUids),
      dataPath: 'avatar',
    });

    for (const profile of profiles) {
      const userInfo: UserInfo = {
        username: profile.user.username,
        email: profile.user.email,
        fullName: profile.user.full_name,
        avatar: profile.data.avatar,
      };
      fetchedProfiles.set(profile.uid, userInfo);
    }

    // Cache the fetched profiles for future requests.
    setCachedUserProfiles(fetchedProfiles);
  } catch (e) {
    // Log but don't fail the request if user profile fetch fails.
    logger.warn(`Failed to fetch user profiles: ${e.message}`);
  }

  // Merge cached and fetched profiles.
  const result = new Map<string, UserInfo>(cachedProfiles);
  for (const [uid, userInfo] of fetchedProfiles) {
    result.set(uid, userInfo);
  }

  return result;
};
