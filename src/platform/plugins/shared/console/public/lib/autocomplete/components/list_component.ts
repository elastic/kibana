/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import _ from 'lodash';
import { SharedComponent } from './shared_component';
/** A component that suggests one of the give options, but accepts anything */
import type { AutocompleteMatch, AutocompleteTermDefinition } from './autocomplete_component';
import type { AutoCompleteContext } from '../types';

type ListGenerator = (
  context?: AutoCompleteContext,
  editor?: unknown
) => AutocompleteTermDefinition[];

export class ListComponent extends SharedComponent {
  listGenerator: ListGenerator;
  multiValued: boolean;
  allowNonValidValues: boolean;

  constructor(
    name: string,
    list: AutocompleteTermDefinition[] | ListGenerator,
    parent?: SharedComponent,
    multiValued?: boolean,
    allowNonValidValues?: boolean
  ) {
    super(name, parent);
    this.listGenerator = Array.isArray(list)
      ? function () {
          return list;
        }
      : list;
    this.multiValued = _.isUndefined(multiValued) ? true : multiValued;
    this.allowNonValidValues = _.isUndefined(allowNonValidValues) ? false : allowNonValidValues;
  }
  getTerms(context: AutoCompleteContext, editor: unknown): AutocompleteTermDefinition[] {
    if (!this.multiValued && context.otherTokenValues) {
      // already have a value -> no suggestions
      return [];
    }
    const alreadySet = context.otherTokenValues
      ? Array.isArray(context.otherTokenValues)
        ? context.otherTokenValues
        : [context.otherTokenValues]
      : [];

    let ret: AutocompleteTermDefinition[] = _.difference(
      this.listGenerator(context, editor),
      alreadySet
    );

    if (this.getDefaultTermMeta()) {
      const meta = this.getDefaultTermMeta();
      ret = _.map(ret, function (term) {
        if (_.isString(term)) {
          term = { name: term };
        }
        return _.defaults(term, { meta });
      });
    }

    return ret;
  }

  validateTokens(tokens: string[]) {
    if (!this.multiValued && tokens.length > 1) {
      return false;
    }

    // verify we have all tokens
    const list = this.listGenerator();
    const notFound = _.some(tokens, function (token) {
      return list.indexOf(token) === -1;
    });

    if (notFound) {
      return false;
    }
    return true;
  }

  getContextKey() {
    return this.name;
  }

  getDefaultTermMeta() {
    return this.name;
  }

  match(
    token: string | string[],
    context: AutoCompleteContext,
    editor: unknown
  ): AutocompleteMatch {
    const tokens = Array.isArray(token) ? token : [token];
    if (!this.allowNonValidValues && !this.validateTokens(tokens)) {
      return null;
    }
    const result = super.match(tokens, context, editor);
    if (!result) {
      return result;
    }
    result.context_values = result.context_values || {};
    result.context_values[this.getContextKey()] = tokens;
    return result;
  }
}
