/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import { i18n } from '@kbn/i18n';
import type { ESQLSearchResponse } from '@kbn/es-types';
import { hasStartEndParams, getStartEndParams } from '@kbn/esql-utils';
import type { TimeCache } from './time_cache';
import type { SearchAPI } from './search_api';
import type { Data, EsqlUrlObject, Bool } from './types';
import { CONTEXT, getRequestName, TIMEFIELD } from './parser_utils';

/**
 * Internal type for EsqlUrlObject with runtime properties added during parsing
 */
interface InternalEsqlUrlObject extends EsqlUrlObject {
  _useTimeParams?: boolean;
}

/**
 * Internal request type using InternalEsqlUrlObject
 */
interface InternalEsqlQueryRequest {
  url: InternalEsqlUrlObject;
  dataObject: Data;
}

/**
 * Named parameters injected into ES|QL query
 */
interface InjectedParams {
  query: string;
  params: Record<string, unknown>[];
}

/**
 * Default value for dropNullColumns parameter
 */
const DEFAULT_DROP_NULL_COLUMNS = true;

/**
 * Localized strings for ESQL query parser
 */
const strings = {
  missingQueryErrorMessage: () =>
    i18n.translate('visTypeVega.esqlQueryParser.missingQueryErrorMessage', {
      defaultMessage:
        '{dataUrlParam} with {typeParam} requires a {queryParam} parameter with an ES|QL query',
      values: {
        dataUrlParam: '"data.url"',
        typeParam: '"%type%": "esql"',
        queryParam: '"query"',
      },
    }),
  emptyQueryErrorMessage: () =>
    i18n.translate('visTypeVega.esqlQueryParser.emptyQueryErrorMessage', {
      defaultMessage: 'ES|QL {queryParam} cannot be empty',
      values: {
        queryParam: '"query"',
      },
    }),
  timeFieldWithoutParamsWarning: () =>
    i18n.translate('visTypeVega.esqlQueryParser.timeFieldWithoutParamsWarning', {
      defaultMessage:
        '{timefieldParam} was specified but query does not contain {tstartParam} or {tendParam} parameters',
      values: {
        timefieldParam: '"%timefield%"',
        tstartParam: '?_tstart',
        tendParam: '?_tend',
      },
    }),
  transformationWarningMessage: (message: string) =>
    i18n.translate('visTypeVega.esqlQueryParser.transformationWarningMessage', {
      defaultMessage: 'Failed to transform ES|QL response: {message}. Returning empty data.',
      values: { message },
    }),
};

/**
 * This class parses ES|QL requests specified in the data.url objects.
 */
export class EsqlQueryParser {
  readonly _timeCache: TimeCache;
  readonly _searchAPI: SearchAPI;
  readonly _filters: Bool;
  readonly _onWarning: (...args: string[]) => void;

  constructor(
    timeCache: TimeCache,
    searchAPI: SearchAPI,
    filters: Bool,
    onWarning: (...args: string[]) => void
  ) {
    this._timeCache = timeCache;
    this._searchAPI = searchAPI;
    this._filters = filters;
    this._onWarning = onWarning;
  }

  /**
   * Update request object, validating ES|QL configuration
   */
  parseUrl(dataObject: Data, url: EsqlUrlObject): { dataObject: Data; url: InternalEsqlUrlObject } {
    // Extract special parameters before creating internal URL
    const context = url[CONTEXT];
    const timefield = url[TIMEFIELD];

    // Create internal URL without mutating the original
    const { [CONTEXT]: _, [TIMEFIELD]: __, ...cleanUrl } = url;
    const internalUrl = cleanUrl as InternalEsqlUrlObject;

    // Validate that query exists
    if (!internalUrl.query || typeof internalUrl.query !== 'string') {
      throw new Error(strings.missingQueryErrorMessage());
    }

    if (internalUrl.query.trim().length === 0) {
      throw new Error(strings.emptyQueryErrorMessage());
    }

    // Handle context
    if (context === true) {
      internalUrl.filter = this._filters;
    }

    // Mark that we need time parameter injection
    if (timefield) {
      internalUrl._useTimeParams = true;
    }

    if (internalUrl.dropNullColumns === undefined) {
      internalUrl.dropNullColumns = DEFAULT_DROP_NULL_COLUMNS;
    }

    return { dataObject, url: internalUrl };
  }

  /**
   * Process items generated by parseUrl()
   */
  async populateData(requests: InternalEsqlQueryRequest[]) {
    const esqlSearches = requests.map((r, index) => {
      const { query, params: urlParams } = this._injectNamedParams(r.url.query, r.url);

      return {
        query,
        filter: r.url.filter,
        params: urlParams,
        dropNullColumns: r.url.dropNullColumns ?? DEFAULT_DROP_NULL_COLUMNS,
        name: getRequestName(r.dataObject.name, index),
      };
    });

    const data$ = this._searchAPI.searchEsql(esqlSearches);
    const results = await data$.toPromise();

    results.forEach((data) => {
      const requestObject = requests.find(
        (item, idx) => getRequestName(item.dataObject.name, idx) === data.name
      );

      if (requestObject) {
        const esqlResponse = data.rawResponse as unknown as ESQLSearchResponse;
        const rowData = this._transformEsqlRowsToVegaRows(esqlResponse);

        requestObject.dataObject.url = requestObject.url;
        requestObject.dataObject.values = rowData;
      }
    });
  }

  /**
   * Inject named parameters for time range
   */
  private _injectNamedParams(query: string, url: InternalEsqlUrlObject): InjectedParams {
    const params: Record<string, unknown>[] = [];

    // Check if we should inject time parameters
    if (url._useTimeParams) {
      if (hasStartEndParams(query)) {
        const bounds = this._timeCache.getTimeBounds();

        // Convert numeric bounds to TimeRange format for shared utility
        const timeRange = {
          from: new Date(bounds.min).toISOString(),
          to: new Date(bounds.max).toISOString(),
        };

        params.push(...getStartEndParams(query, timeRange));
      } else {
        // Warn user that timefield was specified but no parameters in query
        this._onWarning(strings.timeFieldWithoutParamsWarning());
      }
    }

    // Include any params that were explicitly provided in the URL object
    if (url.params && Array.isArray(url.params)) {
      params.push(...url.params);
    }

    return { query, params };
  }

  /**
   * Transform ES|QL columnar response to Vega row-based format
   */
  private _transformEsqlRowsToVegaRows(response: ESQLSearchResponse): Record<string, unknown>[] {
    try {
      // Check response validity before destructuring
      if (!response || !response.columns) {
        throw new Error('Invalid response: missing columns');
      }

      const { columns, values } = response;

      // Handle empty results
      if (!values || values.length === 0) {
        return [];
      }

      // Transform each row from array to object
      const rows = values.map((row) => {
        const rowObject: Record<string, unknown> = {};

        columns.forEach((column, columnIndex) => {
          rowObject[column.name] = row[columnIndex];
        });

        return rowObject;
      });

      return rows;
    } catch (error) {
      this._onWarning(strings.transformationWarningMessage((error as Error).message));
      return [];
    }
  }
}
