/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import * as recast from 'recast';
const n = recast.types.namedTypes;
import fs from 'fs';
import path from 'path';
import { functions } from '../src/sections/generated/scalar_functions';

interface DocsSectionContent {
  description: string;
  preview?: boolean;
}

(function () {
  const pathToElasticsearch = process.argv[2];
  if (!pathToElasticsearch) {
    throw new Error('Path to Elasticsearch must be provided as the first argument.');
  }

  // Define function types and their corresponding output paths
  const functionTypes = [
    { fnType: 'scalar', outputFile: '../src/sections/generated/scalar_functions.tsx' },
    { fnType: 'agg', outputFile: '../src/sections/generated/aggregation_functions.tsx' },
    {
      fnType: 'time_series_agg',
      outputFile: '../src/sections/generated/timeseries_aggregation_functions.tsx',
    },
    { fnType: 'grouping', outputFile: '../src/sections/generated/grouping_functions.tsx' },
    { fnType: 'operator', outputFile: '../src/sections/generated/operators.tsx' },
  ];

  // Process each function type
  functionTypes.forEach(({ fnType, outputFile }) => {
    const functionDocs = loadFunctionDocs({
      pathToDefs: getPathToDefs(pathToElasticsearch, fnType),
      pathToDocs: getPathToDocs(pathToElasticsearch, fnType),
      fnType,
    });

    writeFunctionDocs(functionDocs, path.join(__dirname, outputFile));
  });
})();

/**
 * Constructs the path to the definitions directory.
 */
function getPathToDefs(basePath: string, fnType: string): string {
  return path.join(
    basePath,
    `/docs/reference/query-languages/esql/kibana/definition/${
      fnType === 'operator' ? 'operator' : 'function'
    }s`
  );
}

/**
 * Constructs the path to the documentation directory.
 */
function getPathToDocs(basePath: string, fnType: string): string {
  return path.join(
    basePath,
    `/docs/reference/query-languages/esql/kibana/docs/${
      fnType === 'operator' ? 'operator' : 'function'
    }s`
  );
}

function loadFunctionDocs({
  pathToDefs,
  pathToDocs,
  fnType,
}: {
  pathToDefs: string;
  pathToDocs: string;
  fnType: string;
}) {
  // Read the directory
  const docsFiles = fs.readdirSync(pathToDocs);

  const ESFunctionDefinitions = fs
    .readdirSync(pathToDefs)
    .map((file) => JSON.parse(fs.readFileSync(`${pathToDefs}/${file}`, 'utf-8')));

  const docs = new Map<string, DocsSectionContent>();

  // Iterate over each file in the directory
  for (const file of docsFiles) {
    // Ensure we only process .md files
    if (path.extname(file) === '.md') {
      const functionDefinition = ESFunctionDefinitions.find(
        (def) => def.name === path.basename(file, '.md')
      );

      if (
        !functionDefinition ||
        functionDefinition.snapshot_only ||
        functionDefinition.type !== fnType
      ) {
        continue;
      }

      // Read the file content
      const content = fs.readFileSync(path.join(pathToDocs, file), 'utf-8');

      // Get the function name from the file name by removing the .md extension
      const functionName = `${
        functionDefinition.titleName ? functionDefinition.titleName : path.basename(file, '.md')
      }${functionDefinition.operator ? ` (${functionDefinition.operator})` : ''}`;

      // Add the function name and content to the map
      docs.set(functionName, {
        description: content,
        preview: functionDefinition.preview,
      });
    }
  }

  return docs;
}

function writeFunctionDocs(functionDocs: Map<string, DocsSectionContent>, pathToDocsFile: string) {
  const codeStrings = Array.from(functionDocs.entries()).map(([name, doc]) => {
    const defaultMessage = doc.description
      .replace(/^.*\n/, '') // remove first line (comment from ES)
      .replaceAll('`', '\\`');
    return `
  const foo = 
  // Do not edit manually... automatically generated by scripts/generate_esql_docs.ts
  {
    label: i18n.translate(
      'languageDocumentation.documentationESQL.${name}',
      {
        defaultMessage: '${name.toUpperCase()}',
      }
    ),
    preview: ${doc.preview || false},
    description: (
      <Markdown
        openLinksInNewTab
        readOnly
        enableSoftLineBreaks
        markdownContent={i18n.translate(
          'languageDocumentation.documentationESQL.${name}.markdown',
          {
            defaultMessage: \`${defaultMessage}\`,
            description:
              'Text is in markdown. Do not translate function names, special characters, or field names like sum(bytes)',
            ignoreTag: true,
          }
        )}
      />
    ),
  };`;
  });

  const ast = recast.parse(fs.readFileSync(pathToDocsFile, 'utf-8'), {
    parser: require('recast/parsers/babel'),
  });

  const functionsList = findFunctionsList(ast);

  functionsList.elements = codeStrings.map(
    (codeString) => recast.parse(codeString).program.body[0].declarations[0].init
  );

  const newFileContents = recast.print(ast);

  fs.writeFileSync(pathToDocsFile, newFileContents.code);
}

/**
 * This function searches the AST for the functions list
 */
function findFunctionsList(ast: any): recast.types.namedTypes.ArrayExpression {
  let foundArray: recast.types.namedTypes.ArrayExpression | null = null;

  const functionsArrayIdentifier = Object.keys({ functions })[0];

  recast.visit(ast, {
    visitVariableDeclarator(astPath) {
      if (
        n.Identifier.check(astPath.node.id) &&
        astPath.node.id.name === functionsArrayIdentifier
      ) {
        this.traverse(astPath);
      }
      return false;
    },
    visitObjectProperty(astPath) {
      if (
        n.Identifier.check(astPath.node.key) &&
        astPath.node.key.name === 'items' &&
        n.ArrayExpression.check(astPath.node.value)
      ) {
        foundArray = astPath.node.value;
        this.abort();
      }
      return false;
    },
  });

  if (!foundArray) {
    throw new Error('Could not find the functions array in the AST');
  }

  return foundArray;
}
