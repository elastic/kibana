/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/* eslint-disable no-console */

import * as fs from 'fs';
import * as path from 'path';
import {
  processingCommandsIntro,
  processingCommandsItems,
} from './resources/commands/processing_data';
import { sourceCommandsIntro, sourceCommandsItems } from './resources/commands/source_data';
import type { CommandDefinition, MultipleLicenseInfo } from '../src/types';
import { getLicenseInfoForCommand } from '../src/utils/get_license_info';
import {
  DEFINITION_DIR_SUFFIX,
  ELASTISEARCH_ESQL_DOCS_BASE_PATH,
  OUTPUT_DIR,
} from './scripts.constants';
import { loadElasticDefinitions } from '../src/utils/load_elastic_definitions';

const ELASTIC_COMMAND_DIR_PATH = path.join(
  ELASTISEARCH_ESQL_DOCS_BASE_PATH,
  DEFINITION_DIR_SUFFIX,
  'commands'
);

interface CommandItemMetadata {
  name: string;
  labelDefaultMessage: string;
  descriptionDefaultMessage: string;
  descriptionOptions?: {
    ignoreTag?: boolean;
    description?: string;
  };
  openLinksInNewTab?: boolean;
  preview?: boolean;
  license?: MultipleLicenseInfo;
}

interface CommandSectionMetadata {
  labelKey: string;
  labelDefaultMessage: string;
  descriptionKey: string;
  descriptionDefaultMessage: string;
  items: CommandItemMetadata[];
  outputFile: string;
}

const commandsData: CommandSectionMetadata[] = [
  {
    ...sourceCommandsIntro,
    items: sourceCommandsItems,
    outputFile: `${OUTPUT_DIR}/source_commands.tsx`,
  },
  {
    ...processingCommandsIntro,
    items: processingCommandsItems,
    outputFile: `${OUTPUT_DIR}/processing_commands.tsx`,
  },
];

/**
 * This script generates the ESQL inline command documentation files by merging
 * the source and processing commands with Elasticsearch definitions.
 *
 * Step 1: Load the Elasticsearch command definitions from the specified path.
 * Step 2: Merge the loaded definitions with the source and processing commands.
 * Step 3: Generate separate documentation files for each command type, including the extra information, such as license details.
 * Step 4: Write the generated content to the output files in the specified directory.
 */
(function () {
  try {
    console.log(`Start generating commands documentation`);

    const pathToElasticsearch = process.argv[2];
    if (!pathToElasticsearch) {
      throw new Error(
        'No Elasticsearch path provided, generating without license info for testing...'
      );
    }

    const esCommandDirPath = path.join(pathToElasticsearch, ELASTIC_COMMAND_DIR_PATH);
    const cmdDefinitions = loadElasticDefinitions<CommandDefinition>(esCommandDirPath);
    const commands = commandsData.map((cmd) => addDefinitionsToCommands(cmd, cmdDefinitions));
    const docContents = commands.map((cmd) => generateDoc(cmd));

    // Ensure the output directory exists
    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    // Write each generated documentation file
    docContents.forEach((content, i) => fs.writeFileSync(`${commands[i].outputFile}`, content));
    console.log(`Sucessfully generated commands documentation files`);
  } catch (error) {
    console.error(`Error writing documentation files: ${error.message}`);
    process.exit(1);
  }
})();

/**
 * Adds Elasticsearch information, such as license details, to commands
 */
function addDefinitionsToCommands(
  data: CommandSectionMetadata,
  definitions: Map<string, CommandDefinition>
): CommandSectionMetadata {
  return {
    ...data,
    items: data.items.map((item) => {
      const commandDef = definitions.get(item.name);
      const licenseInfo = getLicenseInfoForCommand(commandDef);

      if (licenseInfo) {
        return {
          ...item,
          license: licenseInfo,
        };
      }
      return item;
    }),
  };
}

/**
 * Generates the full content for a single command documentation file.
 */
function generateDoc(data: CommandSectionMetadata): string {
  return `
import { i18n } from '@kbn/i18n';

// Do not edit manually... automatically generated by scripts/generate_esql_command_docs.ts

export const commands = ${generateCommandSectionDoc(data)};
`;
}

/**
 * Generates a documentation for a specific group of commands.
 */
function generateCommandSectionDoc({
  items,
  labelKey,
  labelDefaultMessage,
  descriptionKey,
  descriptionDefaultMessage,
}: CommandSectionMetadata): string {
  const commandsContentDoc = items.map((item) => generateCommandItemDoc(item)).join(',\n    ');

  return `{
  label: i18n.translate('${labelKey}', {
    defaultMessage: '${labelDefaultMessage}',
  }),
  description: i18n.translate('${descriptionKey}', {
    defaultMessage: \`${descriptionDefaultMessage}\`,
  }),
  items: [
    ${commandsContentDoc}
  ],
}`;
}

/**
 * Generates a single command documentation.
 */
function generateCommandItemDoc({
  name,
  labelDefaultMessage,
  descriptionDefaultMessage,
  openLinksInNewTab,
  descriptionOptions,
  preview,
  license,
}: CommandItemMetadata): string {
  function generateDescriptionOptions(
    options: {
      ignoreTag?: boolean;
      description?: string;
    } = {}
  ) {
    const formattedDescriptionOptions = Object.entries(options || {}).map(([key, value]) =>
      typeof value === 'boolean'
        ? `${key}: ${value},`
        : `${key}: '${String(value).replace(/'/g, "\\'")}',`
    );

    return formattedDescriptionOptions.length > 0
      ? `,\n ${formattedDescriptionOptions.join('\n')}`
      : '';
  }

  // Sample (as a command) use a special suffix to avoid conflict with the same function name
  const labelKey = `languageDocumentation.documentationESQL.${
    name === 'sample' ? name + 'Command' : name
  }`;
  const descriptionKey = `${labelKey}.markdown`;
  const previewProp = preview !== undefined ? `\n preview: ${preview},` : '';
  const licenseProp = license ? `\n license: ${JSON.stringify(license)},` : '';
  // replace(/`/g, '\\`') escape backticks for nested template literals in the generated file
  const description = descriptionDefaultMessage.replace(/`/g, '\\`');

  return `{
      label: i18n.translate('${labelKey}', {
        defaultMessage: '${labelDefaultMessage}',
      }),${previewProp}
      description: {
        markdownContent: i18n.translate('${descriptionKey}', {
          defaultMessage: \`${description}\`${generateDescriptionOptions(descriptionOptions)}
        }),
        openLinksInNewTab: ${openLinksInNewTab ? 'true' : 'false'},
      },${licenseProp}
}`;
}
