/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/**
 * __AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.__
 *
 * @note This file is generated by the `generate_function_definitions.ts`
 * script. Do not edit it manually.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

import { i18n } from '@kbn/i18n';
import { Location } from '../../registry/types';
import { type FunctionDefinition, FunctionDefinitionTypes } from '../types';

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const absDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'abs',
  description: i18n.translate('kbn-esql-language.esql.definitions.abs', {
    defaultMessage: 'Returns the absolute value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW number = -1.0\n| EVAL abs_number = ABS(number)',
    'FROM employees\n| KEEP first_name, last_name, height\n| EVAL abs_height = ABS(0.0 - height)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const acosDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'acos',
  description: i18n.translate('kbn-esql-language.esql.definitions.acos', {
    defaultMessage: 'Returns the arccosine of `n` as an angle, expressed in radians.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Number between -1 and 1. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Number between -1 and 1. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Number between -1 and 1. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Number between -1 and 1. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=.9\n| EVAL acos=ACOS(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const asinDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'asin',
  description: i18n.translate('kbn-esql-language.esql.definitions.asin', {
    defaultMessage:
      'Returns the arcsine of the input\nnumeric expression as an angle, expressed in radians.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Number between -1 and 1. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Number between -1 and 1. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Number between -1 and 1. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Number between -1 and 1. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=.9\n| EVAL asin=ASIN(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const atanDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'atan',
  description: i18n.translate('kbn-esql-language.esql.definitions.atan', {
    defaultMessage:
      'Returns the arctangent of the input\nnumeric expression as an angle, expressed in radians.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=12.9\n| EVAL atan=ATAN(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const atan2Definition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'atan2',
  description: i18n.translate('kbn-esql-language.esql.definitions.atan2', {
    defaultMessage:
      'The angle between the positive x-axis and the ray from the\norigin to the point (x , y) in the Cartesian plane, expressed in radians.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'double',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'double',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'double',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'integer',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'double',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'long',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'double',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'unsigned_long',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'integer',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'double',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'integer',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'integer',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'integer',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'long',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'integer',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'unsigned_long',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'long',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'double',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'long',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'integer',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'long',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'long',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'long',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'unsigned_long',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'unsigned_long',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'double',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'unsigned_long',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'integer',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'unsigned_long',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'long',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'unsigned_long',
          optional: false,
          description: 'y coordinate. If `null`, the function returns `null`.',
        },
        {
          name: 'x_coordinate',
          type: 'unsigned_long',
          optional: false,
          description: 'x coordinate. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW y=12.9, x=.6\n| EVAL atan2=ATAN2(y, x)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const bitLengthDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'bit_length',
  description: i18n.translate('kbn-esql-language.esql.definitions.bit_length', {
    defaultMessage: 'Returns the bit length of a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airports\n| WHERE country == "India"\n| KEEP city\n| EVAL fn_length = LENGTH(city), fn_bit_length = BIT_LENGTH(city)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const byteLengthDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'byte_length',
  description: i18n.translate('kbn-esql-language.esql.definitions.byte_length', {
    defaultMessage: 'Returns the byte length of a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airports\n| WHERE country == "India"\n| KEEP city\n| EVAL fn_length = LENGTH(city), fn_byte_length = BYTE_LENGTH(city)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const cbrtDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'cbrt',
  description: i18n.translate('kbn-esql-language.esql.definitions.cbrt', {
    defaultMessage:
      'Returns the cube root of a number. The input can be any numeric value, the return value is always a double.\nCube roots of infinities are null.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW d = 1000.0\n| EVAL c = CBRT(d)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const ceilDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'ceil',
  description: i18n.translate('kbn-esql-language.esql.definitions.ceil', {
    defaultMessage: 'Round a number up to the nearest integer.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=1.8\n| EVAL a=CEIL(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const chunkDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'chunk',
  description: i18n.translate('kbn-esql-language.esql.definitions.chunk', {
    defaultMessage: 'Use `CHUNK` to split a text field into smaller chunks.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'The input to chunk.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'The input to chunk.',
        },
        {
          name: 'chunking_settings',
          type: 'function_named_parameters',
          mapParams:
            "{name='separator_group', values=[markdown, plaintext], description='Sets a predefined lists of separators based on the selected text type. Values may be `markdown` or `plaintext`.\nOnly applicable to the `recursive` chunking strategy. When using the `recursive` chunking strategy one of\n`separators` or `separator_group` must be specified.\n', type=[keyword]}, {name='overlap', values=[0], description='The number of overlapping words for chunks. It is applicable only to a `word` chunking strategy.\nThis value cannot be higher than half the `max_chunk_size` value.\n', type=[integer]}, {name='sentence_overlap', values=[1, 0], description='The number of overlapping sentences for chunks. It is applicable only for a `sentence` chunking strategy.\nIt can be either `1` or `0`.\n', type=[integer]}, {name='strategy', values=[sentence, word, none, recursive], description='The chunking strategy to use. Default value is `sentence`.', type=[keyword]}, {name='max_chunk_size', values=[300], description='The maximum size of a chunk in words. This value cannot be lower than `20` (for `sentence` strategy)\nor `10` (for `word` or `recursive` strategies). This model should not exceed the window size for any\nassociated models using the output of this function.\n', type=[integer]}, {name='separators', values=[(?<!\\n)\\n\\n(?!\\n), (?<!\\n)\\n(?!\\n)], description='A list of strings used as possible split points when chunking text. Each string can be a plain string or a\nregular expression (regex) pattern. The system tries each separator in order to split the text, starting from\nthe first item in the list. After splitting, it attempts to recombine smaller pieces into larger chunks that stay\nwithin the `max_chunk_size` limit, to reduce the total number of chunks generated. Only applicable to the\n`recursive` chunking strategy. When using the `recursive` chunking strategy one of `separators` or `separator_group`\nmust be specified.\n', type=[keyword]}",
          optional: true,
          description:
            'Options to customize chunking behavior. Defaults to {"strategy":"sentence","max_chunk_size":300,"sentence_overlap":0}.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'The input to chunk.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'The input to chunk.',
        },
        {
          name: 'chunking_settings',
          type: 'function_named_parameters',
          mapParams:
            "{name='separator_group', values=[markdown, plaintext], description='Sets a predefined lists of separators based on the selected text type. Values may be `markdown` or `plaintext`.\nOnly applicable to the `recursive` chunking strategy. When using the `recursive` chunking strategy one of\n`separators` or `separator_group` must be specified.\n', type=[keyword]}, {name='overlap', values=[0], description='The number of overlapping words for chunks. It is applicable only to a `word` chunking strategy.\nThis value cannot be higher than half the `max_chunk_size` value.\n', type=[integer]}, {name='sentence_overlap', values=[1, 0], description='The number of overlapping sentences for chunks. It is applicable only for a `sentence` chunking strategy.\nIt can be either `1` or `0`.\n', type=[integer]}, {name='strategy', values=[sentence, word, none, recursive], description='The chunking strategy to use. Default value is `sentence`.', type=[keyword]}, {name='max_chunk_size', values=[300], description='The maximum size of a chunk in words. This value cannot be lower than `20` (for `sentence` strategy)\nor `10` (for `word` or `recursive` strategies). This model should not exceed the window size for any\nassociated models using the output of this function.\n', type=[integer]}, {name='separators', values=[(?<!\\n)\\n\\n(?!\\n), (?<!\\n)\\n(?!\\n)], description='A list of strings used as possible split points when chunking text. Each string can be a plain string or a\nregular expression (regex) pattern. The system tries each separator in order to split the text, starting from\nthe first item in the list. After splitting, it attempts to recombine smaller pieces into larger chunks that stay\nwithin the `max_chunk_size` limit, to reduce the total number of chunks generated. Only applicable to the\n`recursive` chunking strategy. When using the `recursive` chunking strategy one of `separators` or `separator_group`\nmust be specified.\n', type=[keyword]}",
          optional: true,
          description:
            'Options to customize chunking behavior. Defaults to {"strategy":"sentence","max_chunk_size":300,"sentence_overlap":0}.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW result = CHUNK("It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief.", {"strategy": "word", "max_chunk_size": 10, "overlap": 1})\n| MV_EXPAND result',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const cidrMatchDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'cidr_match',
  description: i18n.translate('kbn-esql-language.esql.definitions.cidr_match', {
    defaultMessage:
      'Returns true if the provided IP is contained in one of the provided CIDR blocks.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'ip',
          type: 'ip',
          optional: false,
          description: 'IP address of type `ip` (both IPv4 and IPv6 are supported).',
        },
        {
          name: 'blockX',
          type: 'keyword',
          optional: false,
          description: 'CIDR block to test the IP against.',
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'ip',
          type: 'ip',
          optional: false,
          description: 'IP address of type `ip` (both IPv4 and IPv6 are supported).',
        },
        {
          name: 'blockX',
          type: 'text',
          optional: false,
          description: 'CIDR block to test the IP against.',
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM hosts\n| WHERE CIDR_MATCH(ip1, "127.0.0.2/32", "127.0.0.3/32")\n| KEEP card, host, ip0, ip1',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const clampDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'clamp',
  description: i18n.translate('kbn-esql-language.esql.definitions.clamp', {
    defaultMessage:
      'Limits (or clamps) the values of all samples to have a lower limit of min and an upper limit of max.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'boolean',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'boolean',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'date',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'date',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'double',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'double',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'integer',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'integer',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'unsigned_long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'unsigned_long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'double',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'double',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'integer',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'integer',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'unsigned_long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'unsigned_long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'ip',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'ip',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'keyword',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'keyword',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'double',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'double',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'integer',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'integer',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'unsigned_long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'unsigned_long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'double',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'double',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'integer',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'integer',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'unsigned_long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'unsigned_long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'min',
          type: 'version',
          optional: false,
          description: 'The min value to clamp data into.',
        },
        {
          name: 'max',
          type: 'version',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'TS k8s\n| EVAL full_clamped_cost = clamp(network.cost, clamp_max(network.bytes_in, 5), network.bytes_in / 100)\n| KEEP full_clamped_cost, @timestamp',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const clampMaxDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'clamp_max',
  description: i18n.translate('kbn-esql-language.esql.definitions.clamp_max', {
    defaultMessage:
      'Limits (or clamps) all input sample values to an upper bound of max. Any value above max is reduced to max.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'boolean',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'date',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'double',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'integer',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'unsigned_long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'double',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'integer',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'unsigned_long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'ip',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'keyword',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'double',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'integer',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'unsigned_long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'double',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'integer',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'unsigned_long',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'max',
          type: 'version',
          optional: false,
          description: 'The max value to clamp data into.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'TS k8s\n| STATS full_clamped_cost=sum(clamp(network.cost, 1, 2)), clamped_cost=sum(clamp_max(network.cost, 1)), clamped_min_cost=sum(clamp_min(network.cost, 10)) BY time_bucket = bucket(@timestamp,1minute)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const clampMinDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'clamp_min',
  description: i18n.translate('kbn-esql-language.esql.definitions.clamp_min', {
    defaultMessage:
      'Limits (or clamps) all input sample values to a lower bound of min. Any value below min is set to min.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'boolean',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'date',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'double',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'integer',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'unsigned_long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'double',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'integer',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'unsigned_long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'ip',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'keyword',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'double',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'integer',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'unsigned_long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'double',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'integer',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'unsigned_long',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'field to clamp.',
        },
        {
          name: 'min',
          type: 'version',
          optional: false,
          description: 'The min value to clamp data into.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM k8s\n| STATS full_clamped_cost=sum(clamp(network.cost, 1, 2)), clamped_cost=sum(clamp_max(network.cost, 1)), clamped_min_cost=sum(clamp_min(network.cost, 10)) BY time_bucket = bucket(@timestamp,1minute)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const coalesceDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'coalesce',
  description: i18n.translate('kbn-esql-language.esql.definitions.coalesce', {
    defaultMessage:
      'Returns the first of its arguments that is not null. If all arguments are null, it returns `null`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
          description: 'Expression to evaluate.',
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'boolean',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'cartesian_point',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'cartesian_point',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'cartesian_point',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'cartesian_shape',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'cartesian_shape',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'cartesian_shape',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'date',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'date',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date_nanos',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'date_nanos',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'date_nanos',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'exponential_histogram',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'exponential_histogram',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'exponential_histogram',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'geo_point',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'geo_point',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'geo_point',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'geo_shape',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'geo_shape',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'geo_shape',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'geohash',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'geohash',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'geohash',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'geohex',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'geohex',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'geohex',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'geotile',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'geotile',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'geotile',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
          description: 'Expression to evaluate.',
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'integer',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'ip',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'ip',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'ip',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
          description: 'Expression to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'keyword',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
          description: 'Expression to evaluate.',
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'long',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
          description: 'Expression to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'text',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'version',
          optional: false,
          description: 'Expression to evaluate.',
        },
        {
          name: 'rest',
          type: 'version',
          optional: true,
          description: 'Other expression to evaluate.',
        },
      ],
      returnType: 'version',
      minParams: 1,
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=null, b="b"\n| EVAL COALESCE(a, b)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const concatDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'concat',
  description: i18n.translate('kbn-esql-language.esql.definitions.concat', {
    defaultMessage: 'Concatenates two or more strings.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
          description: 'Strings to concatenate.',
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
          description: 'Strings to concatenate.',
        },
      ],
      returnType: 'keyword',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
          description: 'Strings to concatenate.',
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
          description: 'Strings to concatenate.',
        },
      ],
      returnType: 'keyword',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
          description: 'Strings to concatenate.',
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
          description: 'Strings to concatenate.',
        },
      ],
      returnType: 'keyword',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
          description: 'Strings to concatenate.',
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
          description: 'Strings to concatenate.',
        },
      ],
      returnType: 'keyword',
      minParams: 2,
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM employees\n| KEEP first_name, last_name\n| EVAL fullname = CONCAT(first_name, " ", last_name)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const containsDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'contains',
  description: i18n.translate('kbn-esql-language.esql.definitions.contains', {
    defaultMessage:
      'Returns a boolean that indicates whether a keyword substring is within another string.\nReturns `null` if either parameter is null.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description:
            'String expression: input string to check against. If `null`, the function returns `null`.',
        },
        {
          name: 'substring',
          type: 'keyword',
          optional: false,
          description:
            'String expression: A substring to find in the input string. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description:
            'String expression: input string to check against. If `null`, the function returns `null`.',
        },
        {
          name: 'substring',
          type: 'text',
          optional: false,
          description:
            'String expression: A substring to find in the input string. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description:
            'String expression: input string to check against. If `null`, the function returns `null`.',
        },
        {
          name: 'substring',
          type: 'keyword',
          optional: false,
          description:
            'String expression: A substring to find in the input string. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description:
            'String expression: input string to check against. If `null`, the function returns `null`.',
        },
        {
          name: 'substring',
          type: 'text',
          optional: false,
          description:
            'String expression: A substring to find in the input string. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a = "hello"\n| EVAL has_ll = CONTAINS(a, "ll")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const copySignDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'copy_sign',
  description: i18n.translate('kbn-esql-language.esql.definitions.copy_sign', {
    defaultMessage:
      "Returns a value with the magnitude of the first argument and the sign of the second argument.\nThis function is similar to Java's Math.copySign(double magnitude, double sign) which is\nsimilar to `copysign` from IEEE 754.",
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'magnitude',
          type: 'double',
          optional: false,
          description:
            'The expression providing the magnitude of the result. Must be a numeric type.',
        },
        {
          name: 'sign',
          type: 'double',
          optional: false,
          description: 'The expression providing the sign of the result. Must be a numeric type.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'magnitude',
          type: 'double',
          optional: false,
          description:
            'The expression providing the magnitude of the result. Must be a numeric type.',
        },
        {
          name: 'sign',
          type: 'integer',
          optional: false,
          description: 'The expression providing the sign of the result. Must be a numeric type.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'magnitude',
          type: 'double',
          optional: false,
          description:
            'The expression providing the magnitude of the result. Must be a numeric type.',
        },
        {
          name: 'sign',
          type: 'long',
          optional: false,
          description: 'The expression providing the sign of the result. Must be a numeric type.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'magnitude',
          type: 'integer',
          optional: false,
          description:
            'The expression providing the magnitude of the result. Must be a numeric type.',
        },
        {
          name: 'sign',
          type: 'double',
          optional: false,
          description: 'The expression providing the sign of the result. Must be a numeric type.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'magnitude',
          type: 'integer',
          optional: false,
          description:
            'The expression providing the magnitude of the result. Must be a numeric type.',
        },
        {
          name: 'sign',
          type: 'integer',
          optional: false,
          description: 'The expression providing the sign of the result. Must be a numeric type.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'magnitude',
          type: 'integer',
          optional: false,
          description:
            'The expression providing the magnitude of the result. Must be a numeric type.',
        },
        {
          name: 'sign',
          type: 'long',
          optional: false,
          description: 'The expression providing the sign of the result. Must be a numeric type.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'magnitude',
          type: 'long',
          optional: false,
          description:
            'The expression providing the magnitude of the result. Must be a numeric type.',
        },
        {
          name: 'sign',
          type: 'double',
          optional: false,
          description: 'The expression providing the sign of the result. Must be a numeric type.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'magnitude',
          type: 'long',
          optional: false,
          description:
            'The expression providing the magnitude of the result. Must be a numeric type.',
        },
        {
          name: 'sign',
          type: 'integer',
          optional: false,
          description: 'The expression providing the sign of the result. Must be a numeric type.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'magnitude',
          type: 'long',
          optional: false,
          description:
            'The expression providing the magnitude of the result. Must be a numeric type.',
        },
        {
          name: 'sign',
          type: 'long',
          optional: false,
          description: 'The expression providing the sign of the result. Must be a numeric type.',
        },
      ],
      returnType: 'long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['FROM employees\n| EVAL cs1 = COPY_SIGN(salary, LEAST(salary_change))'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const cosDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'cos',
  description: i18n.translate('kbn-esql-language.esql.definitions.cos', {
    defaultMessage: 'Returns the cosine of an angle.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'angle',
          type: 'double',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'integer',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'long',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'unsigned_long',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=1.8\n| EVAL cos=COS(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const coshDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'cosh',
  description: i18n.translate('kbn-esql-language.esql.definitions.cosh', {
    defaultMessage: 'Returns the hyperbolic cosine of a number.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=1.8\n| EVAL cosh=COSH(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dateDiffDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'date_diff',
  description: i18n.translate('kbn-esql-language.esql.definitions.date_diff', {
    defaultMessage:
      'Subtracts the `startTimestamp` from the `endTimestamp` and returns the difference in multiples of `unit`.\nIf `startTimestamp` is later than the `endTimestamp`, negative values are returned.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'unit',
          type: 'keyword',
          optional: false,
          description: 'Time difference unit',
          suggestedValues: [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
            'microsecond',
            'nanosecond',
          ],
        },
        {
          name: 'startTimestamp',
          type: 'date',
          optional: false,
          description: 'A string representing a start timestamp',
        },
        {
          name: 'endTimestamp',
          type: 'date',
          optional: false,
          description: 'A string representing an end timestamp',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'keyword',
          optional: false,
          description: 'Time difference unit',
          suggestedValues: [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
            'microsecond',
            'nanosecond',
          ],
        },
        {
          name: 'startTimestamp',
          type: 'date',
          optional: false,
          description: 'A string representing a start timestamp',
        },
        {
          name: 'endTimestamp',
          type: 'date_nanos',
          optional: false,
          description: 'A string representing an end timestamp',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'keyword',
          optional: false,
          description: 'Time difference unit',
          suggestedValues: [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
            'microsecond',
            'nanosecond',
          ],
        },
        {
          name: 'startTimestamp',
          type: 'date_nanos',
          optional: false,
          description: 'A string representing a start timestamp',
        },
        {
          name: 'endTimestamp',
          type: 'date',
          optional: false,
          description: 'A string representing an end timestamp',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'keyword',
          optional: false,
          description: 'Time difference unit',
          suggestedValues: [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
            'microsecond',
            'nanosecond',
          ],
        },
        {
          name: 'startTimestamp',
          type: 'date_nanos',
          optional: false,
          description: 'A string representing a start timestamp',
        },
        {
          name: 'endTimestamp',
          type: 'date_nanos',
          optional: false,
          description: 'A string representing an end timestamp',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'text',
          optional: false,
          description: 'Time difference unit',
          suggestedValues: [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
            'microsecond',
            'nanosecond',
          ],
        },
        {
          name: 'startTimestamp',
          type: 'date',
          optional: false,
          description: 'A string representing a start timestamp',
        },
        {
          name: 'endTimestamp',
          type: 'date',
          optional: false,
          description: 'A string representing an end timestamp',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'text',
          optional: false,
          description: 'Time difference unit',
          suggestedValues: [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
            'microsecond',
            'nanosecond',
          ],
        },
        {
          name: 'startTimestamp',
          type: 'date',
          optional: false,
          description: 'A string representing a start timestamp',
        },
        {
          name: 'endTimestamp',
          type: 'date_nanos',
          optional: false,
          description: 'A string representing an end timestamp',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'text',
          optional: false,
          description: 'Time difference unit',
          suggestedValues: [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
            'microsecond',
            'nanosecond',
          ],
        },
        {
          name: 'startTimestamp',
          type: 'date_nanos',
          optional: false,
          description: 'A string representing a start timestamp',
        },
        {
          name: 'endTimestamp',
          type: 'date',
          optional: false,
          description: 'A string representing an end timestamp',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'text',
          optional: false,
          description: 'Time difference unit',
          suggestedValues: [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
            'microsecond',
            'nanosecond',
          ],
        },
        {
          name: 'startTimestamp',
          type: 'date_nanos',
          optional: false,
          description: 'A string representing a start timestamp',
        },
        {
          name: 'endTimestamp',
          type: 'date_nanos',
          optional: false,
          description: 'A string representing an end timestamp',
        },
      ],
      returnType: 'integer',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW date1 = TO_DATETIME("2023-12-02T11:00:00.000Z"),\n    date2 = TO_DATETIME("2023-12-02T11:00:00.001Z")\n| EVAL dd_ms = DATE_DIFF("microseconds", date1, date2)',
    'ROW end_23 = TO_DATETIME("2023-12-31T23:59:59.999Z"),\n  start_24 = TO_DATETIME("2024-01-01T00:00:00.000Z"),\n    end_24 = TO_DATETIME("2024-12-31T23:59:59.999")\n| EVAL end23_to_start24 = DATE_DIFF("year", end_23, start_24)\n| EVAL end23_to_end24   = DATE_DIFF("year", end_23, end_24)\n| EVAL start_to_end_24  = DATE_DIFF("year", start_24, end_24)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dateExtractDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'date_extract',
  description: i18n.translate('kbn-esql-language.esql.definitions.date_extract', {
    defaultMessage: 'Extracts parts of a date, like year, month, day, hour.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'datePart',
          type: 'keyword',
          optional: false,
          description:
            'Part of the date to extract.  Can be: `aligned_day_of_week_in_month`, `aligned_day_of_week_in_year`, `aligned_week_of_month`, `aligned_week_of_year`, `ampm_of_day`, `clock_hour_of_ampm`, `clock_hour_of_day`, `day_of_month`, `day_of_week`, `day_of_year`, `epoch_day`, `era`, `hour_of_ampm`, `hour_of_day`, `instant_seconds`, `micro_of_day`, `micro_of_second`, `milli_of_day`, `milli_of_second`, `minute_of_day`, `minute_of_hour`, `month_of_year`, `nano_of_day`, `nano_of_second`, `offset_seconds`, `proleptic_month`, `second_of_day`, `second_of_minute`, `year`, or `year_of_era`. Refer to {javadoc8}/java/time/temporal/ChronoField.html[java.time.temporal.ChronoField] for a description of these values.  If `null`, the function returns `null`.',
          suggestedValues: [
            'ALIGNED_DAY_OF_WEEK_IN_MONTH',
            'ALIGNED_DAY_OF_WEEK_IN_YEAR',
            'ALIGNED_WEEK_OF_MONTH',
            'ALIGNED_WEEK_OF_YEAR',
            'AMPM_OF_DAY',
            'CLOCK_HOUR_OF_AMPM',
            'CLOCK_HOUR_OF_DAY',
            'DAY_OF_MONTH',
            'DAY_OF_WEEK',
            'DAY_OF_YEAR',
            'EPOCH_DAY',
            'ERA',
            'HOUR_OF_AMPM',
            'HOUR_OF_DAY',
            'INSTANT_SECONDS',
            'MICRO_OF_DAY',
            'MICRO_OF_SECOND',
            'MILLI_OF_DAY',
            'MILLI_OF_SECOND',
            'MINUTE_OF_DAY',
            'MINUTE_OF_HOUR',
            'MONTH_OF_YEAR',
            'NANO_OF_DAY',
            'NANO_OF_SECOND',
            'OFFSET_SECONDS',
            'PROLEPTIC_MONTH',
            'SECOND_OF_DAY',
            'SECOND_OF_MINUTE',
            'YEAR',
            'YEAR_OF_ERA',
          ],
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'datePart',
          type: 'keyword',
          optional: false,
          description:
            'Part of the date to extract.  Can be: `aligned_day_of_week_in_month`, `aligned_day_of_week_in_year`, `aligned_week_of_month`, `aligned_week_of_year`, `ampm_of_day`, `clock_hour_of_ampm`, `clock_hour_of_day`, `day_of_month`, `day_of_week`, `day_of_year`, `epoch_day`, `era`, `hour_of_ampm`, `hour_of_day`, `instant_seconds`, `micro_of_day`, `micro_of_second`, `milli_of_day`, `milli_of_second`, `minute_of_day`, `minute_of_hour`, `month_of_year`, `nano_of_day`, `nano_of_second`, `offset_seconds`, `proleptic_month`, `second_of_day`, `second_of_minute`, `year`, or `year_of_era`. Refer to {javadoc8}/java/time/temporal/ChronoField.html[java.time.temporal.ChronoField] for a description of these values.  If `null`, the function returns `null`.',
          suggestedValues: [
            'ALIGNED_DAY_OF_WEEK_IN_MONTH',
            'ALIGNED_DAY_OF_WEEK_IN_YEAR',
            'ALIGNED_WEEK_OF_MONTH',
            'ALIGNED_WEEK_OF_YEAR',
            'AMPM_OF_DAY',
            'CLOCK_HOUR_OF_AMPM',
            'CLOCK_HOUR_OF_DAY',
            'DAY_OF_MONTH',
            'DAY_OF_WEEK',
            'DAY_OF_YEAR',
            'EPOCH_DAY',
            'ERA',
            'HOUR_OF_AMPM',
            'HOUR_OF_DAY',
            'INSTANT_SECONDS',
            'MICRO_OF_DAY',
            'MICRO_OF_SECOND',
            'MILLI_OF_DAY',
            'MILLI_OF_SECOND',
            'MINUTE_OF_DAY',
            'MINUTE_OF_HOUR',
            'MONTH_OF_YEAR',
            'NANO_OF_DAY',
            'NANO_OF_SECOND',
            'OFFSET_SECONDS',
            'PROLEPTIC_MONTH',
            'SECOND_OF_DAY',
            'SECOND_OF_MINUTE',
            'YEAR',
            'YEAR_OF_ERA',
          ],
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'datePart',
          type: 'text',
          optional: false,
          description:
            'Part of the date to extract.  Can be: `aligned_day_of_week_in_month`, `aligned_day_of_week_in_year`, `aligned_week_of_month`, `aligned_week_of_year`, `ampm_of_day`, `clock_hour_of_ampm`, `clock_hour_of_day`, `day_of_month`, `day_of_week`, `day_of_year`, `epoch_day`, `era`, `hour_of_ampm`, `hour_of_day`, `instant_seconds`, `micro_of_day`, `micro_of_second`, `milli_of_day`, `milli_of_second`, `minute_of_day`, `minute_of_hour`, `month_of_year`, `nano_of_day`, `nano_of_second`, `offset_seconds`, `proleptic_month`, `second_of_day`, `second_of_minute`, `year`, or `year_of_era`. Refer to {javadoc8}/java/time/temporal/ChronoField.html[java.time.temporal.ChronoField] for a description of these values.  If `null`, the function returns `null`.',
          suggestedValues: [
            'ALIGNED_DAY_OF_WEEK_IN_MONTH',
            'ALIGNED_DAY_OF_WEEK_IN_YEAR',
            'ALIGNED_WEEK_OF_MONTH',
            'ALIGNED_WEEK_OF_YEAR',
            'AMPM_OF_DAY',
            'CLOCK_HOUR_OF_AMPM',
            'CLOCK_HOUR_OF_DAY',
            'DAY_OF_MONTH',
            'DAY_OF_WEEK',
            'DAY_OF_YEAR',
            'EPOCH_DAY',
            'ERA',
            'HOUR_OF_AMPM',
            'HOUR_OF_DAY',
            'INSTANT_SECONDS',
            'MICRO_OF_DAY',
            'MICRO_OF_SECOND',
            'MILLI_OF_DAY',
            'MILLI_OF_SECOND',
            'MINUTE_OF_DAY',
            'MINUTE_OF_HOUR',
            'MONTH_OF_YEAR',
            'NANO_OF_DAY',
            'NANO_OF_SECOND',
            'OFFSET_SECONDS',
            'PROLEPTIC_MONTH',
            'SECOND_OF_DAY',
            'SECOND_OF_MINUTE',
            'YEAR',
            'YEAR_OF_ERA',
          ],
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'datePart',
          type: 'text',
          optional: false,
          description:
            'Part of the date to extract.  Can be: `aligned_day_of_week_in_month`, `aligned_day_of_week_in_year`, `aligned_week_of_month`, `aligned_week_of_year`, `ampm_of_day`, `clock_hour_of_ampm`, `clock_hour_of_day`, `day_of_month`, `day_of_week`, `day_of_year`, `epoch_day`, `era`, `hour_of_ampm`, `hour_of_day`, `instant_seconds`, `micro_of_day`, `micro_of_second`, `milli_of_day`, `milli_of_second`, `minute_of_day`, `minute_of_hour`, `month_of_year`, `nano_of_day`, `nano_of_second`, `offset_seconds`, `proleptic_month`, `second_of_day`, `second_of_minute`, `year`, or `year_of_era`. Refer to {javadoc8}/java/time/temporal/ChronoField.html[java.time.temporal.ChronoField] for a description of these values.  If `null`, the function returns `null`.',
          suggestedValues: [
            'ALIGNED_DAY_OF_WEEK_IN_MONTH',
            'ALIGNED_DAY_OF_WEEK_IN_YEAR',
            'ALIGNED_WEEK_OF_MONTH',
            'ALIGNED_WEEK_OF_YEAR',
            'AMPM_OF_DAY',
            'CLOCK_HOUR_OF_AMPM',
            'CLOCK_HOUR_OF_DAY',
            'DAY_OF_MONTH',
            'DAY_OF_WEEK',
            'DAY_OF_YEAR',
            'EPOCH_DAY',
            'ERA',
            'HOUR_OF_AMPM',
            'HOUR_OF_DAY',
            'INSTANT_SECONDS',
            'MICRO_OF_DAY',
            'MICRO_OF_SECOND',
            'MILLI_OF_DAY',
            'MILLI_OF_SECOND',
            'MINUTE_OF_DAY',
            'MINUTE_OF_HOUR',
            'MONTH_OF_YEAR',
            'NANO_OF_DAY',
            'NANO_OF_SECOND',
            'OFFSET_SECONDS',
            'PROLEPTIC_MONTH',
            'SECOND_OF_DAY',
            'SECOND_OF_MINUTE',
            'YEAR',
            'YEAR_OF_ERA',
          ],
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW date = DATE_PARSE("yyyy-MM-dd", "2022-05-06")\n| EVAL year = DATE_EXTRACT("year", date)',
    'FROM sample_data\n| WHERE DATE_EXTRACT("hour_of_day", @timestamp) < 9\n    AND DATE_EXTRACT("hour_of_day", @timestamp) >= 17',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dateFormatDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'date_format',
  description: i18n.translate('kbn-esql-language.esql.definitions.date_format', {
    defaultMessage: 'Returns a string representation of a date, in the provided format.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'date',
          type: 'date',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'dateFormat',
          type: 'keyword',
          optional: true,
          description:
            "Date format (optional).  If no format is specified, the `yyyy-MM-dd'T'HH:mm:ss.SSSZ` format is used. If `null`, the function returns `null`.",
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'dateFormat',
          type: 'keyword',
          optional: true,
          description:
            "Date format (optional).  If no format is specified, the `yyyy-MM-dd'T'HH:mm:ss.SSSZ` format is used. If `null`, the function returns `null`.",
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'dateFormat',
          type: 'text',
          optional: true,
          description:
            "Date format (optional).  If no format is specified, the `yyyy-MM-dd'T'HH:mm:ss.SSSZ` format is used. If `null`, the function returns `null`.",
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'dateFormat',
          type: 'text',
          optional: true,
          description:
            "Date format (optional).  If no format is specified, the `yyyy-MM-dd'T'HH:mm:ss.SSSZ` format is used. If `null`, the function returns `null`.",
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM employees\n| KEEP first_name, last_name, hire_date\n| EVAL hired = DATE_FORMAT("yyyy-MM-dd", hire_date)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dateParseDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'date_parse',
  description: i18n.translate('kbn-esql-language.esql.definitions.date_parse', {
    defaultMessage:
      'Returns a date by parsing the second argument using the format specified in the first argument.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'dateString',
          type: 'keyword',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'keyword',
          optional: true,
          description:
            'The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`.',
        },
        {
          name: 'dateString',
          type: 'keyword',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'keyword',
          optional: true,
          description:
            'The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`.',
        },
        {
          name: 'dateString',
          type: 'keyword',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.', type=[keyword]}, {name='locale', values=[standard], description='The locale to use when parsing the date, relevant when parsing month names or week days.', type=[keyword]}",
          optional: true,
          description:
            '(Optional) Additional options for date parsing, specifying time zone and locale as <<esql-function-named-params,function named parameters>>.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'dateString',
          type: 'keyword',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.', type=[keyword]}, {name='locale', values=[standard], description='The locale to use when parsing the date, relevant when parsing month names or week days.', type=[keyword]}",
          optional: true,
          description:
            '(Optional) Additional options for date parsing, specifying time zone and locale as <<esql-function-named-params,function named parameters>>.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'keyword',
          optional: true,
          description:
            'The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`.',
        },
        {
          name: 'dateString',
          type: 'text',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'keyword',
          optional: true,
          description:
            'The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`.',
        },
        {
          name: 'dateString',
          type: 'text',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.', type=[keyword]}, {name='locale', values=[standard], description='The locale to use when parsing the date, relevant when parsing month names or week days.', type=[keyword]}",
          optional: true,
          description:
            '(Optional) Additional options for date parsing, specifying time zone and locale as <<esql-function-named-params,function named parameters>>.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'dateString',
          type: 'text',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'text',
          optional: true,
          description:
            'The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`.',
        },
        {
          name: 'dateString',
          type: 'keyword',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'text',
          optional: true,
          description:
            'The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`.',
        },
        {
          name: 'dateString',
          type: 'keyword',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.', type=[keyword]}, {name='locale', values=[standard], description='The locale to use when parsing the date, relevant when parsing month names or week days.', type=[keyword]}",
          optional: true,
          description:
            '(Optional) Additional options for date parsing, specifying time zone and locale as <<esql-function-named-params,function named parameters>>.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'dateString',
          type: 'text',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.', type=[keyword]}, {name='locale', values=[standard], description='The locale to use when parsing the date, relevant when parsing month names or week days.', type=[keyword]}",
          optional: true,
          description:
            '(Optional) Additional options for date parsing, specifying time zone and locale as <<esql-function-named-params,function named parameters>>.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'text',
          optional: true,
          description:
            'The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`.',
        },
        {
          name: 'dateString',
          type: 'text',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'text',
          optional: true,
          description:
            'The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`.',
        },
        {
          name: 'dateString',
          type: 'text',
          optional: false,
          description:
            'Date expression as a string. If `null` or an empty string, the function returns `null`.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.', type=[keyword]}, {name='locale', values=[standard], description='The locale to use when parsing the date, relevant when parsing month names or week days.', type=[keyword]}",
          optional: true,
          description:
            '(Optional) Additional options for date parsing, specifying time zone and locale as <<esql-function-named-params,function named parameters>>.',
        },
      ],
      returnType: 'date',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW date_string = "2022-05-06"\n| EVAL date = DATE_PARSE("yyyy-MM-dd", date_string)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dateTruncDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'date_trunc',
  description: i18n.translate('kbn-esql-language.esql.definitions.date_trunc', {
    defaultMessage:
      'Rounds down a date to the closest interval since epoch, which starts at `0001-01-01T00:00:00Z`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'interval',
          type: 'date_period',
          optional: false,
          description: 'Interval; expressed using the timespan literal syntax.',
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
          description: 'Date expression',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'interval',
          type: 'date_period',
          optional: false,
          description: 'Interval; expressed using the timespan literal syntax.',
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
          description: 'Date expression',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'interval',
          type: 'time_duration',
          optional: false,
          description: 'Interval; expressed using the timespan literal syntax.',
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
          description: 'Date expression',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'interval',
          type: 'time_duration',
          optional: false,
          description: 'Interval; expressed using the timespan literal syntax.',
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
          description: 'Date expression',
        },
      ],
      returnType: 'date_nanos',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM employees\n| KEEP first_name, last_name, hire_date\n| EVAL year_hired = DATE_TRUNC(1 year, hire_date)',
    'FROM employees\n| EVAL year = DATE_TRUNC(1 year, hire_date)\n| STATS hires = COUNT(emp_no) BY year\n| SORT year',
    'FROM sample_data\n| EVAL error = CASE(message LIKE "*error*", 1, 0)\n| EVAL hour = DATE_TRUNC(1 hour, @timestamp)\n| STATS error_rate = AVG(error) by hour\n| SORT hour',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dayNameDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'day_name',
  description: i18n.translate('kbn-esql-language.esql.definitions.day_name', {
    defaultMessage: 'Returns the name of the weekday for date based on the configured Locale.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'date',
          type: 'date',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW dt = to_datetime("1953-09-02T00:00:00.000Z")\n| EVAL weekday = DAY_NAME(dt);'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const decayDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'decay',
  description: i18n.translate('kbn-esql-language.esql.definitions.decay', {
    defaultMessage:
      'Calculates a relevance score that decays based on the distance of a numeric, spatial or date type value from a target origin, using configurable decay functions.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'value',
          type: 'cartesian_point',
          optional: false,
          description: 'The input value to apply decay scoring to.',
        },
        {
          name: 'origin',
          type: 'cartesian_point',
          optional: false,
          description: 'Central point from which the distances are calculated.',
        },
        {
          name: 'scale',
          type: 'double',
          optional: false,
          description: 'Distance from the origin where the function returns the decay value.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='offset', values=[], description='Distance from the origin where no decay occurs.', type=[double, integer, long, time_duration, keyword, text]}, {name='type', values=[], description='Decay function to use: linear, exponential or gaussian.', type=[keyword]}, {name='decay', values=[], description='Multiplier value returned at the scale distance from the origin.', type=[double]}",
          optional: true,
          description: '',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'value',
          type: 'date',
          optional: false,
          description: 'The input value to apply decay scoring to.',
        },
        {
          name: 'origin',
          type: 'date',
          optional: false,
          description: 'Central point from which the distances are calculated.',
        },
        {
          name: 'scale',
          type: 'time_duration',
          optional: false,
          description: 'Distance from the origin where the function returns the decay value.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='offset', values=[], description='Distance from the origin where no decay occurs.', type=[double, integer, long, time_duration, keyword, text]}, {name='type', values=[], description='Decay function to use: linear, exponential or gaussian.', type=[keyword]}, {name='decay', values=[], description='Multiplier value returned at the scale distance from the origin.', type=[double]}",
          optional: true,
          description: '',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'value',
          type: 'date_nanos',
          optional: false,
          description: 'The input value to apply decay scoring to.',
        },
        {
          name: 'origin',
          type: 'date_nanos',
          optional: false,
          description: 'Central point from which the distances are calculated.',
        },
        {
          name: 'scale',
          type: 'time_duration',
          optional: false,
          description: 'Distance from the origin where the function returns the decay value.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='offset', values=[], description='Distance from the origin where no decay occurs.', type=[double, integer, long, time_duration, keyword, text]}, {name='type', values=[], description='Decay function to use: linear, exponential or gaussian.', type=[keyword]}, {name='decay', values=[], description='Multiplier value returned at the scale distance from the origin.', type=[double]}",
          optional: true,
          description: '',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'value',
          type: 'double',
          optional: false,
          description: 'The input value to apply decay scoring to.',
        },
        {
          name: 'origin',
          type: 'double',
          optional: false,
          description: 'Central point from which the distances are calculated.',
        },
        {
          name: 'scale',
          type: 'double',
          optional: false,
          description: 'Distance from the origin where the function returns the decay value.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='offset', values=[], description='Distance from the origin where no decay occurs.', type=[double, integer, long, time_duration, keyword, text]}, {name='type', values=[], description='Decay function to use: linear, exponential or gaussian.', type=[keyword]}, {name='decay', values=[], description='Multiplier value returned at the scale distance from the origin.', type=[double]}",
          optional: true,
          description: '',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'value',
          type: 'geo_point',
          optional: false,
          description: 'The input value to apply decay scoring to.',
        },
        {
          name: 'origin',
          type: 'geo_point',
          optional: false,
          description: 'Central point from which the distances are calculated.',
        },
        {
          name: 'scale',
          type: 'keyword',
          optional: false,
          description: 'Distance from the origin where the function returns the decay value.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='offset', values=[], description='Distance from the origin where no decay occurs.', type=[double, integer, long, time_duration, keyword, text]}, {name='type', values=[], description='Decay function to use: linear, exponential or gaussian.', type=[keyword]}, {name='decay', values=[], description='Multiplier value returned at the scale distance from the origin.', type=[double]}",
          optional: true,
          description: '',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'value',
          type: 'geo_point',
          optional: false,
          description: 'The input value to apply decay scoring to.',
        },
        {
          name: 'origin',
          type: 'geo_point',
          optional: false,
          description: 'Central point from which the distances are calculated.',
        },
        {
          name: 'scale',
          type: 'text',
          optional: false,
          description: 'Distance from the origin where the function returns the decay value.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='offset', values=[], description='Distance from the origin where no decay occurs.', type=[double, integer, long, time_duration, keyword, text]}, {name='type', values=[], description='Decay function to use: linear, exponential or gaussian.', type=[keyword]}, {name='decay', values=[], description='Multiplier value returned at the scale distance from the origin.', type=[double]}",
          optional: true,
          description: '',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'value',
          type: 'integer',
          optional: false,
          description: 'The input value to apply decay scoring to.',
        },
        {
          name: 'origin',
          type: 'integer',
          optional: false,
          description: 'Central point from which the distances are calculated.',
        },
        {
          name: 'scale',
          type: 'integer',
          optional: false,
          description: 'Distance from the origin where the function returns the decay value.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='offset', values=[], description='Distance from the origin where no decay occurs.', type=[double, integer, long, time_duration, keyword, text]}, {name='type', values=[], description='Decay function to use: linear, exponential or gaussian.', type=[keyword]}, {name='decay', values=[], description='Multiplier value returned at the scale distance from the origin.', type=[double]}",
          optional: true,
          description: '',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'value',
          type: 'long',
          optional: false,
          description: 'The input value to apply decay scoring to.',
        },
        {
          name: 'origin',
          type: 'long',
          optional: false,
          description: 'Central point from which the distances are calculated.',
        },
        {
          name: 'scale',
          type: 'long',
          optional: false,
          description: 'Distance from the origin where the function returns the decay value.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='offset', values=[], description='Distance from the origin where no decay occurs.', type=[double, integer, long, time_duration, keyword, text]}, {name='type', values=[], description='Decay function to use: linear, exponential or gaussian.', type=[keyword]}, {name='decay', values=[], description='Multiplier value returned at the scale distance from the origin.', type=[double]}",
          optional: true,
          description: '',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM employees\n| EVAL decay_result = decay(salary, 0, 100000, {"offset": 5, "decay": 0.5, "type": "linear"})\n| SORT decay_result DESC',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const eDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'e',
  description: i18n.translate('kbn-esql-language.esql.definitions.e', {
    defaultMessage: 'Returns Eulers number.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW E()'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const endsWithDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'ends_with',
  description: i18n.translate('kbn-esql-language.esql.definitions.ends_with', {
    defaultMessage:
      'Returns a boolean that indicates whether a keyword string ends with another string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'suffix',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'suffix',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'suffix',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'suffix',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['FROM employees\n| KEEP last_name\n| EVAL ln_E = ENDS_WITH(last_name, "d")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const expDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'exp',
  description: i18n.translate('kbn-esql-language.esql.definitions.exp', {
    defaultMessage: 'Returns the value of e raised to the power of the given number.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW d = 5.0\n| EVAL s = EXP(d)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const floorDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'floor',
  description: i18n.translate('kbn-esql-language.esql.definitions.floor', {
    defaultMessage: 'Round a number down to the nearest integer.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=1.8\n| EVAL a=FLOOR(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const fromBase64Definition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'from_base64',
  description: i18n.translate('kbn-esql-language.esql.definitions.from_base64', {
    defaultMessage: 'Decode a base64 string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'A base64 string.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'A base64 string.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a = "ZWxhc3RpYw=="\n| EVAL d = FROM_BASE64(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const greatestDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'greatest',
  description: i18n.translate('kbn-esql-language.esql.definitions.greatest', {
    defaultMessage:
      'Returns the maximum value from multiple columns. This is similar to `MV_MAX`\nexcept it is intended to run on multiple columns at once.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'boolean',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'date',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'date',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date_nanos',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'date_nanos',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'date_nanos',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'double',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'double',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'double',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'integer',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'ip',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'ip',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'ip',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'keyword',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'long',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'text',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'version',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'version',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'version',
      minParams: 1,
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a = 10, b = 20\n| EVAL g = GREATEST(a, b)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const hashDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'hash',
  description: i18n.translate('kbn-esql-language.esql.definitions.hash', {
    defaultMessage:
      'Computes the hash of the input using various algorithms such as MD5, SHA, SHA-224, SHA-256, SHA-384, SHA-512.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'algorithm',
          type: 'keyword',
          optional: false,
          description: 'Hash algorithm to use.',
        },
        {
          name: 'input',
          type: 'keyword',
          optional: false,
          description: 'Input to hash.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'algorithm',
          type: 'keyword',
          optional: false,
          description: 'Hash algorithm to use.',
        },
        {
          name: 'input',
          type: 'text',
          optional: false,
          description: 'Input to hash.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'algorithm',
          type: 'text',
          optional: false,
          description: 'Hash algorithm to use.',
        },
        {
          name: 'input',
          type: 'keyword',
          optional: false,
          description: 'Input to hash.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'algorithm',
          type: 'text',
          optional: false,
          description: 'Hash algorithm to use.',
        },
        {
          name: 'input',
          type: 'text',
          optional: false,
          description: 'Input to hash.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM sample_data\n| WHERE message != "Connection error"\n| EVAL md5 = hash("md5", message), sha256 = hash("sha256", message)\n| KEEP message, md5, sha256',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const hypotDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'hypot',
  description: i18n.translate('kbn-esql-language.esql.definitions.hypot', {
    defaultMessage:
      'Returns the hypotenuse of two numbers. The input can be any numeric values, the return value is always a double.\nHypotenuses of infinities are null.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number1',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
        {
          name: 'number2',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a = 3.0, b = 4.0\n| EVAL c = HYPOT(a, b)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const ipPrefixDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'ip_prefix',
  description: i18n.translate('kbn-esql-language.esql.definitions.ip_prefix', {
    defaultMessage: 'Truncates an IP to a given prefix length.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'ip',
          type: 'ip',
          optional: false,
          description: 'IP address of type `ip` (both IPv4 and IPv6 are supported).',
        },
        {
          name: 'prefixLengthV4',
          type: 'integer',
          optional: false,
          description: 'Prefix length for IPv4 addresses.',
        },
        {
          name: 'prefixLengthV6',
          type: 'integer',
          optional: false,
          description: 'Prefix length for IPv6 addresses.',
        },
      ],
      returnType: 'ip',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW ip4 = to_ip("1.2.3.4"), ip6 = TO_IP("fe80::cae2:65ff:fece:feb9")\n| EVAL ip4_prefix = IP_PREFIX(ip4, 24, 0), ip6_prefix = IP_PREFIX(ip6, 0, 112);',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const knnDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'knn',
  description: i18n.translate('kbn-esql-language.esql.definitions.knn', {
    defaultMessage:
      'Finds the k nearest vectors to a query vector, as measured by a similarity metric. knn function finds nearest vectors through approximate search on indexed dense_vectors or semantic_text fields.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'dense_vector',
          optional: false,
          description:
            'Field that the query will target. knn function can be used with dense_vector or semantic_text fields. Other text fields are not allowed',
        },
        {
          name: 'query',
          type: 'dense_vector',
          optional: false,
          description: 'Vector value to find top nearest neighbours for.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.Defaults to 1.0.', type=[float]}, {name='k', values=[10], description='The number of nearest neighbors to return from each shard. Elasticsearch collects k results from each shard, then merges them to find the global top results. This value must be less than or equal to num_candidates. This value is automatically set with any LIMIT applied to the function.', type=[integer]}, {name='visit_percentage', values=[10], description='The percentage of vectors to explore per shard while doing knn search with bbq_disk. Must be between 0 and 100. 0 will default to using num_candidates for calculating the percent visited. Increasing visit_percentage tends to improve the accuracy of the final results. If visit_percentage is set for bbq_disk, num_candidates is ignored. Defaults to ~1% per shard for every 1 million vectors', type=[float]}, {name='min_candidates', values=[10], description='The minimum number of nearest neighbor candidates to consider per shard while doing knn search.  KNN may use a higher number of candidates in case the query can't use a approximate results. Cannot exceed 10,000. Increasing min_candidates tends to improve the accuracy of the final results. Defaults to 1.5 * k (or LIMIT) used for the query.', type=[integer]}, {name='rescore_oversample', values=[3.5], description='Applies the specified oversampling for rescoring quantized vectors. See [oversampling and rescoring quantized vectors](docs-content://solutions/search/vector/knn.md#dense-vector-knn-search-rescoring) for details.', type=[double]}, {name='similarity', values=[0.01], description='The minimum similarity required for a document to be considered a match. The similarity value calculated relates to the raw similarity used, not the document score.', type=[double]}",
          optional: true,
          description:
            '(Optional) kNN additional options as <<esql-function-named-params,function named parameters>>. See [knn query](https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-knn-query) for more information.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Field that the query will target. knn function can be used with dense_vector or semantic_text fields. Other text fields are not allowed',
        },
        {
          name: 'query',
          type: 'dense_vector',
          optional: false,
          description: 'Vector value to find top nearest neighbours for.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.Defaults to 1.0.', type=[float]}, {name='k', values=[10], description='The number of nearest neighbors to return from each shard. Elasticsearch collects k results from each shard, then merges them to find the global top results. This value must be less than or equal to num_candidates. This value is automatically set with any LIMIT applied to the function.', type=[integer]}, {name='visit_percentage', values=[10], description='The percentage of vectors to explore per shard while doing knn search with bbq_disk. Must be between 0 and 100. 0 will default to using num_candidates for calculating the percent visited. Increasing visit_percentage tends to improve the accuracy of the final results. If visit_percentage is set for bbq_disk, num_candidates is ignored. Defaults to ~1% per shard for every 1 million vectors', type=[float]}, {name='min_candidates', values=[10], description='The minimum number of nearest neighbor candidates to consider per shard while doing knn search.  KNN may use a higher number of candidates in case the query can't use a approximate results. Cannot exceed 10,000. Increasing min_candidates tends to improve the accuracy of the final results. Defaults to 1.5 * k (or LIMIT) used for the query.', type=[integer]}, {name='rescore_oversample', values=[3.5], description='Applies the specified oversampling for rescoring quantized vectors. See [oversampling and rescoring quantized vectors](docs-content://solutions/search/vector/knn.md#dense-vector-knn-search-rescoring) for details.', type=[double]}, {name='similarity', values=[0.01], description='The minimum similarity required for a document to be considered a match. The similarity value calculated relates to the raw similarity used, not the document score.', type=[double]}",
          optional: true,
          description:
            '(Optional) kNN additional options as <<esql-function-named-params,function named parameters>>. See [knn query](https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-knn-query) for more information.',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'from colors metadata _score\n| where knn(rgb_vector, [0, 120, 0])\n| sort _score desc, color asc',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const kqlDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'kql',
  description: i18n.translate('kbn-esql-language.esql.definitions.kql', {
    defaultMessage:
      'Performs a KQL query. Returns true if the provided KQL query string matches the row.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Query string in KQL query string format.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Query string in KQL query string format.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='time_zone', values=[UTC, Europe/Paris, America/New_York], description='UTC offset or IANA time zone used to interpret date literals in the query string.', type=[keyword]}, {name='case_insensitive', values=[true, false], description='If true, performs case-insensitive matching for keyword fields. Defaults to false.', type=[boolean]}, {name='default_field', values=[*, logs.*, title], description='Default field to search if no field is provided in the query string. Supports wildcards (*).', type=[keyword]}",
          optional: true,
          description:
            '(Optional) KQL additional options as <<esql-function-named-params,function named parameters>>. Available in stack version 9.3.0 and later.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'query',
          type: 'text',
          optional: false,
          description: 'Query string in KQL query string format.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'query',
          type: 'text',
          optional: false,
          description: 'Query string in KQL query string format.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='time_zone', values=[UTC, Europe/Paris, America/New_York], description='UTC offset or IANA time zone used to interpret date literals in the query string.', type=[keyword]}, {name='case_insensitive', values=[true, false], description='If true, performs case-insensitive matching for keyword fields. Defaults to false.', type=[boolean]}, {name='default_field', values=[*, logs.*, title], description='Default field to search if no field is provided in the query string. Supports wildcards (*).', type=[keyword]}",
          optional: true,
          description:
            '(Optional) KQL additional options as <<esql-function-named-params,function named parameters>>. Available in stack version 9.3.0 and later.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [Location.WHERE, Location.STATS_WHERE, Location.JOIN, Location.EVAL],
  examples: [
    'FROM books\n| WHERE KQL("author: Faulkner")',
    'FROM employees\n| WHERE KQL("mary", {"case_insensitive": true, "default_field": "first_name", "boost": 1.5})',
  ],
  customParametersSnippet: '"""$0"""',
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const leastDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'least',
  description: i18n.translate('kbn-esql-language.esql.definitions.least', {
    defaultMessage:
      'Returns the minimum value from multiple columns. This is similar to `MV_MIN` except it is intended to run on multiple columns at once.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'boolean',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'date',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'date',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date_nanos',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'date_nanos',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'date_nanos',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'double',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'double',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'double',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'integer',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'ip',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'ip',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'ip',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'keyword',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'long',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'text',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'version',
          optional: false,
          description: 'First of the columns to evaluate.',
        },
        {
          name: 'rest',
          type: 'version',
          optional: true,
          description: 'The rest of the columns to evaluate.',
        },
      ],
      returnType: 'version',
      minParams: 1,
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a = 10, b = 20\n| EVAL l = LEAST(a, b)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const leftDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'left',
  description: i18n.translate('kbn-esql-language.esql.definitions.left', {
    defaultMessage:
      'Returns the substring that extracts *length* chars from *string* starting from the left.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'The string from which to return a substring.',
        },
        {
          name: 'length',
          type: 'integer',
          optional: false,
          description: 'The number of characters to return.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'The string from which to return a substring.',
        },
        {
          name: 'length',
          type: 'integer',
          optional: false,
          description: 'The number of characters to return.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['FROM employees\n| KEEP last_name\n| EVAL left = LEFT(last_name, 3)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const lengthDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'length',
  description: i18n.translate('kbn-esql-language.esql.definitions.length', {
    defaultMessage: 'Returns the character length of a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airports\n| WHERE country == "India"\n| KEEP city\n| EVAL fn_length = LENGTH(city)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const locateDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'locate',
  description: i18n.translate('kbn-esql-language.esql.definitions.locate', {
    defaultMessage:
      'Returns an integer that indicates the position of a keyword substring within another string.\nReturns `0` if the substring cannot be found.\nNote that string positions start from `1`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'An input string',
        },
        {
          name: 'substring',
          type: 'keyword',
          optional: false,
          description: 'A substring to locate in the input string',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'An input string',
        },
        {
          name: 'substring',
          type: 'keyword',
          optional: false,
          description: 'A substring to locate in the input string',
        },
        {
          name: 'start',
          type: 'integer',
          optional: true,
          description: 'The start index',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'An input string',
        },
        {
          name: 'substring',
          type: 'text',
          optional: false,
          description: 'A substring to locate in the input string',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'An input string',
        },
        {
          name: 'substring',
          type: 'text',
          optional: false,
          description: 'A substring to locate in the input string',
        },
        {
          name: 'start',
          type: 'integer',
          optional: true,
          description: 'The start index',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'An input string',
        },
        {
          name: 'substring',
          type: 'keyword',
          optional: false,
          description: 'A substring to locate in the input string',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'An input string',
        },
        {
          name: 'substring',
          type: 'keyword',
          optional: false,
          description: 'A substring to locate in the input string',
        },
        {
          name: 'start',
          type: 'integer',
          optional: true,
          description: 'The start index',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'An input string',
        },
        {
          name: 'substring',
          type: 'text',
          optional: false,
          description: 'A substring to locate in the input string',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'An input string',
        },
        {
          name: 'substring',
          type: 'text',
          optional: false,
          description: 'A substring to locate in the input string',
        },
        {
          name: 'start',
          type: 'integer',
          optional: true,
          description: 'The start index',
        },
      ],
      returnType: 'integer',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a = "hello"\n| EVAL a_ll = LOCATE(a, "ll")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const logDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'log',
  description: i18n.translate('kbn-esql-language.esql.definitions.log', {
    defaultMessage:
      'Returns the logarithm of a value to a base. The input can be any numeric value, the return value is always a double.\n\nLogs of zero, negative numbers, and base of one return `null` as well as a warning.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
          description:
            'Base of logarithm. If `null`, the function returns `null`. If not provided, this function returns the natural logarithm (base e) of a value.',
        },
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW base = 2.0, value = 8.0\n| EVAL s = LOG(base, value)',
    'ROW value = 100\n| EVAL s = LOG(value);',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const log10Definition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'log10',
  description: i18n.translate('kbn-esql-language.esql.definitions.log10', {
    defaultMessage:
      'Returns the logarithm of a value to base 10. The input can be any numeric value, the return value is always a double.\n\nLogs of 0 and negative numbers return `null` as well as a warning.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW d = 1000.0\n| EVAL s = LOG10(d)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const ltrimDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'ltrim',
  description: i18n.translate('kbn-esql-language.esql.definitions.ltrim', {
    defaultMessage: 'Removes leading whitespaces from a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW message = "   some text  ",  color = " red "\n| EVAL message = LTRIM(message)\n| EVAL color = LTRIM(color)\n| EVAL message = CONCAT("\'", message, "\'")\n| EVAL color = CONCAT("\'", color, "\'")',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const matchDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'match',
  description: i18n.translate('kbn-esql-language.esql.definitions.match', {
    defaultMessage:
      'Use `MATCH` to perform a match query on the specified field.\nUsing `MATCH` is equivalent to using the `match` query in the Elasticsearch Query DSL.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'boolean',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'date',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'date_nanos',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'double',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'integer',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'long',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'double',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'integer',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'long',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'ip',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'double',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'integer',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'long',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'double',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'integer',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'long',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'unsigned_long',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'version',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Match additional options as <<esql-function-named-params,function named parameters>>.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [Location.WHERE, Location.STATS_WHERE, Location.JOIN, Location.EVAL],
  examples: [
    'FROM books\n| WHERE MATCH(author, "Faulkner")',
    'FROM books\n| WHERE MATCH(title, "Hobbit Back Again", {"operator": "AND"})\n| KEEP title;',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const matchPhraseDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'match_phrase',
  description: i18n.translate('kbn-esql-language.esql.definitions.match_phrase', {
    defaultMessage:
      'Use `MATCH_PHRASE` to perform a `match_phrase` on the\nspecified field.\nUsing `MATCH_PHRASE` is equivalent to using the `match_phrase` query in the Elasticsearch Query DSL.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='slop', values=[1], description='Maximum number of positions allowed between matching tokens. Defaults to 0. Transposed terms have a slop of 2.', type=[integer]}",
          optional: true,
          description:
            '(Optional) MatchPhrase additional options as <<esql-function-named-params,function named parameters>>. See [`match_phrase`](https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-match-query-phrase) for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Field that the query will target.',
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided field.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='zero_terms_query', values=[none, all], description='Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0.', type=[float]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='slop', values=[1], description='Maximum number of positions allowed between matching tokens. Defaults to 0. Transposed terms have a slop of 2.', type=[integer]}",
          optional: true,
          description:
            '(Optional) MatchPhrase additional options as <<esql-function-named-params,function named parameters>>. See [`match_phrase`](https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-match-query-phrase) for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [Location.WHERE, Location.STATS_WHERE, Location.JOIN, Location.EVAL],
  examples: ['FROM books\n| WHERE MATCH_PHRASE(author, "William Faulkner")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const md5Definition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'md5',
  description: i18n.translate('kbn-esql-language.esql.definitions.md5', {
    defaultMessage: 'Computes the MD5 hash of the input (if the MD5 hash is available on the JVM).',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'input',
          type: 'keyword',
          optional: false,
          description: 'Input to hash.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'input',
          type: 'text',
          optional: false,
          description: 'Input to hash.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM sample_data\n| WHERE message != "Connection error"\n| EVAL md5 = md5(message)\n| KEEP message, md5',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const monthNameDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'month_name',
  description: i18n.translate('kbn-esql-language.esql.definitions.month_name', {
    defaultMessage: 'Returns the month name for the provided date based on the configured Locale.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'date',
          type: 'date',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
          description: 'Date expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW dt = to_datetime("1996-03-21T00:00:00.000Z")\n| EVAL monthName = MONTH_NAME(dt);',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const multiMatchDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'multi_match',
  description: i18n.translate('kbn-esql-language.esql.definitions.multi_match', {
    defaultMessage:
      'Use `MULTI_MATCH` to perform a multi-match query on the specified field.\nThe multi_match query builds on the match query to allow multi-field queries.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'query',
          type: 'boolean',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'boolean',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'boolean',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'date',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'date',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'date',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'date_nanos',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'date_nanos',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'date_nanos',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'double',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'double',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'double',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'integer',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'double',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'double',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'long',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'integer',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'double',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'integer',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'integer',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'integer',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'integer',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'long',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'ip',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'ip',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'ip',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'long',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'double',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'long',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'integer',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'long',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'long',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'long',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'text',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'unsigned_long',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'double',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'unsigned_long',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'integer',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'unsigned_long',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'unsigned_long',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'long',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'unsigned_long',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'unsigned_long',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'version',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'keyword',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'query',
          type: 'version',
          optional: false,
          description: 'Value to find in the provided fields.',
          constantOnly: true,
        },
        {
          name: 'fields',
          type: 'version',
          optional: false,
          description: 'Fields to use for matching',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.', type=[integer]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='tie_breaker', values=[0], description='Controls how score is blended together between field groups. Defaults to 0 (best score from each group).', type=[float]}, {name='type', values=['best_fields'], description='Controls the way multi_match is executed internally. Can be one of `best_fields`, `most_fields`, `cross_fields`, `phrase`, `phrase_prefix` or `bool_prefix`. Defaults to 'best_fields'. See <<multi-match-types,multi_match types>>.', type=[object]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to true.', type=[boolean]}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value. Defaults to OR.', type=[keyword]}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand. Defaults to 50.', type=[integer]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the indexs default analyzer is used.', type=[keyword]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default.', type=[keyword]}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}",
          optional: true,
          description:
            '(Optional) Additional options for MultiMatch, passed as <<esql-function-named-params,function named parameters>>."  See <<query-dsl-multi-match-query,multi-match query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
  ],
  locationsAvailable: [Location.WHERE, Location.STATS_WHERE, Location.JOIN, Location.EVAL],
  examples: [
    'FROM books\n| WHERE MULTI_MATCH("Faulkner", author, description)\n| KEEP book_no, author\n| SORT book_no\n| LIMIT 5',
    'FROM books\n| WHERE MULTI_MATCH("Hobbit Back Again", title, description, {"operator": "AND"})\n| KEEP title;',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvAppendDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_append',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_append', {
    defaultMessage: 'Concatenates values of two multi-value fields.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field1',
          type: 'boolean',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'boolean',
          optional: false,
          description: '',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'cartesian_point',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'cartesian_point',
          optional: false,
          description: '',
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'cartesian_shape',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'cartesian_shape',
          optional: false,
          description: '',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'date',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'date',
          optional: false,
          description: '',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'date_nanos',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'date_nanos',
          optional: false,
          description: '',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'double',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'double',
          optional: false,
          description: '',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geo_point',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'geo_point',
          optional: false,
          description: '',
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geo_shape',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'geo_shape',
          optional: false,
          description: '',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geohash',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'geohash',
          optional: false,
          description: '',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geohex',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'geohex',
          optional: false,
          description: '',
        },
      ],
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geotile',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'geotile',
          optional: false,
          description: '',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'integer',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'integer',
          optional: false,
          description: '',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'ip',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'ip',
          optional: false,
          description: '',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'keyword',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'keyword',
          optional: false,
          description: '',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'keyword',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'text',
          optional: false,
          description: '',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'long',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'long',
          optional: false,
          description: '',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'text',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'keyword',
          optional: false,
          description: '',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'text',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'text',
          optional: false,
          description: '',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'unsigned_long',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'unsigned_long',
          optional: false,
          description: '',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'version',
          optional: false,
          description: '',
        },
        {
          name: 'field2',
          type: 'version',
          optional: false,
          description: '',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM employees\n| WHERE emp_no == 10039 OR emp_no == 10040\n| SORT emp_no\n| EVAL dates = MV_APPEND(birth_date, hire_date)\n| KEEP emp_no, birth_date, hire_date, dates',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvAvgDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_avg',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_avg', {
    defaultMessage:
      'Converts a multivalued field into a single valued field containing the average of all of the values.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=[3, 5, 1, 6]\n| EVAL avg_a = MV_AVG(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvConcatDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_concat',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_concat', {
    defaultMessage:
      'Converts a multivalued string expression into a single valued column containing the concatenation of all values separated by a delimiter.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: false,
          description: 'Delimiter.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'text',
          optional: false,
          description: 'Delimiter.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: false,
          description: 'Delimiter.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'text',
          optional: false,
          description: 'Delimiter.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW a=["foo", "zoo", "bar"]\n| EVAL j = MV_CONCAT(a, ", ")',
    'ROW a=[10, 9, 8]\n| EVAL j = MV_CONCAT(TO_STRING(a), ", ")',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvContainsDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_contains',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_contains', {
    defaultMessage:
      'Checks if all values yielded by the second multivalue expression are present in the values yielded by the first multivalue expression. Returns a boolean. Null values are treated as an empty set.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'superset',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'date',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'date',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'superset',
          type: 'version',
          optional: false,
          description: 'Multivalue expression.',
          supportsMultiValues: true,
        },
        {
          name: 'subset',
          type: 'version',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW set = ["a", "b", "c"], element = "a"\n| EVAL set_contains_element = mv_contains(set, element)',
    'ROW setA = ["a","c"], setB = ["a", "b", "c"]\n| EVAL a_subset_of_b = mv_contains(setB, setA)\n| EVAL b_subset_of_a = mv_contains(setA, setB)',
    'FROM airports\n| WHERE mv_contains(type, ["major","military"]) AND scalerank == 9\n| KEEP scalerank, name, country',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvCountDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_count',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_count', {
    defaultMessage:
      'Converts a multivalued expression into a single valued column containing a count of the number of values.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=["foo", "zoo", "bar"]\n| EVAL count_a = MV_COUNT(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvDedupeDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_dedupe',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_dedupe', {
    defaultMessage: 'Remove duplicate values from a multivalued field.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=["foo", "foo", "bar", "foo"]\n| EVAL dedupe_a = MV_DEDUPE(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvFirstDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_first',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_first', {
    defaultMessage:
      'Converts a multivalued expression into a single valued column containing the\nfirst value. This is most useful when reading from a function that emits\nmultivalued columns in a known order like `SPLIT`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a="foo;bar;baz"\n| EVAL first_a = MV_FIRST(SPLIT(a, ";"))'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvIntersectionDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_intersection',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_intersection', {
    defaultMessage:
      'Returns the values that appear in both input fields. Returns `null` if either field is null or if no values match.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field1',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'date',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'date',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'double',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'double',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'text',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'long',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'long',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'text',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'text',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'text',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'version',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
        {
          name: 'field2',
          type: 'version',
          optional: false,
          description: 'Multivalue expression. If null, the function returns null.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW a = [1, 2, 3, 4, 5], b = [2, 3, 4, 5, 6]\n| EVAL finalValue = MV_INTERSECTION(a, b)\n| KEEP finalValue',
    'ROW a = [1, 2, 3, 4, 5]::long, b = [2, 3, 4, 5, 6]::long\n| EVAL finalValue = MV_INTERSECTION(a, b)\n| KEEP finalValue',
    'ROW a = [true, false, false, false], b = [false]\n| EVAL finalValue = MV_INTERSECTION(a, b)\n| KEEP finalValue',
    'ROW a = [5.2, 10.5, 1.12345, 2.6928], b = [10.5, 2.6928]\n| EVAL finalValue = MV_INTERSECTION(a, b)\n| KEEP finalValue',
    'ROW a = ["one", "two", "three", "four", "five"], b = ["one", "four"]\n| EVAL finalValue = MV_INTERSECTION(a, b)\n| KEEP finalValue',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvLastDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_last',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_last', {
    defaultMessage:
      'Converts a multivalue expression into a single valued column containing the last\nvalue. This is most useful when reading from a function that emits multivalued\ncolumns in a known order like `SPLIT`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a="foo;bar;baz"\n| EVAL last_a = MV_LAST(SPLIT(a, ";"))'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvMaxDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_max',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_max', {
    defaultMessage:
      'Converts a multivalued expression into a single valued column containing the maximum value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW a=[3, 5, 1]\n| EVAL max_a = MV_MAX(a)',
    'ROW a=["foo", "zoo", "bar"]\n| EVAL max_a = MV_MAX(a)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvMedianDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_median',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_median', {
    defaultMessage:
      'Converts a multivalued field into a single valued field containing the median value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW a=[3, 5, 1]\n| EVAL median_a = MV_MEDIAN(a)',
    'ROW a=[3, 7, 1, 6]\n| EVAL median_a = MV_MEDIAN(a)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvMedianAbsoluteDeviationDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_median_absolute_deviation',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_median_absolute_deviation', {
    defaultMessage:
      'Converts a multivalued field into a single valued field containing the median absolute deviation.\n\nIt is calculated as the median of each data points deviation from the median of the entire sample. That is, for a random variable `X`, the median absolute deviation is `median(|median(X) - X|)`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW values = [0, 2, 5, 6]\n| EVAL median_absolute_deviation = MV_MEDIAN_ABSOLUTE_DEVIATION(values), median = MV_MEDIAN(values)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvMinDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_min',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_min', {
    defaultMessage:
      'Converts a multivalued expression into a single valued column containing the minimum value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW a=[2, 1]\n| EVAL min_a = MV_MIN(a)',
    'ROW a=["foo", "bar"]\n| EVAL min_a = MV_MIN(a)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvPercentileDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_percentile',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_percentile', {
    defaultMessage:
      'Converts a multivalued field into a single valued field containing the value at which a certain percentage of observed values occur.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'percentile',
          type: 'double',
          optional: false,
          description:
            'The percentile to calculate. Must be a number between 0 and 100. Numbers out of range will return a null instead.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'percentile',
          type: 'integer',
          optional: false,
          description:
            'The percentile to calculate. Must be a number between 0 and 100. Numbers out of range will return a null instead.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'percentile',
          type: 'long',
          optional: false,
          description:
            'The percentile to calculate. Must be a number between 0 and 100. Numbers out of range will return a null instead.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'percentile',
          type: 'double',
          optional: false,
          description:
            'The percentile to calculate. Must be a number between 0 and 100. Numbers out of range will return a null instead.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'percentile',
          type: 'integer',
          optional: false,
          description:
            'The percentile to calculate. Must be a number between 0 and 100. Numbers out of range will return a null instead.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'percentile',
          type: 'long',
          optional: false,
          description:
            'The percentile to calculate. Must be a number between 0 and 100. Numbers out of range will return a null instead.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'percentile',
          type: 'double',
          optional: false,
          description:
            'The percentile to calculate. Must be a number between 0 and 100. Numbers out of range will return a null instead.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'percentile',
          type: 'integer',
          optional: false,
          description:
            'The percentile to calculate. Must be a number between 0 and 100. Numbers out of range will return a null instead.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'percentile',
          type: 'long',
          optional: false,
          description:
            'The percentile to calculate. Must be a number between 0 and 100. Numbers out of range will return a null instead.',
        },
      ],
      returnType: 'long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW values = [5, 5, 10, 12, 5000]\n| EVAL p50 = MV_PERCENTILE(values, 50), median = MV_MEDIAN(values)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvPseriesWeightedSumDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_pseries_weighted_sum',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_pseries_weighted_sum', {
    defaultMessage:
      'Converts a multivalued expression into a single-valued column by multiplying every element on the input list by its corresponding term in P-Series and computing the sum.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'p',
          type: 'double',
          optional: false,
          description:
            'It is a constant number that represents the *p* parameter in the P-Series. It impacts every elements contribution to the weighted sum.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW a = [70.0, 45.0, 21.0, 21.0, 21.0]\n| EVAL sum = MV_PSERIES_WEIGHTED_SUM(a, 1.5)\n| KEEP sum',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvSliceDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_slice',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_slice', {
    defaultMessage:
      'Returns a subset of the multivalued field using the start and end index values.\nThis is most useful when reading from a function that emits multivalued columns\nin a known order like `SPLIT` or `MV_SORT`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description:
            'Start position. If `null`, the function returns `null`. The start argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
          description:
            'End position(included). Optional; if omitted, the position at `start` is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'row a = [1, 2, 2, 3]\n| eval a1 = mv_slice(a, 1), a2 = mv_slice(a, 2, 3)',
    'row a = [1, 2, 2, 3]\n| eval a1 = mv_slice(a, -2), a2 = mv_slice(a, -3, -1)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvSortDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_sort',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_sort', {
    defaultMessage: 'Sorts a multivalued field in lexicographical order.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          description: 'Sort order. The valid options are ASC and DESC, the default is ASC.',
          constantOnly: true,
          suggestedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          description: 'Sort order. The valid options are ASC and DESC, the default is ASC.',
          constantOnly: true,
          suggestedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          description: 'Sort order. The valid options are ASC and DESC, the default is ASC.',
          constantOnly: true,
          suggestedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          description: 'Sort order. The valid options are ASC and DESC, the default is ASC.',
          constantOnly: true,
          suggestedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          description: 'Sort order. The valid options are ASC and DESC, the default is ASC.',
          constantOnly: true,
          suggestedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          description: 'Sort order. The valid options are ASC and DESC, the default is ASC.',
          constantOnly: true,
          suggestedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          description: 'Sort order. The valid options are ASC and DESC, the default is ASC.',
          constantOnly: true,
          suggestedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          description: 'Sort order. The valid options are ASC and DESC, the default is ASC.',
          constantOnly: true,
          suggestedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          description: 'Sort order. The valid options are ASC and DESC, the default is ASC.',
          constantOnly: true,
          suggestedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description: 'Multivalue expression. If `null`, the function returns `null`.',
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          description: 'Sort order. The valid options are ASC and DESC, the default is ASC.',
          constantOnly: true,
          suggestedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a = [4, 2, -3, 2]\n| EVAL sa = mv_sort(a), sd = mv_sort(a, "DESC")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvSumDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_sum',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_sum', {
    defaultMessage:
      'Converts a multivalued field into a single valued field containing the sum of all of the values.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=[3, 5, 6]\n| EVAL sum_a = MV_SUM(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvUnionDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_union',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_union', {
    defaultMessage:
      'Returns all unique values from the combined input fields (set union). Null values are treated as empty sets; returns `null` only if both fields are null.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field1',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'boolean',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'cartesian_point',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'cartesian_shape',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'date',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'date',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'date_nanos',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'double',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'double',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'geo_point',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'geo_shape',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'geohash',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'geohex',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'geotile',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'integer',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'ip',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'text',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'long',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'long',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'text',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'text',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'text',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'unsigned_long',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'version',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
        {
          name: 'field2',
          type: 'version',
          optional: false,
          description: 'Multivalue expression. Null values are treated as empty sets.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW a = [1, 2, 3, 4, 5], b = [2, 3, 4, 5, 6]\n| EVAL finalValue = MV_UNION(a, b)\n| KEEP finalValue',
    'ROW a = [1, 2, 3, 4, 5]::long, b = [2, 3, 4, 5, 6]::long\n| EVAL finalValue = MV_UNION(a, b)\n| KEEP finalValue',
    'ROW a = [true, false], b = [false]\n| EVAL finalValue = MV_UNION(a, b)\n| KEEP finalValue',
    'ROW a = [5.2, 10.5, 1.12345], b = [10.5, 2.6928]\n| EVAL finalValue = MV_UNION(a, b)\n| KEEP finalValue',
    'ROW a = ["one", "two", "three"], b = ["two", "four"]\n| EVAL finalValue = MV_UNION(a, b)\n| KEEP finalValue',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvZipDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'mv_zip',
  description: i18n.translate('kbn-esql-language.esql.definitions.mv_zip', {
    defaultMessage:
      'Combines the values from two multivalued fields with a delimiter that joins them together.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: true,
          description: 'Delimiter. Optional; if omitted, `,` is used as a default delimiter.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'text',
          optional: true,
          description: 'Delimiter. Optional; if omitted, `,` is used as a default delimiter.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: true,
          description: 'Delimiter. Optional; if omitted, `,` is used as a default delimiter.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'text',
          optional: true,
          description: 'Delimiter. Optional; if omitted, `,` is used as a default delimiter.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: true,
          description: 'Delimiter. Optional; if omitted, `,` is used as a default delimiter.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'text',
          optional: true,
          description: 'Delimiter. Optional; if omitted, `,` is used as a default delimiter.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: true,
          description: 'Delimiter. Optional; if omitted, `,` is used as a default delimiter.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
          description: 'Multivalue expression.',
        },
        {
          name: 'delim',
          type: 'text',
          optional: true,
          description: 'Delimiter. Optional; if omitted, `,` is used as a default delimiter.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW a = ["x", "y", "z"], b = ["1", "2"]\n| EVAL c = mv_zip(a, b, "-")\n| KEEP a, b, c',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const networkDirectionDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'network_direction',
  description: i18n.translate('kbn-esql-language.esql.definitions.network_direction', {
    defaultMessage:
      'Returns the direction type (inbound, outbound, internal, external) given a source IP address, destination IP address, and a list of internal networks.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'source_ip',
          type: 'ip',
          optional: false,
          description: 'Source IP address of type `ip` (both IPv4 and IPv6 are supported).',
        },
        {
          name: 'destination_ip',
          type: 'ip',
          optional: false,
          description: 'Destination IP address of type `ip` (both IPv4 and IPv6 are supported).',
        },
        {
          name: 'internal_networks',
          type: 'keyword',
          optional: false,
          description:
            'List of internal networks. Supports IPv4 and IPv6 addresses, ranges in CIDR notation, and named ranges.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'source_ip',
          type: 'ip',
          optional: false,
          description: 'Source IP address of type `ip` (both IPv4 and IPv6 are supported).',
        },
        {
          name: 'destination_ip',
          type: 'ip',
          optional: false,
          description: 'Destination IP address of type `ip` (both IPv4 and IPv6 are supported).',
        },
        {
          name: 'internal_networks',
          type: 'text',
          optional: false,
          description:
            'List of internal networks. Supports IPv4 and IPv6 addresses, ranges in CIDR notation, and named ranges.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW ip0 = "127.0.0.1"::ip, ip1 = "5.6.7.8"::ip\n| EVAL direction = NETWORK_DIRECTION(ip0, ip1, ["loopback", "private"])',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const nowDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'now',
  description: i18n.translate('kbn-esql-language.esql.definitions.now', {
    defaultMessage: 'Returns current date and time.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [],
      returnType: 'date',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW current_date = NOW()', 'FROM sample_data\n| WHERE @timestamp > NOW() - 1 hour'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const piDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'pi',
  description: i18n.translate('kbn-esql-language.esql.definitions.pi', {
    defaultMessage: 'Returns Pi, the ratio of a circles circumference to its diameter.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW PI()'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const powDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'pow',
  description: i18n.translate('kbn-esql-language.esql.definitions.pow', {
    defaultMessage: 'Returns the value of `base` raised to the power of `exponent`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'double',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'integer',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'long',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'unsigned_long',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'double',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'integer',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'long',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'unsigned_long',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'double',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'integer',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'long',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'unsigned_long',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'double',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'integer',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'long',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression for the base. If `null`, the function returns `null`.',
        },
        {
          name: 'exponent',
          type: 'unsigned_long',
          optional: false,
          description:
            'Numeric expression for the exponent. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW base = 2.0, exponent = 2\n| EVAL result = POW(base, exponent)',
    'ROW base = 4, exponent = 0.5\n| EVAL s = POW(base, exponent)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const qstrDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'qstr',
  description: i18n.translate('kbn-esql-language.esql.definitions.qstr', {
    defaultMessage:
      'Performs a query string query. Returns true if the provided query string matches the row.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description: 'Query string in Lucene query string format.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='max_determinized_states', values=[10000], description='Maximum number of automaton states required for the query. Default is 10000.', type=[integer]}, {name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='phrase_slop', values=[0], description='Maximum number of positions allowed between matching tokens for phrases. Defaults to 0 (which means exact matches are required).', type=[integer]}, {name='default_field', values=[standard], description='Default field to search if no field is provided in the query string. Supports wildcards (*).', type=[keyword]}, {name='allow_leading_wildcard', values=[true, false], description='If true, the wildcard characters * and ? are allowed as the first character of the query string. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[standard], description='Minimum number of clauses that must match for a document to be returned.', type=[string]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_prefix_length', values=[0], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.', type=[keyword]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='rewrite', values=[standard], description='Method used to rewrite the query.', type=[keyword]}, {name='default_operator', values=[OR, AND], description='Default boolean logic used to interpret text in the query string if no operators are specified.', type=[keyword]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the default_field.', type=[keyword]}, {name='fuzzy_max_expansions', values=[50], description='Maximum number of terms to which the query expands for fuzzy matching. Defaults to 50.', type=[integer]}, {name='quote_analyzer', values=[standard], description='Analyzer used to convert quoted text in the query string into tokens. Defaults to the search_quote_analyzer mapped for the default_field.', type=[keyword]}, {name='allow_wildcard', values=[false, true], description='If true, the query attempts to analyze wildcard terms in the query string. Defaults to false.', type=[boolean]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='quote_field_suffix', values=[standard], description='Suffix appended to quoted text in the query string.', type=[keyword]}, {name='enable_position_increments', values=[true, false], description='If true, enable position increments in queries constructed from a query_string search. Defaults to true.', type=[boolean]}, {name='fields', values=[standard], description='Array of fields to search. Supports wildcards (*).', type=[keyword]}",
          optional: true,
          description:
            '(Optional) Additional options for Query String as <<esql-function-named-params,function named parameters>>. See <<query-dsl-query-string-query,query string query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'query',
          type: 'text',
          optional: false,
          description: 'Query string in Lucene query string format.',
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='max_determinized_states', values=[10000], description='Maximum number of automaton states required for the query. Default is 10000.', type=[integer]}, {name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.', type=[keyword]}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true.', type=[boolean]}, {name='phrase_slop', values=[0], description='Maximum number of positions allowed between matching tokens for phrases. Defaults to 0 (which means exact matches are required).', type=[integer]}, {name='default_field', values=[standard], description='Default field to search if no field is provided in the query string. Supports wildcards (*).', type=[keyword]}, {name='allow_leading_wildcard', values=[true, false], description='If true, the wildcard characters * and ? are allowed as the first character of the query string. Defaults to true.', type=[boolean]}, {name='minimum_should_match', values=[standard], description='Minimum number of clauses that must match for a document to be returned.', type=[string]}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba). Defaults to true.', type=[boolean]}, {name='fuzzy_prefix_length', values=[0], description='Number of beginning characters left unchanged for fuzzy matching. Defaults to 0.', type=[integer]}, {name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.', type=[keyword]}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false.', type=[boolean]}, {name='rewrite', values=[standard], description='Method used to rewrite the query.', type=[keyword]}, {name='default_operator', values=[OR, AND], description='Default boolean logic used to interpret text in the query string if no operators are specified.', type=[keyword]}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the default_field.', type=[keyword]}, {name='fuzzy_max_expansions', values=[50], description='Maximum number of terms to which the query expands for fuzzy matching. Defaults to 50.', type=[integer]}, {name='quote_analyzer', values=[standard], description='Analyzer used to convert quoted text in the query string into tokens. Defaults to the search_quote_analyzer mapped for the default_field.', type=[keyword]}, {name='allow_wildcard', values=[false, true], description='If true, the query attempts to analyze wildcard terms in the query string. Defaults to false.', type=[boolean]}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.', type=[float]}, {name='quote_field_suffix', values=[standard], description='Suffix appended to quoted text in the query string.', type=[keyword]}, {name='enable_position_increments', values=[true, false], description='If true, enable position increments in queries constructed from a query_string search. Defaults to true.', type=[boolean]}, {name='fields', values=[standard], description='Array of fields to search. Supports wildcards (*).', type=[keyword]}",
          optional: true,
          description:
            '(Optional) Additional options for Query String as <<esql-function-named-params,function named parameters>>. See <<query-dsl-query-string-query,query string query>> for more information.',
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [Location.WHERE, Location.STATS_WHERE, Location.JOIN, Location.EVAL],
  examples: [
    'FROM books\n| WHERE QSTR("author: Faulkner")',
    'FROM books\n| WHERE QSTR("title: Hobbjt~", {"fuzziness": 2})',
  ],
  customParametersSnippet: '"""$0"""',
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const repeatDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'repeat',
  description: i18n.translate('kbn-esql-language.esql.definitions.repeat', {
    defaultMessage:
      'Returns a string constructed by concatenating `string` with itself the specified `number` of times.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression.',
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Number times to repeat.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression.',
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Number times to repeat.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a = "Hello!"\n| EVAL triple_a = REPEAT(a, 3)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const replaceDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'replace',
  description: i18n.translate('kbn-esql-language.esql.definitions.replace', {
    defaultMessage:
      'The function substitutes in the string `str` any match of the regular expression `regex`\nwith the replacement string `newStr`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression.',
        },
        {
          name: 'regex',
          type: 'keyword',
          optional: false,
          description: 'Regular expression.',
        },
        {
          name: 'newString',
          type: 'keyword',
          optional: false,
          description: 'Replacement string.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression.',
        },
        {
          name: 'regex',
          type: 'keyword',
          optional: false,
          description: 'Regular expression.',
        },
        {
          name: 'newString',
          type: 'text',
          optional: false,
          description: 'Replacement string.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression.',
        },
        {
          name: 'regex',
          type: 'text',
          optional: false,
          description: 'Regular expression.',
        },
        {
          name: 'newString',
          type: 'keyword',
          optional: false,
          description: 'Replacement string.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression.',
        },
        {
          name: 'regex',
          type: 'text',
          optional: false,
          description: 'Regular expression.',
        },
        {
          name: 'newString',
          type: 'text',
          optional: false,
          description: 'Replacement string.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression.',
        },
        {
          name: 'regex',
          type: 'keyword',
          optional: false,
          description: 'Regular expression.',
        },
        {
          name: 'newString',
          type: 'keyword',
          optional: false,
          description: 'Replacement string.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression.',
        },
        {
          name: 'regex',
          type: 'keyword',
          optional: false,
          description: 'Regular expression.',
        },
        {
          name: 'newString',
          type: 'text',
          optional: false,
          description: 'Replacement string.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression.',
        },
        {
          name: 'regex',
          type: 'text',
          optional: false,
          description: 'Regular expression.',
        },
        {
          name: 'newString',
          type: 'keyword',
          optional: false,
          description: 'Replacement string.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression.',
        },
        {
          name: 'regex',
          type: 'text',
          optional: false,
          description: 'Regular expression.',
        },
        {
          name: 'newString',
          type: 'text',
          optional: false,
          description: 'Replacement string.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW str = "Hello World"\n| EVAL str = REPLACE(str, "World", "Universe")',
    'ROW str = "Hello World"\n| EVAL str = REPLACE(str, "\\\\\\\\s+", "")',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const reverseDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'reverse',
  description: i18n.translate('kbn-esql-language.esql.definitions.reverse', {
    defaultMessage: 'Returns a new string representing the input string in reverse order.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW message = "Some Text" | EVAL message_reversed = REVERSE(message);',
    'ROW bending_arts = "" | EVAL bending_arts_reversed = REVERSE(bending_arts);',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const rightDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'right',
  description: i18n.translate('kbn-esql-language.esql.definitions.right', {
    defaultMessage:
      'Return the substring that extracts *length* chars from *str* starting from the right.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'The string from which to returns a substring.',
        },
        {
          name: 'length',
          type: 'integer',
          optional: false,
          description: 'The number of characters to return.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'The string from which to returns a substring.',
        },
        {
          name: 'length',
          type: 'integer',
          optional: false,
          description: 'The number of characters to return.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['FROM employees\n| KEEP last_name\n| EVAL right = RIGHT(last_name, 3)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const roundDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'round',
  description: i18n.translate('kbn-esql-language.esql.definitions.round', {
    defaultMessage:
      'Rounds a number to the specified number of decimal places.\nDefaults to 0, which returns the nearest integer. If the\nprecision is a negative number, rounds to the number of digits left\nof the decimal point.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'decimals',
          type: 'integer',
          optional: true,
          description:
            'The number of decimal places to round to. Defaults to 0. If `null`, the function returns `null`.',
          constantOnly: true,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'decimals',
          type: 'long',
          optional: true,
          description:
            'The number of decimal places to round to. Defaults to 0. If `null`, the function returns `null`.',
          constantOnly: true,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'decimals',
          type: 'integer',
          optional: true,
          description:
            'The number of decimal places to round to. Defaults to 0. If `null`, the function returns `null`.',
          constantOnly: true,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'decimals',
          type: 'long',
          optional: true,
          description:
            'The number of decimal places to round to. Defaults to 0. If `null`, the function returns `null`.',
          constantOnly: true,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'decimals',
          type: 'integer',
          optional: true,
          description:
            'The number of decimal places to round to. Defaults to 0. If `null`, the function returns `null`.',
          constantOnly: true,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'decimals',
          type: 'long',
          optional: true,
          description:
            'The number of decimal places to round to. Defaults to 0. If `null`, the function returns `null`.',
          constantOnly: true,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'decimals',
          type: 'integer',
          optional: true,
          description:
            'The number of decimal places to round to. Defaults to 0. If `null`, the function returns `null`.',
          constantOnly: true,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'decimals',
          type: 'long',
          optional: true,
          description:
            'The number of decimal places to round to. Defaults to 0. If `null`, the function returns `null`.',
          constantOnly: true,
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM employees\n| KEEP first_name, last_name, height\n| EVAL height_ft = ROUND(height * 3.281, 1)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const roundToDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'round_to',
  description: i18n.translate('kbn-esql-language.esql.definitions.round_to', {
    defaultMessage: 'Rounds down to one of a list of fixed points.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'date',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'date',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'date_nanos',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'date_nanos',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'double',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'double',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'integer',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'double',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'long',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'double',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'double',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'double',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'integer',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'integer',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'long',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'long',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'double',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'double',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'integer',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'long',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'The numeric value to round. If `null`, the function returns `null`.',
        },
        {
          name: 'points',
          type: 'long',
          optional: false,
          description: 'Remaining rounding points. Must be constants.',
          constantOnly: true,
        },
      ],
      returnType: 'long',
      minParams: 2,
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM employees\n| STATS COUNT(*) BY birth_window=ROUND_TO(\n    birth_date,\n    "1900-01-01T00:00:00Z"::DATETIME,\n    "1950-01-01T00:00:00Z"::DATETIME,\n    "1955-01-01T00:00:00Z"::DATETIME,\n    "1960-01-01T00:00:00Z"::DATETIME,\n    "1965-01-01T00:00:00Z"::DATETIME,\n    "1970-01-01T00:00:00Z"::DATETIME,\n    "1975-01-01T00:00:00Z"::DATETIME\n)\n| SORT birth_window ASC',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const rtrimDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'rtrim',
  description: i18n.translate('kbn-esql-language.esql.definitions.rtrim', {
    defaultMessage: 'Removes trailing whitespaces from a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW message = "   some text  ",  color = " red "\n| EVAL message = RTRIM(message)\n| EVAL color = RTRIM(color)\n| EVAL message = CONCAT("\'", message, "\'")\n| EVAL color = CONCAT("\'", color, "\'")',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const scalbDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'scalb',
  description: i18n.translate('kbn-esql-language.esql.definitions.scalb', {
    defaultMessage:
      "Returns the result of `d * 2 ^ scaleFactor`,\nSimilar to Java's `scalb` function. Result is rounded as if\nperformed by a single correctly rounded floating-point multiply\nto a member of the double value set.",
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'd',
          type: 'double',
          optional: false,
          description:
            'Numeric expression for the multiplier. If `null`, the function returns `null`.',
        },
        {
          name: 'scaleFactor',
          type: 'integer',
          optional: false,
          description:
            'Numeric expression for the scale factor. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'd',
          type: 'double',
          optional: false,
          description:
            'Numeric expression for the multiplier. If `null`, the function returns `null`.',
        },
        {
          name: 'scaleFactor',
          type: 'long',
          optional: false,
          description:
            'Numeric expression for the scale factor. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'd',
          type: 'integer',
          optional: false,
          description:
            'Numeric expression for the multiplier. If `null`, the function returns `null`.',
        },
        {
          name: 'scaleFactor',
          type: 'integer',
          optional: false,
          description:
            'Numeric expression for the scale factor. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'd',
          type: 'integer',
          optional: false,
          description:
            'Numeric expression for the multiplier. If `null`, the function returns `null`.',
        },
        {
          name: 'scaleFactor',
          type: 'long',
          optional: false,
          description:
            'Numeric expression for the scale factor. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'd',
          type: 'long',
          optional: false,
          description:
            'Numeric expression for the multiplier. If `null`, the function returns `null`.',
        },
        {
          name: 'scaleFactor',
          type: 'integer',
          optional: false,
          description:
            'Numeric expression for the scale factor. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'd',
          type: 'long',
          optional: false,
          description:
            'Numeric expression for the multiplier. If `null`, the function returns `null`.',
        },
        {
          name: 'scaleFactor',
          type: 'long',
          optional: false,
          description:
            'Numeric expression for the scale factor. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'd',
          type: 'unsigned_long',
          optional: false,
          description:
            'Numeric expression for the multiplier. If `null`, the function returns `null`.',
        },
        {
          name: 'scaleFactor',
          type: 'integer',
          optional: false,
          description:
            'Numeric expression for the scale factor. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'd',
          type: 'unsigned_long',
          optional: false,
          description:
            'Numeric expression for the multiplier. If `null`, the function returns `null`.',
        },
        {
          name: 'scaleFactor',
          type: 'long',
          optional: false,
          description:
            'Numeric expression for the scale factor. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['row x = 3.0, y = 10 | eval z = scalb(x, y)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const scoreDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'score',
  description: i18n.translate('kbn-esql-language.esql.definitions.score', {
    defaultMessage:
      'Scores an expression. Only full text functions will be scored. Returns scores for all the resulting docs.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'query',
          type: 'boolean',
          optional: false,
          description: 'Boolean expression that contains full text function(s) to be scored.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM books METADATA _score\n| WHERE match(title, "Return") AND match(author, "Tolkien")\n| EVAL first_score = score(match(title, "Return"))',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const sha1Definition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'sha1',
  description: i18n.translate('kbn-esql-language.esql.definitions.sha1', {
    defaultMessage: 'Computes the SHA1 hash of the input.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'input',
          type: 'keyword',
          optional: false,
          description: 'Input to hash.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'input',
          type: 'text',
          optional: false,
          description: 'Input to hash.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM sample_data\n| WHERE message != "Connection error"\n| EVAL sha1 = sha1(message)\n| KEEP message, sha1',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const sha256Definition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'sha256',
  description: i18n.translate('kbn-esql-language.esql.definitions.sha256', {
    defaultMessage: 'Computes the SHA256 hash of the input.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'input',
          type: 'keyword',
          optional: false,
          description: 'Input to hash.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'input',
          type: 'text',
          optional: false,
          description: 'Input to hash.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM sample_data\n| WHERE message != "Connection error"\n| EVAL sha256 = sha256(message)\n| KEEP message, sha256',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const signumDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'signum',
  description: i18n.translate('kbn-esql-language.esql.definitions.signum', {
    defaultMessage:
      'Returns the sign of the given number.\nIt returns `-1` for negative numbers, `0` for `0` and `1` for positive numbers.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW d = 100.0\n| EVAL s = SIGNUM(d)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const sinDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'sin',
  description: i18n.translate('kbn-esql-language.esql.definitions.sin', {
    defaultMessage: 'Returns the sine of an angle.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'angle',
          type: 'double',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'integer',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'long',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'unsigned_long',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=1.8\n| EVAL sin=SIN(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const sinhDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'sinh',
  description: i18n.translate('kbn-esql-language.esql.definitions.sinh', {
    defaultMessage: 'Returns the hyperbolic sine of a number.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=1.8\n| EVAL sinh=SINH(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const spaceDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'space',
  description: i18n.translate('kbn-esql-language.esql.definitions.space', {
    defaultMessage: 'Returns a string made of `number` spaces.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Number of spaces in result.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW message = CONCAT("Hello", SPACE(1), "World!");'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const splitDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'split',
  description: i18n.translate('kbn-esql-language.esql.definitions.split', {
    defaultMessage: 'Split a single valued string into multiple strings.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: false,
          description: 'Delimiter. Only single byte delimiters are currently supported.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'delim',
          type: 'text',
          optional: false,
          description: 'Delimiter. Only single byte delimiters are currently supported.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: false,
          description: 'Delimiter. Only single byte delimiters are currently supported.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'delim',
          type: 'text',
          optional: false,
          description: 'Delimiter. Only single byte delimiters are currently supported.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW words="foo;bar;baz;qux;quux;corge"\n| EVAL word = SPLIT(words, ";")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const sqrtDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'sqrt',
  description: i18n.translate('kbn-esql-language.esql.definitions.sqrt', {
    defaultMessage:
      'Returns the square root of a number. The input can be any numeric value, the return value is always a double.\nSquare roots of negative numbers and infinities are null.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW d = 100.0\n| EVAL s = SQRT(d)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stContainsDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_contains',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_contains', {
    defaultMessage:
      'Returns whether the first geometry contains the second geometry.\nThis is the inverse of the ST_WITHIN function.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airport_city_boundaries\n| WHERE ST_CONTAINS(city_boundary, TO_GEOSHAPE("POLYGON((109.35 18.3, 109.45 18.3, 109.45 18.4, 109.35 18.4, 109.35 18.3))"))\n| KEEP abbrev, airport, region, city, city_location',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stDisjointDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_disjoint',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_disjoint', {
    defaultMessage:
      'Returns whether the two geometries or geometry columns are disjoint.\nThis is the inverse of the ST_INTERSECTS function.\nIn mathematical terms: ST_Disjoint(A, B)  A  B = ',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geohash',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geohex',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geotile',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geohash',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geohex',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geotile',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airport_city_boundaries\n| WHERE ST_DISJOINT(city_boundary, TO_GEOSHAPE("POLYGON((-10 -60, 120 -60, 120 60, -10 60, -10 -60))"))\n| KEEP abbrev, airport, region, city, city_location',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stDistanceDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_distance',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_distance', {
    defaultMessage:
      'Computes the distance between two points.\nFor cartesian geometries, this is the pythagorean distance in the same units as the original coordinates.\nFor geographic geometries, this is the circular distance along the great circle in meters.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point` or `cartesian_point`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point` or `cartesian_point`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_point` and `cartesian_point` parameters.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point` or `cartesian_point`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point` or `cartesian_point`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_point` and `cartesian_point` parameters.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airports\n| WHERE abbrev == "CPH"\n| EVAL distance = ST_DISTANCE(location, city_location)\n| KEEP abbrev, name, location, city_location, distance',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stEnvelopeDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_envelope',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_envelope', {
    defaultMessage: 'Determines the minimum bounding box of the supplied geometry.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geometry',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'geo_shape',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| KEEP abbrev, airport, envelope',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stGeohashDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_geohash',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_geohash', {
    defaultMessage:
      'Calculates the `geohash` of the supplied geo_point at the specified precision.\nThe result is long encoded. Use TO_STRING to convert the result to a string,\nTO_LONG to convert it to a `long`, or TO_GEOSHAPE to calculate\nthe `geo_shape` bounding geometry.\n\nThese functions are related to the `geo_grid` query\nand the `geohash_grid` aggregation.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_point',
          optional: false,
          description: 'Expression of type `geo_point`. If `null`, the function returns `null`.',
        },
        {
          name: 'precision',
          type: 'integer',
          optional: false,
          description:
            'Expression of type `integer`. If `null`, the function returns `null`. Valid values are between [1 and 12](https://en.wikipedia.org/wiki/Geohash).',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_point',
          optional: false,
          description: 'Expression of type `geo_point`. If `null`, the function returns `null`.',
        },
        {
          name: 'precision',
          type: 'integer',
          optional: false,
          description:
            'Expression of type `integer`. If `null`, the function returns `null`. Valid values are between [1 and 12](https://en.wikipedia.org/wiki/Geohash).',
        },
        {
          name: 'bounds',
          type: 'geo_shape',
          optional: true,
          description:
            'Optional bounds to filter the grid tiles, a `geo_shape` of type `BBOX`. Use [`ST_ENVELOPE`](#esql-st_envelope) if the `geo_shape` is of any other type.',
        },
      ],
      returnType: 'geohash',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airports\n| EVAL geohash = ST_GEOHASH(location, 1)\n| STATS\n    count = COUNT(geohash),\n    centroid = ST_CENTROID_AGG(location)\n      BY geohash\n| WHERE count >= 10\n| EVAL geohashString = TO_STRING(geohash)\n| KEEP count, centroid, geohashString\n| SORT count DESC, geohashString ASC',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stGeohexDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_geohex',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_geohex', {
    defaultMessage:
      'Calculates the `geohex`, the H3 cell-id, of the supplied geo_point at the specified precision.\nThe result is long encoded. Use TO_STRING to convert the result to a string,\nTO_LONG to convert it to a `long`, or TO_GEOSHAPE to calculate\nthe `geo_shape` bounding geometry.\n\nThese functions are related to the `geo_grid` query\nand the `geohex_grid` aggregation.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_point',
          optional: false,
          description: 'Expression of type `geo_point`. If `null`, the function returns `null`.',
        },
        {
          name: 'precision',
          type: 'integer',
          optional: false,
          description:
            'Expression of type `integer`. If `null`, the function returns `null`. Valid values are between [0 and 15](https://h3geo.org/docs/core-library/restable/).',
        },
      ],
      license: 'platinum',
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_point',
          optional: false,
          description: 'Expression of type `geo_point`. If `null`, the function returns `null`.',
        },
        {
          name: 'precision',
          type: 'integer',
          optional: false,
          description:
            'Expression of type `integer`. If `null`, the function returns `null`. Valid values are between [0 and 15](https://h3geo.org/docs/core-library/restable/).',
        },
        {
          name: 'bounds',
          type: 'geo_shape',
          optional: true,
          description:
            'Optional bounds to filter the grid tiles, a `geo_shape` of type `BBOX`. Use [`ST_ENVELOPE`](#esql-st_envelope) if the `geo_shape` is of any other type.',
        },
      ],
      license: 'platinum',
      returnType: 'geohex',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  license: 'platinum',
  examples: [
    'FROM airports\n| EVAL geohex = ST_GEOHEX(location, 1)\n| STATS\n    count = COUNT(geohex),\n    centroid = ST_CENTROID_AGG(location)\n      BY geohex\n| WHERE count >= 10\n| EVAL geohexString = TO_STRING(geohex)\n| KEEP count, centroid, geohexString\n| SORT count DESC, geohexString ASC',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stGeotileDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_geotile',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_geotile', {
    defaultMessage:
      'Calculates the `geotile` of the supplied geo_point at the specified precision.\nThe result is long encoded. Use TO_STRING to convert the result to a string,\nTO_LONG to convert it to a `long`, or TO_GEOSHAPE to calculate\nthe `geo_shape` bounding geometry.\n\nThese functions are related to the `geo_grid` query\nand the `geotile_grid` aggregation.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_point',
          optional: false,
          description: 'Expression of type `geo_point`. If `null`, the function returns `null`.',
        },
        {
          name: 'precision',
          type: 'integer',
          optional: false,
          description:
            'Expression of type `integer`. If `null`, the function returns `null`. Valid values are between [0 and 29](https://wiki.openstreetmap.org/wiki/Zoom_levels).',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_point',
          optional: false,
          description: 'Expression of type `geo_point`. If `null`, the function returns `null`.',
        },
        {
          name: 'precision',
          type: 'integer',
          optional: false,
          description:
            'Expression of type `integer`. If `null`, the function returns `null`. Valid values are between [0 and 29](https://wiki.openstreetmap.org/wiki/Zoom_levels).',
        },
        {
          name: 'bounds',
          type: 'geo_shape',
          optional: true,
          description:
            'Optional bounds to filter the grid tiles, a `geo_shape` of type `BBOX`. Use [`ST_ENVELOPE`](#esql-st_envelope) if the `geo_shape` is of any other type.',
        },
      ],
      returnType: 'geotile',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airports\n| EVAL geotile = ST_GEOTILE(location, 2)\n| STATS\n    count = COUNT(geotile),\n    centroid = ST_CENTROID_AGG(location)\n      BY geotile\n| EVAL geotileString = TO_STRING(geotile)\n| SORT count DESC, geotileString ASC\n| KEEP count, centroid, geotileString',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stIntersectsDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_intersects',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_intersects', {
    defaultMessage:
      'Returns true if two geometries intersect.\nThey intersect if they have any point in common, including their interior points\n(points along lines or within polygons).\nThis is the inverse of the ST_DISJOINT function.\nIn mathematical terms: ST_Intersects(A, B)  A  B  ',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geohash',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geohex',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geotile',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geohash',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geohex',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geotile',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression that is either a geometry (`geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`) or a geo-grid value (`geohash`, `geotile`, `geohex`). If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airports\n| WHERE ST_INTERSECTS(location, TO_GEOSHAPE("POLYGON((42 14, 43 14, 43 15, 42 15, 42 14))"))',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stNpointsDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_npoints',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_npoints', {
    defaultMessage: 'Counts the number of points in the supplied geometry.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geometry',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'integer',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL points = ST_NPOINTS(city_boundary)\n| KEEP abbrev, airport, points',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stSimplifyDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_simplify',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_simplify', {
    defaultMessage:
      'Simplifies the input geometry by applying the Douglas-Peucker algorithm with a specified tolerance. Vertices that fall within the tolerance distance from the simplified shape are removed. Note that the resulting geometry may be invalid, even if the original input was valid.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geometry',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'tolerance',
          type: 'double',
          optional: false,
          description: 'Tolerance for the geometry simplification, in the units of the input SRS',
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'tolerance',
          type: 'double',
          optional: false,
          description: 'Tolerance for the geometry simplification, in the units of the input SRS',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'tolerance',
          type: 'double',
          optional: false,
          description: 'Tolerance for the geometry simplification, in the units of the input SRS',
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'tolerance',
          type: 'double',
          optional: false,
          description: 'Tolerance for the geometry simplification, in the units of the input SRS',
        },
      ],
      returnType: 'geo_shape',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW wkt = "POLYGON ((7.998 53.827, 9.470 53.068, 15.754 53.801, 16.523 57.160, 11.162 57.868, 8.064 57.445, 6.219 55.317, 7.998 53.827))"\n| EVAL simplified = ST_SIMPLIFY(TO_GEOSHAPE(wkt), 0.7)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stWithinDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_within',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_within', {
    defaultMessage:
      'Returns whether the first geometry is within the second geometry.\nThis is the inverse of the ST_CONTAINS function.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `cartesian_point`, `geo_shape` or `cartesian_shape`. If `null`, the function returns `null`. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine `geo_*` and `cartesian_*` parameters.',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airport_city_boundaries\n| WHERE ST_WITHIN(city_boundary, TO_GEOSHAPE("POLYGON((109.1 18.15, 109.6 18.15, 109.6 18.65, 109.1 18.65, 109.1 18.15))"))\n| KEEP abbrev, airport, region, city, city_location',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stXDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_x',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_x', {
    defaultMessage:
      'Extracts the `x` coordinate from the supplied point.\nIf the point is of type `geo_point` this is equivalent to extracting the `longitude` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point` or `cartesian_point`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point` or `cartesian_point`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW point = TO_GEOPOINT("POINT(42.97109629958868 14.7552534006536)")\n| EVAL x =  ST_X(point), y = ST_Y(point)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stXmaxDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_xmax',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_xmax', {
    defaultMessage:
      'Extracts the maximum value of the `x` coordinates from the supplied geometry.\nIf the geometry is of type `geo_point` or `geo_shape` this is equivalent to extracting the maximum `longitude` value.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stXminDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_xmin',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_xmin', {
    defaultMessage:
      'Extracts the minimum value of the `x` coordinates from the supplied geometry.\nIf the geometry is of type `geo_point` or `geo_shape` this is equivalent to extracting the minimum `longitude` value.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stYDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_y',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_y', {
    defaultMessage:
      'Extracts the `y` coordinate from the supplied point.\nIf the point is of type `geo_point` this is equivalent to extracting the `latitude` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point` or `cartesian_point`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point` or `cartesian_point`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW point = TO_GEOPOINT("POINT(42.97109629958868 14.7552534006536)")\n| EVAL x =  ST_X(point), y = ST_Y(point)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stYmaxDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_ymax',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_ymax', {
    defaultMessage:
      'Extracts the maximum value of the `y` coordinates from the supplied geometry.\nIf the geometry is of type `geo_point` or `geo_shape` this is equivalent to extracting the maximum `latitude` value.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stYminDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'st_ymin',
  description: i18n.translate('kbn-esql-language.esql.definitions.st_ymin', {
    defaultMessage:
      'Extracts the minimum value of the `y` coordinates from the supplied geometry.\nIf the geometry is of type `geo_point` or `geo_shape` this is equivalent to extracting the minimum `latitude` value.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_shape',
          optional: false,
          description:
            'Expression of type `geo_point`, `geo_shape`, `cartesian_point` or `cartesian_shape`. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const startsWithDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'starts_with',
  description: i18n.translate('kbn-esql-language.esql.definitions.starts_with', {
    defaultMessage:
      'Returns a boolean that indicates whether a keyword string starts with another string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'prefix',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'prefix',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'prefix',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'prefix',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['FROM employees\n| KEEP last_name\n| EVAL ln_S = STARTS_WITH(last_name, "B")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const substringDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'substring',
  description: i18n.translate('kbn-esql-language.esql.definitions.substring', {
    defaultMessage:
      'Returns a substring of a string, specified by a start position and an optional length.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description: 'Start position.',
        },
        {
          name: 'length',
          type: 'integer',
          optional: true,
          description:
            'Length of the substring from the start position. Optional; if omitted, all positions after `start` are returned.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
          description: 'Start position.',
        },
        {
          name: 'length',
          type: 'integer',
          optional: true,
          description:
            'Length of the substring from the start position. Optional; if omitted, all positions after `start` are returned.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM employees\n| KEEP last_name\n| EVAL ln_sub = SUBSTRING(last_name, 1, 3)',
    'FROM employees\n| KEEP last_name\n| EVAL ln_sub = SUBSTRING(last_name, -3, 3)',
    'FROM employees\n| KEEP last_name\n| EVAL ln_sub = SUBSTRING(last_name, 2)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const tanDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'tan',
  description: i18n.translate('kbn-esql-language.esql.definitions.tan', {
    defaultMessage: 'Returns the tangent of an angle.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'angle',
          type: 'double',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'integer',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'long',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'unsigned_long',
          optional: false,
          description: 'An angle, in radians. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=1.8\n| EVAL tan=TAN(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const tanhDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'tanh',
  description: i18n.translate('kbn-esql-language.esql.definitions.tanh', {
    defaultMessage: 'Returns the hyperbolic tangent of a number.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description: 'Numeric expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=1.8\n| EVAL tanh=TANH(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const tauDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'tau',
  description: i18n.translate('kbn-esql-language.esql.definitions.tau', {
    defaultMessage: 'Returns the ratio of a circles circumference to its radius.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW TAU()'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const textEmbeddingDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'text_embedding',
  description: i18n.translate('kbn-esql-language.esql.definitions.text_embedding', {
    defaultMessage:
      'Generates dense vector embeddings from text input using a specified inference endpoint. Use this function to generate query vectors for KNN searches against your vectorized data or others dense vector based operations.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'text',
          type: 'keyword',
          optional: false,
          description:
            'Text string to generate embeddings from. Must be a non-null literal string value.',
        },
        {
          name: 'inference_id',
          type: 'keyword',
          optional: false,
          description:
            'Identifier of an existing inference endpoint the that will generate the embeddings. The inference endpoint must have the `text_embedding` task type and should use the same model that was used to embed your indexed data.',
          hint: {
            entityType: 'inference_endpoint',
            constraints: {
              task_type: 'text_embedding',
            },
          },
        },
      ],
      returnType: 'dense_vector',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM dense_vector_text METADATA _score\n| WHERE KNN(text_embedding_field, TEXT_EMBEDDING("be excellent to each other", "test_dense_inference"))',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toAggregateMetricDoubleDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_aggregate_metric_double',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_aggregate_metric_double', {
    defaultMessage: 'Encode a numeric to an aggregate_metric_double.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'aggregate_metric_double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'aggregate_metric_double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'aggregate_metric_double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'aggregate_metric_double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'aggregate_metric_double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'aggregate_metric_double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW x = 3892095203\n| EVAL agg_metric = TO_AGGREGATE_METRIC_DOUBLE(x)',
    'ROW x = [5032, 11111, 40814]\n| EVAL agg_metric = TO_AGGREGATE_METRIC_DOUBLE(x)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toBase64Definition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_base64',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_base64', {
    defaultMessage: 'Encode a string to a base64 string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'A string.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'A string.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a = "elastic"\n| EVAL e = TO_BASE64(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toBooleanDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_boolean',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_boolean', {
    defaultMessage:
      'Converts an input value to a boolean value.\nA string value of `true` will be case-insensitive converted to the Boolean `true`.\nFor anything else, including the empty string, the function will return `false`.\nThe numerical value of `0` will be converted to `false`, anything else will be converted to `true`.',
  }),
  preview: false,
  alias: ['to_bool'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW str = ["true", "TRuE", "false", "", "yes", "1"]\n| EVAL bool = TO_BOOLEAN(str)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toCartesianpointDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_cartesianpoint',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_cartesianpoint', {
    defaultMessage:
      'Converts an input value to a `cartesian_point` value.\nA string will only be successfully converted if it respects the\nWKT Point format.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'cartesian_point',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW wkt = ["POINT(4297.11 -1475.53)", "POINT(7580.93 2272.77)"]\n| MV_EXPAND wkt\n| EVAL pt = TO_CARTESIANPOINT(wkt)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toCartesianshapeDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_cartesianshape',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_cartesianshape', {
    defaultMessage:
      'Converts an input value to a `cartesian_shape` value.\nA string will only be successfully converted if it respects the\nWKT format.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'cartesian_shape',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW wkt = ["POINT(4297.11 -1475.53)", "POLYGON ((3339584.72 1118889.97, 4452779.63 4865942.27, 2226389.81 4865942.27, 1113194.90 2273030.92, 3339584.72 1118889.97))"]\n| MV_EXPAND wkt\n| EVAL geom = TO_CARTESIANSHAPE(wkt)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDateNanosDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_date_nanos',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_date_nanos', {
    defaultMessage: 'Converts an input to a nanosecond-resolution date value (aka date_nanos).',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date_nanos',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM date_nanos\n| WHERE MV_MIN(nanos) < TO_DATE_NANOS("2023-10-23T12:27:28.948Z")\n    AND millis > "2000-01-01"\n| SORT nanos DESC',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDateperiodDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_dateperiod',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_dateperiod', {
    defaultMessage: 'Converts an input value into a `date_period` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'date_period',
          optional: false,
          description: 'Input value. The input is a valid constant date period expression.',
        },
      ],
      returnType: 'date_period',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Input value. The input is a valid constant date period expression.',
        },
      ],
      returnType: 'date_period',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Input value. The input is a valid constant date period expression.',
        },
      ],
      returnType: 'date_period',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW x = "2024-01-01"::datetime\n| EVAL y = x + "3 DAYS"::date_period, z = x - TO_DATEPERIOD("3 days");',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDatetimeDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_datetime',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_datetime', {
    defaultMessage:
      "Converts an input value to a date value.\nA string will only be successfully converted if its respecting the format `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'`.\nTo convert dates in other formats, use `DATE_PARSE`.",
  }),
  preview: false,
  alias: ['to_dt'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'date',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW string = ["1953-09-02T00:00:00.000Z", "1964-06-02T00:00:00.000Z", "1964-06-02 00:00:00"]\n| EVAL datetime = TO_DATETIME(string)',
    'ROW int = [0, 1]\n| EVAL dt = TO_DATETIME(int)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDegreesDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_degrees',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_degrees', {
    defaultMessage: 'Converts a number in radians to degrees.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW rad = [1.57, 3.14, 4.71]\n| EVAL deg = TO_DEGREES(rad)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDenseVectorDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_dense_vector',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_dense_vector', {
    defaultMessage:
      'Converts a multi-valued input of numbers, or a hexadecimal string, to a dense_vector.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description: 'multi-valued input of numbers or hexadecimal string to convert.',
        },
      ],
      returnType: 'dense_vector',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description: 'multi-valued input of numbers or hexadecimal string to convert.',
        },
      ],
      returnType: 'dense_vector',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'multi-valued input of numbers or hexadecimal string to convert.',
        },
      ],
      returnType: 'dense_vector',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description: 'multi-valued input of numbers or hexadecimal string to convert.',
        },
      ],
      returnType: 'dense_vector',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['row ints = [1, 2, 3]\n| eval vector = to_dense_vector(ints)\n| keep vector'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDoubleDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_double',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_double', {
    defaultMessage:
      'Converts an input value to a double value. If the input parameter is of a date type,\nits value will be interpreted as milliseconds since the Unix epoch,\nconverted to double. Boolean `true` will be converted to double `1.0`, `false` to `0.0`.',
  }),
  preview: false,
  alias: ['to_dbl'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW str1 = "5.20128E11", str2 = "foo"\n| EVAL dbl = TO_DOUBLE("520128000000"), dbl1 = TO_DOUBLE(str1), dbl2 = TO_DOUBLE(str2)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toGeohashDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_geohash',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_geohash', {
    defaultMessage:
      'Converts an input value to a `geohash` value.\nA string will only be successfully converted if it respects the\n`geohash` format, as described for the\ngeohash grid aggregation.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'geohash',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geohash',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geohash',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW string = "u3bu"\n| EVAL geohash = TO_GEOHASH(string)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toGeohexDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_geohex',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_geohex', {
    defaultMessage:
      'Converts an input value to a `geohex` value.\nA string will only be successfully converted if it respects the\n`geohex` format, as described for the\ngeohex grid aggregation.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'geohex',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geohex',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geohex',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW string = "841f059ffffffff"\n| EVAL geohex = TO_GEOHEX(string)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toGeopointDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_geopoint',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_geopoint', {
    defaultMessage:
      'Converts an input value to a `geo_point` value.\nA string will only be successfully converted if it respects the\nWKT Point format.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geo_point',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW wkt = "POINT(42.97109630194 14.7552534413725)"\n| EVAL pt = TO_GEOPOINT(wkt)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toGeoshapeDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_geoshape',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_geoshape', {
    defaultMessage:
      'Converts an input value to a `geo_shape` value.\nA string will only be successfully converted if it respects the\nWKT format.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohash',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohex',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geotile',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geo_shape',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW wkt = "POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))"\n| EVAL geom = TO_GEOSHAPE(wkt)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toGeotileDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_geotile',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_geotile', {
    defaultMessage:
      'Converts an input value to a `geotile` value.\nA string will only be successfully converted if it respects the\n`geotile` format, as described for the\ngeotile grid aggregation.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'geotile',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geotile',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'geotile',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW string = "4/8/5"\n| EVAL geotile = TO_GEOTILE(string)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toIntegerDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_integer',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_integer', {
    defaultMessage:
      'Converts an input value to an integer value.\nIf the input parameter is of a date type, its value will be interpreted as milliseconds\nsince the Unix epoch, converted to integer.\nBoolean `true` will be converted to integer `1`, `false` to `0`.',
  }),
  preview: false,
  alias: ['to_int'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'integer',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'long',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'integer',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'long',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'integer',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW long = [5013792, 2147483647, 501379200000]\n| EVAL int = TO_INTEGER(long)',
    'ROW str1 = "0x32", str2 = "31"\n| EVAL int1 = TO_INTEGER(str1, 16), int2 = TO_INTEGER(str2, 13)\n| KEEP str1, int1, str2, int2',
    'ROW str1 = "Kona"\n| EVAL int1 = TO_INTEGER(str1, 27), fail1 = TO_INTEGER(str1, 10)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toIpDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_ip',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_ip', {
    defaultMessage: 'Converts an input string to an IP value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='leading_zeros', values=[reject, octal, decimal], description='What to do with leading 0s in IPv4 addresses.', type=[keyword]}",
          optional: true,
          description: '(Optional) Additional options.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='leading_zeros', values=[reject, octal, decimal], description='What to do with leading 0s in IPv4 addresses.', type=[keyword]}",
          optional: true,
          description: '(Optional) Additional options.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='leading_zeros', values=[reject, octal, decimal], description='What to do with leading 0s in IPv4 addresses.', type=[keyword]}",
          optional: true,
          description: '(Optional) Additional options.',
        },
      ],
      returnType: 'ip',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW str1 = "1.1.1.1", str2 = "foo"\n| EVAL ip1 = TO_IP(str1), ip2 = TO_IP(str2)\n| WHERE CIDR_MATCH(ip1, "1.0.0.0/8")',
    'ROW s = "1.1.010.1" | EVAL ip = TO_IP(s, {"leading_zeros":"octal"})',
    'ROW s = "1.1.010.1" | EVAL ip = TO_IP(s, {"leading_zeros":"decimal"})',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toLongDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_long',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_long', {
    defaultMessage:
      'Converts the input value to a long.\nIf the input parameter is of a date type, its value will be interpreted as milliseconds\nsince the Unix epoch, converted to long.\nBoolean `true` will be converted to long `1`, `false` to `0`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohash',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohex',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geotile',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'integer',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'long',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'integer',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'long',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
          description:
            '(Optional) Radix or base used to convert the input value.When a base is specified the input type must be `keyword` or `text`.',
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW str1 = "2147483648", str2 = "2147483648.2", str3 = "foo"\n| EVAL long1 = TO_LONG(str1), long2 = TO_LONG(str2), long3 = TO_LONG(str3)',
    'ROW str1 = "0x32", str2 = "31"\n| EVAL long1 = TO_LONG(str1, 16), long2 = TO_LONG(str2, 13)\n| KEEP str1, long1, str2, long2',
    'ROW str1 = "Hazelnut"\n| EVAL long1 = TO_LONG(str1, 36), fail1 = TO_LONG(str1, 10)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toLowerDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_lower',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_lower', {
    defaultMessage: 'Returns a new string representing the input string converted to lower case.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
          description:
            'String expression. If `null`, the function returns `null`. The input can be a single-valued column or expression, or a multi-valued column or expression. ',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
          description:
            'String expression. If `null`, the function returns `null`. The input can be a single-valued column or expression, or a multi-valued column or expression. ',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW message = "Some Text"\n| EVAL message_lower = TO_LOWER(message)',
    'ROW v = TO_LOWER(["Some", "Text"])',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toRadiansDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_radians',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_radians', {
    defaultMessage: 'Converts a number in degrees to radians.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW deg = [90.0, 180.0, 270.0]\n| EVAL rad = TO_RADIANS(deg)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toStringDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_string',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_string', {
    defaultMessage: 'Converts an input value into a string.',
  }),
  preview: false,
  alias: ['to_str'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'aggregate_metric_double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'dense_vector',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'exponential_histogram',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohash',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geohex',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geotile',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'histogram',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW a=10\n| EVAL j = TO_STRING(a)', 'ROW a=[10, 9, 8]\n| EVAL j = TO_STRING(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toTimedurationDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_timeduration',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_timeduration', {
    defaultMessage: 'Converts an input value into a `time_duration` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'Input value. The input is a valid constant time duration expression.',
        },
      ],
      returnType: 'time_duration',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'Input value. The input is a valid constant time duration expression.',
        },
      ],
      returnType: 'time_duration',
    },
    {
      params: [
        {
          name: 'field',
          type: 'time_duration',
          optional: false,
          description: 'Input value. The input is a valid constant time duration expression.',
        },
      ],
      returnType: 'time_duration',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW x = "2024-01-01"::datetime\n| EVAL y = x + "3 hours"::time_duration, z = x - TO_TIMEDURATION("3 hours");',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toUnsignedLongDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_unsigned_long',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_unsigned_long', {
    defaultMessage:
      'Converts an input value to an unsigned long value. If the input parameter is of a date type,\nits value will be interpreted as milliseconds since the Unix epoch, converted to unsigned long.\nBoolean `true` will be converted to unsigned long `1`, `false` to `0`.',
  }),
  preview: true,
  alias: ['to_ul', 'to_ulong'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW str1 = "2147483648", str2 = "2147483648.2", str3 = "foo"\n| EVAL long1 = TO_UNSIGNED_LONG(str1), long2 = TO_ULONG(str2), long3 = TO_UL(str3)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toUpperDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_upper',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_upper', {
    defaultMessage: 'Returns a new string representing the input string converted to upper case.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
          description:
            'String expression. If `null`, the function returns `null`. The input can be a single-valued column or expression, or a multi-valued column or expression. ',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
          description:
            'String expression. If `null`, the function returns `null`. The input can be a single-valued column or expression, or a multi-valued column or expression. ',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW message = "Some Text"\n| EVAL message_upper = TO_UPPER(message)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toVersionDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'to_version',
  description: i18n.translate('kbn-esql-language.esql.definitions.to_version', {
    defaultMessage: 'Converts an input string to a version value.',
  }),
  preview: false,
  alias: ['to_ver'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'version',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'version',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          description:
            'Input value. The input can be a single- or multi-valued column or an expression.',
        },
      ],
      returnType: 'version',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW v = TO_VERSION("1.2.3")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const topSnippetsDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'top_snippets',
  description: i18n.translate('kbn-esql-language.esql.definitions.top_snippets', {
    defaultMessage:
      'Use `TOP_SNIPPETS` to extract the best snippets for a given query string from a text field.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'The input to chunk.',
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description:
            'The input text containing only query terms for snippet extraction. Lucene query syntax, operators, and wildcards are not allowed. ',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          description: 'The input to chunk.',
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description:
            'The input text containing only query terms for snippet extraction. Lucene query syntax, operators, and wildcards are not allowed. ',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='num_words', values=[300], description='The maximum number of words to return in each snippet.\nThis allows better control of inference costs by limiting the size of tokens per snippet.\n', type=[integer]}, {name='num_snippets', values=[3], description='The maximum number of matching snippets to return.', type=[integer]}",
          optional: true,
          description:
            '(Optional) `TOP_SNIPPETS` additional options as [function named parameters](https://www.elastic.co/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params).',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'The input to chunk.',
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description:
            'The input text containing only query terms for snippet extraction. Lucene query syntax, operators, and wildcards are not allowed. ',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          description: 'The input to chunk.',
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          description:
            'The input text containing only query terms for snippet extraction. Lucene query syntax, operators, and wildcards are not allowed. ',
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='num_words', values=[300], description='The maximum number of words to return in each snippet.\nThis allows better control of inference costs by limiting the size of tokens per snippet.\n', type=[integer]}, {name='num_snippets', values=[3], description='The maximum number of matching snippets to return.', type=[integer]}",
          optional: true,
          description:
            '(Optional) `TOP_SNIPPETS` additional options as [function named parameters](https://www.elastic.co/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params).',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM books\n| EVAL snippets = TOP_SNIPPETS(description, "Tolkien")',
    'FROM books\n| WHERE MATCH(title, "Return")\n| EVAL snippets = TOP_SNIPPETS(description, "Tolkien", { "num_snippets": 3, "num_words": 25 })',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const trangeDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'trange',
  description: i18n.translate('kbn-esql-language.esql.definitions.trange', {
    defaultMessage: 'Filters data for the given time range using the @timestamp attribute.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'start_time_or_offset',
          type: 'date',
          optional: false,
          description:
            ' Offset from NOW for the single parameter mode. Start time for two parameter mode.  In two parameter mode, the start time value can be a date string, date, date_nanos or epoch milliseconds. ',
        },
        {
          name: 'end_time',
          type: 'date',
          optional: true,
          description:
            'Explicit end time that can be a date string, date, date_nanos or epoch milliseconds.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'start_time_or_offset',
          type: 'date_nanos',
          optional: false,
          description:
            ' Offset from NOW for the single parameter mode. Start time for two parameter mode.  In two parameter mode, the start time value can be a date string, date, date_nanos or epoch milliseconds. ',
        },
        {
          name: 'end_time',
          type: 'date_nanos',
          optional: true,
          description:
            'Explicit end time that can be a date string, date, date_nanos or epoch milliseconds.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'start_time_or_offset',
          type: 'date_period',
          optional: false,
          description:
            ' Offset from NOW for the single parameter mode. Start time for two parameter mode.  In two parameter mode, the start time value can be a date string, date, date_nanos or epoch milliseconds. ',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'start_time_or_offset',
          type: 'keyword',
          optional: false,
          description:
            ' Offset from NOW for the single parameter mode. Start time for two parameter mode.  In two parameter mode, the start time value can be a date string, date, date_nanos or epoch milliseconds. ',
        },
        {
          name: 'end_time',
          type: 'keyword',
          optional: true,
          description:
            'Explicit end time that can be a date string, date, date_nanos or epoch milliseconds.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'start_time_or_offset',
          type: 'long',
          optional: false,
          description:
            ' Offset from NOW for the single parameter mode. Start time for two parameter mode.  In two parameter mode, the start time value can be a date string, date, date_nanos or epoch milliseconds. ',
        },
        {
          name: 'end_time',
          type: 'long',
          optional: true,
          description:
            'Explicit end time that can be a date string, date, date_nanos or epoch milliseconds.',
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'start_time_or_offset',
          type: 'time_duration',
          optional: false,
          description:
            ' Offset from NOW for the single parameter mode. Start time for two parameter mode.  In two parameter mode, the start time value can be a date string, date, date_nanos or epoch milliseconds. ',
        },
      ],
      returnType: 'boolean',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'FROM k8s\n| WHERE TRANGE(1h)\n| KEEP @timestamp',
    'FROM k8s\n| WHERE TRANGE("2024-05-10T00:17:14.000Z", "2024-05-10T00:18:33.000Z")\n| SORT @timestamp\n| KEEP @timestamp\n| LIMIT 10',
    'FROM k8s\n| WHERE TRANGE(to_datetime("2024-05-10T00:17:14Z"), to_datetime("2024-05-10T00:18:33Z"))\n| SORT @timestamp\n| KEEP @timestamp\n| LIMIT 10',
    'FROM k8s\n| WHERE TRANGE(to_datetime("2024-05-10T00:17:14.000Z"), to_datetime("2024-05-10T00:18:33.000Z"))\n| SORT @timestamp\n| KEEP @timestamp\n| LIMIT 10',
    'FROM k8s\n| WHERE TRANGE(1715300236000, 1715300282000)\n| SORT @timestamp\n| KEEP @timestamp\n| LIMIT 10',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const trimDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'trim',
  description: i18n.translate('kbn-esql-language.esql.definitions.trim', {
    defaultMessage: 'Removes leading and trailing whitespaces from a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'String expression. If `null`, the function returns `null`.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW message = "   some text  ",  color = " red "\n| EVAL message = TRIM(message)\n| EVAL color = TRIM(color)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const urlDecodeDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'url_decode',
  description: i18n.translate('kbn-esql-language.esql.definitions.url_decode', {
    defaultMessage:
      'URL-decodes the input, or returns `null` and adds a warning header to the response if the input cannot be decoded.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'The URL-encoded string to decode.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'The URL-encoded string to decode.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'ROW u = "https%3A%2F%2Fexample.com%2F%3Fx%3Dfoo%20bar%26y%3Dbaz"\n| EVAL u = URL_DECODE(u)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const urlEncodeDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'url_encode',
  description: i18n.translate('kbn-esql-language.esql.definitions.url_encode', {
    defaultMessage:
      'URL-encodes the input. All characters are percent-encoded except for alphanumerics, `.`, `-`, `_`, and `~`. Spaces are encoded as `+`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'The URL to encode.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'The URL to encode.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW u = "https://example.com/?x=foo bar&y=baz" | EVAL u = URL_ENCODE(u)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const urlEncodeComponentDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'url_encode_component',
  description: i18n.translate('kbn-esql-language.esql.definitions.url_encode_component', {
    defaultMessage:
      'URL-encodes the input. All characters are percent-encoded except for alphanumerics, `.`, `-`, `_`, and `~`. Spaces are encoded as `%20`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
          description: 'The URL to encode.',
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
          description: 'The URL to encode.',
        },
      ],
      returnType: 'keyword',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: ['ROW u = "https://example.com/?x=foo bar&y=baz"\n| EVAL u = URL_ENCODE_COMPONENT(u)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const vCosineDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'v_cosine',
  description: i18n.translate('kbn-esql-language.esql.definitions.v_cosine', {
    defaultMessage: 'Calculates the cosine similarity between two dense_vectors.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'left',
          type: 'dense_vector',
          optional: false,
          description: 'first dense_vector to calculate cosine similarity',
        },
        {
          name: 'right',
          type: 'dense_vector',
          optional: false,
          description: 'second dense_vector to calculate cosine similarity',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'from colors\n| where color != "black"\n| eval similarity = v_cosine(rgb_vector, [0, 255, 255])\n| sort similarity desc, color asc',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const vDotProductDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'v_dot_product',
  description: i18n.translate('kbn-esql-language.esql.definitions.v_dot_product', {
    defaultMessage: 'Calculates the dot product between two dense_vectors.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'left',
          type: 'dense_vector',
          optional: false,
          description: 'first dense_vector to calculate dot product similarity',
        },
        {
          name: 'right',
          type: 'dense_vector',
          optional: false,
          description: 'second dense_vector to calculate dot product similarity',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'from colors\n| eval similarity = v_dot_product(rgb_vector, [0, 255, 255])\n| sort similarity desc, color asc',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const vHammingDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'v_hamming',
  description: i18n.translate('kbn-esql-language.esql.definitions.v_hamming', {
    defaultMessage: 'Calculates the Hamming distance between two dense vectors.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'left',
          type: 'dense_vector',
          optional: false,
          description: 'First dense_vector to use to calculate the Hamming distance',
        },
        {
          name: 'right',
          type: 'dense_vector',
          optional: false,
          description: 'Second dense_vector to use to calculate the Hamming distance',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'from colors\n| eval similarity = v_hamming(rgb_byte_vector, [0, 127, 127])\n| sort similarity desc, color asc',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const vL1NormDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'v_l1_norm',
  description: i18n.translate('kbn-esql-language.esql.definitions.v_l1_norm', {
    defaultMessage: 'Calculates the l1 norm between two dense_vectors.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'left',
          type: 'dense_vector',
          optional: false,
          description: 'first dense_vector to calculate l1 norm similarity',
        },
        {
          name: 'right',
          type: 'dense_vector',
          optional: false,
          description: 'second dense_vector to calculate l1 norm similarity',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'from colors\n| eval similarity = v_l1_norm(rgb_vector, [0, 255, 255])\n| sort similarity desc, color asc',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const vL2NormDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'v_l2_norm',
  description: i18n.translate('kbn-esql-language.esql.definitions.v_l2_norm', {
    defaultMessage: 'Calculates the l2 norm between two dense_vectors.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'left',
          type: 'dense_vector',
          optional: false,
          description: 'first dense_vector to calculate l2 norm similarity',
        },
        {
          name: 'right',
          type: 'dense_vector',
          optional: false,
          description: 'second dense_vector to calculate l2 norm similarity',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'from colors\n| eval similarity = v_l2_norm(rgb_vector, [0, 255, 255])\n| sort similarity desc, color asc',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const vMagnitudeDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'v_magnitude',
  description: i18n.translate('kbn-esql-language.esql.definitions.v_magnitude', {
    defaultMessage: 'Calculates the magnitude of a dense_vector.',
  }),
  ignoreAsSuggestion: true,
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'input',
          type: 'dense_vector',
          optional: false,
          description: 'dense_vector for which to compute the magnitude',
        },
      ],
      returnType: 'double',
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    ' from colors\n | eval magnitude = v_magnitude(rgb_vector)\n | sort magnitude desc, color asc',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const caseDefinition: FunctionDefinition = {
  type: FunctionDefinitionTypes.SCALAR,
  name: 'case',
  description: i18n.translate('kbn-esql-language.esql.definitions.case', {
    defaultMessage:
      'Accepts pairs of conditions and values. The function returns the value that belongs to the first condition that evaluates to `true`. If the number of arguments is odd, the last argument is the default value which is returned when no condition matches.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'condition',
          type: 'boolean',
        },
        {
          name: 'value',
          type: 'any',
        },
      ],
      minParams: 2,
      returnType: 'unknown',
      isSignatureRepeating: true,
    },
  ],
  locationsAvailable: [
    Location.EVAL,
    Location.ROW,
    Location.SORT,
    Location.WHERE,
    Location.STATS,
    Location.STATS_BY,
    Location.STATS_WHERE,
    Location.STATS_TIMESERIES,
    Location.COMPLETION,
    Location.RERANK,
    Location.JOIN,
  ],
  examples: [
    'from index | eval type = case(languages <= 1, "monolingual", languages <= 2, "bilingual", "polyglot")',
  ],
};
export const scalarFunctionDefinitions = [
  absDefinition,
  acosDefinition,
  asinDefinition,
  atanDefinition,
  atan2Definition,
  bitLengthDefinition,
  byteLengthDefinition,
  cbrtDefinition,
  ceilDefinition,
  chunkDefinition,
  cidrMatchDefinition,
  clampDefinition,
  clampMaxDefinition,
  clampMinDefinition,
  coalesceDefinition,
  concatDefinition,
  containsDefinition,
  copySignDefinition,
  cosDefinition,
  coshDefinition,
  dateDiffDefinition,
  dateExtractDefinition,
  dateFormatDefinition,
  dateParseDefinition,
  dateTruncDefinition,
  dayNameDefinition,
  decayDefinition,
  eDefinition,
  endsWithDefinition,
  expDefinition,
  floorDefinition,
  fromBase64Definition,
  greatestDefinition,
  hashDefinition,
  hypotDefinition,
  ipPrefixDefinition,
  knnDefinition,
  kqlDefinition,
  leastDefinition,
  leftDefinition,
  lengthDefinition,
  locateDefinition,
  logDefinition,
  log10Definition,
  ltrimDefinition,
  matchDefinition,
  matchPhraseDefinition,
  md5Definition,
  monthNameDefinition,
  multiMatchDefinition,
  mvAppendDefinition,
  mvAvgDefinition,
  mvConcatDefinition,
  mvContainsDefinition,
  mvCountDefinition,
  mvDedupeDefinition,
  mvFirstDefinition,
  mvIntersectionDefinition,
  mvLastDefinition,
  mvMaxDefinition,
  mvMedianDefinition,
  mvMedianAbsoluteDeviationDefinition,
  mvMinDefinition,
  mvPercentileDefinition,
  mvPseriesWeightedSumDefinition,
  mvSliceDefinition,
  mvSortDefinition,
  mvSumDefinition,
  mvUnionDefinition,
  mvZipDefinition,
  networkDirectionDefinition,
  nowDefinition,
  piDefinition,
  powDefinition,
  qstrDefinition,
  repeatDefinition,
  replaceDefinition,
  reverseDefinition,
  rightDefinition,
  roundDefinition,
  roundToDefinition,
  rtrimDefinition,
  scalbDefinition,
  scoreDefinition,
  sha1Definition,
  sha256Definition,
  signumDefinition,
  sinDefinition,
  sinhDefinition,
  spaceDefinition,
  splitDefinition,
  sqrtDefinition,
  stContainsDefinition,
  stDisjointDefinition,
  stDistanceDefinition,
  stEnvelopeDefinition,
  stGeohashDefinition,
  stGeohexDefinition,
  stGeotileDefinition,
  stIntersectsDefinition,
  stNpointsDefinition,
  stSimplifyDefinition,
  stWithinDefinition,
  stXDefinition,
  stXmaxDefinition,
  stXminDefinition,
  stYDefinition,
  stYmaxDefinition,
  stYminDefinition,
  startsWithDefinition,
  substringDefinition,
  tanDefinition,
  tanhDefinition,
  tauDefinition,
  textEmbeddingDefinition,
  toAggregateMetricDoubleDefinition,
  toBase64Definition,
  toBooleanDefinition,
  toCartesianpointDefinition,
  toCartesianshapeDefinition,
  toDateNanosDefinition,
  toDateperiodDefinition,
  toDatetimeDefinition,
  toDegreesDefinition,
  toDenseVectorDefinition,
  toDoubleDefinition,
  toGeohashDefinition,
  toGeohexDefinition,
  toGeopointDefinition,
  toGeoshapeDefinition,
  toGeotileDefinition,
  toIntegerDefinition,
  toIpDefinition,
  toLongDefinition,
  toLowerDefinition,
  toRadiansDefinition,
  toStringDefinition,
  toTimedurationDefinition,
  toUnsignedLongDefinition,
  toUpperDefinition,
  toVersionDefinition,
  topSnippetsDefinition,
  trangeDefinition,
  trimDefinition,
  urlDecodeDefinition,
  urlEncodeDefinition,
  urlEncodeComponentDefinition,
  vCosineDefinition,
  vDotProductDefinition,
  vHammingDefinition,
  vL1NormDefinition,
  vL2NormDefinition,
  vMagnitudeDefinition,
  caseDefinition,
];
