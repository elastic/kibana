/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import Path from 'path';
import Fs from 'fs/promises';
import execa, { type ExecaChildProcess } from 'execa';
import type { ToolingLog } from '@kbn/tooling-log';
import { getBuildDir } from './get_build_dir';

async function waitForStdout({
  log,
  proc,
  search,
}: {
  log: ToolingLog;
  proc: ExecaChildProcess;
  search: string | RegExp;
}): Promise<string> {
  return await new Promise<string>((resolve, reject) => {
    function handleData(data: any) {
      const line: string = data.toString();
      log.verbose(line);
      const isMatch = typeof search === 'string' ? line.includes(search) : search.test(line);

      if (isMatch) {
        proc.stdout?.off('data', handleData);
        resolve(line);
      }
    }

    proc.stdout?.on('data', handleData);

    proc.on('exit', (code) =>
      reject(new Error(`Process "${proc.spawnargs.join(' ')}" exited early with code ${code}`))
    );

    proc.on('error', reject);
  });
}

async function startEs({
  cwd,
  log: parentLog,
  args = [],
}: {
  cwd: string;
  log: ToolingLog;
  args?: string[];
}): Promise<{ proc: ExecaChildProcess; port: number }> {
  const log = parentLog.withContext('es-start');

  log.info('Starting Elasticsearch');

  const [file, ...cmdArgs] = ['node', 'scripts/es.js', 'snapshot', ...args];
  log.debug(`Spawning "${file} ${cmdArgs.join(' ')}"`);

  const proc: ExecaChildProcess = execa(file, cmdArgs, { cwd });

  const regex = /AbstractHttpServerTransport.*publish_address .*:(\d+)/;

  const publishAddressOut = await waitForStdout({ proc, log, search: regex });
  log.debug(`Elasticsearch publish address line: ${publishAddressOut.toString().trim()}`);

  const match = publishAddressOut.match(regex);

  const discoveredPort = match ? Number(match[1]) : undefined;

  if (!discoveredPort) {
    throw new Error('Failed to determine Elasticsearch port');
  }

  log.info(`Elasticsearch running on port ${discoveredPort}`);

  await waitForStdout({
    proc,
    log,
    search: 'kbn/es setup complete',
  });
  log.debug('Elasticsearch reported setup complete');

  return { proc, port: discoveredPort };
}

async function startKibana({
  cwd,
  log: parentLog,
  port,
  esPort,
  esUsername = 'kibana_system',
  esPassword = 'changeme',
  args = [],
}: {
  cwd: string;
  log: ToolingLog;
  port: number; // desired kibana server.port
  esPort: number; // actual es http port discovered from startEs
  esUsername?: string;
  esPassword?: string;
  args?: string[];
}): Promise<{ proc: ExecaChildProcess }> {
  // Discover the built distribution directory dynamically so we don't have to
  // know the version/platform ahead of time.

  const log = parentLog.withContext('kbn-start');

  const defaultBuildRoot = Path.join(cwd, 'build', 'default');

  const distDir = await getBuildDir(defaultBuildRoot);

  const binFile = Path.join(distDir, 'bin', 'kibana');

  // Write config file instead of relying on CLI flags so we test the shipped config path
  const configDir = Path.join(distDir, 'config');
  const configPath = Path.join(configDir, 'kibana.yml');
  const yamlLines = [
    '# Auto-generated by benchmarks startKibana()',
    `server.port: ${port}`,
    `elasticsearch.hosts: ["http://localhost:${esPort}"]`,
    `elasticsearch.username: ${esUsername}`,
    `elasticsearch.password: ${esPassword}`,
  ];
  await Fs.writeFile(configPath, yamlLines.join('\n'), 'utf8');
  log.info(
    `Wrote Kibana config at ${configPath} (server.port=${port} esPort=${esPort} esUser=${esUsername} esPass=<redacted>)`
  );

  const [file, ...cmdArgs] = [binFile, '--config', configPath, ...args];

  log.info(`Starting Kibana via --config ./config/kibana.yml (port ${port}, ES port ${esPort})`);

  log.debug(
    `Spawning "${file} ${cmdArgs.join(' ')}" in ${cwd}, NODE_OPTIONS=${
      process.env.NODE_OPTIONS ?? '(not set)'
    }, pid=${process.pid}`
  );

  const proc: ExecaChildProcess = execa(file, cmdArgs, { cwd });

  await waitForStdout({
    proc,
    log,
    search: 'Kibana is now available',
  });
  log.info('Kibana is now available');

  // log rest of output while the process is running
  waitForStdout({
    proc,
    log,
    search: 'this_will_never_happen',
  }).catch((error) => {});

  return { proc };
}

export async function stopGracefully(
  proc: ExecaChildProcess,
  {
    name,
    timeoutMs = 15000,
    log,
  }: {
    name: string;
    timeoutMs?: number;
    log: ToolingLog;
  }
) {
  if (proc.exitCode !== null) {
    return;
  }

  log.debug(`Attempting to gracefully shut down ${name} (pid=${proc.pid})`);

  async function sendAndWait(signal: NodeJS.Signals, timeout: number) {
    log.debug(`Sending ${signal} to ${name} (pid=${proc.pid})`);
    proc.kill(signal);

    const waitForProc = proc.then(
      () => true,
      () => true // ignore error rejection caused by signal
    );

    const exited = await Promise.race([
      waitForProc,
      new Promise<boolean>((r) => setTimeout(() => r(false), timeout)),
    ]);

    return exited;
  }

  // Already exited?
  if (proc.exitCode !== null) return;

  if (await sendAndWait('SIGINT', 30000)) {
    log.debug('Gracefully exited after SIGINT');
    return;
  }

  if (await sendAndWait('SIGTERM', 30000)) {
    log.debug('Gracefully exited after SIGTERM');
    return;
  }

  log.warning(`${name} did not exit within ${timeoutMs}ms after SIGINT/SIGTERM, sending SIGKILL`);

  await sendAndWait('SIGKILL', 1000);
}

export { startEs, startKibana };
