/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/**
 * Datadog Connector
 *
 * This connector enables:
 * - Receiving alerts from Datadog via webhook
 * - Performing actions on Datadog monitors (mute, unmute, acknowledge)
 *
 * Authentication:
 * - Outbound (to Datadog API): API Key + Application Key
 * - Inbound (webhook from Datadog): Webhook token generated by Kibana
 */

import { z } from '@kbn/zod/v4';
import { i18n } from '@kbn/i18n';
import type { ConnectorSpec } from '../../connector_spec';

// Datadog site options
const DATADOG_SITES = [
  'datadoghq.com', // US1
  'us3.datadoghq.com', // US3
  'us5.datadoghq.com', // US5
  'datadoghq.eu', // EU1
  'ap1.datadoghq.com', // AP1
  'ddog-gov.com', // US1-FED
] as const;

export const DatadogConnector: ConnectorSpec = {
  metadata: {
    id: '.datadog',
    displayName: 'Datadog',
    description: i18n.translate('connectorSpecs.datadog.metadata.description', {
      defaultMessage: 'Receive alerts from Datadog and perform actions on monitors',
    }),
    minimumLicense: 'gold',
    supportedFeatureIds: ['alerting', 'workflows'],
  },

  // Authentication for outbound requests to Datadog API
  // Datadog requires both API Key and Application Key in headers
  auth: {
    types: [{ type: 'api_key_header', defaults: { headerField: 'DD-API-KEY' } }],
  },

  // Additional configuration schema
  schema: z.object({
    // Datadog site/region
    site: z
      .enum(DATADOG_SITES)
      .default('datadoghq.com')
      .meta({
        label: i18n.translate('connectorSpecs.datadog.schema.site.label', {
          defaultMessage: 'Datadog Site',
        }),
      })
      .describe(
        i18n.translate('connectorSpecs.datadog.schema.site', {
          defaultMessage: 'Datadog Site',
        })
      ),
    // Application key (required for most API operations)
    appKey: z
      .string()
      .meta({
        sensitive: true,
        widget: 'password',
        label: i18n.translate('connectorSpecs.datadog.schema.appKey.label', {
          defaultMessage: 'Application Key',
        }),
        placeholder: 'Enter your Datadog Application Key',
      })
      .describe(
        i18n.translate('connectorSpecs.datadog.schema.appKey', {
          defaultMessage: 'Application Key',
        })
      ),
  }),

  actions: {
    /**
     * Mute a Datadog monitor
     * https://docs.datadoghq.com/api/latest/monitors/#mute-a-monitor
     */
    muteMonitor: {
      isTool: true,
      input: z.object({
        monitorId: z.number().describe('The ID of the monitor to mute'),
        scope: z.string().optional().describe('The scope to mute (e.g., "host:myhost")'),
        end: z.number().optional().describe('POSIX timestamp for when the mute should end'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as { monitorId: number; scope?: string; end?: number };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;

        const response = await ctx.client.post(
          `https://api.${site}/api/v1/monitor/${typedInput.monitorId}/mute`,
          {
            ...(typedInput.scope && { scope: typedInput.scope }),
            ...(typedInput.end && { end: typedInput.end }),
          },
          {
            headers: {
              'DD-APPLICATION-KEY': appKey,
            },
          }
        );

        return {
          success: true,
          monitorId: typedInput.monitorId,
          muted: true,
          data: response.data,
        };
      },
    },

    /**
     * Unmute a Datadog monitor
     * https://docs.datadoghq.com/api/latest/monitors/#unmute-a-monitor
     */
    unmuteMonitor: {
      isTool: true,
      input: z.object({
        monitorId: z.number().describe('The ID of the monitor to unmute'),
        scope: z.string().optional().describe('The scope to unmute'),
        allScopes: z.boolean().optional().describe('Whether to unmute all scopes'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as { monitorId: number; scope?: string; allScopes?: boolean };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;

        const response = await ctx.client.post(
          `https://api.${site}/api/v1/monitor/${typedInput.monitorId}/unmute`,
          {
            ...(typedInput.scope && { scope: typedInput.scope }),
            ...(typedInput.allScopes && { all_scopes: typedInput.allScopes }),
          },
          {
            headers: {
              'DD-APPLICATION-KEY': appKey,
            },
          }
        );

        return {
          success: true,
          monitorId: typedInput.monitorId,
          muted: false,
          data: response.data,
        };
      },
    },

    /**
     * Get monitor details
     * https://docs.datadoghq.com/api/latest/monitors/#get-a-monitor-s-details
     */
    getMonitor: {
      isTool: true,
      input: z.object({
        monitorId: z.number().describe('The ID of the monitor to retrieve'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as { monitorId: number };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;

        const response = await ctx.client.get(
          `https://api.${site}/api/v1/monitor/${typedInput.monitorId}`,
          {
            headers: {
              'DD-APPLICATION-KEY': appKey,
            },
          }
        );

        return {
          id: response.data.id,
          name: response.data.name,
          type: response.data.type,
          query: response.data.query,
          message: response.data.message,
          tags: response.data.tags,
          overallState: response.data.overall_state,
          options: response.data.options,
        };
      },
    },

    /**
     * List monitors
     * https://docs.datadoghq.com/api/latest/monitors/#get-all-monitor-details
     */
    listMonitors: {
      isTool: true,
      input: z.object({
        tags: z.string().optional().describe('Comma-separated list of tags to filter by'),
        monitorTags: z.string().optional().describe('Comma-separated list of monitor tags'),
        name: z.string().optional().describe('Filter by monitor name'),
        page: z.number().optional().describe('Page number (0-indexed)'),
        pageSize: z.number().optional().describe('Number of monitors per page (max 1000)'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as {
          tags?: string;
          monitorTags?: string;
          name?: string;
          page?: number;
          pageSize?: number;
        };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;

        const params: Record<string, unknown> = {};
        if (typedInput.tags) params.tags = typedInput.tags;
        if (typedInput.monitorTags) params.monitor_tags = typedInput.monitorTags;
        if (typedInput.name) params.name = typedInput.name;
        if (typedInput.page !== undefined) params.page = typedInput.page;
        if (typedInput.pageSize !== undefined) params.page_size = typedInput.pageSize;

        const response = await ctx.client.get(`https://api.${site}/api/v1/monitor`, {
          params,
          headers: {
            'DD-APPLICATION-KEY': appKey,
          },
        });

        return {
          monitors: response.data.map((m: Record<string, unknown>) => ({
            id: m.id,
            name: m.name,
            type: m.type,
            message: m.message,
            overallState: m.overall_state,
            tags: m.tags,
          })),
          total: response.data.length,
        };
      },
    },

    /**
     * List triggered monitors (in Alert or Warn state)
     * Filters monitors by their overall_state to return only those that are currently triggered
     * https://docs.datadoghq.com/api/latest/monitors/#get-all-monitor-details
     */
    listTriggeredMonitors: {
      isTool: true,
      input: z.object({
        includeWarn: z
          .union([z.boolean(), z.string().transform((val) => val === 'true' || val === '1')])
          .optional()
          .default(true)
          .describe('Include monitors in Warn state (default: true)'),
        includeNoData: z
          .union([z.boolean(), z.string().transform((val) => val === 'true' || val === '1')])
          .optional()
          .default(false)
          .describe('Include monitors in No Data state (default: false)'),
        tags: z.string().optional().describe('Comma-separated list of tags to filter by'),
        monitorTags: z.string().optional().describe('Comma-separated list of monitor tags'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as {
          includeWarn?: boolean;
          includeNoData?: boolean;
          tags?: string;
          monitorTags?: string;
        };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;
        const includeWarn = typedInput.includeWarn !== false;
        const includeNoData = typedInput.includeNoData === true;

        const params: Record<string, unknown> = { page_size: 1000 };
        if (typedInput.tags) params.tags = typedInput.tags;
        if (typedInput.monitorTags) params.monitor_tags = typedInput.monitorTags;

        const response = await ctx.client.get(`https://api.${site}/api/v1/monitor`, {
          params,
          headers: {
            'DD-APPLICATION-KEY': appKey,
          },
        });

        // Filter to only triggered monitors
        const triggeredStates = ['Alert'];
        if (includeWarn) triggeredStates.push('Warn');
        if (includeNoData) triggeredStates.push('No Data');

        const triggeredMonitors = response.data
          .filter((m: Record<string, unknown>) => triggeredStates.includes(m.overall_state as string))
          .map((m: Record<string, unknown>) => ({
            id: m.id,
            name: m.name,
            type: m.type,
            query: m.query,
            message: m.message,
            overallState: m.overall_state,
            tags: m.tags,
            created: m.created,
            modified: m.modified,
            priority: m.priority,
          }));

        return {
          monitors: triggeredMonitors,
          total: triggeredMonitors.length,
          totalChecked: response.data.length,
          states: triggeredStates,
        };
      },
    },

    /**
     * Instrument a single monitor to send alerts to Kibana webhook
     * Adds @webhook-{webhookName} to the monitor's message if not already present
     */
    instrumentMonitor: {
      isTool: true,
      input: z.object({
        monitorId: z.coerce.number().describe('The ID of the monitor to instrument'),
        webhookName: z
          .string()
          .optional()
          .describe('Name of the webhook (default: kibana-alerts-webhook)'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as { monitorId: number; webhookName?: string };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;
        const webhookName = typedInput.webhookName || 'kibana-alerts-webhook';
        const webhookMention = `@webhook-${webhookName}`;

        // First, get the current monitor details
        const getResponse = await ctx.client.get(
          `https://api.${site}/api/v1/monitor/${typedInput.monitorId}`,
          {
            headers: {
              'DD-APPLICATION-KEY': appKey,
            },
          }
        );

        const monitor = getResponse.data;
        const monitorType = monitor.type as string;
        const currentMessage = monitor.message || '';

        // Synthetics monitors cannot be modified via the standard monitor API
        // They need to be configured through the Synthetics UI
        const unsupportedTypes = ['synthetics alert'];
        if (unsupportedTypes.includes(monitorType)) {
          return {
            success: false,
            monitorId: typedInput.monitorId,
            monitorName: monitor.name,
            skipped: true,
            reason: `Monitor type "${monitorType}" cannot be instrumented via API. Please configure webhook notifications in the Datadog Synthetics UI.`,
            message: `Skipped monitor "${monitor.name}" - ${monitorType} monitors must be configured in Datadog UI`,
          };
        }

        // Check if webhook is already in the message
        if (currentMessage.includes(webhookMention)) {
          return {
            success: true,
            monitorId: typedInput.monitorId,
            monitorName: monitor.name,
            alreadyInstrumented: true,
            message: `Monitor "${monitor.name}" already has ${webhookMention} in its notification message`,
          };
        }

        // Add webhook mention to the message
        const newMessage = currentMessage ? `${currentMessage}\n${webhookMention}` : webhookMention;

        // Update the monitor with the new message
        try {
          const updateResponse = await ctx.client.put(
            `https://api.${site}/api/v1/monitor/${typedInput.monitorId}`,
            {
              message: newMessage,
            },
            {
              headers: {
                'DD-APPLICATION-KEY': appKey,
              },
            }
          );

          return {
            success: true,
            monitorId: typedInput.monitorId,
            monitorName: monitor.name,
            instrumented: true,
            message: `Monitor "${monitor.name}" instrumented successfully. Added ${webhookMention} to notification message.`,
            data: updateResponse.data,
          };
        } catch (error: unknown) {
          const err = error as { response?: { status?: number; data?: unknown } };
          if (err.response?.status === 400) {
            return {
              success: false,
              monitorId: typedInput.monitorId,
              monitorName: monitor.name,
              skipped: true,
              reason: `Monitor type "${monitorType}" returned 400 error. This monitor type may not support message updates via API.`,
              message: `Skipped monitor "${monitor.name}" - cannot update via API`,
            };
          }
          throw error;
        }
      },
    },

    /**
     * Instrument all monitors to send alerts to Kibana webhook
     * Adds @webhook-{webhookName} to each monitor's message if not already present
     */
    instrumentAllMonitors: {
      isTool: true,
      input: z.object({
        webhookName: z
          .string()
          .optional()
          .describe('Name of the webhook (default: kibana-alerts-webhook)'),
        tags: z.string().optional().describe('Only instrument monitors with these tags (comma-separated)'),
        dryRun: z
          .boolean()
          .optional()
          .describe('If true, only report what would be changed without making changes'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as { webhookName?: string; tags?: string; dryRun?: boolean };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;
        const webhookName = typedInput.webhookName || 'kibana-alerts-webhook';
        const webhookMention = `@webhook-${webhookName}`;
        const isDryRun = typedInput.dryRun || false;

        // Get all monitors
        const params: Record<string, unknown> = { page_size: 1000 };
        if (typedInput.tags) params.tags = typedInput.tags;

        const listResponse = await ctx.client.get(`https://api.${site}/api/v1/monitor`, {
          params,
          headers: {
            'DD-APPLICATION-KEY': appKey,
          },
        });

        const monitors = listResponse.data as Array<{
          id: number;
          name: string;
          message: string;
          type: string;
        }>;

        const results = {
          total: monitors.length,
          alreadyInstrumented: [] as Array<{ id: number; name: string }>,
          instrumented: [] as Array<{ id: number; name: string }>,
          failed: [] as Array<{ id: number; name: string; error: string }>,
        };

        for (const monitor of monitors) {
          const currentMessage = monitor.message || '';

          // Check if already instrumented
          if (currentMessage.includes(webhookMention)) {
            results.alreadyInstrumented.push({ id: monitor.id, name: monitor.name });
            continue;
          }

          if (isDryRun) {
            results.instrumented.push({ id: monitor.id, name: monitor.name });
            continue;
          }

          // Add webhook mention to the message
          const newMessage = currentMessage
            ? `${currentMessage}\n${webhookMention}`
            : webhookMention;

          try {
            await ctx.client.put(
              `https://api.${site}/api/v1/monitor/${monitor.id}`,
              {
                message: newMessage,
              },
              {
                headers: {
                  'DD-APPLICATION-KEY': appKey,
                },
              }
            );
            results.instrumented.push({ id: monitor.id, name: monitor.name });
          } catch (error: unknown) {
            const err = error as { message?: string };
            results.failed.push({
              id: monitor.id,
              name: monitor.name,
              error: err.message || 'Unknown error',
            });
          }
        }

        const summary = isDryRun
          ? `DRY RUN: Would instrument ${results.instrumented.length} monitors`
          : `Instrumented ${results.instrumented.length} monitors`;

        return {
          success: true,
          dryRun: isDryRun,
          webhookName,
          summary,
          results,
          message: `${summary}. ${results.alreadyInstrumented.length} already had ${webhookMention}. ${results.failed.length} failed.`,
        };
      },
    },

    /**
     * Validate monitor definition
     * https://docs.datadoghq.com/api/latest/monitors/#validate-a-monitor
     */
    validateMonitor: {
      isTool: false,
      input: z.object({
        type: z.string().describe('The type of monitor'),
        query: z.string().describe('The monitor query'),
        name: z.string().optional().describe('The name of the monitor'),
        message: z.string().optional().describe('The notification message'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as {
          type: string;
          query: string;
          name?: string;
          message?: string;
        };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;

        const response = await ctx.client.post(
          `https://api.${site}/api/v1/monitor/validate`,
          {
            type: typedInput.type,
            query: typedInput.query,
            ...(typedInput.name && { name: typedInput.name }),
            ...(typedInput.message && { message: typedInput.message }),
          },
          {
            headers: {
              'DD-APPLICATION-KEY': appKey,
            },
          }
        );

        return {
          valid: true,
          data: response.data,
        };
      },
    },

    /**
     * Get webhook integration details from Datadog
     * https://docs.datadoghq.com/api/latest/webhooks-integration/#get-a-webhooks-integration
     */
    getWebhook: {
      isTool: false,
      input: z.object({
        webhookName: z
          .string()
          .optional()
          .describe('Name of the webhook to get (default: kibana-alerts-webhook)'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as { webhookName?: string };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;
        const webhookName = typedInput.webhookName || 'kibana-alerts-webhook';

        try {
          const response = await ctx.client.get(
            `https://api.${site}/api/v1/integration/webhooks/configuration/webhooks/${webhookName}`,
            {
              headers: {
                'DD-APPLICATION-KEY': appKey,
              },
            }
          );

          return {
            exists: true,
            name: response.data.name,
            url: response.data.url,
            payload: response.data.payload,
            encodeAs: response.data.encode_as,
          };
        } catch (error: unknown) {
          const err = error as { response?: { status?: number } };
          if (err.response?.status === 404) {
            return {
              exists: false,
              name: webhookName,
            };
          }
          throw error;
        }
      },
    },

    /**
     * Setup webhook integration in Datadog
     * Creates a webhook that sends alerts to Kibana
     * https://docs.datadoghq.com/api/latest/webhooks-integration/#create-a-webhooks-integration
     */
    setupWebhook: {
      isTool: false,
      input: z.object({
        webhookName: z
          .string()
          .optional()
          .describe('Custom name for the webhook (default: kibana-alerts-webhook)'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as {
          webhookName?: string;
        };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;

        // Get kibanaUrl from workflow context, connectorId from connector context
        const kibanaUrl = ctx.kibanaUrl || 'http://localhost:5601';
        const connectorId = ctx.connectorId || 'unknown';
        // Hardcoded webhook token for PoC - will be replaced with proper auth later
        const webhookToken = 'kibana-datadog-webhook-poc-token';

        const webhookName = typedInput.webhookName || 'kibana-alerts-webhook';
        const webhookUrl = `${kibanaUrl}/api/observability/events/webhook?connector_id=${connectorId}&webhook_token=${webhookToken}`;

        // Datadog webhook payload template - sends alert data in our expected format
        const payloadTemplate = JSON.stringify({
          title: '$EVENT_TITLE',
          message: '$EVENT_MSG',
          severity: '$ALERT_PRIORITY',
          source: 'datadog',
          status: '$ALERT_TRANSITION',
          monitor_id: '$ALERT_ID',
          raw_payload: {
            alertId: '$ALERT_ID',
            alertTitle: '$ALERT_TITLE',
            alertType: '$ALERT_TYPE',
            alertQuery: '$ALERT_QUERY',
            alertScope: '$ALERT_SCOPE',
            alertStatus: '$ALERT_STATUS',
            alertTransition: '$ALERT_TRANSITION',
            alertMetric: '$ALERT_METRIC',
            alertPriority: '$ALERT_PRIORITY',
            alertCycleKey: '$ALERT_CYCLE_KEY',
            date: '$DATE',
            eventTitle: '$EVENT_TITLE',
            eventMsg: '$EVENT_MSG',
            hostname: '$HOSTNAME',
            orgId: '$ORG_ID',
            orgName: '$ORG_NAME',
            tags: '$TAGS',
            link: '$LINK',
            lastUpdated: '$LAST_UPDATED',
            snapshotUrl: '$SNAPSHOT',
          },
        });

        // First, check if webhook already exists
        try {
          const existingWebhook = await ctx.client.get(
            `https://api.${site}/api/v1/integration/webhooks/configuration/webhooks/${webhookName}`,
            {
              headers: {
                'DD-APPLICATION-KEY': appKey,
              },
            }
          );

          if (existingWebhook.data) {
            // Update existing webhook
            const response = await ctx.client.put(
              `https://api.${site}/api/v1/integration/webhooks/configuration/webhooks/${webhookName}`,
              {
                name: webhookName,
                url: webhookUrl,
                payload: payloadTemplate,
                encode_as: 'json',
              },
              {
                headers: {
                  'DD-APPLICATION-KEY': appKey,
                },
              }
            );

            return {
              success: true,
              webhookName,
              webhookUrl,
              updated: true,
              message: `Webhook "${webhookName}" updated successfully`,
              data: response.data,
            };
          }
        } catch {
          // Webhook doesn't exist, create it
        }

        // Create new webhook
        const response = await ctx.client.post(
          `https://api.${site}/api/v1/integration/webhooks/configuration/webhooks`,
          {
            name: webhookName,
            url: webhookUrl,
            payload: payloadTemplate,
            encode_as: 'json',
          },
          {
            headers: {
              'DD-APPLICATION-KEY': appKey,
            },
          }
        );

        return {
          success: true,
          webhookName,
          webhookUrl,
          created: true,
          message: `Webhook "${webhookName}" created successfully. Add @webhook-${webhookName} to your monitor notifications to send alerts to Kibana.`,
          data: response.data,
        };
      },
    },

    /**
     * Delete webhook integration from Datadog
     * https://docs.datadoghq.com/api/latest/webhooks-integration/#delete-a-webhooks-integration
     */
    deleteWebhook: {
      isTool: false,
      input: z.object({
        webhookName: z
          .string()
          .optional()
          .describe('Name of the webhook to delete (default: kibana-alerts-webhook)'),
      }),
      handler: async (ctx, input) => {
        const typedInput = input as { webhookName?: string };
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        const appKey = ctx.config?.appKey as string;

        const webhookName = typedInput.webhookName || 'kibana-alerts-webhook';

        await ctx.client.delete(
          `https://api.${site}/api/v1/integration/webhooks/configuration/webhooks/${webhookName}`,
          {
            headers: {
              'DD-APPLICATION-KEY': appKey,
            },
          }
        );

        return {
          success: true,
          webhookName,
          deleted: true,
          message: `Webhook "${webhookName}" deleted successfully`,
        };
      },
    },

    /**
     * Test connection to Datadog API
     * This action is used by the connector test UI
     */
    testConnection: {
      isTool: false,
      input: z.object({}),
      handler: async (ctx) => {
        const site = (ctx.config?.site as string) || 'datadoghq.com';
        // appKey is in config (from schema), not secrets (from auth)
        const appKey = ctx.config?.appKey as string;

        // Debug logging to understand what secrets/config we have
        ctx.log.info(`[Datadog] Testing connection to ${site}`);
        ctx.log.info(`[Datadog] Config keys: ${JSON.stringify(Object.keys(ctx.config || {}))}`);
        ctx.log.info(`[Datadog] Secrets keys: ${JSON.stringify(Object.keys(ctx.secrets || {}))}`);
        ctx.log.info(`[Datadog] App key present: ${!!appKey}, length: ${appKey?.length || 0}`);

        try {
          // Step 1: Validate API key
          ctx.log.debug('[Datadog] Validating API key...');
          const validateResponse = await ctx.client.get(`https://api.${site}/api/v1/validate`, {
            headers: {
              'DD-APPLICATION-KEY': appKey,
            },
          });

          if (!validateResponse.data.valid) {
            return {
              ok: false,
              message: 'Invalid API key',
            };
          }
          ctx.log.debug('[Datadog] API key is valid');

          // Step 2: Check monitors_read scope by listing monitors
          ctx.log.debug('[Datadog] Checking monitors_read scope...');
          try {
            await ctx.client.get(`https://api.${site}/api/v1/monitor`, {
              params: { page_size: 1 },
              headers: {
                'DD-APPLICATION-KEY': appKey,
              },
            });
            ctx.log.debug('[Datadog] monitors_read scope OK');
          } catch (monitorError: unknown) {
            const err = monitorError as { response?: { status?: number } };
            if (err.response?.status === 403) {
              return {
                ok: false,
                message:
                  'API key is valid but missing monitors_read permission. Please ensure your Application Key has the required scopes.',
              };
            }
            throw monitorError;
          }

          // Step 3: Check webhooks scope by listing webhooks
          ctx.log.debug('[Datadog] Checking webhooks scope...');
          let hasWebhookScope = true;
          try {
            await ctx.client.get(
              `https://api.${site}/api/v1/integration/webhooks/configuration/webhooks`,
              {
                headers: {
                  'DD-APPLICATION-KEY': appKey,
                },
              }
            );
            ctx.log.debug('[Datadog] webhooks scope OK');
          } catch (webhookError: unknown) {
            const err = webhookError as { response?: { status?: number } };
            if (err.response?.status === 403) {
              hasWebhookScope = false;
              ctx.log.debug('[Datadog] webhooks scope NOT available');
            }
          }

          const successMessage = hasWebhookScope
            ? 'Successfully connected to Datadog API. All required permissions are available.'
            : 'Successfully connected to Datadog API. Note: Webhook integration permission is missing - you will need to manually configure the webhook in Datadog.';

          ctx.log.info(`[Datadog] Connection test successful: ${successMessage}`);

          return {
            ok: true,
            message: successMessage,
            details: {
              apiKeyValid: true,
              monitorsReadScope: true,
              webhooksScope: hasWebhookScope,
            },
          };
        } catch (error: unknown) {
          const err = error as { response?: { status?: number; data?: { errors?: string[] } } };
          let errorMessage = error instanceof Error ? error.message : 'Unknown error';

          if (err.response?.status === 401) {
            errorMessage = 'Invalid API key';
          } else if (err.response?.status === 403) {
            errorMessage = 'Invalid Application key or insufficient permissions';
          } else if (err.response?.data?.errors) {
            errorMessage = err.response.data.errors.join(', ');
          }

          ctx.log.error(`[Datadog] Connection test failed: ${errorMessage}`);

          return {
            ok: false,
            message: `Failed to connect to Datadog API: ${errorMessage}`,
          };
        }
      },
    },
  },

  test: {
    description: i18n.translate('connectorSpecs.datadog.test.description', {
      defaultMessage:
        'Verifies connection to Datadog API by validating credentials and checking permissions',
    }),
    handler: async (ctx) => {
      const site = (ctx.config?.site as string) || 'datadoghq.com';
      const appKey = ctx.config?.appKey as string;

      try {
        // Step 1: Validate API key
        const validateResponse = await ctx.client.get(`https://api.${site}/api/v1/validate`, {
          headers: {
            'DD-APPLICATION-KEY': appKey,
          },
        });

        if (!validateResponse.data.valid) {
          return {
            ok: false,
            message: i18n.translate('connectorSpecs.datadog.test.invalidApiKey', {
              defaultMessage: 'Invalid API key',
            }),
          };
        }

        // Step 2: Check monitors_read scope by listing monitors
        try {
          await ctx.client.get(`https://api.${site}/api/v1/monitor`, {
            params: { page_size: 1 },
            headers: {
              'DD-APPLICATION-KEY': appKey,
            },
          });
        } catch (monitorError: unknown) {
          const err = monitorError as { response?: { status?: number } };
          if (err.response?.status === 403) {
            return {
              ok: false,
              message: i18n.translate('connectorSpecs.datadog.test.noMonitorReadScope', {
                defaultMessage:
                  'API key is valid but missing monitors_read permission. Please ensure your Application Key has the required scopes.',
              }),
            };
          }
          throw monitorError;
        }

        // Step 3: Check webhooks scope by listing webhooks
        let hasWebhookScope = true;
        try {
          await ctx.client.get(
            `https://api.${site}/api/v1/integration/webhooks/configuration/webhooks`,
            {
              headers: {
                'DD-APPLICATION-KEY': appKey,
              },
            }
          );
        } catch (webhookError: unknown) {
          const err = webhookError as { response?: { status?: number } };
          if (err.response?.status === 403) {
            hasWebhookScope = false;
          }
        }

        const successMessage = hasWebhookScope
          ? i18n.translate('connectorSpecs.datadog.test.successFull', {
              defaultMessage:
                'Successfully connected to Datadog API. All required permissions are available.',
            })
          : i18n.translate('connectorSpecs.datadog.test.successPartial', {
              defaultMessage:
                'Successfully connected to Datadog API. Note: Webhook integration permission is missing - you will need to manually configure the webhook in Datadog.',
            });

        return {
          ok: true,
          message: successMessage,
          details: {
            apiKeyValid: true,
            monitorsReadScope: true,
            webhooksScope: hasWebhookScope,
          },
        };
      } catch (error: unknown) {
        const err = error as { response?: { status?: number; data?: { errors?: string[] } } };
        let errorMessage = error instanceof Error ? error.message : 'Unknown error';

        if (err.response?.status === 401) {
          errorMessage = 'Invalid API key';
        } else if (err.response?.status === 403) {
          errorMessage = 'Invalid Application key or insufficient permissions';
        } else if (err.response?.data?.errors) {
          errorMessage = err.response.data.errors.join(', ');
        }

        return {
          ok: false,
          message: i18n.translate('connectorSpecs.datadog.test.failure', {
            defaultMessage: 'Failed to connect to Datadog API: {error}',
            values: { error: errorMessage },
          }),
        };
      }
    },
  },

  // Retry policy for Datadog API
  policies: {
    retry: {
      retryOnStatusCodes: [429, 500, 502, 503, 504],
      maxRetries: 3,
      backoffStrategy: 'exponential',
      initialDelay: 1000,
    },
    rateLimit: {
      strategy: 'header',
      remainingHeader: 'X-RateLimit-Remaining',
      resetHeader: 'X-RateLimit-Reset',
    },
  },
};

