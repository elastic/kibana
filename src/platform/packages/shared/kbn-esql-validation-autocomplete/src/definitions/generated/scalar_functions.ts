/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/**
 * __AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.__
 *
 * @note This file is generated by the `generate_function_definitions.ts`
 * script. Do not edit it manually.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

import { i18n } from '@kbn/i18n';
import type { ESQLFunction } from '@kbn/esql-ast';
import type { FunctionDefinition } from '../types';
import { isLiteralItem } from '../../shared/helpers';

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const absDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'abs',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.abs', {
    defaultMessage: 'Returns the absolute value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW number = -1.0 \n| EVAL abs_number = ABS(number)',
    'FROM employees\n| KEEP first_name, last_name, height\n| EVAL abs_height = ABS(0.0 - height)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const acosDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'acos',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.acos', {
    defaultMessage: 'Returns the arccosine of `n` as an angle, expressed in radians.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=.9\n| EVAL acos=ACOS(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const asinDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'asin',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.asin', {
    defaultMessage:
      'Returns the arcsine of the input\nnumeric expression as an angle, expressed in radians.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=.9\n| EVAL asin=ASIN(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const atanDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'atan',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.atan', {
    defaultMessage:
      'Returns the arctangent of the input\nnumeric expression as an angle, expressed in radians.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=12.9\n| EVAL atan=ATAN(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const atan2Definition: FunctionDefinition = {
  type: 'scalar',
  name: 'atan2',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.atan2', {
    defaultMessage:
      'The angle between the positive x-axis and the ray from the\norigin to the point (x , y) in the Cartesian plane, expressed in radians.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'double',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'double',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'double',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'double',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'integer',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'integer',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'integer',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'integer',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'long',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'long',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'long',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'long',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'y_coordinate',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'x_coordinate',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW y=12.9, x=.6\n| EVAL atan2=ATAN2(y, x)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const bitLengthDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'bit_length',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.bit_length', {
    defaultMessage: 'Returns the bit length of a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airports\n| WHERE country == "India"\n| KEEP city\n| EVAL fn_length = LENGTH(city), fn_bit_length = BIT_LENGTH(city)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const byteLengthDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'byte_length',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.byte_length', {
    defaultMessage: 'Returns the byte length of a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airports\n| WHERE country == "India"\n| KEEP city\n| EVAL fn_length = LENGTH(city), fn_byte_length = BYTE_LENGTH(city)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const cbrtDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'cbrt',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.cbrt', {
    defaultMessage:
      'Returns the cube root of a number. The input can be any numeric value, the return value is always a double.\nCube roots of infinities are null.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW d = 1000.0\n| EVAL c = cbrt(d)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const ceilDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'ceil',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.ceil', {
    defaultMessage: 'Round a number up to the nearest integer.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=1.8\n| EVAL a=CEIL(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const cidrMatchDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'cidr_match',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.cidr_match', {
    defaultMessage:
      'Returns true if the provided IP is contained in one of the provided CIDR blocks.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'ip',
          type: 'ip',
          optional: false,
        },
        {
          name: 'blockX',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'ip',
          type: 'ip',
          optional: false,
        },
        {
          name: 'blockX',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'boolean',
      minParams: 2,
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM hosts \n| WHERE CIDR_MATCH(ip1, "127.0.0.2/32", "127.0.0.3/32") \n| KEEP card, host, ip0, ip1',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const coalesceDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'coalesce',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.coalesce', {
    defaultMessage:
      'Returns the first of its arguments that is not null. If all arguments are null, it returns `null`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
        },
        {
          name: 'rest',
          type: 'boolean',
          optional: true,
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'rest',
          type: 'cartesian_point',
          optional: true,
        },
      ],
      returnType: 'cartesian_point',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'rest',
          type: 'cartesian_shape',
          optional: true,
        },
      ],
      returnType: 'cartesian_shape',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date',
          optional: false,
        },
        {
          name: 'rest',
          type: 'date',
          optional: true,
        },
      ],
      returnType: 'date',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date_nanos',
          optional: false,
        },
        {
          name: 'rest',
          type: 'date_nanos',
          optional: true,
        },
      ],
      returnType: 'date_nanos',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'rest',
          type: 'geo_point',
          optional: true,
        },
      ],
      returnType: 'geo_point',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'rest',
          type: 'geo_shape',
          optional: true,
        },
      ],
      returnType: 'geo_shape',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
        },
        {
          name: 'rest',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'ip',
          optional: false,
        },
        {
          name: 'rest',
          type: 'ip',
          optional: true,
        },
      ],
      returnType: 'ip',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'rest',
          type: 'keyword',
          optional: true,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
        },
        {
          name: 'rest',
          type: 'long',
          optional: true,
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
        },
        {
          name: 'rest',
          type: 'text',
          optional: true,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'version',
          optional: false,
        },
        {
          name: 'rest',
          type: 'version',
          optional: true,
        },
      ],
      returnType: 'version',
      minParams: 1,
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=null, b="b"\n| EVAL COALESCE(a, b)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const concatDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'concat',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.concat', {
    defaultMessage: 'Concatenates two or more strings.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
      minParams: 2,
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
      minParams: 2,
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM employees\n| KEEP first_name, last_name\n| EVAL fullname = CONCAT(first_name, " ", last_name)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const cosDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'cos',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.cos', {
    defaultMessage: 'Returns the cosine of an angle.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'angle',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=1.8 \n| EVAL cos=COS(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const coshDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'cosh',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.cosh', {
    defaultMessage: 'Returns the hyperbolic cosine of a number.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=1.8 \n| EVAL cosh=COSH(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dateDiffDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'date_diff',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.date_diff', {
    defaultMessage:
      'Subtracts the `startTimestamp` from the `endTimestamp` and returns the difference in multiples of `unit`.\nIf `startTimestamp` is later than the `endTimestamp`, negative values are returned.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'unit',
          type: 'keyword',
          optional: false,
          acceptedValues: [
            'year',
            'years',
            'yy',
            'yyyy',
            'quarter',
            'quarters',
            'qq',
            'q',
            'month',
            'months',
            'mm',
            'm',
            'dayofyear',
            'dy',
            'y',
            'day',
            'days',
            'dd',
            'd',
            'week',
            'weeks',
            'wk',
            'ww',
            'weekday',
            'weekdays',
            'dw',
            'hour',
            'hours',
            'hh',
            'minute',
            'minutes',
            'mi',
            'n',
            'second',
            'seconds',
            'ss',
            's',
            'millisecond',
            'milliseconds',
            'ms',
            'microsecond',
            'microseconds',
            'mcs',
            'nanosecond',
            'nanoseconds',
            'ns',
          ],
          literalSuggestions: [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
            'microsecond',
            'nanosecond',
          ],
        },
        {
          name: 'startTimestamp',
          type: 'date',
          optional: false,
        },
        {
          name: 'endTimestamp',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'startTimestamp',
          type: 'date',
          optional: false,
        },
        {
          name: 'endTimestamp',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'startTimestamp',
          type: 'date_nanos',
          optional: false,
        },
        {
          name: 'endTimestamp',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'startTimestamp',
          type: 'date_nanos',
          optional: false,
        },
        {
          name: 'endTimestamp',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'text',
          optional: false,
        },
        {
          name: 'startTimestamp',
          type: 'date',
          optional: false,
        },
        {
          name: 'endTimestamp',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'text',
          optional: false,
        },
        {
          name: 'startTimestamp',
          type: 'date',
          optional: false,
        },
        {
          name: 'endTimestamp',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'text',
          optional: false,
        },
        {
          name: 'startTimestamp',
          type: 'date_nanos',
          optional: false,
        },
        {
          name: 'endTimestamp',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'unit',
          type: 'text',
          optional: false,
        },
        {
          name: 'startTimestamp',
          type: 'date_nanos',
          optional: false,
        },
        {
          name: 'endTimestamp',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW date1 = TO_DATETIME("2023-12-02T11:00:00.000Z"), date2 = TO_DATETIME("2023-12-02T11:00:00.001Z")\n| EVAL dd_ms = DATE_DIFF("microseconds", date1, date2)',
    'ROW end_23=TO_DATETIME("2023-12-31T23:59:59.999Z"),\n  start_24=TO_DATETIME("2024-01-01T00:00:00.000Z"),\n    end_24=TO_DATETIME("2024-12-31T23:59:59.999")\n| EVAL end23_to_start24=DATE_DIFF("year", end_23, start_24)\n| EVAL end23_to_end24=DATE_DIFF("year", end_23, end_24)\n| EVAL start_to_end_24=DATE_DIFF("year", start_24, end_24)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dateExtractDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'date_extract',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.date_extract', {
    defaultMessage: 'Extracts parts of a date, like year, month, day, hour.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'datePart',
          type: 'keyword',
          optional: false,
          acceptedValues: [
            'ALIGNED_DAY_OF_WEEK_IN_MONTH',
            'ALIGNED_DAY_OF_WEEK_IN_YEAR',
            'ALIGNED_WEEK_OF_MONTH',
            'ALIGNED_WEEK_OF_YEAR',
            'AMPM_OF_DAY',
            'CLOCK_HOUR_OF_AMPM',
            'CLOCK_HOUR_OF_DAY',
            'DAY_OF_MONTH',
            'DAY_OF_WEEK',
            'DAY_OF_YEAR',
            'EPOCH_DAY',
            'ERA',
            'HOUR_OF_AMPM',
            'HOUR_OF_DAY',
            'INSTANT_SECONDS',
            'MICRO_OF_DAY',
            'MICRO_OF_SECOND',
            'MILLI_OF_DAY',
            'MILLI_OF_SECOND',
            'MINUTE_OF_DAY',
            'MINUTE_OF_HOUR',
            'MONTH_OF_YEAR',
            'NANO_OF_DAY',
            'NANO_OF_SECOND',
            'OFFSET_SECONDS',
            'PROLEPTIC_MONTH',
            'SECOND_OF_DAY',
            'SECOND_OF_MINUTE',
            'YEAR',
            'YEAR_OF_ERA',
          ],
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'datePart',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'datePart',
          type: 'text',
          optional: false,
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'datePart',
          type: 'text',
          optional: false,
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW date = DATE_PARSE("yyyy-MM-dd", "2022-05-06")\n| EVAL year = DATE_EXTRACT("year", date)',
    'FROM sample_data\n| WHERE DATE_EXTRACT("hour_of_day", @timestamp) < 9 AND DATE_EXTRACT("hour_of_day", @timestamp) >= 17',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dateFormatDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'date_format',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.date_format', {
    defaultMessage: 'Returns a string representation of a date, in the provided format.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'dateFormat',
          type: 'date',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'dateFormat',
          type: 'date_nanos',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'dateFormat',
          type: 'keyword',
          optional: true,
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'dateFormat',
          type: 'keyword',
          optional: true,
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'dateFormat',
          type: 'text',
          optional: true,
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'dateFormat',
          type: 'text',
          optional: true,
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM employees\n| KEEP first_name, last_name, hire_date\n| EVAL hired = DATE_FORMAT("yyyy-MM-dd", hire_date)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dateParseDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'date_parse',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.date_parse', {
    defaultMessage:
      'Returns a date by parsing the second argument using the format specified in the first argument.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'datePattern',
          type: 'keyword',
          optional: true,
        },
        {
          name: 'dateString',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'keyword',
          optional: true,
        },
        {
          name: 'dateString',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'text',
          optional: true,
        },
        {
          name: 'dateString',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'datePattern',
          type: 'text',
          optional: true,
        },
        {
          name: 'dateString',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'date',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW date_string = "2022-05-06"\n| EVAL date = DATE_PARSE("yyyy-MM-dd", date_string)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const dateTruncDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'date_trunc',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.date_trunc', {
    defaultMessage: 'Rounds down a date to the closest interval.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'interval',
          type: 'time_literal',
          optional: false,
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'interval',
          type: 'date_period',
          optional: false,
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'interval',
          type: 'time_duration',
          optional: false,
        },
        {
          name: 'date',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'interval',
          type: 'time_duration',
          optional: false,
        },
        {
          name: 'date',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM employees\n| KEEP first_name, last_name, hire_date\n| EVAL year_hired = DATE_TRUNC(1 year, hire_date)',
    'FROM employees\n| EVAL year = DATE_TRUNC(1 year, hire_date)\n| STATS hires = COUNT(emp_no) BY year\n| SORT year',
    'FROM sample_data\n| EVAL error = CASE(message LIKE "*error*", 1, 0)\n| EVAL hour = DATE_TRUNC(1 hour, @timestamp)\n| STATS error_rate = AVG(error) by hour\n| SORT hour',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const eDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'e',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.e', {
    defaultMessage: "Returns Euler's number.",
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW E()'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const endsWithDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'ends_with',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.ends_with', {
    defaultMessage:
      'Returns a boolean that indicates whether a keyword string ends with another string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'suffix',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'suffix',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
        },
        {
          name: 'suffix',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
        },
        {
          name: 'suffix',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['FROM employees\n| KEEP last_name\n| EVAL ln_E = ENDS_WITH(last_name, "d")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const expDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'exp',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.exp', {
    defaultMessage: 'Returns the value of e raised to the power of the given number.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW d = 5.0\n| EVAL s = EXP(d)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const floorDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'floor',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.floor', {
    defaultMessage: 'Round a number down to the nearest integer.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=1.8\n| EVAL a=FLOOR(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const fromBase64Definition: FunctionDefinition = {
  type: 'scalar',
  name: 'from_base64',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.from_base64', {
    defaultMessage: 'Decode a base64 string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['row a = "ZWxhc3RpYw==" \n| eval d = from_base64(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const greatestDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'greatest',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.greatest', {
    defaultMessage:
      'Returns the maximum value from multiple columns. This is similar to `MV_MAX`\nexcept it is intended to run on multiple columns at once.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
        },
        {
          name: 'rest',
          type: 'boolean',
          optional: true,
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date',
          optional: false,
        },
        {
          name: 'rest',
          type: 'date',
          optional: true,
        },
      ],
      returnType: 'date',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date_nanos',
          optional: false,
        },
        {
          name: 'rest',
          type: 'date_nanos',
          optional: true,
        },
      ],
      returnType: 'date_nanos',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'double',
          optional: false,
        },
        {
          name: 'rest',
          type: 'double',
          optional: true,
        },
      ],
      returnType: 'double',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
        },
        {
          name: 'rest',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'ip',
          optional: false,
        },
        {
          name: 'rest',
          type: 'ip',
          optional: true,
        },
      ],
      returnType: 'ip',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'rest',
          type: 'keyword',
          optional: true,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
        },
        {
          name: 'rest',
          type: 'long',
          optional: true,
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
        },
        {
          name: 'rest',
          type: 'text',
          optional: true,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'version',
          optional: false,
        },
        {
          name: 'rest',
          type: 'version',
          optional: true,
        },
      ],
      returnType: 'version',
      minParams: 1,
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a = 10, b = 20\n| EVAL g = GREATEST(a, b)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const hashDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'hash',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.hash', {
    defaultMessage:
      'Computes the hash of the input using various algorithms such as MD5, SHA, SHA-224, SHA-256, SHA-384, SHA-512.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'algorithm',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'input',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'algorithm',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'input',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'algorithm',
          type: 'text',
          optional: false,
        },
        {
          name: 'input',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'algorithm',
          type: 'text',
          optional: false,
        },
        {
          name: 'input',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM sample_data \n| WHERE message != "Connection error"\n| EVAL md5 = hash("md5", message), sha256 = hash("sha256", message) \n| KEEP message, md5, sha256;',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const hypotDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'hypot',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.hypot', {
    defaultMessage:
      'Returns the hypotenuse of two numbers. The input can be any numeric values, the return value is always a double.\nHypotenuses of infinities are null.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number1',
          type: 'double',
          optional: false,
        },
        {
          name: 'number2',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'double',
          optional: false,
        },
        {
          name: 'number2',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'double',
          optional: false,
        },
        {
          name: 'number2',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'double',
          optional: false,
        },
        {
          name: 'number2',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'integer',
          optional: false,
        },
        {
          name: 'number2',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'integer',
          optional: false,
        },
        {
          name: 'number2',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'integer',
          optional: false,
        },
        {
          name: 'number2',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'integer',
          optional: false,
        },
        {
          name: 'number2',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'long',
          optional: false,
        },
        {
          name: 'number2',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'long',
          optional: false,
        },
        {
          name: 'number2',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'long',
          optional: false,
        },
        {
          name: 'number2',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'long',
          optional: false,
        },
        {
          name: 'number2',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'number2',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'number2',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'number2',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number1',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'number2',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a = 3.0, b = 4.0\n| EVAL c = HYPOT(a, b)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const ipPrefixDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'ip_prefix',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.ip_prefix', {
    defaultMessage: 'Truncates an IP to a given prefix length.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'ip',
          type: 'ip',
          optional: false,
        },
        {
          name: 'prefixLengthV4',
          type: 'integer',
          optional: false,
        },
        {
          name: 'prefixLengthV6',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'ip',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'row ip4 = to_ip("1.2.3.4"), ip6 = to_ip("fe80::cae2:65ff:fece:feb9")\n| eval ip4_prefix = ip_prefix(ip4, 24, 0), ip6_prefix = ip_prefix(ip6, 0, 112);',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const kqlDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'kql',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.kql', {
    defaultMessage:
      'Performs a KQL query. Returns true if the provided KQL query string matches the row.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          fieldsOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'query',
          type: 'text',
          optional: false,
          fieldsOnly: true,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['where'],
  supportedOptions: [],
  validate: undefined,
  examples: [
    'FROM books \n| WHERE KQL("author: Faulkner")\n| KEEP book_no, author \n| SORT book_no \n| LIMIT 5',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const leastDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'least',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.least', {
    defaultMessage:
      'Returns the minimum value from multiple columns. This is similar to `MV_MIN` except it is intended to run on multiple columns at once.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'boolean',
          optional: false,
        },
        {
          name: 'rest',
          type: 'boolean',
          optional: true,
        },
      ],
      returnType: 'boolean',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date',
          optional: false,
        },
        {
          name: 'rest',
          type: 'date',
          optional: true,
        },
      ],
      returnType: 'date',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'date_nanos',
          optional: false,
        },
        {
          name: 'rest',
          type: 'date_nanos',
          optional: true,
        },
      ],
      returnType: 'date_nanos',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'double',
          optional: false,
        },
        {
          name: 'rest',
          type: 'double',
          optional: true,
        },
      ],
      returnType: 'double',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'integer',
          optional: false,
        },
        {
          name: 'rest',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'integer',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'ip',
          optional: false,
        },
        {
          name: 'rest',
          type: 'ip',
          optional: true,
        },
      ],
      returnType: 'ip',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'rest',
          type: 'keyword',
          optional: true,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'long',
          optional: false,
        },
        {
          name: 'rest',
          type: 'long',
          optional: true,
        },
      ],
      returnType: 'long',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'text',
          optional: false,
        },
        {
          name: 'rest',
          type: 'text',
          optional: true,
        },
      ],
      returnType: 'keyword',
      minParams: 1,
    },
    {
      params: [
        {
          name: 'first',
          type: 'version',
          optional: false,
        },
        {
          name: 'rest',
          type: 'version',
          optional: true,
        },
      ],
      returnType: 'version',
      minParams: 1,
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a = 10, b = 20\n| EVAL l = LEAST(a, b)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const leftDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'left',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.left', {
    defaultMessage:
      "Returns the substring that extracts 'length' chars from 'string' starting from the left.",
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'length',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'length',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM employees\n| KEEP last_name\n| EVAL left = LEFT(last_name, 3)\n| SORT last_name ASC\n| LIMIT 5',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const lengthDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'length',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.length', {
    defaultMessage: 'Returns the character length of a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airports\n| WHERE country == "India"\n| KEEP city\n| EVAL fn_length = LENGTH(city)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const locateDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'locate',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.locate', {
    defaultMessage:
      'Returns an integer that indicates the position of a keyword substring within another string.\nReturns `0` if the substring cannot be found.\nNote that string positions start from `1`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'substring',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'substring',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'substring',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'substring',
          type: 'text',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'substring',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'substring',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'substring',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'substring',
          type: 'text',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'integer',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['row a = "hello"\n| eval a_ll = locate(a, "ll")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const logDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'log',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.log', {
    defaultMessage:
      'Returns the logarithm of a value to a base. The input can be any numeric value, the return value is always a double.\n\nLogs of zero, negative numbers, and base of one return `null` as well as a warning.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: true,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: true,
        },
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: true,
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: true,
        },
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: true,
        },
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: true,
        },
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: true,
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: true,
        },
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: true,
        },
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: true,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: true,
        },
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: true,
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: true,
        },
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: true,
        },
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
        },
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
        },
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: true,
        },
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: (fnDef: ESQLFunction) => {
    const messages = [];
    // do not really care here about the base and field
    // just need to check both values are not negative
    for (const arg of fnDef.args) {
      if (isLiteralItem(arg) && Number(arg.value) < 0) {
        messages.push({
          type: 'warning' as const,
          code: 'logOfNegativeValue',
          text: i18n.translate(
            'kbn-esql-validation-autocomplete.esql.divide.warning.logOfNegativeValue',
            {
              defaultMessage: 'Log of a negative number results in null: {value}',
              values: {
                value: arg.value,
              },
            }
          ),
          location: arg.location,
        });
      }
    }
    return messages;
  },
  examples: [
    'ROW base = 2.0, value = 8.0\n| EVAL s = LOG(base, value)',
    'row value = 100\n| EVAL s = LOG(value);',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const log10Definition: FunctionDefinition = {
  type: 'scalar',
  name: 'log10',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.log10', {
    defaultMessage:
      'Returns the logarithm of a value to base 10. The input can be any numeric value, the return value is always a double.\n\nLogs of 0 and negative numbers return `null` as well as a warning.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: (fnDef: ESQLFunction) => {
    const messages = [];
    // do not really care here about the base and field
    // just need to check both values are not negative
    for (const arg of fnDef.args) {
      if (isLiteralItem(arg) && Number(arg.value) < 0) {
        messages.push({
          type: 'warning' as const,
          code: 'logOfNegativeValue',
          text: i18n.translate(
            'kbn-esql-validation-autocomplete.esql.divide.warning.logOfNegativeValue',
            {
              defaultMessage: 'Log of a negative number results in null: {value}',
              values: {
                value: arg.value,
              },
            }
          ),
          location: arg.location,
        });
      }
    }
    return messages;
  },
  examples: ['ROW d = 1000.0 \n| EVAL s = LOG10(d)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const ltrimDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'ltrim',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.ltrim', {
    defaultMessage: 'Removes leading whitespaces from a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW message = "   some text  ",  color = " red "\n| EVAL message = LTRIM(message)\n| EVAL color = LTRIM(color)\n| EVAL message = CONCAT("\'", message, "\'")\n| EVAL color = CONCAT("\'", color, "\'")',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const matchDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'match',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.match', {
    defaultMessage:
      'Use `MATCH` to perform a match query on the specified field.\nUsing `MATCH` is equivalent to using the `match` query in the Elasticsearch Query DSL.\n\nMatch can be used on fields from the text family like  text and  semantic_text,\nas well as other field types like keyword, boolean, dates, and numeric types.\n\nMatch can use function named parameters to specify additional options for the match query.\nAll match query parameters are supported.\n\nFor a simplified syntax, you can use the match operator `:` operator instead of `MATCH`.\n\n`MATCH` returns true if the provided query matches the row.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'boolean',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'date',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'date_nanos',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'double',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'integer',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'long',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'double',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'integer',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'long',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'ip',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'double',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'integer',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'long',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'double',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'integer',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'long',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'unsigned_long',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
          fieldsOnly: true,
        },
        {
          name: 'query',
          type: 'version',
          optional: false,
          constantOnly: true,
        },
        {
          name: 'options',
          type: 'function_named_parameters',
          mapParams:
            "{name='fuzziness', values=[AUTO, 1, 2], description='Maximum edit distance allowed for matching.'}, {name='auto_generate_synonyms_phrase_query', values=[true, false], description='If true, match phrase queries are automatically created for multi-term synonyms.'}, {name='analyzer', values=[standard], description='Analyzer used to convert the text in the query value into token.'}, {name='minimum_should_match', values=[2], description='Minimum number of clauses that must match for a document to be returned.'}, {name='zero_terms_query', values=[none, all], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='boost', values=[2.5], description='Floating point number used to decrease or increase the relevance scores of the query.'}, {name='fuzzy_transpositions', values=[true, false], description='If true, edits for fuzzy matching include transpositions of two adjacent characters (ab  ba).'}, {name='fuzzy_rewrite', values=[constant_score_blended, constant_score, constant_score_boolean, top_terms_blended_freqs_N, top_terms_boost_N, top_terms_N], description='Method used to rewrite the query. See the rewrite parameter for valid values and more information.'}, {name='prefix_length', values=[1], description='Number of beginning characters left unchanged for fuzzy matching.'}, {name='lenient', values=[true, false], description='If false, format-based errors, such as providing a text query value for a numeric field, are returned.'}, {name='operator', values=[AND, OR], description='Boolean logic used to interpret text in the query value.'}, {name='max_expansions', values=[50], description='Maximum number of terms to which the query will expand.'}",
          optional: true,
          constantOnly: true,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['where'],
  supportedOptions: [],
  validate: undefined,
  examples: [
    'FROM books \n| WHERE MATCH(author, "Faulkner")\n| KEEP book_no, author \n| SORT book_no \n| LIMIT 5',
    'FROM books \n| WHERE MATCH(title, "Hobbit Back Again", {"operator": "AND"})\n| KEEP title;',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const md5Definition: FunctionDefinition = {
  type: 'scalar',
  name: 'md5',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.md5', {
    defaultMessage: 'Computes the MD5 hash of the input.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'input',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'input',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM sample_data \n| WHERE message != "Connection error"\n| EVAL md5 = md5(message)\n| KEEP message, md5;',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvAppendDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_append',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_append', {
    defaultMessage: 'Concatenates values of two multi-value fields.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field1',
          type: 'boolean',
          optional: false,
        },
        {
          name: 'field2',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'field2',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'field2',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'date',
          optional: false,
        },
        {
          name: 'field2',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'date_nanos',
          optional: false,
        },
        {
          name: 'field2',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'double',
          optional: false,
        },
        {
          name: 'field2',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'field2',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'field2',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'integer',
          optional: false,
        },
        {
          name: 'field2',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'ip',
          optional: false,
        },
        {
          name: 'field2',
          type: 'ip',
          optional: false,
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'field2',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'field2',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'long',
          optional: false,
        },
        {
          name: 'field2',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'text',
          optional: false,
        },
        {
          name: 'field2',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'text',
          optional: false,
        },
        {
          name: 'field2',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'field2',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field1',
          type: 'version',
          optional: false,
        },
        {
          name: 'field2',
          type: 'version',
          optional: false,
        },
      ],
      returnType: 'version',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvAvgDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_avg',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_avg', {
    defaultMessage:
      'Converts a multivalued field into a single valued field containing the average of all of the values.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=[3, 5, 1, 6]\n| EVAL avg_a = MV_AVG(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvConcatDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_concat',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_concat', {
    defaultMessage:
      'Converts a multivalued string expression into a single valued column containing the concatenation of all values separated by a delimiter.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'delim',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'delim',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW a=["foo", "zoo", "bar"]\n| EVAL j = MV_CONCAT(a, ", ")',
    'ROW a=[10, 9, 8]\n| EVAL j = MV_CONCAT(TO_STRING(a), ", ")',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvCountDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_count',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_count', {
    defaultMessage:
      'Converts a multivalued expression into a single valued column containing a count of the number of values.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=["foo", "zoo", "bar"]\n| EVAL count_a = MV_COUNT(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvDedupeDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_dedupe',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_dedupe', {
    defaultMessage: 'Remove duplicate values from a multivalued field.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
        },
      ],
      returnType: 'version',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=["foo", "foo", "bar", "foo"]\n| EVAL dedupe_a = MV_DEDUPE(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvFirstDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_first',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_first', {
    defaultMessage:
      'Converts a multivalued expression into a single valued column containing the\nfirst value. This is most useful when reading from a function that emits\nmultivalued columns in a known order like `SPLIT`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
        },
      ],
      returnType: 'version',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a="foo;bar;baz"\n| EVAL first_a = MV_FIRST(SPLIT(a, ";"))'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvLastDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_last',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_last', {
    defaultMessage:
      'Converts a multivalue expression into a single valued column containing the last\nvalue. This is most useful when reading from a function that emits multivalued\ncolumns in a known order like `SPLIT`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
        },
      ],
      returnType: 'version',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a="foo;bar;baz"\n| EVAL last_a = MV_LAST(SPLIT(a, ";"))'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvMaxDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_max',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_max', {
    defaultMessage:
      'Converts a multivalued expression into a single valued column containing the maximum value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
        },
      ],
      returnType: 'version',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW a=[3, 5, 1]\n| EVAL max_a = MV_MAX(a)',
    'ROW a=["foo", "zoo", "bar"]\n| EVAL max_a = MV_MAX(a)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvMedianDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_median',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_median', {
    defaultMessage:
      'Converts a multivalued field into a single valued field containing the median value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW a=[3, 5, 1]\n| EVAL median_a = MV_MEDIAN(a)',
    'ROW a=[3, 7, 1, 6]\n| EVAL median_a = MV_MEDIAN(a)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvMedianAbsoluteDeviationDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_median_absolute_deviation',
  description: i18n.translate(
    'kbn-esql-validation-autocomplete.esql.definitions.mv_median_absolute_deviation',
    {
      defaultMessage:
        "Converts a multivalued field into a single valued field containing the median absolute deviation.\n\nIt is calculated as the median of each data point's deviation from the median of the entire sample. That is, for a random variable `X`, the median absolute deviation is `median(|median(X) - X|)`.",
    }
  ),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW values = [0, 2, 5, 6]\n| EVAL median_absolute_deviation = MV_MEDIAN_ABSOLUTE_DEVIATION(values), median = MV_MEDIAN(values)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvMinDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_min',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_min', {
    defaultMessage:
      'Converts a multivalued expression into a single valued column containing the minimum value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
        },
      ],
      returnType: 'version',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW a=[2, 1]\n| EVAL min_a = MV_MIN(a)',
    'ROW a=["foo", "bar"]\n| EVAL min_a = MV_MIN(a)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvPercentileDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_percentile',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_percentile', {
    defaultMessage:
      'Converts a multivalued field into a single valued field containing the value at which a certain percentage of observed values occur.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
        {
          name: 'percentile',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
        {
          name: 'percentile',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
        {
          name: 'percentile',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
        {
          name: 'percentile',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
        {
          name: 'percentile',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
        {
          name: 'percentile',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
        {
          name: 'percentile',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
        {
          name: 'percentile',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
        {
          name: 'percentile',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW values = [5, 5, 10, 12, 5000]\n| EVAL p50 = MV_PERCENTILE(values, 50), median = MV_MEDIAN(values)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvPseriesWeightedSumDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_pseries_weighted_sum',
  description: i18n.translate(
    'kbn-esql-validation-autocomplete.esql.definitions.mv_pseries_weighted_sum',
    {
      defaultMessage:
        'Converts a multivalued expression into a single-valued column by multiplying every element on the input list by its corresponding term in P-Series and computing the sum.',
    }
  ),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
        {
          name: 'p',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW a = [70.0, 45.0, 21.0, 21.0, 21.0]\n| EVAL sum = MV_PSERIES_WEIGHTED_SUM(a, 1.5)\n| KEEP sum',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvSliceDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_slice',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_slice', {
    defaultMessage:
      'Returns a subset of the multivalued field using the start and end index values.\nThis is most useful when reading from a function that emits multivalued columns\nin a known order like `SPLIT` or `MV_SORT`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'end',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'version',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'row a = [1, 2, 2, 3]\n| eval a1 = mv_slice(a, 1), a2 = mv_slice(a, 2, 3)',
    'row a = [1, 2, 2, 3]\n| eval a1 = mv_slice(a, -2), a2 = mv_slice(a, -3, -1)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvSortDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_sort',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_sort', {
    defaultMessage: 'Sorts a multivalued field in lexicographical order.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          acceptedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          acceptedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          acceptedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          acceptedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          acceptedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          acceptedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          acceptedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          acceptedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          acceptedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
        },
        {
          name: 'order',
          type: 'keyword',
          optional: true,
          acceptedValues: ['asc', 'desc'],
        },
      ],
      returnType: 'version',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a = [4, 2, -3, 2]\n| EVAL sa = mv_sort(a), sd = mv_sort(a, "DESC")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvSumDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_sum',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_sum', {
    defaultMessage:
      'Converts a multivalued field into a single valued field containing the sum of all of the values.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=[3, 5, 6]\n| EVAL sum_a = MV_SUM(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const mvZipDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'mv_zip',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.mv_zip', {
    defaultMessage:
      'Combines the values from two multivalued fields with a delimiter that joins them together.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'delim',
          type: 'text',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
        },
        {
          name: 'delim',
          type: 'text',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
        },
        {
          name: 'string2',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'delim',
          type: 'text',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string1',
          type: 'text',
          optional: false,
        },
        {
          name: 'string2',
          type: 'text',
          optional: false,
        },
        {
          name: 'delim',
          type: 'text',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW a = ["x", "y", "z"], b = ["1", "2"]\n| EVAL c = mv_zip(a, b, "-")\n| KEEP a, b, c',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const nowDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'now',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.now', {
    defaultMessage: 'Returns current date and time.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [],
      returnType: 'date',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW current_date = NOW()', 'FROM sample_data\n| WHERE @timestamp > NOW() - 1 hour'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const piDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'pi',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.pi', {
    defaultMessage: "Returns Pi, the ratio of a circle's circumference to its diameter.",
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW PI()'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const powDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'pow',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.pow', {
    defaultMessage: 'Returns the value of `base` raised to the power of `exponent`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'double',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'integer',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'long',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'base',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'exponent',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW base = 2.0, exponent = 2\n| EVAL result = POW(base, exponent)',
    'ROW base = 4, exponent = 0.5\n| EVAL s = POW(base, exponent)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const qstrDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'qstr',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.qstr', {
    defaultMessage:
      'Performs a query string query. Returns true if the provided query string matches the row.',
  }),
  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'query',
          type: 'keyword',
          optional: false,
          fieldsOnly: true,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'query',
          type: 'text',
          optional: false,
          fieldsOnly: true,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['where'],
  supportedOptions: [],
  validate: undefined,
  examples: [
    'FROM books \n| WHERE QSTR("author: Faulkner")\n| KEEP book_no, author \n| SORT book_no \n| LIMIT 5',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const repeatDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'repeat',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.repeat', {
    defaultMessage:
      'Returns a string constructed by concatenating `string` with itself the specified `number` of times.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a = "Hello!"\n| EVAL triple_a = REPEAT(a, 3)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const replaceDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'replace',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.replace', {
    defaultMessage:
      'The function substitutes in the string `str` any match of the regular expression `regex`\nwith the replacement string `newStr`.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'regex',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'newString',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'regex',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'newString',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'regex',
          type: 'text',
          optional: false,
        },
        {
          name: 'newString',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'regex',
          type: 'text',
          optional: false,
        },
        {
          name: 'newString',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'regex',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'newString',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'regex',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'newString',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'regex',
          type: 'text',
          optional: false,
        },
        {
          name: 'newString',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'regex',
          type: 'text',
          optional: false,
        },
        {
          name: 'newString',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW str = "Hello World"\n| EVAL str = REPLACE(str, "World", "Universe")\n| KEEP str'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const reverseDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'reverse',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.reverse', {
    defaultMessage: 'Returns a new string representing the input string in reverse order.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW message = "Some Text" | EVAL message_reversed = REVERSE(message);',
    'ROW bending_arts = "" | EVAL bending_arts_reversed = REVERSE(bending_arts);',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const rightDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'right',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.right', {
    defaultMessage:
      "Return the substring that extracts 'length' chars from 'str' starting from the right.",
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'length',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'length',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM employees\n| KEEP last_name\n| EVAL right = RIGHT(last_name, 3)\n| SORT last_name ASC\n| LIMIT 5',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const roundDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'round',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.round', {
    defaultMessage:
      'Rounds a number to the specified number of decimal places.\nDefaults to 0, which returns the nearest integer. If the\nprecision is a negative number, rounds to the number of digits left\nof the decimal point.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
        {
          name: 'decimals',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
        {
          name: 'decimals',
          type: 'long',
          optional: true,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
        {
          name: 'decimals',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
        {
          name: 'decimals',
          type: 'long',
          optional: true,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
        {
          name: 'decimals',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
        {
          name: 'decimals',
          type: 'long',
          optional: true,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'decimals',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
        {
          name: 'decimals',
          type: 'long',
          optional: true,
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM employees\n| KEEP first_name, last_name, height\n| EVAL height_ft = ROUND(height * 3.281, 1)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const rtrimDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'rtrim',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.rtrim', {
    defaultMessage: 'Removes trailing whitespaces from a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW message = "   some text  ",  color = " red "\n| EVAL message = RTRIM(message)\n| EVAL color = RTRIM(color)\n| EVAL message = CONCAT("\'", message, "\'")\n| EVAL color = CONCAT("\'", color, "\'")',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const sha1Definition: FunctionDefinition = {
  type: 'scalar',
  name: 'sha1',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.sha1', {
    defaultMessage: 'Computes the SHA1 hash of the input.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'input',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'input',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM sample_data \n| WHERE message != "Connection error"\n| EVAL sha1 = sha1(message)\n| KEEP message, sha1;',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const sha256Definition: FunctionDefinition = {
  type: 'scalar',
  name: 'sha256',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.sha256', {
    defaultMessage: 'Computes the SHA256 hash of the input.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'input',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'input',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM sample_data \n| WHERE message != "Connection error"\n| EVAL sha256 = sha256(message)\n| KEEP message, sha256;',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const signumDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'signum',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.signum', {
    defaultMessage:
      'Returns the sign of the given number.\nIt returns `-1` for negative numbers, `0` for `0` and `1` for positive numbers.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW d = 100.0\n| EVAL s = SIGNUM(d)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const sinDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'sin',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.sin', {
    defaultMessage: 'Returns the sine of an angle.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'angle',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=1.8 \n| EVAL sin=SIN(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const sinhDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'sinh',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.sinh', {
    defaultMessage: 'Returns the hyperbolic sine of a number.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=1.8 \n| EVAL sinh=SINH(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const spaceDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'space',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.space', {
    defaultMessage: 'Returns a string made of `number` spaces.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW message = CONCAT("Hello", SPACE(1), "World!");'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const splitDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'split',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.split', {
    defaultMessage: 'Split a single valued string into multiple strings.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'delim',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'delim',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'delim',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW words="foo;bar;baz;qux;quux;corge"\n| EVAL word = SPLIT(words, ";")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const sqrtDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'sqrt',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.sqrt', {
    defaultMessage:
      'Returns the square root of a number. The input can be any numeric value, the return value is always a double.\nSquare roots of negative numbers and infinities are null.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW d = 100.0\n| EVAL s = SQRT(d)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stContainsDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_contains',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_contains', {
    defaultMessage:
      'Returns whether the first geometry contains the second geometry.\nThis is the inverse of the `ST_WITHIN` function.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airport_city_boundaries\n| WHERE ST_CONTAINS(city_boundary, TO_GEOSHAPE("POLYGON((109.35 18.3, 109.45 18.3, 109.45 18.4, 109.35 18.4, 109.35 18.3))"))\n| KEEP abbrev, airport, region, city, city_location',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stDisjointDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_disjoint',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_disjoint', {
    defaultMessage:
      'Returns whether the two geometries or geometry columns are disjoint.\nThis is the inverse of the `ST_INTERSECTS` function.\nIn mathematical terms: ST_Disjoint(A, B)  A  B = ',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airport_city_boundaries\n| WHERE ST_DISJOINT(city_boundary, TO_GEOSHAPE("POLYGON((-10 -60, 120 -60, 120 60, -10 60, -10 -60))"))\n| KEEP abbrev, airport, region, city, city_location',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stDistanceDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_distance',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_distance', {
    defaultMessage:
      'Computes the distance between two points.\nFor cartesian geometries, this is the pythagorean distance in the same units as the original coordinates.\nFor geographic geometries, this is the circular distance along the great circle in meters.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airports\n| WHERE abbrev == "CPH"\n| EVAL distance = ST_DISTANCE(location, city_location)\n| KEEP abbrev, name, location, city_location, distance',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stEnvelopeDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_envelope',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_envelope', {
    defaultMessage: 'Determines the minimum bounding box of the supplied geometry.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geometry',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'geometry',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'geo_shape',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| KEEP abbrev, airport, envelope',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stIntersectsDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_intersects',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_intersects', {
    defaultMessage:
      'Returns true if two geometries intersect.\nThey intersect if they have any point in common, including their interior points\n(points along lines or within polygons).\nThis is the inverse of the `ST_DISJOINT` function.\nIn mathematical terms: ST_Intersects(A, B)  A  B  ',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airports\n| WHERE ST_INTERSECTS(location, TO_GEOSHAPE("POLYGON((42 14, 43 14, 43 15, 42 15, 42 14))"))',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stWithinDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_within',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_within', {
    defaultMessage:
      'Returns whether the first geometry is within the second geometry.\nThis is the inverse of the `ST_CONTAINS` function.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'cartesian_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_point',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'geomA',
          type: 'geo_shape',
          optional: false,
        },
        {
          name: 'geomB',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airport_city_boundaries\n| WHERE ST_WITHIN(city_boundary, TO_GEOSHAPE("POLYGON((109.1 18.15, 109.6 18.15, 109.6 18.65, 109.1 18.65, 109.1 18.15))"))\n| KEEP abbrev, airport, region, city, city_location',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stXDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_x',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_x', {
    defaultMessage:
      'Extracts the `x` coordinate from the supplied point.\nIf the points is of type `geo_point` this is equivalent to extracting the `longitude` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW point = TO_GEOPOINT("POINT(42.97109629958868 14.7552534006536)")\n| EVAL x =  ST_X(point), y = ST_Y(point)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stXmaxDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_xmax',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_xmax', {
    defaultMessage:
      'Extracts the maximum value of the `x` coordinates from the supplied geometry.\nIf the geometry is of type `geo_point` or `geo_shape` this is equivalent to extracting the maximum `longitude` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stXminDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_xmin',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_xmin', {
    defaultMessage:
      'Extracts the minimum value of the `x` coordinates from the supplied geometry.\nIf the geometry is of type `geo_point` or `geo_shape` this is equivalent to extracting the minimum `longitude` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stYDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_y',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_y', {
    defaultMessage:
      'Extracts the `y` coordinate from the supplied point.\nIf the points is of type `geo_point` this is equivalent to extracting the `latitude` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW point = TO_GEOPOINT("POINT(42.97109629958868 14.7552534006536)")\n| EVAL x =  ST_X(point), y = ST_Y(point)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stYmaxDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_ymax',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_ymax', {
    defaultMessage:
      'Extracts the maximum value of the `y` coordinates from the supplied geometry.\nIf the geometry is of type `geo_point` or `geo_shape` this is equivalent to extracting the maximum `latitude` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const stYminDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'st_ymin',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.st_ymin', {
    defaultMessage:
      'Extracts the minimum value of the `y` coordinates from the supplied geometry.\nIf the geometry is of type `geo_point` or `geo_shape` this is equivalent to extracting the minimum `latitude` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'point',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM airport_city_boundaries\n| WHERE abbrev == "CPH"\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const startsWithDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'starts_with',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.starts_with', {
    defaultMessage:
      'Returns a boolean that indicates whether a keyword string starts with another string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'prefix',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'prefix',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
        },
        {
          name: 'prefix',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
        },
        {
          name: 'prefix',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['FROM employees\n| KEEP last_name\n| EVAL ln_S = STARTS_WITH(last_name, "B")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const substringDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'substring',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.substring', {
    defaultMessage:
      'Returns a substring of a string, specified by a start position and an optional length.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'length',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
        {
          name: 'start',
          type: 'integer',
          optional: false,
        },
        {
          name: 'length',
          type: 'integer',
          optional: true,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'FROM employees\n| KEEP last_name\n| EVAL ln_sub = SUBSTRING(last_name, 1, 3)',
    'FROM employees\n| KEEP last_name\n| EVAL ln_sub = SUBSTRING(last_name, -3, 3)',
    'FROM employees\n| KEEP last_name\n| EVAL ln_sub = SUBSTRING(last_name, 2)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const tanDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'tan',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.tan', {
    defaultMessage: 'Returns the tangent of an angle.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'angle',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'angle',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=1.8 \n| EVAL tan=TAN(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const tanhDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'tanh',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.tanh', {
    defaultMessage: 'Returns the hyperbolic tangent of a number.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=1.8 \n| EVAL tanh=TANH(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const tauDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'tau',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.tau', {
    defaultMessage: "Returns the ratio of a circle's circumference to its radius.",
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW TAU()'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const termDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'term',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.term', {
    defaultMessage:
      'Performs a Term query on the specified field. Returns true if the provided term matches the row.',
  }),
  ignoreAsSuggestion: true,

  preview: true,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
        {
          name: 'query',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
        {
          name: 'query',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
        {
          name: 'query',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['FROM books \n| WHERE TERM(author, "gabriel")  \n| KEEP book_no, title\n| LIMIT 3;'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toBase64Definition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_base64',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_base64', {
    defaultMessage: 'Encode a string to a base64 string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['row a = "elastic" \n| eval e = to_base64(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toBooleanDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_boolean',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_boolean', {
    defaultMessage:
      'Converts an input value to a boolean value.\nA string value of *true* will be case-insensitive converted to the Boolean *true*.\nFor anything else, including the empty string, the function will return *false*.\nThe numerical value of *0* will be converted to *false*, anything else will be converted to *true*.',
  }),
  preview: false,
  alias: ['to_bool'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'boolean',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW str = ["true", "TRuE", "false", "", "yes", "1"]\n| EVAL bool = TO_BOOLEAN(str)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toCartesianpointDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_cartesianpoint',
  description: i18n.translate(
    'kbn-esql-validation-autocomplete.esql.definitions.to_cartesianpoint',
    {
      defaultMessage:
        'Converts an input value to a `cartesian_point` value.\nA string will only be successfully converted if it respects WKT Point format.',
    }
  ),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'cartesian_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'cartesian_point',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW wkt = ["POINT(4297.11 -1475.53)", "POINT(7580.93 2272.77)"]\n| MV_EXPAND wkt\n| EVAL pt = TO_CARTESIANPOINT(wkt)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toCartesianshapeDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_cartesianshape',
  description: i18n.translate(
    'kbn-esql-validation-autocomplete.esql.definitions.to_cartesianshape',
    {
      defaultMessage:
        'Converts an input value to a `cartesian_shape` value.\nA string will only be successfully converted if it respects WKT format.',
    }
  ),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'cartesian_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'cartesian_shape',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW wkt = ["POINT(4297.11 -1475.53)", "POLYGON ((3339584.72 1118889.97, 4452779.63 4865942.27, 2226389.81 4865942.27, 1113194.90 2273030.92, 3339584.72 1118889.97))"]\n| MV_EXPAND wkt\n| EVAL geom = TO_CARTESIANSHAPE(wkt)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDateNanosDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_date_nanos',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_date_nanos', {
    defaultMessage: 'Converts an input to a nanosecond-resolution date value (aka date_nanos).',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'date_nanos',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDateperiodDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_dateperiod',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_dateperiod', {
    defaultMessage: 'Converts an input value into a `date_period` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'date_period',
          optional: false,
        },
      ],
      returnType: 'date_period',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'date_period',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'date_period',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'row x = "2024-01-01"::datetime | eval y = x + "3 DAYS"::date_period, z = x - to_dateperiod("3 days");',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDatetimeDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_datetime',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_datetime', {
    defaultMessage:
      "Converts an input value to a date value.\nA string will only be successfully converted if it's respecting the format `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'`.\nTo convert dates in other formats, use `DATE_PARSE`.",
  }),
  preview: false,
  alias: ['to_dt'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'date',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'date',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW string = ["1953-09-02T00:00:00.000Z", "1964-06-02T00:00:00.000Z", "1964-06-02 00:00:00"]\n| EVAL datetime = TO_DATETIME(string)',
    'ROW int = [0, 1]\n| EVAL dt = TO_DATETIME(int)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDegreesDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_degrees',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_degrees', {
    defaultMessage: 'Converts a number in radians to degrees.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW rad = [1.57, 3.14, 4.71]\n| EVAL deg = TO_DEGREES(rad)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toDoubleDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_double',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_double', {
    defaultMessage:
      'Converts an input value to a double value. If the input parameter is of a date type,\nits value will be interpreted as milliseconds since the Unix epoch,\nconverted to double. Boolean *true* will be converted to double *1.0*, *false* to *0.0*.',
  }),
  preview: false,
  alias: ['to_dbl'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW str1 = "5.20128E11", str2 = "foo"\n| EVAL dbl = TO_DOUBLE("520128000000"), dbl1 = TO_DOUBLE(str1), dbl2 = TO_DOUBLE(str2)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toGeopointDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_geopoint',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_geopoint', {
    defaultMessage:
      'Converts an input value to a `geo_point` value.\nA string will only be successfully converted if it respects WKT Point format.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'geo_point',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'geo_point',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW wkt = "POINT(42.97109630194 14.7552534413725)"\n| EVAL pt = TO_GEOPOINT(wkt)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toGeoshapeDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_geoshape',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_geoshape', {
    defaultMessage:
      'Converts an input value to a `geo_shape` value.\nA string will only be successfully converted if it respects WKT format.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'geo_shape',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'geo_shape',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW wkt = "POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))"\n| EVAL geom = TO_GEOSHAPE(wkt)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toIntegerDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_integer',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_integer', {
    defaultMessage:
      'Converts an input value to an integer value.\nIf the input parameter is of a date type, its value will be interpreted as milliseconds\nsince the Unix epoch, converted to integer.\nBoolean *true* will be converted to integer *1*, *false* to *0*.',
  }),
  preview: false,
  alias: ['to_int'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'integer',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW long = [5013792, 2147483647, 501379200000]\n| EVAL int = TO_INTEGER(long)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toIpDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_ip',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_ip', {
    defaultMessage: 'Converts an input string to an IP value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'ip',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'ip',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW str1 = "1.1.1.1", str2 = "foo"\n| EVAL ip1 = TO_IP(str1), ip2 = TO_IP(str2)\n| WHERE CIDR_MATCH(ip1, "1.0.0.0/8")',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toLongDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_long',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_long', {
    defaultMessage:
      'Converts an input value to a long value. If the input parameter is of a date type,\nits value will be interpreted as milliseconds since the Unix epoch, converted to long.\nBoolean *true* will be converted to long *1*, *false* to *0*.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_integer',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'counter_long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW str1 = "2147483648", str2 = "2147483648.2", str3 = "foo"\n| EVAL long1 = TO_LONG(str1), long2 = TO_LONG(str2), long3 = TO_LONG(str3)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toLowerDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_lower',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_lower', {
    defaultMessage: 'Returns a new string representing the input string converted to lower case.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW message = "Some Text"\n| EVAL message_lower = TO_LOWER(message)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toRadiansDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_radians',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_radians', {
    defaultMessage: 'Converts a number in degrees to radians.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'number',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
    {
      params: [
        {
          name: 'number',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'double',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW deg = [90.0, 180.0, 270.0]\n| EVAL rad = TO_RADIANS(deg)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toStringDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_string',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_string', {
    defaultMessage: 'Converts an input value into a string.',
  }),
  preview: false,
  alias: ['to_str'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_point',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'cartesian_shape',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date_nanos',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_point',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'geo_shape',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'ip',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW a=10\n| EVAL j = TO_STRING(a)', 'ROW a=[10, 9, 8]\n| EVAL j = TO_STRING(a)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toTimedurationDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_timeduration',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_timeduration', {
    defaultMessage: 'Converts an input value into a `time_duration` value.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'time_duration',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'time_duration',
    },
    {
      params: [
        {
          name: 'field',
          type: 'time_duration',
          optional: false,
        },
      ],
      returnType: 'time_duration',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'row x = "2024-01-01"::datetime | eval y = x + "3 hours"::time_duration, z = x - to_timeduration("3 hours");',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toUnsignedLongDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_unsigned_long',
  description: i18n.translate(
    'kbn-esql-validation-autocomplete.esql.definitions.to_unsigned_long',
    {
      defaultMessage:
        'Converts an input value to an unsigned long value. If the input parameter is of a date type,\nits value will be interpreted as milliseconds since the Unix epoch, converted to unsigned long.\nBoolean *true* will be converted to unsigned long *1*, *false* to *0*.',
    }
  ),
  preview: false,
  alias: ['to_ul', 'to_ulong'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'boolean',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'date',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'double',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'integer',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
    {
      params: [
        {
          name: 'field',
          type: 'unsigned_long',
          optional: false,
        },
      ],
      returnType: 'unsigned_long',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW str1 = "2147483648", str2 = "2147483648.2", str3 = "foo"\n| EVAL long1 = TO_UNSIGNED_LONG(str1), long2 = TO_ULONG(str2), long3 = TO_UL(str3)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toUpperDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_upper',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_upper', {
    defaultMessage: 'Returns a new string representing the input string converted to upper case.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'str',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'str',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW message = "Some Text"\n| EVAL message_upper = TO_UPPER(message)'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const toVersionDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'to_version',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.to_version', {
    defaultMessage: 'Converts an input string to a version value.',
  }),
  preview: false,
  alias: ['to_ver'],
  signatures: [
    {
      params: [
        {
          name: 'field',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'version',
    },
    {
      params: [
        {
          name: 'field',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'version',
    },
    {
      params: [
        {
          name: 'field',
          type: 'version',
          optional: false,
        },
      ],
      returnType: 'version',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: ['ROW v = TO_VERSION("1.2.3")'],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const trimDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'trim',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.trim', {
    defaultMessage: 'Removes leading and trailing whitespaces from a string.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'string',
          type: 'keyword',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
    {
      params: [
        {
          name: 'string',
          type: 'text',
          optional: false,
        },
      ],
      returnType: 'keyword',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'ROW message = "   some text  ",  color = " red "\n| EVAL message = TRIM(message)\n| EVAL color = TRIM(color)',
  ],
};

// Do not edit this manually... generated by scripts/generate_function_definitions.ts
const caseDefinition: FunctionDefinition = {
  type: 'scalar',
  name: 'case',
  description: i18n.translate('kbn-esql-validation-autocomplete.esql.definitions.case', {
    defaultMessage:
      'Accepts pairs of conditions and values. The function returns the value that belongs to the first condition that evaluates to `true`. If the number of arguments is odd, the last argument is the default value which is returned when no condition matches.',
  }),
  preview: false,
  alias: undefined,
  signatures: [
    {
      params: [
        {
          name: 'condition',
          type: 'boolean',
        },
        {
          name: 'value',
          type: 'any',
        },
      ],
      minParams: 2,
      returnType: 'unknown',
    },
  ],
  supportedCommands: ['stats', 'inlinestats', 'metrics', 'eval', 'where', 'row', 'sort'],
  supportedOptions: ['by'],
  validate: undefined,
  examples: [
    'from index | eval type = case(languages <= 1, "monolingual", languages <= 2, "bilingual", "polyglot")',
  ],
};
export const scalarFunctionDefinitions = [
  absDefinition,
  acosDefinition,
  asinDefinition,
  atanDefinition,
  atan2Definition,
  bitLengthDefinition,
  byteLengthDefinition,
  cbrtDefinition,
  ceilDefinition,
  cidrMatchDefinition,
  coalesceDefinition,
  concatDefinition,
  cosDefinition,
  coshDefinition,
  dateDiffDefinition,
  dateExtractDefinition,
  dateFormatDefinition,
  dateParseDefinition,
  dateTruncDefinition,
  eDefinition,
  endsWithDefinition,
  expDefinition,
  floorDefinition,
  fromBase64Definition,
  greatestDefinition,
  hashDefinition,
  hypotDefinition,
  ipPrefixDefinition,
  kqlDefinition,
  leastDefinition,
  leftDefinition,
  lengthDefinition,
  locateDefinition,
  logDefinition,
  log10Definition,
  ltrimDefinition,
  matchDefinition,
  md5Definition,
  mvAppendDefinition,
  mvAvgDefinition,
  mvConcatDefinition,
  mvCountDefinition,
  mvDedupeDefinition,
  mvFirstDefinition,
  mvLastDefinition,
  mvMaxDefinition,
  mvMedianDefinition,
  mvMedianAbsoluteDeviationDefinition,
  mvMinDefinition,
  mvPercentileDefinition,
  mvPseriesWeightedSumDefinition,
  mvSliceDefinition,
  mvSortDefinition,
  mvSumDefinition,
  mvZipDefinition,
  nowDefinition,
  piDefinition,
  powDefinition,
  qstrDefinition,
  repeatDefinition,
  replaceDefinition,
  reverseDefinition,
  rightDefinition,
  roundDefinition,
  rtrimDefinition,
  sha1Definition,
  sha256Definition,
  signumDefinition,
  sinDefinition,
  sinhDefinition,
  spaceDefinition,
  splitDefinition,
  sqrtDefinition,
  stContainsDefinition,
  stDisjointDefinition,
  stDistanceDefinition,
  stEnvelopeDefinition,
  stIntersectsDefinition,
  stWithinDefinition,
  stXDefinition,
  stXmaxDefinition,
  stXminDefinition,
  stYDefinition,
  stYmaxDefinition,
  stYminDefinition,
  startsWithDefinition,
  substringDefinition,
  tanDefinition,
  tanhDefinition,
  tauDefinition,
  termDefinition,
  toBase64Definition,
  toBooleanDefinition,
  toCartesianpointDefinition,
  toCartesianshapeDefinition,
  toDateNanosDefinition,
  toDateperiodDefinition,
  toDatetimeDefinition,
  toDegreesDefinition,
  toDoubleDefinition,
  toGeopointDefinition,
  toGeoshapeDefinition,
  toIntegerDefinition,
  toIpDefinition,
  toLongDefinition,
  toLowerDefinition,
  toRadiansDefinition,
  toStringDefinition,
  toTimedurationDefinition,
  toUnsignedLongDefinition,
  toUpperDefinition,
  toVersionDefinition,
  trimDefinition,
  caseDefinition,
];
