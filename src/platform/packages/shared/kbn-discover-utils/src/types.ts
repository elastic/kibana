/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import type { SearchHit } from '@elastic/elasticsearch/lib/api/types';
import type { DatatableColumnMeta } from '@kbn/expressions-plugin/common';
import { Filter, Query, TimeRange } from '@kbn/es-query';

export type { IgnoredReason, ShouldShowFieldInTableHandler } from './utils';
export type {
  RowControlColumn,
  RowControlComponent,
  RowControlProps,
  RowControlRowProps,
} from './components/custom_control_columns/types';
export type * from './components/app_menu/types';
export { AppMenuActionId, AppMenuActionType } from './components/app_menu/types';
import type { DefaultEmbeddableApi } from '@kbn/embeddable-plugin/public';
import type { HasInspectorAdapters } from '@kbn/inspector-plugin/public';
import type {
  HasEditCapabilities,
  HasLibraryTransforms,
  HasSupportedTriggers,
  PublishesBlockingError,
  PublishesDataLoading,
  PublishesSavedObjectId,
  PublishesWritableTitle,
  PublishesWritableUnifiedSearch,
  PublishingSubject,
  SerializedTimeRange,
  SerializedTitles,
} from '@kbn/presentation-publishing';
import type {
  SavedSearch,
  SavedSearchAttributes,
  SerializableSavedSearch,
} from '@kbn/saved-search-plugin/common/types';
import type { BehaviorSubject } from 'rxjs';
import type { PublishesWritableDataViews } from '@kbn/presentation-publishing/interfaces/publishes_data_views';
import type { DynamicActionsSerializedState } from '@kbn/embeddable-enhanced-plugin/public/plugin';
import type { HasDynamicActions } from '@kbn/embeddable-enhanced-plugin/public';
import { EDITABLE_SAVED_SEARCH_KEYS } from './constants';

type DiscoverSearchHit = SearchHit<Record<string, unknown>>;

export interface EsHitRecord extends Omit<DiscoverSearchHit, '_index' | '_id' | '_source'> {
  _index?: DiscoverSearchHit['_index'];
  _id?: DiscoverSearchHit['_id'];
  _source?: DiscoverSearchHit['_source'];
}

/**
 * This is the record/row of data provided to our Data Table
 */
export interface DataTableRecord {
  /**
   * A unique id generated by index, id and routing of a record
   */
  id: string;
  /**
   * The document returned by Elasticsearch for search queries
   */
  raw: EsHitRecord;
  /**
   * A flattened version of the ES doc or data provided by SQL, aggregations ...
   */
  flattened: Record<string, unknown>;
  /**
   * Determines that the given doc is the anchor doc when rendering view surrounding docs
   */
  isAnchor?: boolean;
}

/**
 * Custom column types per column name
 */
export type DataTableColumnsMeta = Record<
  string,
  {
    type: DatatableColumnMeta['type'];
    esType?: DatatableColumnMeta['esType'];
  }
>;

type FormattedHitPair = readonly [
  fieldDisplayName: string,
  formattedValue: string,
  fieldName: string | null // `null` is when number of fields is limited and there is an extra pair about it
];

/**
 * Pairs array for each field in the hit
 */
export type FormattedHit = FormattedHitPair[];

export interface LogDocumentOverview
  extends LogResourceFields,
    LogStackTraceFields,
    LogCloudFields {
  '@timestamp': string;
  'log.level'?: string;
  message?: string;
  'error.message'?: string;
  'event.original'?: string;
  'trace.id'?: string;
  'log.file.path'?: string;
  'data_stream.namespace': string;
  'data_stream.dataset': string;
}

export interface LogResourceFields {
  'host.name'?: string;
  'service.name'?: string;
  'agent.name'?: string;
  'orchestrator.cluster.name'?: string;
  'orchestrator.cluster.id'?: string;
  'orchestrator.resource.id'?: string;
  'orchestrator.namespace'?: string;
  'container.name'?: string;
  'container.id'?: string;
}

export interface LogStackTraceFields {
  'error.stack_trace'?: string;
  'error.exception.stacktrace'?: string;
  'error.log.stacktrace'?: string;
}

export interface LogCloudFields {
  'cloud.provider'?: string;
  'cloud.region'?: string;
  'cloud.availability_zone'?: string;
  'cloud.project.id'?: string;
  'cloud.instance.id'?: string;
}

export interface TransactionDocumentOverview
  extends TraceFields,
    ServiceFields,
    TransactionFields,
    UserAgentFields {}

export interface SpanDocumentOverview
  extends TraceFields,
    ServiceFields,
    SpanFields,
    UserAgentFields {
  'transaction.id'?: string;
  'transaction.name'?: string;
}

export interface TraceFields {
  '@timestamp': number;
  'trace.id': string;
  'processor.event'?: 'span' | 'transaction';
  'parent.id'?: string;
  'http.response.status_code'?: number;
}

export interface ServiceFields {
  'service.name': string;
  'service.environment': string;
  'agent.name': string;
}

export interface TransactionFields {
  'transaction.id': string;
  'transaction.type': string;
  'transaction.name': string;
  'transaction.duration.us'?: number;
}

export interface SpanFields {
  'span.id': string;
  'span.name': string;
  'span.action': string;
  'span.duration.us': number;
  'span.type': string;
  'span.subtype': string;
  'span.destination.service.resource': string;
}

export interface UserAgentFields {
  'user_agent.name': string;
  'user_agent.version': string;
}

export type SearchEmbeddableState = Pick<
  SerializableSavedSearch,
  | 'rowHeight'
  | 'rowsPerPage'
  | 'headerRowHeight'
  | 'columns'
  | 'sort'
  | 'sampleSize'
  | 'viewMode'
  | 'grid'
  | 'density'
> & {
  rows: DataTableRecord[];
  columnsMeta: DataTableColumnsMeta | undefined;
  totalHitCount: number | undefined;
  inspectorAdapters: Record<string, unknown>;
};

export type SearchEmbeddableStateManager = {
  [key in keyof Required<SearchEmbeddableState>]: BehaviorSubject<SearchEmbeddableState[key]>;
};

export type SearchEmbeddableSerializedAttributes = Omit<
  SearchEmbeddableState,
  'rows' | 'columnsMeta' | 'totalHitCount' | 'searchSource' | 'inspectorAdapters'
> &
  Pick<SerializableSavedSearch, 'serializedSearchSource'>;

// These are options that are not persisted in the saved object, but can be used by solutions
// when utilising the SavedSearchComponent package outside of dashboard contexts.
export interface NonPersistedDisplayOptions {
  solutionNavIdOverride?: 'oblt' | 'security' | 'search';
  enableDocumentViewer?: boolean;
  enableFilters?: boolean;
}

export type EditableSavedSearchAttributes = Partial<
  Pick<SavedSearchAttributes, (typeof EDITABLE_SAVED_SEARCH_KEYS)[number]>
>;

export type SearchEmbeddableSerializedState = SerializedTitles &
  SerializedTimeRange &
  Partial<DynamicActionsSerializedState> &
  EditableSavedSearchAttributes & {
    // by value
    attributes?: SavedSearchAttributes & { references: SavedSearch['references'] };
    // by reference
    savedObjectId?: string;
    nonPersistedDisplayOptions?: NonPersistedDisplayOptions;
  };

export type SearchEmbeddableRuntimeState = SearchEmbeddableSerializedAttributes &
  SerializedTitles &
  SerializedTimeRange &
  Partial<DynamicActionsSerializedState> & {
    rawSavedObjectAttributes?: EditableSavedSearchAttributes;
    savedObjectTitle?: string;
    savedObjectId?: string;
    savedObjectDescription?: string;
    nonPersistedDisplayOptions?: NonPersistedDisplayOptions;
  };

export type SearchEmbeddableApi = DefaultEmbeddableApi<
  SearchEmbeddableSerializedState,
  SearchEmbeddableRuntimeState
> &
  PublishesSavedObjectId &
  PublishesDataLoading &
  PublishesBlockingError &
  PublishesWritableTitle &
  PublishesSavedSearch &
  PublishesWritableDataViews &
  PublishesWritableUnifiedSearch &
  HasLibraryTransforms &
  HasTimeRange &
  HasInspectorAdapters &
  Partial<HasEditCapabilities & PublishesSavedObjectId> &
  HasDynamicActions &
  HasSupportedTriggers;

export interface PublishesSavedSearch {
  savedSearch$: PublishingSubject<SavedSearch>;
}
export interface HasTimeRange {
  hasTimeRange(): boolean;
}
export interface SavedSearchCasesAttachmentPersistedState {
  index: string;
  timeRange?: TimeRange;
  query?: Query;
  filters?: Filter[];
  timestampField?: string;
}
