/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

/**
 * Babel plugin that transforms top-level require() calls into lazy-loaded getters.
 *
 *
 * @example
 * Input:
 *   const foo = require('./foo');
 *   const { bar, baz } = require('./utils');
 *   foo.doSomething();
 *
 * Output:
 *   const _module_foo = { initialized: false, value: undefined };
 *   const _module_utils = { initialized: false, value: undefined };
 *   const _imports = {
 *     get foo() {
 *       if (!_module_foo.initialized) {
 *         _module_foo.value = require('./foo');
 *         _module_foo.initialized = true;
 *       }
 *       return _module_foo.value;
 *     },
 *     get bar() {
 *       if (!_module_utils.initialized) {
 *         _module_utils.value = require('./utils');
 *         _module_utils.initialized = true;
 *       }
 *       return _module_utils.value.bar;
 *     },
 *     get baz() {
 *       if (!_module_utils.initialized) {
 *         _module_utils.value = require('./utils');
 *         _module_utils.initialized = true;
 *       }
 *       return _module_utils.value.baz;
 *     }
 *   };
 *   _imports.foo.doSomething();
 *
 * Note: require('./utils') is only called once even though both bar and baz
 * share the same module cache (_module_utils).
 */

module.exports = function lazyRequirePlugin({ types: t }) {
  /**
   * Check if an expression is a direct require() call with a string literal
   */
  function isSimpleRequireCall(node) {
    return (
      t.isCallExpression(node) &&
      t.isIdentifier(node.callee, { name: 'require' }) &&
      node.arguments.length === 1 &&
      t.isStringLiteral(node.arguments[0])
    );
  }

  return {
    name: 'kbn-lazy-require',
    visitor: {
      Program(programPath) {
        // Track modules by their require path (for shared caching)
        const modules = new Map();

        // Track properties by their variable name (what the user accesses)
        const properties = new Map();

        // Track declarations to remove (only remove after checking module-level usage)
        const declarationsToRemove = new Map(); // varName -> { type: 'import'|'require', path, index? }

        // Generate unique identifier for imports object
        const importsVar = programPath.scope.generateUidIdentifier('imports');

        // ============================================================
        // PHASE 1: Collect all top-level require declarations
        // ============================================================
        programPath.traverse({
          VariableDeclaration(path) {
            // Only transform top-level declarations
            if (path.parent !== programPath.node) {
              return;
            }

            const declarations = path.node.declarations;
            const declIndicesToRemove = [];

            for (let i = 0; i < declarations.length; i++) {
              const decl = declarations[i];

              let requirePath = null;
              let outerFunc = null;

              // Check for direct require: const foo = require('./foo')
              if (isSimpleRequireCall(decl.init)) {
                requirePath = decl.init.arguments[0].value;
              }
              // Check for wrapped require: const foo = _interopRequireDefault(require('./foo'))
              // This pattern is generated by Babel when transforming ES6 default imports
              else if (
                t.isCallExpression(decl.init) &&
                decl.init.arguments.length === 1 &&
                isSimpleRequireCall(decl.init.arguments[0])
              ) {
                requirePath = decl.init.arguments[0].arguments[0].value;
                outerFunc = decl.init.callee;
              }

              // Skip if we didn't find a require pattern
              if (!requirePath) {
                continue;
              }

              const isConst = path.node.kind === 'const';

              // Ensure module cache exists for this require path
              if (!modules.has(requirePath)) {
                modules.set(requirePath, {
                  cacheId: programPath.scope.generateUidIdentifier(`module`),
                  requirePath,
                  outerFunc,
                });
              }

              // Handle different declaration patterns
              if (t.isIdentifier(decl.id)) {
                // Simple: const foo = require('./foo')
                // Or wrapped: const foo = _interopRequireDefault(require('./foo'))
                const varName = decl.id.name;
                properties.set(varName, {
                  moduleRequirePath: requirePath,
                  propertyKey: null, // null = return entire module
                  isConst,
                });
                declIndicesToRemove.push(i);
                declarationsToRemove.set(varName, { type: 'require', path, index: i });
              } else if (t.isObjectPattern(decl.id)) {
                // Destructured: const { a, b } = require('./foo')
                let canTransform = true;

                // Verify all properties are simple identifier patterns
                for (const prop of decl.id.properties) {
                  if (
                    !t.isObjectProperty(prop) ||
                    !t.isIdentifier(prop.key) ||
                    !t.isIdentifier(prop.value) ||
                    prop.computed
                  ) {
                    canTransform = false;
                    break;
                  }
                }

                if (canTransform) {
                  for (const prop of decl.id.properties) {
                    const varName = prop.value.name;
                    const propKey = prop.key.name;

                    properties.set(varName, {
                      moduleRequirePath: requirePath,
                      propertyKey: propKey,
                      isConst,
                    });
                    // Store removal info for the first property (they all share the same declaration)
                    if (!declarationsToRemove.has(varName)) {
                      declarationsToRemove.set(varName, { type: 'require', path, index: i });
                    }
                  }
                  declIndicesToRemove.push(i);
                }
              }
            }

            // Don't remove yet - we'll check for module-level usage first
          },

          ImportDeclaration(path) {
            // Only transform top-level imports
            if (path.parent !== programPath.node) {
              return;
            }

            const importPath = path.node.source.value;
            const isConst = true; // imports are always const

            // Ensure module cache exists for this import path
            if (!modules.has(importPath)) {
              modules.set(importPath, {
                cacheId: programPath.scope.generateUidIdentifier(`module`),
                requirePath: importPath,
                outerFunc: null, // We'll handle interop manually for imports
              });
            }

            // Check if any imported names are re-exported
            let hasReExport = false;
            for (const specifier of path.node.specifiers) {
              const localName = specifier.local.name;
              const binding = path.scope.getBinding(localName);

              if (binding) {
                // Check if this binding is referenced in any export
                for (const refPath of binding.referencePaths) {
                  if (
                    refPath.isReferencedIdentifier() &&
                    (t.isExportSpecifier(refPath.parent) ||
                      t.isExportDefaultDeclaration(refPath.parent) ||
                      t.isExportNamedDeclaration(refPath.parent))
                  ) {
                    hasReExport = true;
                    break;
                  }
                }
              }
              if (hasReExport) break;
            }

            // Skip transformation if this import is re-exported
            if (hasReExport) {
              return;
            }

            // Handle different import types
            for (const specifier of path.node.specifiers) {
              if (t.isImportDefaultSpecifier(specifier)) {
                // import foo from './bar' -> foo = _interopRequireDefault(require('./bar')).default
                const varName = specifier.local.name;

                // We need to mark this as requiring interop AND accessing .default
                properties.set(varName, {
                  moduleRequirePath: importPath,
                  propertyKey: 'default',
                  isConst,
                  needsInterop: true,
                });
                declarationsToRemove.set(varName, { type: 'import', path });
              } else if (t.isImportNamespaceSpecifier(specifier)) {
                // import * as foo from './bar' -> foo = require('./bar')
                const varName = specifier.local.name;
                properties.set(varName, {
                  moduleRequirePath: importPath,
                  propertyKey: null, // entire module
                  isConst,
                });
                declarationsToRemove.set(varName, { type: 'import', path });
              } else if (t.isImportSpecifier(specifier)) {
                // import { foo } from './bar' -> foo = require('./bar').foo
                const varName = specifier.local.name;
                const importedName = specifier.imported.name;
                properties.set(varName, {
                  moduleRequirePath: importPath,
                  propertyKey: importedName,
                  isConst,
                });
                declarationsToRemove.set(varName, { type: 'import', path });
              }
            }

            // Don't remove yet - we'll check for top-level usage first
          },
        });

        // If no requires found, nothing to transform
        if (properties.size === 0) {
          return;
        }

        // ============================================================
        // PHASE 1.5: Detect module-level code that uses imports (skip lazy loading)
        // ============================================================
        // Module-level code runs during initialization, so lazy loading doesn't help
        // and can cause errors. We need to detect imports used in:
        // 1. Module-level variable initializers (including JSX)
        // 2. Module-level function calls (even if the import is used deep in the call chain)
        const importsUsedInModuleLevelCode = new Set();

        // Check code that runs at module initialization time
        programPath.traverse({
          // Check TypeScript import equals (export import alias = Module)
          // These create module-level aliases that must be eagerly evaluated
          TSImportEqualsDeclaration(tsImportPath) {
            // Can be at top level or inside a namespace
            // Possible paths:
            //   Program > TSImportEqualsDeclaration
            //   Program > TSModuleDeclaration > TSModuleBlock > TSImportEqualsDeclaration
            //   Program > ExportNamedDeclaration > TSModuleDeclaration > TSModuleBlock > TSImportEqualsDeclaration
            const isTopLevel = tsImportPath.parent === programPath.node;

            let isInTopLevelNamespace = false;
            if (t.isTSModuleBlock(tsImportPath.parent)) {
              const moduleDecl = tsImportPath.parentPath.parent;
              if (t.isTSModuleDeclaration(moduleDecl)) {
                // Check if namespace is at top level
                const moduleDeclPath = tsImportPath.parentPath.parentPath;
                const namespaceParent = moduleDeclPath.parent;
                isInTopLevelNamespace =
                  namespaceParent === programPath.node ||
                  (t.isExportNamedDeclaration(namespaceParent) &&
                    moduleDeclPath.parentPath.parent === programPath.node);
              }
            }

            if (!isTopLevel && !isInTopLevelNamespace) {
              return;
            }

            // Check if the moduleReference uses any of our imports
            tsImportPath.traverse({
              Identifier(idPath) {
                const name = idPath.node.name;
                if (properties.has(name) && idPath.isReferencedIdentifier()) {
                  importsUsedInModuleLevelCode.add(name);
                }
              },
            });
          },

          // Check top-level variable declarations
          VariableDeclaration(varDeclPath) {
            // Only check top-level declarations
            if (varDeclPath.parent !== programPath.node) {
              return;
            }

            // Skip our own import transformations
            if (
              varDeclPath.node.declarations.some(
                (decl) => decl.init && isSimpleRequireCall(decl.init)
              )
            ) {
              return;
            }

            // Check if any declarations' initializers use imports
            varDeclPath.traverse({
              Identifier(idPath) {
                const name = idPath.node.name;
                if (properties.has(name) && idPath.isReferencedIdentifier()) {
                  importsUsedInModuleLevelCode.add(name);
                }
              },
              // Also check JSXIdentifier for JSX element names
              JSXIdentifier(jsxIdPath) {
                const name = jsxIdPath.node.name;
                if (properties.has(name)) {
                  importsUsedInModuleLevelCode.add(name);
                }
              },
            });
          },

          // Check class static properties (they initialize when the class is defined)
          ClassProperty(classPropPath) {
            // Only check static properties in top-level classes
            // Path structure:
            //   Program > ClassDeclaration > ClassBody > ClassProperty
            //   OR Program > ExportDefaultDeclaration > ClassDeclaration > ClassBody > ClassProperty
            if (!classPropPath.node.static) {
              return;
            }

            // Walk up to find if this is a top-level class
            const classBody = classPropPath.parent;
            if (!t.isClassBody(classBody)) {
              return;
            }

            const classDecl = classPropPath.parentPath.parent;
            if (!t.isClassDeclaration(classDecl)) {
              return;
            }

            const classDeclPath = classPropPath.parentPath.parentPath;
            const classParent = classDeclPath.parent;

            // Check if class is at top level (direct) or exported (wrapped in export)
            const isTopLevel =
              classParent === programPath.node ||
              (t.isExportDefaultDeclaration(classParent) &&
                classDeclPath.parentPath.parent === programPath.node) ||
              (t.isExportNamedDeclaration(classParent) &&
                classDeclPath.parentPath.parent === programPath.node);

            if (!isTopLevel) {
              return;
            }

            // Check if the property initializer uses imports
            if (classPropPath.node.value) {
              classPropPath.traverse({
                Identifier(idPath) {
                  const name = idPath.node.name;
                  if (properties.has(name) && idPath.isReferencedIdentifier()) {
                    importsUsedInModuleLevelCode.add(name);
                  }
                },
                JSXIdentifier(jsxIdPath) {
                  const name = jsxIdPath.node.name;
                  if (properties.has(name)) {
                    importsUsedInModuleLevelCode.add(name);
                  }
                },
              });
            }
          },
        });

        // Remove imports/requires that are used in module-level code from transformation
        for (const varName of importsUsedInModuleLevelCode) {
          properties.delete(varName);
          declarationsToRemove.delete(varName);
        }

        // Remove modules that no longer have any properties
        const modulesToRemove = [];
        for (const [modulePath] of modules) {
          let hasProperties = false;
          for (const [, propInfo] of properties) {
            if (propInfo.moduleRequirePath === modulePath) {
              hasProperties = true;
              break;
            }
          }
          if (!hasProperties) {
            modulesToRemove.push(modulePath);
          }
        }
        for (const modulePath of modulesToRemove) {
          modules.delete(modulePath);
        }

        // If all imports are used in module-level code, nothing to transform
        if (properties.size === 0) {
          return;
        }

        // Remove declarations that we're transforming
        const requirePathsToProcess = new Set();
        const importPathsToRemove = new Set();

        for (const [varName, declInfo] of declarationsToRemove) {
          // Only process if this property is still being transformed
          if (properties.has(varName)) {
            if (declInfo.type === 'import') {
              importPathsToRemove.add(declInfo.path);
            } else if (declInfo.type === 'require') {
              requirePathsToProcess.add(declInfo.path);
            }
          }
        }

        // Handle import removals (can be partial)
        for (const importPath of importPathsToRemove) {
          // Check if ALL specifiers from this import are being transformed
          const specifiers = importPath.node.specifiers;
          const allTransformed = specifiers.every((spec) => {
            const localName = spec.local.name;
            return properties.has(localName);
          });

          if (allTransformed) {
            // Remove the entire import
            importPath.remove();
          } else {
            // Partial removal - only remove the specifiers we're transforming
            const remainingSpecifiers = specifiers.filter((spec) => {
              return !properties.has(spec.local.name);
            });
            importPath.node.specifiers = remainingSpecifiers;
          }
        }

        // Handle require removals
        for (const requirePath of requirePathsToProcess) {
          const declarations = requirePath.node.declarations;
          const indicesToRemove = [];

          for (let i = 0; i < declarations.length; i++) {
            const decl = declarations[i];
            // Check if this declaration should be removed
            let shouldRemove = false;

            if (t.isIdentifier(decl.id) && properties.has(decl.id.name)) {
              shouldRemove = true;
            } else if (t.isObjectPattern(decl.id)) {
              // Check if any property is being transformed
              const allPropsTransformed = decl.id.properties.every((prop) => {
                return (
                  t.isObjectProperty(prop) &&
                  t.isIdentifier(prop.value) &&
                  properties.has(prop.value.name)
                );
              });
              if (allPropsTransformed) {
                shouldRemove = true;
              }
            }

            if (shouldRemove) {
              indicesToRemove.push(i);
            }
          }

          // Remove in reverse order to maintain indices
          for (let i = indicesToRemove.length - 1; i >= 0; i--) {
            declarations.splice(indicesToRemove[i], 1);
          }

          // If all declarations removed, remove the entire statement
          if (declarations.length === 0) {
            requirePath.remove();
          }
        }

        // ============================================================
        // PHASE 2: Replace all usages with _imports.propertyName
        // ============================================================
        programPath.traverse({
          Identifier(path) {
            const varName = path.node.name;

            // Skip if this identifier is not one of our tracked properties
            if (!properties.has(varName)) {
              return;
            }

            // Skip variable/function declarations
            if (
              (t.isVariableDeclarator(path.parent) && path.parent.id === path.node) ||
              (t.isFunctionDeclaration(path.parent) && path.parent.id === path.node)
            ) {
              return;
            }

            // Skip export/import specifiers (e.g., 'foo' in 'export { foo }' or 'import { foo }')
            if (
              t.isExportSpecifier(path.parent) ||
              t.isImportSpecifier(path.parent) ||
              t.isImportDefaultSpecifier(path.parent) ||
              t.isImportNamespaceSpecifier(path.parent) ||
              t.isTSImportEqualsDeclaration(path.parent)
            ) {
              return;
            }

            // Skip object property keys (non-computed)
            if (
              (t.isObjectProperty(path.parent) || t.isObjectMethod(path.parent)) &&
              path.parent.key === path.node &&
              !path.parent.computed
            ) {
              return;
            }

            // Skip member expression properties (e.g., 'bar' in 'foo.bar' or 'foo?.bar')
            if (
              (t.isMemberExpression(path.parent) || t.isOptionalMemberExpression(path.parent)) &&
              path.parent.property === path.node &&
              !path.parent.computed
            ) {
              return;
            }

            // Skip class method/property keys
            if (
              (t.isClassMethod(path.parent) || t.isClassProperty(path.parent)) &&
              path.parent.key === path.node &&
              !path.parent.computed
            ) {
              return;
            }

            // Skip TypeScript type annotations (types are not runtime code)
            // But allow type assertions (as Type) and other runtime TS features
            let currentPath = path;
            while (currentPath) {
              const parentNode = currentPath.parent;
              if (!parentNode) break;

              // Skip only pure type contexts, not runtime contexts with type info
              if (
                parentNode.type &&
                (t.isTSTypeAnnotation(parentNode) ||
                  t.isTSTypeReference(parentNode) ||
                  t.isTSTypeParameterDeclaration(parentNode) ||
                  t.isTSTypeParameter(parentNode) ||
                  t.isTSInterfaceDeclaration(parentNode) ||
                  t.isTSTypeAliasDeclaration(parentNode) ||
                  t.isTSTypeQuery(parentNode) ||
                  t.isTSTypeLiteral(parentNode) ||
                  t.isTSIndexedAccessType(parentNode) ||
                  t.isTSMappedType(parentNode) ||
                  t.isTSConditionalType(parentNode) ||
                  t.isTSExpressionWithTypeArguments(parentNode))
              ) {
                return;
              }

              currentPath = currentPath.parentPath;
            }

            // Check scope: only replace if binding is from program scope
            const binding = path.scope.getBinding(varName);
            if (binding && binding.scope !== programPath.scope) {
              // This is a local variable shadowing our import, don't replace
              return;
            }

            // Replace: foo â†’ _imports.foo
            path.replaceWith(t.memberExpression(importsVar, t.identifier(varName)));
          },
        });

        // ============================================================
        // PHASE 3: Generate module cache variables
        // ============================================================
        const moduleCacheDeclarations = [];

        for (const [, moduleInfo] of modules) {
          moduleCacheDeclarations.push(
            t.variableDeclaration('const', [
              t.variableDeclarator(
                moduleInfo.cacheId,
                t.objectExpression([
                  t.objectProperty(t.identifier('initialized'), t.booleanLiteral(false)),
                  t.objectProperty(t.identifier('value'), t.identifier('undefined')),
                ])
              ),
            ])
          );
        }

        // ============================================================
        // PHASE 4: Generate _imports object with getters/setters
        // ============================================================

        // Check if we need _interopRequireDefault helper
        let needsInteropHelper = false;
        for (const [, propInfo] of properties) {
          if (propInfo.needsInterop) {
            needsInteropHelper = true;
            break;
          }
        }

        const importProperties = [];

        for (const [varName, propInfo] of properties) {
          const moduleInfo = modules.get(propInfo.moduleRequirePath);
          const cacheId = moduleInfo.cacheId;

          // Build the require expression: require('path')
          // IMPORTANT: Always store the RAW require() result in the cache
          // We'll apply _interopRequireDefault only when returning for default imports
          let requireExpression = t.callExpression(t.identifier('require'), [
            t.stringLiteral(propInfo.moduleRequirePath),
          ]);

          // Wrap with outer function if present (e.g., from already-transformed code)
          if (moduleInfo.outerFunc) {
            requireExpression = t.callExpression(moduleInfo.outerFunc, [requireExpression]);
          }

          // References to cache fields
          const cacheInitialized = t.memberExpression(cacheId, t.identifier('initialized'));
          const cacheValue = t.memberExpression(cacheId, t.identifier('value'));

          // Determine what to return from getter
          let returnExpression;
          if (propInfo.needsInterop) {
            // Default import: apply _interopRequireDefault and access .default
            // return _interopRequireDefault(_module.value).default
            returnExpression = t.memberExpression(
              t.callExpression(t.identifier('_interopRequireDefault'), [cacheValue]),
              t.identifier('default')
            );
          } else if (propInfo.propertyKey === null) {
            // Full module (namespace import): return _module.value
            returnExpression = cacheValue;
          } else {
            // Named import: return _module.value.propertyKey
            returnExpression = t.memberExpression(cacheValue, t.identifier(propInfo.propertyKey));
          }

          // Create getter
          importProperties.push(
            t.objectMethod(
              'get',
              t.identifier(varName),
              [],
              t.blockStatement([
                // if (!_module_foo.initialized) {
                t.ifStatement(
                  t.unaryExpression('!', cacheInitialized),
                  t.blockStatement([
                    // _module_foo.value = require('...') or _interopRequireDefault(require('...'));
                    t.expressionStatement(
                      t.assignmentExpression('=', cacheValue, requireExpression)
                    ),
                    // _module_foo.initialized = true;
                    t.expressionStatement(
                      t.assignmentExpression('=', cacheInitialized, t.booleanLiteral(true))
                    ),
                  ])
                ),
                // return _module_foo.value (or .value.prop)
                t.returnStatement(returnExpression),
              ])
            )
          );

          // Create setter for non-const declarations
          if (!propInfo.isConst) {
            importProperties.push(
              t.objectMethod(
                'set',
                t.identifier(varName),
                [t.identifier('newValue')],
                t.blockStatement([
                  // Ensure module is loaded first (for side effects)
                  t.ifStatement(
                    t.unaryExpression('!', cacheInitialized),
                    t.blockStatement([
                      t.expressionStatement(
                        t.assignmentExpression('=', cacheValue, requireExpression)
                      ),
                      t.expressionStatement(
                        t.assignmentExpression('=', cacheInitialized, t.booleanLiteral(true))
                      ),
                    ])
                  ),
                  // Now set the value
                  t.expressionStatement(
                    t.assignmentExpression('=', cacheValue, t.identifier('newValue'))
                  ),
                ])
              )
            );
          }
        }

        // ============================================================
        // PHASE 5: Insert generated code at top of file
        // ============================================================

        // Insert _imports object
        programPath.unshiftContainer(
          'body',
          t.variableDeclaration('const', [
            t.variableDeclarator(importsVar, t.objectExpression(importProperties)),
          ])
        );

        // Insert _interopRequireDefault helper if needed for default imports
        if (needsInteropHelper) {
          programPath.unshiftContainer(
            'body',
            t.variableDeclaration('const', [
              t.variableDeclarator(
                t.identifier('_interopRequireDefault'),
                t.callExpression(t.identifier('require'), [
                  t.stringLiteral('@babel/runtime/helpers/interopRequireDefault'),
                ])
              ),
            ])
          );
        }

        // Insert module cache variables (in reverse to maintain order)
        for (let i = moduleCacheDeclarations.length - 1; i >= 0; i--) {
          programPath.unshiftContainer('body', moduleCacheDeclarations[i]);
        }
      },
    },
  };
};
