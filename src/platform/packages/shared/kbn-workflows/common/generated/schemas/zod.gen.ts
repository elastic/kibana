// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const types_id = z.string();

/**
 * Time unit for milliseconds
 */
export const types_unit_millis = z.number().register(z.globalRegistry, {
    description: "Time unit for milliseconds"
});

export const types_duration_value_unit_millis = types_unit_millis;

/**
 * A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
 * `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
 */
export const types_duration = z.union([
    z.string(),
    z.enum([
        '-1'
    ]),
    z.enum([
        '0'
    ])
]);

/**
 * Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
 */
export const types_field = z.string().register(z.globalRegistry, {
    description: "Path to field or array of paths. Some API's support wildcards in the path to select multiple fields."
});

export const types_uint = z.number();

export const types_epoch_time_unit_millis = types_unit_millis;

export const types_version_string = z.string();

/**
 * A date and time, either as a string whose format can depend on the context (defaulting to ISO 8601), or a
 * number of milliseconds since the Epoch. Elasticsearch accepts both as input, but will generally output a string
 * representation.
 */
export const types_date_time = z.union([
    z.string(),
    types_epoch_time_unit_millis
]);

export const types_sequence_number = z.number();

export const types_metadata = z.record(z.string(), z.record(z.string(), z.unknown()));

export const types_search_type = z.enum([
    'query_then_fetch',
    'dfs_query_then_fetch'
]);

export const types_expand_wildcard = z.enum([
    'all',
    'open',
    'closed',
    'hidden',
    'none'
]);

export const types_expand_wildcards = z.union([
    types_expand_wildcard,
    z.array(types_expand_wildcard)
]);

export const types_query_dsl_query_base = z.object({
    boost: z.optional(z.number().register(z.globalRegistry, {
        description: "Floating point number used to decrease or increase the relevance scores of the query.\nBoost values are relative to the default value of 1.0.\nA boost value between 0 and 1.0 decreases the relevance score.\nA value greater than 1.0 increases the relevance score."
    })).default(1),
    _name: z.optional(z.string())
});

export const types_query_dsl_type_query = types_query_dsl_query_base.and(z.object({
    value: z.string()
}));

export const types_query_dsl_wrapper_query = types_query_dsl_query_base.and(z.object({
    query: z.string().register(z.globalRegistry, {
        description: "A base64 encoded query.\nThe binary data format can be any of JSON, YAML, CBOR or SMILE encodings"
    })
}));

export const types_multi_term_query_rewrite = z.string();

export const types_query_dsl_wildcard_query = types_query_dsl_query_base.and(z.object({
    case_insensitive: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Allows case insensitive matching of the pattern with the indexed field values when set to true. Default is false which means the case sensitivity of matching depends on the underlying field’s mapping."
    })),
    rewrite: z.optional(types_multi_term_query_rewrite),
    value: z.optional(z.string().register(z.globalRegistry, {
        description: "Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set."
    })),
    wildcard: z.optional(z.string().register(z.globalRegistry, {
        description: "Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set."
    }))
}));

export const types_token_pruning_config = z.object({
    tokens_freq_ratio_threshold: z.optional(z.number().register(z.globalRegistry, {
        description: "Tokens whose frequency is more than this threshold times the average frequency of all tokens in the specified field are considered outliers and pruned."
    })).default(5),
    tokens_weight_threshold: z.optional(z.number().register(z.globalRegistry, {
        description: "Tokens whose weight is less than this threshold are considered nonsignificant and pruned."
    })).default(0.4),
    only_score_pruned_tokens: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Whether to only score pruned tokens, vs only scoring kept tokens."
    })).default(false)
});

export const types_query_dsl_weighted_tokens_query = types_query_dsl_query_base.and(z.object({
    tokens: z.union([
        z.record(z.string(), z.number()),
        z.array(z.record(z.string(), z.number()))
    ]),
    pruning_config: z.optional(types_token_pruning_config)
}));

export const types_query_dsl_text_expansion_query = types_query_dsl_query_base.and(z.object({
    model_id: z.string().register(z.globalRegistry, {
        description: "The text expansion NLP model to use"
    }),
    model_text: z.string().register(z.globalRegistry, {
        description: "The query text"
    }),
    pruning_config: z.optional(types_token_pruning_config)
}));

export const types_script_language = z.union([
    z.enum([
        'painless',
        'expression',
        'mustache',
        'java'
    ]),
    z.string()
]);

export const types_mapping_runtime_field_fetch_fields = z.object({
    field: types_field,
    format: z.optional(z.string())
});

export const types_mapping_runtime_field_type = z.enum([
    'boolean',
    'composite',
    'date',
    'double',
    'geo_point',
    'geo_shape',
    'ip',
    'keyword',
    'long',
    'lookup'
]);

export const types_mapping_composite_sub_field = z.object({
    type: types_mapping_runtime_field_type
});

export const types_index_name = z.string();

export const global_search_types_point_in_time_reference = z.object({
    id: types_id,
    keep_alive: z.optional(types_duration)
});

export const global_search_types_suggester = z.object({
    text: z.optional(z.string().register(z.globalRegistry, {
        description: "Global suggest text, to avoid repetition when the same text is used in several suggesters"
    }))
});

export const types_sliced_scroll = z.object({
    field: z.optional(types_field),
    id: types_id,
    max: z.number()
});

export const types_specified_document = z.object({
    index: z.optional(types_index_name),
    id: types_id
});

export const types_score_normalizer = z.enum([
    'none',
    'minmax',
    'l2_norm'
]);

export const types_query_dsl_terms_query = types_query_dsl_query_base.and(z.record(z.string(), z.unknown()));

/**
 * A field value.
 */
export const types_field_value = z.union([
    z.number(),
    z.string(),
    z.boolean(),
    z.null()
]);

export const types_query_dsl_term_query = types_query_dsl_query_base.and(z.object({
    value: types_field_value,
    case_insensitive: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nWhen `false`, the case sensitivity of matching depends on the underlying field’s mapping."
    })).default(false)
}));

export const types_query_dsl_sparse_vector_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    query: z.optional(z.string().register(z.globalRegistry, {
        description: "The query text you want to use for search.\nIf inference_id is specified, query must also be specified."
    })),
    prune: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Whether to perform pruning, omitting the non-significant tokens from the query to improve query performance.\nIf prune is true but the pruning_config is not specified, pruning will occur but default values will be used.\nDefault: false"
    })),
    pruning_config: z.optional(types_token_pruning_config)
}).and(z.object({
    query_vector: z.optional(z.record(z.string(), z.number()).register(z.globalRegistry, {
        description: "Dictionary of precomputed sparse vectors and their associated weights.\nOnly one of inference_id or query_vector may be supplied in a request."
    })),
    inference_id: z.optional(types_id)
})));

export const types_query_dsl_span_term_query = types_query_dsl_query_base.and(z.object({
    value: types_field_value
}));

/**
 * Can only be used as a clause in a span_near query.
 */
export const types_query_dsl_span_gap_query = z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "Can only be used as a clause in a span_near query."
});

export const types_query_dsl_simple_query_string_flag = z.enum([
    'NONE',
    'AND',
    'NOT',
    'OR',
    'PREFIX',
    'PHRASE',
    'PRECEDENCE',
    'ESCAPE',
    'WHITESPACE',
    'FUZZY',
    'NEAR',
    'SLOP',
    'ALL'
]);

/**
 * A set of flags that can be represented as a single enum value or a set of values that are encoded
 * as a pipe-separated string
 *
 * Depending on the target language, code generators can use this hint to generate language specific
 * flags enum constructs and the corresponding (de-)serialization code.
 */
export const spec_utils_pipe_separated_flags_simple_query_string_flag = z.union([
    types_query_dsl_simple_query_string_flag,
    z.string()
]);

/**
 * Query flags can be either a single flag or a combination of flags, e.g. `OR|AND|PREFIX`
 */
export const types_query_dsl_simple_query_string_flags = spec_utils_pipe_separated_flags_simple_query_string_flag;

/**
 * The minimum number of terms that should match as integer, percentage or range
 */
export const types_minimum_should_match = z.union([
    z.number(),
    z.string()
]);

export const types_query_dsl_operator = z.enum([
    'and',
    'AND',
    'or',
    'OR'
]);

export const types_query_dsl_simple_query_string_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to convert text in the query string into tokens."
    })),
    analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the query attempts to analyze wildcard terms in the query string."
    })).default(false),
    auto_generate_synonyms_phrase_query: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the parser creates a match_phrase query for each multi-position token."
    })).default(true),
    default_operator: z.optional(types_query_dsl_operator),
    fields: z.optional(z.array(types_field).register(z.globalRegistry, {
        description: "Array of fields you wish to search.\nAccepts wildcard expressions.\nYou also can boost relevance scores for matches to particular fields using a caret (`^`) notation.\nDefaults to the `index.query.default_field index` setting, which has a default value of `*`."
    })),
    flags: z.optional(types_query_dsl_simple_query_string_flags),
    fuzzy_max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of terms to which the query expands for fuzzy matching."
    })).default(50),
    fuzzy_prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: "Number of beginning characters left unchanged for fuzzy matching."
    })).default(0),
    fuzzy_transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`)."
    })),
    lenient: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, format-based errors, such as providing a text value for a numeric field, are ignored."
    })).default(false),
    minimum_should_match: z.optional(types_minimum_should_match),
    query: z.string().register(z.globalRegistry, {
        description: "Query string in the simple query string syntax you wish to parse and use for search."
    }),
    quote_field_suffix: z.optional(z.string().register(z.globalRegistry, {
        description: "Suffix appended to quoted text in the query string."
    }))
}));

export const types_query_dsl_shape_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: "When set to `true` the query ignores an unmapped field and will not match any documents."
    }))
}));

export const types_query_dsl_semantic_query = types_query_dsl_query_base.and(z.object({
    field: z.string().register(z.globalRegistry, {
        description: "The field to query, which must be a semantic_text field type"
    }),
    query: z.string().register(z.globalRegistry, {
        description: "The query text"
    })
}));

export const global_search_types_learning_to_rank = z.object({
    model_id: z.string().register(z.globalRegistry, {
        description: "The unique identifier of the trained model uploaded to Elasticsearch"
    }),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "Named parameters to be passed to the query templates used for feature"
    }))
});

export const global_search_types_score_mode = z.enum([
    'avg',
    'max',
    'min',
    'multiply',
    'total'
]);

export const types_mapping_chunk_rescorer_chunking_settings = z.object({
    strategy: z.optional(z.string().register(z.globalRegistry, {
        description: "The chunking strategy: `sentence`, `word`, `none` or `recursive`.\n\n * If `strategy` is set to `recursive`, you must also specify:\n\n- `max_chunk_size`\n- either `separators` or`separator_group`\n\nLearn more about different chunking strategies in the linked documentation."
    })).default('sentence'),
    separator_group: z.optional(z.string().register(z.globalRegistry, {
        description: "Only applicable to the `recursive` strategy and required when using it.\n\nSets a predefined list of separators in the saved chunking settings based on the selected text type.\nValues can be `markdown` or `plaintext`.\n\nUsing this parameter is an alternative to manually specifying a custom `separators` list."
    })),
    separators: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: "Only applicable to the `recursive` strategy and required when using it.\n\nA list of strings used as possible split points when chunking text.\n\nEach string can be a plain string or a regular expression (regex) pattern.\nThe system tries each separator in order to split the text, starting from the first item in the list.\n\nAfter splitting, it attempts to recombine smaller pieces into larger chunks that stay within\nthe `max_chunk_size` limit, to reduce the total number of chunks generated."
    })),
    max_chunk_size: z.number().register(z.globalRegistry, {
        description: "The maximum size of a chunk in words.\nThis value cannot be lower than `20` (for `sentence` strategy) or `10` (for `word` strategy).\nThis value should not exceed the window size for the associated model."
    }).default(250),
    overlap: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of overlapping words for chunks.\nIt is applicable only to a `word` chunking strategy.\nThis value cannot be higher than half the `max_chunk_size` value."
    })).default(100),
    sentence_overlap: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of overlapping sentences for chunks.\nIt is applicable only for a `sentence` chunking strategy.\nIt can be either `1` or `0`."
    })).default(1)
});

export const types_chunk_rescorer = z.object({
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of chunks per document to evaluate for reranking."
    })),
    chunking_settings: z.optional(types_mapping_chunk_rescorer_chunking_settings)
});

export const types_rescore_vector = z.object({
    oversample: z.number().register(z.globalRegistry, {
        description: "Applies the specified oversample factor to k on the approximate kNN search"
    })
});

export const types_text_embedding = z.object({
    model_id: z.optional(z.string().register(z.globalRegistry, {
        description: "Model ID is required for all dense_vector fields but\nmay be inferred for semantic_text fields"
    })),
    model_text: z.string()
});

export const types_query_vector_builder = z.object({
    text_embedding: z.optional(types_text_embedding)
});

export const types_query_vector = z.array(z.number());

export const types_sort_results = z.array(types_field_value);

export const types_fields = z.union([
    types_field,
    z.array(types_field)
]);

export const global_search_types_source_filter = z.object({
    exclude_vectors: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, vector fields are excluded from the returned source.\n\nThis option takes precedence over `includes`: any vector field will\nremain excluded even if it matches an `includes` rule."
    })),
    excludes: z.optional(types_fields),
    includes: z.optional(types_fields)
});

/**
 * Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.
 */
export const global_search_types_source_config = z.union([
    z.boolean(),
    global_search_types_source_filter
]);

export const global_search_types_highlighter_tags_schema = z.enum([
    'styled'
]);

export const global_search_types_highlighter_order = z.enum([
    'score'
]);

export const global_search_types_highlighter_fragmenter = z.enum([
    'simple',
    'span'
]);

export const global_search_types_boundary_scanner = z.enum([
    'chars',
    'sentence',
    'word'
]);

export const global_search_types_highlighter_type = z.union([
    z.enum([
        'plain',
        'fvh',
        'unified'
    ]),
    z.string()
]);

export const global_search_types_highlighter_encoder = z.enum([
    'default',
    'html'
]);

/**
 * A reference to a field with formatting instructions on how to return the value
 */
export const types_query_dsl_field_and_format = z.object({
    field: types_field,
    format: z.optional(z.string().register(z.globalRegistry, {
        description: "The format in which the values are returned."
    })),
    include_unmapped: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: "A reference to a field with formatting instructions on how to return the value"
});

export const types_name = z.string();

export const types_script_sort_type = z.enum([
    'string',
    'number',
    'version'
]);

export const types_sort_mode = z.enum([
    'min',
    'max',
    'sum',
    'avg',
    'median'
]);

export const types_sort_order = z.enum([
    'asc',
    'desc'
]);

export const types_distance_unit = z.enum([
    'in',
    'ft',
    'yd',
    'mi',
    'nmi',
    'km',
    'm',
    'cm',
    'mm'
]);

export const types_geo_distance_type = z.enum([
    'arc',
    'plane'
]);

export const types_score_sort = z.object({
    order: z.optional(types_sort_order)
});

export const types_rank_base = z.record(z.string(), z.unknown());

export const types_rrf_rank = types_rank_base.and(z.object({
    rank_constant: z.optional(z.number().register(z.globalRegistry, {
        description: "How much influence documents in individual result sets per query have over the final ranked result set"
    })),
    rank_window_size: z.optional(z.number().register(z.globalRegistry, {
        description: "Size of the individual result sets per query"
    }))
}));

export const types_rank_container = z.object({
    rrf: z.optional(types_rrf_rank)
});

/**
 * Number of hits matching the query to count accurately. If true, the exact
 * number of hits is returned at the cost of some performance. If false, the
 * response does not include the total number of hits matching the query.
 * Defaults to 10,000 hits.
 */
export const global_search_types_track_hits = z.union([
    z.boolean(),
    z.number()
]);

export const types_aggregations_value_type = z.enum([
    'string',
    'long',
    'double',
    'number',
    'date',
    'date_nanos',
    'ip',
    'numeric',
    'geo_point',
    'boolean'
]);

export const types_aggregations_aggregation = z.record(z.string(), z.unknown());

export const types_aggregations_missing = z.union([
    z.string(),
    z.number(),
    z.boolean()
]);

export const types_aggregations_top_metrics_value = z.object({
    field: types_field
});

export const types_aggregations_t_test_type = z.enum([
    'paired',
    'homoscedastic',
    'heteroscedastic'
]);

export const types_query_dsl_regexp_query = types_query_dsl_query_base.and(z.object({
    case_insensitive: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Allows case insensitive matching of the regular expression value with the indexed field values when set to `true`.\nWhen `false`, case sensitivity of matching depends on the underlying field’s mapping."
    })).default(false),
    flags: z.optional(z.string().register(z.globalRegistry, {
        description: "Enables optional operators for the regular expression."
    })),
    max_determinized_states: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of automaton states required for the query."
    })).default(10000),
    rewrite: z.optional(types_multi_term_query_rewrite),
    value: z.string().register(z.globalRegistry, {
        description: "Regular expression for terms you wish to find in the provided field."
    })
}));

export const types_query_dsl_rank_feature_function = z.record(z.string(), z.unknown());

export const types_query_dsl_rank_feature_function_sigmoid = types_query_dsl_rank_feature_function.and(z.object({
    pivot: z.number().register(z.globalRegistry, {
        description: "Configurable pivot value so that the result will be less than 0.5."
    }),
    exponent: z.number().register(z.globalRegistry, {
        description: "Configurable Exponent."
    })
}));

export const types_query_dsl_rank_feature_function_linear = types_query_dsl_rank_feature_function.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_rank_feature_function_logarithm = types_query_dsl_rank_feature_function.and(z.object({
    scaling_factor: z.number().register(z.globalRegistry, {
        description: "Configurable scaling factor."
    })
}));

export const types_query_dsl_rank_feature_function_saturation = types_query_dsl_rank_feature_function.and(z.object({
    pivot: z.optional(z.number().register(z.globalRegistry, {
        description: "Configurable pivot value so that the result will be less than 0.5."
    }))
}));

export const types_query_dsl_rank_feature_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    saturation: z.optional(types_query_dsl_rank_feature_function_saturation),
    log: z.optional(types_query_dsl_rank_feature_function_logarithm),
    linear: z.optional(types_query_dsl_rank_feature_function_linear),
    sigmoid: z.optional(types_query_dsl_rank_feature_function_sigmoid)
}));

export const types_query_dsl_range_relation = z.enum([
    'within',
    'contains',
    'intersects'
]);

export const types_query_dsl_range_query_basestring = types_query_dsl_query_base.and(z.object({
    relation: z.optional(types_query_dsl_range_relation),
    gt: z.optional(z.string().register(z.globalRegistry, {
        description: "Greater than."
    })),
    gte: z.optional(z.string().register(z.globalRegistry, {
        description: "Greater than or equal to."
    })),
    lt: z.optional(z.string().register(z.globalRegistry, {
        description: "Less than."
    })),
    lte: z.optional(z.string().register(z.globalRegistry, {
        description: "Less than or equal to."
    }))
}));

export const types_query_dsl_term_range_query = types_query_dsl_range_query_basestring.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_range_query_basedouble = types_query_dsl_query_base.and(z.object({
    relation: z.optional(types_query_dsl_range_relation),
    gt: z.optional(z.number().register(z.globalRegistry, {
        description: "Greater than."
    })),
    gte: z.optional(z.number().register(z.globalRegistry, {
        description: "Greater than or equal to."
    })),
    lt: z.optional(z.number().register(z.globalRegistry, {
        description: "Less than."
    })),
    lte: z.optional(z.number().register(z.globalRegistry, {
        description: "Less than or equal to."
    }))
}));

export const types_query_dsl_number_range_query = types_query_dsl_range_query_basedouble.and(z.record(z.string(), z.unknown()));

export const types_date_math = z.string();

export const types_query_dsl_range_query_base_date_math = types_query_dsl_query_base.and(z.object({
    relation: z.optional(types_query_dsl_range_relation),
    gt: z.optional(types_date_math),
    gte: z.optional(types_date_math),
    lt: z.optional(types_date_math),
    lte: z.optional(types_date_math)
}));

export const types_time_zone = z.string();

export const types_date_format = z.string();

export const types_query_dsl_date_range_query = types_query_dsl_range_query_base_date_math.and(z.object({
    format: z.optional(types_date_format),
    time_zone: z.optional(types_time_zone)
}));

export const types_query_dsl_range_query_base = types_query_dsl_query_base.and(z.object({
    relation: z.optional(types_query_dsl_range_relation),
    gt: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: "Greater than."
    })),
    gte: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: "Greater than or equal to."
    })),
    lt: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: "Less than."
    })),
    lte: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: "Less than or equal to."
    }))
}));

export const types_query_dsl_untyped_range_query = types_query_dsl_range_query_base.and(z.object({
    format: z.optional(types_date_format),
    time_zone: z.optional(types_time_zone)
}));

export const types_query_dsl_range_query = z.union([
    types_query_dsl_untyped_range_query,
    types_query_dsl_date_range_query,
    types_query_dsl_number_range_query,
    types_query_dsl_term_range_query
]);

export const types_query_dsl_text_query_type = z.enum([
    'best_fields',
    'most_fields',
    'cross_fields',
    'phrase',
    'phrase_prefix',
    'bool_prefix'
]);

export const types_fuzziness = z.union([
    z.string(),
    z.number()
]);

export const types_query_dsl_query_string_query = types_query_dsl_query_base.and(z.object({
    allow_leading_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the wildcard characters `*` and `?` are allowed as the first character of the query string."
    })).default(true),
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to convert text in the query string into tokens."
    })),
    analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the query attempts to analyze wildcard terms in the query string."
    })).default(false),
    auto_generate_synonyms_phrase_query: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, match phrase queries are automatically created for multi-term synonyms."
    })).default(true),
    default_field: z.optional(types_field),
    default_operator: z.optional(types_query_dsl_operator),
    enable_position_increments: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, enable position increments in queries constructed from a `query_string` search."
    })).default(true),
    escape: z.optional(z.boolean()).default(false),
    fields: z.optional(z.array(types_field).register(z.globalRegistry, {
        description: "Array of fields to search. Supports wildcards (`*`)."
    })),
    fuzziness: z.optional(types_fuzziness),
    fuzzy_max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of terms to which the query expands for fuzzy matching."
    })).default(50),
    fuzzy_prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: "Number of beginning characters left unchanged for fuzzy matching."
    })).default(0),
    fuzzy_rewrite: z.optional(types_multi_term_query_rewrite),
    fuzzy_transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`)."
    })).default(true),
    lenient: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, format-based errors, such as providing a text value for a numeric field, are ignored."
    })).default(false),
    max_determinized_states: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of automaton states required for the query."
    })).default(10000),
    minimum_should_match: z.optional(types_minimum_should_match),
    phrase_slop: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of positions allowed between matching tokens for phrases."
    })).default(0),
    query: z.string().register(z.globalRegistry, {
        description: "Query string you wish to parse and use for search."
    }),
    quote_analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to convert quoted text in the query string into tokens.\nFor quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter."
    })),
    quote_field_suffix: z.optional(z.string().register(z.globalRegistry, {
        description: "Suffix appended to quoted text in the query string.\nYou can use this suffix to use a different analysis method for exact matches."
    })),
    rewrite: z.optional(types_multi_term_query_rewrite),
    tie_breaker: z.optional(z.number().register(z.globalRegistry, {
        description: "How to combine the queries generated from the individual search terms in the resulting `dis_max` query."
    })),
    time_zone: z.optional(types_time_zone),
    type: z.optional(types_query_dsl_text_query_type)
}));

export const types_query_dsl_prefix_query = types_query_dsl_query_base.and(z.object({
    rewrite: z.optional(types_multi_term_query_rewrite),
    value: z.string().register(z.globalRegistry, {
        description: "Beginning characters of terms you wish to find in the provided field."
    }),
    case_insensitive: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nDefault is `false` which means the case sensitivity of matching depends on the underlying field’s mapping."
    })).default(false)
}));

export const types_query_dsl_pinned_doc = z.object({
    _id: types_id,
    _index: z.optional(types_index_name)
});

export const types_version_number = z.number();

export const types_routing = z.string();

export const types_query_dsl_percolate_query = types_query_dsl_query_base.and(z.object({
    document: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: "The source of the document being percolated."
    })),
    documents: z.optional(z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "An array of sources of the documents being percolated."
    })),
    field: types_field,
    id: z.optional(types_id),
    index: z.optional(types_index_name),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: "The suffix used for the `_percolator_document_slot` field when multiple `percolate` queries are specified."
    })),
    preference: z.optional(z.string().register(z.globalRegistry, {
        description: "Preference used to fetch document to percolate."
    })),
    routing: z.optional(types_routing),
    version: z.optional(types_version_number)
}));

export const types_relation_name = z.string();

export const types_query_dsl_parent_id_query = types_query_dsl_query_base.and(z.object({
    id: z.optional(types_id),
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Indicates whether to ignore an unmapped `type` and not return any documents instead of an error."
    })).default(false),
    type: z.optional(types_relation_name)
}));

export const types_query_dsl_child_score_mode = z.enum([
    'none',
    'avg',
    'sum',
    'max',
    'min'
]);

export const types_query_dsl_zero_terms_query = z.enum([
    'all',
    'none'
]);

export const types_query_dsl_multi_match_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to convert the text in the query value into tokens."
    })),
    auto_generate_synonyms_phrase_query: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, match phrase queries are automatically created for multi-term synonyms."
    })).default(true),
    cutoff_frequency: z.optional(z.number()),
    fields: z.optional(types_fields),
    fuzziness: z.optional(types_fuzziness),
    fuzzy_rewrite: z.optional(types_multi_term_query_rewrite),
    fuzzy_transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term."
    })).default(true),
    lenient: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored."
    })).default(false),
    max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of terms to which the query will expand."
    })).default(50),
    minimum_should_match: z.optional(types_minimum_should_match),
    operator: z.optional(types_query_dsl_operator),
    prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: "Number of beginning characters left unchanged for fuzzy matching."
    })).default(0),
    query: z.string().register(z.globalRegistry, {
        description: "Text, number, boolean value or date you wish to find in the provided field."
    }),
    slop: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of positions allowed between matching tokens."
    })).default(0),
    tie_breaker: z.optional(z.number().register(z.globalRegistry, {
        description: "Determines how scores for each per-term blended query and scores across groups are combined."
    })).default(0),
    type: z.optional(types_query_dsl_text_query_type),
    zero_terms_query: z.optional(types_query_dsl_zero_terms_query)
}));

export const types_analysis_stop_word_language = z.enum([
    '_arabic_',
    '_armenian_',
    '_basque_',
    '_bengali_',
    '_brazilian_',
    '_bulgarian_',
    '_catalan_',
    '_cjk_',
    '_czech_',
    '_danish_',
    '_dutch_',
    '_english_',
    '_estonian_',
    '_finnish_',
    '_french_',
    '_galician_',
    '_german_',
    '_greek_',
    '_hindi_',
    '_hungarian_',
    '_indonesian_',
    '_irish_',
    '_italian_',
    '_latvian_',
    '_lithuanian_',
    '_norwegian_',
    '_persian_',
    '_portuguese_',
    '_romanian_',
    '_russian_',
    '_serbian_',
    '_sorani_',
    '_spanish_',
    '_swedish_',
    '_thai_',
    '_turkish_',
    '_none_'
]);

/**
 * Language value, such as _arabic_ or _thai_. Defaults to _english_.
 * Each language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words.
 * Also accepts an array of stop words.
 */
export const types_analysis_stop_words = z.union([
    types_analysis_stop_word_language,
    z.array(z.string())
]);

export const types_version_type = z.enum([
    'internal',
    'external',
    'external_gte'
]);

export const types_query_dsl_like_document = z.object({
    doc: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: "A document not present in the index."
    })),
    fields: z.optional(z.array(types_field)),
    _id: z.optional(types_id),
    _index: z.optional(types_index_name),
    per_field_analyzer: z.optional(z.record(z.string(), z.string()).register(z.globalRegistry, {
        description: "Overrides the default analyzer."
    })),
    routing: z.optional(types_routing),
    version: z.optional(types_version_number),
    version_type: z.optional(types_version_type)
});

/**
 * Text that we want similar documents for or a lookup to a document's field for the text.
 */
export const types_query_dsl_like = z.union([
    z.string(),
    types_query_dsl_like_document
]);

export const types_query_dsl_more_like_this_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "The analyzer that is used to analyze the free form text.\nDefaults to the analyzer associated with the first field in fields."
    })),
    boost_terms: z.optional(z.number().register(z.globalRegistry, {
        description: "Each term in the formed query could be further boosted by their tf-idf score.\nThis sets the boost factor to use when using this feature.\nDefaults to deactivated (0)."
    })).default(0),
    fail_on_unsupported_field: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Controls whether the query should fail (throw an exception) if any of the specified fields are not of the supported types (`text` or `keyword`)."
    })).default(true),
    fields: z.optional(z.array(types_field).register(z.globalRegistry, {
        description: "A list of fields to fetch and analyze the text from.\nDefaults to the `index.query.default_field` index setting, which has a default value of `*`."
    })),
    include: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Specifies whether the input documents should also be included in the search results returned."
    })).default(false),
    like: z.union([
        types_query_dsl_like,
        z.array(types_query_dsl_like)
    ]),
    max_doc_freq: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum document frequency above which the terms are ignored from the input document."
    })),
    max_query_terms: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of query terms that can be selected."
    })).default(25),
    max_word_length: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum word length above which the terms are ignored.\nDefaults to unbounded (`0`)."
    })).default(0),
    min_doc_freq: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum document frequency below which the terms are ignored from the input document."
    })).default(5),
    minimum_should_match: z.optional(types_minimum_should_match),
    min_term_freq: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum term frequency below which the terms are ignored from the input document."
    })).default(2),
    min_word_length: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum word length below which the terms are ignored."
    })).default(0),
    routing: z.optional(types_routing),
    stop_words: z.optional(types_analysis_stop_words),
    unlike: z.optional(z.union([
        types_query_dsl_like,
        z.array(types_query_dsl_like)
    ])),
    version: z.optional(types_version_number),
    version_type: z.optional(types_version_type)
}));

export const types_query_dsl_match_phrase_prefix_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to convert text in the query value into tokens."
    })),
    max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of terms to which the last provided term of the query value will expand."
    })).default(50),
    query: z.string().register(z.globalRegistry, {
        description: "Text you wish to find in the provided field."
    }),
    slop: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of positions allowed between matching tokens."
    })).default(0),
    zero_terms_query: z.optional(types_query_dsl_zero_terms_query)
}));

export const types_query_dsl_match_phrase_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to convert the text in the query value into tokens."
    })),
    query: z.string().register(z.globalRegistry, {
        description: "Query terms that are analyzed and turned into a phrase query."
    }),
    slop: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of positions allowed between matching tokens."
    })).default(0),
    zero_terms_query: z.optional(types_query_dsl_zero_terms_query)
}));

export const types_query_dsl_match_none_query = types_query_dsl_query_base.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_match_bool_prefix_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to convert the text in the query value into tokens."
    })),
    fuzziness: z.optional(types_fuzziness),
    fuzzy_rewrite: z.optional(types_multi_term_query_rewrite),
    fuzzy_transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term."
    })).default(true),
    max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of terms to which the query will expand.\nCan be applied to the term subqueries constructed for all terms but the final term."
    })).default(50),
    minimum_should_match: z.optional(types_minimum_should_match),
    operator: z.optional(types_query_dsl_operator),
    prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: "Number of beginning characters left unchanged for fuzzy matching.\nCan be applied to the term subqueries constructed for all terms but the final term."
    })).default(0),
    query: z.string().register(z.globalRegistry, {
        description: "Terms you wish to find in the provided field.\nThe last term is used in a prefix query."
    })
}));

export const types_query_dsl_match_all_query = types_query_dsl_query_base.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_match_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to convert the text in the query value into tokens."
    })),
    auto_generate_synonyms_phrase_query: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, match phrase queries are automatically created for multi-term synonyms."
    })).default(true),
    cutoff_frequency: z.optional(z.number()),
    fuzziness: z.optional(types_fuzziness),
    fuzzy_rewrite: z.optional(types_multi_term_query_rewrite),
    fuzzy_transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`)."
    })).default(true),
    lenient: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored."
    })).default(false),
    max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of terms to which the query will expand."
    })).default(50),
    minimum_should_match: z.optional(types_minimum_should_match),
    operator: z.optional(types_query_dsl_operator),
    prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: "Number of beginning characters left unchanged for fuzzy matching."
    })).default(0),
    query: z.union([
        z.string(),
        z.number(),
        z.boolean()
    ]),
    zero_terms_query: z.optional(types_query_dsl_zero_terms_query)
}));

export const types_query_dsl_intervals_wildcard = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to analyze the `pattern`.\nDefaults to the top-level field's analyzer."
    })),
    pattern: z.string().register(z.globalRegistry, {
        description: "Wildcard pattern used to find matching terms."
    }),
    use_field: z.optional(types_field)
});

export const types_query_dsl_intervals_regexp = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to analyze the `prefix`."
    })),
    pattern: z.string().register(z.globalRegistry, {
        description: "Regex pattern."
    }),
    use_field: z.optional(types_field)
});

export const types_query_dsl_intervals_range = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to analyze the `prefix`."
    })),
    gte: z.optional(z.string().register(z.globalRegistry, {
        description: "Lower term, either gte or gt must be provided."
    })),
    gt: z.optional(z.string().register(z.globalRegistry, {
        description: "Lower term, either gte or gt must be provided."
    })),
    lte: z.optional(z.string().register(z.globalRegistry, {
        description: "Upper term, either lte or lt must be provided."
    })),
    lt: z.optional(z.string().register(z.globalRegistry, {
        description: "Upper term, either lte or lt must be provided."
    })),
    use_field: z.optional(types_field)
});

export const types_query_dsl_intervals_prefix = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to analyze the `prefix`."
    })),
    prefix: z.string().register(z.globalRegistry, {
        description: "Beginning characters of terms you wish to find in the top-level field."
    }),
    use_field: z.optional(types_field)
});

export const types_query_dsl_intervals_fuzzy = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to normalize the term."
    })),
    fuzziness: z.optional(types_fuzziness),
    prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: "Number of beginning characters left unchanged when creating expansions."
    })).default(0),
    term: z.string().register(z.globalRegistry, {
        description: "The term to match."
    }),
    transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`)."
    })).default(true),
    use_field: z.optional(types_field)
});

export const types_ids = z.union([
    types_id,
    z.array(types_id)
]);

export const types_query_dsl_ids_query = types_query_dsl_query_base.and(z.object({
    values: z.optional(types_ids)
}));

export const types_query_dsl_geo_shape_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped."
    })).default(false)
}));

export const types_query_dsl_geo_validation_method = z.enum([
    'coerce',
    'ignore_malformed',
    'strict'
]);

export const types_query_dsl_geo_polygon_query = types_query_dsl_query_base.and(z.object({
    validation_method: z.optional(types_query_dsl_geo_validation_method),
    ignore_unmapped: z.optional(z.boolean())
}));

/**
 * A map hex cell (H3) reference
 */
export const types_geo_hex_cell = z.string().register(z.globalRegistry, {
    description: "A map hex cell (H3) reference"
});

/**
 * A map tile reference, represented as `{zoom}/{x}/{y}`
 */
export const types_geo_tile = z.string().register(z.globalRegistry, {
    description: "A map tile reference, represented as `{zoom}/{x}/{y}`"
});

export const types_geo_hash = z.string();

export const types_query_dsl_geo_grid_query = types_query_dsl_query_base.and(z.object({
    geotile: z.optional(types_geo_tile),
    geohash: z.optional(types_geo_hash),
    geohex: z.optional(types_geo_hex_cell)
}));

export const types_distance = z.string();

export const types_query_dsl_geo_distance_query = types_query_dsl_query_base.and(z.object({
    distance: types_distance,
    distance_type: z.optional(types_geo_distance_type),
    validation_method: z.optional(types_query_dsl_geo_validation_method),
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped."
    })).default(false)
}));

export const types_query_dsl_geo_execution = z.enum([
    'memory',
    'indexed'
]);

export const types_query_dsl_geo_bounding_box_query = types_query_dsl_query_base.and(z.object({
    type: z.optional(types_query_dsl_geo_execution),
    validation_method: z.optional(types_query_dsl_geo_validation_method),
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped."
    })).default(false)
}));

export const types_query_dsl_fuzzy_query = types_query_dsl_query_base.and(z.object({
    max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of variations created."
    })).default(50),
    prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: "Number of beginning characters left unchanged when creating expansions."
    })).default(0),
    rewrite: z.optional(types_multi_term_query_rewrite),
    transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Indicates whether edits include transpositions of two adjacent characters (for example `ab` to `ba`)."
    })).default(true),
    fuzziness: z.optional(types_fuzziness),
    value: z.union([
        z.string(),
        z.number(),
        z.boolean()
    ])
}));

export const types_query_dsl_function_score_mode = z.enum([
    'multiply',
    'sum',
    'avg',
    'first',
    'max',
    'min'
]);

export const types_query_dsl_random_score_function = z.object({
    field: z.optional(types_field),
    seed: z.optional(z.union([
        z.number(),
        z.string()
    ]))
});

export const types_query_dsl_field_value_factor_modifier = z.enum([
    'none',
    'log',
    'log1p',
    'log2p',
    'ln',
    'ln1p',
    'ln2p',
    'square',
    'sqrt',
    'reciprocal'
]);

export const types_query_dsl_field_value_factor_score_function = z.object({
    field: types_field,
    factor: z.optional(z.number().register(z.globalRegistry, {
        description: "Optional factor to multiply the field value with."
    })).default(1),
    missing: z.optional(z.number().register(z.globalRegistry, {
        description: "Value used if the document doesn’t have that field.\nThe modifier and factor are still applied to it as though it were read from the document."
    })),
    modifier: z.optional(types_query_dsl_field_value_factor_modifier)
});

export const types_query_dsl_multi_value_mode = z.enum([
    'min',
    'max',
    'avg',
    'sum'
]);

export const types_query_dsl_decay_function_base_geo_location_distance = z.object({
    multi_value_mode: z.optional(types_query_dsl_multi_value_mode)
});

export const types_query_dsl_geo_decay_function = types_query_dsl_decay_function_base_geo_location_distance.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_decay_function_basedoubledouble = z.object({
    multi_value_mode: z.optional(types_query_dsl_multi_value_mode)
});

export const types_query_dsl_numeric_decay_function = types_query_dsl_decay_function_basedoubledouble.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_decay_function_base_date_math_duration = z.object({
    multi_value_mode: z.optional(types_query_dsl_multi_value_mode)
});

export const types_query_dsl_date_decay_function = types_query_dsl_decay_function_base_date_math_duration.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_decay_function_base = z.object({
    multi_value_mode: z.optional(types_query_dsl_multi_value_mode)
});

export const types_query_dsl_untyped_decay_function = types_query_dsl_decay_function_base.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_decay_function = z.union([
    types_query_dsl_untyped_decay_function,
    types_query_dsl_date_decay_function,
    types_query_dsl_numeric_decay_function,
    types_query_dsl_geo_decay_function
]);

export const types_query_dsl_function_boost_mode = z.enum([
    'multiply',
    'replace',
    'sum',
    'avg',
    'max',
    'min'
]);

export const types_query_dsl_exists_query = types_query_dsl_query_base.and(z.object({
    field: types_field
}));

export const types_query_dsl_distance_feature_query_base_date_math_duration = types_query_dsl_query_base.and(z.object({
    origin: types_date_math,
    pivot: types_duration,
    field: types_field
}));

export const types_query_dsl_date_distance_feature_query = types_query_dsl_distance_feature_query_base_date_math_duration.and(z.record(z.string(), z.unknown()));

export const types_geo_hash_location = z.object({
    geohash: types_geo_hash
});

export const types_lat_lon_geo_location = z.object({
    lat: z.number().register(z.globalRegistry, {
        description: "Latitude"
    }),
    lon: z.number().register(z.globalRegistry, {
        description: "Longitude"
    })
});

/**
 * A latitude/longitude as a 2 dimensional point. It can be represented in various ways:
 * - as a `{lat, long}` object
 * - as a geo hash value
 * - as a `[lon, lat]` array
 * - as a string in `"<lat>, <lon>"` or WKT point formats
 */
export const types_geo_location = z.union([
    types_lat_lon_geo_location,
    types_geo_hash_location,
    z.array(z.number()),
    z.string()
]);

export const types_query_dsl_distance_feature_query_base_geo_location_distance = types_query_dsl_query_base.and(z.object({
    origin: types_geo_location,
    pivot: types_distance,
    field: types_field
}));

export const types_query_dsl_geo_distance_feature_query = types_query_dsl_distance_feature_query_base_geo_location_distance.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_distance_feature_query_base = types_query_dsl_query_base.and(z.object({
    origin: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: "Date or point of origin used to calculate distances.\nIf the `field` value is a `date` or `date_nanos` field, the `origin` value must be a date.\nDate Math, such as `now-1h`, is supported.\nIf the field value is a `geo_point` field, the `origin` value must be a geopoint."
    }),
    pivot: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: "Distance from the `origin` at which relevance scores receive half of the `boost` value.\nIf the `field` value is a `date` or `date_nanos` field, the `pivot` value must be a time unit, such as `1h` or `10d`. If the `field` value is a `geo_point` field, the `pivot` value must be a distance unit, such as `1km` or `12m`."
    }),
    field: types_field
}));

export const types_query_dsl_untyped_distance_feature_query = types_query_dsl_distance_feature_query_base.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_distance_feature_query = z.union([
    types_query_dsl_untyped_distance_feature_query,
    types_query_dsl_geo_distance_feature_query,
    types_query_dsl_date_distance_feature_query
]);

export const types_query_dsl_combined_fields_zero_terms = z.enum([
    'none',
    'all'
]);

export const types_query_dsl_combined_fields_operator = z.enum([
    'or',
    'and'
]);

export const types_query_dsl_combined_fields_query = types_query_dsl_query_base.and(z.object({
    fields: z.array(types_field).register(z.globalRegistry, {
        description: "List of fields to search. Field wildcard patterns are allowed. Only `text` fields are supported, and they must all have the same search `analyzer`."
    }),
    query: z.string().register(z.globalRegistry, {
        description: "Text to search for in the provided `fields`.\nThe `combined_fields` query analyzes the provided text before performing a search."
    }),
    auto_generate_synonyms_phrase_query: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If true, match phrase queries are automatically created for multi-term synonyms."
    })).default(true),
    operator: z.optional(types_query_dsl_combined_fields_operator),
    minimum_should_match: z.optional(types_minimum_should_match),
    zero_terms_query: z.optional(types_query_dsl_combined_fields_zero_terms)
}));

export const types_query_dsl_common_terms_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string()),
    cutoff_frequency: z.optional(z.number()),
    high_freq_operator: z.optional(types_query_dsl_operator),
    low_freq_operator: z.optional(types_query_dsl_operator),
    minimum_should_match: z.optional(types_minimum_should_match),
    query: z.string()
}));

/**
 * Base type for bucket aggregations. These aggregations also accept sub-aggregations.
 */
export const types_aggregations_bucket_aggregation_base = types_aggregations_aggregation.and(z.record(z.string(), z.unknown()));

export const types_aggregations_time_series_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of results to return."
    })).default(10000),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array."
    }))
}));

export const types_aggregations_aggregate_order = z.union([
    z.record(z.string(), types_sort_order),
    z.array(z.record(z.string(), types_sort_order))
]);

export const types_aggregations_missing_order = z.enum([
    'first',
    'last',
    'default'
]);

export const types_aggregations_terms_partition = z.object({
    num_partitions: z.number().register(z.globalRegistry, {
        description: "The number of partitions."
    }),
    partition: z.number().register(z.globalRegistry, {
        description: "The partition number for this request."
    })
});

export const types_aggregations_terms_include = z.union([
    z.string(),
    z.array(z.string()),
    types_aggregations_terms_partition
]);

export const types_aggregations_terms_aggregation_execution_hint = z.enum([
    'map',
    'global_ordinals',
    'global_ordinals_hash',
    'global_ordinals_low_cardinality'
]);

export const types_aggregations_terms_exclude = z.union([
    z.string(),
    z.array(z.string())
]);

export const types_aggregations_terms_aggregation_collect_mode = z.enum([
    'depth_first',
    'breadth_first'
]);

export const types_aggregations_gap_policy = z.enum([
    'skip',
    'insert_zeros',
    'keep_values'
]);

/**
 * Buckets path can be expressed in different ways, and an aggregation may accept some or all of these
 * forms depending on its type. Please refer to each aggregation's documentation to know what buckets
 * path forms they accept.
 */
export const types_aggregations_buckets_path = z.union([
    z.string(),
    z.array(z.string()),
    z.record(z.string(), z.string())
]);

export const types_aggregations_bucket_path_aggregation = types_aggregations_aggregation.and(z.object({
    buckets_path: z.optional(types_aggregations_buckets_path)
}));

export const types_aggregations_pipeline_aggregation_base = types_aggregations_bucket_path_aggregation.and(z.object({
    format: z.optional(z.string().register(z.globalRegistry, {
        description: "`DecimalFormat` pattern for the output value.\nIf specified, the formatted value is returned in the aggregation’s `value_as_string` property."
    })),
    gap_policy: z.optional(types_aggregations_gap_policy)
}));

export const types_aggregations_sum_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_stats_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_percentage_score_heuristic = z.record(z.string(), z.unknown());

export const types_aggregations_mutual_information_heuristic = z.object({
    background_is_superset: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to."
    })),
    include_negatives: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset."
    }))
});

/**
 * For empty Class assignments
 */
export const types_empty_object = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "For empty Class assignments"
});

export const types_aggregations_google_normalized_distance_heuristic = z.object({
    background_is_superset: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to."
    }))
});

export const types_aggregations_chi_square_heuristic = z.object({
    background_is_superset: z.boolean().register(z.globalRegistry, {
        description: "Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to."
    }),
    include_negatives: z.boolean().register(z.globalRegistry, {
        description: "Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset."
    })
});

export const types_aggregations_p_value_heuristic = z.object({
    background_is_superset: z.optional(z.boolean()),
    normalize_above: z.optional(z.number().register(z.globalRegistry, {
        description: "Should the results be normalized when above the given value.\nAllows for consistent significance results at various scales.\nNote: `0` is a special value which means no normalization"
    })).default(0)
});

export const types_aggregations_serial_differencing_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    lag: z.optional(z.number().register(z.globalRegistry, {
        description: "The historical bucket to subtract from the current value.\nMust be a positive, non-zero integer."
    }))
}));

export const types_aggregations_sampler_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "Limits how many top-scoring documents are collected in the sample processed on each shard."
    })).default(100)
}));

export const types_aggregations_random_sampler_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    probability: z.number().register(z.globalRegistry, {
        description: "The probability that a document will be included in the aggregated data.\nMust be greater than 0, less than 0.5, or exactly 1.\nThe lower the probability, the fewer documents are matched."
    }),
    seed: z.optional(z.number().register(z.globalRegistry, {
        description: "The seed to generate the random sampling of documents.\nWhen a seed is provided, the random subset of documents is the same between calls."
    })),
    shard_seed: z.optional(z.number().register(z.globalRegistry, {
        description: "When combined with seed, setting shard_seed ensures 100% consistent sampling over shards where data is exactly the same."
    }))
}));

export const types_aggregations_reverse_nested_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    path: z.optional(types_field)
}));

export const types_aggregations_rate_mode = z.enum([
    'sum',
    'value_count'
]);

export const types_aggregations_calendar_interval = z.enum([
    'second',
    '1s',
    'minute',
    '1m',
    'hour',
    '1h',
    'day',
    '1d',
    'week',
    '1w',
    'month',
    '1M',
    'quarter',
    '1q',
    'year',
    '1y'
]);

export const types_aggregations_rare_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    exclude: z.optional(types_aggregations_terms_exclude),
    field: z.optional(types_field),
    include: z.optional(types_aggregations_terms_include),
    max_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of documents a term should appear in."
    })).default(1),
    missing: z.optional(types_aggregations_missing),
    precision: z.optional(z.number().register(z.globalRegistry, {
        description: "The precision of the internal CuckooFilters.\nSmaller precision leads to better approximation, but higher memory usage."
    })).default(0.001),
    value_type: z.optional(z.string())
}));

export const types_aggregations_aggregation_range = z.object({
    from: z.optional(z.union([
        z.number(),
        z.string(),
        z.null()
    ])),
    key: z.optional(z.string().register(z.globalRegistry, {
        description: "Custom key to return the range with."
    })),
    to: z.optional(z.union([
        z.number(),
        z.string(),
        z.null()
    ]))
});

export const types_aggregations_percentiles_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    percents: z.optional(z.array(z.number()).register(z.globalRegistry, {
        description: "The list of percentiles to calculate."
    }))
}));

export const types_aggregations_t_digest_execution_hint = z.enum([
    'default',
    'high_accuracy'
]);

export const types_aggregations_t_digest = z.object({
    compression: z.optional(z.number().register(z.globalRegistry, {
        description: "Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error."
    })),
    execution_hint: z.optional(types_aggregations_t_digest_execution_hint)
});

export const types_aggregations_hdr_method = z.object({
    number_of_significant_value_digits: z.optional(z.number().register(z.globalRegistry, {
        description: "Specifies the resolution of values for the histogram in number of significant digits."
    }))
});

export const types_aggregations_parent_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    type: z.optional(types_relation_name)
}));

export const types_aggregations_normalize_method = z.enum([
    'rescale_0_1',
    'rescale_0_100',
    'percent_of_sum',
    'mean',
    'z-score',
    'softmax'
]);

export const types_aggregations_normalize_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    method: z.optional(types_aggregations_normalize_method)
}));

export const types_aggregations_nested_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    path: z.optional(types_field)
}));

export const types_aggregations_multi_term_lookup = z.object({
    field: types_field,
    missing: z.optional(types_aggregations_missing)
});

export const types_aggregations_multi_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    collect_mode: z.optional(types_aggregations_terms_aggregation_collect_mode),
    order: z.optional(types_aggregations_aggregate_order),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum number of documents in a bucket for it to be returned."
    })).default(1),
    shard_min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum number of documents in a bucket on each shard for it to be returned."
    })).default(1),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter."
    })),
    show_term_doc_count_error: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Calculates the doc count error on per term basis."
    })).default(false),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of term buckets should be returned out of the overall terms list."
    })).default(10),
    terms: z.array(types_aggregations_multi_term_lookup).register(z.globalRegistry, {
        description: "The field from which to generate sets of terms."
    })
}));

export const types_aggregations_moving_function_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    script: z.optional(z.string().register(z.globalRegistry, {
        description: "The script that should be executed on each window of data."
    })),
    shift: z.optional(z.number().register(z.globalRegistry, {
        description: "By default, the window consists of the last n values excluding the current bucket.\nIncreasing `shift` by 1, moves the starting window position by 1 to the right."
    })).default(0),
    window: z.optional(z.number().register(z.globalRegistry, {
        description: "The size of window to \"slide\" across the histogram."
    }))
}));

export const types_aggregations_moving_percentiles_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    window: z.optional(z.number().register(z.globalRegistry, {
        description: "The size of window to \"slide\" across the histogram."
    })),
    shift: z.optional(z.number().register(z.globalRegistry, {
        description: "By default, the window consists of the last n values excluding the current bucket.\nIncreasing `shift` by 1, moves the starting window position by 1 to the right."
    })).default(0),
    keyed: z.optional(z.boolean())
}));

export const types_aggregations_holt_winters_type = z.enum([
    'add',
    'mult'
]);

export const types_aggregations_holt_winters_model_settings = z.object({
    alpha: z.optional(z.number()),
    beta: z.optional(z.number()),
    gamma: z.optional(z.number()),
    pad: z.optional(z.boolean()),
    period: z.optional(z.number()),
    type: z.optional(types_aggregations_holt_winters_type)
});

export const types_aggregations_moving_average_aggregation_base = types_aggregations_pipeline_aggregation_base.and(z.object({
    minimize: z.optional(z.boolean()),
    predict: z.optional(z.number()),
    window: z.optional(z.number())
}));

export const types_aggregations_holt_winters_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum([
        'holt_winters'
    ]),
    settings: types_aggregations_holt_winters_model_settings
}));

export const types_aggregations_holt_linear_model_settings = z.object({
    alpha: z.optional(z.number()),
    beta: z.optional(z.number())
});

export const types_aggregations_holt_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum([
        'holt'
    ]),
    settings: types_aggregations_holt_linear_model_settings
}));

export const types_aggregations_ewma_model_settings = z.object({
    alpha: z.optional(z.number())
});

export const types_aggregations_ewma_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum([
        'ewma'
    ]),
    settings: types_aggregations_ewma_model_settings
}));

export const types_aggregations_simple_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum([
        'simple'
    ]),
    settings: types_empty_object
}));

export const types_aggregations_linear_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum([
        'linear'
    ]),
    settings: types_empty_object
}));

export const types_aggregations_moving_average_aggregation = z.union([
    z.object({
        model: z.literal("_types.aggregations.LinearMovingAverageAggregation")
    }).and(types_aggregations_linear_moving_average_aggregation),
    z.object({
        model: z.literal("_types.aggregations.SimpleMovingAverageAggregation")
    }).and(types_aggregations_simple_moving_average_aggregation),
    z.object({
        model: z.literal("_types.aggregations.EwmaMovingAverageAggregation")
    }).and(types_aggregations_ewma_moving_average_aggregation),
    z.object({
        model: z.literal("_types.aggregations.HoltMovingAverageAggregation")
    }).and(types_aggregations_holt_moving_average_aggregation),
    z.object({
        model: z.literal("_types.aggregations.HoltWintersMovingAverageAggregation")
    }).and(types_aggregations_holt_winters_moving_average_aggregation)
]);

export const types_aggregations_missing_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: z.optional(types_field),
    missing: z.optional(types_aggregations_missing)
}));

export const types_aggregations_min_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_max_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_matrix_aggregation = types_aggregations_aggregation.and(z.object({
    fields: z.optional(types_fields),
    missing: z.optional(z.record(z.string(), z.number()).register(z.globalRegistry, {
        description: "The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored."
    }))
}));

export const types_aggregations_matrix_stats_aggregation = types_aggregations_matrix_aggregation.and(z.object({
    mode: z.optional(types_sort_mode)
}));

export const ml_types_classification_inference_options = z.object({
    num_top_classes: z.optional(z.number().register(z.globalRegistry, {
        description: "Specifies the number of top class predictions to return. Defaults to 0."
    })),
    num_top_feature_importance_values: z.optional(z.number().register(z.globalRegistry, {
        description: "Specifies the maximum number of feature importance values per document."
    })).default(0),
    prediction_field_type: z.optional(z.string().register(z.globalRegistry, {
        description: "Specifies the type of the predicted field to write. Acceptable values are: string, number, boolean. When boolean is provided 1.0 is transformed to true and 0.0 to false."
    })),
    results_field: z.optional(z.string().register(z.globalRegistry, {
        description: "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value."
    })),
    top_classes_results_field: z.optional(z.string().register(z.globalRegistry, {
        description: "Specifies the field to which the top classes are written. Defaults to top_classes."
    }))
});

export const ml_types_regression_inference_options = z.object({
    results_field: z.optional(types_field),
    num_top_feature_importance_values: z.optional(z.number().register(z.globalRegistry, {
        description: "Specifies the maximum number of feature importance values per document."
    })).default(0)
});

export const types_aggregations_inference_config_container = z.object({
    regression: z.optional(ml_types_regression_inference_options),
    classification: z.optional(ml_types_classification_inference_options)
});

export const types_aggregations_inference_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    model_id: types_name,
    inference_config: z.optional(types_aggregations_inference_config_container)
}));

export const types_aggregations_ip_prefix_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field,
    prefix_length: z.number().register(z.globalRegistry, {
        description: "Length of the network prefix. For IPv4 addresses the accepted range is [0, 32].\nFor IPv6 addresses the accepted range is [0, 128]."
    }),
    is_ipv6: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Defines whether the prefix applies to IPv6 addresses."
    })).default(false),
    append_prefix_length: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Defines whether the prefix length is appended to IP address keys in the response."
    })).default(false),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Defines whether buckets are returned as a hash rather than an array in the response."
    })),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "Minimum number of documents in a bucket for it to be included in the response."
    })).default(1)
}));

export const types_aggregations_ip_range_aggregation_range = z.object({
    from: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    mask: z.optional(z.string().register(z.globalRegistry, {
        description: "IP range defined as a CIDR mask."
    })),
    to: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

export const types_aggregations_ip_range_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: z.optional(types_field),
    ranges: z.optional(z.array(types_aggregations_ip_range_aggregation_range).register(z.globalRegistry, {
        description: "Array of IP ranges."
    }))
}));

export const types_aggregations_extended_boundsdouble = z.object({
    max: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum value for the bound."
    })),
    min: z.optional(z.number().register(z.globalRegistry, {
        description: "Minimum value for the bound."
    }))
});

export const types_aggregations_global_aggregation = types_aggregations_bucket_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_wkt_geo_bounds = z.object({
    wkt: z.string()
});

export const types_top_right_bottom_left_geo_bounds = z.object({
    top_right: types_geo_location,
    bottom_left: types_geo_location
});

export const types_top_left_bottom_right_geo_bounds = z.object({
    top_left: types_geo_location,
    bottom_right: types_geo_location
});

export const types_coords_geo_bounds = z.object({
    top: z.number(),
    bottom: z.number(),
    left: z.number(),
    right: z.number()
});

/**
 * A geo bounding box. It can be represented in various ways:
 * - as 4 top/bottom/left/right coordinates
 * - as 2 top_left / bottom_right points
 * - as 2 top_right / bottom_left points
 * - as a WKT bounding box
 */
export const types_geo_bounds = z.union([
    types_coords_geo_bounds,
    types_top_left_bottom_right_geo_bounds,
    types_top_right_bottom_left_geo_bounds,
    types_wkt_geo_bounds
]);

export const types_aggregations_geohex_grid_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field,
    precision: z.optional(z.number().register(z.globalRegistry, {
        description: "Integer zoom of the key used to defined cells or buckets\nin the results. Value should be between 0-15."
    })).default(6),
    bounds: z.optional(types_geo_bounds),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of buckets to return."
    })).default(10000),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "Number of buckets returned from each shard."
    }))
}));

export const types_geo_tile_precision = z.number();

export const types_aggregations_geo_tile_grid_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: z.optional(types_field),
    precision: z.optional(types_geo_tile_precision),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "Allows for more accurate counting of the top cells returned in the final result the aggregation.\nDefaults to returning `max(10,(size x number-of-shards))` buckets from each shard."
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of buckets to return."
    })).default(10000),
    bounds: z.optional(types_geo_bounds)
}));

export const types_aggregations_geo_line_sort = z.object({
    field: types_field
});

export const types_aggregations_geo_line_point = z.object({
    field: types_field
});

export const types_aggregations_geo_line_aggregation = z.object({
    point: types_aggregations_geo_line_point,
    sort: z.optional(types_aggregations_geo_line_sort),
    include_sort: z.optional(z.boolean().register(z.globalRegistry, {
        description: "When `true`, returns an additional array of the sort values in the feature properties."
    })),
    sort_order: z.optional(types_sort_order),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum length of the line represented in the aggregation.\nValid sizes are between 1 and 10000."
    })).default(10000)
});

/**
 * A precision that can be expressed as a geohash length between 1 and 12, or a distance measure like "1km", "10m".
 */
export const types_geo_hash_precision = z.union([
    z.number(),
    z.string()
]);

export const types_aggregations_geo_hash_grid_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    bounds: z.optional(types_geo_bounds),
    field: z.optional(types_field),
    precision: z.optional(types_geo_hash_precision),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "Allows for more accurate counting of the top cells returned in the final result the aggregation.\nDefaults to returning `max(10,(size x number-of-shards))` buckets from each shard."
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of geohash buckets to return."
    })).default(10000)
}));

export const types_aggregations_geo_distance_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    distance_type: z.optional(types_geo_distance_type),
    field: z.optional(types_field),
    origin: z.optional(types_geo_location),
    ranges: z.optional(z.array(types_aggregations_aggregation_range).register(z.globalRegistry, {
        description: "An array of ranges used to bucket documents."
    })),
    unit: z.optional(types_distance_unit)
}));

export const types_aggregations_frequent_item_sets_field = z.object({
    field: types_field,
    exclude: z.optional(types_aggregations_terms_exclude),
    include: z.optional(types_aggregations_terms_include)
});

export const types_aggregations_extended_stats_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    sigma: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of standard deviations above/below the mean to display."
    }))
}));

export const types_aggregations_sampler_aggregation_execution_hint = z.enum([
    'map',
    'global_ordinals',
    'bytes_hash'
]);

export const types_aggregations_derivative_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

/**
 * A date range limit, represented either as a DateMath expression or a number expressed
 * according to the target field's precision.
 */
export const types_aggregations_field_date_math = z.union([
    types_date_math,
    z.number()
]);

export const types_aggregations_date_range_expression = z.object({
    from: z.optional(types_aggregations_field_date_math),
    key: z.optional(z.string().register(z.globalRegistry, {
        description: "Custom key to return the range with."
    })),
    to: z.optional(types_aggregations_field_date_math)
});

export const types_aggregations_date_range_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: z.optional(types_field),
    format: z.optional(z.string().register(z.globalRegistry, {
        description: "The date format used to format `from` and `to` in the response."
    })),
    missing: z.optional(types_aggregations_missing),
    ranges: z.optional(z.array(types_aggregations_date_range_expression).register(z.globalRegistry, {
        description: "Array of date ranges."
    })),
    time_zone: z.optional(types_time_zone),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array."
    }))
}));

export const types_aggregations_extended_bounds_field_date_math = z.object({
    max: z.optional(types_aggregations_field_date_math),
    min: z.optional(types_aggregations_field_date_math)
});

export const types_aggregations_cumulative_sum_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_cumulative_cardinality_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

/**
 * A date histogram interval. Similar to `Duration` with additional units: `w` (week), `M` (month), `q` (quarter) and
 * `y` (year)
 */
export const types_duration_large = z.string().register(z.globalRegistry, {
    description: "A date histogram interval. Similar to `Duration` with additional units: `w` (week), `M` (month), `q` (quarter) and\n`y` (year)"
});

export const types_aggregations_composite_aggregate_key = z.record(z.string(), types_field_value);

export const types_aggregations_children_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    type: z.optional(types_relation_name)
}));

export const types_aggregations_change_point_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_custom_categorize_text_analyzer = z.object({
    char_filter: z.optional(z.array(z.string())),
    tokenizer: z.optional(z.string()),
    filter: z.optional(z.array(z.string()))
});

export const types_aggregations_categorize_text_analyzer = z.union([
    z.string(),
    types_aggregations_custom_categorize_text_analyzer
]);

/**
 * A multi-bucket aggregation that groups semi-structured text into buckets. Each text
 * field is re-analyzed using a custom analyzer. The resulting tokens are then categorized
 * creating buckets of similarly formatted text values. This aggregation works best with machine
 * generated text like system logs. Only the first 100 analyzed tokens are used to categorize the text.
 */
export const types_aggregations_categorize_text_aggregation = types_aggregations_aggregation.and(z.object({
    field: types_field,
    max_unique_tokens: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of unique tokens at any position up to max_matched_tokens. Must be larger than 1.\nSmaller values use less memory and create fewer categories. Larger values will use more memory and\ncreate narrower categories. Max allowed value is 100."
    })).default(50),
    max_matched_tokens: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of token positions to match on before attempting to merge categories. Larger\nvalues will use more memory and create narrower categories. Max allowed value is 100."
    })).default(5),
    similarity_threshold: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum percentage of tokens that must match for text to be added to the category bucket. Must\nbe between 1 and 100. The larger the value the narrower the categories. Larger values will increase memory\nusage and create narrower categories."
    })).default(50),
    categorization_filters: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: "This property expects an array of regular expressions. The expressions are used to filter out matching\nsequences from the categorization field values. You can use this functionality to fine tune the categorization\nby excluding sequences from consideration when categories are defined. For example, you can exclude SQL\nstatements that appear in your log files. This property cannot be used at the same time as categorization_analyzer.\nIf you only want to define simple regular expression filters that are applied prior to tokenization, setting\nthis property is the easiest method. If you also want to customize the tokenizer or post-tokenization filtering,\nuse the categorization_analyzer property instead and include the filters as pattern_replace character filters."
    })),
    categorization_analyzer: z.optional(types_aggregations_categorize_text_analyzer),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of categorization buckets to return from each shard before merging all the results."
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of buckets to return."
    })).default(10),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum number of documents in a bucket to be returned to the results."
    })),
    shard_min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum number of documents in a bucket to be returned from the shard before merging."
    }))
}));

export const types_aggregations_cardinality_execution_mode = z.enum([
    'global_ordinals',
    'segment_ordinals',
    'direct',
    'save_memory_heuristic',
    'save_time_heuristic'
]);

export const types_aggregations_bucket_correlation_function_count_correlation_indicator = z.object({
    doc_count: z.number().register(z.globalRegistry, {
        description: "The total number of documents that initially created the expectations. It’s required to be greater\nthan or equal to the sum of all values in the buckets_path as this is the originating superset of data\nto which the term values are correlated."
    }),
    expectations: z.array(z.number()).register(z.globalRegistry, {
        description: "An array of numbers with which to correlate the configured `bucket_path` values.\nThe length of this value must always equal the number of buckets returned by the `bucket_path`."
    }),
    fractions: z.optional(z.array(z.number()).register(z.globalRegistry, {
        description: "An array of fractions to use when averaging and calculating variance. This should be used if\nthe pre-calculated data and the buckets_path have known gaps. The length of fractions, if provided,\nmust equal expectations."
    }))
});

export const types_aggregations_bucket_correlation_function_count_correlation = z.object({
    indicator: types_aggregations_bucket_correlation_function_count_correlation_indicator
});

export const types_aggregations_bucket_correlation_function = z.object({
    count_correlation: types_aggregations_bucket_correlation_function_count_correlation
});

/**
 * A sibling pipeline aggregation which executes a correlation function on the configured sibling multi-bucket aggregation.
 */
export const types_aggregations_bucket_correlation_aggregation = types_aggregations_bucket_path_aggregation.and(z.object({
    function: types_aggregations_bucket_correlation_function
}));

/**
 * A sibling pipeline aggregation which executes a two sample Kolmogorov–Smirnov test (referred
 * to as a "K-S test" from now on) against a provided distribution, and the distribution implied
 * by the documents counts in the configured sibling aggregation. Specifically, for some metric,
 * assuming that the percentile intervals of the metric are known beforehand or have been computed
 * by an aggregation, then one would use range aggregation for the sibling to compute the p-value
 * of the distribution difference between the metric and the restriction of that metric to a subset
 * of the documents. A natural use case is if the sibling aggregation range aggregation nested in a
 * terms aggregation, in which case one compares the overall distribution of metric to its restriction
 * to each term.
 */
export const types_aggregations_bucket_ks_aggregation = types_aggregations_bucket_path_aggregation.and(z.object({
    alternative: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: "A list of string values indicating which K-S test alternative to calculate. The valid values\nare: \"greater\", \"less\", \"two_sided\". This parameter is key for determining the K-S statistic used\nwhen calculating the K-S test. Default value is all possible alternative hypotheses."
    })),
    fractions: z.optional(z.array(z.number()).register(z.globalRegistry, {
        description: "A list of doubles indicating the distribution of the samples with which to compare to the `buckets_path` results.\nIn typical usage this is the overall proportion of documents in each bucket, which is compared with the actual\ndocument proportions in each bucket from the sibling aggregation counts. The default is to assume that overall\ndocuments are uniformly distributed on these buckets, which they would be if one used equal percentiles of a\nmetric to define the bucket end points."
    })),
    sampling_method: z.optional(z.string().register(z.globalRegistry, {
        description: "Indicates the sampling methodology when calculating the K-S test. Note, this is sampling of the returned values.\nThis determines the cumulative distribution function (CDF) points used comparing the two samples. Default is\n`upper_tail`, which emphasizes the upper end of the CDF points. Valid options are: `upper_tail`, `uniform`,\nand `lower_tail`."
    }))
}));

export const types_aggregations_average_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_minimum_interval = z.enum([
    'second',
    'minute',
    'hour',
    'day',
    'month',
    'year'
]);

/**
 * Cause and details about a request failure. This class defines the properties common to all error types.
 * Additional details are also provided, that depend on the error type.
 */
export const types_error_cause = z.object({
    type: z.string().register(z.globalRegistry, {
        description: "The type of error"
    }),
    reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    stack_trace: z.optional(z.string().register(z.globalRegistry, {
        description: "The server stack trace. Present only if the `error_trace=true` parameter was sent with the request."
    })),
    get caused_by() {
        return z.optional(z.lazy((): any => types_error_cause));
    },
    get root_cause() {
        return z.optional(z.array(z.lazy((): any => types_error_cause)));
    },
    get suppressed() {
        return z.optional(z.array(z.lazy((): any => types_error_cause)));
    }
}).register(z.globalRegistry, {
    description: "Cause and details about a request failure. This class defines the properties common to all error types.\nAdditional details are also provided, that depend on the error type."
});

/**
 * Time unit for nanoseconds
 */
export const types_unit_nanos = z.number().register(z.globalRegistry, {
    description: "Time unit for nanoseconds"
});

export const types_duration_value_unit_nanos = types_unit_nanos;

export const types_node_id = z.string();

export const types_transport_address = z.string();

export const types_node_role = z.enum([
    'master',
    'data',
    'data_cold',
    'data_content',
    'data_frozen',
    'data_hot',
    'data_warm',
    'client',
    'ingest',
    'ml',
    'voting_only',
    'transform',
    'remote_cluster_client',
    'coordinating_only'
]);

export const types_node_roles = z.array(types_node_role);

export const types_inline_get = z.object({
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    found: z.boolean(),
    _seq_no: z.optional(types_sequence_number),
    _primary_term: z.optional(z.number()),
    _routing: z.optional(types_routing),
    _source: z.optional(z.record(z.string(), z.unknown()))
});

export const types_shard_failure = z.object({
    index: z.optional(types_index_name),
    node: z.optional(z.string()),
    reason: types_error_cause,
    shard: z.optional(z.number()),
    status: z.optional(z.string()),
    primary: z.optional(z.boolean())
});

export const types_shard_statistics = z.object({
    failed: types_uint,
    successful: types_uint,
    total: types_uint,
    failures: z.optional(z.array(types_shard_failure)),
    skipped: z.optional(types_uint)
});

export const types_node_name = z.string();

export const types_indices = z.union([
    types_index_name,
    z.array(types_index_name)
]);

export const types_mapping_time_series_metric_type = z.enum([
    'gauge',
    'counter',
    'summary',
    'histogram',
    'position'
]);

/**
 * Base type for multi-bucket aggregation results that can hold sub-aggregations results.
 */
export const types_aggregations_multi_bucket_base = z.object({
    doc_count: z.number()
}).register(z.globalRegistry, {
    description: "Base type for multi-bucket aggregation results that can hold sub-aggregations results."
});

export const types_aggregations_composite_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_aggregations_composite_aggregate_key
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_composite_bucket = z.union([
    z.record(z.string(), types_aggregations_composite_bucket),
    z.array(types_aggregations_composite_bucket)
]);

export const types_aggregations_aggregate_base = z.object({
    meta: z.optional(types_metadata)
});

export const types_aggregations_multi_bucket_aggregate_base_composite_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_composite_bucket
}));

export const types_aggregations_composite_aggregate = types_aggregations_multi_bucket_aggregate_base_composite_bucket.and(z.object({
    after_key: z.optional(types_aggregations_composite_aggregate_key)
}));

export const types_aggregations_range_bucket = types_aggregations_multi_bucket_base.and(z.object({
    from: z.optional(z.number()),
    to: z.optional(z.number()),
    from_as_string: z.optional(z.string()),
    to_as_string: z.optional(z.string()),
    key: z.optional(z.string().register(z.globalRegistry, {
        description: "The bucket key. Present if the aggregation is _not_ keyed"
    }))
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_range_bucket = z.union([
    z.record(z.string(), types_aggregations_range_bucket),
    z.array(types_aggregations_range_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_range_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_range_bucket
}));

export const types_aggregations_range_aggregate = types_aggregations_multi_bucket_aggregate_base_range_bucket.and(z.record(z.string(), z.unknown()));

/**
 * Result of a `date_range` aggregation. Same format as a for a `range` aggregation: `from` and `to`
 * in `buckets` are milliseconds since the Epoch, represented as a floating point number.
 */
export const types_aggregations_date_range_aggregate = types_aggregations_range_aggregate.and(z.record(z.string(), z.unknown()));

export const types_aggregations_filters_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_filters_bucket = z.union([
    z.record(z.string(), types_aggregations_filters_bucket),
    z.array(types_aggregations_filters_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_filters_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_filters_bucket
}));

export const types_aggregations_filters_aggregate = types_aggregations_multi_bucket_aggregate_base_filters_bucket.and(z.record(z.string(), z.unknown()));

/**
 * Base type for single-bucket aggregation results that can hold sub-aggregations results.
 */
export const types_aggregations_single_bucket_aggregate_base = types_aggregations_aggregate_base.and(z.object({
    doc_count: z.number()
}));

export const types_aggregations_filter_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_missing_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_multi_terms_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.array(types_field_value),
    key_as_string: z.optional(z.string()),
    doc_count_error_upper_bound: z.optional(z.number())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_multi_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_multi_terms_bucket),
    z.array(types_aggregations_multi_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_multi_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_multi_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_multi_terms_bucket = types_aggregations_multi_bucket_aggregate_base_multi_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number()),
    sum_other_doc_count: z.optional(z.number())
}));

export const types_aggregations_multi_terms_aggregate = types_aggregations_terms_aggregate_base_multi_terms_bucket.and(z.record(z.string(), z.unknown()));

/**
 * The absence of any type. This is commonly used in APIs that don't return a body.
 *
 * Although "void" is generally used for the unit type that has only one value, this is to be interpreted as
 * the bottom type that has no value at all. Most languages have a unit type, but few have a bottom type.
 *
 * See https://en.m.wikipedia.org/wiki/Unit_type and https://en.m.wikipedia.org/wiki/Bottom_type
 */
export const spec_utils_void = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "The absence of any type. This is commonly used in APIs that don't return a body.\n\nAlthough \"void\" is generally used for the unit type that has only one value, this is to be interpreted as\nthe bottom type that has no value at all. Most languages have a unit type, but few have a bottom type.\n\nSee https://en.m.wikipedia.org/wiki/Unit_type and https://en.m.wikipedia.org/wiki/Bottom_type"
});

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_void = z.union([
    z.record(z.string(), spec_utils_void),
    z.array(spec_utils_void)
]);

export const types_aggregations_multi_bucket_aggregate_base_void = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_void
}));

export const types_aggregations_terms_aggregate_base_void = types_aggregations_multi_bucket_aggregate_base_void.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number()),
    sum_other_doc_count: z.optional(z.number())
}));

/**
 * Result of a `terms` aggregation when the field is unmapped. `buckets` is always empty.
 */
export const types_aggregations_unmapped_terms_aggregate = types_aggregations_terms_aggregate_base_void.and(z.record(z.string(), z.unknown()));

export const types_aggregations_terms_bucket_base = types_aggregations_multi_bucket_base.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number())
}));

export const types_aggregations_double_terms_bucket = types_aggregations_terms_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_double_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_double_terms_bucket),
    z.array(types_aggregations_double_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_double_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_double_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_double_terms_bucket = types_aggregations_multi_bucket_aggregate_base_double_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number()),
    sum_other_doc_count: z.optional(z.number())
}));

/**
 * Result of a `terms` aggregation when the field is some kind of decimal number like a float, double, or distance.
 */
export const types_aggregations_double_terms_aggregate = types_aggregations_terms_aggregate_base_double_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_long_terms_bucket = types_aggregations_terms_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_long_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_long_terms_bucket),
    z.array(types_aggregations_long_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_long_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_long_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_long_terms_bucket = types_aggregations_multi_bucket_aggregate_base_long_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number()),
    sum_other_doc_count: z.optional(z.number())
}));

/**
 * Result of a `terms` aggregation when the field is some kind of whole number like a integer, long, or a date.
 */
export const types_aggregations_long_terms_aggregate = types_aggregations_terms_aggregate_base_long_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_string_terms_bucket = types_aggregations_terms_bucket_base.and(z.object({
    key: types_field_value
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_string_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_string_terms_bucket),
    z.array(types_aggregations_string_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_string_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_string_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_string_terms_bucket = types_aggregations_multi_bucket_aggregate_base_string_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number()),
    sum_other_doc_count: z.optional(z.number())
}));

/**
 * Result of a `terms` aggregation when the field is a string.
 */
export const types_aggregations_string_terms_aggregate = types_aggregations_terms_aggregate_base_string_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_single_metric_aggregate_base = types_aggregations_aggregate_base.and(z.object({
    value: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    value_as_string: z.optional(z.string())
}));

/**
 * Value count aggregation result. `value` is always present.
 */
export const types_aggregations_value_count_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_cardinality_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.number()
}));

export const types_relocation_failure_info = z.object({
    failed_attempts: z.number()
});

export const cluster_allocation_explain_unassigned_information_reason = z.enum([
    'INDEX_CREATED',
    'CLUSTER_RECOVERED',
    'INDEX_REOPENED',
    'DANGLING_INDEX_IMPORTED',
    'NEW_INDEX_RESTORED',
    'EXISTING_INDEX_RESTORED',
    'REPLICA_ADDED',
    'ALLOCATION_FAILED',
    'NODE_LEFT',
    'REROUTE_CANCELLED',
    'REINITIALIZED',
    'REALLOCATED_REPLICA',
    'PRIMARY_FAILED',
    'FORCED_EMPTY_PRIMARY',
    'MANUAL_ALLOCATION'
]);

export const cluster_allocation_explain_unassigned_information = z.object({
    at: types_date_time,
    last_allocation_status: z.optional(z.string()),
    reason: cluster_allocation_explain_unassigned_information_reason,
    details: z.optional(z.string()),
    failed_allocation_attempts: z.optional(z.number()),
    delayed: z.optional(z.boolean()),
    allocation_status: z.optional(z.string())
});

export const indices_stats_shard_routing_state = z.enum([
    'UNASSIGNED',
    'INITIALIZING',
    'STARTED',
    'RELOCATING'
]);

export const types_node_shard = z.object({
    state: indices_stats_shard_routing_state,
    primary: z.boolean(),
    node: z.optional(types_node_name),
    shard: z.number(),
    index: types_index_name,
    allocation_id: z.optional(z.record(z.string(), types_id)),
    recovery_source: z.optional(z.record(z.string(), types_id)),
    unassigned_info: z.optional(cluster_allocation_explain_unassigned_information),
    relocating_node: z.optional(z.union([
        types_node_id,
        z.string(),
        z.null()
    ])),
    relocation_failure_info: z.optional(types_relocation_failure_info)
});

export const global_search_shards_search_shards_node_attributes = z.object({
    name: types_node_name,
    ephemeral_id: types_id,
    transport_address: types_transport_address,
    external_id: z.string(),
    attributes: z.record(z.string(), z.string()).register(z.globalRegistry, {
        description: "Lists node attributes."
    }),
    roles: types_node_roles,
    version: types_version_string,
    min_index_version: z.number(),
    max_index_version: z.number()
});

export const types_mapbox_vector_tiles = z.record(z.string(), z.unknown());

export const global_search_mvt_types_grid_type = z.enum([
    'grid',
    'point',
    'centroid'
]);

export const global_search_mvt_types_grid_aggregation_type = z.enum([
    'geotile',
    'geohex'
]);

export const global_search_mvt_types_coordinate = z.number();

export const global_search_mvt_types_zoom_level = z.number();

export const types_acknowledged_response_base = z.object({
    acknowledged: z.boolean().register(z.globalRegistry, {
        description: "For a successful response, this value is always true. On failure, an exception is returned instead."
    })
});

export const global_rank_eval_rank_eval_hit = z.object({
    _id: types_id,
    _index: types_index_name,
    _score: z.number()
});

export const global_rank_eval_rank_eval_hit_item = z.object({
    hit: global_rank_eval_rank_eval_hit,
    rating: z.optional(z.union([
        z.number(),
        z.string(),
        z.null()
    ]))
});

export const global_rank_eval_unrated_document = z.object({
    _id: types_id,
    _index: types_index_name
});

export const global_rank_eval_rank_eval_metric_detail = z.object({
    metric_score: z.number().register(z.globalRegistry, {
        description: "The metric_score in the details section shows the contribution of this query to the global quality metric score"
    }),
    unrated_docs: z.array(global_rank_eval_unrated_document).register(z.globalRegistry, {
        description: "The unrated_docs section contains an _index and _id entry for each document in the search result for this query that didn’t have a ratings value. This can be used to ask the user to supply ratings for these documents"
    }),
    hits: z.array(global_rank_eval_rank_eval_hit_item).register(z.globalRegistry, {
        description: "The hits section shows a grouping of the search results with their supplied ratings"
    }),
    metric_details: z.record(z.string(), z.record(z.string(), z.record(z.string(), z.unknown()))).register(z.globalRegistry, {
        description: "The metric_details give additional information about the calculated quality metric (e.g. how many of the retrieved documents were relevant). The content varies for each metric but allows for better interpretation of the results"
    })
});

export const global_rank_eval_rank_eval_metric_base = z.object({
    k: z.optional(z.number().register(z.globalRegistry, {
        description: "Sets the maximum number of documents retrieved per query. This value will act in place of the usual size parameter in the query."
    })).default(10)
});

/**
 * Expected Reciprocal Rank (ERR)
 */
export const global_rank_eval_rank_eval_metric_expected_reciprocal_rank = global_rank_eval_rank_eval_metric_base.and(z.object({
    maximum_relevance: z.number().register(z.globalRegistry, {
        description: "The highest relevance grade used in the user-supplied relevance judgments."
    })
}));

/**
 * Discounted cumulative gain (DCG)
 */
export const global_rank_eval_rank_eval_metric_discounted_cumulative_gain = global_rank_eval_rank_eval_metric_base.and(z.object({
    normalize: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If set to true, this metric will calculate the Normalized DCG."
    })).default(false)
}));

export const global_rank_eval_rank_eval_metric_rating_treshold = global_rank_eval_rank_eval_metric_base.and(z.object({
    relevant_rating_threshold: z.optional(z.number().register(z.globalRegistry, {
        description: "Sets the rating threshold above which documents are considered to be \"relevant\"."
    })).default(1)
}));

/**
 * Mean Reciprocal Rank
 */
export const global_rank_eval_rank_eval_metric_mean_reciprocal_rank = global_rank_eval_rank_eval_metric_rating_treshold.and(z.record(z.string(), z.unknown()));

/**
 * Recall at K (R@k)
 */
export const global_rank_eval_rank_eval_metric_recall = global_rank_eval_rank_eval_metric_rating_treshold.and(z.record(z.string(), z.unknown()));

/**
 * Precision at K (P@k)
 */
export const global_rank_eval_rank_eval_metric_precision = global_rank_eval_rank_eval_metric_rating_treshold.and(z.object({
    ignore_unlabeled: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Controls how unlabeled documents in the search results are counted. If set to true, unlabeled documents are ignored and neither count as relevant or irrelevant. Set to false (the default), they are treated as irrelevant."
    })).default(false)
}));

export const global_rank_eval_rank_eval_metric = z.object({
    precision: z.optional(global_rank_eval_rank_eval_metric_precision),
    recall: z.optional(global_rank_eval_rank_eval_metric_recall),
    mean_reciprocal_rank: z.optional(global_rank_eval_rank_eval_metric_mean_reciprocal_rank),
    dcg: z.optional(global_rank_eval_rank_eval_metric_discounted_cumulative_gain),
    expected_reciprocal_rank: z.optional(global_rank_eval_rank_eval_metric_expected_reciprocal_rank)
});

export const global_rank_eval_document_rating = z.object({
    _id: types_id,
    _index: types_index_name,
    rating: z.number().register(z.globalRegistry, {
        description: "The document’s relevance with regard to this search request."
    })
});

export const types_project_routing = z.string();

/**
 * Contains parameters used to limit or change the subsequent search body request.
 */
export const global_msearch_multisearch_header = z.object({
    allow_no_indices: z.optional(z.boolean()),
    expand_wildcards: z.optional(types_expand_wildcards),
    ignore_unavailable: z.optional(z.boolean()),
    index: z.optional(types_indices),
    preference: z.optional(z.string()),
    project_routing: z.optional(types_project_routing),
    request_cache: z.optional(z.boolean()),
    routing: z.optional(types_routing),
    search_type: z.optional(types_search_type),
    ccs_minimize_roundtrips: z.optional(z.boolean()),
    allow_partial_search_results: z.optional(z.boolean()),
    ignore_throttled: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: "Contains parameters used to limit or change the subsequent search body request."
});

/**
 * The response returned by Elasticsearch when request execution did not succeed.
 */
export const types_error_response_base = z.object({
    error: types_error_cause,
    status: z.number()
}).register(z.globalRegistry, {
    description: "The response returned by Elasticsearch when request execution did not succeed."
});

export const global_search_types_term_suggest_option = z.object({
    text: z.string(),
    score: z.number(),
    freq: z.number(),
    highlighted: z.optional(z.string()),
    collate_match: z.optional(z.boolean())
});

export const global_search_types_suggest_base = z.object({
    length: z.number(),
    offset: z.number(),
    text: z.string()
});

export const global_search_types_term_suggest = global_search_types_suggest_base.and(z.object({
    options: z.union([
        global_search_types_term_suggest_option,
        z.array(global_search_types_term_suggest_option)
    ])
}));

export const global_search_types_phrase_suggest_option = z.object({
    text: z.string(),
    score: z.number(),
    highlighted: z.optional(z.string()),
    collate_match: z.optional(z.boolean())
});

export const global_search_types_phrase_suggest = global_search_types_suggest_base.and(z.object({
    options: z.union([
        global_search_types_phrase_suggest_option,
        z.array(global_search_types_phrase_suggest_option)
    ])
}));

/**
 * Text or location that we want similar documents for or a lookup to a document's field for the text.
 */
export const global_search_types_context = z.union([
    z.string(),
    types_geo_location
]);

export const global_search_types_completion_suggest_option = z.object({
    collate_match: z.optional(z.boolean()),
    contexts: z.optional(z.record(z.string(), z.array(global_search_types_context))),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    _id: z.optional(z.string()),
    _index: z.optional(types_index_name),
    _routing: z.optional(types_routing),
    _score: z.optional(z.number()),
    _source: z.optional(z.record(z.string(), z.unknown())),
    text: z.string(),
    score: z.optional(z.number())
});

export const global_search_types_completion_suggest = global_search_types_suggest_base.and(z.object({
    options: z.union([
        global_search_types_completion_suggest_option,
        z.array(global_search_types_completion_suggest_option)
    ])
}));

export const global_search_types_suggest = z.union([
    global_search_types_completion_suggest,
    global_search_types_phrase_suggest,
    global_search_types_term_suggest
]);

export const types_scroll_id = z.string();

export const global_search_types_query_breakdown = z.object({
    advance: z.number(),
    advance_count: z.number(),
    build_scorer: z.number(),
    build_scorer_count: z.number(),
    create_weight: z.number(),
    create_weight_count: z.number(),
    match: z.number(),
    match_count: z.number(),
    shallow_advance: z.number(),
    shallow_advance_count: z.number(),
    next_doc: z.number(),
    next_doc_count: z.number(),
    score: z.number(),
    score_count: z.number(),
    compute_max_score: z.number(),
    compute_max_score_count: z.number(),
    count_weight: z.number(),
    count_weight_count: z.number(),
    set_min_competitive_score: z.number(),
    set_min_competitive_score_count: z.number()
});

export const global_search_types_query_profile = z.object({
    breakdown: global_search_types_query_breakdown,
    description: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    type: z.string(),
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_query_profile)));
    }
});

export const global_search_types_collector = z.object({
    name: z.string(),
    reason: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_collector)));
    }
});

export const global_search_types_search_profile = z.object({
    collector: z.array(global_search_types_collector),
    query: z.array(global_search_types_query_profile),
    rewrite_time: z.number()
});

export const global_search_types_fetch_profile_debug = z.object({
    stored_fields: z.optional(z.array(z.string())),
    fast_path: z.optional(z.number())
});

export const global_search_types_fetch_profile_breakdown = z.object({
    load_source: z.optional(z.number()),
    load_source_count: z.optional(z.number()),
    load_stored_fields: z.optional(z.number()),
    load_stored_fields_count: z.optional(z.number()),
    next_reader: z.optional(z.number()),
    next_reader_count: z.optional(z.number()),
    process_count: z.optional(z.number()),
    process: z.optional(z.number())
});

export const global_search_types_fetch_profile = z.object({
    type: z.string(),
    description: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    breakdown: global_search_types_fetch_profile_breakdown,
    debug: z.optional(global_search_types_fetch_profile_debug),
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_fetch_profile)));
    }
});

export const global_search_types_knn_collector_result = z.object({
    name: z.string(),
    reason: z.string(),
    time: z.optional(types_duration),
    time_in_nanos: types_duration_value_unit_nanos,
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_knn_collector_result)));
    }
});

export const global_search_types_knn_query_profile_breakdown = z.object({
    advance: z.number(),
    advance_count: z.number(),
    build_scorer: z.number(),
    build_scorer_count: z.number(),
    compute_max_score: z.number(),
    compute_max_score_count: z.number(),
    count_weight: z.number(),
    count_weight_count: z.number(),
    create_weight: z.number(),
    create_weight_count: z.number(),
    match: z.number(),
    match_count: z.number(),
    next_doc: z.number(),
    next_doc_count: z.number(),
    score: z.number(),
    score_count: z.number(),
    set_min_competitive_score: z.number(),
    set_min_competitive_score_count: z.number(),
    shallow_advance: z.number(),
    shallow_advance_count: z.number()
});

export const global_search_types_knn_query_profile_result = z.object({
    type: z.string(),
    description: z.string(),
    time: z.optional(types_duration),
    time_in_nanos: types_duration_value_unit_nanos,
    breakdown: global_search_types_knn_query_profile_breakdown,
    debug: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_knn_query_profile_result)));
    }
});

export const global_search_types_dfs_knn_profile = z.object({
    vector_operations_count: z.optional(z.number()),
    query: z.array(global_search_types_knn_query_profile_result),
    rewrite_time: z.number(),
    collector: z.array(global_search_types_knn_collector_result)
});

export const global_search_types_dfs_statistics_breakdown = z.object({
    collection_statistics: z.number(),
    collection_statistics_count: z.number(),
    create_weight: z.number(),
    create_weight_count: z.number(),
    rewrite: z.number(),
    rewrite_count: z.number(),
    term_statistics: z.number(),
    term_statistics_count: z.number()
});

export const global_search_types_dfs_statistics_profile = z.object({
    type: z.string(),
    description: z.string(),
    time: z.optional(types_duration),
    time_in_nanos: types_duration_value_unit_nanos,
    breakdown: global_search_types_dfs_statistics_breakdown,
    debug: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_dfs_statistics_profile)));
    }
});

export const global_search_types_dfs_profile = z.object({
    statistics: z.optional(global_search_types_dfs_statistics_profile),
    knn: z.optional(z.array(global_search_types_dfs_knn_profile))
});

export const global_search_types_aggregation_profile_delegate_debug_filter = z.object({
    results_from_metadata: z.optional(z.number()),
    query: z.optional(z.string()),
    specialized_for: z.optional(z.string()),
    segments_counted_in_constant_time: z.optional(z.number())
});

export const global_search_types_aggregation_profile_debug = z.object({
    segments_with_multi_valued_ords: z.optional(z.number()),
    collection_strategy: z.optional(z.string()),
    segments_with_single_valued_ords: z.optional(z.number()),
    total_buckets: z.optional(z.number()),
    built_buckets: z.optional(z.number()),
    result_strategy: z.optional(z.string()),
    has_filter: z.optional(z.boolean()),
    delegate: z.optional(z.string()),
    get delegate_debug() {
        return z.optional(z.lazy((): any => global_search_types_aggregation_profile_debug));
    },
    chars_fetched: z.optional(z.number()),
    extract_count: z.optional(z.number()),
    extract_ns: z.optional(z.number()),
    values_fetched: z.optional(z.number()),
    collect_analyzed_ns: z.optional(z.number()),
    collect_analyzed_count: z.optional(z.number()),
    surviving_buckets: z.optional(z.number()),
    ordinals_collectors_used: z.optional(z.number()),
    ordinals_collectors_overhead_too_high: z.optional(z.number()),
    string_hashing_collectors_used: z.optional(z.number()),
    numeric_collectors_used: z.optional(z.number()),
    empty_collectors_used: z.optional(z.number()),
    deferred_aggregators: z.optional(z.array(z.string())),
    segments_with_doc_count_field: z.optional(z.number()),
    segments_with_deleted_docs: z.optional(z.number()),
    filters: z.optional(z.array(global_search_types_aggregation_profile_delegate_debug_filter)),
    segments_counted: z.optional(z.number()),
    segments_collected: z.optional(z.number()),
    map_reducer: z.optional(z.string()),
    brute_force_used: z.optional(z.number()),
    dynamic_pruning_attempted: z.optional(z.number()),
    dynamic_pruning_used: z.optional(z.number()),
    skipped_due_to_no_data: z.optional(z.number())
});

export const global_search_types_aggregation_breakdown = z.object({
    build_aggregation: z.number(),
    build_aggregation_count: z.number(),
    build_leaf_collector: z.number(),
    build_leaf_collector_count: z.number(),
    collect: z.number(),
    collect_count: z.number(),
    initialize: z.number(),
    initialize_count: z.number(),
    post_collection: z.optional(z.number()),
    post_collection_count: z.optional(z.number()),
    reduce: z.number(),
    reduce_count: z.number()
});

export const global_search_types_aggregation_profile = z.object({
    breakdown: global_search_types_aggregation_breakdown,
    description: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    type: z.string(),
    debug: z.optional(global_search_types_aggregation_profile_debug),
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_aggregation_profile)));
    }
});

export const global_search_types_shard_profile = z.object({
    aggregations: z.array(global_search_types_aggregation_profile),
    cluster: z.string(),
    dfs: z.optional(global_search_types_dfs_profile),
    fetch: z.optional(global_search_types_fetch_profile),
    id: z.string(),
    index: types_index_name,
    node_id: types_node_id,
    searches: z.array(global_search_types_search_profile),
    shard_id: z.number()
});

export const global_search_types_profile = z.object({
    shards: z.array(global_search_types_shard_profile)
});

export const types_cluster_search_status = z.enum([
    'running',
    'successful',
    'partial',
    'skipped',
    'failed'
]);

export const types_cluster_details = z.object({
    status: types_cluster_search_status,
    indices: z.string(),
    took: z.optional(types_duration_value_unit_millis),
    timed_out: z.boolean(),
    _shards: z.optional(types_shard_statistics),
    failures: z.optional(z.array(types_shard_failure))
});

export const types_cluster_statistics = z.object({
    skipped: z.number(),
    successful: z.number(),
    total: z.number(),
    running: z.number(),
    partial: z.number(),
    failed: z.number(),
    details: z.optional(z.record(z.string(), types_cluster_details))
});

/**
 * A GeoJson GeoLine.
 */
export const types_geo_line = z.object({
    type: z.string().register(z.globalRegistry, {
        description: "Always `\"LineString\"`"
    }),
    coordinates: z.array(z.array(z.number())).register(z.globalRegistry, {
        description: "Array of `[lon, lat]` coordinates"
    })
}).register(z.globalRegistry, {
    description: "A GeoJson GeoLine."
});

export const types_aggregations_geo_line_aggregate = types_aggregations_aggregate_base.and(z.object({
    type: z.string(),
    geometry: types_geo_line,
    properties: z.record(z.string(), z.unknown())
}));

export const types_aggregations_matrix_stats_fields = z.object({
    name: types_field,
    count: z.number(),
    mean: z.number(),
    variance: z.number(),
    skewness: z.number(),
    kurtosis: z.number(),
    covariance: z.record(z.string(), z.number()),
    correlation: z.record(z.string(), z.number())
});

export const types_aggregations_matrix_stats_aggregate = types_aggregations_aggregate_base.and(z.object({
    doc_count: z.number(),
    fields: z.optional(z.array(types_aggregations_matrix_stats_fields))
}));

/**
 * Result of the `cumulative_cardinality` aggregation
 */
export const types_aggregations_cumulative_cardinality_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.number(),
    value_as_string: z.optional(z.string())
}));

export const types_aggregations_rate_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.number(),
    value_as_string: z.optional(z.string())
}));

export const types_aggregations_t_test_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    value_as_string: z.optional(z.string())
}));

export const types_aggregations_top_metrics = z.object({
    sort: z.array(z.union([
        types_field_value,
        z.string(),
        z.null()
    ])),
    metrics: z.record(z.string(), z.union([
        types_field_value,
        z.string(),
        z.null()
    ]))
});

export const types_aggregations_top_metrics_aggregate = types_aggregations_aggregate_base.and(z.object({
    top: z.array(types_aggregations_top_metrics)
}));

export const types_aggregations_box_plot_aggregate = types_aggregations_aggregate_base.and(z.object({
    min: z.number(),
    max: z.number(),
    q1: z.number(),
    q2: z.number(),
    q3: z.number(),
    lower: z.number(),
    upper: z.number(),
    min_as_string: z.optional(z.string()),
    max_as_string: z.optional(z.string()),
    q1_as_string: z.optional(z.string()),
    q2_as_string: z.optional(z.string()),
    q3_as_string: z.optional(z.string()),
    lower_as_string: z.optional(z.string()),
    upper_as_string: z.optional(z.string())
}));

export const types_aggregations_string_stats_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    min_length: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    max_length: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    avg_length: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    entropy: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    distribution: z.optional(z.union([
        z.record(z.string(), z.number()),
        z.string(),
        z.null()
    ])),
    min_length_as_string: z.optional(z.string()),
    max_length_as_string: z.optional(z.string()),
    avg_length_as_string: z.optional(z.string())
}));

export const types_aggregations_inference_top_class_entry = z.object({
    class_name: types_field_value,
    class_probability: z.number(),
    class_score: z.number()
});

export const types_aggregations_inference_class_importance = z.object({
    class_name: z.string(),
    importance: z.number()
});

export const types_aggregations_inference_feature_importance = z.object({
    feature_name: z.string(),
    importance: z.optional(z.number()),
    classes: z.optional(z.array(types_aggregations_inference_class_importance))
});

export const types_aggregations_inference_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.optional(types_field_value),
    feature_importance: z.optional(z.array(types_aggregations_inference_feature_importance)),
    top_classes: z.optional(z.array(types_aggregations_inference_top_class_entry)),
    warning: z.optional(z.string())
}));

export const global_search_types_nested_identity = z.object({
    field: types_field,
    offset: z.number(),
    get _nested() {
        return z.optional(z.lazy((): any => global_search_types_nested_identity));
    }
});

export const global_explain_explanation_detail = z.object({
    description: z.string(),
    get details() {
        return z.optional(z.array(z.lazy((): any => global_explain_explanation_detail)));
    },
    value: z.number()
});

export const global_explain_explanation = z.object({
    description: z.string(),
    details: z.array(global_explain_explanation_detail),
    value: z.number()
});

export const global_search_types_total_hits_relation = z.enum([
    'eq',
    'gte'
]);

export const global_search_types_total_hits = z.object({
    relation: global_search_types_total_hits_relation,
    value: z.number()
});

export const types_aggregations_scripted_metric_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.record(z.string(), z.unknown())
}));

export const types_aggregations_time_series_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.record(z.string(), types_field_value)
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_time_series_bucket = z.union([
    z.record(z.string(), types_aggregations_time_series_bucket),
    z.array(types_aggregations_time_series_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_time_series_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_time_series_bucket
}));

export const types_aggregations_time_series_aggregate = types_aggregations_multi_bucket_aggregate_base_time_series_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_frequent_item_sets_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.record(z.string(), z.array(z.string())),
    support: z.number()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_frequent_item_sets_bucket = z.union([
    z.record(z.string(), types_aggregations_frequent_item_sets_bucket),
    z.array(types_aggregations_frequent_item_sets_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_frequent_item_sets_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_frequent_item_sets_bucket
}));

export const types_aggregations_frequent_item_sets_aggregate = types_aggregations_multi_bucket_aggregate_base_frequent_item_sets_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_significant_terms_aggregate_base_void = types_aggregations_multi_bucket_aggregate_base_void.and(z.object({
    bg_count: z.optional(z.number()),
    doc_count: z.optional(z.number())
}));

/**
 * Result of the `significant_terms` aggregation on an unmapped field. `buckets` is always empty.
 */
export const types_aggregations_unmapped_significant_terms_aggregate = types_aggregations_significant_terms_aggregate_base_void.and(z.record(z.string(), z.unknown()));

export const types_aggregations_significant_terms_bucket_base = types_aggregations_multi_bucket_base.and(z.object({
    score: z.number(),
    bg_count: z.number()
}));

export const types_aggregations_significant_string_terms_bucket = types_aggregations_significant_terms_bucket_base.and(z.object({
    key: z.string()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_significant_string_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_significant_string_terms_bucket),
    z.array(types_aggregations_significant_string_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_significant_string_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_significant_string_terms_bucket
}));

export const types_aggregations_significant_terms_aggregate_base_significant_string_terms_bucket = types_aggregations_multi_bucket_aggregate_base_significant_string_terms_bucket.and(z.object({
    bg_count: z.optional(z.number()),
    doc_count: z.optional(z.number())
}));

export const types_aggregations_significant_string_terms_aggregate = types_aggregations_significant_terms_aggregate_base_significant_string_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_significant_long_terms_bucket = types_aggregations_significant_terms_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_significant_long_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_significant_long_terms_bucket),
    z.array(types_aggregations_significant_long_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_significant_long_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_significant_long_terms_bucket
}));

export const types_aggregations_significant_terms_aggregate_base_significant_long_terms_bucket = types_aggregations_multi_bucket_aggregate_base_significant_long_terms_bucket.and(z.object({
    bg_count: z.optional(z.number()),
    doc_count: z.optional(z.number())
}));

export const types_aggregations_significant_long_terms_aggregate = types_aggregations_significant_terms_aggregate_base_significant_long_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_adjacency_matrix_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.string()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_adjacency_matrix_bucket = z.union([
    z.record(z.string(), types_aggregations_adjacency_matrix_bucket),
    z.array(types_aggregations_adjacency_matrix_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_adjacency_matrix_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_adjacency_matrix_bucket
}));

export const types_aggregations_adjacency_matrix_aggregate = types_aggregations_multi_bucket_aggregate_base_adjacency_matrix_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_ip_prefix_bucket = types_aggregations_multi_bucket_base.and(z.object({
    is_ipv6: z.boolean(),
    key: z.string(),
    prefix_length: z.number(),
    netmask: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_ip_prefix_bucket = z.union([
    z.record(z.string(), types_aggregations_ip_prefix_bucket),
    z.array(types_aggregations_ip_prefix_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_ip_prefix_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_ip_prefix_bucket
}));

export const types_aggregations_ip_prefix_aggregate = types_aggregations_multi_bucket_aggregate_base_ip_prefix_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_ip_range_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.optional(z.string()),
    from: z.optional(z.string()),
    to: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_ip_range_bucket = z.union([
    z.record(z.string(), types_aggregations_ip_range_bucket),
    z.array(types_aggregations_ip_range_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_ip_range_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_ip_range_bucket
}));

export const types_aggregations_ip_range_aggregate = types_aggregations_multi_bucket_aggregate_base_ip_range_bucket.and(z.record(z.string(), z.unknown()));

/**
 * Result of a `geo_distance` aggregation. The unit for `from` and `to` is meters by default.
 */
export const types_aggregations_geo_distance_aggregate = types_aggregations_range_aggregate.and(z.record(z.string(), z.unknown()));

export const types_aggregations_geo_hex_grid_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_geo_hex_cell
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_geo_hex_grid_bucket = z.union([
    z.record(z.string(), types_aggregations_geo_hex_grid_bucket),
    z.array(types_aggregations_geo_hex_grid_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_geo_hex_grid_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_geo_hex_grid_bucket
}));

export const types_aggregations_geo_hex_grid_aggregate = types_aggregations_multi_bucket_aggregate_base_geo_hex_grid_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_geo_tile_grid_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_geo_tile
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_geo_tile_grid_bucket = z.union([
    z.record(z.string(), types_aggregations_geo_tile_grid_bucket),
    z.array(types_aggregations_geo_tile_grid_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_geo_tile_grid_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_geo_tile_grid_bucket
}));

export const types_aggregations_geo_tile_grid_aggregate = types_aggregations_multi_bucket_aggregate_base_geo_tile_grid_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_geo_hash_grid_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_geo_hash
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_geo_hash_grid_bucket = z.union([
    z.record(z.string(), types_aggregations_geo_hash_grid_bucket),
    z.array(types_aggregations_geo_hash_grid_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_geo_hash_grid_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_geo_hash_grid_bucket
}));

export const types_aggregations_geo_hash_grid_aggregate = types_aggregations_multi_bucket_aggregate_base_geo_hash_grid_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_unmapped_sampler_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_sampler_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_parent_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_children_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_global_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_reverse_nested_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_nested_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

/**
 * Result of a `rare_terms` aggregation when the field is unmapped. `buckets` is always empty.
 */
export const types_aggregations_unmapped_rare_terms_aggregate = types_aggregations_multi_bucket_aggregate_base_void.and(z.record(z.string(), z.unknown()));

export const types_aggregations_string_rare_terms_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.string()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_string_rare_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_string_rare_terms_bucket),
    z.array(types_aggregations_string_rare_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_string_rare_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_string_rare_terms_bucket
}));

/**
 * Result of the `rare_terms` aggregation when the field is a string.
 */
export const types_aggregations_string_rare_terms_aggregate = types_aggregations_multi_bucket_aggregate_base_string_rare_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_long_rare_terms_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_long_rare_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_long_rare_terms_bucket),
    z.array(types_aggregations_long_rare_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_long_rare_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_long_rare_terms_bucket
}));

/**
 * Result of the `rare_terms` aggregation when the field is some kind of whole number like a integer, long, or a date.
 */
export const types_aggregations_long_rare_terms_aggregate = types_aggregations_multi_bucket_aggregate_base_long_rare_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_variable_width_histogram_bucket = types_aggregations_multi_bucket_base.and(z.object({
    min: z.number(),
    key: z.number(),
    max: z.number(),
    min_as_string: z.optional(z.string()),
    key_as_string: z.optional(z.string()),
    max_as_string: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_variable_width_histogram_bucket = z.union([
    z.record(z.string(), types_aggregations_variable_width_histogram_bucket),
    z.array(types_aggregations_variable_width_histogram_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_variable_width_histogram_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_variable_width_histogram_bucket
}));

export const types_aggregations_variable_width_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_variable_width_histogram_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_date_histogram_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key_as_string: z.optional(z.string()),
    key: types_epoch_time_unit_millis
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_date_histogram_bucket = z.union([
    z.record(z.string(), types_aggregations_date_histogram_bucket),
    z.array(types_aggregations_date_histogram_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_date_histogram_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_date_histogram_bucket
}));

export const types_aggregations_auto_date_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_date_histogram_bucket.and(z.object({
    interval: types_duration_large
}));

export const types_aggregations_date_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_date_histogram_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_histogram_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key_as_string: z.optional(z.string()),
    key: z.number()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_histogram_bucket = z.union([
    z.record(z.string(), types_aggregations_histogram_bucket),
    z.array(types_aggregations_histogram_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_histogram_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_histogram_bucket
}));

export const types_aggregations_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_histogram_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_geo_centroid_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    location: z.optional(types_geo_location)
}));

export const types_aggregations_geo_bounds_aggregate = types_aggregations_aggregate_base.and(z.object({
    bounds: z.optional(types_geo_bounds)
}));

export const types_cartesian_point = z.object({
    x: z.number(),
    y: z.number()
});

export const types_aggregations_cartesian_centroid_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    location: z.optional(types_cartesian_point)
}));

export const types_aggregations_cartesian_bounds_aggregate = types_aggregations_aggregate_base.and(z.object({
    bounds: z.optional(types_top_left_bottom_right_geo_bounds)
}));

export const types_aggregations_standard_deviation_bounds_as_string = z.object({
    upper: z.string(),
    lower: z.string(),
    upper_population: z.string(),
    lower_population: z.string(),
    upper_sampling: z.string(),
    lower_sampling: z.string()
});

export const types_aggregations_standard_deviation_bounds = z.object({
    upper: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    lower: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    upper_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    lower_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    upper_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    lower_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ])
});

/**
 * Statistics aggregation result. `min`, `max` and `avg` are missing if there were no values to process
 * (`count` is zero).
 */
export const types_aggregations_stats_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    min: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    max: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    avg: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    sum: z.number(),
    min_as_string: z.optional(z.string()),
    max_as_string: z.optional(z.string()),
    avg_as_string: z.optional(z.string()),
    sum_as_string: z.optional(z.string())
}));

export const types_aggregations_extended_stats_aggregate = types_aggregations_stats_aggregate.and(z.object({
    sum_of_squares: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    variance: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    variance_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    variance_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation_bounds: z.optional(types_aggregations_standard_deviation_bounds),
    sum_of_squares_as_string: z.optional(z.string()),
    variance_as_string: z.optional(z.string()),
    variance_population_as_string: z.optional(z.string()),
    variance_sampling_as_string: z.optional(z.string()),
    std_deviation_as_string: z.optional(z.string()),
    std_deviation_bounds_as_string: z.optional(types_aggregations_standard_deviation_bounds_as_string)
}));

export const types_aggregations_extended_stats_bucket_aggregate = types_aggregations_extended_stats_aggregate.and(z.record(z.string(), z.unknown()));

export const types_aggregations_stats_bucket_aggregate = types_aggregations_stats_aggregate.and(z.record(z.string(), z.unknown()));

export const types_aggregations_change_point_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_field_value
}));

export const types_aggregations_trend_change = z.object({
    p_value: z.number(),
    r_value: z.number(),
    change_point: z.number()
});

export const types_aggregations_abstract_change_point = z.object({
    p_value: z.number(),
    change_point: z.number()
});

export const types_aggregations_step_change = types_aggregations_abstract_change_point.and(z.record(z.string(), z.unknown()));

export const types_aggregations_stationary = z.record(z.string(), z.unknown());

export const types_aggregations_spike = types_aggregations_abstract_change_point.and(z.record(z.string(), z.unknown()));

export const types_aggregations_non_stationary = z.object({
    p_value: z.number(),
    r_value: z.number(),
    trend: z.string()
});

export const types_aggregations_indeterminable = z.object({
    reason: z.string()
});

export const types_aggregations_distribution_change = types_aggregations_abstract_change_point.and(z.record(z.string(), z.unknown()));

export const types_aggregations_dip = types_aggregations_abstract_change_point.and(z.record(z.string(), z.unknown()));

export const types_aggregations_change_type = z.object({
    dip: z.optional(types_aggregations_dip),
    distribution_change: z.optional(types_aggregations_distribution_change),
    indeterminable: z.optional(types_aggregations_indeterminable),
    non_stationary: z.optional(types_aggregations_non_stationary),
    spike: z.optional(types_aggregations_spike),
    stationary: z.optional(types_aggregations_stationary),
    step_change: z.optional(types_aggregations_step_change),
    trend_change: z.optional(types_aggregations_trend_change)
});

export const types_aggregations_change_point_aggregate = types_aggregations_aggregate_base.and(z.object({
    type: types_aggregations_change_type,
    bucket: z.optional(types_aggregations_change_point_bucket)
}));

export const types_aggregations_bucket_metric_value_aggregate = types_aggregations_single_metric_aggregate_base.and(z.object({
    keys: z.array(z.string())
}));

export const types_aggregations_derivative_aggregate = types_aggregations_single_metric_aggregate_base.and(z.object({
    normalized_value: z.optional(z.number()),
    normalized_value_as_string: z.optional(z.string())
}));

export const types_aggregations_simple_value_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

/**
 * Weighted average aggregation result. `value` is missing if the weight was set to zero.
 */
export const types_aggregations_weighted_avg_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_avg_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

/**
 * Sum aggregation result. `value` is always present and is zero if there were no values to process.
 */
export const types_aggregations_sum_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_max_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_min_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_median_absolute_deviation_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_array_percentiles_item = z.object({
    key: z.number(),
    value: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    value_as_string: z.optional(z.string())
});

export const types_aggregations_keyed_percentiles = z.record(z.string(), z.union([
    z.string(),
    z.number(),
    z.null()
]));

export const types_aggregations_percentiles = z.union([
    types_aggregations_keyed_percentiles,
    z.array(types_aggregations_array_percentiles_item)
]);

export const types_aggregations_percentiles_aggregate_base = types_aggregations_aggregate_base.and(z.object({
    values: types_aggregations_percentiles
}));

export const types_aggregations_percentiles_bucket_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_t_digest_percentile_ranks_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_t_digest_percentiles_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_hdr_percentile_ranks_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_hdr_percentiles_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.string(), z.unknown()));

export const global_field_caps_field_capability = z.object({
    aggregatable: z.boolean().register(z.globalRegistry, {
        description: "Whether this field can be aggregated on all indices."
    }),
    indices: z.optional(types_indices),
    meta: z.optional(types_metadata),
    non_aggregatable_indices: z.optional(types_indices),
    non_searchable_indices: z.optional(types_indices),
    searchable: z.boolean().register(z.globalRegistry, {
        description: "Whether this field is indexed for search on all indices."
    }),
    type: z.string(),
    metadata_field: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Whether this field is registered as a metadata field."
    })),
    time_series_dimension: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Whether this field is used as a time series dimension."
    })),
    time_series_metric: z.optional(types_mapping_time_series_metric_type),
    non_dimension_indices: z.optional(z.array(types_index_name).register(z.globalRegistry, {
        description: "If this list is present in response then some indices have the\nfield marked as a dimension and other indices, the ones in this list, do not."
    })),
    metric_conflicts_indices: z.optional(z.array(types_index_name).register(z.globalRegistry, {
        description: "The list of indices where this field is present if these indices\ndon’t have the same `time_series_metric` value for this field."
    }))
});

export const types_scroll_ids = z.union([
    types_scroll_id,
    z.array(types_scroll_id)
]);

/**
 * Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.
 * Used as a query parameter along with the `_source_includes` and `_source_excludes` parameters.
 */
export const global_search_types_source_config_param = z.union([
    z.boolean(),
    types_fields
]);

export const types_suggest_mode = z.enum([
    'missing',
    'popular',
    'always'
]);

export const async_search_types_async_search_response_base = z.object({
    id: z.optional(types_id),
    is_partial: z.boolean().register(z.globalRegistry, {
        description: "When the query is no longer running, this property indicates whether the search failed or was successfully completed on all shards.\nWhile the query is running, `is_partial` is always set to `true`."
    }),
    is_running: z.boolean().register(z.globalRegistry, {
        description: "Indicates whether the search is still running or has completed.\n\n> info\n> If the search failed after some shards returned their results or the node that is coordinating the async search dies, results may be partial even though `is_running` is `false`."
    }),
    expiration_time: z.optional(types_date_time),
    expiration_time_in_millis: types_epoch_time_unit_millis,
    start_time: z.optional(types_date_time),
    start_time_in_millis: types_epoch_time_unit_millis,
    completion_time: z.optional(types_date_time),
    completion_time_in_millis: z.optional(types_epoch_time_unit_millis),
    error: z.optional(types_error_cause)
});

export const async_search_status_status_response_base = async_search_types_async_search_response_base.and(z.object({
    _shards: types_shard_statistics,
    _clusters: z.optional(types_cluster_statistics),
    completion_status: z.optional(z.number().register(z.globalRegistry, {
        description: "If the async search completed, this field shows the status code of the search.\nFor example, `200` indicates that the async search was successfully completed.\n`503` indicates that the async search was completed with an error."
    }))
}));

export const types_query_dsl_terms_set_query = types_query_dsl_query_base.and(z.lazy(() => z.object({
    minimum_should_match: z.optional(types_minimum_should_match),
    minimum_should_match_field: z.optional(types_field),
    get minimum_should_match_script() {
        return z.optional(z.lazy((): any => types_script));
    },
    terms: z.array(types_field_value).register(z.globalRegistry, {
        description: "Array of terms you wish to find in the provided field."
    })
})));

export const types_mapping_runtime_field = z.object({
    fields: z.optional(z.record(z.string(), types_mapping_composite_sub_field).register(z.globalRegistry, {
        description: "For type `composite`"
    })),
    fetch_fields: z.optional(z.array(types_mapping_runtime_field_fetch_fields).register(z.globalRegistry, {
        description: "For type `lookup`"
    })),
    format: z.optional(z.string().register(z.globalRegistry, {
        description: "A custom format for `date` type runtime fields."
    })),
    input_field: z.optional(types_field),
    target_field: z.optional(types_field),
    target_index: z.optional(types_index_name),
    get script() {
        return z.optional(z.lazy((): any => types_script));
    },
    type: types_mapping_runtime_field_type
});

export const types_script = z.object({
    get source() {
        return z.optional(z.lazy((): any => types_script_source));
    },
    id: z.optional(types_id),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "Specifies any named parameters that are passed into the script as variables.\nUse parameters instead of hard-coded values to decrease compile time."
    })),
    lang: z.optional(types_script_language),
    options: z.optional(z.record(z.string(), z.string()))
});

export const types_mapping_runtime_fields = z.record(z.string(), types_mapping_runtime_field);

export const types_pinned_retriever = z.lazy((): any => types_retriever_base).and(z.lazy(() => z.object({
    get retriever() {
        return z.lazy((): any => types_retriever_container);
    },
    ids: z.optional(z.array(z.string())),
    docs: z.optional(z.array(types_specified_document)),
    rank_window_size: z.optional(z.number())
})));

export const types_retriever_container = z.object({
    get standard() {
        return z.optional(z.lazy((): any => types_standard_retriever));
    },
    get knn() {
        return z.optional(z.lazy((): any => types_knn_retriever));
    },
    get rrf() {
        return z.optional(z.lazy((): any => types_rrf_retriever));
    },
    get text_similarity_reranker() {
        return z.optional(z.lazy((): any => types_text_similarity_reranker));
    },
    get rule() {
        return z.optional(z.lazy((): any => types_rule_retriever));
    },
    get rescorer() {
        return z.optional(z.lazy((): any => types_rescorer_retriever));
    },
    get linear() {
        return z.optional(z.lazy((): any => types_linear_retriever));
    },
    pinned: z.optional(types_pinned_retriever)
});

export const types_inner_retriever = z.object({
    retriever: types_retriever_container,
    weight: z.number(),
    normalizer: types_score_normalizer
});

export const types_linear_retriever = z.lazy((): any => types_retriever_base).and(z.object({
    retrievers: z.optional(z.array(types_inner_retriever).register(z.globalRegistry, {
        description: "Inner retrievers."
    })),
    rank_window_size: z.optional(z.number()),
    query: z.optional(z.string()),
    fields: z.optional(z.array(z.string())),
    normalizer: z.optional(types_score_normalizer)
}));

/**
 * An Elasticsearch Query DSL (Domain Specific Language) object that defines a query.
 */
export const types_query_dsl_query_container = z.object({
    get bool() {
        return z.optional(z.lazy((): any => types_query_dsl_bool_query));
    },
    get boosting() {
        return z.optional(z.lazy((): any => types_query_dsl_boosting_query));
    },
    common: z.optional(z.record(z.string(), types_query_dsl_common_terms_query)),
    combined_fields: z.optional(types_query_dsl_combined_fields_query),
    get constant_score() {
        return z.optional(z.lazy((): any => types_query_dsl_constant_score_query));
    },
    get dis_max() {
        return z.optional(z.lazy((): any => types_query_dsl_dis_max_query));
    },
    distance_feature: z.optional(types_query_dsl_distance_feature_query),
    exists: z.optional(types_query_dsl_exists_query),
    get function_score() {
        return z.optional(z.lazy((): any => types_query_dsl_function_score_query));
    },
    fuzzy: z.optional(z.record(z.string(), types_query_dsl_fuzzy_query).register(z.globalRegistry, {
        description: "Returns documents that contain terms similar to the search term, as measured by a Levenshtein edit distance."
    })),
    geo_bounding_box: z.optional(types_query_dsl_geo_bounding_box_query),
    geo_distance: z.optional(types_query_dsl_geo_distance_query),
    geo_grid: z.optional(z.record(z.string(), types_query_dsl_geo_grid_query).register(z.globalRegistry, {
        description: "Matches `geo_point` and `geo_shape` values that intersect a grid cell from a GeoGrid aggregation."
    })),
    geo_polygon: z.optional(types_query_dsl_geo_polygon_query),
    geo_shape: z.optional(types_query_dsl_geo_shape_query),
    get has_child() {
        return z.optional(z.lazy((): any => types_query_dsl_has_child_query));
    },
    get has_parent() {
        return z.optional(z.lazy((): any => types_query_dsl_has_parent_query));
    },
    ids: z.optional(types_query_dsl_ids_query),
    get intervals() {
        return z.optional(z.record(z.string(), z.lazy((): any => types_query_dsl_intervals_query)).register(z.globalRegistry, {
            description: "Returns documents based on the order and proximity of matching terms."
        }));
    },
    get knn() {
        return z.optional(z.lazy((): any => types_knn_query));
    },
    match: z.optional(z.record(z.string(), types_query_dsl_match_query).register(z.globalRegistry, {
        description: "Returns documents that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching."
    })),
    match_all: z.optional(types_query_dsl_match_all_query),
    match_bool_prefix: z.optional(z.record(z.string(), types_query_dsl_match_bool_prefix_query).register(z.globalRegistry, {
        description: "Analyzes its input and constructs a `bool` query from the terms.\nEach term except the last is used in a `term` query.\nThe last term is used in a prefix query."
    })),
    match_none: z.optional(types_query_dsl_match_none_query),
    match_phrase: z.optional(z.record(z.string(), types_query_dsl_match_phrase_query).register(z.globalRegistry, {
        description: "Analyzes the text and creates a phrase query out of the analyzed text."
    })),
    match_phrase_prefix: z.optional(z.record(z.string(), types_query_dsl_match_phrase_prefix_query).register(z.globalRegistry, {
        description: "Returns documents that contain the words of a provided text, in the same order as provided.\nThe last term of the provided text is treated as a prefix, matching any words that begin with that term."
    })),
    more_like_this: z.optional(types_query_dsl_more_like_this_query),
    multi_match: z.optional(types_query_dsl_multi_match_query),
    get nested() {
        return z.optional(z.lazy((): any => types_query_dsl_nested_query));
    },
    parent_id: z.optional(types_query_dsl_parent_id_query),
    percolate: z.optional(types_query_dsl_percolate_query),
    get pinned() {
        return z.optional(z.lazy((): any => types_query_dsl_pinned_query));
    },
    prefix: z.optional(z.record(z.string(), types_query_dsl_prefix_query).register(z.globalRegistry, {
        description: "Returns documents that contain a specific prefix in a provided field."
    })),
    query_string: z.optional(types_query_dsl_query_string_query),
    range: z.optional(z.record(z.string(), types_query_dsl_range_query).register(z.globalRegistry, {
        description: "Returns documents that contain terms within a provided range."
    })),
    rank_feature: z.optional(types_query_dsl_rank_feature_query),
    regexp: z.optional(z.record(z.string(), types_query_dsl_regexp_query).register(z.globalRegistry, {
        description: "Returns documents that contain terms matching a regular expression."
    })),
    get rule() {
        return z.optional(z.lazy((): any => types_query_dsl_rule_query));
    },
    get script() {
        return z.optional(z.lazy((): any => types_query_dsl_script_query));
    },
    get script_score() {
        return z.optional(z.lazy((): any => types_query_dsl_script_score_query));
    },
    semantic: z.optional(types_query_dsl_semantic_query),
    shape: z.optional(types_query_dsl_shape_query),
    simple_query_string: z.optional(types_query_dsl_simple_query_string_query),
    get span_containing() {
        return z.optional(z.lazy((): any => types_query_dsl_span_containing_query));
    },
    get span_field_masking() {
        return z.optional(z.lazy((): any => types_query_dsl_span_field_masking_query));
    },
    get span_first() {
        return z.optional(z.lazy((): any => types_query_dsl_span_first_query));
    },
    get span_multi() {
        return z.optional(z.lazy((): any => types_query_dsl_span_multi_term_query));
    },
    get span_near() {
        return z.optional(z.lazy((): any => types_query_dsl_span_near_query));
    },
    get span_not() {
        return z.optional(z.lazy((): any => types_query_dsl_span_not_query));
    },
    get span_or() {
        return z.optional(z.lazy((): any => types_query_dsl_span_or_query));
    },
    span_term: z.optional(z.record(z.string(), types_query_dsl_span_term_query).register(z.globalRegistry, {
        description: "Matches spans containing a term."
    })),
    get span_within() {
        return z.optional(z.lazy((): any => types_query_dsl_span_within_query));
    },
    sparse_vector: z.optional(types_query_dsl_sparse_vector_query),
    term: z.optional(z.record(z.string(), types_query_dsl_term_query).register(z.globalRegistry, {
        description: "Returns documents that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field's value, including whitespace and capitalization."
    })),
    terms: z.optional(types_query_dsl_terms_query),
    terms_set: z.optional(z.record(z.string(), types_query_dsl_terms_set_query).register(z.globalRegistry, {
        description: "Returns documents that contain a minimum number of exact terms in a provided field.\nTo return a document, a required number of terms must exactly match the field values, including whitespace and capitalization."
    })),
    text_expansion: z.optional(z.record(z.string(), types_query_dsl_text_expansion_query).register(z.globalRegistry, {
        description: "Uses a natural language processing model to convert the query text into a list of token-weight pairs which are then used in a query against a sparse vector or rank features field."
    })),
    weighted_tokens: z.optional(z.record(z.string(), types_query_dsl_weighted_tokens_query).register(z.globalRegistry, {
        description: "Supports returning text_expansion query results by sending in precomputed tokens with the query."
    })),
    wildcard: z.optional(z.record(z.string(), types_query_dsl_wildcard_query).register(z.globalRegistry, {
        description: "Returns documents that contain terms matching a wildcard pattern."
    })),
    wrapper: z.optional(types_query_dsl_wrapper_query),
    type: z.optional(types_query_dsl_type_query)
}).register(z.globalRegistry, {
    description: "An Elasticsearch Query DSL (Domain Specific Language) object that defines a query."
});

export const types_query_dsl_span_within_query = types_query_dsl_query_base.and(z.lazy(() => z.object({
    get big() {
        return z.lazy((): any => types_query_dsl_span_query);
    },
    get little() {
        return z.lazy((): any => types_query_dsl_span_query);
    }
})));

export const types_query_dsl_span_query = z.object({
    get span_containing() {
        return z.optional(z.lazy((): any => types_query_dsl_span_containing_query));
    },
    get span_field_masking() {
        return z.optional(z.lazy((): any => types_query_dsl_span_field_masking_query));
    },
    get span_first() {
        return z.optional(z.lazy((): any => types_query_dsl_span_first_query));
    },
    span_gap: z.optional(types_query_dsl_span_gap_query),
    get span_multi() {
        return z.optional(z.lazy((): any => types_query_dsl_span_multi_term_query));
    },
    get span_near() {
        return z.optional(z.lazy((): any => types_query_dsl_span_near_query));
    },
    get span_not() {
        return z.optional(z.lazy((): any => types_query_dsl_span_not_query));
    },
    get span_or() {
        return z.optional(z.lazy((): any => types_query_dsl_span_or_query));
    },
    span_term: z.optional(z.record(z.string(), types_query_dsl_span_term_query).register(z.globalRegistry, {
        description: "The equivalent of the `term` query but for use with other span queries."
    })),
    span_within: z.optional(types_query_dsl_span_within_query)
});

export const types_query_dsl_span_or_query = types_query_dsl_query_base.and(z.object({
    clauses: z.array(types_query_dsl_span_query).register(z.globalRegistry, {
        description: "Array of one or more other span type queries."
    })
}));

export const types_query_dsl_span_not_query = types_query_dsl_query_base.and(z.object({
    dist: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of tokens from within the include span that can’t have overlap with the exclude span.\nEquivalent to setting both `pre` and `post`."
    })),
    exclude: types_query_dsl_span_query,
    include: types_query_dsl_span_query,
    post: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of tokens after the include span that can’t have overlap with the exclude span."
    })).default(0),
    pre: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of tokens before the include span that can’t have overlap with the exclude span."
    })).default(0)
}));

export const types_query_dsl_span_near_query = types_query_dsl_query_base.and(z.object({
    clauses: z.array(types_query_dsl_span_query).register(z.globalRegistry, {
        description: "Array of one or more other span type queries."
    }),
    in_order: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Controls whether matches are required to be in-order."
    })),
    slop: z.optional(z.number().register(z.globalRegistry, {
        description: "Controls the maximum number of intervening unmatched positions permitted."
    }))
}));

export const types_query_dsl_span_multi_term_query = types_query_dsl_query_base.and(z.object({
    match: types_query_dsl_query_container
}));

export const types_query_dsl_span_first_query = types_query_dsl_query_base.and(z.object({
    end: z.number().register(z.globalRegistry, {
        description: "Controls the maximum end position permitted in a match."
    }),
    match: types_query_dsl_span_query
}));

export const types_query_dsl_span_field_masking_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    query: types_query_dsl_span_query
}));

export const types_query_dsl_span_containing_query = types_query_dsl_query_base.and(z.object({
    big: types_query_dsl_span_query,
    little: types_query_dsl_span_query
}));

export const types_query_dsl_script_score_query = types_query_dsl_query_base.and(z.object({
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: "Documents with a score lower than this floating point number are excluded from the search results."
    })),
    query: types_query_dsl_query_container,
    script: types_script
}));

export const types_rescorer_retriever = z.lazy((): any => types_retriever_base).and(z.object({
    retriever: types_retriever_container,
    rescore: z.union([
        z.lazy((): any => global_search_types_rescore),
        z.array(z.lazy((): any => global_search_types_rescore))
    ])
}));

export const global_search_types_script_rescore = z.object({
    script: types_script
});

export const global_search_types_rescore_query = z.object({
    rescore_query: types_query_dsl_query_container,
    query_weight: z.optional(z.number().register(z.globalRegistry, {
        description: "Relative importance of the original query versus the rescore query."
    })).default(1),
    rescore_query_weight: z.optional(z.number().register(z.globalRegistry, {
        description: "Relative importance of the rescore query versus the original query."
    })).default(1),
    score_mode: z.optional(global_search_types_score_mode)
});

export const global_search_types_rescore = z.object({
    window_size: z.optional(z.number())
}).and(z.object({
    query: z.optional(global_search_types_rescore_query),
    learning_to_rank: z.optional(global_search_types_learning_to_rank),
    script: z.optional(global_search_types_script_rescore)
}));

export const types_retriever_base = z.object({
    filter: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: "Minimum _score for matching documents. Documents with a lower _score are not included in the top documents."
    })),
    _name: z.optional(z.string().register(z.globalRegistry, {
        description: "Retriever name."
    }))
});

export const types_rule_retriever = types_retriever_base.and(z.object({
    ruleset_ids: z.union([
        types_id,
        z.array(types_id)
    ]),
    match_criteria: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: "The match criteria that will determine if a rule in the provided rulesets should be applied."
    }),
    retriever: types_retriever_container,
    rank_window_size: z.optional(z.number().register(z.globalRegistry, {
        description: "This value determines the size of the individual result set."
    }))
}));

export const types_text_similarity_reranker = types_retriever_base.and(z.object({
    retriever: types_retriever_container,
    rank_window_size: z.optional(z.number().register(z.globalRegistry, {
        description: "This value determines how many documents we will consider from the nested retriever."
    })),
    inference_id: z.optional(z.string().register(z.globalRegistry, {
        description: "Unique identifier of the inference endpoint created using the inference API."
    })),
    inference_text: z.string().register(z.globalRegistry, {
        description: "The text snippet used as the basis for similarity comparison."
    }),
    field: z.string().register(z.globalRegistry, {
        description: "The document field to be used for text similarity comparisons. This field should contain the text that will be evaluated against the inference_text."
    }),
    chunk_rescorer: z.optional(types_chunk_rescorer)
}));

/**
 * Wraps a retriever with an optional weight for RRF scoring.
 */
export const types_rrf_retriever_component = z.object({
    retriever: types_retriever_container,
    weight: z.optional(z.number().register(z.globalRegistry, {
        description: "Weight multiplier for this retriever's contribution to the RRF score. Higher values increase influence. Defaults to 1.0 if not specified. Must be non-negative."
    })).default(1)
}).register(z.globalRegistry, {
    description: "Wraps a retriever with an optional weight for RRF scoring."
});

/**
 * Either a direct RetrieverContainer (backward compatible) or an RRFRetrieverComponent with weight.
 */
export const types_rrf_retriever_entry = z.union([
    types_retriever_container,
    types_rrf_retriever_component
]);

export const types_rrf_retriever = types_retriever_base.and(z.object({
    retrievers: z.array(types_rrf_retriever_entry).register(z.globalRegistry, {
        description: "A list of child retrievers to specify which sets of returned top documents will have the RRF formula applied to them. Each retriever can optionally include a weight parameter."
    }),
    rank_constant: z.optional(z.number().register(z.globalRegistry, {
        description: "This value determines how much influence documents in individual result sets per query have over the final ranked result set."
    })),
    rank_window_size: z.optional(z.number().register(z.globalRegistry, {
        description: "This value determines the size of the individual result sets per query."
    })),
    query: z.optional(z.string()),
    fields: z.optional(z.array(z.string()))
}));

export const types_knn_retriever = types_retriever_base.and(z.object({
    field: z.string().register(z.globalRegistry, {
        description: "The name of the vector field to search against."
    }),
    query_vector: z.optional(types_query_vector),
    query_vector_builder: z.optional(types_query_vector_builder),
    k: z.number().register(z.globalRegistry, {
        description: "Number of nearest neighbors to return as top hits."
    }),
    num_candidates: z.number().register(z.globalRegistry, {
        description: "Number of nearest neighbor candidates to consider per shard."
    }),
    visit_percentage: z.optional(z.number().register(z.globalRegistry, {
        description: "The percentage of vectors to explore per shard while doing knn search with bbq_disk"
    })),
    similarity: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum similarity required for a document to be considered a match."
    })),
    rescore_vector: z.optional(types_rescore_vector)
}));

export const types_standard_retriever = types_retriever_base.and(z.lazy(() => z.object({
    query: z.optional(types_query_dsl_query_container),
    search_after: z.optional(types_sort_results),
    terminate_after: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of documents to collect for each shard."
    })),
    get sort() {
        return z.optional(z.lazy((): any => types_sort));
    },
    get collapse() {
        return z.optional(z.lazy((): any => global_search_types_field_collapse));
    }
})));

export const types_script_field = z.object({
    script: types_script,
    ignore_failure: z.optional(z.boolean())
});

export const global_search_types_highlight_field = z.lazy((): any => global_search_types_highlight_base).and(z.object({
    fragment_offset: z.optional(z.number()),
    matched_fields: z.optional(types_fields)
}));

export const global_search_types_highlight_base = z.object({
    type: z.optional(global_search_types_highlighter_type),
    boundary_chars: z.optional(z.string().register(z.globalRegistry, {
        description: "A string that contains each boundary character."
    })).default('.,!? \\t\\n'),
    boundary_max_scan: z.optional(z.number().register(z.globalRegistry, {
        description: "How far to scan for boundary characters."
    })).default(20),
    boundary_scanner: z.optional(global_search_types_boundary_scanner),
    boundary_scanner_locale: z.optional(z.string().register(z.globalRegistry, {
        description: "Controls which locale is used to search for sentence and word boundaries.\nThis parameter takes a form of a language tag, for example: `\"en-US\"`, `\"fr-FR\"`, `\"ja-JP\"`."
    })).default('Locale.ROOT'),
    force_source: z.optional(z.boolean()),
    fragmenter: z.optional(global_search_types_highlighter_fragmenter),
    fragment_size: z.optional(z.number().register(z.globalRegistry, {
        description: "The size of the highlighted fragment in characters."
    })).default(100),
    highlight_filter: z.optional(z.boolean()),
    highlight_query: z.optional(types_query_dsl_query_container),
    max_fragment_length: z.optional(z.number()),
    max_analyzed_offset: z.optional(z.number().register(z.globalRegistry, {
        description: "If set to a non-negative value, highlighting stops at this defined maximum limit.\nThe rest of the text is not processed, thus not highlighted and no error is returned\nThe `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it’s set to lower value than the query setting."
    })),
    no_match_size: z.optional(z.number().register(z.globalRegistry, {
        description: "The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight."
    })).default(0),
    number_of_fragments: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of fragments to return.\nIf the number of fragments is set to `0`, no fragments are returned.\nInstead, the entire field contents are highlighted and returned.\nThis can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.\nIf `number_of_fragments` is `0`, `fragment_size` is ignored."
    })).default(5),
    options: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    order: z.optional(global_search_types_highlighter_order),
    phrase_limit: z.optional(z.number().register(z.globalRegistry, {
        description: "Controls the number of matching phrases in a document that are considered.\nPrevents the `fvh` highlighter from analyzing too many phrases and consuming too much memory.\nWhen using `matched_fields`, `phrase_limit` phrases per matched field are considered. Raising the limit increases query time and consumes more memory.\nOnly supported by the `fvh` highlighter."
    })).default(256),
    post_tags: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: "Use in conjunction with `pre_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags."
    })),
    pre_tags: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: "Use in conjunction with `post_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags."
    })),
    require_field_match: z.optional(z.boolean().register(z.globalRegistry, {
        description: "By default, only fields that contains a query match are highlighted.\nSet to `false` to highlight all fields."
    })).default(true),
    tags_schema: z.optional(global_search_types_highlighter_tags_schema)
});

export const global_search_types_highlight = global_search_types_highlight_base.and(z.object({
    encoder: z.optional(global_search_types_highlighter_encoder),
    fields: z.union([
        z.record(z.string(), global_search_types_highlight_field),
        z.array(z.record(z.string(), global_search_types_highlight_field))
    ])
}));

export const global_search_types_inner_hits = z.object({
    name: z.optional(types_name),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of hits to return per `inner_hits`."
    })).default(3),
    from: z.optional(z.number().register(z.globalRegistry, {
        description: "Inner hit starting document offset."
    })).default(0),
    get collapse() {
        return z.optional(z.lazy((): any => global_search_types_field_collapse));
    },
    docvalue_fields: z.optional(z.array(types_query_dsl_field_and_format)),
    explain: z.optional(z.boolean()),
    highlight: z.optional(global_search_types_highlight),
    ignore_unmapped: z.optional(z.boolean()),
    script_fields: z.optional(z.record(z.string(), types_script_field)),
    seq_no_primary_term: z.optional(z.boolean()),
    fields: z.optional(z.array(types_field)),
    get sort() {
        return z.optional(z.lazy((): any => types_sort));
    },
    _source: z.optional(global_search_types_source_config),
    stored_fields: z.optional(types_fields),
    track_scores: z.optional(z.boolean()).default(false),
    version: z.optional(z.boolean())
});

export const types_script_sort = z.object({
    order: z.optional(types_sort_order),
    script: types_script,
    type: z.optional(types_script_sort_type),
    mode: z.optional(types_sort_mode),
    get nested() {
        return z.optional(z.lazy((): any => types_nested_sort_value));
    }
});

export const types_nested_sort_value = z.object({
    filter: z.optional(types_query_dsl_query_container),
    max_children: z.optional(z.number()),
    get nested() {
        return z.optional(z.lazy((): any => types_nested_sort_value));
    },
    path: types_field
});

export const types_geo_distance_sort = z.object({
    mode: z.optional(types_sort_mode),
    distance_type: z.optional(types_geo_distance_type),
    ignore_unmapped: z.optional(z.boolean()),
    order: z.optional(types_sort_order),
    unit: z.optional(types_distance_unit),
    nested: z.optional(types_nested_sort_value)
});

export const types_sort_options = z.object({
    _score: z.optional(types_score_sort),
    _doc: z.optional(types_score_sort),
    _geo_distance: z.optional(types_geo_distance_sort),
    _script: z.optional(types_script_sort)
});

export const types_sort_combinations = z.union([
    types_field,
    types_sort_options
]);

export const types_sort = z.union([
    types_sort_combinations,
    z.array(types_sort_combinations)
]);

export const global_search_types_field_collapse = z.object({
    field: types_field,
    inner_hits: z.optional(z.union([
        global_search_types_inner_hits,
        z.array(global_search_types_inner_hits)
    ])),
    max_concurrent_group_searches: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of concurrent requests allowed to retrieve the inner_hits per group"
    })),
    get collapse() {
        return z.optional(z.lazy((): any => global_search_types_field_collapse));
    }
});

export const types_knn_search = z.object({
    field: types_field,
    query_vector: z.optional(types_query_vector),
    query_vector_builder: z.optional(types_query_vector_builder),
    k: z.optional(z.number().register(z.globalRegistry, {
        description: "The final number of nearest neighbors to return as top hits"
    })),
    num_candidates: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of nearest neighbor candidates to consider per shard"
    })),
    visit_percentage: z.optional(z.number().register(z.globalRegistry, {
        description: "The percentage of vectors to explore per shard while doing knn search with bbq_disk"
    })),
    boost: z.optional(z.number().register(z.globalRegistry, {
        description: "Boost value to apply to kNN scores"
    })),
    filter: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    similarity: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum similarity for a vector to be considered a match"
    })),
    inner_hits: z.optional(global_search_types_inner_hits),
    rescore_vector: z.optional(types_rescore_vector)
});

export const types_aggregations_aggregation_container = z.object({
    get aggregations() {
        return z.optional(z.record(z.string(), z.lazy((): any => types_aggregations_aggregation_container)).register(z.globalRegistry, {
            description: "Sub-aggregations for this aggregation.\nOnly applies to bucket aggregations."
        }));
    },
    meta: z.optional(types_metadata)
}).and(z.lazy(() => z.object({
    get adjacency_matrix() {
        return z.optional(z.lazy((): any => types_aggregations_adjacency_matrix_aggregation));
    },
    get auto_date_histogram() {
        return z.optional(z.lazy((): any => types_aggregations_auto_date_histogram_aggregation));
    },
    get avg() {
        return z.optional(z.lazy((): any => types_aggregations_average_aggregation));
    },
    avg_bucket: z.optional(types_aggregations_average_bucket_aggregation),
    get boxplot() {
        return z.optional(z.lazy((): any => types_aggregations_boxplot_aggregation));
    },
    get bucket_script() {
        return z.optional(z.lazy((): any => types_aggregations_bucket_script_aggregation));
    },
    get bucket_selector() {
        return z.optional(z.lazy((): any => types_aggregations_bucket_selector_aggregation));
    },
    get bucket_sort() {
        return z.optional(z.lazy((): any => types_aggregations_bucket_sort_aggregation));
    },
    bucket_count_ks_test: z.optional(types_aggregations_bucket_ks_aggregation),
    bucket_correlation: z.optional(types_aggregations_bucket_correlation_aggregation),
    get cardinality() {
        return z.optional(z.lazy((): any => types_aggregations_cardinality_aggregation));
    },
    get cartesian_bounds() {
        return z.optional(z.lazy((): any => types_aggregations_cartesian_bounds_aggregation));
    },
    get cartesian_centroid() {
        return z.optional(z.lazy((): any => types_aggregations_cartesian_centroid_aggregation));
    },
    categorize_text: z.optional(types_aggregations_categorize_text_aggregation),
    change_point: z.optional(types_aggregations_change_point_aggregation),
    children: z.optional(types_aggregations_children_aggregation),
    get composite() {
        return z.optional(z.lazy((): any => types_aggregations_composite_aggregation));
    },
    cumulative_cardinality: z.optional(types_aggregations_cumulative_cardinality_aggregation),
    cumulative_sum: z.optional(types_aggregations_cumulative_sum_aggregation),
    get date_histogram() {
        return z.optional(z.lazy((): any => types_aggregations_date_histogram_aggregation));
    },
    date_range: z.optional(types_aggregations_date_range_aggregation),
    derivative: z.optional(types_aggregations_derivative_aggregation),
    get diversified_sampler() {
        return z.optional(z.lazy((): any => types_aggregations_diversified_sampler_aggregation));
    },
    get extended_stats() {
        return z.optional(z.lazy((): any => types_aggregations_extended_stats_aggregation));
    },
    extended_stats_bucket: z.optional(types_aggregations_extended_stats_bucket_aggregation),
    get frequent_item_sets() {
        return z.optional(z.lazy((): any => types_aggregations_frequent_item_sets_aggregation));
    },
    filter: z.optional(types_query_dsl_query_container),
    get filters() {
        return z.optional(z.lazy((): any => types_aggregations_filters_aggregation));
    },
    get geo_bounds() {
        return z.optional(z.lazy((): any => types_aggregations_geo_bounds_aggregation));
    },
    get geo_centroid() {
        return z.optional(z.lazy((): any => types_aggregations_geo_centroid_aggregation));
    },
    geo_distance: z.optional(types_aggregations_geo_distance_aggregation),
    geohash_grid: z.optional(types_aggregations_geo_hash_grid_aggregation),
    geo_line: z.optional(types_aggregations_geo_line_aggregation),
    geotile_grid: z.optional(types_aggregations_geo_tile_grid_aggregation),
    geohex_grid: z.optional(types_aggregations_geohex_grid_aggregation),
    global: z.optional(types_aggregations_global_aggregation),
    get histogram() {
        return z.optional(z.lazy((): any => types_aggregations_histogram_aggregation));
    },
    ip_range: z.optional(types_aggregations_ip_range_aggregation),
    ip_prefix: z.optional(types_aggregations_ip_prefix_aggregation),
    inference: z.optional(types_aggregations_inference_aggregation),
    line: z.optional(types_aggregations_geo_line_aggregation),
    matrix_stats: z.optional(types_aggregations_matrix_stats_aggregation),
    get max() {
        return z.optional(z.lazy((): any => types_aggregations_max_aggregation));
    },
    max_bucket: z.optional(types_aggregations_max_bucket_aggregation),
    get median_absolute_deviation() {
        return z.optional(z.lazy((): any => types_aggregations_median_absolute_deviation_aggregation));
    },
    get min() {
        return z.optional(z.lazy((): any => types_aggregations_min_aggregation));
    },
    min_bucket: z.optional(types_aggregations_min_bucket_aggregation),
    missing: z.optional(types_aggregations_missing_aggregation),
    moving_avg: z.optional(types_aggregations_moving_average_aggregation),
    moving_percentiles: z.optional(types_aggregations_moving_percentiles_aggregation),
    moving_fn: z.optional(types_aggregations_moving_function_aggregation),
    multi_terms: z.optional(types_aggregations_multi_terms_aggregation),
    nested: z.optional(types_aggregations_nested_aggregation),
    normalize: z.optional(types_aggregations_normalize_aggregation),
    parent: z.optional(types_aggregations_parent_aggregation),
    get percentile_ranks() {
        return z.optional(z.lazy((): any => types_aggregations_percentile_ranks_aggregation));
    },
    get percentiles() {
        return z.optional(z.lazy((): any => types_aggregations_percentiles_aggregation));
    },
    percentiles_bucket: z.optional(types_aggregations_percentiles_bucket_aggregation),
    get range() {
        return z.optional(z.lazy((): any => types_aggregations_range_aggregation));
    },
    rare_terms: z.optional(types_aggregations_rare_terms_aggregation),
    get rate() {
        return z.optional(z.lazy((): any => types_aggregations_rate_aggregation));
    },
    reverse_nested: z.optional(types_aggregations_reverse_nested_aggregation),
    random_sampler: z.optional(types_aggregations_random_sampler_aggregation),
    sampler: z.optional(types_aggregations_sampler_aggregation),
    get scripted_metric() {
        return z.optional(z.lazy((): any => types_aggregations_scripted_metric_aggregation));
    },
    serial_diff: z.optional(types_aggregations_serial_differencing_aggregation),
    get significant_terms() {
        return z.optional(z.lazy((): any => types_aggregations_significant_terms_aggregation));
    },
    get significant_text() {
        return z.optional(z.lazy((): any => types_aggregations_significant_text_aggregation));
    },
    get stats() {
        return z.optional(z.lazy((): any => types_aggregations_stats_aggregation));
    },
    stats_bucket: z.optional(types_aggregations_stats_bucket_aggregation),
    get string_stats() {
        return z.optional(z.lazy((): any => types_aggregations_string_stats_aggregation));
    },
    get sum() {
        return z.optional(z.lazy((): any => types_aggregations_sum_aggregation));
    },
    sum_bucket: z.optional(types_aggregations_sum_bucket_aggregation),
    get terms() {
        return z.optional(z.lazy((): any => types_aggregations_terms_aggregation));
    },
    time_series: z.optional(types_aggregations_time_series_aggregation),
    get top_hits() {
        return z.optional(z.lazy((): any => types_aggregations_top_hits_aggregation));
    },
    get t_test() {
        return z.optional(z.lazy((): any => types_aggregations_t_test_aggregation));
    },
    get top_metrics() {
        return z.optional(z.lazy((): any => types_aggregations_top_metrics_aggregation));
    },
    get value_count() {
        return z.optional(z.lazy((): any => types_aggregations_value_count_aggregation));
    },
    get weighted_avg() {
        return z.optional(z.lazy((): any => types_aggregations_weighted_average_aggregation));
    },
    get variable_width_histogram() {
        return z.optional(z.lazy((): any => types_aggregations_variable_width_histogram_aggregation));
    }
})));

export const types_aggregations_variable_width_histogram_aggregation = z.object({
    field: z.optional(types_field),
    buckets: z.optional(z.number().register(z.globalRegistry, {
        description: "The target number of buckets."
    })).default(10),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of buckets that the coordinating node will request from each shard.\nDefaults to `buckets * 50`."
    })),
    initial_buffer: z.optional(z.number().register(z.globalRegistry, {
        description: "Specifies the number of individual documents that will be stored in memory on a shard before the initial bucketing algorithm is run.\nDefaults to `min(10 * shard_size, 50000)`."
    })),
    script: z.optional(types_script)
});

export const global_search_types_search_request_body = z.object({
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregation_container).register(z.globalRegistry, {
        description: "Defines the aggregations that are run as part of the search request."
    })),
    collapse: z.optional(global_search_types_field_collapse),
    explain: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the request returns detailed information about score computation as part of a hit."
    })).default(false),
    ext: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "Configuration of search extensions defined by Elasticsearch plugins."
    })),
    from: z.optional(z.number().register(z.globalRegistry, {
        description: "The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
    })).default(0),
    highlight: z.optional(global_search_types_highlight),
    track_total_hits: z.optional(global_search_types_track_hits),
    indices_boost: z.optional(z.array(z.record(z.string(), z.number())).register(z.globalRegistry, {
        description: "Boost the `_score` of documents from specified indices.\nThe boost value is the factor by which scores are multiplied.\nA boost value greater than `1.0` increases the score.\nA boost value between `0` and `1.0` decreases the score."
    })),
    docvalue_fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: "An array of wildcard (`*`) field patterns.\nThe request returns doc values for field names matching these patterns in the `hits.fields` property of the response."
    })),
    knn: z.optional(z.union([
        types_knn_search,
        z.array(types_knn_search)
    ])),
    rank: z.optional(types_rank_container),
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum `_score` for matching documents.\nDocuments with a lower `_score` are not included in search results or results collected by aggregations."
    })),
    post_filter: z.optional(types_query_dsl_query_container),
    profile: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to return detailed timing information about the execution of individual components in a search request.\nNOTE: This is a debugging tool and adds significant overhead to search execution."
    })).default(false),
    query: z.optional(types_query_dsl_query_container),
    rescore: z.optional(z.union([
        global_search_types_rescore,
        z.array(global_search_types_rescore)
    ])),
    retriever: z.optional(types_retriever_container),
    script_fields: z.optional(z.record(z.string(), types_script_field).register(z.globalRegistry, {
        description: "Retrieve a script evaluation (based on different fields) for each hit."
    })),
    search_after: z.optional(types_sort_results),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of hits to return, which must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` property."
    })).default(10),
    slice: z.optional(types_sliced_scroll),
    sort: z.optional(types_sort),
    _source: z.optional(global_search_types_source_config),
    fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: "An array of wildcard (`*`) field patterns.\nThe request returns values for field names matching these patterns in the `hits.fields` property of the response."
    })),
    suggest: z.optional(global_search_types_suggester),
    terminate_after: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this property to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this property for requests that target data streams with backing indices across multiple data tiers.\n\nIf set to `0` (default), the query does not terminate early."
    })).default(0),
    timeout: z.optional(z.string().register(z.globalRegistry, {
        description: "The period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout."
    })),
    track_scores: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, calculate and return document scores, even if the scores are not used for sorting."
    })).default(false),
    version: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the request returns the document version as part of a hit."
    })).default(false),
    seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the request returns sequence number and primary term of the last modification of each hit."
    })),
    stored_fields: z.optional(types_fields),
    pit: z.optional(global_search_types_point_in_time_reference),
    runtime_mappings: z.optional(types_mapping_runtime_fields),
    stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: "The stats groups to associate with the search.\nEach group maintains a statistics aggregation for its associated searches.\nYou can retrieve these stats using the indices stats API."
    }))
});

export const types_script_source = z.union([
    z.string(),
    global_search_types_search_request_body
]);

export const types_aggregations_weighted_average_value = z.object({
    field: z.optional(types_field),
    missing: z.optional(z.number().register(z.globalRegistry, {
        description: "A value or weight to use if the field is missing."
    })),
    script: z.optional(types_script)
});

export const types_aggregations_weighted_average_aggregation = types_aggregations_aggregation.and(z.object({
    format: z.optional(z.string().register(z.globalRegistry, {
        description: "A numeric response formatter."
    })),
    value: z.optional(types_aggregations_weighted_average_value),
    value_type: z.optional(types_aggregations_value_type),
    weight: z.optional(types_aggregations_weighted_average_value)
}));

export const types_aggregations_formattable_metric_aggregation = z.lazy((): any => types_aggregations_metric_aggregation_base).and(z.object({
    format: z.optional(z.string())
}));

export const types_aggregations_metric_aggregation_base = z.object({
    field: z.optional(types_field),
    missing: z.optional(types_aggregations_missing),
    script: z.optional(types_script)
});

export const types_aggregations_value_count_aggregation = types_aggregations_formattable_metric_aggregation.and(z.record(z.string(), z.unknown()));

export const types_aggregations_top_metrics_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    metrics: z.optional(z.union([
        types_aggregations_top_metrics_value,
        z.array(types_aggregations_top_metrics_value)
    ])),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of top documents from which to return metrics."
    })).default(1),
    sort: z.optional(types_sort)
}));

export const types_aggregations_test_population = z.object({
    field: types_field,
    script: z.optional(types_script),
    filter: z.optional(types_query_dsl_query_container)
});

export const types_query_dsl_script_query = types_query_dsl_query_base.and(z.object({
    script: types_script
}));

export const types_query_dsl_rule_query = types_query_dsl_query_base.and(z.object({
    organic: types_query_dsl_query_container,
    ruleset_ids: z.optional(z.union([
        types_id,
        z.array(types_id)
    ])),
    ruleset_id: z.optional(z.string()),
    match_criteria: z.record(z.string(), z.unknown())
}));

export const types_query_dsl_pinned_query = types_query_dsl_query_base.and(z.object({
    organic: types_query_dsl_query_container
}).and(z.object({
    ids: z.optional(z.array(types_id).register(z.globalRegistry, {
        description: "Document IDs listed in the order they are to appear in results.\nRequired if `docs` is not specified."
    })),
    docs: z.optional(z.array(types_query_dsl_pinned_doc).register(z.globalRegistry, {
        description: "Documents listed in the order they are to appear in results.\nRequired if `ids` is not specified."
    }))
})));

export const types_query_dsl_nested_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Indicates whether to ignore an unmapped path and not return any documents instead of an error."
    })).default(false),
    inner_hits: z.optional(global_search_types_inner_hits),
    path: types_field,
    query: types_query_dsl_query_container,
    score_mode: z.optional(types_query_dsl_child_score_mode)
}));

export const types_knn_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    query_vector: z.optional(types_query_vector),
    query_vector_builder: z.optional(types_query_vector_builder),
    num_candidates: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of nearest neighbor candidates to consider per shard"
    })),
    visit_percentage: z.optional(z.number().register(z.globalRegistry, {
        description: "The percentage of vectors to explore per shard while doing knn search with bbq_disk"
    })),
    k: z.optional(z.number().register(z.globalRegistry, {
        description: "The final number of nearest neighbors to return as top hits"
    })),
    filter: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    similarity: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum similarity for a vector to be considered a match"
    })),
    rescore_vector: z.optional(types_rescore_vector)
}));

export const types_query_dsl_intervals_match = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: "Analyzer used to analyze terms in the query."
    })),
    max_gaps: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of positions between the matching terms.\nTerms further apart than this are not considered matches."
    })).default(-1),
    ordered: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, matching terms must appear in their specified order."
    })).default(false),
    query: z.string().register(z.globalRegistry, {
        description: "Text you wish to find in the provided field."
    }),
    use_field: z.optional(types_field),
    get filter() {
        return z.optional(z.lazy((): any => types_query_dsl_intervals_filter));
    }
});

export const types_query_dsl_intervals_container = z.object({
    get all_of() {
        return z.optional(z.lazy((): any => types_query_dsl_intervals_all_of));
    },
    get any_of() {
        return z.optional(z.lazy((): any => types_query_dsl_intervals_any_of));
    },
    fuzzy: z.optional(types_query_dsl_intervals_fuzzy),
    match: z.optional(types_query_dsl_intervals_match),
    prefix: z.optional(types_query_dsl_intervals_prefix),
    range: z.optional(types_query_dsl_intervals_range),
    regexp: z.optional(types_query_dsl_intervals_regexp),
    wildcard: z.optional(types_query_dsl_intervals_wildcard)
});

export const types_query_dsl_intervals_filter = z.object({
    after: z.optional(types_query_dsl_intervals_container),
    before: z.optional(types_query_dsl_intervals_container),
    contained_by: z.optional(types_query_dsl_intervals_container),
    containing: z.optional(types_query_dsl_intervals_container),
    not_contained_by: z.optional(types_query_dsl_intervals_container),
    not_containing: z.optional(types_query_dsl_intervals_container),
    not_overlapping: z.optional(types_query_dsl_intervals_container),
    overlapping: z.optional(types_query_dsl_intervals_container),
    script: z.optional(types_script)
});

export const types_query_dsl_intervals_any_of = z.object({
    intervals: z.array(types_query_dsl_intervals_container).register(z.globalRegistry, {
        description: "An array of rules to match."
    }),
    filter: z.optional(types_query_dsl_intervals_filter)
});

export const types_query_dsl_intervals_all_of = z.object({
    intervals: z.array(types_query_dsl_intervals_container).register(z.globalRegistry, {
        description: "An array of rules to combine. All rules must produce a match in a document for the overall source to match."
    }),
    max_gaps: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of positions between the matching terms.\nIntervals produced by the rules further apart than this are not considered matches."
    })).default(-1),
    ordered: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, intervals produced by the rules should appear in the order in which they are specified."
    })).default(false),
    filter: z.optional(types_query_dsl_intervals_filter)
});

export const types_query_dsl_intervals_query = types_query_dsl_query_base.and(z.object({
    all_of: z.optional(types_query_dsl_intervals_all_of),
    any_of: z.optional(types_query_dsl_intervals_any_of),
    fuzzy: z.optional(types_query_dsl_intervals_fuzzy),
    match: z.optional(types_query_dsl_intervals_match),
    prefix: z.optional(types_query_dsl_intervals_prefix),
    range: z.optional(types_query_dsl_intervals_range),
    regexp: z.optional(types_query_dsl_intervals_regexp),
    wildcard: z.optional(types_query_dsl_intervals_wildcard)
}));

export const types_query_dsl_has_parent_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Indicates whether to ignore an unmapped `parent_type` and not return any documents instead of an error.\nYou can use this parameter to query multiple indices that may not contain the `parent_type`."
    })).default(false),
    inner_hits: z.optional(global_search_types_inner_hits),
    parent_type: types_relation_name,
    query: types_query_dsl_query_container,
    score: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Indicates whether the relevance score of a matching parent document is aggregated into its child documents."
    })).default(false)
}));

export const types_query_dsl_has_child_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Indicates whether to ignore an unmapped `type` and not return any documents instead of an error."
    })).default(false),
    inner_hits: z.optional(global_search_types_inner_hits),
    max_children: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of child documents that match the query allowed for a returned parent document.\nIf the parent document exceeds this limit, it is excluded from the search results."
    })),
    min_children: z.optional(z.number().register(z.globalRegistry, {
        description: "Minimum number of child documents that match the query required to match the query for a returned parent document.\nIf the parent document does not meet this limit, it is excluded from the search results."
    })),
    query: types_query_dsl_query_container,
    score_mode: z.optional(types_query_dsl_child_score_mode),
    type: types_relation_name
}));

export const types_query_dsl_script_score_function = z.object({
    script: types_script
});

export const types_query_dsl_function_score_container = z.object({
    filter: z.optional(types_query_dsl_query_container),
    weight: z.optional(z.number())
}).and(z.object({
    exp: z.optional(types_query_dsl_decay_function),
    gauss: z.optional(types_query_dsl_decay_function),
    linear: z.optional(types_query_dsl_decay_function),
    field_value_factor: z.optional(types_query_dsl_field_value_factor_score_function),
    random_score: z.optional(types_query_dsl_random_score_function),
    script_score: z.optional(types_query_dsl_script_score_function)
}));

export const types_query_dsl_function_score_query = types_query_dsl_query_base.and(z.object({
    boost_mode: z.optional(types_query_dsl_function_boost_mode),
    functions: z.optional(z.array(types_query_dsl_function_score_container).register(z.globalRegistry, {
        description: "One or more functions that compute a new score for each document returned by the query."
    })),
    max_boost: z.optional(z.number().register(z.globalRegistry, {
        description: "Restricts the new score to not exceed the provided limit."
    })),
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: "Excludes documents that do not meet the provided score threshold."
    })),
    query: z.optional(types_query_dsl_query_container),
    score_mode: z.optional(types_query_dsl_function_score_mode)
}));

export const types_query_dsl_dis_max_query = types_query_dsl_query_base.and(z.object({
    queries: z.array(types_query_dsl_query_container).register(z.globalRegistry, {
        description: "One or more query clauses.\nReturned documents must match one or more of these queries.\nIf a document matches multiple queries, Elasticsearch uses the highest relevance score."
    }),
    tie_breaker: z.optional(z.number().register(z.globalRegistry, {
        description: "Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses."
    })).default(0)
}));

export const types_query_dsl_constant_score_query = types_query_dsl_query_base.and(z.object({
    filter: types_query_dsl_query_container
}));

export const types_query_dsl_boosting_query = types_query_dsl_query_base.and(z.object({
    negative_boost: z.number().register(z.globalRegistry, {
        description: "Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query."
    }),
    negative: types_query_dsl_query_container,
    positive: types_query_dsl_query_container
}));

export const types_query_dsl_bool_query = types_query_dsl_query_base.and(z.object({
    filter: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    minimum_should_match: z.optional(types_minimum_should_match),
    must: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    must_not: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    should: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ]))
}));

export const types_aggregations_t_test_aggregation = types_aggregations_aggregation.and(z.object({
    a: z.optional(types_aggregations_test_population),
    b: z.optional(types_aggregations_test_population),
    type: z.optional(types_aggregations_t_test_type)
}));

export const types_aggregations_top_hits_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    docvalue_fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: "Fields for which to return doc values."
    })),
    explain: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, returns detailed information about score computation as part of a hit."
    })).default(false),
    fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: "Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response."
    })),
    from: z.optional(z.number().register(z.globalRegistry, {
        description: "Starting document offset."
    })).default(0),
    highlight: z.optional(global_search_types_highlight),
    script_fields: z.optional(z.record(z.string(), types_script_field).register(z.globalRegistry, {
        description: "Returns the result of one or more script evaluations for each hit."
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of top matching hits to return per bucket."
    })).default(3),
    sort: z.optional(types_sort),
    _source: z.optional(global_search_types_source_config),
    stored_fields: z.optional(types_fields),
    track_scores: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, calculates and returns document scores, even if the scores are not used for sorting."
    })).default(false),
    version: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, returns document version as part of a hit."
    })).default(false),
    seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, returns sequence number and primary term of the last modification of each hit."
    }))
}));

export const types_aggregations_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    collect_mode: z.optional(types_aggregations_terms_aggregation_collect_mode),
    exclude: z.optional(types_aggregations_terms_exclude),
    execution_hint: z.optional(types_aggregations_terms_aggregation_execution_hint),
    field: z.optional(types_field),
    include: z.optional(types_aggregations_terms_include),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "Only return values that are found in more than `min_doc_count` hits."
    })).default(1),
    missing: z.optional(types_aggregations_missing),
    missing_order: z.optional(types_aggregations_missing_order),
    missing_bucket: z.optional(z.boolean()),
    value_type: z.optional(z.string().register(z.globalRegistry, {
        description: "Coerced unmapped fields into the specified type."
    })),
    order: z.optional(types_aggregations_aggregate_order),
    script: z.optional(types_script),
    shard_min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`.\nTerms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`."
    })),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter."
    })),
    show_term_doc_count_error: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to return the `doc_count_error_upper_bound`, which is an upper bound to the error on the `doc_count` returned by each shard."
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of buckets returned out of the overall terms list."
    })).default(10),
    format: z.optional(z.string())
}));

export const types_aggregations_sum_aggregation = z.lazy((): any => types_aggregations_format_metric_aggregation_base).and(z.record(z.string(), z.unknown()));

export const types_aggregations_format_metric_aggregation_base = types_aggregations_metric_aggregation_base.and(z.object({
    format: z.optional(z.string())
}));

export const types_aggregations_string_stats_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    show_distribution: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Shows the probability distribution for all characters."
    })).default(false)
}));

export const types_aggregations_stats_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_significant_text_aggregation = types_aggregations_bucket_aggregation_base.and(z.lazy(() => z.object({
    background_filter: z.optional(types_query_dsl_query_container),
    chi_square: z.optional(types_aggregations_chi_square_heuristic),
    exclude: z.optional(types_aggregations_terms_exclude),
    execution_hint: z.optional(types_aggregations_terms_aggregation_execution_hint),
    field: z.optional(types_field),
    filter_duplicate_text: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Whether to out duplicate text to deal with noisy data."
    })),
    gnd: z.optional(types_aggregations_google_normalized_distance_heuristic),
    include: z.optional(types_aggregations_terms_include),
    jlh: z.optional(types_empty_object),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "Only return values that are found in more than `min_doc_count` hits."
    })).default(3),
    mutual_information: z.optional(types_aggregations_mutual_information_heuristic),
    percentage: z.optional(types_aggregations_percentage_score_heuristic),
    get script_heuristic() {
        return z.optional(z.lazy((): any => types_aggregations_scripted_heuristic));
    },
    shard_min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "Regulates the certainty a shard has if the values should actually be added to the candidate list or not with respect to the min_doc_count.\nValues will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`."
    })),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter."
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of buckets returned out of the overall terms list."
    })),
    source_fields: z.optional(types_fields)
})));

export const types_aggregations_scripted_heuristic = z.object({
    script: types_script
});

export const types_aggregations_significant_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    background_filter: z.optional(types_query_dsl_query_container),
    chi_square: z.optional(types_aggregations_chi_square_heuristic),
    exclude: z.optional(types_aggregations_terms_exclude),
    execution_hint: z.optional(types_aggregations_terms_aggregation_execution_hint),
    field: z.optional(types_field),
    gnd: z.optional(types_aggregations_google_normalized_distance_heuristic),
    include: z.optional(types_aggregations_terms_include),
    jlh: z.optional(types_empty_object),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "Only return terms that are found in more than `min_doc_count` hits."
    })).default(3),
    mutual_information: z.optional(types_aggregations_mutual_information_heuristic),
    percentage: z.optional(types_aggregations_percentage_score_heuristic),
    script_heuristic: z.optional(types_aggregations_scripted_heuristic),
    p_value: z.optional(types_aggregations_p_value_heuristic),
    shard_min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`.\nTerms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`."
    })),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "Can be used to control the volumes of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter."
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of buckets returned out of the overall terms list."
    }))
}));

export const types_aggregations_scripted_metric_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    combine_script: z.optional(types_script),
    init_script: z.optional(types_script),
    map_script: z.optional(types_script),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "A global object with script parameters for `init`, `map` and `combine` scripts.\nIt is shared between the scripts."
    })),
    reduce_script: z.optional(types_script)
}));

export const types_aggregations_rate_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    unit: z.optional(types_aggregations_calendar_interval),
    mode: z.optional(types_aggregations_rate_mode)
}));

export const types_aggregations_range_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: z.optional(types_field),
    missing: z.optional(z.number().register(z.globalRegistry, {
        description: "The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored."
    })),
    ranges: z.optional(z.array(types_aggregations_aggregation_range).register(z.globalRegistry, {
        description: "An array of ranges used to bucket documents."
    })),
    script: z.optional(types_script),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array."
    })),
    format: z.optional(z.string())
}));

export const types_aggregations_percentiles_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: "By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array.\nSet to `false` to disable this behavior."
    })).default(true),
    percents: z.optional(z.union([
        z.number(),
        z.array(z.number())
    ])),
    hdr: z.optional(types_aggregations_hdr_method),
    tdigest: z.optional(types_aggregations_t_digest)
}));

export const types_aggregations_percentile_ranks_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: "By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array.\nSet to `false` to disable this behavior."
    })).default(true),
    values: z.optional(z.union([
        z.array(z.number()),
        z.string(),
        z.null()
    ])),
    hdr: z.optional(types_aggregations_hdr_method),
    tdigest: z.optional(types_aggregations_t_digest)
}));

export const types_aggregations_min_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_median_absolute_deviation_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    compression: z.optional(z.number().register(z.globalRegistry, {
        description: "Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error."
    })).default(1000),
    execution_hint: z.optional(types_aggregations_t_digest_execution_hint)
}));

export const types_aggregations_max_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_histogram_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    extended_bounds: z.optional(types_aggregations_extended_boundsdouble),
    hard_bounds: z.optional(types_aggregations_extended_boundsdouble),
    field: z.optional(types_field),
    interval: z.optional(z.number().register(z.globalRegistry, {
        description: "The interval for the buckets.\nMust be a positive decimal."
    })),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "Only returns buckets that have `min_doc_count` number of documents.\nBy default, the response will fill gaps in the histogram with empty buckets."
    })),
    missing: z.optional(z.number().register(z.globalRegistry, {
        description: "The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored."
    })),
    offset: z.optional(z.number().register(z.globalRegistry, {
        description: "By default, the bucket keys start with 0 and then continue in even spaced steps of `interval`.\nThe bucket boundaries can be shifted by using the `offset` option."
    })),
    order: z.optional(types_aggregations_aggregate_order),
    script: z.optional(types_script),
    format: z.optional(z.string()),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, returns buckets as a hash instead of an array, keyed by the bucket keys."
    })).default(false)
}));

export const types_aggregations_geo_centroid_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    count: z.optional(z.number()),
    location: z.optional(types_geo_location)
}));

export const types_aggregations_geo_bounds_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    wrap_longitude: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Specifies whether the bounding box should be allowed to overlap the international date line."
    })).default(true)
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_query_container = z.union([
    z.record(z.string(), types_query_dsl_query_container),
    z.array(types_query_dsl_query_container)
]);

export const types_aggregations_filters_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    filters: z.optional(types_aggregations_buckets_query_container),
    other_bucket: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to add a bucket to the response which will contain all documents that do not match any of the given filters."
    })),
    other_bucket_key: z.optional(z.string().register(z.globalRegistry, {
        description: "The key with which the other bucket is returned."
    })).default('_other_'),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: "By default, the named filters aggregation returns the buckets as an object.\nSet to `false` to return the buckets as an array of objects."
    })).default(true)
}));

export const types_aggregations_frequent_item_sets_aggregation = z.object({
    fields: z.array(types_aggregations_frequent_item_sets_field).register(z.globalRegistry, {
        description: "Fields to analyze."
    }),
    minimum_set_size: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum size of one item set."
    })).default(1),
    minimum_support: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum support of one item set."
    })).default(0.1),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of top item sets to return."
    })).default(10),
    filter: z.optional(types_query_dsl_query_container)
});

export const types_aggregations_extended_stats_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    sigma: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of standard deviations above/below the mean to display."
    }))
}));

export const types_aggregations_diversified_sampler_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    execution_hint: z.optional(types_aggregations_sampler_aggregation_execution_hint),
    max_docs_per_value: z.optional(z.number().register(z.globalRegistry, {
        description: "Limits how many documents are permitted per choice of de-duplicating value."
    })).default(1),
    script: z.optional(types_script),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: "Limits how many top-scoring documents are collected in the sample processed on each shard."
    })).default(100),
    field: z.optional(types_field)
}));

export const types_aggregations_date_histogram_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    calendar_interval: z.optional(types_aggregations_calendar_interval),
    extended_bounds: z.optional(types_aggregations_extended_bounds_field_date_math),
    hard_bounds: z.optional(types_aggregations_extended_bounds_field_date_math),
    field: z.optional(types_field),
    fixed_interval: z.optional(types_duration),
    format: z.optional(z.string().register(z.globalRegistry, {
        description: "The date format used to format `key_as_string` in the response.\nIf no `format` is specified, the first date format specified in the field mapping is used."
    })),
    interval: z.optional(types_duration),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: "Only returns buckets that have `min_doc_count` number of documents.\nBy default, all buckets between the first bucket that matches documents and the last one are returned."
    })),
    missing: z.optional(types_date_time),
    offset: z.optional(types_duration),
    order: z.optional(types_aggregations_aggregate_order),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    script: z.optional(types_script),
    time_zone: z.optional(types_time_zone),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array."
    }))
}));

export const types_aggregations_composite_geo_tile_grid_aggregation = z.lazy((): any => types_aggregations_composite_aggregation_base).and(z.object({
    precision: z.optional(z.number()),
    bounds: z.optional(types_geo_bounds)
}));

export const types_aggregations_composite_aggregation_base = z.object({
    field: z.optional(types_field),
    missing_bucket: z.optional(z.boolean()),
    missing_order: z.optional(types_aggregations_missing_order),
    script: z.optional(types_script),
    value_type: z.optional(types_aggregations_value_type),
    order: z.optional(types_sort_order)
});

export const types_aggregations_composite_date_histogram_aggregation = types_aggregations_composite_aggregation_base.and(z.object({
    format: z.optional(z.string()),
    calendar_interval: z.optional(types_duration_large),
    fixed_interval: z.optional(types_duration_large),
    offset: z.optional(types_duration),
    time_zone: z.optional(types_time_zone)
}));

export const types_aggregations_composite_histogram_aggregation = types_aggregations_composite_aggregation_base.and(z.object({
    interval: z.number()
}));

export const types_aggregations_composite_terms_aggregation = types_aggregations_composite_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_composite_aggregation_source = z.object({
    terms: z.optional(types_aggregations_composite_terms_aggregation),
    histogram: z.optional(types_aggregations_composite_histogram_aggregation),
    date_histogram: z.optional(types_aggregations_composite_date_histogram_aggregation),
    geotile_grid: z.optional(types_aggregations_composite_geo_tile_grid_aggregation)
});

export const types_aggregations_composite_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    after: z.optional(types_aggregations_composite_aggregate_key),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of composite buckets that should be returned."
    })).default(10),
    sources: z.optional(z.array(z.record(z.string(), types_aggregations_composite_aggregation_source)).register(z.globalRegistry, {
        description: "The value sources used to build composite buckets.\nKeys are returned in the order of the `sources` definition."
    }))
}));

export const types_aggregations_cartesian_centroid_aggregation = types_aggregations_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_cartesian_bounds_aggregation = types_aggregations_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_cardinality_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    precision_threshold: z.optional(z.number().register(z.globalRegistry, {
        description: "A unique count below which counts are expected to be close to accurate.\nThis allows to trade memory for accuracy."
    })).default(3000),
    rehash: z.optional(z.boolean()),
    execution_hint: z.optional(types_aggregations_cardinality_execution_mode)
}));

export const types_aggregations_bucket_sort_aggregation = types_aggregations_aggregation.and(z.object({
    from: z.optional(z.number().register(z.globalRegistry, {
        description: "Buckets in positions prior to `from` will be truncated."
    })),
    gap_policy: z.optional(types_aggregations_gap_policy),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of buckets to return.\nDefaults to all buckets of the parent aggregation."
    })),
    sort: z.optional(types_sort)
}));

export const types_aggregations_bucket_selector_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    script: z.optional(types_script)
}));

export const types_aggregations_bucket_script_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    script: z.optional(types_script)
}));

export const types_aggregations_boxplot_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    compression: z.optional(z.number().register(z.globalRegistry, {
        description: "Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error."
    })),
    execution_hint: z.optional(types_aggregations_t_digest_execution_hint)
}));

export const types_aggregations_average_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_auto_date_histogram_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    buckets: z.optional(z.number().register(z.globalRegistry, {
        description: "The target number of buckets."
    })).default(10),
    field: z.optional(types_field),
    format: z.optional(z.string().register(z.globalRegistry, {
        description: "The date format used to format `key_as_string` in the response.\nIf no `format` is specified, the first date format specified in the field mapping is used."
    })),
    minimum_interval: z.optional(types_aggregations_minimum_interval),
    missing: z.optional(types_date_time),
    offset: z.optional(z.string().register(z.globalRegistry, {
        description: "Time zone specified as a ISO 8601 UTC offset."
    })),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    script: z.optional(types_script),
    time_zone: z.optional(types_time_zone)
}));

export const types_aggregations_adjacency_matrix_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    filters: z.optional(z.record(z.string(), types_query_dsl_query_container).register(z.globalRegistry, {
        description: "Filters used to create buckets.\nAt least one filter is required."
    })),
    separator: z.optional(z.string().register(z.globalRegistry, {
        description: "Separator used to concatenate filter names. Defaults to &."
    }))
}));

export const global_search_shards_shard_store_index = z.object({
    aliases: z.optional(z.array(types_name)),
    filter: z.optional(types_query_dsl_query_container)
});

export const global_rank_eval_rank_eval_query = z.object({
    query: types_query_dsl_query_container,
    size: z.optional(z.number())
});

export const global_rank_eval_rank_eval_request_item = z.object({
    id: types_id,
    request: z.optional(global_rank_eval_rank_eval_query),
    ratings: z.array(global_rank_eval_document_rating).register(z.globalRegistry, {
        description: "List of document ratings"
    }),
    template_id: z.optional(types_id),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "The search template parameters."
    }))
});

export const global_msearch_template_template_config = z.object({
    explain: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, returns detailed information about score calculation as part of each hit."
    })).default(false),
    id: z.optional(types_id),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value."
    })),
    profile: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the query execution is profiled."
    })).default(false),
    source: z.optional(types_script_source)
});

export const global_msearch_template_request_item = z.union([
    global_msearch_multisearch_header,
    global_msearch_template_template_config
]);

export const global_msearch_multi_search_result = z.object({
    took: z.number(),
    get responses() {
        return z.array(z.lazy((): any => global_msearch_response_item));
    }
});

export const types_aggregations_top_hits_aggregate = types_aggregations_aggregate_base.and(z.lazy(() => z.object({
    get hits() {
        return z.lazy((): any => global_search_types_hits_metadata);
    }
})));

export const global_search_types_inner_hits_result = z.object({
    get hits() {
        return z.lazy((): any => global_search_types_hits_metadata);
    }
});

export const global_search_types_hits_metadata = z.object({
    total: z.optional(z.union([
        global_search_types_total_hits,
        z.number()
    ])),
    get hits() {
        return z.array(z.lazy((): any => global_search_types_hit));
    },
    max_score: z.optional(z.union([
        z.number(),
        z.string(),
        z.null()
    ]))
});

export const global_search_types_hit = z.object({
    _index: types_index_name,
    _id: z.optional(types_id),
    _score: z.optional(z.union([
        z.number(),
        z.string(),
        z.null()
    ])),
    _explanation: z.optional(global_explain_explanation),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    highlight: z.optional(z.record(z.string(), z.array(z.string()))),
    inner_hits: z.optional(z.record(z.string(), global_search_types_inner_hits_result)),
    matched_queries: z.optional(z.union([
        z.array(z.string()),
        z.record(z.string(), z.number())
    ])),
    _nested: z.optional(global_search_types_nested_identity),
    _ignored: z.optional(z.array(z.string())),
    ignored_field_values: z.optional(z.record(z.string(), z.array(z.record(z.string(), z.unknown())))),
    _shard: z.optional(z.string()),
    _node: z.optional(z.string()),
    _routing: z.optional(z.string()),
    _source: z.optional(z.record(z.string(), z.unknown())),
    _rank: z.optional(z.number()),
    _seq_no: z.optional(types_sequence_number),
    _primary_term: z.optional(z.number()),
    _version: z.optional(types_version_number),
    sort: z.optional(types_sort_results)
});

export const types_aggregations_aggregate = z.union([
    types_aggregations_cardinality_aggregate,
    types_aggregations_hdr_percentiles_aggregate,
    types_aggregations_hdr_percentile_ranks_aggregate,
    types_aggregations_t_digest_percentiles_aggregate,
    types_aggregations_t_digest_percentile_ranks_aggregate,
    types_aggregations_percentiles_bucket_aggregate,
    types_aggregations_median_absolute_deviation_aggregate,
    types_aggregations_min_aggregate,
    types_aggregations_max_aggregate,
    types_aggregations_sum_aggregate,
    types_aggregations_avg_aggregate,
    types_aggregations_weighted_avg_aggregate,
    types_aggregations_value_count_aggregate,
    types_aggregations_simple_value_aggregate,
    types_aggregations_derivative_aggregate,
    types_aggregations_bucket_metric_value_aggregate,
    types_aggregations_change_point_aggregate,
    types_aggregations_stats_aggregate,
    types_aggregations_stats_bucket_aggregate,
    types_aggregations_extended_stats_aggregate,
    types_aggregations_extended_stats_bucket_aggregate,
    types_aggregations_cartesian_bounds_aggregate,
    types_aggregations_cartesian_centroid_aggregate,
    types_aggregations_geo_bounds_aggregate,
    types_aggregations_geo_centroid_aggregate,
    types_aggregations_histogram_aggregate,
    types_aggregations_date_histogram_aggregate,
    types_aggregations_auto_date_histogram_aggregate,
    types_aggregations_variable_width_histogram_aggregate,
    types_aggregations_string_terms_aggregate,
    types_aggregations_long_terms_aggregate,
    types_aggregations_double_terms_aggregate,
    types_aggregations_unmapped_terms_aggregate,
    types_aggregations_long_rare_terms_aggregate,
    types_aggregations_string_rare_terms_aggregate,
    types_aggregations_unmapped_rare_terms_aggregate,
    types_aggregations_multi_terms_aggregate,
    types_aggregations_missing_aggregate,
    types_aggregations_nested_aggregate,
    types_aggregations_reverse_nested_aggregate,
    types_aggregations_global_aggregate,
    types_aggregations_filter_aggregate,
    types_aggregations_children_aggregate,
    types_aggregations_parent_aggregate,
    types_aggregations_sampler_aggregate,
    types_aggregations_unmapped_sampler_aggregate,
    types_aggregations_geo_hash_grid_aggregate,
    types_aggregations_geo_tile_grid_aggregate,
    types_aggregations_geo_hex_grid_aggregate,
    types_aggregations_range_aggregate,
    types_aggregations_date_range_aggregate,
    types_aggregations_geo_distance_aggregate,
    types_aggregations_ip_range_aggregate,
    types_aggregations_ip_prefix_aggregate,
    types_aggregations_filters_aggregate,
    types_aggregations_adjacency_matrix_aggregate,
    types_aggregations_significant_long_terms_aggregate,
    types_aggregations_significant_string_terms_aggregate,
    types_aggregations_unmapped_significant_terms_aggregate,
    types_aggregations_composite_aggregate,
    types_aggregations_frequent_item_sets_aggregate,
    types_aggregations_time_series_aggregate,
    types_aggregations_scripted_metric_aggregate,
    types_aggregations_top_hits_aggregate,
    types_aggregations_inference_aggregate,
    types_aggregations_string_stats_aggregate,
    types_aggregations_box_plot_aggregate,
    types_aggregations_top_metrics_aggregate,
    types_aggregations_t_test_aggregate,
    types_aggregations_rate_aggregate,
    types_aggregations_cumulative_cardinality_aggregate,
    types_aggregations_matrix_stats_aggregate,
    types_aggregations_geo_line_aggregate
]);

export const global_search_response_body = z.object({
    took: z.number().register(z.globalRegistry, {
        description: "The number of milliseconds it took Elasticsearch to run the request.\nThis value is calculated by measuring the time elapsed between receipt of a request on the coordinating node and the time at which the coordinating node is ready to send the response.\nIt includes:\n\n* Communication time between the coordinating node and data nodes\n* Time the request spends in the search thread pool, queued for execution\n* Actual run time\n\nIt does not include:\n\n* Time needed to send the request to Elasticsearch\n* Time needed to serialize the JSON response\n* Time needed to send the response to a client"
    }),
    timed_out: z.boolean().register(z.globalRegistry, {
        description: "If `true`, the request timed out before completion; returned results may be partial or empty."
    }),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregate)),
    _clusters: z.optional(types_cluster_statistics),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    max_score: z.optional(z.number()),
    num_reduce_phases: z.optional(z.number()),
    profile: z.optional(global_search_types_profile),
    pit_id: z.optional(types_id),
    _scroll_id: z.optional(types_scroll_id),
    suggest: z.optional(z.record(z.string(), z.array(global_search_types_suggest))),
    terminated_early: z.optional(z.boolean())
});

export const global_msearch_multi_search_item = global_search_response_body.and(z.object({
    status: z.optional(z.number())
}));

export const global_msearch_response_item = z.union([
    global_msearch_multi_search_item,
    types_error_response_base
]);

export const global_msearch_request_item = z.union([
    global_msearch_multisearch_header,
    global_search_types_search_request_body
]);

export const async_search_types_async_search = z.object({
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregate).register(z.globalRegistry, {
        description: "Partial aggregations results, coming from the shards that have already completed running the query."
    })),
    _clusters: z.optional(types_cluster_statistics),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    hits: global_search_types_hits_metadata,
    max_score: z.optional(z.number()),
    num_reduce_phases: z.optional(z.number().register(z.globalRegistry, {
        description: "Indicates how many reductions of the results have been performed.\nIf this number increases compared to the last retrieved results for a get asynch search request, you can expect additional results included in the search response."
    })),
    profile: z.optional(global_search_types_profile),
    pit_id: z.optional(types_id),
    _scroll_id: z.optional(types_scroll_id),
    _shards: types_shard_statistics,
    suggest: z.optional(z.record(z.string(), z.array(global_search_types_suggest))),
    terminated_early: z.optional(z.boolean()),
    timed_out: z.boolean(),
    took: z.number()
});

export const async_search_types_async_search_document_response_base = async_search_types_async_search_response_base.and(z.object({
    response: async_search_types_async_search
}));

/**
 * A comma-separated list of data streams, indices, and index aliases to search.
 * Wildcard (`*`) expressions are supported.
 * To search all data streams or indices, omit this parameter or use `*`  or `_all`.
 */
export const terms_enum_index = types_indices;

/**
 * If `true`, the response prefixes aggregation and suggester names with their respective types.
 */
export const search_template_typed_keys = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the response prefixes aggregation and suggester names with their respective types."
});

/**
 * If `true`, `hits.total` is rendered as an integer in the response.
 * If `false`, it is rendered as an object.
 */
export const search_template_rest_total_hits_as_int = z.boolean().register(z.globalRegistry, {
    description: "If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object."
});

/**
 * The type of the search operation.
 */
export const search_template_search_type = types_search_type;

/**
 * Specifies how long a consistent view of the index
 * should be maintained for scrolled search.
 */
export const search_template_scroll = types_duration;

/**
 * A custom value used to route operations to a specific shard.
 */
export const search_template_routing = types_routing;

/**
 * If `true`, the query execution is profiled.
 */
export const search_template_profile = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the query execution is profiled."
});

/**
 * The node or shard the operation should be performed on.
 * It is random by default.
 */
export const search_template_preference = z.string().register(z.globalRegistry, {
    description: "The node or shard the operation should be performed on.\nIt is random by default."
});

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const search_template_ignore_unavailable = z.boolean().register(z.globalRegistry, {
    description: "If `false`, the request returns an error if it targets a missing or closed index."
});

/**
 * If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled.
 *
 * @deprecated
 */
export const search_template_ignore_throttled = z.boolean().register(z.globalRegistry, {
    description: "If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled."
});

/**
 * If `true`, the response includes additional details about score computation as part of a hit.
 */
export const search_template_explain = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the response includes additional details about score computation as part of a hit."
});

/**
 * The type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const search_template_expand_wildcards = types_expand_wildcards;

/**
 * If `true`, network round-trips are minimized for cross-cluster search requests.
 */
export const search_template_ccs_minimize_roundtrips = z.boolean().register(z.globalRegistry, {
    description: "If `true`, network round-trips are minimized for cross-cluster search requests."
});

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 * For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const search_template_allow_no_indices = z.boolean().register(z.globalRegistry, {
    description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
});

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 */
export const search_template_index = types_indices;

/**
 * A custom value used to route operations to a specific shard.
 */
export const search_shards_routing = types_routing;

/**
 * The node or shard the operation should be performed on.
 * It is random by default.
 */
export const search_shards_preference = z.string().register(z.globalRegistry, {
    description: "The node or shard the operation should be performed on.\nIt is random by default."
});

/**
 * The period to wait for a connection to the master node.
 * If the master node is not available before the timeout expires, the request fails and returns an error.
 * IT can also be set to `-1` to indicate that the request should never timeout.
 */
export const search_shards_master_timeout = types_duration;

/**
 * If `true`, the request retrieves information from the local node only.
 */
export const search_shards_local = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the request retrieves information from the local node only."
});

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const search_shards_ignore_unavailable = z.boolean().register(z.globalRegistry, {
    description: "If `false`, the request returns an error if it targets a missing or closed index."
});

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const search_shards_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 * For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const search_shards_allow_no_indices = z.boolean().register(z.globalRegistry, {
    description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
});

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 * To search all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const search_shards_index = types_indices;

/**
 * If `true`, the hits and aggs layers will contain additional point features representing
 * suggested label positions for the original features.
 *
 * * `Point` and `MultiPoint` features will have one of the points selected.
 * * `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.
 * * `LineString` features will likewise provide a roughly central point selected from the triangle-tree.
 * * The aggregation results will provide one central point for each aggregation bucket.
 *
 * All attributes from the original features will also be copied to the new label features.
 * In addition, the new features will be distinguishable using the tag `_mvt_label_position`.
 */
export const search_mvt_with_labels = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.\n\n* `Point` and `MultiPoint` features will have one of the points selected.\n* `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.\n* `LineString` features will likewise provide a roughly central point selected from the triangle-tree.\n* The aggregation results will provide one central point for each aggregation bucket.\n\nAll attributes from the original features will also be copied to the new label features.\nIn addition, the new features will be distinguishable using the tag `_mvt_label_position`."
});

/**
 * The number of hits matching the query to count accurately.
 * If `true`, the exact number of hits is returned at the cost of some performance.
 * If `false`, the response does not include the total number of hits matching the query.
 */
export const search_mvt_track_total_hits = global_search_types_track_hits;

/**
 * Maximum number of features to return in the hits layer. Accepts 0-10000.
 * If 0, results don't include the hits layer.
 */
export const search_mvt_size = z.number().register(z.globalRegistry, {
    description: "Maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results don't include the hits layer."
});

/**
 * Determines the geometry type for features in the aggs layer. In the aggs layer,
 * each feature represents a geotile_grid cell. If 'grid' each feature is a Polygon
 * of the cells bounding box. If 'point' each feature is a Point that is the centroid
 * of the cell.
 */
export const search_mvt_grid_type = global_search_mvt_types_grid_type;

/**
 * Additional zoom levels available through the aggs layer. For example, if <zoom> is 7
 * and grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results
 * don't include the aggs layer.
 */
export const search_mvt_grid_precision = z.number().register(z.globalRegistry, {
    description: "Additional zoom levels available through the aggs layer. For example, if <zoom> is 7\nand grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndon't include the aggs layer."
});

/**
 * Aggregation used to create a grid for `field`.
 */
export const search_mvt_grid_agg = global_search_mvt_types_grid_aggregation_type;

/**
 * The size, in pixels, of a side of the tile. Vector tiles are square with equal sides.
 */
export const search_mvt_extent = z.number().register(z.globalRegistry, {
    description: "The size, in pixels, of a side of the tile. Vector tiles are square with equal sides."
});

/**
 * If `false`, the meta layer's feature is the bounding box of the tile.
 * If true, the meta layer's feature is a bounding box resulting from a
 * geo_bounds aggregation. The aggregation runs on <field> values that intersect
 * the <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting
 * bounding box may be larger than the vector tile.
 */
export const search_mvt_exact_bounds = z.boolean().register(z.globalRegistry, {
    description: "If `false`, the meta layer's feature is the bounding box of the tile.\nIf true, the meta layer's feature is a bounding box resulting from a\ngeo_bounds aggregation. The aggregation runs on <field> values that intersect\nthe <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting\nbounding box may be larger than the vector tile."
});

/**
 * Y coordinate for the vector tile to search
 */
export const search_mvt_y = global_search_mvt_types_coordinate;

/**
 * X coordinate for the vector tile to search
 */
export const search_mvt_x = global_search_mvt_types_coordinate;

/**
 * Zoom level for the vector tile to search
 */
export const search_mvt_zoom = global_search_mvt_types_zoom_level;

/**
 * Field containing geospatial data to return
 */
export const search_mvt_field = types_field;

/**
 * Comma-separated list of data streams, indices, or aliases to search
 */
export const search_mvt_index = types_indices;

/**
 * A comma-separated list of `<field>:<direction>` pairs.
 */
export const search_sort = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * The starting document offset, which must be non-negative.
 * By default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.
 * To page through more hits, use the `search_after` parameter.
 */
export const search_from = z.number().register(z.globalRegistry, {
    description: "The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
});

/**
 * The number of hits to return.
 * By default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.
 * To page through more hits, use the `search_after` parameter.
 */
export const search_size = z.number().register(z.globalRegistry, {
    description: "The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
});

/**
 * A query in the Lucene query string syntax.
 * Query parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.
 *
 * IMPORTANT: This parameter overrides the query parameter in the request body.
 * If both parameters are specified, documents matching the query request body parameter are not returned.
 */
export const search_q = z.string().register(z.globalRegistry, {
    description: "A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned."
});

/**
 * If `true`, the request returns the sequence number and primary term of the last modification of each hit.
 */
export const search_seq_no_primary_term = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the request returns the sequence number and primary term of the last modification of each hit."
});

/**
 * A comma-separated list of source fields to include in the response.
 * If this parameter is specified, only these source fields are returned.
 * You can exclude fields from this subset using the `_source_excludes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const search_source_includes = types_fields;

/**
 * Whether vectors should be excluded from _source
 */
export const search_source_exclude_vectors = z.boolean().register(z.globalRegistry, {
    description: "Whether vectors should be excluded from _source"
});

/**
 * A comma-separated list of source fields to exclude from the response.
 * You can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const search_source_excludes = types_fields;

/**
 * The source fields that are returned for matching documents.
 * These fields are returned in the `hits._source` property of the search response.
 * Valid values are:
 *
 * * `true` to return the entire document source.
 * * `false` to not return the document source.
 * * `<string>` to return the source fields that are specified as a comma-separated list that supports wildcard (`*`) patterns.
 */
export const search_source = global_search_types_source_config_param;

/**
 * If `true`, the request returns the document version as part of a hit.
 */
export const search_version = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the request returns the document version as part of a hit."
});

/**
 * Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.
 */
export const search_rest_total_hits_as_int = z.boolean().register(z.globalRegistry, {
    description: "Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response."
});

/**
 * If `true`, aggregation and suggester names are be prefixed by their respective types in the response.
 */
export const search_typed_keys = z.boolean().register(z.globalRegistry, {
    description: "If `true`, aggregation and suggester names are be prefixed by their respective types in the response."
});

/**
 * If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.
 */
export const search_track_scores = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the request calculates and returns document scores, even if the scores are not used for sorting."
});

/**
 * The number of hits matching the query to count accurately.
 * If `true`, the exact number of hits is returned at the cost of some performance.
 * If `false`, the response does not include the total number of hits matching the query.
 */
export const search_track_total_hits = global_search_types_track_hits;

/**
 * The period of time to wait for a response from each shard.
 * If no response is received before the timeout expires, the request fails and returns an error.
 * It defaults to no timeout.
 */
export const search_timeout = types_duration;

/**
 * The maximum number of documents to collect for each shard.
 * If a query reaches this limit, Elasticsearch terminates the query early.
 * Elasticsearch collects documents before sorting.
 *
 * IMPORTANT: Use with caution.
 * Elasticsearch applies this parameter to each shard handling the request.
 * When possible, let Elasticsearch perform early termination automatically.
 * Avoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.
 * If set to `0` (default), the query does not terminate early.
 */
export const search_terminate_after = z.number().register(z.globalRegistry, {
    description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early."
});

/**
 * The source text for which the suggestions should be returned.
 * This parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.
 */
export const search_suggest_text = z.string().register(z.globalRegistry, {
    description: "The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified."
});

/**
 * The number of suggestions to return.
 * This parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.
 */
export const search_suggest_size = z.number().register(z.globalRegistry, {
    description: "The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified."
});

/**
 * The suggest mode.
 * This parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.
 */
export const search_suggest_mode = types_suggest_mode;

/**
 * The field to use for suggestions.
 */
export const search_suggest_field = types_field;

/**
 * A comma-separated list of stored fields to return as part of a hit.
 * If no fields are specified, no stored fields are included in the response.
 * If this field is specified, the `_source` parameter defaults to `false`.
 * You can pass `_source: true` to return both source fields and stored fields in the search response.
 */
export const search_stored_fields = types_fields;

/**
 * Specific `tag` of the request for logging and statistical purposes.
 */
export const search_stats = z.array(z.string()).register(z.globalRegistry, {
    description: "Specific `tag` of the request for logging and statistical purposes."
});

/**
 * Indicates how distributed term frequencies are calculated for relevance scoring.
 */
export const search_search_type = types_search_type;

/**
 * The period to retain the search context for scrolling.
 * By default, this value cannot exceed `1d` (24 hours).
 * You can change this limit by using the `search.max_keep_alive` cluster-level setting.
 */
export const search_scroll = types_duration;

/**
 * A custom value that is used to route operations to a specific shard.
 */
export const search_routing = types_routing;

/**
 * If `true`, the caching of search results is enabled for requests where `size` is `0`.
 * It defaults to index level settings.
 */
export const search_request_cache = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings."
});

/**
 * A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.
 * This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).
 * When unspecified, the pre-filter phase is executed if any of these conditions is met:
 *
 * * The request targets more than 128 shards.
 * * The request targets one or more read-only index.
 * * The primary sort of the query targets an indexed field.
 */
export const search_pre_filter_shard_size = z.number().register(z.globalRegistry, {
    description: "A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field."
});

/**
 * The nodes and shards used for the search.
 * By default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.
 * Valid values are:
 *
 * * `_only_local` to run the search only on shards on the local node.
 * * `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.
 * * `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.
 * * `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.
 * * `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.
 * * `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.
 */
export const search_preference = z.string().register(z.globalRegistry, {
    description: "The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order."
});

/**
 * The number of concurrent shard requests per node that the search runs concurrently.
 * This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
 */
export const search_max_concurrent_shard_requests = z.number().register(z.globalRegistry, {
    description: "The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests."
});

/**
 * If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_lenient = z.boolean().register(z.globalRegistry, {
    description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * If `true`, the response includes the score contribution from any named queries.
 *
 * This functionality reruns each named query on every hit in a search response.
 * Typically, this adds a small overhead to a request.
 * However, using computationally expensive named queries on a large number of hits may add significant overhead.
 */
export const search_include_named_queries_score = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead."
});

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const search_ignore_unavailable = z.boolean().register(z.globalRegistry, {
    description: "If `false`, the request returns an error if it targets a missing or closed index."
});

/**
 * If `true`, concrete, expanded or aliased indices will be ignored when frozen.
 *
 * @deprecated
 */
export const search_ignore_throttled = z.boolean().register(z.globalRegistry, {
    description: "If `true`, concrete, expanded or aliased indices will be ignored when frozen."
});

/**
 * If `true`, the request returns detailed information about score computation as part of a hit.
 */
export const search_explain = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the request returns detailed information about score computation as part of a hit."
});

/**
 * The type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * It supports comma-separated values such as `open,hidden`.
 */
export const search_expand_wildcards = types_expand_wildcards;

/**
 * A comma-separated list of fields to return as the docvalue representation of a field for each hit.
 */
export const search_docvalue_fields = types_fields;

/**
 * The field to use as a default when no field prefix is given in the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_df = z.string().register(z.globalRegistry, {
    description: "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * The default operator for the query string query: `and` or `or`.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_default_operator = types_query_dsl_operator;

/**
 * If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.
 */
export const search_ccs_minimize_roundtrips = z.boolean().register(z.globalRegistry, {
    description: "If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests."
});

/**
 * The number of shard results that should be reduced at once on the coordinating node.
 * If the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.
 */
export const search_batched_reduce_size = z.number().register(z.globalRegistry, {
    description: "The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request."
});

/**
 * If `true`, wildcard and prefix queries are analyzed.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_analyze_wildcard = z.boolean().register(z.globalRegistry, {
    description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * The analyzer to use for the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_analyzer = z.string().register(z.globalRegistry, {
    description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * If `true` and there are shard request timeouts or shard failures, the request returns partial results.
 * If `false`, it returns an error with no partial results.
 *
 * To override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.
 */
export const search_allow_partial_search_results = z.boolean().register(z.globalRegistry, {
    description: "If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`."
});

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 * For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const search_allow_no_indices = z.boolean().register(z.globalRegistry, {
    description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
});

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 * To search all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const search_index = types_indices;

/**
 * If true, the API response’s hit.total property is returned as an integer. If false, the API response’s hit.total property is returned as an object.
 */
export const scroll_rest_total_hits_as_int = z.boolean().register(z.globalRegistry, {
    description: "If true, the API response’s hit.total property is returned as an integer. If false, the API response’s hit.total property is returned as an object."
});

/**
 * The scroll ID for scrolled search
 *
 * @deprecated
 */
export const scroll_scroll_id = types_scroll_id;

/**
 * The period to retain the search context for scrolling.
 */
export const scroll_scroll = types_duration;

/**
 * The scroll ID
 *
 * @deprecated
 */
export const scroll_scroll_id2 = types_scroll_id;

/**
 * The ID of the search template to render.
 * If no `source` is specified, this or the `id` request body parameter is required.
 */
export const render_search_template_id = types_id;

/**
 * Search operation type
 */
export const rank_eval_search_type = z.string().register(z.globalRegistry, {
    description: "Search operation type"
});

/**
 * If `true`, missing or closed indices are not included in the response.
 */
export const rank_eval_ignore_unavailable = z.boolean().register(z.globalRegistry, {
    description: "If `true`, missing or closed indices are not included in the response."
});

/**
 * Whether to expand wildcard expression to concrete indices that are open, closed or both.
 */
export const rank_eval_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const rank_eval_allow_no_indices = z.boolean().register(z.globalRegistry, {
    description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
});

/**
 * A  comma-separated list of data streams, indices, and index aliases used to limit the request.
 * Wildcard (`*`) expressions are supported.
 * To target all data streams and indices in a cluster, omit this parameter or use `_all` or `*`.
 */
export const rank_eval_index = types_indices;

/**
 * If `true`, the response prefixes aggregation and suggester names with their respective types.
 */
export const msearch_template_typed_keys = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the response prefixes aggregation and suggester names with their respective types."
});

/**
 * If `true`, the response returns `hits.total` as an integer.
 * If `false`, it returns `hits.total` as an object.
 */
export const msearch_template_rest_total_hits_as_int = z.boolean().register(z.globalRegistry, {
    description: "If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object."
});

/**
 * The type of the search operation.
 */
export const msearch_template_search_type = types_search_type;

/**
 * The maximum number of concurrent searches the API can run.
 */
export const msearch_template_max_concurrent_searches = z.number().register(z.globalRegistry, {
    description: "The maximum number of concurrent searches the API can run."
});

/**
 * If `true`, network round-trips are minimized for cross-cluster search requests.
 */
export const msearch_template_ccs_minimize_roundtrips = z.boolean().register(z.globalRegistry, {
    description: "If `true`, network round-trips are minimized for cross-cluster search requests."
});

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 * To search all data streams and indices, omit this parameter or use `*`.
 */
export const msearch_template_index = types_indices;

/**
 * Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.
 */
export const msearch_typed_keys = z.boolean().register(z.globalRegistry, {
    description: "Specifies whether aggregation and suggester names should be prefixed by their respective types in the response."
});

/**
 * Indicates whether global term and document frequencies should be used when scoring returned documents.
 */
export const msearch_search_type = types_search_type;

/**
 * Custom routing value used to route search operations to a specific shard.
 */
export const msearch_routing = types_routing;

/**
 * If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.
 */
export const msearch_rest_total_hits_as_int = z.boolean().register(z.globalRegistry, {
    description: "If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object."
});

/**
 * Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.
 */
export const msearch_pre_filter_shard_size = z.number().register(z.globalRegistry, {
    description: "Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint."
});

/**
 * Maximum number of concurrent shard requests that each sub-search request executes per node.
 */
export const msearch_max_concurrent_shard_requests = z.number().register(z.globalRegistry, {
    description: "Maximum number of concurrent shard requests that each sub-search request executes per node."
});

/**
 * Maximum number of concurrent searches the multi search API can execute.
 * Defaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`.
 */
export const msearch_max_concurrent_searches = z.number().register(z.globalRegistry, {
    description: "Maximum number of concurrent searches the multi search API can execute.\nDefaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`."
});

/**
 * Comma-separated list of data streams, indices, and index aliases to use as default
 */
export const msearch_index = types_indices;

/**
 * Indicates whether hit.matched_queries should be rendered as a map that includes
 * the name of the matched query associated with its score (true)
 * or as an array containing the name of the matched queries (false)
 * This functionality reruns each named query on every hit in a search response.
 * Typically, this adds a small overhead to a request.
 * However, using computationally expensive named queries on a large number of hits may add significant overhead.
 */
export const msearch_include_named_queries_score = z.boolean().register(z.globalRegistry, {
    description: "Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead."
});

/**
 * If true, missing or closed indices are not included in the response.
 */
export const msearch_ignore_unavailable = z.boolean().register(z.globalRegistry, {
    description: "If true, missing or closed indices are not included in the response."
});

/**
 * If true, concrete, expanded or aliased indices are ignored when frozen.
 *
 * @deprecated
 */
export const msearch_ignore_throttled = z.boolean().register(z.globalRegistry, {
    description: "If true, concrete, expanded or aliased indices are ignored when frozen."
});

/**
 * Type of index that wildcard expressions can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 */
export const msearch_expand_wildcards = types_expand_wildcards;

/**
 * If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.
 */
export const msearch_ccs_minimize_roundtrips = z.boolean().register(z.globalRegistry, {
    description: "If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests."
});

/**
 * If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.
 */
export const msearch_allow_no_indices = z.boolean().register(z.globalRegistry, {
    description: "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar."
});

/**
 * Comma-separated list of data streams, indices, and index aliases to search.
 */
export const msearch_index2 = types_indices;

/**
 * If false, empty fields are not included in the response.
 */
export const field_caps_include_empty_fields = z.boolean().register(z.globalRegistry, {
    description: "If false, empty fields are not included in the response."
});

/**
 * A comma-separated list of field types to include.
 * Any fields that do not match one of these types will be excluded from the results.
 * It defaults to empty, meaning that all field types are returned.
 */
export const field_caps_types = z.array(z.string()).register(z.globalRegistry, {
    description: "A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned."
});

/**
 * A comma-separated list of filters to apply to the response.
 */
export const field_caps_filters = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * If true, unmapped fields are included in the response.
 */
export const field_caps_include_unmapped = z.boolean().register(z.globalRegistry, {
    description: "If true, unmapped fields are included in the response."
});

/**
 * If `true`, missing or closed indices are not included in the response.
 */
export const field_caps_ignore_unavailable = z.boolean().register(z.globalRegistry, {
    description: "If `true`, missing or closed indices are not included in the response."
});

/**
 * A comma-separated list of fields to retrieve capabilities for. Wildcard (`*`) expressions are supported.
 */
export const field_caps_fields = types_fields;

/**
 * The type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`.
 */
export const field_caps_expand_wildcards = types_expand_wildcards;

/**
 * If false, the request returns an error if any wildcard expression, index alias,
 * or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request
 * targeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar.
 */
export const field_caps_allow_no_indices = z.boolean().register(z.globalRegistry, {
    description: "If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar."
});

/**
 * A comma-separated list of data streams, indices, and aliases used to limit the request. Supports wildcards (*). To target all data streams and indices, omit this parameter or use * or _all.
 */
export const field_caps_index = types_indices;

/**
 * The query in the Lucene query string syntax.
 */
export const explain_q = z.string().register(z.globalRegistry, {
    description: "The query in the Lucene query string syntax."
});

/**
 * A comma-separated list of stored fields to return in the response.
 */
export const explain_stored_fields = types_fields;

/**
 * A comma-separated list of source fields to include in the response.
 * If this parameter is specified, only these source fields are returned.
 * You can exclude fields from this subset using the `_source_excludes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const explain_source_includes = types_fields;

/**
 * A comma-separated list of source fields to exclude from the response.
 * You can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const explain_source_excludes = types_fields;

/**
 * `True` or `false` to return the `_source` field or not or a list of fields to return.
 */
export const explain_source = global_search_types_source_config_param;

/**
 * A custom value used to route operations to a specific shard.
 */
export const explain_routing = types_routing;

/**
 * The node or shard the operation should be performed on.
 * It is random by default.
 */
export const explain_preference = z.string().register(z.globalRegistry, {
    description: "The node or shard the operation should be performed on.\nIt is random by default."
});

/**
 * If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const explain_lenient = z.boolean().register(z.globalRegistry, {
    description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * The field to use as default where no field prefix is given in the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const explain_df = z.string().register(z.globalRegistry, {
    description: "The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * The default operator for query string query: `and` or `or`.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const explain_default_operator = types_query_dsl_operator;

/**
 * If `true`, wildcard and prefix queries are analyzed.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const explain_analyze_wildcard = z.boolean().register(z.globalRegistry, {
    description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * The analyzer to use for the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const explain_analyzer = z.string().register(z.globalRegistry, {
    description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * Index names that are used to limit the request.
 * Only a single index name can be provided to this parameter.
 */
export const explain_index = types_index_name;

/**
 * The document identifier.
 */
export const explain_id = types_id;

/**
 * The query in Lucene query string syntax. This parameter cannot be used with a request body.
 */
export const count_q = z.string().register(z.globalRegistry, {
    description: "The query in Lucene query string syntax. This parameter cannot be used with a request body."
});

/**
 * The maximum number of documents to collect for each shard.
 * If a query reaches this limit, Elasticsearch terminates the query early.
 * Elasticsearch collects documents before sorting.
 *
 * IMPORTANT: Use with caution.
 * Elasticsearch applies this parameter to each shard handling the request.
 * When possible, let Elasticsearch perform early termination automatically.
 * Avoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.
 */
export const count_terminate_after = z.number().register(z.globalRegistry, {
    description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers."
});

/**
 * A custom value used to route operations to a specific shard.
 */
export const count_routing = types_routing;

/**
 * The node or shard the operation should be performed on.
 * By default, it is random.
 */
export const count_preference = z.string().register(z.globalRegistry, {
    description: "The node or shard the operation should be performed on.\nBy default, it is random."
});

/**
 * The minimum `_score` value that documents must have to be included in the result.
 */
export const count_min_score = z.number().register(z.globalRegistry, {
    description: "The minimum `_score` value that documents must have to be included in the result."
});

/**
 * If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const count_lenient = z.boolean().register(z.globalRegistry, {
    description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const count_ignore_unavailable = z.boolean().register(z.globalRegistry, {
    description: "If `false`, the request returns an error if it targets a missing or closed index."
});

/**
 * If `true`, concrete, expanded, or aliased indices are ignored when frozen.
 *
 * @deprecated
 */
export const count_ignore_throttled = z.boolean().register(z.globalRegistry, {
    description: "If `true`, concrete, expanded, or aliased indices are ignored when frozen."
});

/**
 * The type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * It supports comma-separated values, such as `open,hidden`.
 */
export const count_expand_wildcards = types_expand_wildcards;

/**
 * The field to use as a default when no field prefix is given in the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const count_df = z.string().register(z.globalRegistry, {
    description: "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * The default operator for query string query: `and` or `or`.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const count_default_operator = types_query_dsl_operator;

/**
 * If `true`, wildcard and prefix queries are analyzed.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const count_analyze_wildcard = z.boolean().register(z.globalRegistry, {
    description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * The analyzer to use for the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const count_analyzer = z.string().register(z.globalRegistry, {
    description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
});

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 * For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const count_allow_no_indices = z.boolean().register(z.globalRegistry, {
    description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
});

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 * To search all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const count_index = types_indices;

/**
 * A comma-separated list of scroll IDs to clear.
 * To clear all scroll IDs, use `_all`.
 * IMPORTANT: Scroll IDs can be long. It is recommended to specify scroll IDs in the request body parameter.
 *
 * @deprecated
 */
export const clear_scroll_scroll_id = types_scroll_ids;

/**
 * A comma-separated list of <field>:<direction> pairs
 */
export const async_search_submit_sort = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * Starting offset (default: 0)
 */
export const async_search_submit_from = z.number().register(z.globalRegistry, {
    description: "Starting offset (default: 0)"
});

/**
 * Number of hits to return (default: 10)
 */
export const async_search_submit_size = z.number().register(z.globalRegistry, {
    description: "Number of hits to return (default: 10)"
});

/**
 * Query in the Lucene query string syntax
 */
export const async_search_submit_q = z.string().register(z.globalRegistry, {
    description: "Query in the Lucene query string syntax"
});

/**
 * Specify whether to return sequence number and primary term of the last modification of each hit
 */
export const async_search_submit_seq_no_primary_term = z.boolean().register(z.globalRegistry, {
    description: "Specify whether to return sequence number and primary term of the last modification of each hit"
});

/**
 * A list of fields to extract and return from the _source field
 */
export const async_search_submit_source_includes = types_fields;

/**
 * A list of fields to exclude from the returned _source field
 */
export const async_search_submit_source_excludes = types_fields;

/**
 * True or false to return the _source field or not, or a list of fields to return
 */
export const async_search_submit_source = global_search_types_source_config_param;

/**
 * Specify whether to return document version as part of a hit
 */
export const async_search_submit_version = z.boolean().register(z.globalRegistry, {
    description: "Specify whether to return document version as part of a hit"
});

/**
 * Indicates whether hits.total should be rendered as an integer or an object in the rest search response
 */
export const async_search_submit_rest_total_hits_as_int = z.boolean().register(z.globalRegistry, {
    description: "Indicates whether hits.total should be rendered as an integer or an object in the rest search response"
});

/**
 * Specify whether aggregation and suggester names should be prefixed by their respective types in the response
 */
export const async_search_submit_typed_keys = z.boolean().register(z.globalRegistry, {
    description: "Specify whether aggregation and suggester names should be prefixed by their respective types in the response"
});

/**
 * Whether to calculate and return scores even if they are not used for sorting
 */
export const async_search_submit_track_scores = z.boolean().register(z.globalRegistry, {
    description: "Whether to calculate and return scores even if they are not used for sorting"
});

/**
 * Indicate if the number of documents that match the query should be tracked. A number can also be specified, to accurately track the total hit count up to the number.
 */
export const async_search_submit_track_total_hits = global_search_types_track_hits;

/**
 * Explicit operation timeout
 */
export const async_search_submit_timeout = types_duration;

/**
 * The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
 */
export const async_search_submit_terminate_after = z.number().register(z.globalRegistry, {
    description: "The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early."
});

/**
 * The source text for which the suggestions should be returned.
 */
export const async_search_submit_suggest_text = z.string().register(z.globalRegistry, {
    description: "The source text for which the suggestions should be returned."
});

/**
 * How many suggestions to return in response
 */
export const async_search_submit_suggest_size = z.number().register(z.globalRegistry, {
    description: "How many suggestions to return in response"
});

/**
 * Specify suggest mode
 */
export const async_search_submit_suggest_mode = types_suggest_mode;

/**
 * Specifies which field to use for suggestions.
 */
export const async_search_submit_suggest_field = types_field;

/**
 * A comma-separated list of stored fields to return as part of a hit
 */
export const async_search_submit_stored_fields = types_fields;

/**
 * Specific 'tag' of the request for logging and statistical purposes
 */
export const async_search_submit_stats = z.array(z.string()).register(z.globalRegistry, {
    description: "Specific 'tag' of the request for logging and statistical purposes"
});

/**
 * Search operation type
 */
export const async_search_submit_search_type = types_search_type;

/**
 * A comma-separated list of specific routing values
 */
export const async_search_submit_routing = types_routing;

/**
 * Specify if request cache should be used for this request or not, defaults to true
 */
export const async_search_submit_request_cache = z.boolean().register(z.globalRegistry, {
    description: "Specify if request cache should be used for this request or not, defaults to true"
});

/**
 * Specify the node or shard the operation should be performed on (default: random)
 */
export const async_search_submit_preference = z.string().register(z.globalRegistry, {
    description: "Specify the node or shard the operation should be performed on (default: random)"
});

/**
 * The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests
 */
export const async_search_submit_max_concurrent_shard_requests = z.number().register(z.globalRegistry, {
    description: "The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests"
});

/**
 * Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
 */
export const async_search_submit_lenient = z.boolean().register(z.globalRegistry, {
    description: "Specify whether format-based query failures (such as providing text to a numeric field) should be ignored"
});

/**
 * Whether specified concrete indices should be ignored when unavailable (missing or closed)
 */
export const async_search_submit_ignore_unavailable = z.boolean().register(z.globalRegistry, {
    description: "Whether specified concrete indices should be ignored when unavailable (missing or closed)"
});

/**
 * Whether specified concrete, expanded or aliased indices should be ignored when throttled
 */
export const async_search_submit_ignore_throttled = z.boolean().register(z.globalRegistry, {
    description: "Whether specified concrete, expanded or aliased indices should be ignored when throttled"
});

/**
 * Specify whether to return detailed information about score computation as part of a hit
 */
export const async_search_submit_explain = z.boolean().register(z.globalRegistry, {
    description: "Specify whether to return detailed information about score computation as part of a hit"
});

/**
 * Whether to expand wildcard expression to concrete indices that are open, closed or both.
 */
export const async_search_submit_expand_wildcards = types_expand_wildcards;

/**
 * A comma-separated list of fields to return as the docvalue representation of a field for each hit
 */
export const async_search_submit_docvalue_fields = types_fields;

/**
 * The field to use as default where no field prefix is given in the query string
 */
export const async_search_submit_df = z.string().register(z.globalRegistry, {
    description: "The field to use as default where no field prefix is given in the query string"
});

/**
 * The default operator for query string query (AND or OR)
 */
export const async_search_submit_default_operator = types_query_dsl_operator;

/**
 * The default value is the only supported value.
 */
export const async_search_submit_ccs_minimize_roundtrips = z.boolean().register(z.globalRegistry, {
    description: "The default value is the only supported value."
});

/**
 * Affects how often partial results become available, which happens whenever shard results are reduced.
 * A partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).
 */
export const async_search_submit_batched_reduce_size = z.number().register(z.globalRegistry, {
    description: "Affects how often partial results become available, which happens whenever shard results are reduced.\nA partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default)."
});

/**
 * Specify whether wildcard and prefix queries should be analyzed (default: false)
 */
export const async_search_submit_analyze_wildcard = z.boolean().register(z.globalRegistry, {
    description: "Specify whether wildcard and prefix queries should be analyzed (default: false)"
});

/**
 * The analyzer to use for the query string
 */
export const async_search_submit_analyzer = z.string().register(z.globalRegistry, {
    description: "The analyzer to use for the query string"
});

/**
 * Indicate if an error should be returned if there is a partial search failure or timeout
 */
export const async_search_submit_allow_partial_search_results = z.boolean().register(z.globalRegistry, {
    description: "Indicate if an error should be returned if there is a partial search failure or timeout"
});

/**
 * Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
 */
export const async_search_submit_allow_no_indices = z.boolean().register(z.globalRegistry, {
    description: "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)"
});

/**
 * If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`.
 */
export const async_search_submit_keep_on_completion = z.boolean().register(z.globalRegistry, {
    description: "If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`."
});

/**
 * Specifies how long the async search needs to be available.
 * Ongoing async searches and any saved search results are deleted after this period.
 */
export const async_search_submit_keep_alive = types_duration;

/**
 * Blocks and waits until the search is completed up to a certain timeout.
 * When the async search completes within the timeout, the response won’t include the ID as the results are not stored in the cluster.
 */
export const async_search_submit_wait_for_completion_timeout = types_duration;

/**
 * A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
 */
export const async_search_submit_index = types_indices;

export const scroll = z.object({
    scroll: z.optional(types_duration),
    scroll_id: types_scroll_id
});

export const clear_scroll = z.object({
    scroll_id: z.optional(types_scroll_ids)
});

export const terms_enum = z.object({
    field: types_field,
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of matching terms to return."
    })).default(10),
    timeout: z.optional(types_duration),
    case_insensitive: z.optional(z.boolean().register(z.globalRegistry, {
        description: "When `true`, the provided search string is matched against index terms without case sensitivity."
    })).default(false),
    index_filter: z.optional(types_query_dsl_query_container),
    string: z.optional(z.string().register(z.globalRegistry, {
        description: "The string to match at the start of indexed terms.\nIf it is not provided, all terms in the field are considered.\n\n> info\n> The prefix string cannot be larger than the largest possible keyword value, which is Lucene's term byte-length limit of 32766."
    })),
    search_after: z.optional(z.string().register(z.globalRegistry, {
        description: "The string after which terms in the index should be returned.\nIt allows for a form of pagination if the last result from one request is passed as the `search_after` parameter for a subsequent request."
    }))
});

export const search_template = z.object({
    explain: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, returns detailed information about score calculation as part of each hit.\nIf you specify both this and the `explain` query parameter, the API uses only the query parameter."
    })).default(false),
    id: z.optional(types_id),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value."
    })),
    profile: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the query execution is profiled."
    })).default(false),
    source: z.optional(types_script_source)
});

export const search_mvt = z.object({
    aggs: z.optional(z.record(z.string(), types_aggregations_aggregation_container).register(z.globalRegistry, {
        description: "Sub-aggregations for the geotile_grid.\n\nIt supports the following aggregation types:\n\n- `avg`\n- `boxplot`\n- `cardinality`\n- `extended stats`\n- `max`\n- `median absolute deviation`\n- `min`\n- `percentile`\n- `percentile-rank`\n- `stats`\n- `sum`\n- `value count`\n\nThe aggregation names can't start with `_mvt_`. The `_mvt_` prefix is reserved for internal aggregations."
    })),
    buffer: z.optional(z.number().register(z.globalRegistry, {
        description: "The size, in pixels, of a clipping buffer outside the tile. This allows renderers\nto avoid outline artifacts from geometries that extend past the extent of the tile."
    })).default(5),
    exact_bounds: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `false`, the meta layer's feature is the bounding box of the tile.\nIf `true`, the meta layer's feature is a bounding box resulting from a\n`geo_bounds` aggregation. The aggregation runs on <field> values that intersect\nthe `<zoom>/<x>/<y>` tile with `wrap_longitude` set to `false`. The resulting\nbounding box may be larger than the vector tile."
    })).default(false),
    extent: z.optional(z.number().register(z.globalRegistry, {
        description: "The size, in pixels, of a side of the tile. Vector tiles are square with equal sides."
    })).default(4096),
    fields: z.optional(types_fields),
    grid_agg: z.optional(global_search_mvt_types_grid_aggregation_type),
    grid_precision: z.optional(z.number().register(z.globalRegistry, {
        description: "Additional zoom levels available through the aggs layer. For example, if `<zoom>` is `7`\nand `grid_precision` is `8`, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndon't include the aggs layer."
    })).default(8),
    grid_type: z.optional(global_search_mvt_types_grid_type),
    query: z.optional(types_query_dsl_query_container),
    runtime_mappings: z.optional(types_mapping_runtime_fields),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results don't include the hits layer."
    })).default(10000),
    sort: z.optional(types_sort),
    track_total_hits: z.optional(global_search_types_track_hits),
    with_labels: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.\n\n* `Point` and `MultiPoint` features will have one of the points selected.\n* `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.\n* `LineString` features will likewise provide a roughly central point selected from the triangle-tree.\n* The aggregation results will provide one central point for each aggregation bucket.\n\nAll attributes from the original features will also be copied to the new label features.\nIn addition, the new features will be distinguishable using the tag `_mvt_label_position`."
    }))
});

export const search = z.object({
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregation_container).register(z.globalRegistry, {
        description: "Defines the aggregations that are run as part of the search request."
    })),
    collapse: z.optional(global_search_types_field_collapse),
    explain: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the request returns detailed information about score computation as part of a hit."
    })).default(false),
    ext: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "Configuration of search extensions defined by Elasticsearch plugins."
    })),
    from: z.optional(z.number().register(z.globalRegistry, {
        description: "The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
    })).default(0),
    highlight: z.optional(global_search_types_highlight),
    track_total_hits: z.optional(global_search_types_track_hits),
    indices_boost: z.optional(z.array(z.record(z.string(), z.number())).register(z.globalRegistry, {
        description: "Boost the `_score` of documents from specified indices.\nThe boost value is the factor by which scores are multiplied.\nA boost value greater than `1.0` increases the score.\nA boost value between `0` and `1.0` decreases the score."
    })),
    docvalue_fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: "An array of wildcard (`*`) field patterns.\nThe request returns doc values for field names matching these patterns in the `hits.fields` property of the response."
    })),
    knn: z.optional(z.union([
        types_knn_search,
        z.array(types_knn_search)
    ])),
    rank: z.optional(types_rank_container),
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: "The minimum `_score` for matching documents.\nDocuments with a lower `_score` are not included in search results and results collected by aggregations."
    })),
    post_filter: z.optional(types_query_dsl_query_container),
    profile: z.optional(z.boolean().register(z.globalRegistry, {
        description: "Set to `true` to return detailed timing information about the execution of individual components in a search request.\nNOTE: This is a debugging tool and adds significant overhead to search execution."
    })).default(false),
    query: z.optional(types_query_dsl_query_container),
    rescore: z.optional(z.union([
        global_search_types_rescore,
        z.array(global_search_types_rescore)
    ])),
    retriever: z.optional(types_retriever_container),
    script_fields: z.optional(z.record(z.string(), types_script_field).register(z.globalRegistry, {
        description: "Retrieve a script evaluation (based on different fields) for each hit."
    })),
    search_after: z.optional(types_sort_results),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of hits to return, which must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` property."
    })).default(10),
    slice: z.optional(types_sliced_scroll),
    sort: z.optional(types_sort),
    _source: z.optional(global_search_types_source_config),
    fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: "An array of wildcard (`*`) field patterns.\nThe request returns values for field names matching these patterns in the `hits.fields` property of the response."
    })),
    suggest: z.optional(global_search_types_suggester),
    terminate_after: z.optional(z.number().register(z.globalRegistry, {
        description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this property to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this property for requests that target data streams with backing indices across multiple data tiers.\n\nIf set to `0` (default), the query does not terminate early."
    })).default(0),
    timeout: z.optional(z.string().register(z.globalRegistry, {
        description: "The period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout."
    })),
    track_scores: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, calculate and return document scores, even if the scores are not used for sorting."
    })).default(false),
    version: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the request returns the document version as part of a hit."
    })).default(false),
    seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If `true`, the request returns sequence number and primary term of the last modification of each hit."
    })),
    stored_fields: z.optional(types_fields),
    pit: z.optional(global_search_types_point_in_time_reference),
    runtime_mappings: z.optional(types_mapping_runtime_fields),
    stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: "The stats groups to associate with the search.\nEach group maintains a statistics aggregation for its associated searches.\nYou can retrieve these stats using the indices stats API."
    }))
});

export const render_search_template = z.object({
    id: z.optional(types_id),
    file: z.optional(z.string()),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value."
    })),
    source: z.optional(types_script_source)
});

export const rank_eval = z.object({
    requests: z.array(global_rank_eval_rank_eval_request_item).register(z.globalRegistry, {
        description: "A set of typical search requests, together with their provided ratings."
    }),
    metric: z.optional(global_rank_eval_rank_eval_metric)
});

export const msearch_template = z.array(global_msearch_template_request_item);

export const msearch = z.array(global_msearch_request_item);

export const field_caps = z.object({
    fields: z.optional(types_fields),
    index_filter: z.optional(types_query_dsl_query_container),
    runtime_mappings: z.optional(types_mapping_runtime_fields)
});

export const explain = z.object({
    query: z.optional(types_query_dsl_query_container)
});

export const count = z.object({
    query: z.optional(types_query_dsl_query_container)
});

export const async_search_submit = z.object({
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregation_container)),
    collapse: z.optional(global_search_types_field_collapse),
    explain: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If true, returns detailed information about score computation as part of a hit."
    })).default(false),
    ext: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "Configuration of search extensions defined by Elasticsearch plugins."
    })),
    from: z.optional(z.number().register(z.globalRegistry, {
        description: "Starting document offset. By default, you cannot page through more than 10,000\nhits using the from and size parameters. To page through more hits, use the\nsearch_after parameter."
    })).default(0),
    highlight: z.optional(global_search_types_highlight),
    track_total_hits: z.optional(global_search_types_track_hits),
    indices_boost: z.optional(z.array(z.record(z.string(), z.number())).register(z.globalRegistry, {
        description: "Boosts the _score of documents from specified indices."
    })),
    docvalue_fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: "Array of wildcard (*) patterns. The request returns doc values for field\nnames matching these patterns in the hits.fields property of the response."
    })),
    knn: z.optional(z.union([
        types_knn_search,
        z.array(types_knn_search)
    ])),
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: "Minimum _score for matching documents. Documents with a lower _score are\nnot included in search results and results collected by aggregations."
    })),
    post_filter: z.optional(types_query_dsl_query_container),
    profile: z.optional(z.boolean()),
    query: z.optional(types_query_dsl_query_container),
    rescore: z.optional(z.union([
        global_search_types_rescore,
        z.array(global_search_types_rescore)
    ])),
    script_fields: z.optional(z.record(z.string(), types_script_field).register(z.globalRegistry, {
        description: "Retrieve a script evaluation (based on different fields) for each hit."
    })),
    search_after: z.optional(types_sort_results),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: "The number of hits to return. By default, you cannot page through more\nthan 10,000 hits using the from and size parameters. To page through more\nhits, use the search_after parameter."
    })).default(10),
    slice: z.optional(types_sliced_scroll),
    sort: z.optional(types_sort),
    _source: z.optional(global_search_types_source_config),
    fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: "Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response."
    })),
    suggest: z.optional(global_search_types_suggester),
    terminate_after: z.optional(z.number().register(z.globalRegistry, {
        description: "Maximum number of documents to collect for each shard. If a query reaches this\nlimit, Elasticsearch terminates the query early. Elasticsearch collects documents\nbefore sorting. Defaults to 0, which does not terminate query execution early."
    })).default(0),
    timeout: z.optional(z.string().register(z.globalRegistry, {
        description: "Specifies the period of time to wait for a response from each shard. If no response\nis received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout."
    })),
    track_scores: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If true, calculate and return document scores, even if the scores are not used for sorting."
    })).default(false),
    version: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If true, returns document version as part of a hit."
    })).default(false),
    seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If true, returns sequence number and primary term of the last modification\nof each hit. See Optimistic concurrency control."
    })),
    stored_fields: z.optional(types_fields),
    pit: z.optional(global_search_types_point_in_time_reference),
    runtime_mappings: z.optional(types_mapping_runtime_fields),
    stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: "Stats groups to associate with the search. Each group maintains a statistics\naggregation for its associated searches. You can retrieve these stats using\nthe indices stats API."
    }))
});

export const async_search_delete_request = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: types_id
    }),
    query: z.optional(z.never())
});

export const async_search_delete_response = types_acknowledged_response_base;

export const async_search_status_request = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: types_id
    }),
    query: z.optional(z.object({
        keep_alive: z.optional(types_duration)
    }))
});

export const async_search_status_response = async_search_status_status_response_base;

export const clear_scroll_request = z.object({
    body: z.optional(clear_scroll),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const clear_scroll_response = z.object({
    succeeded: z.boolean().register(z.globalRegistry, {
        description: "If `true`, the request succeeded.\nThis does not indicate whether any scrolling search requests were cleared."
    }),
    num_freed: z.number().register(z.globalRegistry, {
        description: "The number of scrolling search requests cleared."
    })
});

export const clear_scroll1_request = z.object({
    body: z.optional(clear_scroll),
    path: z.object({
        scroll_id: types_scroll_ids
    }),
    query: z.optional(z.never())
});

export const clear_scroll1_response = z.object({
    succeeded: z.boolean().register(z.globalRegistry, {
        description: "If `true`, the request succeeded.\nThis does not indicate whether any scrolling search requests were cleared."
    }),
    num_freed: z.number().register(z.globalRegistry, {
        description: "The number of scrolling search requests cleared."
    })
});

export const close_point_in_time_request = z.object({
    body: z.object({
        id: types_id
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const close_point_in_time_response = z.object({
    succeeded: z.boolean().register(z.globalRegistry, {
        description: "If `true`, all search contexts associated with the point-in-time ID were successfully closed."
    }),
    num_freed: z.number().register(z.globalRegistry, {
        description: "The number of search contexts that were successfully closed."
    })
});

export const async_search_get_request = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: types_id
    }),
    query: z.optional(z.object({
        keep_alive: z.optional(types_duration),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether aggregation and suggester names should be prefixed by their respective types in the response"
        })),
        wait_for_completion_timeout: z.optional(types_duration)
    }))
});

export const async_search_get_response = async_search_types_async_search_document_response_base;

export const async_search_submit_request = z.object({
    body: z.optional(async_search_submit),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        wait_for_completion_timeout: z.optional(types_duration),
        keep_alive: z.optional(types_duration),
        keep_on_completion: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`."
        })),
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)"
        })),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicate if an error should be returned if there is a partial search failure or timeout"
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string"
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether wildcard and prefix queries should be analyzed (default: false)"
        })),
        batched_reduce_size: z.optional(z.number().register(z.globalRegistry, {
            description: "Affects how often partial results become available, which happens whenever shard results are reduced.\nA partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default)."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "The default value is the only supported value."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as default where no field prefix is given in the query string"
        })),
        docvalue_fields: z.optional(types_fields),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether to return detailed information about score computation as part of a hit"
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether specified concrete, expanded or aliased indices should be ignored when throttled"
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether specified concrete indices should be ignored when unavailable (missing or closed)"
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether format-based query failures (such as providing text to a numeric field) should be ignored"
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests"
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "Specify the node or shard the operation should be performed on (default: random)"
        })),
        request_cache: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify if request cache should be used for this request or not, defaults to true"
        })),
        routing: z.optional(types_routing),
        search_type: z.optional(types_search_type),
        stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: "Specific 'tag' of the request for logging and statistical purposes"
        })),
        stored_fields: z.optional(types_fields),
        suggest_field: z.optional(types_field),
        suggest_mode: z.optional(types_suggest_mode),
        suggest_size: z.optional(z.number().register(z.globalRegistry, {
            description: "How many suggestions to return in response"
        })),
        suggest_text: z.optional(z.string().register(z.globalRegistry, {
            description: "The source text for which the suggestions should be returned."
        })),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early."
        })),
        timeout: z.optional(types_duration),
        track_total_hits: z.optional(global_search_types_track_hits),
        track_scores: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether to calculate and return scores even if they are not used for sorting"
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether aggregation and suggester names should be prefixed by their respective types in the response"
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether hits.total should be rendered as an integer or an object in the rest search response"
        })),
        version: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether to return document version as part of a hit"
        })),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_includes: z.optional(types_fields),
        seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether to return sequence number and primary term of the last modification of each hit"
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "Query in the Lucene query string syntax"
        })),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: "Number of hits to return (default: 10)"
        })),
        from: z.optional(z.number().register(z.globalRegistry, {
            description: "Starting offset (default: 0)"
        })),
        sort: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ]))
    }))
});

export const async_search_submit_response = async_search_types_async_search_document_response_base;

export const async_search_submit1_request = z.object({
    body: z.optional(async_search_submit),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        wait_for_completion_timeout: z.optional(types_duration),
        keep_alive: z.optional(types_duration),
        keep_on_completion: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`."
        })),
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)"
        })),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicate if an error should be returned if there is a partial search failure or timeout"
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string"
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether wildcard and prefix queries should be analyzed (default: false)"
        })),
        batched_reduce_size: z.optional(z.number().register(z.globalRegistry, {
            description: "Affects how often partial results become available, which happens whenever shard results are reduced.\nA partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default)."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "The default value is the only supported value."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as default where no field prefix is given in the query string"
        })),
        docvalue_fields: z.optional(types_fields),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether to return detailed information about score computation as part of a hit"
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether specified concrete, expanded or aliased indices should be ignored when throttled"
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether specified concrete indices should be ignored when unavailable (missing or closed)"
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether format-based query failures (such as providing text to a numeric field) should be ignored"
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests"
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "Specify the node or shard the operation should be performed on (default: random)"
        })),
        request_cache: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify if request cache should be used for this request or not, defaults to true"
        })),
        routing: z.optional(types_routing),
        search_type: z.optional(types_search_type),
        stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: "Specific 'tag' of the request for logging and statistical purposes"
        })),
        stored_fields: z.optional(types_fields),
        suggest_field: z.optional(types_field),
        suggest_mode: z.optional(types_suggest_mode),
        suggest_size: z.optional(z.number().register(z.globalRegistry, {
            description: "How many suggestions to return in response"
        })),
        suggest_text: z.optional(z.string().register(z.globalRegistry, {
            description: "The source text for which the suggestions should be returned."
        })),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early."
        })),
        timeout: z.optional(types_duration),
        track_total_hits: z.optional(global_search_types_track_hits),
        track_scores: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether to calculate and return scores even if they are not used for sorting"
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether aggregation and suggester names should be prefixed by their respective types in the response"
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether hits.total should be rendered as an integer or an object in the rest search response"
        })),
        version: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether to return document version as part of a hit"
        })),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_includes: z.optional(types_fields),
        seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specify whether to return sequence number and primary term of the last modification of each hit"
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "Query in the Lucene query string syntax"
        })),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: "Number of hits to return (default: 10)"
        })),
        from: z.optional(z.number().register(z.globalRegistry, {
            description: "Starting offset (default: 0)"
        })),
        sort: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ]))
    }))
});

export const async_search_submit1_response = async_search_types_async_search_document_response_base;

export const scroll_request = z.object({
    body: z.optional(scroll),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        scroll: z.optional(types_duration),
        scroll_id: z.optional(types_scroll_id),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, the API response’s hit.total property is returned as an integer. If false, the API response’s hit.total property is returned as an object."
        }))
    }))
});

export const scroll_response = global_search_response_body;

export const scroll1_request = z.object({
    body: z.optional(scroll),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        scroll: z.optional(types_duration),
        scroll_id: z.optional(types_scroll_id),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, the API response’s hit.total property is returned as an integer. If false, the API response’s hit.total property is returned as an object."
        }))
    }))
});

export const scroll1_response = global_search_response_body;

export const scroll2_request = z.object({
    body: z.optional(scroll),
    path: z.object({
        scroll_id: types_scroll_id
    }),
    query: z.optional(z.object({
        scroll: z.optional(types_duration),
        scroll_id: z.optional(types_scroll_id),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, the API response’s hit.total property is returned as an integer. If false, the API response’s hit.total property is returned as an object."
        }))
    }))
});

export const scroll2_response = global_search_response_body;

export const scroll3_request = z.object({
    body: z.optional(scroll),
    path: z.object({
        scroll_id: types_scroll_id
    }),
    query: z.optional(z.object({
        scroll: z.optional(types_duration),
        scroll_id: z.optional(types_scroll_id),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, the API response’s hit.total property is returned as an integer. If false, the API response’s hit.total property is returned as an object."
        }))
    }))
});

export const scroll3_response = global_search_response_body;

export const count1_request = z.object({
    body: z.optional(count),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, concrete, expanded, or aliased indices are ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        min_score: z.optional(z.number().register(z.globalRegistry, {
            description: "The minimum `_score` value that documents must have to be included in the result."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nBy default, it is random."
        })),
        routing: z.optional(types_routing),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers."
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "The query in Lucene query string syntax. This parameter cannot be used with a request body."
        }))
    }))
});

export const count1_response = z.object({
    count: z.number(),
    _shards: types_shard_statistics
});

export const count_request = z.object({
    body: z.optional(count),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, concrete, expanded, or aliased indices are ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        min_score: z.optional(z.number().register(z.globalRegistry, {
            description: "The minimum `_score` value that documents must have to be included in the result."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nBy default, it is random."
        })),
        routing: z.optional(types_routing),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers."
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "The query in Lucene query string syntax. This parameter cannot be used with a request body."
        }))
    }))
});

export const count_response = z.object({
    count: z.number(),
    _shards: types_shard_statistics
});

export const count3_request = z.object({
    body: z.optional(count),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, concrete, expanded, or aliased indices are ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        min_score: z.optional(z.number().register(z.globalRegistry, {
            description: "The minimum `_score` value that documents must have to be included in the result."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nBy default, it is random."
        })),
        routing: z.optional(types_routing),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers."
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "The query in Lucene query string syntax. This parameter cannot be used with a request body."
        }))
    }))
});

export const count3_response = z.object({
    count: z.number(),
    _shards: types_shard_statistics
});

export const count2_request = z.object({
    body: z.optional(count),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, concrete, expanded, or aliased indices are ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        min_score: z.optional(z.number().register(z.globalRegistry, {
            description: "The minimum `_score` value that documents must have to be included in the result."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nBy default, it is random."
        })),
        routing: z.optional(types_routing),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers."
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "The query in Lucene query string syntax. This parameter cannot be used with a request body."
        }))
    }))
});

export const count2_response = z.object({
    count: z.number(),
    _shards: types_shard_statistics
});

export const explain_request = z.object({
    body: z.optional(explain),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.optional(z.object({
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nIt is random by default."
        })),
        routing: z.optional(types_routing),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_includes: z.optional(types_fields),
        stored_fields: z.optional(types_fields),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "The query in the Lucene query string syntax."
        }))
    }))
});

export const explain_response = z.object({
    _index: types_index_name,
    _id: types_id,
    matched: z.boolean(),
    explanation: z.optional(global_explain_explanation_detail),
    get: z.optional(types_inline_get)
});

export const explain1_request = z.object({
    body: z.optional(explain),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.optional(z.object({
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nIt is random by default."
        })),
        routing: z.optional(types_routing),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_includes: z.optional(types_fields),
        stored_fields: z.optional(types_fields),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "The query in the Lucene query string syntax."
        }))
    }))
});

export const explain1_response = z.object({
    _index: types_index_name,
    _id: types_id,
    matched: z.boolean(),
    explanation: z.optional(global_explain_explanation_detail),
    get: z.optional(types_inline_get)
});

export const field_caps_request = z.object({
    body: z.optional(field_caps),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        fields: z.optional(types_fields),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, missing or closed indices are not included in the response."
        })),
        include_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, unmapped fields are included in the response."
        })),
        filters: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ])),
        types: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: "A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned."
        })),
        include_empty_fields: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, empty fields are not included in the response."
        }))
    }))
});

export const field_caps_response = z.object({
    indices: types_indices,
    fields: z.record(z.string(), z.record(z.string(), global_field_caps_field_capability))
});

export const field_caps1_request = z.object({
    body: z.optional(field_caps),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        fields: z.optional(types_fields),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, missing or closed indices are not included in the response."
        })),
        include_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, unmapped fields are included in the response."
        })),
        filters: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ])),
        types: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: "A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned."
        })),
        include_empty_fields: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, empty fields are not included in the response."
        }))
    }))
});

export const field_caps1_response = z.object({
    indices: types_indices,
    fields: z.record(z.string(), z.record(z.string(), global_field_caps_field_capability))
});

export const field_caps2_request = z.object({
    body: z.optional(field_caps),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        fields: z.optional(types_fields),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, missing or closed indices are not included in the response."
        })),
        include_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, unmapped fields are included in the response."
        })),
        filters: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ])),
        types: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: "A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned."
        })),
        include_empty_fields: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, empty fields are not included in the response."
        }))
    }))
});

export const field_caps2_response = z.object({
    indices: types_indices,
    fields: z.record(z.string(), z.record(z.string(), global_field_caps_field_capability))
});

export const field_caps3_request = z.object({
    body: z.optional(field_caps),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        fields: z.optional(types_fields),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, missing or closed indices are not included in the response."
        })),
        include_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, unmapped fields are included in the response."
        })),
        filters: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ])),
        types: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: "A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned."
        })),
        include_empty_fields: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, empty fields are not included in the response."
        }))
    }))
});

export const field_caps3_response = z.object({
    indices: types_indices,
    fields: z.record(z.string(), z.record(z.string(), global_field_caps_field_capability))
});

export const msearch_request = z.object({
    body: msearch,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, concrete, expanded or aliased indices are ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, missing or closed indices are not included in the response."
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead."
        })),
        index: z.optional(types_indices),
        max_concurrent_searches: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of concurrent searches the multi search API can execute.\nDefaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`."
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of concurrent shard requests that each sub-search request executes per node."
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: "Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint."
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object."
        })),
        routing: z.optional(types_routing),
        search_type: z.optional(types_search_type),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specifies whether aggregation and suggester names should be prefixed by their respective types in the response."
        }))
    }))
});

export const msearch_response = global_msearch_multi_search_result;

export const msearch1_request = z.object({
    body: msearch,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, concrete, expanded or aliased indices are ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, missing or closed indices are not included in the response."
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead."
        })),
        index: z.optional(types_indices),
        max_concurrent_searches: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of concurrent searches the multi search API can execute.\nDefaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`."
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of concurrent shard requests that each sub-search request executes per node."
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: "Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint."
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object."
        })),
        routing: z.optional(types_routing),
        search_type: z.optional(types_search_type),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specifies whether aggregation and suggester names should be prefixed by their respective types in the response."
        }))
    }))
});

export const msearch1_response = global_msearch_multi_search_result;

export const msearch2_request = z.object({
    body: msearch,
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, concrete, expanded or aliased indices are ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, missing or closed indices are not included in the response."
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead."
        })),
        index: z.optional(types_indices),
        max_concurrent_searches: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of concurrent searches the multi search API can execute.\nDefaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`."
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of concurrent shard requests that each sub-search request executes per node."
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: "Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint."
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object."
        })),
        routing: z.optional(types_routing),
        search_type: z.optional(types_search_type),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specifies whether aggregation and suggester names should be prefixed by their respective types in the response."
        }))
    }))
});

export const msearch2_response = global_msearch_multi_search_result;

export const msearch3_request = z.object({
    body: msearch,
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, concrete, expanded or aliased indices are ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, missing or closed indices are not included in the response."
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead."
        })),
        index: z.optional(types_indices),
        max_concurrent_searches: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of concurrent searches the multi search API can execute.\nDefaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`."
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of concurrent shard requests that each sub-search request executes per node."
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: "Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint."
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object."
        })),
        routing: z.optional(types_routing),
        search_type: z.optional(types_search_type),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Specifies whether aggregation and suggester names should be prefixed by their respective types in the response."
        }))
    }))
});

export const msearch3_response = global_msearch_multi_search_result;

export const msearch_template_request = z.object({
    body: msearch_template,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips are minimized for cross-cluster search requests."
        })),
        max_concurrent_searches: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of concurrent searches the API can run."
        })),
        search_type: z.optional(types_search_type),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response prefixes aggregation and suggester names with their respective types."
        }))
    }))
});

export const msearch_template_response = global_msearch_multi_search_result;

export const msearch_template1_request = z.object({
    body: msearch_template,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips are minimized for cross-cluster search requests."
        })),
        max_concurrent_searches: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of concurrent searches the API can run."
        })),
        search_type: z.optional(types_search_type),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response prefixes aggregation and suggester names with their respective types."
        }))
    }))
});

export const msearch_template1_response = global_msearch_multi_search_result;

export const msearch_template2_request = z.object({
    body: msearch_template,
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips are minimized for cross-cluster search requests."
        })),
        max_concurrent_searches: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of concurrent searches the API can run."
        })),
        search_type: z.optional(types_search_type),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response prefixes aggregation and suggester names with their respective types."
        }))
    }))
});

export const msearch_template2_response = global_msearch_multi_search_result;

export const msearch_template3_request = z.object({
    body: msearch_template,
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips are minimized for cross-cluster search requests."
        })),
        max_concurrent_searches: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of concurrent searches the API can run."
        })),
        search_type: z.optional(types_search_type),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response prefixes aggregation and suggester names with their respective types."
        }))
    }))
});

export const msearch_template3_response = global_msearch_multi_search_result;

export const open_point_in_time_request = z.object({
    body: z.optional(z.object({
        index_filter: z.optional(types_query_dsl_query_container)
    })),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        keep_alive: types_duration,
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nBy default, it is random."
        })),
        routing: z.optional(types_routing),
        expand_wildcards: z.optional(types_expand_wildcards),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether the point in time tolerates unavailable shards or shard failures when initially creating the PIT.\nIf `false`, creating a point in time request when a shard is missing or unavailable will throw an exception.\nIf `true`, the point in time will contain all the shards that are available at the time of the request."
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of concurrent shard requests that each sub-search request executes per node."
        }))
    })
});

export const open_point_in_time_response = z.object({
    _shards: types_shard_statistics,
    id: types_id
});

export const rank_eval_request = z.object({
    body: rank_eval,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, missing or closed indices are not included in the response."
        })),
        search_type: z.optional(z.string().register(z.globalRegistry, {
            description: "Search operation type"
        }))
    }))
});

export const rank_eval_response = z.object({
    metric_score: z.number().register(z.globalRegistry, {
        description: "The overall evaluation quality calculated by the defined metric"
    }),
    details: z.record(z.string(), global_rank_eval_rank_eval_metric_detail).register(z.globalRegistry, {
        description: "The details section contains one entry for every query in the original requests section, keyed by the search request id"
    }),
    failures: z.record(z.string(), z.record(z.string(), z.unknown()))
});

export const rank_eval1_request = z.object({
    body: rank_eval,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, missing or closed indices are not included in the response."
        })),
        search_type: z.optional(z.string().register(z.globalRegistry, {
            description: "Search operation type"
        }))
    }))
});

export const rank_eval1_response = z.object({
    metric_score: z.number().register(z.globalRegistry, {
        description: "The overall evaluation quality calculated by the defined metric"
    }),
    details: z.record(z.string(), global_rank_eval_rank_eval_metric_detail).register(z.globalRegistry, {
        description: "The details section contains one entry for every query in the original requests section, keyed by the search request id"
    }),
    failures: z.record(z.string(), z.record(z.string(), z.unknown()))
});

export const rank_eval2_request = z.object({
    body: rank_eval,
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, missing or closed indices are not included in the response."
        })),
        search_type: z.optional(z.string().register(z.globalRegistry, {
            description: "Search operation type"
        }))
    }))
});

export const rank_eval2_response = z.object({
    metric_score: z.number().register(z.globalRegistry, {
        description: "The overall evaluation quality calculated by the defined metric"
    }),
    details: z.record(z.string(), global_rank_eval_rank_eval_metric_detail).register(z.globalRegistry, {
        description: "The details section contains one entry for every query in the original requests section, keyed by the search request id"
    }),
    failures: z.record(z.string(), z.record(z.string(), z.unknown()))
});

export const rank_eval3_request = z.object({
    body: rank_eval,
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, missing or closed indices are not included in the response."
        })),
        search_type: z.optional(z.string().register(z.globalRegistry, {
            description: "Search operation type"
        }))
    }))
});

export const rank_eval3_response = z.object({
    metric_score: z.number().register(z.globalRegistry, {
        description: "The overall evaluation quality calculated by the defined metric"
    }),
    details: z.record(z.string(), global_rank_eval_rank_eval_metric_detail).register(z.globalRegistry, {
        description: "The details section contains one entry for every query in the original requests section, keyed by the search request id"
    }),
    failures: z.record(z.string(), z.record(z.string(), z.unknown()))
});

export const render_search_template_request = z.object({
    body: render_search_template,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const render_search_template_response = z.object({
    template_output: z.record(z.string(), z.record(z.string(), z.unknown()))
});

export const render_search_template1_request = z.object({
    body: render_search_template,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const render_search_template1_response = z.object({
    template_output: z.record(z.string(), z.record(z.string(), z.unknown()))
});

export const render_search_template2_request = z.object({
    body: render_search_template,
    path: z.object({
        id: types_id
    }),
    query: z.optional(z.never())
});

export const render_search_template2_response = z.object({
    template_output: z.record(z.string(), z.record(z.string(), z.unknown()))
});

export const render_search_template3_request = z.object({
    body: render_search_template,
    path: z.object({
        id: types_id
    }),
    query: z.optional(z.never())
});

export const render_search_template3_response = z.object({
    template_output: z.record(z.string(), z.record(z.string(), z.unknown()))
});

export const search_request = z.object({
    body: z.optional(search),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`."
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        batched_reduce_size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        docvalue_fields: z.optional(types_fields),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns detailed information about score computation as part of a hit."
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, concrete, expanded or aliased indices will be ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead."
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order."
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: "A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field."
        })),
        request_cache: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings."
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: "Specific `tag` of the request for logging and statistical purposes."
        })),
        stored_fields: z.optional(types_fields),
        suggest_field: z.optional(types_field),
        suggest_mode: z.optional(types_suggest_mode),
        suggest_size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified."
        })),
        suggest_text: z.optional(z.string().register(z.globalRegistry, {
            description: "The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified."
        })),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early."
        })),
        timeout: z.optional(types_duration),
        track_total_hits: z.optional(global_search_types_track_hits),
        track_scores: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request calculates and returns document scores, even if the scores are not used for sorting."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, aggregation and suggester names are be prefixed by their respective types in the response."
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response."
        })),
        version: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns the document version as part of a hit."
        })),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_exclude_vectors: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether vectors should be excluded from _source"
        })),
        _source_includes: z.optional(types_fields),
        seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns the sequence number and primary term of the last modification of each hit."
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned."
        })),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
        })),
        from: z.optional(z.number().register(z.globalRegistry, {
            description: "The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
        })),
        sort: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ]))
    }))
});

export const search_response = global_search_response_body;

export const search1_request = z.object({
    body: z.optional(search),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`."
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        batched_reduce_size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        docvalue_fields: z.optional(types_fields),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns detailed information about score computation as part of a hit."
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, concrete, expanded or aliased indices will be ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead."
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order."
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: "A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field."
        })),
        request_cache: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings."
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: "Specific `tag` of the request for logging and statistical purposes."
        })),
        stored_fields: z.optional(types_fields),
        suggest_field: z.optional(types_field),
        suggest_mode: z.optional(types_suggest_mode),
        suggest_size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified."
        })),
        suggest_text: z.optional(z.string().register(z.globalRegistry, {
            description: "The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified."
        })),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early."
        })),
        timeout: z.optional(types_duration),
        track_total_hits: z.optional(global_search_types_track_hits),
        track_scores: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request calculates and returns document scores, even if the scores are not used for sorting."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, aggregation and suggester names are be prefixed by their respective types in the response."
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response."
        })),
        version: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns the document version as part of a hit."
        })),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_exclude_vectors: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether vectors should be excluded from _source"
        })),
        _source_includes: z.optional(types_fields),
        seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns the sequence number and primary term of the last modification of each hit."
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned."
        })),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
        })),
        from: z.optional(z.number().register(z.globalRegistry, {
            description: "The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
        })),
        sort: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ]))
    }))
});

export const search1_response = global_search_response_body;

export const search2_request = z.object({
    body: z.optional(search),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`."
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        batched_reduce_size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        docvalue_fields: z.optional(types_fields),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns detailed information about score computation as part of a hit."
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, concrete, expanded or aliased indices will be ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead."
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order."
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: "A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field."
        })),
        request_cache: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings."
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: "Specific `tag` of the request for logging and statistical purposes."
        })),
        stored_fields: z.optional(types_fields),
        suggest_field: z.optional(types_field),
        suggest_mode: z.optional(types_suggest_mode),
        suggest_size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified."
        })),
        suggest_text: z.optional(z.string().register(z.globalRegistry, {
            description: "The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified."
        })),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early."
        })),
        timeout: z.optional(types_duration),
        track_total_hits: z.optional(global_search_types_track_hits),
        track_scores: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request calculates and returns document scores, even if the scores are not used for sorting."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, aggregation and suggester names are be prefixed by their respective types in the response."
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response."
        })),
        version: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns the document version as part of a hit."
        })),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_exclude_vectors: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether vectors should be excluded from _source"
        })),
        _source_includes: z.optional(types_fields),
        seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns the sequence number and primary term of the last modification of each hit."
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned."
        })),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
        })),
        from: z.optional(z.number().register(z.globalRegistry, {
            description: "The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
        })),
        sort: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ]))
    }))
});

export const search2_response = global_search_response_body;

export const search3_request = z.object({
    body: z.optional(search),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`."
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        batched_reduce_size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests."
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        docvalue_fields: z.optional(types_fields),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns detailed information about score computation as part of a hit."
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, concrete, expanded or aliased indices will be ignored when frozen."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead."
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified."
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order."
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: "A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field."
        })),
        request_cache: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings."
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: "Specific `tag` of the request for logging and statistical purposes."
        })),
        stored_fields: z.optional(types_fields),
        suggest_field: z.optional(types_field),
        suggest_mode: z.optional(types_suggest_mode),
        suggest_size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified."
        })),
        suggest_text: z.optional(z.string().register(z.globalRegistry, {
            description: "The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified."
        })),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early."
        })),
        timeout: z.optional(types_duration),
        track_total_hits: z.optional(global_search_types_track_hits),
        track_scores: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request calculates and returns document scores, even if the scores are not used for sorting."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, aggregation and suggester names are be prefixed by their respective types in the response."
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response."
        })),
        version: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns the document version as part of a hit."
        })),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_exclude_vectors: z.optional(z.boolean().register(z.globalRegistry, {
            description: "Whether vectors should be excluded from _source"
        })),
        _source_includes: z.optional(types_fields),
        seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request returns the sequence number and primary term of the last modification of each hit."
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: "A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned."
        })),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: "The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
        })),
        from: z.optional(z.number().register(z.globalRegistry, {
            description: "The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter."
        })),
        sort: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ]))
    }))
});

export const search3_response = global_search_response_body;

export const search_mvt1_request = z.object({
    body: z.optional(search_mvt),
    path: z.object({
        index: types_indices,
        field: types_field,
        zoom: global_search_mvt_types_zoom_level,
        x: global_search_mvt_types_coordinate,
        y: global_search_mvt_types_coordinate
    }),
    query: z.optional(z.object({
        exact_bounds: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the meta layer's feature is the bounding box of the tile.\nIf true, the meta layer's feature is a bounding box resulting from a\ngeo_bounds aggregation. The aggregation runs on <field> values that intersect\nthe <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting\nbounding box may be larger than the vector tile."
        })),
        extent: z.optional(z.number().register(z.globalRegistry, {
            description: "The size, in pixels, of a side of the tile. Vector tiles are square with equal sides."
        })),
        grid_agg: z.optional(global_search_mvt_types_grid_aggregation_type),
        grid_precision: z.optional(z.number().register(z.globalRegistry, {
            description: "Additional zoom levels available through the aggs layer. For example, if <zoom> is 7\nand grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndon't include the aggs layer."
        })),
        grid_type: z.optional(global_search_mvt_types_grid_type),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results don't include the hits layer."
        })),
        track_total_hits: z.optional(global_search_types_track_hits),
        with_labels: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.\n\n* `Point` and `MultiPoint` features will have one of the points selected.\n* `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.\n* `LineString` features will likewise provide a roughly central point selected from the triangle-tree.\n* The aggregation results will provide one central point for each aggregation bucket.\n\nAll attributes from the original features will also be copied to the new label features.\nIn addition, the new features will be distinguishable using the tag `_mvt_label_position`."
        }))
    }))
});

export const search_mvt1_response = types_mapbox_vector_tiles;

export const search_mvt_request = z.object({
    body: z.optional(search_mvt),
    path: z.object({
        index: types_indices,
        field: types_field,
        zoom: global_search_mvt_types_zoom_level,
        x: global_search_mvt_types_coordinate,
        y: global_search_mvt_types_coordinate
    }),
    query: z.optional(z.object({
        exact_bounds: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the meta layer's feature is the bounding box of the tile.\nIf true, the meta layer's feature is a bounding box resulting from a\ngeo_bounds aggregation. The aggregation runs on <field> values that intersect\nthe <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting\nbounding box may be larger than the vector tile."
        })),
        extent: z.optional(z.number().register(z.globalRegistry, {
            description: "The size, in pixels, of a side of the tile. Vector tiles are square with equal sides."
        })),
        grid_agg: z.optional(global_search_mvt_types_grid_aggregation_type),
        grid_precision: z.optional(z.number().register(z.globalRegistry, {
            description: "Additional zoom levels available through the aggs layer. For example, if <zoom> is 7\nand grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndon't include the aggs layer."
        })),
        grid_type: z.optional(global_search_mvt_types_grid_type),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: "Maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results don't include the hits layer."
        })),
        track_total_hits: z.optional(global_search_types_track_hits),
        with_labels: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.\n\n* `Point` and `MultiPoint` features will have one of the points selected.\n* `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.\n* `LineString` features will likewise provide a roughly central point selected from the triangle-tree.\n* The aggregation results will provide one central point for each aggregation bucket.\n\nAll attributes from the original features will also be copied to the new label features.\nIn addition, the new features will be distinguishable using the tag `_mvt_label_position`."
        }))
    }))
});

export const search_mvt_response = types_mapbox_vector_tiles;

export const search_shards_request = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        local: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request retrieves information from the local node only."
        })),
        master_timeout: z.optional(types_duration),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nIt is random by default."
        })),
        routing: z.optional(types_routing)
    }))
});

export const search_shards_response = z.object({
    nodes: z.record(z.string(), global_search_shards_search_shards_node_attributes),
    shards: z.array(z.array(types_node_shard)),
    indices: z.record(z.string(), global_search_shards_shard_store_index)
});

export const search_shards1_request = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        local: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request retrieves information from the local node only."
        })),
        master_timeout: z.optional(types_duration),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nIt is random by default."
        })),
        routing: z.optional(types_routing)
    }))
});

export const search_shards1_response = z.object({
    nodes: z.record(z.string(), global_search_shards_search_shards_node_attributes),
    shards: z.array(z.array(types_node_shard)),
    indices: z.record(z.string(), global_search_shards_shard_store_index)
});

export const search_shards2_request = z.object({
    body: z.optional(z.never()),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        local: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request retrieves information from the local node only."
        })),
        master_timeout: z.optional(types_duration),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nIt is random by default."
        })),
        routing: z.optional(types_routing)
    }))
});

export const search_shards2_response = z.object({
    nodes: z.record(z.string(), global_search_shards_search_shards_node_attributes),
    shards: z.array(z.array(types_node_shard)),
    indices: z.record(z.string(), global_search_shards_shard_store_index)
});

export const search_shards3_request = z.object({
    body: z.optional(z.never()),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        local: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the request retrieves information from the local node only."
        })),
        master_timeout: z.optional(types_duration),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nIt is random by default."
        })),
        routing: z.optional(types_routing)
    }))
});

export const search_shards3_response = z.object({
    nodes: z.record(z.string(), global_search_shards_search_shards_node_attributes),
    shards: z.array(z.array(types_node_shard)),
    indices: z.record(z.string(), global_search_shards_shard_store_index)
});

export const search_template_request = z.object({
    body: search_template,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips are minimized for cross-cluster search requests."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response includes additional details about score computation as part of a hit."
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nIt is random by default."
        })),
        profile: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the query execution is profiled."
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response prefixes aggregation and suggester names with their respective types."
        }))
    }))
});

export const search_template_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregate)),
    _clusters: z.optional(types_cluster_statistics),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    max_score: z.optional(z.number()),
    num_reduce_phases: z.optional(z.number()),
    profile: z.optional(global_search_types_profile),
    pit_id: z.optional(types_id),
    _scroll_id: z.optional(types_scroll_id),
    suggest: z.optional(z.record(z.string(), z.array(global_search_types_suggest))),
    terminated_early: z.optional(z.boolean())
});

export const search_template1_request = z.object({
    body: search_template,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips are minimized for cross-cluster search requests."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response includes additional details about score computation as part of a hit."
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nIt is random by default."
        })),
        profile: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the query execution is profiled."
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response prefixes aggregation and suggester names with their respective types."
        }))
    }))
});

export const search_template1_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregate)),
    _clusters: z.optional(types_cluster_statistics),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    max_score: z.optional(z.number()),
    num_reduce_phases: z.optional(z.number()),
    profile: z.optional(global_search_types_profile),
    pit_id: z.optional(types_id),
    _scroll_id: z.optional(types_scroll_id),
    suggest: z.optional(z.record(z.string(), z.array(global_search_types_suggest))),
    terminated_early: z.optional(z.boolean())
});

export const search_template2_request = z.object({
    body: search_template,
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips are minimized for cross-cluster search requests."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response includes additional details about score computation as part of a hit."
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nIt is random by default."
        })),
        profile: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the query execution is profiled."
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response prefixes aggregation and suggester names with their respective types."
        }))
    }))
});

export const search_template2_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregate)),
    _clusters: z.optional(types_cluster_statistics),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    max_score: z.optional(z.number()),
    num_reduce_phases: z.optional(z.number()),
    profile: z.optional(global_search_types_profile),
    pit_id: z.optional(types_id),
    _scroll_id: z.optional(types_scroll_id),
    suggest: z.optional(z.record(z.string(), z.array(global_search_types_suggest))),
    terminated_early: z.optional(z.boolean())
});

export const search_template3_request = z.object({
    body: search_template,
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`."
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, network round-trips are minimized for cross-cluster search requests."
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response includes additional details about score computation as part of a hit."
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled."
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `false`, the request returns an error if it targets a missing or closed index."
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: "The node or shard the operation should be performed on.\nIt is random by default."
        })),
        profile: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the query execution is profiled."
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object."
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: "If `true`, the response prefixes aggregation and suggester names with their respective types."
        }))
    }))
});

export const search_template3_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregate)),
    _clusters: z.optional(types_cluster_statistics),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    max_score: z.optional(z.number()),
    num_reduce_phases: z.optional(z.number()),
    profile: z.optional(global_search_types_profile),
    pit_id: z.optional(types_id),
    _scroll_id: z.optional(types_scroll_id),
    suggest: z.optional(z.record(z.string(), z.array(global_search_types_suggest))),
    terminated_early: z.optional(z.boolean())
});

export const terms_enum_request = z.object({
    body: terms_enum,
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.never())
});

export const terms_enum_response = z.object({
    _shards: types_shard_statistics,
    terms: z.array(z.string()),
    complete: z.boolean().register(z.globalRegistry, {
        description: "If `false`, the returned terms set may be incomplete and should be treated as approximate.\nThis can occur due to a few reasons, such as a request timeout or a node error."
    })
});

export const terms_enum1_request = z.object({
    body: terms_enum,
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.never())
});

export const terms_enum1_response = z.object({
    _shards: types_shard_statistics,
    terms: z.array(z.string()),
    complete: z.boolean().register(z.globalRegistry, {
        description: "If `false`, the returned terms set may be incomplete and should be treated as approximate.\nThis can occur due to a few reasons, such as a request timeout or a node error."
    })
});
