/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

// This file is auto-generated by @hey-api/openapi-ts

import { z } from '@kbn/zod/v4';

/**
 * Unsuccessful rule API response
 */
export const alerting_401_response = z.object({
  error: z.optional(z.enum(['Unauthorized'])),
  message: z.optional(z.string()),
  statusCode: z.optional(z.literal(401)),
});

/**
 * Field map objects in the get rule types response
 */
export const alerting_fieldmap_properties = z.object({
  array: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the field is an array.',
    })
  ),
  dynamic: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether it is a dynamic field mapping.',
    })
  ),
  format: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Indicates the format of the field. For example, if the `type` is `date_range`, the `format` can be `epoch_millis||strict_date_optional_time`.\n',
    })
  ),
  ignore_above: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Specifies the maximum length of a string field. Longer strings are not indexed or stored.',
    })
  ),
  index: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether field values are indexed.',
    })
  ),
  path: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'TBD',
    })
  ),
  properties: z.optional(
    z
      .record(
        z.string(),
        z.object({
          type: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The data type for each object property.',
            })
          ),
        })
      )
      .register(z.globalRegistry, {
        description:
          'Details about the object properties. This property is applicable when `type` is `object`.\n',
      })
  ),
  required: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the field is required.',
    })
  ),
  scaling_factor: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The scaling factor to use when encoding values. This property is applicable when `type` is `scaled_float`. Values will be multiplied by this factor at index time and rounded to the closest long value. \n',
    })
  ),
  type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Specifies the data type for the field.',
    })
  ),
});

export const apm_ui_400_response = z.object({
  error: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error type',
    })
  ),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error message',
    })
  ),
  statusCode: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'Error status code',
    })
  ),
});

export const apm_ui_401_response = z.object({
  error: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error type',
    })
  ),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error message',
    })
  ),
  statusCode: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'Error status code',
    })
  ),
});

export const apm_ui_403_response = z.object({
  error: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error type',
    })
  ),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error message',
    })
  ),
  statusCode: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'Error status code',
    })
  ),
});

export const apm_ui_404_response = z.object({
  error: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error type',
    })
  ),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error message',
    })
  ),
  statusCode: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'Error status code',
    })
  ),
});

export const apm_ui_500_response = z.object({
  error: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error type',
    })
  ),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error message',
    })
  ),
  statusCode: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'Error status code',
    })
  ),
});

export const apm_ui_501_response = z.object({
  error: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error type',
    })
  ),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error message',
    })
  ),
  statusCode: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'Error status code',
    })
  ),
});

export const apm_ui_agent_keys_object = z.object({
  name: z.string().register(z.globalRegistry, {
    description: 'The name of the APM agent key.',
  }),
  privileges: z.array(z.enum(['event:write', 'config_agent:read'])).register(z.globalRegistry, {
    description:
      'The APM agent key privileges. It can take one or more of the following values:\n* `event:write`, which is required for ingesting APM agent events. * `config_agent:read`, which is required for APM agents to read agent configuration remotely.\n',
  }),
});

export const apm_ui_agent_keys_response = z.object({
  agentKey: z.optional(
    z
      .object({
        api_key: z.string(),
        encoded: z.string(),
        expiration: z.optional(z.coerce.bigint()),
        id: z.string(),
        name: z.string(),
      })
      .register(z.globalRegistry, {
        description: 'Agent key',
      })
  ),
});

export const apm_ui_annotation_search_response = z.object({
  annotations: z.optional(
    z
      .array(
        z.object({
          '@timestamp': z.optional(z.number()),
          id: z.optional(z.string()),
          text: z.optional(z.string()),
          type: z.optional(z.enum(['version'])),
        })
      )
      .register(z.globalRegistry, {
        description: 'Annotations',
      })
  ),
});

export const apm_ui_base_source_map_object = z.object({
  compressionAlgorithm: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Compression Algorithm',
    })
  ),
  created: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Created date',
    })
  ),
  decodedSha256: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Decoded SHA-256',
    })
  ),
  decodedSize: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'Decoded size',
    })
  ),
  encodedSha256: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Encoded SHA-256',
    })
  ),
  encodedSize: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'Encoded size',
    })
  ),
  encryptionAlgorithm: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Encryption Algorithm',
    })
  ),
  id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Identifier',
    })
  ),
  identifier: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Identifier',
    })
  ),
  packageName: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Package name',
    })
  ),
  relative_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Relative URL',
    })
  ),
  type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Type',
    })
  ),
});

export const apm_ui_create_annotation_object = z.object({
  '@timestamp': z.string().register(z.globalRegistry, {
    description: 'The date and time of the annotation. It must be in ISO 8601 format.',
  }),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The message displayed in the annotation. It defaults to `service.version`.',
    })
  ),
  service: z
    .object({
      environment: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The environment of the service.',
        })
      ),
      version: z.string().register(z.globalRegistry, {
        description: 'The version of the service.',
      }),
    })
    .register(z.globalRegistry, {
      description: 'The service that identifies the configuration to create or update.',
    }),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'Tags are used by the Applications UI to distinguish APM annotations from other annotations. Tags may have additional functionality in future releases. It defaults to `[apm]`. While you can add additional tags, you cannot remove the `apm` tag.\n',
    })
  ),
});

export const apm_ui_create_annotation_response = z.object({
  _id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Identifier',
    })
  ),
  _index: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Index',
    })
  ),
  _source: z.optional(
    z
      .object({
        '@timestamp': z.optional(z.string()),
        annotation: z.optional(
          z.object({
            title: z.optional(z.string()),
            type: z.optional(z.string()),
          })
        ),
        event: z.optional(
          z.object({
            created: z.optional(z.string()),
          })
        ),
        message: z.optional(z.string()),
        service: z.optional(
          z.object({
            environment: z.optional(z.string()),
            name: z.optional(z.string()),
            version: z.optional(z.string()),
          })
        ),
        tags: z.optional(z.array(z.string())),
      })
      .register(z.globalRegistry, {
        description: 'Response',
      })
  ),
});

export const apm_ui_delete_agent_configurations_response = z.object({
  result: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Result',
    })
  ),
});

export const apm_ui_service_agent_name_response = z.object({
  agentName: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Agent name',
    })
  ),
});

export const apm_ui_service_environment_object = z.object({
  alreadyConfigured: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Already configured',
    })
  ),
  name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Service environment name',
    })
  ),
});

export const apm_ui_service_environments_response = z.object({
  environments: z.optional(
    z.array(apm_ui_service_environment_object).register(z.globalRegistry, {
      description: 'Service environment list',
    })
  ),
});

/**
 * Service
 */
export const apm_ui_service_object = z
  .object({
    environment: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The environment of the service.',
      })
    ),
    name: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The name of the service.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Service',
  });

/**
 * Service
 */
export const apm_ui_delete_service_object = z
  .object({
    service: apm_ui_service_object,
  })
  .register(z.globalRegistry, {
    description: 'Service',
  });

export const apm_ui_search_agent_configuration_object = z.object({
  etag: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'If etags match then `applied_by_agent` field will be set to `true`',
    })
  ),
  mark_as_applied_by_agent: z.optional(
    z.boolean().register(z.globalRegistry, {
      description:
        '`markAsAppliedByAgent=true` means "force setting it to true regardless of etag".\nThis is needed for Jaeger agent that doesn\'t have etags\n',
    })
  ),
  service: apm_ui_service_object,
});

/**
 * Agent configuration settings
 */
export const apm_ui_settings_object = z.record(z.string(), z.string()).register(z.globalRegistry, {
  description: 'Agent configuration settings',
});

export const apm_ui_agent_configuration_intake_object = z.object({
  agent_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The agent name is used by the UI to determine which settings to display.',
    })
  ),
  service: apm_ui_service_object,
  settings: apm_ui_settings_object,
});

/**
 * Agent configuration
 */
export const apm_ui_agent_configuration_object = z
  .object({
    '@timestamp': z.number().register(z.globalRegistry, {
      description: 'Timestamp',
    }),
    agent_name: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Agent name',
      })
    ),
    applied_by_agent: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Applied by agent',
      })
    ),
    etag: z.string().register(z.globalRegistry, {
      description:
        '`etag` is sent by the APM agent to indicate the `etag` of the last successfully applied configuration. If the `etag` matches an existing configuration its `applied_by_agent` property will be set to `true`. Every time a configuration is edited `applied_by_agent` is reset to `false`.\n',
    }),
    service: apm_ui_service_object,
    settings: apm_ui_settings_object,
  })
  .register(z.globalRegistry, {
    description: 'Agent configuration',
  });

export const apm_ui_agent_configurations_response = z.object({
  configurations: z.optional(
    z.array(apm_ui_agent_configuration_object).register(z.globalRegistry, {
      description: 'Agent configuration',
    })
  ),
});

export const apm_ui_search_agent_configuration_response = z.object({
  _id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Identifier',
    })
  ),
  _index: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Index',
    })
  ),
  _score: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'Score',
    })
  ),
  _source: z.optional(apm_ui_agent_configuration_object),
});

export const apm_ui_single_agent_configuration_response = z
  .object({
    id: z.string(),
  })
  .and(apm_ui_agent_configuration_object);

export const apm_ui_source_maps_response = z.object({
  artifacts: z.optional(
    z
      .array(
        z
          .object({
            body: z.optional(
              z.object({
                bundleFilepath: z.optional(z.string()),
                serviceName: z.optional(z.string()),
                serviceVersion: z.optional(z.string()),
                sourceMap: z.optional(
                  z.object({
                    file: z.optional(z.string()),
                    mappings: z.optional(z.string()),
                    sourceRoot: z.optional(z.string()),
                    sources: z.optional(z.array(z.string())),
                    sourcesContent: z.optional(z.array(z.string())),
                    version: z.optional(z.number()),
                  })
                ),
              })
            ),
          })
          .and(apm_ui_base_source_map_object)
      )
      .register(z.globalRegistry, {
        description: 'Artifacts',
      })
  ),
});

export const apm_ui_upload_source_map_object = z.object({
  bundle_filepath: z.string().register(z.globalRegistry, {
    description: 'The absolute path of the final bundle as used in the web application.',
  }),
  service_name: z.string().register(z.globalRegistry, {
    description: 'The name of the service that the service map should apply to.',
  }),
  service_version: z.string().register(z.globalRegistry, {
    description: 'The version of the service that the service map should apply to.',
  }),
  sourcemap: z.string().register(z.globalRegistry, {
    description:
      'The source map. It can be a string or file upload. It must follow the\n[source map format specification](https://tc39.es/ecma426/).\n',
  }),
});

export const apm_ui_upload_source_maps_response = z
  .object({
    body: z.optional(z.string()),
  })
  .and(apm_ui_base_source_map_object);

/**
 * Unsuccessful cases API response
 */
export const cases_4xx_response = z.object({
  error: z.optional(z.string()),
  message: z.optional(z.string()),
  statusCode: z.optional(z.int()),
});

export const cases_actions = z.enum(['add', 'create', 'delete', 'push_to_service', 'update']);

/**
 * Add case file request properties
 *
 * Defines the file that will be attached to the case. Optional parameters will be generated automatically from the file metadata if not defined.
 */
export const cases_add_case_file_request = z
  .object({
    file: z.string().register(z.globalRegistry, {
      description: 'The file being attached to the case.',
    }),
    filename: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The desired name of the file being attached to the case, it can be different than the name of the file in the filesystem. **This should not include the file extension.**',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'Defines the file that will be attached to the case. Optional parameters will be generated automatically from the file metadata if not defined.',
  });

/**
 * Alert identifiers
 *
 * The alert identifiers. It is required only when `type` is `alert`. You can use an array of strings to add multiple alerts to a case, provided that they all relate to the same rule; `index` must also be an array with the same length or number of elements. Adding multiple alerts in this manner is recommended rather than calling the API multiple times. This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.
 *
 */
export const cases_alert_identifiers = z.union([z.string(), z.array(z.string()).max(1000)]);

/**
 * Alert indices
 *
 * The alert indices. It is required only when `type` is `alert`. If you are adding multiple alerts to a case, use an array of strings; the position of each index name in the array must match the position of the corresponding alert identifier in the `alertId` array.  This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.
 *
 */
export const cases_alert_indices = z.union([z.string(), z.array(z.string()).max(1000)]);

export const cases_alert_response_properties = z.object({
  attached_at: z.optional(z.iso.datetime()),
  id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The alert identifier.',
    })
  ),
  index: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The alert index.',
    })
  ),
});

/**
 * An array containing users that are assigned to the case.
 */
export const cases_assignees = z.union([
  z
    .array(
      z.object({
        uid: z.string().register(z.globalRegistry, {
          description:
            'A unique identifier for the user profile. These identifiers can be found by using the suggest user profile API.',
        }),
      })
    )
    .max(10),
  z.null(),
]);

/**
 * A word or phrase that categorizes the case.
 */
export const cases_case_category = z.string().max(50).register(z.globalRegistry, {
  description: 'A word or phrase that categorizes the case.',
});

export const cases_case_categories = z.array(cases_case_category).max(100);

/**
 * The description for the case.
 */
export const cases_case_description = z.string().max(30000).register(z.globalRegistry, {
  description: 'The description for the case.',
});

/**
 * Case response properties for closed_by
 */
export const cases_case_response_closed_by_properties = z.union([
  z.object({
    email: z.union([z.string(), z.null()]),
    full_name: z.union([z.string(), z.null()]),
    profile_uid: z.optional(z.string()),
    username: z.union([z.string(), z.null()]),
  }),
  z.null(),
]);

/**
 * Case response properties for created_by
 */
export const cases_case_response_created_by_properties = z.object({
  email: z.union([z.string(), z.null()]),
  full_name: z.union([z.string(), z.null()]),
  profile_uid: z.optional(z.string()),
  username: z.union([z.string(), z.null()]),
});

/**
 * Case response properties for pushed_by
 */
export const cases_case_response_pushed_by_properties = z.union([
  z.object({
    email: z.union([z.string(), z.null()]),
    full_name: z.union([z.string(), z.null()]),
    profile_uid: z.optional(z.string()),
    username: z.union([z.string(), z.null()]),
  }),
  z.null(),
]);

/**
 * Case response properties for updated_by
 */
export const cases_case_response_updated_by_properties = z.union([
  z.object({
    email: z.union([z.string(), z.null()]),
    full_name: z.union([z.string(), z.null()]),
    profile_uid: z.optional(z.string()),
    username: z.union([z.string(), z.null()]),
  }),
  z.null(),
]);

/**
 * The severity of the case.
 */
export const cases_case_severity = z
  .enum(['critical', 'high', 'low', 'medium'])
  .register(z.globalRegistry, {
    description: 'The severity of the case.',
  });

/**
 * The status of the case.
 */
export const cases_case_status = z
  .enum(['closed', 'in-progress', 'open'])
  .register(z.globalRegistry, {
    description: 'The status of the case.',
  });

/**
 * The words and phrases that help categorize cases. It can be an empty array.
 *
 */
export const cases_case_tags = z.array(z.string().max(256)).max(200).register(z.globalRegistry, {
  description: 'The words and phrases that help categorize cases. It can be an empty array.\n',
});

/**
 * A title for the case.
 */
export const cases_case_title = z.string().max(160).register(z.globalRegistry, {
  description: 'A title for the case.',
});

/**
 * Indicates whether a case is automatically closed when it is pushed to external systems (`close-by-pushing`) or not automatically closed (`close-by-user`).
 */
export const cases_closure_types = z
  .enum(['close-by-pushing', 'close-by-user'])
  .register(z.globalRegistry, {
    description:
      'Indicates whether a case is automatically closed when it is pushed to external systems (`close-by-pushing`) or not automatically closed (`close-by-user`).',
  });

/**
 * Create or upate case request properties for Cases Webhook connector
 *
 * Defines properties for connectors when type is `.cases-webhook`.
 */
export const cases_connector_properties_cases_webhook = z
  .object({
    fields: z.union([z.string(), z.null()]),
    id: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the connector. To retrieve connector IDs, use the find connectors API.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: 'The name of the connector.',
    }),
    type: z.enum(['.cases-webhook']).register(z.globalRegistry, {
      description: 'The type of connector.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.cases-webhook`.',
  });

/**
 * Create or update case request properties for a Jira connector
 *
 * Defines properties for connectors when type is `.jira`.
 */
export const cases_connector_properties_jira = z
  .object({
    fields: z
      .object({
        issueType: z.union([z.string(), z.null()]),
        parent: z.union([z.string(), z.null()]),
        priority: z.union([z.string(), z.null()]),
      })
      .register(z.globalRegistry, {
        description:
          'An object containing the connector fields. If you want to omit any individual field, specify null as its value.',
      }),
    id: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the connector. To retrieve connector IDs, use the find connectors API.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: 'The name of the connector.',
    }),
    type: z.enum(['.jira']).register(z.globalRegistry, {
      description: 'The type of connector.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.jira`.',
  });

/**
 * Create or update case request properties for no connector
 *
 * Defines properties for connectors when type is `.none`.
 */
export const cases_connector_properties_none = z
  .object({
    fields: z.union([z.string(), z.null()]),
    id: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the connector. To create a case without a connector, use `none`. To update a case to remove the connector, specify `none`.',
    }),
    name: z.string().register(z.globalRegistry, {
      description:
        'The name of the connector. To create a case without a connector, use `none`. To update a case to remove the connector, specify `none`.',
    }),
    type: z.enum(['.none']).register(z.globalRegistry, {
      description:
        'The type of connector. To create a case without a connector, use `.none`. To update a case to remove the connector, specify `.none`.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.none`.',
  });

/**
 * Create case request properties for a IBM Resilient connector
 *
 * Defines properties for connectors when type is `.resilient`.
 */
export const cases_connector_properties_resilient = z
  .object({
    fields: z.union([
      z.object({
        issueTypes: z.array(z.string()).register(z.globalRegistry, {
          description: 'The type of incident.',
        }),
        severityCode: z.string().register(z.globalRegistry, {
          description: 'The severity code of the incident.',
        }),
      }),
      z.null(),
    ]),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the connector.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: 'The name of the connector.',
    }),
    type: z.enum(['.resilient']).register(z.globalRegistry, {
      description: 'The type of connector.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.resilient`.',
  });

/**
 * Create case request properties for a ServiceNow ITSM connector
 *
 * Defines properties for connectors when type is `.servicenow`.
 */
export const cases_connector_properties_servicenow = z
  .object({
    fields: z
      .object({
        category: z.union([z.string(), z.null()]),
        impact: z.union([z.string(), z.null()]),
        severity: z.union([z.string(), z.null()]),
        subcategory: z.union([z.string(), z.null()]),
        urgency: z.union([z.string(), z.null()]),
      })
      .register(z.globalRegistry, {
        description:
          'An object containing the connector fields. If you want to omit any individual field, specify null as its value.',
      }),
    id: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the connector. To retrieve connector IDs, use the find connectors API.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: 'The name of the connector.',
    }),
    type: z.enum(['.servicenow']).register(z.globalRegistry, {
      description: 'The type of connector.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.servicenow`.',
  });

/**
 * Create case request properties for a ServiceNow SecOps connector
 *
 * Defines properties for connectors when type is `.servicenow-sir`.
 */
export const cases_connector_properties_servicenow_sir = z
  .object({
    fields: z
      .object({
        category: z.union([z.string(), z.null()]),
        destIp: z.union([z.boolean(), z.null()]),
        malwareHash: z.union([z.boolean(), z.null()]),
        malwareUrl: z.union([z.boolean(), z.null()]),
        priority: z.union([z.string(), z.null()]),
        sourceIp: z.union([z.boolean(), z.null()]),
        subcategory: z.union([z.string(), z.null()]),
      })
      .register(z.globalRegistry, {
        description:
          'An object containing the connector fields. If you want to omit any individual field, specify null as its value.',
      }),
    id: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the connector. To retrieve connector IDs, use the find connectors API.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: 'The name of the connector.',
    }),
    type: z.enum(['.servicenow-sir']).register(z.globalRegistry, {
      description: 'The type of connector.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.servicenow-sir`.',
  });

/**
 * Create case request properties for a Swimlane connector
 *
 * Defines properties for connectors when type is `.swimlane`.
 */
export const cases_connector_properties_swimlane = z
  .object({
    fields: z
      .object({
        caseId: z.union([z.string(), z.null()]),
      })
      .register(z.globalRegistry, {
        description:
          'An object containing the connector fields. If you want to omit any individual field, specify null as its value.',
      }),
    id: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the connector. To retrieve connector IDs, use the find connectors API.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: 'The name of the connector.',
    }),
    type: z.enum(['.swimlane']).register(z.globalRegistry, {
      description: 'The type of connector.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.swimlane`.',
  });

/**
 * The type of connector.
 */
export const cases_connector_types = z
  .enum([
    '.cases-webhook',
    '.jira',
    '.none',
    '.resilient',
    '.servicenow',
    '.servicenow-sir',
    '.swimlane',
  ])
  .register(z.globalRegistry, {
    description: 'The type of connector.',
  });

export const cases_external_service = z.union([
  z.object({
    connector_id: z.optional(z.string()),
    connector_name: z.optional(z.string()),
    external_id: z.optional(z.string()),
    external_title: z.optional(z.string()),
    external_url: z.optional(z.string()),
    pushed_at: z.optional(z.iso.datetime()),
    pushed_by: z.optional(
      z.union([
        z.object({
          email: z.optional(z.union([z.string(), z.null()])),
          full_name: z.optional(z.union([z.string(), z.null()])),
          profile_uid: z.optional(z.string()),
          username: z.optional(z.union([z.string(), z.null()])),
        }),
        z.null(),
      ])
    ),
  }),
  z.null(),
]);

/**
 * The application that owns the cases: Stack Management, Observability, or Elastic Security.
 *
 */
export const cases_owner = z
  .enum(['cases', 'observability', 'securitySolution'])
  .register(z.globalRegistry, {
    description:
      'The application that owns the cases: Stack Management, Observability, or Elastic Security.\n',
  });

/**
 * Add case comment request properties for user comments
 *
 * Defines properties for case comment requests when type is user.
 */
export const cases_add_user_comment_request_properties = z
  .object({
    comment: z.string().max(30000).register(z.globalRegistry, {
      description: 'The new comment. It is required only when `type` is `user`.',
    }),
    owner: cases_owner,
    type: z.enum(['user']).register(z.globalRegistry, {
      description: 'The type of comment.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for case comment requests when type is user.',
  });

/**
 * Add case comment response properties for alerts
 */
export const cases_alert_comment_response_properties = z.object({
  alertId: z.optional(z.array(z.string())),
  created_at: z.optional(z.iso.datetime()),
  created_by: z.optional(
    z.object({
      email: z.union([z.string(), z.null()]),
      full_name: z.union([z.string(), z.null()]),
      profile_uid: z.optional(z.string()),
      username: z.union([z.string(), z.null()]),
    })
  ),
  id: z.optional(z.string()),
  index: z.optional(z.array(z.string())),
  owner: z.optional(cases_owner),
  pushed_at: z.optional(z.union([z.iso.datetime(), z.null()])),
  pushed_by: z.optional(
    z.union([
      z.object({
        email: z.union([z.string(), z.null()]),
        full_name: z.union([z.string(), z.null()]),
        profile_uid: z.optional(z.string()),
        username: z.union([z.string(), z.null()]),
      }),
      z.null(),
    ])
  ),
  rule: z.optional(
    z.object({
      id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The rule identifier.',
        })
      ),
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The rule name.',
        })
      ),
    })
  ),
  type: z.enum(['alert']),
  updated_at: z.optional(z.union([z.iso.datetime(), z.null()])),
  updated_by: z.optional(
    z.union([
      z.object({
        email: z.union([z.string(), z.null()]),
        full_name: z.union([z.string(), z.null()]),
        profile_uid: z.optional(z.string()),
        username: z.union([z.string(), z.null()]),
      }),
      z.null(),
    ])
  ),
  version: z.optional(z.string()),
});

export const cases_owners = z.array(cases_owner);

export const cases_payload_alert_comment = z.object({
  comment: z.optional(
    z.object({
      alertId: z.optional(z.union([z.string(), z.array(z.string())])),
      index: z.optional(z.union([z.string(), z.array(z.string())])),
      owner: z.optional(cases_owner),
      rule: z.optional(
        z.object({
          id: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The rule identifier.',
            })
          ),
          name: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The rule name.',
            })
          ),
        })
      ),
      type: z.optional(z.enum(['alert'])),
    })
  ),
});

export const cases_payload_assignees = z.object({
  assignees: z.optional(cases_assignees),
});

export const cases_payload_connector = z.object({
  connector: z.optional(
    z.object({
      fields: z.optional(
        z.union([
          z.object({
            caseId: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The case identifier for Swimlane connectors.',
              })
            ),
            category: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The category of the incident for ServiceNow ITSM and ServiceNow SecOps connectors.',
              })
            ),
            destIp: z.optional(z.union([z.boolean(), z.null()])),
            impact: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The effect an incident had on business for ServiceNow ITSM connectors.',
              })
            ),
            issueType: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The type of issue for Jira connectors.',
              })
            ),
            issueTypes: z.optional(
              z.array(z.string()).register(z.globalRegistry, {
                description: 'The type of incident for IBM Resilient connectors.',
              })
            ),
            malwareHash: z.optional(z.union([z.boolean(), z.null()])),
            malwareUrl: z.optional(z.union([z.boolean(), z.null()])),
            parent: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The key of the parent issue, when the issue type is sub-task for Jira connectors.',
              })
            ),
            priority: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The priority of the issue for Jira and ServiceNow SecOps connectors.',
              })
            ),
            severity: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The severity of the incident for ServiceNow ITSM connectors.',
              })
            ),
            severityCode: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The severity code of the incident for IBM Resilient connectors.',
              })
            ),
            sourceIp: z.optional(z.union([z.boolean(), z.null()])),
            subcategory: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The subcategory of the incident for ServiceNow ITSM connectors.',
              })
            ),
            urgency: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The extent to which the incident resolution can be delayed for ServiceNow ITSM connectors.',
              })
            ),
          }),
          z.null(),
        ])
      ),
      id: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The identifier for the connector. To create a case without a connector, use `none`.',
        })
      ),
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The name of the connector. To create a case without a connector, use `none`.',
        })
      ),
      type: z.optional(cases_connector_types),
    })
  ),
});

/**
 * If the `action` is `delete` and the `type` is `delete_case`, the payload is nullable.
 */
export const cases_payload_delete = z.union([z.record(z.string(), z.unknown()), z.null()]);

export const cases_payload_description = z.object({
  description: z.optional(z.string()),
});

export const cases_payload_pushed = z.object({
  externalService: z.optional(cases_external_service),
});

export const cases_payload_severity = z.object({
  severity: z.optional(cases_case_severity),
});

export const cases_payload_status = z.object({
  status: z.optional(cases_case_status),
});

export const cases_payload_tags = z.object({
  tags: z.optional(z.array(z.string())),
});

export const cases_payload_title = z.object({
  title: z.optional(z.string()),
});

export const cases_payload_user_comment = z.object({
  comment: z.optional(
    z.object({
      comment: z.optional(z.string()),
      owner: z.optional(cases_owner),
      type: z.optional(z.enum(['user'])),
    })
  ),
});

/**
 * Alerting rule
 *
 * The rule that is associated with the alerts. It is required only when `type` is `alert`. This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.
 *
 */
export const cases_rule = z
  .object({
    id: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The rule identifier.',
      })
    ),
    name: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The rule name.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'The rule that is associated with the alerts. It is required only when `type` is `alert`. This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.\n',
  });

/**
 * Add case comment request properties for alerts
 *
 * Defines properties for case comment requests when type is alert.
 */
export const cases_add_alert_comment_request_properties = z
  .object({
    alertId: cases_alert_identifiers,
    index: cases_alert_indices,
    owner: cases_owner,
    rule: cases_rule,
    type: z.enum(['alert']).register(z.globalRegistry, {
      description: 'The type of comment.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for case comment requests when type is alert.',
  });

/**
 * Add case comment request
 *
 * The add comment to case API request body varies depending on whether you are adding an alert or a comment.
 */
export const cases_add_case_comment_request = z.union([
  z
    .object({
      type: z.literal('alert'),
    })
    .and(cases_add_alert_comment_request_properties),
  z
    .object({
      type: z.literal('user'),
    })
    .and(cases_add_user_comment_request_properties),
]);

/**
 * The fields to perform the `simple_query_string` parsed query against.
 */
export const cases_search_fields_type = z
  .enum(['description', 'title'])
  .register(z.globalRegistry, {
    description: 'The fields to perform the `simple_query_string` parsed query against.',
  });

export const cases_search_fields_type_array = z.array(cases_search_fields_type);

/**
 * An object that contains the case settings.
 */
export const cases_settings = z
  .object({
    syncAlerts: z.boolean().register(z.globalRegistry, {
      description: 'Turns alert syncing on or off.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'An object that contains the case settings.',
  });

/**
 * Create case request
 *
 * The create case API request body varies depending on the type of connector.
 */
export const cases_create_case_request = z
  .object({
    assignees: z.optional(cases_assignees),
    category: z.optional(cases_case_category),
    connector: z.union([
      cases_connector_properties_none,
      cases_connector_properties_cases_webhook,
      cases_connector_properties_jira,
      cases_connector_properties_resilient,
      cases_connector_properties_servicenow,
      cases_connector_properties_servicenow_sir,
      cases_connector_properties_swimlane,
    ]),
    customFields: z.optional(
      z
        .array(
          z.object({
            key: z.string().register(z.globalRegistry, {
              description:
                'The unique identifier for the custom field. The key value must exist in the case configuration settings.\n',
            }),
            type: z.enum(['text', 'toggle']).register(z.globalRegistry, {
              description:
                'The custom field type. It must match the type specified in the case configuration settings.\n',
            }),
            value: z.union([z.string().min(1).max(160), z.null(), z.boolean()]),
          })
        )
        .min(0)
        .max(10)
        .register(z.globalRegistry, {
          description:
            'Custom field values for a case. Any optional custom fields that are not specified in the request are set to null.\n',
        })
    ),
    description: cases_case_description,
    owner: cases_owner,
    settings: cases_settings,
    severity: z.optional(cases_case_severity),
    tags: cases_case_tags,
    title: cases_case_title,
  })
  .register(z.globalRegistry, {
    description: 'The create case API request body varies depending on the type of connector.',
  });

export const cases_payload_create_case = z.object({
  assignees: z.optional(cases_assignees),
  connector: z.optional(
    z.object({
      fields: z.optional(
        z.union([
          z.object({
            caseId: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The case identifier for Swimlane connectors.',
              })
            ),
            category: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The category of the incident for ServiceNow ITSM and ServiceNow SecOps connectors.',
              })
            ),
            destIp: z.optional(z.union([z.boolean(), z.null()])),
            impact: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The effect an incident had on business for ServiceNow ITSM connectors.',
              })
            ),
            issueType: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The type of issue for Jira connectors.',
              })
            ),
            issueTypes: z.optional(
              z.array(z.string()).register(z.globalRegistry, {
                description: 'The type of incident for IBM Resilient connectors.',
              })
            ),
            malwareHash: z.optional(z.union([z.boolean(), z.null()])),
            malwareUrl: z.optional(z.union([z.boolean(), z.null()])),
            parent: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The key of the parent issue, when the issue type is sub-task for Jira connectors.',
              })
            ),
            priority: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The priority of the issue for Jira and ServiceNow SecOps connectors.',
              })
            ),
            severity: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The severity of the incident for ServiceNow ITSM connectors.',
              })
            ),
            severityCode: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The severity code of the incident for IBM Resilient connectors.',
              })
            ),
            sourceIp: z.optional(z.union([z.boolean(), z.null()])),
            subcategory: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The subcategory of the incident for ServiceNow ITSM connectors.',
              })
            ),
            urgency: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The extent to which the incident resolution can be delayed for ServiceNow ITSM connectors.',
              })
            ),
          }),
          z.null(),
        ])
      ),
      id: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The identifier for the connector. To create a case without a connector, use `none`.',
        })
      ),
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The name of the connector. To create a case without a connector, use `none`.',
        })
      ),
      type: z.optional(cases_connector_types),
    })
  ),
  description: z.optional(z.string()),
  owner: z.optional(cases_owner),
  settings: z.optional(cases_settings),
  severity: z.optional(cases_case_severity),
  status: z.optional(cases_case_status),
  tags: z.optional(z.array(z.string())),
  title: z.optional(z.string()),
});

export const cases_payload_settings = z.object({
  settings: z.optional(cases_settings),
});

export const cases_string = z.string();

export const cases_string_array = z.array(cases_string).max(100);

/**
 * The words and phrases that help categorize templates. It can be an empty array.
 *
 */
export const cases_template_tags = z
  .array(z.string().max(256))
  .max(200)
  .register(z.globalRegistry, {
    description:
      'The words and phrases that help categorize templates. It can be an empty array.\n',
  });

export const cases_templates = z.array(
  z.object({
    caseFields: z.optional(
      z.object({
        assignees: z.optional(cases_assignees),
        category: z.optional(cases_case_category),
        connector: z.optional(
          z.object({
            fields: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
            id: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The identifier for the connector. If you do not want a default connector, use `none`. To retrieve connector IDs, use the find connectors API.',
              })
            ),
            name: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The name of the connector. If you do not want a default connector, use `none`. To retrieve connector names, use the find connectors API.',
              })
            ),
            type: z.optional(cases_connector_types),
          })
        ),
        customFields: z.optional(
          z
            .array(
              z.object({
                key: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'The unique key for the custom field.',
                  })
                ),
                type: z.optional(
                  z.enum(['text', 'toggle']).register(z.globalRegistry, {
                    description: 'The type of the custom field.',
                  })
                ),
                value: z.optional(z.union([z.string(), z.boolean()])),
              })
            )
            .register(z.globalRegistry, {
              description: 'Custom field values in the template.',
            })
        ),
        description: z.optional(cases_case_description),
        settings: z.optional(cases_settings),
        severity: z.optional(cases_case_severity),
        tags: z.optional(cases_case_tags),
        title: z.optional(cases_case_title),
      })
    ),
    description: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'A description for the template.',
      })
    ),
    key: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "A unique key for the template. Must be lower case and composed only of a-z, 0-9, '_', and '-' characters. It is used in API calls to refer to a specific template.\n",
      })
    ),
    name: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The name of the template.',
      })
    ),
    tags: z.optional(cases_template_tags),
  })
);

/**
 * Set case configuration request
 *
 * External connection details, such as the closure type and default connector for cases.
 */
export const cases_set_case_configuration_request = z
  .object({
    closure_type: cases_closure_types,
    connector: z
      .object({
        fields: z.union([z.record(z.string(), z.unknown()), z.null()]),
        id: z.string().register(z.globalRegistry, {
          description:
            'The identifier for the connector. If you do not want a default connector, use `none`. To retrieve connector IDs, use the find connectors API.',
        }),
        name: z.string().register(z.globalRegistry, {
          description:
            'The name of the connector. If you do not want a default connector, use `none`. To retrieve connector names, use the find connectors API.',
        }),
        type: cases_connector_types,
      })
      .register(z.globalRegistry, {
        description: 'An object that contains the connector configuration.',
      }),
    customFields: z.optional(
      z
        .array(
          z.object({
            defaultValue: z.optional(z.union([z.string(), z.boolean()])),
            key: z.string().min(1).max(36).register(z.globalRegistry, {
              description:
                "A unique key for the custom field. Must be lower case and composed only of a-z, 0-9, '_', and '-' characters. It is used in API calls to refer to a specific custom field.\n",
            }),
            label: z.string().min(1).max(50).register(z.globalRegistry, {
              description: 'The custom field label that is displayed in the case.',
            }),
            type: z.enum(['text', 'toggle']).register(z.globalRegistry, {
              description: 'The type of the custom field.',
            }),
            required: z.boolean().register(z.globalRegistry, {
              description:
                'Indicates whether the field is required. If `false`, the custom field can be set to null or omitted when a case is created or updated.\n',
            }),
          })
        )
        .min(0)
        .max(10)
        .register(z.globalRegistry, {
          description: 'Custom fields case configuration.',
        })
    ),
    owner: cases_owner,
    templates: z.optional(cases_templates),
  })
  .register(z.globalRegistry, {
    description:
      'External connection details, such as the closure type and default connector for cases.',
  });

/**
 * Update case comment request properties for alerts
 *
 * Defines properties for case comment requests when type is alert.
 */
export const cases_update_alert_comment_request_properties = z
  .object({
    alertId: cases_alert_identifiers,
    id: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the comment. To retrieve comment IDs, use the get comments API.\n',
    }),
    index: cases_alert_indices,
    owner: cases_owner,
    rule: cases_rule,
    type: z.enum(['alert']).register(z.globalRegistry, {
      description: 'The type of comment.',
    }),
    version: z.string().register(z.globalRegistry, {
      description:
        'The current comment version. To retrieve version values, use the get comments API.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for case comment requests when type is alert.',
  });

/**
 * Update case configuration request
 *
 * You can update settings such as the closure type, custom fields, templates, and the default connector for cases.
 *
 */
export const cases_update_case_configuration_request = z
  .object({
    closure_type: z.optional(cases_closure_types),
    connector: z.optional(
      z
        .object({
          fields: z.union([z.record(z.string(), z.unknown()), z.null()]),
          id: z.string().register(z.globalRegistry, {
            description:
              'The identifier for the connector. If you do not want a default connector, use `none`. To retrieve connector IDs, use the find connectors API.',
          }),
          name: z.string().register(z.globalRegistry, {
            description:
              'The name of the connector. If you do not want a default connector, use `none`. To retrieve connector names, use the find connectors API.',
          }),
          type: cases_connector_types,
        })
        .register(z.globalRegistry, {
          description: 'An object that contains the connector configuration.',
        })
    ),
    customFields: z.optional(
      z
        .array(
          z.object({
            defaultValue: z.optional(z.union([z.string(), z.boolean()])),
            key: z.string().min(1).max(36).register(z.globalRegistry, {
              description:
                "A unique key for the custom field. Must be lower case and composed only of a-z, 0-9, '_', and '-' characters. It is used in API calls to refer to a specific custom field.\n",
            }),
            label: z.string().min(1).max(50).register(z.globalRegistry, {
              description: 'The custom field label that is displayed in the case.',
            }),
            type: z.enum(['text', 'toggle']).register(z.globalRegistry, {
              description: 'The type of the custom field.',
            }),
            required: z.boolean().register(z.globalRegistry, {
              description:
                'Indicates whether the field is required. If `false`, the custom field can be set to null or omitted when a case is created or updated.\n',
            }),
          })
        )
        .register(z.globalRegistry, {
          description: 'Custom fields case configuration.',
        })
    ),
    templates: z.optional(cases_templates),
    version: z.string().register(z.globalRegistry, {
      description:
        'The version of the connector. To retrieve the version value, use the get configuration API.\n',
    }),
  })
  .register(z.globalRegistry, {
    description:
      'You can update settings such as the closure type, custom fields, templates, and the default connector for cases.\n',
  });

/**
 * Update case request
 *
 * The update case API request body varies depending on the type of connector.
 */
export const cases_update_case_request = z
  .object({
    cases: z
      .array(
        z.object({
          assignees: z.optional(cases_assignees),
          category: z.optional(cases_case_category),
          connector: z.optional(
            z.union([
              cases_connector_properties_none,
              cases_connector_properties_cases_webhook,
              cases_connector_properties_jira,
              cases_connector_properties_resilient,
              cases_connector_properties_servicenow,
              cases_connector_properties_servicenow_sir,
              cases_connector_properties_swimlane,
            ])
          ),
          customFields: z.optional(
            z
              .array(
                z.object({
                  key: z.string().register(z.globalRegistry, {
                    description:
                      'The unique identifier for the custom field. The key value must exist in the case configuration settings.\n',
                  }),
                  type: z.enum(['text', 'toggle']).register(z.globalRegistry, {
                    description:
                      'The custom field type. It must match the type specified in the case configuration settings.\n',
                  }),
                  value: z.union([z.string().min(1).max(160), z.null(), z.boolean()]),
                })
              )
              .min(0)
              .max(10)
              .register(z.globalRegistry, {
                description:
                  'Custom field values for a case. Any optional custom fields that are not specified in the request are set to null.\n',
              })
          ),
          description: z.optional(cases_case_description),
          id: z.string().max(30000).register(z.globalRegistry, {
            description: 'The identifier for the case.',
          }),
          settings: z.optional(cases_settings),
          severity: z.optional(cases_case_severity),
          status: z.optional(cases_case_status),
          tags: z.optional(cases_case_tags),
          title: z.optional(cases_case_title),
          version: z.string().register(z.globalRegistry, {
            description:
              'The current version of the case. To determine this value, use the get case or find cases APIs.',
          }),
        })
      )
      .min(1)
      .max(100)
      .register(z.globalRegistry, {
        description: 'An array containing one or more case objects.',
      }),
  })
  .register(z.globalRegistry, {
    description: 'The update case API request body varies depending on the type of connector.',
  });

/**
 * Update case comment request properties for user comments
 *
 * Defines properties for case comment requests when type is user.
 */
export const cases_update_user_comment_request_properties = z
  .object({
    comment: z.string().max(30000).register(z.globalRegistry, {
      description: 'The new comment. It is required only when `type` is `user`.',
    }),
    id: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the comment. To retrieve comment IDs, use the get comments API.\n',
    }),
    owner: cases_owner,
    type: z.enum(['user']).register(z.globalRegistry, {
      description: 'The type of comment.',
    }),
    version: z.string().register(z.globalRegistry, {
      description:
        'The current comment version. To retrieve version values, use the get comments API.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for case comment requests when type is user.',
  });

/**
 * Update case comment request
 *
 * The update case comment API request body varies depending on whether you are updating an alert or a comment.
 */
export const cases_update_case_comment_request = z.union([
  z
    .object({
      type: z.literal('alert'),
    })
    .and(cases_update_alert_comment_request_properties),
  z
    .object({
      type: z.literal('user'),
    })
    .and(cases_update_user_comment_request_properties),
]);

export const cases_user_actions_find_response_properties = z.object({
  action: cases_actions,
  comment_id: z.union([z.string(), z.null()]),
  created_at: z.iso.datetime(),
  created_by: z.object({
    email: z.union([z.string(), z.null()]),
    full_name: z.union([z.string(), z.null()]),
    profile_uid: z.optional(z.string()),
    username: z.union([z.string(), z.null()]),
  }),
  id: z.string(),
  owner: cases_owner,
  payload: z.union([
    cases_payload_alert_comment,
    cases_payload_assignees,
    cases_payload_connector,
    cases_payload_create_case,
    cases_payload_delete,
    cases_payload_description,
    cases_payload_pushed,
    cases_payload_settings,
    cases_payload_severity,
    cases_payload_status,
    cases_payload_tags,
    cases_payload_title,
    cases_payload_user_comment,
  ]),
  type: z
    .enum([
      'assignees',
      'create_case',
      'comment',
      'connector',
      'description',
      'pushed',
      'tags',
      'title',
      'status',
      'settings',
      'severity',
    ])
    .register(z.globalRegistry, {
      description: 'The type of action.',
    }),
  version: z.string(),
});

/**
 * Case response properties for user comments
 */
export const cases_user_comment_response_properties = z.object({
  comment: z.optional(z.string()),
  created_at: z.optional(z.iso.datetime()),
  created_by: z.optional(cases_case_response_created_by_properties),
  id: z.optional(z.string()),
  owner: z.optional(cases_owner),
  pushed_at: z.optional(z.union([z.iso.datetime(), z.null()])),
  pushed_by: z.optional(cases_case_response_pushed_by_properties),
  type: z.enum(['user']),
  updated_at: z.optional(z.union([z.iso.datetime(), z.null()])),
  updated_by: z.optional(cases_case_response_updated_by_properties),
  version: z.optional(z.string()),
});

/**
 * Case response properties
 */
export const cases_case_response_properties = z.object({
  assignees: z.optional(cases_assignees),
  category: z.optional(z.union([z.string(), z.null()])),
  closed_at: z.union([z.iso.datetime(), z.null()]),
  closed_by: cases_case_response_closed_by_properties,
  comments: z
    .array(
      z.union([
        z
          .object({
            type: z.literal('alert'),
          })
          .and(cases_alert_comment_response_properties),
        z
          .object({
            type: z.literal('user'),
          })
          .and(cases_user_comment_response_properties),
      ])
    )
    .max(10000)
    .register(z.globalRegistry, {
      description: 'An array of comment objects for the case.',
    }),
  connector: z.union([
    z
      .object({
        type: z.literal('.none'),
      })
      .and(cases_connector_properties_none),
    z
      .object({
        type: z.literal('.cases-webhook'),
      })
      .and(cases_connector_properties_cases_webhook),
    z
      .object({
        type: z.literal('.jira'),
      })
      .and(cases_connector_properties_jira),
    z
      .object({
        type: z.literal('.resilient'),
      })
      .and(cases_connector_properties_resilient),
    z
      .object({
        type: z.literal('.servicenow'),
      })
      .and(cases_connector_properties_servicenow),
    z
      .object({
        type: z.literal('.servicenow-sir'),
      })
      .and(cases_connector_properties_servicenow_sir),
    z
      .object({
        type: z.literal('.swimlane'),
      })
      .and(cases_connector_properties_swimlane),
  ]),
  created_at: z.iso.datetime(),
  created_by: cases_case_response_created_by_properties,
  customFields: z.optional(
    z
      .array(
        z.object({
          key: z.optional(
            z.string().register(z.globalRegistry, {
              description:
                'The unique identifier for the custom field. The key value must exist in the case configuration settings.\n',
            })
          ),
          type: z.optional(
            z.enum(['text', 'toggle']).register(z.globalRegistry, {
              description:
                'The custom field type. It must match the type specified in the case configuration settings.\n',
            })
          ),
          value: z.optional(z.union([z.string().min(1).max(160), z.null(), z.boolean()])),
        })
      )
      .register(z.globalRegistry, {
        description: 'Custom field values for the case.',
      })
  ),
  description: z.string(),
  duration: z.union([z.int(), z.null()]),
  external_service: cases_external_service,
  id: z.string(),
  owner: cases_owner,
  settings: cases_settings,
  severity: cases_case_severity,
  status: cases_case_status,
  tags: z.array(z.string()),
  title: z.string(),
  totalAlerts: z.int(),
  totalComment: z.int(),
  updated_at: z.union([z.iso.datetime(), z.null()]),
  updated_by: cases_case_response_updated_by_properties,
  version: z.string(),
});

/**
 * Bad request
 */
export const data_views_400_response = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.number(),
});

export const data_views_404_response = z.object({
  error: z.optional(z.enum(['Not Found'])),
  message: z.optional(z.string()),
  statusCode: z.optional(z.literal(404)),
});

/**
 * Allows the data view saved object to exist before the data is available. Defaults to `false`.
 */
export const data_views_allownoindex = z.boolean().register(z.globalRegistry, {
  description:
    'Allows the data view saved object to exist before the data is available. Defaults to `false`.',
});

/**
 * A map of field attributes by field name.
 */
export const data_views_fieldattrs = z
  .object({
    count: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'Popularity count for the field.',
      })
    ),
    customDescription: z.optional(
      z.string().max(300).register(z.globalRegistry, {
        description: 'Custom description for the field.',
      })
    ),
    customLabel: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Custom label for the field.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'A map of field attributes by field name.',
  });

/**
 * A map of field formats by field name.
 */
export const data_views_fieldformats = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'A map of field formats by field name.',
  });

/**
 * An array of space identifiers for sharing the data view between multiple spaces.
 */
export const data_views_namespaces = z
  .array(z.string().default('default'))
  .register(z.globalRegistry, {
    description: 'An array of space identifiers for sharing the data view between multiple spaces.',
  });

/**
 * A map of runtime field definitions by field name.
 */
export const data_views_runtimefieldmap = z
  .object({
    script: z.object({
      source: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Script for the runtime field.',
        })
      ),
    }),
    type: z.string().register(z.globalRegistry, {
      description: 'Mapping type of the runtime field.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'A map of runtime field definitions by field name.',
  });

/**
 * The array of field names you want to filter out in Discover.
 */
export const data_views_sourcefilters = z
  .array(
    z.object({
      value: z.string(),
    })
  )
  .register(z.globalRegistry, {
    description: 'The array of field names you want to filter out in Discover.',
  });

/**
 * Data view reference swap request
 */
export const data_views_swap_data_view_request_object = z.object({
  delete: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Deletes referenced saved object if all references are removed.',
    })
  ),
  forId: z.optional(z.union([z.string(), z.array(z.string())])),
  forType: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Limit the affected saved objects by type.',
    })
  ),
  fromId: z.string().register(z.globalRegistry, {
    description: 'The saved object reference to change.',
  }),
  fromType: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Specify the type of the saved object reference to alter. The default value is `index-pattern` for data views.\n',
    })
  ),
  toId: z.string().register(z.globalRegistry, {
    description: 'New saved object reference value to replace the old value.',
  }),
});

/**
 * The timestamp field name, which you use for time-based data views.
 */
export const data_views_timefieldname = z.string().register(z.globalRegistry, {
  description: 'The timestamp field name, which you use for time-based data views.',
});

/**
 * Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
 */
export const data_views_title = z.string().register(z.globalRegistry, {
  description:
    'Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).',
});

/**
 * When set to `rollup`, identifies the rollup data views.
 */
export const data_views_type = z.string().register(z.globalRegistry, {
  description: 'When set to `rollup`, identifies the rollup data views.',
});

/**
 * When you use rollup indices, contains the field list for the rollup data view API endpoints.
 */
export const data_views_typemeta = z
  .object({
    aggs: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'A map of rollup restrictions by aggregation type and field name.',
    }),
    params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'Properties for retrieving rollup fields.',
    }),
  })
  .register(z.globalRegistry, {
    description:
      'When you use rollup indices, contains the field list for the rollup data view API endpoints.',
  });

/**
 * Create data view request
 */
export const data_views_create_data_view_request_object = z.object({
  data_view: z
    .object({
      allowNoIndex: z.optional(data_views_allownoindex),
      fieldAttrs: z.optional(z.record(z.string(), data_views_fieldattrs)),
      fieldFormats: z.optional(data_views_fieldformats),
      fields: z.optional(z.record(z.string(), z.unknown())),
      id: z.optional(z.string()),
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The data view name.',
        })
      ),
      namespaces: z.optional(data_views_namespaces),
      runtimeFieldMap: z.optional(z.record(z.string(), data_views_runtimefieldmap)),
      sourceFilters: z.optional(data_views_sourcefilters),
      timeFieldName: z.optional(data_views_timefieldname),
      title: data_views_title,
      type: z.optional(data_views_type),
      typeMeta: z.optional(data_views_typemeta),
      version: z.optional(z.string()),
    })
    .register(z.globalRegistry, {
      description: 'The data view object.',
    }),
  override: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Override an existing data view if a data view with the provided title already exists.',
      })
    )
    .default(false),
});

/**
 * When you use rollup indices, contains the field list for the rollup data view API endpoints.
 */
export const data_views_typemeta_response = z.union([
  z.object({
    aggs: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'A map of rollup restrictions by aggregation type and field name.',
      })
    ),
    params: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Properties for retrieving rollup fields.',
      })
    ),
  }),
  z.null(),
]);

/**
 * Data view response properties
 */
export const data_views_data_view_response_object = z.object({
  data_view: z.optional(
    z.object({
      allowNoIndex: z.optional(data_views_allownoindex),
      fieldAttrs: z.optional(z.record(z.string(), data_views_fieldattrs)),
      fieldFormats: z.optional(data_views_fieldformats),
      fields: z.optional(z.record(z.string(), z.unknown())),
      id: z.optional(z.string()),
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The data view name.',
        })
      ),
      namespaces: z.optional(data_views_namespaces),
      runtimeFieldMap: z.optional(z.record(z.string(), data_views_runtimefieldmap)),
      sourceFilters: z.optional(data_views_sourcefilters),
      timeFieldName: z.optional(data_views_timefieldname),
      title: z.optional(data_views_title),
      typeMeta: z.optional(data_views_typemeta_response),
      version: z.optional(z.string()),
    })
  ),
});

/**
 * Update data view request
 */
export const data_views_update_data_view_request_object = z.object({
  data_view: z
    .object({
      allowNoIndex: z.optional(data_views_allownoindex),
      fieldFormats: z.optional(data_views_fieldformats),
      fields: z.optional(z.record(z.string(), z.unknown())),
      name: z.optional(z.string()),
      runtimeFieldMap: z.optional(z.record(z.string(), data_views_runtimefieldmap)),
      sourceFilters: z.optional(data_views_sourcefilters),
      timeFieldName: z.optional(data_views_timefieldname),
      title: z.optional(data_views_title),
      type: z.optional(data_views_type),
      typeMeta: z.optional(data_views_typemeta),
    })
    .register(z.globalRegistry, {
      description:
        'The data view properties you want to update. Only the specified properties are updated in the data view. Unspecified fields stay as they are persisted.\n',
    }),
  refresh_fields: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Reloads the data view fields after the data view is updated.',
      })
    )
    .default(false),
});

/**
 * A minimal representation of Kibana's operational status.
 */
export const kibana_http_ap_is_core_status_redacted_response = z
  .object({
    status: z.object({
      overall: z.object({
        level: z
          .enum(['available', 'degraded', 'unavailable', 'critical'])
          .register(z.globalRegistry, {
            description: 'Service status levels as human and machine readable values.',
          }),
      }),
    }),
  })
  .register(z.globalRegistry, {
    description: "A minimal representation of Kibana's operational status.",
  });

/**
 * Kibana's operational status as well as a detailed breakdown of plugin statuses indication of various loads (like event loop utilization and network traffic) at time of request.
 */
export const kibana_http_ap_is_core_status_response = z
  .object({
    metrics: z
      .object({
        collection_interval_in_millis: z.number().register(z.globalRegistry, {
          description: 'The interval at which metrics should be collected.',
        }),
        elasticsearch_client: z
          .object({
            totalActiveSockets: z.number().register(z.globalRegistry, {
              description: 'Count of network sockets currently in use.',
            }),
            totalIdleSockets: z.number().register(z.globalRegistry, {
              description: 'Count of network sockets currently idle.',
            }),
            totalQueuedRequests: z.number().register(z.globalRegistry, {
              description: 'Count of requests not yet assigned to sockets.',
            }),
          })
          .register(z.globalRegistry, {
            description: "Current network metrics of Kibana's Elasticsearch client.",
          }),
        last_updated: z.string().register(z.globalRegistry, {
          description: 'The time metrics were collected.',
        }),
      })
      .register(z.globalRegistry, {
        description: 'Metric groups collected by Kibana.',
      }),
    name: z.string().register(z.globalRegistry, {
      description: 'Kibana instance name.',
    }),
    status: z.object({
      core: z
        .object({
          elasticsearch: z.object({
            detail: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'Human readable detail of the service status.',
              })
            ),
            documentationUrl: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'A URL to further documentation regarding this service.',
              })
            ),
            level: z
              .enum(['available', 'degraded', 'unavailable', 'critical'])
              .register(z.globalRegistry, {
                description: 'Service status levels as human and machine readable values.',
              }),
            meta: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
              description: 'An unstructured set of extra metadata about this service.',
            }),
            summary: z.string().register(z.globalRegistry, {
              description: 'A human readable summary of the service status.',
            }),
          }),
          http: z.optional(
            z.object({
              detail: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'Human readable detail of the service status.',
                })
              ),
              documentationUrl: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'A URL to further documentation regarding this service.',
                })
              ),
              level: z
                .enum(['available', 'degraded', 'unavailable', 'critical'])
                .register(z.globalRegistry, {
                  description: 'Service status levels as human and machine readable values.',
                }),
              meta: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
                description: 'An unstructured set of extra metadata about this service.',
              }),
              summary: z.string().register(z.globalRegistry, {
                description: 'A human readable summary of the service status.',
              }),
            })
          ),
          savedObjects: z.object({
            detail: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'Human readable detail of the service status.',
              })
            ),
            documentationUrl: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'A URL to further documentation regarding this service.',
              })
            ),
            level: z
              .enum(['available', 'degraded', 'unavailable', 'critical'])
              .register(z.globalRegistry, {
                description: 'Service status levels as human and machine readable values.',
              }),
            meta: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
              description: 'An unstructured set of extra metadata about this service.',
            }),
            summary: z.string().register(z.globalRegistry, {
              description: 'A human readable summary of the service status.',
            }),
          }),
        })
        .register(z.globalRegistry, {
          description: 'Statuses of core Kibana services.',
        }),
      overall: z.object({
        detail: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Human readable detail of the service status.',
          })
        ),
        documentationUrl: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'A URL to further documentation regarding this service.',
          })
        ),
        level: z
          .enum(['available', 'degraded', 'unavailable', 'critical'])
          .register(z.globalRegistry, {
            description: 'Service status levels as human and machine readable values.',
          }),
        meta: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description: 'An unstructured set of extra metadata about this service.',
        }),
        summary: z.string().register(z.globalRegistry, {
          description: 'A human readable summary of the service status.',
        }),
      }),
      plugins: z
        .record(
          z.string(),
          z.object({
            detail: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'Human readable detail of the service status.',
              })
            ),
            documentationUrl: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'A URL to further documentation regarding this service.',
              })
            ),
            level: z
              .enum(['available', 'degraded', 'unavailable', 'critical'])
              .register(z.globalRegistry, {
                description: 'Service status levels as human and machine readable values.',
              }),
            meta: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
              description: 'An unstructured set of extra metadata about this service.',
            }),
            summary: z.string().register(z.globalRegistry, {
              description: 'A human readable summary of the service status.',
            }),
          })
        )
        .register(z.globalRegistry, {
          description: 'A dynamic mapping of plugin ID to plugin status.',
        }),
    }),
    uuid: z.string().register(z.globalRegistry, {
      description:
        'Unique, generated Kibana instance UUID. This UUID should persist even if the Kibana process restarts.',
    }),
    version: z.object({
      build_date: z.string().register(z.globalRegistry, {
        description: 'The date and time of this build.',
      }),
      build_flavor: z.enum(['serverless', 'traditional']).register(z.globalRegistry, {
        description:
          'The build flavour determines configuration and behavior of Kibana. On premise users will almost always run the "traditional" flavour, while other flavours are reserved for Elastic-specific use cases.',
      }),
      build_hash: z.string().register(z.globalRegistry, {
        description: 'A unique hash value representing the git commit of this Kibana build.',
      }),
      build_number: z.number().register(z.globalRegistry, {
        description:
          'A monotonically increasing number, each subsequent build will have a higher number.',
      }),
      build_snapshot: z.boolean().register(z.globalRegistry, {
        description: 'Whether this build is a snapshot build.',
      }),
      number: z.string().register(z.globalRegistry, {
        description: 'A semantic version number.',
      }),
    }),
  })
  .register(z.globalRegistry, {
    description:
      "Kibana's operational status as well as a detailed breakdown of plugin statuses indication of various loads (like event loop utilization and network traffic) at time of request.",
  });

/**
 * Unsuccessful sync API response
 */
export const machine_learning_ap_is_ml_sync4xx_response = z.object({
  error: z.optional(z.string()),
  message: z.optional(z.string()),
  statusCode: z.optional(z.int()),
});

/**
 * The success or failure of the synchronization.
 */
export const machine_learning_ap_is_ml_sync_response_success = z
  .boolean()
  .register(z.globalRegistry, {
    description: 'The success or failure of the synchronization.',
  });

/**
 * Sync API response for anomaly detection jobs
 *
 * The sync machine learning saved objects API response contains this object when there are anomaly detection jobs affected by the synchronization. There is an object for each relevant job, which contains the synchronization status.
 */
export const machine_learning_ap_is_ml_sync_response_anomaly_detectors = z
  .object({
    success: z.optional(machine_learning_ap_is_ml_sync_response_success),
  })
  .register(z.globalRegistry, {
    description:
      'The sync machine learning saved objects API response contains this object when there are anomaly detection jobs affected by the synchronization. There is an object for each relevant job, which contains the synchronization status.',
  });

/**
 * Sync API response for datafeeds
 *
 * The sync machine learning saved objects API response contains this object when there are datafeeds affected by the synchronization. There is an object for each relevant datafeed, which contains the synchronization status.
 */
export const machine_learning_ap_is_ml_sync_response_datafeeds = z
  .object({
    success: z.optional(machine_learning_ap_is_ml_sync_response_success),
  })
  .register(z.globalRegistry, {
    description:
      'The sync machine learning saved objects API response contains this object when there are datafeeds affected by the synchronization. There is an object for each relevant datafeed, which contains the synchronization status.',
  });

/**
 * Sync API response for data frame analytics jobs
 *
 * The sync machine learning saved objects API response contains this object when there are data frame analytics jobs affected by the synchronization. There is an object for each relevant job, which contains the synchronization status.
 */
export const machine_learning_ap_is_ml_sync_response_data_frame_analytics = z
  .object({
    success: z.optional(machine_learning_ap_is_ml_sync_response_success),
  })
  .register(z.globalRegistry, {
    description:
      'The sync machine learning saved objects API response contains this object when there are data frame analytics jobs affected by the synchronization. There is an object for each relevant job, which contains the synchronization status.',
  });

/**
 * Sync API response for trained models
 *
 * The sync machine learning saved objects API response contains this object when there are trained models affected by the synchronization. There is an object for each relevant trained model, which contains the synchronization status.
 */
export const machine_learning_ap_is_ml_sync_response_trained_models = z
  .object({
    success: z.optional(machine_learning_ap_is_ml_sync_response_success),
  })
  .register(z.globalRegistry, {
    description:
      'The sync machine learning saved objects API response contains this object when there are trained models affected by the synchronization. There is an object for each relevant trained model, which contains the synchronization status.',
  });

/**
 * Sync API response for created saved objects
 *
 * If saved objects are missing for machine learning jobs or trained models, they are created when you run the sync machine learning saved objects API.
 */
export const machine_learning_ap_is_ml_sync_response_saved_objects_created = z
  .object({
    'anomaly-detector': z.optional(
      z
        .record(z.string(), machine_learning_ap_is_ml_sync_response_anomaly_detectors)
        .register(z.globalRegistry, {
          description: 'If saved objects are missing for anomaly detection jobs, they are created.',
        })
    ),
    'data-frame-analytics': z.optional(
      z
        .record(z.string(), machine_learning_ap_is_ml_sync_response_data_frame_analytics)
        .register(z.globalRegistry, {
          description:
            'If saved objects are missing for data frame analytics jobs, they are created.',
        })
    ),
    'trained-model': z.optional(
      z
        .record(z.string(), machine_learning_ap_is_ml_sync_response_trained_models)
        .register(z.globalRegistry, {
          description: 'If saved objects are missing for trained models, they are created.',
        })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'If saved objects are missing for machine learning jobs or trained models, they are created when you run the sync machine learning saved objects API.',
  });

/**
 * Sync API response for deleted saved objects
 *
 * If saved objects exist for machine learning jobs or trained models that no longer exist, they are deleted when you run the sync machine learning saved objects API.
 */
export const machine_learning_ap_is_ml_sync_response_saved_objects_deleted = z
  .object({
    'anomaly-detector': z.optional(
      z
        .record(z.string(), machine_learning_ap_is_ml_sync_response_anomaly_detectors)
        .register(z.globalRegistry, {
          description:
            'If there are saved objects exist for nonexistent anomaly detection jobs, they are deleted.',
        })
    ),
    'data-frame-analytics': z.optional(
      z
        .record(z.string(), machine_learning_ap_is_ml_sync_response_data_frame_analytics)
        .register(z.globalRegistry, {
          description:
            'If there are saved objects exist for nonexistent data frame analytics jobs, they are deleted.',
        })
    ),
    'trained-model': z.optional(
      z
        .record(z.string(), machine_learning_ap_is_ml_sync_response_trained_models)
        .register(z.globalRegistry, {
          description:
            'If there are saved objects exist for nonexistent trained models, they are deleted.',
        })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'If saved objects exist for machine learning jobs or trained models that no longer exist, they are deleted when you run the sync machine learning saved objects API.',
  });

/**
 * Successful sync API response
 */
export const machine_learning_ap_is_ml_sync200_response = z.object({
  datafeedsAdded: z.optional(
    z
      .record(z.string(), machine_learning_ap_is_ml_sync_response_datafeeds)
      .register(z.globalRegistry, {
        description:
          'If a saved object for an anomaly detection job is missing a datafeed identifier, it is added when you run the sync machine learning saved objects API.',
      })
  ),
  datafeedsRemoved: z.optional(
    z
      .record(z.string(), machine_learning_ap_is_ml_sync_response_datafeeds)
      .register(z.globalRegistry, {
        description:
          'If a saved object for an anomaly detection job references a datafeed that no longer exists, it is deleted when you run the sync machine learning saved objects API.',
      })
  ),
  savedObjectsCreated: z.optional(machine_learning_ap_is_ml_sync_response_saved_objects_created),
  savedObjectsDeleted: z.optional(machine_learning_ap_is_ml_sync_response_saved_objects_deleted),
});

export const observability_ai_assistant_api_chat_complete_request_example = z.unknown();

export const observability_ai_assistant_api_chat_complete_response_example = z.unknown();

export const observability_ai_assistant_api_function = z.object({
  description: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The description of the function.',
    })
  ),
  name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The name of the function.',
    })
  ),
  parameters: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The parameters of the function.',
    })
  ),
});

/**
 * Details of the function call within the message.
 */
export const observability_ai_assistant_api_function_call = z
  .object({
    arguments: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The arguments for the function call.',
      })
    ),
    name: z.string().register(z.globalRegistry, {
      description: 'The name of the function.',
    }),
    trigger: z.enum(['assistant', 'user', 'elastic']).register(z.globalRegistry, {
      description: 'The trigger of the function call.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Details of the function call within the message.',
  });

export const observability_ai_assistant_api_instruction = z.union([
  z.string().register(z.globalRegistry, {
    description: 'A simple instruction represented as a string.',
  }),
  z
    .object({
      id: z.string().register(z.globalRegistry, {
        description: 'A unique identifier for the instruction.',
      }),
      text: z.string().register(z.globalRegistry, {
        description: 'The text of the instruction.',
      }),
    })
    .register(z.globalRegistry, {
      description: 'A detailed instruction with an ID and text.',
    }),
]);

/**
 * The role of the message sender.
 */
export const observability_ai_assistant_api_message_role_enum = z
  .enum(['system', 'assistant', 'function', 'user', 'elastic'])
  .register(z.globalRegistry, {
    description: 'The role of the message sender.',
  });

export const observability_ai_assistant_api_message = z.object({
  '@timestamp': z.string().register(z.globalRegistry, {
    description: 'The timestamp when the message was created.',
  }),
  message: z
    .object({
      content: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The content of the message.',
        })
      ),
      data: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Additional data associated with the message.',
        })
      ),
      event: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The event related to the message.',
        })
      ),
      function_call: z.optional(observability_ai_assistant_api_function_call),
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The name associated with the message.',
        })
      ),
      role: observability_ai_assistant_api_message_role_enum,
    })
    .register(z.globalRegistry, {
      description: 'The main content of the message.',
    }),
});

/**
 * Bad request
 */
export const saved_objects_400_response = z.object({
  error: z.enum(['Bad Request']),
  message: z.string(),
  statusCode: z.literal(400),
});

/**
 * The data that you want to create. WARNING: When you create saved objects, attributes are not validated, which allows you to pass arbitrary and ill-formed data into the API that can break Kibana. Make sure any data that you send to the API is properly formed.
 *
 */
export const saved_objects_attributes = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'The data that you want to create. WARNING: When you create saved objects, attributes are not validated, which allows you to pass arbitrary and ill-formed data into the API that can break Kibana. Make sure any data that you send to the API is properly formed.\n',
  });

/**
 * Identifiers for the spaces in which this object is created. If this is provided, the object is created only in the explicitly defined spaces. If this is not provided, the object is created in the current space (default behavior). For shareable object types (registered with `namespaceType: 'multiple'`), this option can be used to specify one or more spaces, including the "All spaces" identifier ('*'). For isolated object types (registered with `namespaceType: 'single'` or `namespaceType: 'multiple-isolated'`), this option can only be used to specify a single space, and the "All spaces" identifier ('*') is not allowed. For global object types (`registered with `namespaceType: agnostic`), this option cannot be used.
 *
 */
export const saved_objects_initial_namespaces = z.array(z.unknown()).register(z.globalRegistry, {
  description:
    "Identifiers for the spaces in which this object is created. If this is provided, the object is created only in the explicitly defined spaces. If this is not provided, the object is created in the current space (default behavior). For shareable object types (registered with `namespaceType: 'multiple'`), this option can be used to specify one or more spaces, including the \"All spaces\" identifier ('*'). For isolated object types (registered with `namespaceType: 'single'` or `namespaceType: 'multiple-isolated'`), this option can only be used to specify a single space, and the \"All spaces\" identifier ('*') is not allowed. For global object types (`registered with `namespaceType: agnostic`), this option cannot be used.\n",
});

/**
 * Objects with `name`, `id`, and `type` properties that describe the other saved objects that this object references. Use `name` in attributes to refer to the other saved object, but never the `id`, which can update automatically during migrations or import and export.
 *
 */
export const saved_objects_references = z.array(z.unknown()).register(z.globalRegistry, {
  description:
    'Objects with `name`, `id`, and `type` properties that describe the other saved objects that this object references. Use `name` in attributes to refer to the other saved object, but never the `id`, which can update automatically during migrations or import and export.\n',
});

export const security_ai_assistant_api_anonymization_field_create_props = z.object({
  allowed: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this field is allowed to be sent to the model.',
    })
  ),
  anonymized: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this field should be anonymized.',
    })
  ),
  field: z.string().register(z.globalRegistry, {
    description: 'Name of the anonymization field to create.',
  }),
});

export const security_ai_assistant_api_anonymization_field_details_in_error = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'The ID of the anonymization field.',
  }),
  name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Name of the anonymization field.',
    })
  ),
});

/**
 * Reason why the anonymization field was not modified.
 */
export const security_ai_assistant_api_anonymization_fields_bulk_action_skip_reason = z
  .enum(['ANONYMIZATION_FIELD_NOT_MODIFIED'])
  .register(z.globalRegistry, {
    description: 'Reason why the anonymization field was not modified.',
  });

export const security_ai_assistant_api_anonymization_fields_bulk_action_skip_result = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'The ID of the anonymization field that was not modified.',
  }),
  name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Name of the anonymization field that was not modified.',
    })
  ),
  skip_reason: security_ai_assistant_api_anonymization_fields_bulk_action_skip_reason,
});

export const security_ai_assistant_api_anonymization_field_update_props = z.object({
  allowed: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this field is allowed to be sent to the model.',
    })
  ),
  anonymized: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this field should be anonymized.',
    })
  ),
  id: z.string().register(z.globalRegistry, {
    description: 'The ID of the anonymization field to update.',
  }),
});

/**
 * The basis of a content reference
 */
export const security_ai_assistant_api_base_content_reference = z
  .object({
    id: z.string().register(z.globalRegistry, {
      description: 'Id of the content reference',
    }),
    type: z.string().register(z.globalRegistry, {
      description: 'Type of the content reference',
    }),
  })
  .register(z.globalRegistry, {
    description: 'The basis of a content reference',
  });

export const security_ai_assistant_api_bulk_crud_action_summary = z.object({
  failed: z.int().register(z.globalRegistry, {
    description: 'The number of failed actions.',
  }),
  skipped: z.int().register(z.globalRegistry, {
    description: 'The number of skipped actions.',
  }),
  succeeded: z.int().register(z.globalRegistry, {
    description: 'The number of successfully performed actions.',
  }),
  total: z.int().register(z.globalRegistry, {
    description: 'The total number of actions attempted.',
  }),
});

/**
 * The role associated with the message in the chat.
 */
export const security_ai_assistant_api_chat_message_role = z
  .enum(['system', 'user', 'assistant'])
  .register(z.globalRegistry, {
    description: 'The role associated with the message in the chat.',
  });

/**
 * The conversation category.
 */
export const security_ai_assistant_api_conversation_category = z
  .enum(['assistant', 'insights'])
  .register(z.globalRegistry, {
    description: 'The conversation category.',
  });

/**
 * References an ESQL query
 */
export const security_ai_assistant_api_esql_content_reference =
  security_ai_assistant_api_base_content_reference.and(
    z.object({
      label: z.string().register(z.globalRegistry, {
        description: 'Label of the query',
      }),
      query: z.string().register(z.globalRegistry, {
        description: 'An ESQL query',
      }),
      timerange: z.optional(
        z
          .object({
            from: z.string(),
            to: z.string(),
          })
          .register(z.globalRegistry, {
            description: 'Time range to select in the time picker.',
          })
      ),
      type: z.enum(['EsqlQuery']),
    })
  );

export const security_ai_assistant_api_find_anonymization_fields_sort_field = z.enum([
  'created_at',
  'anonymized',
  'allowed',
  'field',
  'updated_at',
]);

/**
 * The field by which to sort the conversations. Possible values are `created_at`, `title`, and `updated_at`.
 */
export const security_ai_assistant_api_find_conversations_sort_field = z
  .enum(['created_at', 'title', 'updated_at'])
  .register(z.globalRegistry, {
    description:
      'The field by which to sort the conversations. Possible values are `created_at`, `title`, and `updated_at`.',
  });

/**
 * Fields available for sorting Knowledge Base Entries.
 */
export const security_ai_assistant_api_find_knowledge_base_entries_sort_field = z
  .enum(['created_at', 'is_default', 'title', 'updated_at'])
  .register(z.globalRegistry, {
    description: 'Fields available for sorting Knowledge Base Entries.',
  });

/**
 * Field by which to sort the prompts.
 */
export const security_ai_assistant_api_find_prompts_sort_field = z
  .enum(['created_at', 'is_default', 'name', 'updated_at'])
  .register(z.globalRegistry, {
    description: 'Field by which to sort the prompts.',
  });

/**
 * References an external URL
 */
export const security_ai_assistant_api_href_content_reference =
  security_ai_assistant_api_base_content_reference.and(
    z.object({
      href: z.string().register(z.globalRegistry, {
        description: 'URL to the external resource',
      }),
      label: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Label of the query',
        })
      ),
      type: z.enum(['Href']),
    })
  );

export const security_ai_assistant_api_index_entry_required_fields = z.object({
  description: z.string().register(z.globalRegistry, {
    description:
      'Description for when this index or data stream should be queried for Knowledge Base content. Passed to the LLM as a tool description.',
  }),
  field: z.string().register(z.globalRegistry, {
    description: 'Field to query for Knowledge Base content.',
  }),
  index: z.string().register(z.globalRegistry, {
    description: 'Index or Data Stream to query for Knowledge Base content.',
  }),
  queryDescription: z.string().register(z.globalRegistry, {
    description:
      'Description of query field used to fetch Knowledge Base content. Passed to the LLM as part of the tool input schema.',
  }),
  type: z.enum(['index']).register(z.globalRegistry, {
    description: 'Entry type.',
  }),
});

/**
 * Array of objects defining the input schema, allowing the LLM to extract structured data to be used in retrieval.
 */
export const security_ai_assistant_api_input_schema = z
  .array(
    z.object({
      description: z.string().register(z.globalRegistry, {
        description: 'Description of the field.',
      }),
      fieldName: z.string().register(z.globalRegistry, {
        description: 'Name of the field.',
      }),
      fieldType: z.string().register(z.globalRegistry, {
        description: 'Type of the field.',
      }),
    })
  )
  .register(z.globalRegistry, {
    description:
      'Array of objects defining the input schema, allowing the LLM to extract structured data to be used in retrieval.',
  });

export const security_ai_assistant_api_index_entry_optional_fields = z.object({
  inputSchema: z.optional(security_ai_assistant_api_input_schema),
  outputFields: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'Fields to extract from the query result, defaults to all fields if not provided or empty.',
    })
  ),
});

export const security_ai_assistant_api_index_entry_response_fields =
  security_ai_assistant_api_index_entry_required_fields.and(
    security_ai_assistant_api_index_entry_optional_fields
  );

/**
 * The type of interrupt
 */
export const security_ai_assistant_api_interrupt_type = z
  .enum(['SELECT_OPTION', 'INPUT_TEXT'])
  .register(z.globalRegistry, {
    description: 'The type of interrupt',
  });

/**
 * The basis of an interrupt resume value
 */
export const security_ai_assistant_api_base_interrupt_resume_value = z
  .object({
    type: security_ai_assistant_api_interrupt_type,
  })
  .register(z.globalRegistry, {
    description: 'The basis of an interrupt resume value',
  });

/**
 * The basis of an agent interrupt
 */
export const security_ai_assistant_api_base_interrupt_value = z
  .object({
    expired: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the interrupt has expired and can no longer be resumed.',
      })
    ),
    threadId: z.string().register(z.globalRegistry, {
      description: 'Thread ID of the graph execution that produced this message.',
    }),
    type: security_ai_assistant_api_interrupt_type,
  })
  .register(z.globalRegistry, {
    description: 'The basis of an agent interrupt',
  });

/**
 * A resume value for input text
 */
export const security_ai_assistant_api_input_text_interrupt_resume_value =
  security_ai_assistant_api_base_interrupt_resume_value.and(
    z.object({
      type: z.enum(['INPUT_TEXT']),
      value: z.string().register(z.globalRegistry, {
        description: 'Text value used to resume the graph execution with.',
      }),
    })
  );

/**
 * Interrupt that requests user to provide text input
 */
export const security_ai_assistant_api_input_text_interrupt_value =
  security_ai_assistant_api_base_interrupt_value.and(
    z.object({
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Description of action required',
        })
      ),
      placeholder: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Placeholder text for the input field',
        })
      ),
      type: z.enum(['INPUT_TEXT']),
    })
  );

/**
 * Reason why a Knowledge Base Entry was skipped during the bulk action.
 */
export const security_ai_assistant_api_knowledge_base_entry_bulk_action_skip_reason = z
  .enum(['KNOWLEDGE_BASE_ENTRY_NOT_MODIFIED'])
  .register(z.globalRegistry, {
    description: 'Reason why a Knowledge Base Entry was skipped during the bulk action.',
  });

export const security_ai_assistant_api_knowledge_base_entry_bulk_action_skip_result = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'ID of the skipped Knowledge Base Entry.',
  }),
  name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Name of the skipped Knowledge Base Entry.',
    })
  ),
  skip_reason: security_ai_assistant_api_knowledge_base_entry_bulk_action_skip_reason,
});

export const security_ai_assistant_api_knowledge_base_entry_bulk_crud_action_summary = z.object({
  failed: z.int().register(z.globalRegistry, {
    description: 'Number of Knowledge Base Entries that failed during the bulk action.',
  }),
  skipped: z.int().register(z.globalRegistry, {
    description: 'Number of Knowledge Base Entries that were skipped during the bulk action.',
  }),
  succeeded: z.int().register(z.globalRegistry, {
    description:
      'Number of Knowledge Base Entries that were successfully processed during the bulk action.',
  }),
  total: z.int().register(z.globalRegistry, {
    description: 'Total number of Knowledge Base Entries involved in the bulk action.',
  }),
});

/**
 * References a knowledge base entry
 */
export const security_ai_assistant_api_knowledge_base_entry_content_reference =
  security_ai_assistant_api_base_content_reference.and(
    z.object({
      knowledgeBaseEntryId: z.string().register(z.globalRegistry, {
        description: 'Id of the Knowledge Base Entry',
      }),
      knowledgeBaseEntryName: z.string().register(z.globalRegistry, {
        description: 'Name of the knowledge base entry',
      }),
      type: z.enum(['KnowledgeBaseEntry']),
    })
  );

export const security_ai_assistant_api_knowledge_base_entry_details_in_error = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'ID of the Knowledge Base Entry that encountered an error.',
  }),
  name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Name of the Knowledge Base Entry that encountered an error.',
    })
  ),
});

export const security_ai_assistant_api_knowledge_base_entry_error_schema = z.object({
  error: z.string().register(z.globalRegistry, {
    description: 'Error type or category.',
  }),
  message: z.string().register(z.globalRegistry, {
    description: 'Detailed error message.',
  }),
  statusCode: z.number().register(z.globalRegistry, {
    description: 'HTTP status code of the error.',
  }),
});

export const security_ai_assistant_api_knowledge_base_read_response200 = z.object({
  defend_insights_exists: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates if Defend Insights documentation exists in the KnowledgeBase.',
    })
  ),
  elser_exists: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates if the ELSER model exists for the KnowledgeBase.',
    })
  ),
  is_setup_available: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates if the setup process is available for the KnowledgeBase.',
    })
  ),
  is_setup_in_progress: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates if the setup process is currently in progress.',
    })
  ),
  product_documentation_status: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The status of the product documentation in the KnowledgeBase.',
    })
  ),
  security_labs_exists: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates if Security Labs documentation exists in the KnowledgeBase.',
    })
  ),
  user_data_exists: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates if user data exists in the KnowledgeBase.',
    })
  ),
});

/**
 * Knowledge Base resource name for grouping entries, e.g. 'security_labs', 'user', etc.
 */
export const security_ai_assistant_api_knowledge_base_resource = z
  .enum(['security_labs', 'defend_insights', 'user'])
  .register(z.globalRegistry, {
    description:
      "Knowledge Base resource name for grouping entries, e.g. 'security_labs', 'user', etc.",
  });

export const security_ai_assistant_api_document_entry_required_fields = z.object({
  kbResource: security_ai_assistant_api_knowledge_base_resource,
  source: z.string().register(z.globalRegistry, {
    description: 'Source document name or filepath.',
  }),
  text: z.string().register(z.globalRegistry, {
    description: 'Knowledge Base Entry content.',
  }),
  type: z.enum(['document']).register(z.globalRegistry, {
    description: 'Entry type.',
  }),
});

/**
 * AI assistant KnowledgeBase.
 */
export const security_ai_assistant_api_knowledge_base_response = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Identify the success of the method execution.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'AI assistant KnowledgeBase.',
  });

export const security_ai_assistant_api_knowledge_base_response400 = z.object({
  error: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A short description of the error.',
    })
  ),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A detailed error message.',
    })
  ),
  statusCode: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The HTTP status code of the error.',
    })
  ),
});

/**
 * ECS-style metadata attached to the message.
 */
export const security_ai_assistant_api_message_data = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'ECS-style metadata attached to the message.',
  });

/**
 * A message exchanged within the AI chat conversation.
 */
export const security_ai_assistant_api_chat_message = z
  .object({
    content: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The textual content of the message.',
      })
    ),
    data: z.optional(security_ai_assistant_api_message_data),
    fields_to_anonymize: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description: 'List of field names within the data object that should be anonymized.',
      })
    ),
    role: security_ai_assistant_api_chat_message_role,
  })
  .register(z.globalRegistry, {
    description: 'A message exchanged within the AI chat conversation.',
  });

/**
 * Message role.
 */
export const security_ai_assistant_api_message_role = z
  .enum(['system', 'user', 'assistant'])
  .register(z.globalRegistry, {
    description: 'Message role.',
  });

/**
 * A string that does not contain only whitespace characters.
 */
export const security_ai_assistant_api_non_empty_string = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: 'A string that does not contain only whitespace characters.',
  });

/**
 * The request payload for creating a chat completion.
 */
export const security_ai_assistant_api_chat_complete_props = z
  .object({
    connectorId: z.string().register(z.globalRegistry, {
      description: 'Required connector identifier to route the request.',
    }),
    conversationId: z.optional(security_ai_assistant_api_non_empty_string),
    isStream: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If true, the response will be streamed in chunks.',
      })
    ),
    langSmithApiKey: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'API key for LangSmith integration.',
      })
    ),
    langSmithProject: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'LangSmith project name for tracing.',
      })
    ),
    messages: z.array(security_ai_assistant_api_chat_message).register(z.globalRegistry, {
      description: 'List of chat messages exchanged so far.',
    }),
    model: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Model ID or name to use for the response.',
      })
    ),
    persist: z.boolean().register(z.globalRegistry, {
      description: 'Whether to persist the chat and response to storage.',
    }),
    promptId: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Prompt template identifier.',
      })
    ),
    responseLanguage: z.optional(
      z.string().register(z.globalRegistry, {
        description: "ISO language code for the assistant's response.",
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request payload for creating a chat completion.',
  });

export const security_ai_assistant_api_delete_response_fields = z.object({
  id: security_ai_assistant_api_non_empty_string,
});

/**
 * A string that represents a timestamp in ISO 8601 format and does not contain only whitespace characters.
 */
export const security_ai_assistant_api_non_empty_timestamp = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description:
      'A string that represents a timestamp in ISO 8601 format and does not contain only whitespace characters.',
  });

export const security_ai_assistant_api_anonymization_field_response = z.object({
  allowed: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this field is allowed to be sent to the model.',
    })
  ),
  anonymized: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this field should be anonymized.',
    })
  ),
  createdAt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Timestamp of when the anonymization field was created.',
    })
  ),
  createdBy: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Username of the person who created the anonymization field.',
    })
  ),
  field: z.string().register(z.globalRegistry, {
    description: 'Name of the anonymization field.',
  }),
  id: security_ai_assistant_api_non_empty_string,
  namespace: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Kibana space in which this anonymization field exists.',
    })
  ),
  timestamp: z.optional(security_ai_assistant_api_non_empty_timestamp),
  updatedAt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Timestamp of the last update.',
    })
  ),
  updatedBy: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Username of the person who last updated the field.',
    })
  ),
});

export const security_ai_assistant_api_anonymization_fields_bulk_crud_action_results = z.object({
  created: z
    .array(security_ai_assistant_api_anonymization_field_response)
    .register(z.globalRegistry, {
      description: 'List of anonymization fields successfully created.',
    }),
  deleted: z.array(
    z.string().register(z.globalRegistry, {
      description: 'Array of IDs of anonymization fields that were deleted.',
    })
  ),
  skipped: z
    .array(security_ai_assistant_api_anonymization_fields_bulk_action_skip_result)
    .register(z.globalRegistry, {
      description: 'List of anonymization fields that were skipped during the operation.',
    }),
  updated: z
    .array(security_ai_assistant_api_anonymization_field_response)
    .register(z.globalRegistry, {
      description: 'List of anonymization fields successfully updated.',
    }),
});

export const security_ai_assistant_api_normalized_anonymization_field_error = z.object({
  anonymization_fields: z
    .array(security_ai_assistant_api_anonymization_field_details_in_error)
    .register(z.globalRegistry, {
      description: 'Array of anonymization fields that caused the error.',
    }),
  err_code: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Error code indicating the type of failure.',
    })
  ),
  message: z.string().register(z.globalRegistry, {
    description: 'Error message.',
  }),
  status_code: z.int().register(z.globalRegistry, {
    description: 'Status code of the response.',
  }),
});

export const security_ai_assistant_api_anonymization_fields_bulk_crud_action_response = z.object({
  anonymization_fields_count: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Total number of anonymization fields processed.',
    })
  ),
  attributes: z.object({
    errors: z.optional(
      z
        .array(security_ai_assistant_api_normalized_anonymization_field_error)
        .register(z.globalRegistry, {
          description: 'List of errors that occurred during the bulk operation.',
        })
    ),
    results: security_ai_assistant_api_anonymization_fields_bulk_crud_action_results,
    summary: security_ai_assistant_api_bulk_crud_action_summary,
  }),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Message providing information about the bulk action result.',
    })
  ),
  status_code: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'HTTP status code returned.',
    })
  ),
  success: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates if the bulk action was successful.',
    })
  ),
});

export const security_ai_assistant_api_normalized_knowledge_base_entry_error = z.object({
  err_code: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Specific error code for the issue.',
    })
  ),
  knowledgeBaseEntries: z
    .array(security_ai_assistant_api_knowledge_base_entry_details_in_error)
    .register(z.globalRegistry, {
      description: 'List of Knowledge Base Entries that encountered the error.',
    }),
  message: z.string().register(z.globalRegistry, {
    description: 'Error message describing the issue.',
  }),
  statusCode: z.int().register(z.globalRegistry, {
    description: 'HTTP status code associated with the error.',
  }),
});

/**
 * References the product documentation
 */
export const security_ai_assistant_api_product_documentation_content_reference =
  security_ai_assistant_api_base_content_reference.and(
    z.object({
      title: z.string().register(z.globalRegistry, {
        description: 'Title of the documentation',
      }),
      type: z.enum(['ProductDocumentation']),
      url: z.string().register(z.globalRegistry, {
        description: 'URL to the documentation',
      }),
    })
  );

export const security_ai_assistant_api_prompt_details_in_error = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'The ID of the prompt that encountered an error.',
  }),
  name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The name of the prompt that encountered an error.',
    })
  ),
});

export const security_ai_assistant_api_normalized_prompt_error = z.object({
  err_code: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A code representing the error type.',
    })
  ),
  message: z.string().register(z.globalRegistry, {
    description: 'A message describing the error encountered.',
  }),
  prompts: z.array(security_ai_assistant_api_prompt_details_in_error).register(z.globalRegistry, {
    description: 'List of prompts that encountered errors.',
  }),
  status_code: z.int().register(z.globalRegistry, {
    description: 'The HTTP status code associated with the error.',
  }),
});

/**
 * Reason why a prompt was skipped during the bulk action.
 */
export const security_ai_assistant_api_prompts_bulk_action_skip_reason = z
  .enum(['PROMPT_FIELD_NOT_MODIFIED'])
  .register(z.globalRegistry, {
    description: 'Reason why a prompt was skipped during the bulk action.',
  });

export const security_ai_assistant_api_prompts_bulk_action_skip_result = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'The ID of the prompt that was skipped.',
  }),
  name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The name of the prompt that was skipped.',
    })
  ),
  skip_reason: security_ai_assistant_api_prompts_bulk_action_skip_reason,
});

/**
 * Type of the prompt (either system or quick).
 */
export const security_ai_assistant_api_prompt_type = z
  .enum(['system', 'quick'])
  .register(z.globalRegistry, {
    description: 'Type of the prompt (either system or quick).',
  });

export const security_ai_assistant_api_prompt_create_props = z.object({
  categories: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'List of categories for the prompt.',
    })
  ),
  color: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The color associated with the prompt.',
    })
  ),
  consumer: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The consumer associated with the prompt.',
    })
  ),
  content: z.string().register(z.globalRegistry, {
    description: 'The content of the prompt.',
  }),
  isDefault: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this prompt should be the default.',
    })
  ),
  isNewConversationDefault: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this prompt should be the default for new conversations.',
    })
  ),
  name: z.string().register(z.globalRegistry, {
    description: 'The name of the prompt.',
  }),
  promptType: security_ai_assistant_api_prompt_type,
});

export const security_ai_assistant_api_prompt_update_props = z.object({
  categories: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'The updated categories for the prompt.',
    })
  ),
  color: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The updated color associated with the prompt.',
    })
  ),
  consumer: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The updated consumer for the prompt.',
    })
  ),
  content: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The updated content for the prompt.',
    })
  ),
  id: z.string().register(z.globalRegistry, {
    description: 'The ID of the prompt to update.',
  }),
  isDefault: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this prompt should be the default.',
    })
  ),
  isNewConversationDefault: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether the prompt should be the default for new conversations.',
    })
  ),
});

/**
 * Provider
 */
export const security_ai_assistant_api_provider = z
  .enum(['OpenAI', 'Azure OpenAI', 'Other'])
  .register(z.globalRegistry, {
    description: 'Provider',
  });

export const security_ai_assistant_api_api_config = z.object({
  actionTypeId: z.string().register(z.globalRegistry, {
    description: 'Action type ID',
  }),
  connectorId: z.string().register(z.globalRegistry, {
    description: 'Connector ID',
  }),
  defaultSystemPromptId: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Default system prompt ID',
    })
  ),
  model: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Model',
    })
  ),
  provider: z.optional(security_ai_assistant_api_provider),
});

export const security_ai_assistant_api_reader = z.record(z.string(), z.unknown());

/**
 * Replacements object used to anonymize/deanonymize messages
 */
export const security_ai_assistant_api_replacements = z
  .record(z.string(), z.string())
  .register(z.globalRegistry, {
    description: 'Replacements object used to anonymize/deanonymize messages',
  });

export const security_ai_assistant_api_response_fields = z.object({
  createdAt: z.string().register(z.globalRegistry, {
    description: 'Time the Knowledge Base Entry was created.',
  }),
  createdBy: z.string().register(z.globalRegistry, {
    description: 'User who created the Knowledge Base Entry.',
  }),
  id: security_ai_assistant_api_non_empty_string,
  updatedAt: z.string().register(z.globalRegistry, {
    description: 'Time the Knowledge Base Entry was last updated.',
  }),
  updatedBy: z.string().register(z.globalRegistry, {
    description: 'User who last updated the Knowledge Base Entry.',
  }),
});

/**
 * References a security alert
 */
export const security_ai_assistant_api_security_alert_content_reference =
  security_ai_assistant_api_base_content_reference.and(
    z.object({
      alertId: z.string().register(z.globalRegistry, {
        description: 'ID of the Alert',
      }),
      type: z.enum(['SecurityAlert']),
    })
  );

/**
 * References the security alerts page
 */
export const security_ai_assistant_api_security_alerts_page_content_reference =
  security_ai_assistant_api_base_content_reference.and(
    z.object({
      type: z.enum(['SecurityAlertsPage']),
    })
  );

/**
 * A union of all content reference types
 */
export const security_ai_assistant_api_content_references = z
  .record(
    z.string(),
    z.union([
      security_ai_assistant_api_knowledge_base_entry_content_reference,
      security_ai_assistant_api_security_alert_content_reference,
      security_ai_assistant_api_security_alerts_page_content_reference,
      security_ai_assistant_api_product_documentation_content_reference,
      security_ai_assistant_api_esql_content_reference,
      security_ai_assistant_api_href_content_reference,
    ])
  )
  .register(z.globalRegistry, {
    description: 'A union of all content reference types',
  });

/**
 * A request approval option
 */
export const security_ai_assistant_api_select_option_interrupt_option = z
  .object({
    buttonColor: z.optional(
      z.enum([
        'text',
        'accent',
        'accentSecondary',
        'primary',
        'success',
        'warning',
        'danger',
        'neutral',
        'risk',
      ])
    ),
    label: z.string(),
    value: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'A request approval option',
  });

/**
 * A request approval resume schema
 */
export const security_ai_assistant_api_select_option_interrupt_resume_value =
  security_ai_assistant_api_base_interrupt_resume_value.and(
    z.object({
      type: z.enum(['SELECT_OPTION']),
      value: z.string().register(z.globalRegistry, {
        description: 'The value of the selected option to resume the graph execution with',
      }),
    })
  );

/**
 * Union of the interrupt resume values
 */
export const security_ai_assistant_api_interrupt_resume_value = z.union([
  security_ai_assistant_api_select_option_interrupt_resume_value,
  security_ai_assistant_api_input_text_interrupt_resume_value,
]);

/**
 * Interrupt that requests user to select one of the provided options
 */
export const security_ai_assistant_api_select_option_interrupt_value =
  security_ai_assistant_api_base_interrupt_value.and(
    z.object({
      description: z.string().register(z.globalRegistry, {
        description: 'Description of action required',
      }),
      options: z
        .array(security_ai_assistant_api_select_option_interrupt_option)
        .register(z.globalRegistry, {
          description: 'List of actions to choose from',
        }),
      type: z.enum(['SELECT_OPTION']),
    })
  );

/**
 * Union of the interrupt values
 */
export const security_ai_assistant_api_interrupt_value = z.union([
  security_ai_assistant_api_select_option_interrupt_value,
  security_ai_assistant_api_input_text_interrupt_value,
]);

/**
 * Message metadata
 */
export const security_ai_assistant_api_message_metadata = z
  .object({
    contentReferences: z.optional(security_ai_assistant_api_content_references),
    interruptResumeValue: z.optional(security_ai_assistant_api_interrupt_resume_value),
    interruptValue: z.optional(security_ai_assistant_api_interrupt_value),
  })
  .register(z.globalRegistry, {
    description: 'Message metadata',
  });

/**
 * The order in which results are sorted.
 */
export const security_ai_assistant_api_sort_order = z
  .enum(['asc', 'desc'])
  .register(z.globalRegistry, {
    description: 'The order in which results are sorted.',
  });

/**
 * Trace Data
 */
export const security_ai_assistant_api_trace_data = z
  .object({
    traceId: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Could be any string, not necessarily a UUID',
      })
    ),
    transactionId: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Could be any string, not necessarily a UUID',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Trace Data',
  });

/**
 * Could be any string, not necessarily a UUID.
 */
export const security_ai_assistant_api_user = z
  .object({
    id: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'User id.',
      })
    ),
    name: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'User name.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Could be any string, not necessarily a UUID.',
  });

export const security_ai_assistant_api_index_entry = z
  .object({
    global: z.boolean().register(z.globalRegistry, {
      description: 'Whether this Knowledge Base Entry is global, defaults to false.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: 'Name of the Knowledge Base Entry.',
    }),
    namespace: z.string().register(z.globalRegistry, {
      description: "Kibana Space, defaults to 'default' space.",
    }),
    users: z.array(security_ai_assistant_api_user).register(z.globalRegistry, {
      description:
        'Users who have access to the Knowledge Base Entry, defaults to current user. Empty array provides access to all users.',
    }),
  })
  .and(security_ai_assistant_api_response_fields)
  .and(security_ai_assistant_api_index_entry_response_fields);

export const security_ai_assistant_api_index_entry_create_fields = z
  .object({
    global: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether this Knowledge Base Entry is global, defaults to false.',
      })
    ),
    name: z.string().register(z.globalRegistry, {
      description: 'Name of the Knowledge Base Entry.',
    }),
    namespace: z.optional(
      z.string().register(z.globalRegistry, {
        description: "Kibana Space, defaults to 'default' space.",
      })
    ),
    users: z.optional(
      z.array(security_ai_assistant_api_user).register(z.globalRegistry, {
        description:
          'Users who have access to the Knowledge Base Entry, defaults to current user. Empty array provides access to all users.',
      })
    ),
  })
  .and(security_ai_assistant_api_index_entry_required_fields)
  .and(security_ai_assistant_api_index_entry_optional_fields);

export const security_ai_assistant_api_index_entry_update_fields = z
  .object({
    global: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether this Knowledge Base Entry is global, defaults to false.',
      })
    ),
    id: security_ai_assistant_api_non_empty_string,
    name: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Name of the Knowledge Base Entry.',
      })
    ),
    namespace: z.optional(
      z.string().register(z.globalRegistry, {
        description: "Kibana Space, defaults to 'default' space.",
      })
    ),
    users: z.optional(
      z.array(security_ai_assistant_api_user).register(z.globalRegistry, {
        description:
          'Users who have access to the Knowledge Base Entry, defaults to current user. Empty array provides access to all users.',
      })
    ),
  })
  .and(security_ai_assistant_api_index_entry_create_fields);

/**
 * AI assistant conversation message.
 */
export const security_ai_assistant_api_message = z
  .object({
    content: z.string().register(z.globalRegistry, {
      description: 'Message content.',
    }),
    id: z.optional(security_ai_assistant_api_non_empty_string),
    isError: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Is error message.',
      })
    ),
    metadata: z.optional(security_ai_assistant_api_message_metadata),
    reader: z.optional(security_ai_assistant_api_reader),
    role: security_ai_assistant_api_message_role,
    timestamp: security_ai_assistant_api_non_empty_timestamp,
    traceData: z.optional(security_ai_assistant_api_trace_data),
    user: z.optional(security_ai_assistant_api_user),
  })
  .register(z.globalRegistry, {
    description: 'AI assistant conversation message.',
  });

export const security_ai_assistant_api_conversation_create_props = z.object({
  apiConfig: z.optional(security_ai_assistant_api_api_config),
  category: z.optional(security_ai_assistant_api_conversation_category),
  excludeFromLastConversationStorage: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Exclude from last conversation storage.',
    })
  ),
  id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The conversation id.',
    })
  ),
  messages: z.optional(
    z.array(security_ai_assistant_api_message).register(z.globalRegistry, {
      description: 'The conversation messages.',
    })
  ),
  replacements: z.optional(security_ai_assistant_api_replacements),
  title: z.string().register(z.globalRegistry, {
    description: 'The conversation title.',
  }),
});

export const security_ai_assistant_api_conversation_response = z.object({
  apiConfig: z.optional(security_ai_assistant_api_api_config),
  category: security_ai_assistant_api_conversation_category,
  createdAt: z.string().register(z.globalRegistry, {
    description: 'The time conversation was created.',
  }),
  createdBy: security_ai_assistant_api_user,
  excludeFromLastConversationStorage: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Exclude from last conversation storage.',
    })
  ),
  id: security_ai_assistant_api_non_empty_string,
  messages: z.optional(
    z.array(security_ai_assistant_api_message).register(z.globalRegistry, {
      description: 'The conversation messages.',
    })
  ),
  namespace: z.string().register(z.globalRegistry, {
    description: 'Kibana space',
  }),
  replacements: z.optional(security_ai_assistant_api_replacements),
  timestamp: z.optional(security_ai_assistant_api_non_empty_timestamp),
  title: z.string().register(z.globalRegistry, {
    description: 'The conversation title.',
  }),
  updatedAt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The last time conversation was updated.',
    })
  ),
  users: z.array(security_ai_assistant_api_user),
});

export const security_ai_assistant_api_conversation_update_props = z.object({
  apiConfig: z.optional(security_ai_assistant_api_api_config),
  category: z.optional(security_ai_assistant_api_conversation_category),
  excludeFromLastConversationStorage: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Exclude from last conversation storage.',
    })
  ),
  id: security_ai_assistant_api_non_empty_string,
  messages: z.optional(
    z.array(security_ai_assistant_api_message).register(z.globalRegistry, {
      description: 'The conversation messages.',
    })
  ),
  replacements: z.optional(security_ai_assistant_api_replacements),
  title: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The conversation title.',
    })
  ),
  users: z.optional(z.array(security_ai_assistant_api_user)),
});

export const security_ai_assistant_api_prompt_response = z.object({
  categories: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'Categories associated with the prompt.',
    })
  ),
  color: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The color associated with the prompt.',
    })
  ),
  consumer: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The consumer that the prompt is associated with.',
    })
  ),
  content: z.string().register(z.globalRegistry, {
    description: 'The content of the prompt.',
  }),
  createdAt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The timestamp of when the prompt was created.',
    })
  ),
  createdBy: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The user who created the prompt.',
    })
  ),
  id: security_ai_assistant_api_non_empty_string,
  isDefault: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this prompt is the default.',
    })
  ),
  isNewConversationDefault: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this prompt is the default for new conversations.',
    })
  ),
  name: z.string().register(z.globalRegistry, {
    description: 'The name of the prompt.',
  }),
  namespace: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Kibana space where the prompt is located.',
    })
  ),
  promptType: security_ai_assistant_api_prompt_type,
  timestamp: z.optional(security_ai_assistant_api_non_empty_timestamp),
  updatedAt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The timestamp of when the prompt was last updated.',
    })
  ),
  updatedBy: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The user who last updated the prompt.',
    })
  ),
  users: z.optional(
    z.array(security_ai_assistant_api_user).register(z.globalRegistry, {
      description: 'List of users associated with the prompt.',
    })
  ),
});

export const security_ai_assistant_api_prompts_bulk_crud_action_results = z.object({
  created: z.array(security_ai_assistant_api_prompt_response).register(z.globalRegistry, {
    description: 'List of prompts that were created.',
  }),
  deleted: z.array(z.string()).register(z.globalRegistry, {
    description: 'List of IDs of prompts that were deleted.',
  }),
  skipped: z
    .array(security_ai_assistant_api_prompts_bulk_action_skip_result)
    .register(z.globalRegistry, {
      description: 'List of prompts that were skipped.',
    }),
  updated: z.array(security_ai_assistant_api_prompt_response).register(z.globalRegistry, {
    description: 'List of prompts that were updated.',
  }),
});

export const security_ai_assistant_api_prompts_bulk_crud_action_response = z.object({
  attributes: z.object({
    errors: z.optional(z.array(security_ai_assistant_api_normalized_prompt_error)),
    results: security_ai_assistant_api_prompts_bulk_crud_action_results,
    summary: security_ai_assistant_api_bulk_crud_action_summary,
  }),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A message describing the result of the bulk action.',
    })
  ),
  prompts_count: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of prompts processed in the bulk action.',
    })
  ),
  status_code: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The HTTP status code of the response.',
    })
  ),
  success: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates if the bulk action was successful.',
    })
  ),
});

/**
 * Object containing Knowledge Base Entry text embeddings and modelId used to create the embeddings.
 */
export const security_ai_assistant_api_vector = z
  .object({
    modelId: z.string().register(z.globalRegistry, {
      description: 'ID of the model used to create the embeddings.',
    }),
    tokens: z.record(z.string(), z.number()).register(z.globalRegistry, {
      description: 'Tokens with their corresponding values.',
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Object containing Knowledge Base Entry text embeddings and modelId used to create the embeddings.',
  });

export const security_ai_assistant_api_document_entry_optional_fields = z.object({
  required: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this resource should always be included, defaults to false.',
    })
  ),
  vector: z.optional(security_ai_assistant_api_vector),
});

export const security_ai_assistant_api_document_entry_create_fields = z
  .object({
    global: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether this Knowledge Base Entry is global, defaults to false.',
      })
    ),
    name: z.string().register(z.globalRegistry, {
      description: 'Name of the Knowledge Base Entry.',
    }),
    namespace: z.optional(
      z.string().register(z.globalRegistry, {
        description: "Kibana Space, defaults to 'default' space.",
      })
    ),
    users: z.optional(
      z.array(security_ai_assistant_api_user).register(z.globalRegistry, {
        description:
          'Users who have access to the Knowledge Base Entry, defaults to current user. Empty array provides access to all users.',
      })
    ),
  })
  .and(security_ai_assistant_api_document_entry_required_fields)
  .and(security_ai_assistant_api_document_entry_optional_fields);

export const security_ai_assistant_api_document_entry_response_fields =
  security_ai_assistant_api_document_entry_required_fields.and(
    security_ai_assistant_api_document_entry_optional_fields
  );

export const security_ai_assistant_api_document_entry = z
  .object({
    global: z.boolean().register(z.globalRegistry, {
      description: 'Whether this Knowledge Base Entry is global, defaults to false.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: 'Name of the Knowledge Base Entry.',
    }),
    namespace: z.string().register(z.globalRegistry, {
      description: "Kibana Space, defaults to 'default' space.",
    }),
    users: z.array(security_ai_assistant_api_user).register(z.globalRegistry, {
      description:
        'Users who have access to the Knowledge Base Entry, defaults to current user. Empty array provides access to all users.',
    }),
  })
  .and(security_ai_assistant_api_response_fields)
  .and(security_ai_assistant_api_document_entry_response_fields);

export const security_ai_assistant_api_document_entry_update_fields = z
  .object({
    global: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether this Knowledge Base Entry is global, defaults to false.',
      })
    ),
    id: security_ai_assistant_api_non_empty_string,
    name: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Name of the Knowledge Base Entry.',
      })
    ),
    namespace: z.optional(
      z.string().register(z.globalRegistry, {
        description: "Kibana Space, defaults to 'default' space.",
      })
    ),
    users: z.optional(
      z.array(security_ai_assistant_api_user).register(z.globalRegistry, {
        description:
          'Users who have access to the Knowledge Base Entry, defaults to current user. Empty array provides access to all users.',
      })
    ),
  })
  .and(security_ai_assistant_api_document_entry_create_fields);

export const security_ai_assistant_api_knowledge_base_entry_create_props = z.union([
  z
    .object({
      type: z.optional(z.literal('Security_AI_Assistant_API_DocumentEntryCreateFields')),
    })
    .and(security_ai_assistant_api_document_entry_create_fields),
  z
    .object({
      type: z.optional(z.literal('Security_AI_Assistant_API_IndexEntryCreateFields')),
    })
    .and(security_ai_assistant_api_index_entry_create_fields),
]);

export const security_ai_assistant_api_knowledge_base_entry_response = z.union([
  z
    .object({
      type: z.optional(z.literal('Security_AI_Assistant_API_DocumentEntry')),
    })
    .and(security_ai_assistant_api_document_entry),
  z
    .object({
      type: z.optional(z.literal('Security_AI_Assistant_API_IndexEntry')),
    })
    .and(security_ai_assistant_api_index_entry),
]);

export const security_ai_assistant_api_knowledge_base_entry_bulk_crud_action_results = z.object({
  created: z
    .array(security_ai_assistant_api_knowledge_base_entry_response)
    .register(z.globalRegistry, {
      description: 'List of Knowledge Base Entries that were successfully created.',
    }),
  deleted: z.array(z.string()).register(z.globalRegistry, {
    description: 'List of IDs of Knowledge Base Entries that were successfully deleted.',
  }),
  skipped: z
    .array(security_ai_assistant_api_knowledge_base_entry_bulk_action_skip_result)
    .register(z.globalRegistry, {
      description: 'List of Knowledge Base Entries that were skipped during the bulk action.',
    }),
  updated: z
    .array(security_ai_assistant_api_knowledge_base_entry_response)
    .register(z.globalRegistry, {
      description: 'List of Knowledge Base Entries that were successfully updated.',
    }),
});

export const security_ai_assistant_api_knowledge_base_entry_bulk_crud_action_response = z.object({
  attributes: z.object({
    errors: z.optional(
      z
        .array(security_ai_assistant_api_normalized_knowledge_base_entry_error)
        .register(z.globalRegistry, {
          description: 'List of errors encountered during the bulk action.',
        })
    ),
    results: security_ai_assistant_api_knowledge_base_entry_bulk_crud_action_results,
    summary: security_ai_assistant_api_knowledge_base_entry_bulk_crud_action_summary,
  }),
  knowledgeBaseEntriesCount: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Total number of Knowledge Base Entries processed.',
    })
  ),
  message: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Message describing the result of the bulk action.',
    })
  ),
  statusCode: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'HTTP status code of the response.',
    })
  ),
  success: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the bulk action was successful.',
    })
  ),
});

export const security_ai_assistant_api_knowledge_base_entry_update_props = z.union([
  z
    .object({
      type: z.optional(z.literal('Security_AI_Assistant_API_DocumentEntryUpdateFields')),
    })
    .and(security_ai_assistant_api_document_entry_update_fields),
  z
    .object({
      type: z.optional(z.literal('Security_AI_Assistant_API_IndexEntryUpdateFields')),
    })
    .and(security_ai_assistant_api_index_entry_update_fields),
]);

export const security_ai_assistant_api_knowledge_base_entry_update_route_props = z.union([
  z
    .object({
      type: z.optional(z.literal('Security_AI_Assistant_API_DocumentEntryCreateFields')),
    })
    .and(security_ai_assistant_api_document_entry_create_fields),
  z
    .object({
      type: z.optional(z.literal('Security_AI_Assistant_API_IndexEntryCreateFields')),
    })
    .and(security_ai_assistant_api_index_entry_create_fields),
]);

export const security_attack_discovery_api_attack_discovery_api_schedule_action_alerts_filter =
  z.record(z.string(), z.unknown());

/**
 * Groups actions by use cases. Use `default` for alert notifications.
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_action_group = z
  .string()
  .register(z.globalRegistry, {
    description: 'Groups actions by use cases. Use `default` for alert notifications.',
  });

/**
 * The connector ID.
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_action_id = z
  .string()
  .register(z.globalRegistry, {
    description: 'The connector ID.',
  });

/**
 * The condition for throttling the notification: `onActionGroupChange`, `onActiveAlert`,  or `onThrottleInterval`
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_action_notify_when = z
  .enum(['onActiveAlert', 'onThrottleInterval', 'onActionGroupChange'])
  .register(z.globalRegistry, {
    description:
      'The condition for throttling the notification: `onActionGroupChange`, `onActiveAlert`,  or `onThrottleInterval`',
  });

/**
 * Object containing the allowed connector fields, which varies according to the connector type.
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_action_params = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'Object containing the allowed connector fields, which varies according to the connector type.',
  });

/**
 * Defines how often schedule actions are taken. Time interval in seconds, minutes, hours, or days.
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_action_throttle = z
  .string()
  .regex(/^[1-9]\d*[smhd]$/)
  .register(z.globalRegistry, {
    description:
      'Defines how often schedule actions are taken. Time interval in seconds, minutes, hours, or days.',
  });

/**
 * The action frequency defines when the action runs (for example, only on schedule execution or at specific time intervals).
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_action_frequency = z
  .object({
    notify_when: security_attack_discovery_api_attack_discovery_api_schedule_action_notify_when,
    summary: z.boolean().register(z.globalRegistry, {
      description:
        'Action summary indicates whether we will send a summary notification about all the generate alerts or notification per individual alert',
    }),
    throttle: security_attack_discovery_api_attack_discovery_api_schedule_action_throttle,
  })
  .register(z.globalRegistry, {
    description:
      'The action frequency defines when the action runs (for example, only on schedule execution or at specific time intervals).',
  });

/**
 * An attack discovery schedule execution status
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_execution_status = z
  .enum(['ok', 'active', 'error', 'unknown', 'warning'])
  .register(z.globalRegistry, {
    description: 'An attack discovery schedule execution status',
  });

/**
 * An attack discovery schedule execution information
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_execution = z
  .object({
    date: z.iso.datetime().register(z.globalRegistry, {
      description: 'Date of the execution',
    }),
    duration: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'Duration of the execution',
      })
    ),
    message: z.optional(z.string()),
    status: security_attack_discovery_api_attack_discovery_api_schedule_execution_status,
  })
  .register(z.globalRegistry, {
    description: 'An attack discovery schedule execution information',
  });

/**
 * Allowed field names to sort Attack discovery results by. Clients should only pass one of the listed values.
 */
export const security_attack_discovery_api_attack_discovery_find_sort_field = z
  .enum(['@timestamp'])
  .register(z.globalRegistry, {
    description:
      'Allowed field names to sort Attack discovery results by. Clients should only pass one of the listed values.',
  });

export const security_attack_discovery_api_attack_discovery_generation = z.object({
  alerts_context_count: z.optional(
    z.number().register(z.globalRegistry, {
      description:
        'The number of alerts sent as context (max kibana.alert.rule.execution.metrics.alert_counts.active) to the LLM for the generation',
    })
  ),
  connector_id: z.string().register(z.globalRegistry, {
    description: 'The connector id (event.dataset) for this generation',
  }),
  connector_stats: z.optional(
    z
      .object({
        average_successful_duration_nanoseconds: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'The average duration (avg event.duration) in nanoseconds of successful generations for the same connector id, for the current user',
          })
        ),
        successful_generations: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'The number of successful generations for the same connector id, for the current user',
          })
        ),
      })
      .register(z.globalRegistry, {
        description: 'Stats applicable to the connector for this generation',
      })
  ),
  discoveries: z.number().register(z.globalRegistry, {
    description:
      'The number of new Attack discovery alerts (max kibana.alert.rule.execution.metrics.alert_counts.new) for this generation',
  }),
  end: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'When generation ended (max event.end)',
    })
  ),
  execution_uuid: z.string().register(z.globalRegistry, {
    description: 'The unique identifier (kibana.alert.rule.execution.uuid) for the generation',
  }),
  loading_message: z.string().register(z.globalRegistry, {
    description: 'Generation loading message (kibana.alert.rule.execution.status)',
  }),
  reason: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Reason for failed generations (event.reason)',
    })
  ),
  start: z.string().register(z.globalRegistry, {
    description: 'When generation started (min event.start)',
  }),
  status: z
    .enum(['canceled', 'dismissed', 'failed', 'started', 'succeeded'])
    .register(z.globalRegistry, {
      description: 'The status of the attack discovery generation',
    }),
});

/**
 * Generic error response for Attack discovery schedule operations
 */
export const security_attack_discovery_api_attack_discovery_generic_error = z
  .object({
    error: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Error type',
      })
    ),
    message: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Human-readable error message describing what went wrong',
      })
    ),
    status_code: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'HTTP status code',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Generic error response for Attack discovery schedule operations',
  });

/**
 * The filter array used to define the conditions for when alerts are selected as an attack discovery context. Defaults to an empty array.
 */
export const security_attack_discovery_api_filters = z
  .array(z.unknown())
  .register(z.globalRegistry, {
    description:
      'The filter array used to define the conditions for when alerts are selected as an attack discovery context. Defaults to an empty array.',
  });

export const security_attack_discovery_api_interval_api_schedule = z.object({
  interval: z.string().register(z.globalRegistry, {
    description: 'The schedule interval',
  }),
});

/**
 * A string that does not contain only whitespace characters.
 */
export const security_attack_discovery_api_non_empty_string = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: 'A string that does not contain only whitespace characters.',
  });

export const security_attack_discovery_api_attack_discovery_api_schedule_general_action = z.object({
  action_type_id: z.string().register(z.globalRegistry, {
    description: 'The action type used for sending notifications.',
  }),
  alerts_filter: z.optional(
    security_attack_discovery_api_attack_discovery_api_schedule_action_alerts_filter
  ),
  frequency: z.optional(
    security_attack_discovery_api_attack_discovery_api_schedule_action_frequency
  ),
  group: security_attack_discovery_api_attack_discovery_api_schedule_action_group,
  id: security_attack_discovery_api_attack_discovery_api_schedule_action_id,
  params: security_attack_discovery_api_attack_discovery_api_schedule_action_params,
  uuid: z.optional(security_attack_discovery_api_non_empty_string),
});

export const security_attack_discovery_api_attack_discovery_api_schedule_system_action = z.object({
  action_type_id: z.string().register(z.globalRegistry, {
    description: 'The action type used for sending notifications.',
  }),
  id: security_attack_discovery_api_attack_discovery_api_schedule_action_id,
  params: security_attack_discovery_api_attack_discovery_api_schedule_action_params,
  uuid: z.optional(security_attack_discovery_api_non_empty_string),
});

export const security_attack_discovery_api_attack_discovery_api_schedule_action = z.union([
  security_attack_discovery_api_attack_discovery_api_schedule_general_action,
  security_attack_discovery_api_attack_discovery_api_schedule_system_action,
]);

/**
 * A string that represents a timestamp in ISO 8601 format and does not contain only whitespace characters.
 */
export const security_attack_discovery_api_non_empty_timestamp = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description:
      'A string that represents a timestamp in ISO 8601 format and does not contain only whitespace characters.',
  });

export const security_attack_discovery_api_anonymization_field_response = z.object({
  allowed: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this field is allowed to be sent to the model.',
    })
  ),
  anonymized: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether this field should be anonymized.',
    })
  ),
  createdAt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Timestamp of when the anonymization field was created.',
    })
  ),
  createdBy: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Username of the person who created the anonymization field.',
    })
  ),
  field: z.string().register(z.globalRegistry, {
    description: 'Name of the anonymization field.',
  }),
  id: security_attack_discovery_api_non_empty_string,
  namespace: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Kibana space in which this anonymization field exists.',
    })
  ),
  timestamp: z.optional(security_attack_discovery_api_non_empty_timestamp),
  updatedAt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Timestamp of the last update.',
    })
  ),
  updatedBy: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Username of the person who last updated the field.',
    })
  ),
});

/**
 * Provider
 */
export const security_attack_discovery_api_provider = z
  .enum(['OpenAI', 'Azure OpenAI', 'Other'])
  .register(z.globalRegistry, {
    description: 'Provider',
  });

export const security_attack_discovery_api_api_config = z.object({
  actionTypeId: z.string().register(z.globalRegistry, {
    description: 'Action type ID',
  }),
  connectorId: z.string().register(z.globalRegistry, {
    description: 'Connector ID',
  }),
  defaultSystemPromptId: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Default system prompt ID',
    })
  ),
  model: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Model',
    })
  ),
  provider: z.optional(security_attack_discovery_api_provider),
});

/**
 * An query condition to filter alerts
 */
export const security_attack_discovery_api_query = z
  .object({
    language: z.string(),
    query: z.union([z.string(), z.record(z.string(), z.unknown())]),
  })
  .register(z.globalRegistry, {
    description: 'An query condition to filter alerts',
  });

/**
 * An attack discovery schedule params
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_params = z
  .object({
    alerts_index_pattern: z.string().register(z.globalRegistry, {
      description: 'The index pattern to get alerts from',
    }),
    api_config: security_attack_discovery_api_api_config.and(
      z.object({
        name: z.string().register(z.globalRegistry, {
          description: 'The name of the connector',
        }),
      })
    ),
    combined_filter: z.optional(z.record(z.string(), z.unknown())),
    end: z.optional(z.string()),
    filters: z.optional(security_attack_discovery_api_filters),
    query: z.optional(security_attack_discovery_api_query),
    size: z.number(),
    start: z.optional(z.string()),
  })
  .register(z.globalRegistry, {
    description: 'An attack discovery schedule params',
  });

/**
 * An attack discovery schedule
 */
export const security_attack_discovery_api_attack_discovery_api_schedule = z
  .object({
    actions: z
      .array(security_attack_discovery_api_attack_discovery_api_schedule_action)
      .register(z.globalRegistry, {
        description: 'The attack discovery schedule actions',
      }),
    created_at: z.iso.datetime().register(z.globalRegistry, {
      description: 'The date the schedule was created',
    }),
    created_by: z.string().register(z.globalRegistry, {
      description: 'The name of the user that created the schedule',
    }),
    enabled: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the schedule is enabled',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'UUID of attack discovery schedule',
    }),
    last_execution: z.optional(
      security_attack_discovery_api_attack_discovery_api_schedule_execution
    ),
    name: z.string().register(z.globalRegistry, {
      description: 'The name of the schedule',
    }),
    params: security_attack_discovery_api_attack_discovery_api_schedule_params,
    schedule: security_attack_discovery_api_interval_api_schedule,
    updated_at: z.iso.datetime().register(z.globalRegistry, {
      description: 'The date the schedule was updated',
    }),
    updated_by: z.string().register(z.globalRegistry, {
      description: 'The name of the user that updated the schedule',
    }),
  })
  .register(z.globalRegistry, {
    description: 'An attack discovery schedule',
  });

/**
 * An attack discovery schedule create properties
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_create_props = z
  .object({
    actions: z.optional(
      z
        .array(security_attack_discovery_api_attack_discovery_api_schedule_action)
        .register(z.globalRegistry, {
          description: 'The attack discovery schedule actions',
        })
    ),
    enabled: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the schedule is enabled',
      })
    ),
    name: z.string().register(z.globalRegistry, {
      description: 'The name of the schedule',
    }),
    params: security_attack_discovery_api_attack_discovery_api_schedule_params,
    schedule: security_attack_discovery_api_interval_api_schedule,
  })
  .register(z.globalRegistry, {
    description: 'An attack discovery schedule create properties',
  });

/**
 * An attack discovery schedule update properties
 */
export const security_attack_discovery_api_attack_discovery_api_schedule_update_props = z
  .object({
    actions: z
      .array(security_attack_discovery_api_attack_discovery_api_schedule_action)
      .register(z.globalRegistry, {
        description: 'The attack discovery schedule actions',
      }),
    name: z.string().register(z.globalRegistry, {
      description: 'The name of the schedule',
    }),
    params: security_attack_discovery_api_attack_discovery_api_schedule_params,
    schedule: security_attack_discovery_api_interval_api_schedule,
  })
  .register(z.globalRegistry, {
    description: 'An attack discovery schedule update properties',
  });

/**
 * Replacements object used to anonymize/deanonymize messages
 */
export const security_attack_discovery_api_replacements = z
  .record(z.string(), z.string())
  .register(z.globalRegistry, {
    description: 'Replacements object used to anonymize/deanonymize messages',
  });

export const security_attack_discovery_api_attack_discovery_generation_config = z.object({
  alertsIndexPattern: z.string().register(z.globalRegistry, {
    description:
      'The (space specific) index pattern that contains the alerts to use as\ncontext for the attack discovery.\nExample: .alerts-security.alerts-default\n',
  }),
  anonymizationFields: z
    .array(security_attack_discovery_api_anonymization_field_response)
    .register(z.globalRegistry, {
      description:
        'The list of fields, and whether or not they are anonymized, allowed to be sent to LLMs. Consider using the output of the `/api/security_ai_assistant/anonymization_fields/_find` API (for a specific Kibana space) to provide this value.',
    }),
  apiConfig: security_attack_discovery_api_api_config,
  connectorName: z.optional(z.string()),
  end: z.optional(z.string()),
  filter: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'An Elasticsearch-style query DSL object used to filter alerts. For example:\n```json {\n  "filter": {\n    "bool": {\n      "must": [],\n      "filter": [\n        {\n          "bool": {\n            "should": [\n              {\n                "term": {\n                  "user.name": { "value": "james" }\n                }\n              }\n            ],\n            "minimum_should_match": 1\n          }\n        }\n      ],\n      "should": [],\n      "must_not": []\n    }\n  }\n} ```',
    })
  ),
  model: z.optional(z.string()),
  replacements: z.optional(security_attack_discovery_api_replacements),
  size: z.number(),
  start: z.optional(z.string()),
  subAction: z.enum(['invokeAI', 'invokeStream']),
});

/**
 * The order in which results are sorted.
 */
export const security_attack_discovery_api_sort_order = z
  .enum(['asc', 'desc'])
  .register(z.globalRegistry, {
    description: 'The order in which results are sorted.',
  });

/**
 * Could be any string, not necessarily a UUID.
 */
export const security_attack_discovery_api_user = z
  .object({
    id: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'User id.',
      })
    ),
    name: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'User name.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Could be any string, not necessarily a UUID.',
  });

/**
 * An attack discovery that's also an alert (Public API with snake_case)
 */
export const security_attack_discovery_api_attack_discovery_api_alert = z
  .object({
    alert_ids: z.array(z.string()).register(z.globalRegistry, {
      description: 'The alert IDs that the attack discovery is based on',
    }),
    alert_rule_uuid: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The optional kibana.alert.rule.uuid of the rule that generated this attack discovery (not applicable to ad hock runs)',
      })
    ),
    alert_start: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The optional time the attack discovery alert was created',
      })
    ),
    alert_updated_at: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The optional time the attack discovery alert was last updated',
      })
    ),
    alert_updated_by_user_id: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The optional id of the user who last updated the attack discovery alert',
      })
    ),
    alert_updated_by_user_name: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The optional username of the user who updated the attack discovery alert',
      })
    ),
    alert_workflow_status: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The optional kibana.alert.workflow_status of this attack discovery',
      })
    ),
    alert_workflow_status_updated_at: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The optional time the attack discovery alert workflow status was last updated',
      })
    ),
    connector_id: z.string().register(z.globalRegistry, {
      description: 'The ID of the connector that generated the attack discovery',
    }),
    connector_name: z.string().register(z.globalRegistry, {
      description: 'The (human readable) name of the connector that generated the attack discovery',
    }),
    details_markdown: z.string().register(z.globalRegistry, {
      description:
        'Details of the attack with bulleted markdown that always uses special syntax for field names and values from the source data.',
    }),
    entity_summary_markdown: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'An optional, short (no more than a sentence) summary of the attack discovery featuring only the host.name and user.name fields (when they are applicable), using the same syntax',
      })
    ),
    generation_uuid: z.string().register(z.globalRegistry, {
      description: 'The generation ID of the run that created the attack discovery',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The unique ID of the attack discovery',
    }),
    mitre_attack_tactics: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description: 'An optional array of MITRE ATT&CK tactic for the attack discovery',
      })
    ),
    replacements: z.optional(security_attack_discovery_api_replacements),
    risk_score: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'The optional, (but typically populated after generation) risk score of the alert',
      })
    ),
    summary_markdown: z.string().register(z.globalRegistry, {
      description: 'A markdown summary of attack discovery, using the same syntax',
    }),
    timestamp: security_attack_discovery_api_non_empty_timestamp,
    title: z.string().register(z.globalRegistry, {
      description: 'A title for the attack discovery, in plain text',
    }),
    user_id: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The optional id of the user who generated the attack discovery',
      })
    ),
    user_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The optional username of the user who generated the attack discovery, (not applicable to attack discoveries generated by rules)',
      })
    ),
    users: z.optional(
      z.array(security_attack_discovery_api_user).register(z.globalRegistry, {
        description:
          'The optional array of users who may view the attack discovery. When empty, (or not present), all users may view the attack discovery.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: "An attack discovery that's also an alert (Public API with snake_case)",
  });

export const security_detections_api_alert_assignees = z.object({
  add: z.array(
    z.string().min(1).register(z.globalRegistry, {
      description:
        'A list of user profile `uid`s to assign. Users need to activate their user profile by logging into Kibana at least once.',
    })
  ),
  remove: z.array(
    z.string().min(1).register(z.globalRegistry, {
      description:
        'A list of user profile `uid`s to unassign. Users need to activate their user profile by logging into Kibana at least once.',
    })
  ),
});

/**
 * A list of alerts `id`s.
 */
export const security_detections_api_alert_ids = z
  .array(z.string().min(1))
  .min(1)
  .register(z.globalRegistry, {
    description: 'A list of alerts `id`s.',
  });

/**
 * (deprecated) Has no effect.
 *
 * @deprecated
 */
export const security_detections_api_alerts_index = z.string().register(z.globalRegistry, {
  description: '(deprecated) Has no effect.',
});

export const security_detections_api_alerts_index_migration_error = z.object({
  error: z.object({
    message: z.string(),
    status_code: z.string(),
  }),
  index: z.string(),
});

export const security_detections_api_alerts_index_migration_success = z.object({
  index: z.string(),
  migration_id: z.string(),
  migration_index: z.string(),
});

/**
 * Has no effect.
 */
export const security_detections_api_alerts_index_namespace = z
  .string()
  .register(z.globalRegistry, {
    description: 'Has no effect.',
  });

export const security_detections_api_alerts_reindex_options = z.object({
  requests_per_second: z.optional(
    z.int().gte(1).register(z.globalRegistry, {
      description:
        'The throttle for the migration task in sub-requests per second. Corresponds to requests_per_second on the Reindex API.',
    })
  ),
  size: z.optional(
    z.int().gte(1).register(z.globalRegistry, {
      description:
        'Number of alerts to migrate per batch. Corresponds to the source.size option on the Reindex API.',
    })
  ),
  slices: z.optional(
    z.int().gte(1).register(z.globalRegistry, {
      description:
        'The number of subtasks for the migration task. Corresponds to slices on the Reindex API.',
    })
  ),
});

export const security_detections_api_alerts_sort_combinations = z.union([
  z.string(),
  z.record(z.string(), z.unknown()),
]);

export const security_detections_api_alerts_sort = z.union([
  security_detections_api_alerts_sort_combinations,
  z.array(security_detections_api_alerts_sort_combinations),
]);

/**
 * The status of an alert, which can be `open`, `acknowledged`, `in-progress`, or `closed`.
 */
export const security_detections_api_alert_status_except_closed = z
  .enum(['open', 'acknowledged', 'in-progress'])
  .register(z.globalRegistry, {
    description:
      'The status of an alert, which can be `open`, `acknowledged`, `in-progress`, or `closed`.',
  });

/**
 * Time unit
 */
export const security_detections_api_alert_suppression_duration_unit = z
  .enum(['s', 'm', 'h'])
  .register(z.globalRegistry, {
    description: 'Time unit',
  });

export const security_detections_api_alert_suppression_duration = z.object({
  unit: security_detections_api_alert_suppression_duration_unit,
  value: z.int().gte(1),
});

export const security_detections_api_alert_suppression_group_by = z.array(z.string()).min(1).max(3);

/**
 * Describes how alerts will be generated for documents with missing suppress by fields:
 * doNotSuppress - per each document a separate alert will be created
 * suppress - only alert will be created per suppress by bucket
 */
export const security_detections_api_alert_suppression_missing_fields_strategy = z
  .enum(['doNotSuppress', 'suppress'])
  .register(z.globalRegistry, {
    description:
      'Describes how alerts will be generated for documents with missing suppress by fields:\ndoNotSuppress - per each document a separate alert will be created\nsuppress - only alert will be created per suppress by bucket',
  });

/**
 * Defines alert suppression configuration.
 */
export const security_detections_api_alert_suppression = z
  .object({
    duration: z.optional(security_detections_api_alert_suppression_duration),
    group_by: security_detections_api_alert_suppression_group_by,
    missing_fields_strategy: z.optional(
      security_detections_api_alert_suppression_missing_fields_strategy
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines alert suppression configuration.',
  });

/**
 * Use alert tags to organize related alerts into categories that you can filter and group.
 */
export const security_detections_api_alert_tag = z.string().min(1).register(z.globalRegistry, {
  description:
    'Use alert tags to organize related alerts into categories that you can filter and group.',
});

/**
 * List of keywords to organize related alerts into categories that you can filter and group.
 */
export const security_detections_api_alert_tags = z
  .array(security_detections_api_alert_tag)
  .register(z.globalRegistry, {
    description:
      'List of keywords to organize related alerts into categories that you can filter and group.',
  });

export const security_detections_api_alert_version = z.object({
  count: z.int(),
  version: z.int(),
});

/**
 * Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100.
 */
export const security_detections_api_anomaly_threshold = z.int().gte(0).register(z.globalRegistry, {
  description:
    'Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100.',
});

/**
 * Determines if the rule acts as a building block. If yes, the value must be `default`.
 * By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
 * For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
 *
 */
export const security_detections_api_building_block_type = z.string().register(z.globalRegistry, {
  description:
    'Determines if the rule acts as a building block. If yes, the value must be `default`.\nBy default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.\nFor more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).\n',
});

export const security_detections_api_bulk_action_edit_payload_delete_alert_suppression = z.object({
  type: z.enum(['delete_alert_suppression']),
});

/**
 * Overwrites schedule of rules.
 *
 * - `set_schedule` sets a schedule for rules. If the same schedule already exists for a rule, no changes are made.
 *
 * Both `interval` and `lookback` have a format of "{integer}{time_unit}", where accepted time units are `s` for seconds, `m` for minutes, and `h` for hours. The integer must be positive and larger than 0. Examples: "45s", "30m", "6h"
 *
 */
export const security_detections_api_bulk_action_edit_payload_schedule = z
  .object({
    type: z.enum(['set_schedule']),
    value: z.object({
      interval: z
        .string()
        .regex(/^[1-9]\d*[smh]$/)
        .register(z.globalRegistry, {
          description:
            'Interval in which the rule runs. For example, `"1h"` means the rule runs every hour.',
        }),
      lookback: z
        .string()
        .regex(/^[1-9]\d*[smh]$/)
        .register(z.globalRegistry, {
          description:
            'Lookback time for the rules.\n\nAdditional look-back time that the rule analyzes. For example, "10m" means the rule analyzes the last 10 minutes of data in addition to the frequency interval.\n',
        }),
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Overwrites schedule of rules. \n\n- `set_schedule` sets a schedule for rules. If the same schedule already exists for a rule, no changes are made.\n\nBoth `interval` and `lookback` have a format of "{integer}{time_unit}", where accepted time units are `s` for seconds, `m` for minutes, and `h` for hours. The integer must be positive and larger than 0. Examples: "45s", "30m", "6h"\n',
  });

export const security_detections_api_bulk_action_edit_payload_set_alert_suppression = z.object({
  type: z.enum(['set_alert_suppression']),
  value: security_detections_api_alert_suppression,
});

export const security_detections_api_bulk_actions_dry_run_err_code = z.enum([
  'IMMUTABLE',
  'PREBUILT_CUSTOMIZATION_LICENSE',
  'MACHINE_LEARNING_AUTH',
  'MACHINE_LEARNING_INDEX_PATTERN',
  'ESQL_INDEX_PATTERN',
  'MANUAL_RULE_RUN_FEATURE',
  'MANUAL_RULE_RUN_DISABLED_RULE',
  'THRESHOLD_RULE_TYPE_IN_SUPPRESSION',
  'UNSUPPORTED_RULE_IN_SUPPRESSION_FOR_THRESHOLD',
  'RULE_FILL_GAPS_DISABLED_RULE',
]);

export const security_detections_api_bulk_delete_rules = z.object({
  action: z.enum(['delete']),
  gaps_range_end: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range end, valid only when query is provided',
    })
  ),
  gaps_range_start: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range start, valid only when query is provided',
    })
  ),
  ids: z.optional(
    z.array(z.string()).min(1).register(z.globalRegistry, {
      description:
        "Array of rule `id`s to which a bulk action will be applied. Do not use rule's `rule_id` here.\nOnly valid when query property is undefined.\n",
    })
  ),
  query: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Query to filter rules.',
    })
  ),
});

export const security_detections_api_bulk_disable_rules = z.object({
  action: z.enum(['disable']),
  gaps_range_end: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range end, valid only when query is provided',
    })
  ),
  gaps_range_start: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range start, valid only when query is provided',
    })
  ),
  ids: z.optional(
    z.array(z.string()).min(1).register(z.globalRegistry, {
      description:
        "Array of rule `id`s to which a bulk action will be applied. Do not use rule's `rule_id` here.\nOnly valid when query property is undefined.\n",
    })
  ),
  query: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Query to filter rules.',
    })
  ),
});

export const security_detections_api_bulk_duplicate_rules = z.object({
  action: z.enum(['duplicate']),
  duplicate: z.optional(
    z
      .object({
        include_exceptions: z.boolean().register(z.globalRegistry, {
          description: 'Whether to copy exceptions from the original rule',
        }),
        include_expired_exceptions: z.boolean().register(z.globalRegistry, {
          description: 'Whether to copy expired exceptions from the original rule',
        }),
      })
      .register(z.globalRegistry, {
        description: 'Duplicate object that describes applying an update action.',
      })
  ),
  gaps_range_end: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range end, valid only when query is provided',
    })
  ),
  gaps_range_start: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range start, valid only when query is provided',
    })
  ),
  ids: z.optional(
    z.array(z.string()).min(1).register(z.globalRegistry, {
      description:
        "Array of rule `id`s to which a bulk action will be applied. Do not use rule's `rule_id` here.\nOnly valid when query property is undefined.\n",
    })
  ),
  query: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Query to filter rules.',
    })
  ),
});

/**
 * A rule can only be skipped when the bulk action to be performed on it results in nothing being done. For example, if the `edit` action is used to add a tag to a rule that already has that tag, or to delete an index pattern that is not specified in a rule. Objects returned in `attributes.results.skipped` will only include rules' `id`, `name`, and `skip_reason`.
 */
export const security_detections_api_bulk_edit_action_summary = z
  .object({
    failed: z.int(),
    skipped: z.int(),
    succeeded: z.int(),
    total: z.int(),
  })
  .register(z.globalRegistry, {
    description:
      "A rule can only be skipped when the bulk action to be performed on it results in nothing being done. For example, if the `edit` action is used to add a tag to a rule that already has that tag, or to delete an index pattern that is not specified in a rule. Objects returned in `attributes.results.skipped` will only include rules' `id`, `name`, and `skip_reason`.",
  });

export const security_detections_api_bulk_edit_skip_reason = z.enum(['RULE_NOT_MODIFIED']);

export const security_detections_api_bulk_enable_rules = z.object({
  action: z.enum(['enable']),
  gaps_range_end: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range end, valid only when query is provided',
    })
  ),
  gaps_range_start: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range start, valid only when query is provided',
    })
  ),
  ids: z.optional(
    z.array(z.string()).min(1).register(z.globalRegistry, {
      description:
        "Array of rule `id`s to which a bulk action will be applied. Do not use rule's `rule_id` here.\nOnly valid when query property is undefined.\n",
    })
  ),
  query: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Query to filter rules.',
    })
  ),
});

export const security_detections_api_bulk_export_action_response = z.string();

export const security_detections_api_bulk_export_rules = z.object({
  action: z.enum(['export']),
  gaps_range_end: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range end, valid only when query is provided',
    })
  ),
  gaps_range_start: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range start, valid only when query is provided',
    })
  ),
  ids: z.optional(
    z.array(z.string()).min(1).register(z.globalRegistry, {
      description:
        "Array of rule `id`s to which a bulk action will be applied. Do not use rule's `rule_id` here.\nOnly valid when query property is undefined.\n",
    })
  ),
  query: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Query to filter rules.',
    })
  ),
});

export const security_detections_api_bulk_gaps_filling_skip_reason = z.enum(['NO_GAPS_TO_FILL']);

export const security_detections_api_bulk_action_skip_result = z.object({
  id: z.string(),
  name: z.optional(z.string()),
  skip_reason: z.union([
    security_detections_api_bulk_edit_skip_reason,
    security_detections_api_bulk_gaps_filling_skip_reason,
  ]),
});

export const security_detections_api_bulk_manual_rule_fill_gaps = z.object({
  action: z.enum(['fill_gaps']),
  fill_gaps: z
    .object({
      end_date: z.string().register(z.globalRegistry, {
        description: 'End date of the manual gap fill',
      }),
      start_date: z.string().register(z.globalRegistry, {
        description: 'Start date of the manual gap fill',
      }),
    })
    .register(z.globalRegistry, {
      description:
        'Object that describes applying a manual gap fill action for the specified time range.',
    }),
  gaps_range_end: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range end, valid only when query is provided',
    })
  ),
  gaps_range_start: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range start, valid only when query is provided',
    })
  ),
  ids: z.optional(
    z.array(z.string()).min(1).register(z.globalRegistry, {
      description:
        "Array of rule `id`s to which a bulk action will be applied. Do not use rule's `rule_id` here.\nOnly valid when query property is undefined.\n",
    })
  ),
  query: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Query to filter rules.',
    })
  ),
});

export const security_detections_api_bulk_manual_rule_run = z.object({
  action: z.enum(['run']),
  gaps_range_end: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range end, valid only when query is provided',
    })
  ),
  gaps_range_start: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range start, valid only when query is provided',
    })
  ),
  ids: z.optional(
    z.array(z.string()).min(1).register(z.globalRegistry, {
      description:
        "Array of rule `id`s to which a bulk action will be applied. Do not use rule's `rule_id` here.\nOnly valid when query property is undefined.\n",
    })
  ),
  query: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Query to filter rules.',
    })
  ),
  run: z
    .object({
      end_date: z.string().register(z.globalRegistry, {
        description: 'End date of the manual rule run',
      }),
      start_date: z.string().register(z.globalRegistry, {
        description: 'Start date of the manual rule run',
      }),
    })
    .register(z.globalRegistry, {
      description: 'Object that describes applying a manual rule run action.',
    }),
});

export const security_detections_api_concurrent_searches = z.int().gte(1);

export const security_detections_api_data_view_id = z.string();

export const security_detections_api_default_params = z.object({
  command: z.enum(['isolate']),
  comment: z.optional(z.string()),
});

/**
 * Map Osquery results columns or static values to Elastic Common Schema (ECS) fields. Example: "ecs_mapping": {"process.pid": {"field": "pid"}}
 */
export const security_detections_api_ecs_mapping = z
  .record(
    z.string(),
    z.object({
      field: z.optional(z.string()),
      value: z.optional(z.union([z.string(), z.array(z.string())])),
    })
  )
  .register(z.globalRegistry, {
    description:
      'Map Osquery results columns or static values to Elastic Common Schema (ECS) fields. Example: "ecs_mapping": {"process.pid": {"field": "pid"}}',
  });

export const security_detections_api_eql_query_language = z.enum(['eql']);

export const security_detections_api_esql_query_language = z.enum(['esql']);

export const security_detections_api_esql_rule_optional_fields = z.object({
  alert_suppression: z.optional(security_detections_api_alert_suppression),
});

export const security_detections_api_event_category_override = z.string();

/**
 * The exception type
 */
export const security_detections_api_exception_list_type = z
  .enum([
    'detection',
    'rule_default',
    'endpoint',
    'endpoint_trusted_apps',
    'endpoint_trusted_devices',
    'endpoint_events',
    'endpoint_host_isolation_exceptions',
    'endpoint_blocklists',
  ])
  .register(z.globalRegistry, {
    description: 'The exception type',
  });

/**
 * An array of customized field names  that is, fields that the user has modified from their base value. Defaults to an empty array.
 */
export const security_detections_api_external_rule_customized_fields = z
  .array(
    z.object({
      field_name: z.string().register(z.globalRegistry, {
        description: 'Name of a user-modified field in the rule object.',
      }),
    })
  )
  .register(z.globalRegistry, {
    description:
      'An array of customized field names  that is, fields that the user has modified from their base value. Defaults to an empty array.',
  });

/**
 * Determines whether an external/prebuilt rule has its original, unmodified version present when the calculation of its customization status is performed (`rule_source.is_customized` and `rule_source.customized_fields`).
 */
export const security_detections_api_external_rule_has_base_version = z
  .boolean()
  .register(z.globalRegistry, {
    description:
      'Determines whether an external/prebuilt rule has its original, unmodified version present when the calculation of its customization status is performed (`rule_source.is_customized` and `rule_source.customized_fields`).',
  });

export const security_detections_api_find_rules_sort_field = z.enum([
  'created_at',
  'createdAt',
  'enabled',
  'execution_summary.last_execution.date',
  'execution_summary.last_execution.metrics.execution_gap_duration_s',
  'execution_summary.last_execution.metrics.total_indexing_duration_ms',
  'execution_summary.last_execution.metrics.total_search_duration_ms',
  'execution_summary.last_execution.status',
  'name',
  'risk_score',
  'riskScore',
  'severity',
  'updated_at',
  'updatedAt',
]);

/**
 * Start date to use when checking if a term has been seen before. Supports relative dates  for example, now-30d will search the last 30 days of data when checking if a term is new. We do not recommend using absolute dates, which can cause issues with rule performance due to querying increasing amounts of data over time.
 */
export const security_detections_api_history_window_start = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description:
      'Start date to use when checking if a term has been seen before. Supports relative dates  for example, now-30d will search the last 30 days of data when checking if a term is new. We do not recommend using absolute dates, which can cause issues with rule performance due to querying increasing amounts of data over time.',
  });

/**
 * Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
 * > info
 * > This field is not supported for ES|QL rules.
 *
 */
export const security_detections_api_index_pattern_array = z
  .array(z.string())
  .register(z.globalRegistry, {
    description:
      'Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).\n> info\n> This field is not supported for ES|QL rules.\n',
  });

/**
 * Edits index patterns of rulesClient.
 *
 * - `add_index_patterns` adds index patterns to rules. If an index pattern already exists for a rule, no changes are made.
 * - `delete_index_patterns` removes index patterns from rules. If an index pattern does not exist for a rule, no changes are made.
 * - `set_index_patterns` sets index patterns for rules, overwriting any existing index patterns. If the set of index patterns is the same as the existing index patterns, no changes are made.
 *
 */
export const security_detections_api_bulk_action_edit_payload_index_patterns = z
  .object({
    overwrite_data_views: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Resets the data view for the rule.',
      })
    ),
    type: z.enum(['add_index_patterns', 'delete_index_patterns', 'set_index_patterns']),
    value: security_detections_api_index_pattern_array,
  })
  .register(z.globalRegistry, {
    description:
      'Edits index patterns of rulesClient.\n\n- `add_index_patterns` adds index patterns to rules. If an index pattern already exists for a rule, no changes are made.\n- `delete_index_patterns` removes index patterns from rules. If an index pattern does not exist for a rule, no changes are made.\n- `set_index_patterns` sets index patterns for rules, overwriting any existing index patterns. If the set of index patterns is the same as the existing index patterns, no changes are made.\n',
  });

/**
 * Type of rule source for internally sourced rules, i.e. created within the Kibana apps.
 */
export const security_detections_api_internal_rule_source = z
  .object({
    type: z.enum(['internal']),
  })
  .register(z.globalRegistry, {
    description:
      'Type of rule source for internally sourced rules, i.e. created within the Kibana apps.',
  });

/**
 * Notes to help investigate alerts produced by the rule.
 */
export const security_detections_api_investigation_guide = z.string().register(z.globalRegistry, {
  description: 'Notes to help investigate alerts produced by the rule.',
});

/**
 * Determines whether an external/prebuilt rule has been customized by the user (i.e. any of its fields have been modified and diverged from the base value).
 */
export const security_detections_api_is_external_rule_customized = z
  .boolean()
  .register(z.globalRegistry, {
    description:
      'Determines whether an external/prebuilt rule has been customized by the user (i.e. any of its fields have been modified and diverged from the base value).',
  });

/**
 * Type of rule source for externally sourced rules, i.e. rules that have an external source, such as the Elastic Prebuilt rules repo.
 */
export const security_detections_api_external_rule_source = z
  .object({
    customized_fields: security_detections_api_external_rule_customized_fields,
    has_base_version: security_detections_api_external_rule_has_base_version,
    is_customized: security_detections_api_is_external_rule_customized,
    type: z.enum(['external']),
  })
  .register(z.globalRegistry, {
    description:
      'Type of rule source for externally sourced rules, i.e. rules that have an external source, such as the Elastic Prebuilt rules repo.',
  });

/**
 * Determines whether the rule is enabled. Defaults to true.
 */
export const security_detections_api_is_rule_enabled = z.boolean().register(z.globalRegistry, {
  description: 'Determines whether the rule is enabled. Defaults to true.',
});

/**
 * This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
 *
 * @deprecated
 */
export const security_detections_api_is_rule_immutable = z.boolean().register(z.globalRegistry, {
  description:
    'This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.',
});

export const security_detections_api_items_per_search = z.int().gte(1);

export const security_detections_api_kql_query_language = z.enum(['kuery', 'lucene']);

/**
 * Machine learning job ID(s) the rule monitors for anomaly scores.
 */
export const security_detections_api_machine_learning_job_id = z.union([
  z.string(),
  z.array(z.string()).min(1),
]);

export const security_detections_api_machine_learning_rule_optional_fields = z.object({
  alert_suppression: z.optional(security_detections_api_alert_suppression),
});

export const security_detections_api_machine_learning_rule_patch_fields = z
  .object({
    anomaly_threshold: z.optional(security_detections_api_anomaly_threshold),
    machine_learning_job_id: z.optional(security_detections_api_machine_learning_job_id),
    type: z.optional(
      z.enum(['machine_learning']).register(z.globalRegistry, {
        description: 'Rule type',
      })
    ),
  })
  .and(security_detections_api_machine_learning_rule_optional_fields);

export const security_detections_api_machine_learning_rule_required_fields = z.object({
  anomaly_threshold: security_detections_api_anomaly_threshold,
  machine_learning_job_id: security_detections_api_machine_learning_job_id,
  type: z.enum(['machine_learning']).register(z.globalRegistry, {
    description: 'Rule type',
  }),
});

export const security_detections_api_machine_learning_rule_create_fields =
  security_detections_api_machine_learning_rule_required_fields.and(
    security_detections_api_machine_learning_rule_optional_fields
  );

export const security_detections_api_machine_learning_rule_response_fields =
  security_detections_api_machine_learning_rule_required_fields.and(
    security_detections_api_machine_learning_rule_optional_fields
  );

/**
 * Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
 * > info
 * > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
 *
 */
export const security_detections_api_max_signals = z
  .int()
  .gte(1)
  .register(z.globalRegistry, {
    description:
      'Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).\n> info\n> This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.\n',
  })
  .default(100);

export const security_detections_api_migration_cleanup_result = z.object({
  destinationIndex: z.string(),
  error: z.optional(
    z.object({
      message: z.string(),
      status_code: z.int(),
    })
  ),
  id: z.string(),
  sourceIndex: z.string(),
  status: z.enum(['success', 'failure', 'pending']),
  updated: z.iso.datetime(),
  version: z.string(),
});

export const security_detections_api_migration_finalization_result = z.object({
  completed: z.boolean(),
  destinationIndex: z.string(),
  error: z.optional(
    z.object({
      message: z.string(),
      status_code: z.int(),
    })
  ),
  id: z.string(),
  sourceIndex: z.string(),
  status: z.enum(['success', 'failure', 'pending']),
  updated: z.iso.datetime(),
  version: z.string(),
});

/**
 * Fields to monitor for new values.
 */
export const security_detections_api_new_terms_fields = z
  .array(z.string())
  .min(1)
  .max(3)
  .register(z.globalRegistry, {
    description: 'Fields to monitor for new values.',
  });

export const security_detections_api_new_terms_rule_defaultable_fields = z.object({
  language: z.optional(security_detections_api_kql_query_language),
});

/**
 * A string that does not contain only whitespace characters
 */
export const security_detections_api_non_empty_string = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: 'A string that does not contain only whitespace characters',
  });

/**
 * Schema for fields relating to investigation fields. These are user defined fields we use to highlight
 * in various features in the UI such as alert details flyout and exceptions auto-population from alert.
 *
 */
export const security_detections_api_investigation_fields = z
  .object({
    field_names: z.array(security_detections_api_non_empty_string).min(1),
  })
  .register(z.globalRegistry, {
    description:
      'Schema for fields relating to investigation fields. These are user defined fields we use to highlight\nin various features in the UI such as alert details flyout and exceptions auto-population from alert.\n',
  });

/**
 * Edits investigation fields of rules.
 *
 * - `add_investigation_fields` adds investigation fields to rules. If an investigation field already exists for a rule, no changes are made.
 * - `delete_investigation_fields` removes investigation fields from rules. If an investigation field does not exist for a rule, no changes are made.
 * - `set_investigation_fields` sets investigation fields for rules. If the set of investigation fields is the same as the existing investigation fields, no changes are made.
 *
 */
export const security_detections_api_bulk_action_edit_payload_investigation_fields = z
  .object({
    type: z.enum([
      'add_investigation_fields',
      'delete_investigation_fields',
      'set_investigation_fields',
    ]),
    value: security_detections_api_investigation_fields,
  })
  .register(z.globalRegistry, {
    description:
      'Edits investigation fields of rules.\n\n- `add_investigation_fields` adds investigation fields to rules. If an investigation field already exists for a rule, no changes are made.\n- `delete_investigation_fields` removes investigation fields from rules. If an investigation field does not exist for a rule, no changes are made.\n- `set_investigation_fields` sets investigation fields for rules. If the set of investigation fields is the same as the existing investigation fields, no changes are made.\n',
  });

export const security_detections_api_migration_status = z.object({
  id: security_detections_api_non_empty_string,
  status: z.enum(['success', 'failure', 'pending']),
  updated: z.iso.datetime(),
  version: z.int(),
});

export const security_detections_api_index_migration_status = z.object({
  index: security_detections_api_non_empty_string,
  is_outdated: z.boolean(),
  migrations: z.array(security_detections_api_migration_status),
  signal_versions: z.array(security_detections_api_alert_version),
  version: z.int(),
});

export const security_detections_api_osquery_query = z.object({
  ecs_mapping: z.optional(security_detections_api_ecs_mapping),
  id: z.string().register(z.globalRegistry, {
    description: 'Query ID',
  }),
  platform: z.optional(z.string()),
  query: z.string().register(z.globalRegistry, {
    description: 'Query to run',
  }),
  removed: z.optional(z.boolean()),
  snapshot: z.optional(z.boolean()),
  version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Query version',
    })
  ),
});

export const security_detections_api_osquery_params = z.object({
  ecs_mapping: z.optional(security_detections_api_ecs_mapping),
  pack_id: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'To specify a query pack, use the packId field. Example: "packId": "processes_elastic"',
    })
  ),
  queries: z.optional(z.array(security_detections_api_osquery_query)),
  query: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'To run a single query, use the query field and enter a SQL query. Example: "query": "SELECT * FROM processes;"',
    })
  ),
  saved_query_id: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'To run a saved query, use the saved_query_id field and specify the saved query ID. Example: "saved_query_id": "processes_elastic"',
    })
  ),
  timeout: z.optional(
    z.number().register(z.globalRegistry, {
      description:
        'A timeout period, in seconds, after which the query will stop running. Overwriting the default timeout allows you to support queries that require more time to complete. The default and minimum supported value is 60. The maximum supported value is 900. Example: "timeout": 120.',
    })
  ),
});

export const security_detections_api_osquery_response_action = z.object({
  action_type_id: z.enum(['.osquery']),
  params: security_detections_api_osquery_params,
});

export const security_detections_api_platform_error_response = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.int(),
});

export const security_detections_api_processes_params = z.object({
  command: z.enum(['kill-process', 'suspend-process']).register(z.globalRegistry, {
    description:
      'To run an endpoint response action, specify a value for the command field. Example: "command": "isolate"',
  }),
  comment: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Add a note that explains or describes the action. You can find your comment in the response actions history log. Example: "comment": "Check processes"',
    })
  ),
  config: z.object({
    field: z.string().register(z.globalRegistry, {
      description: 'Field to use instead of process.pid',
    }),
    overwrite: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to overwrite field with process.pid',
        })
      )
      .default(true),
  }),
});

export const security_detections_api_endpoint_response_action = z.object({
  action_type_id: z.enum(['.endpoint']),
  params: z.union([
    security_detections_api_default_params,
    security_detections_api_processes_params,
  ]),
});

export const security_detections_api_query_rule_required_fields = z.object({
  type: z.enum(['query']).register(z.globalRegistry, {
    description: 'Rule type',
  }),
});

/**
 * The reason for closing the alerts
 */
export const security_detections_api_reason_enum = z
  .enum([
    'false_positive',
    'duplicate',
    'true_positive',
    'benign_positive',
    'automated_closure',
    'other',
  ])
  .register(z.globalRegistry, {
    description: 'The reason for closing the alerts',
  });

export const security_detections_api_close_alerts_by_ids = z.object({
  reason: z.optional(security_detections_api_reason_enum),
  signal_ids: z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
    description:
      'List of alert ids. Use field `_id` on alert document or `kibana.alert.uuid`. Note: signals are a deprecated term for alerts.',
  }),
  status: z.enum(['closed']),
});

export const security_detections_api_close_alerts_by_query = z.object({
  conflicts: z.optional(z.enum(['abort', 'proceed'])),
  query: z.record(z.string(), z.unknown()),
  reason: z.optional(security_detections_api_reason_enum),
  status: z.enum(['closed']),
});

/**
 * Related integration is a potential dependency of a rule. It's assumed that if the user installs
 * one of the related integrations of a rule, the rule might start to work properly because it will
 * have source events (generated by this integration) potentially matching the rule's query.
 *
 * NOTE: Proper work is not guaranteed, because a related integration, if installed, can be
 * configured differently or generate data that is not necessarily relevant for this rule.
 *
 * Related integration is a combination of a Fleet package and (optionally) one of the
 * package's "integrations" that this package contains. It is represented by 3 properties:
 *
 * - `package`: name of the package (required, unique id)
 * - `version`: version of the package (required, semver-compatible)
 * - `integration`: name of the integration of this package (optional, id within the package)
 *
 * There are Fleet packages like `windows` that contain only one integration; in this case,
 * `integration` should be unspecified. There are also packages like `aws` and `azure` that contain
 * several integrations; in this case, `integration` should be specified.
 *
 */
export const security_detections_api_related_integration = z
  .object({
    integration: z.optional(security_detections_api_non_empty_string),
    package: security_detections_api_non_empty_string,
    version: security_detections_api_non_empty_string,
  })
  .register(z.globalRegistry, {
    description:
      "Related integration is a potential dependency of a rule. It's assumed that if the user installs\none of the related integrations of a rule, the rule might start to work properly because it will\nhave source events (generated by this integration) potentially matching the rule's query.\n\nNOTE: Proper work is not guaranteed, because a related integration, if installed, can be\nconfigured differently or generate data that is not necessarily relevant for this rule.\n\nRelated integration is a combination of a Fleet package and (optionally) one of the\npackage's \"integrations\" that this package contains. It is represented by 3 properties:\n\n- `package`: name of the package (required, unique id)\n- `version`: version of the package (required, semver-compatible)\n- `integration`: name of the integration of this package (optional, id within the package)\n\nThere are Fleet packages like `windows` that contain only one integration; in this case,\n`integration` should be unspecified. There are also packages like `aws` and `azure` that contain\nseveral integrations; in this case, `integration` should be specified.\n",
  });

export const security_detections_api_related_integration_array = z.array(
  security_detections_api_related_integration
);

/**
 * Describes an Elasticsearch field that is needed for the rule to function.
 *
 * Almost all types of Security rules check source event documents for a match to some kind of
 * query or filter. If a document has certain field with certain values, then it's a match and
 * the rule will generate an alert.
 *
 * Required field is an event field that must be present in the source indices of a given rule.
 *
 * @example
 * const standardEcsField: RequiredField = {
 * name: 'event.action',
 * type: 'keyword',
 * ecs: true,
 * };
 *
 * @example
 * const nonEcsField: RequiredField = {
 * name: 'winlog.event_data.AttributeLDAPDisplayName',
 * type: 'keyword',
 * ecs: false,
 * };
 *
 */
export const security_detections_api_required_field = z
  .object({
    ecs: z.boolean().register(z.globalRegistry, {
      description:
        'Indicates whether the field is ECS-compliant. This property is only present in responses. Its value is computed based on fields name and type.',
    }),
    name: z.string().min(1).register(z.globalRegistry, {
      description: 'Name of an Elasticsearch field',
    }),
    type: z.string().min(1).register(z.globalRegistry, {
      description: 'Type of the Elasticsearch field',
    }),
  })
  .register(z.globalRegistry, {
    description:
      "Describes an Elasticsearch field that is needed for the rule to function.\n\nAlmost all types of Security rules check source event documents for a match to some kind of\nquery or filter. If a document has certain field with certain values, then it's a match and\nthe rule will generate an alert.\n\nRequired field is an event field that must be present in the source indices of a given rule.\n\n@example\nconst standardEcsField: RequiredField = {\n  name: 'event.action',\n  type: 'keyword',\n  ecs: true,\n};\n\n@example\nconst nonEcsField: RequiredField = {\n  name: 'winlog.event_data.AttributeLDAPDisplayName',\n  type: 'keyword',\n  ecs: false,\n};\n",
  });

export const security_detections_api_required_field_array = z.array(
  security_detections_api_required_field
);

/**
 * Input parameters to create a RequiredField. Does not include the `ecs` field, because `ecs` is calculated on the backend based on the field name and type.
 */
export const security_detections_api_required_field_input = z
  .object({
    name: z.string().min(1).register(z.globalRegistry, {
      description: 'Name of an Elasticsearch field',
    }),
    type: z.string().min(1).register(z.globalRegistry, {
      description: 'Type of the Elasticsearch field',
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Input parameters to create a RequiredField. Does not include the `ecs` field, because `ecs` is calculated on the backend based on the field name and type.',
  });

export const security_detections_api_response_action = z.union([
  security_detections_api_osquery_response_action,
  security_detections_api_endpoint_response_action,
]);

/**
 * A numerical representation of the alert's severity from 0 to 100, where:
 * * `0` - `21` represents low severity
 * * `22` - `47` represents medium severity
 * * `48` - `73` represents high severity
 * * `74` - `100` represents critical severity
 *
 */
export const security_detections_api_risk_score = z
  .int()
  .gte(0)
  .lte(100)
  .register(z.globalRegistry, {
    description:
      "A numerical representation of the alert's severity from 0 to 100, where:\n* `0` - `21` represents low severity\n* `22` - `47` represents medium severity\n* `48` - `73` represents high severity\n* `74` - `100` represents critical severity\n",
  });

/**
 * Overrides generated alerts' risk_score with a value from the source event
 */
export const security_detections_api_risk_score_mapping = z
  .array(
    z.object({
      field: z.string().register(z.globalRegistry, {
        description: 'Source event field used to override the default `risk_score`.',
      }),
      operator: z.enum(['equals']),
      risk_score: z.optional(security_detections_api_risk_score),
      value: z.string(),
    })
  )
  .register(z.globalRegistry, {
    description: "Overrides generated alerts' risk_score with a value from the source event",
  });

/**
 * Object containing an actions conditional filters.
 *
 * - `timeframe` (object, optional): Object containing the time frame for when this action can be run.
 * - `days` (array of integers, required): List of days of the week on which this action will be run. Days of the week are expressed as numbers between `1-7`, where `1` is Monday and `7` is Sunday. To select all days of the week, enter an empty array.
 * - `hours` (object, required): The hours of the day during which this action will run. Hours of the day are expressed as two strings in the format `hh:mm` in `24` hour time. A start of `00:00` and an end of `24:00` means the action can run all day.
 * - start (string, required): Start time in `hh:mm` format.
 * - end (string, required): End time in `hh:mm` format.
 * - `timezone` (string, required): An ISO timezone name, such as `Europe/Madrid` or `America/New_York`. Specific offsets such as `UTC` or `UTC+1` will also work, but lack built-in DST.
 * - `query` (object, optional): Object containing a query filter which gets applied to an action and determines whether the action should run.
 * - `kql` (string, required): A KQL string.
 * - `filters` (array of objects, required): Array of filter objects, as defined in the `kbn-es-query` package.
 *
 */
export const security_detections_api_rule_action_alerts_filter = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'Object containing an actions conditional filters.\n\n- `timeframe` (object, optional): Object containing the time frame for when this action can be run.\n    - `days` (array of integers, required): List of days of the week on which this action will be run. Days of the week are expressed as numbers between `1-7`, where `1` is Monday and `7` is Sunday. To select all days of the week, enter an empty array.\n    - `hours` (object, required): The hours of the day during which this action will run. Hours of the day are expressed as two strings in the format `hh:mm` in `24` hour time. A start of `00:00` and an end of `24:00` means the action can run all day.\n        - start (string, required): Start time in `hh:mm` format.\n        - end (string, required): End time in `hh:mm` format.\n    - `timezone` (string, required): An ISO timezone name, such as `Europe/Madrid` or `America/New_York`. Specific offsets such as `UTC` or `UTC+1` will also work, but lack built-in DST.\n- `query` (object, optional): Object containing a query filter which gets applied to an action and determines whether the action should run.\n    - `kql` (string, required): A KQL string.\n    - `filters` (array of objects, required): Array of filter objects, as defined in the `kbn-es-query` package.\n',
  });

/**
 * Optionally groups actions by use cases. Use `default` for alert notifications.
 */
export const security_detections_api_rule_action_group = z.string().register(z.globalRegistry, {
  description: 'Optionally groups actions by use cases. Use `default` for alert notifications.',
});

/**
 * The connector ID.
 */
export const security_detections_api_rule_action_id = z.string().register(z.globalRegistry, {
  description: 'The connector ID.',
});

/**
 * Defines how often rules run actions.
 */
export const security_detections_api_rule_action_notify_when = z
  .enum(['onActiveAlert', 'onThrottleInterval', 'onActionGroupChange'])
  .register(z.globalRegistry, {
    description: 'Defines how often rules run actions.',
  });

/**
 * Object containing the allowed connector fields, which varies according to the connector type.
 *
 * For Slack:
 *
 * - `message` (string, required): The notification message.
 *
 * For email:
 *
 * - `to`, `cc`, `bcc` (string): Email addresses to which the notifications are sent. At least one field must have a value.
 * - `subject` (string, optional): Email subject line.
 * - `message` (string, required): Email body text.
 *
 * For Webhook:
 *
 * - `body` (string, required): JSON payload.
 *
 * For PagerDuty:
 *
 * - `severity` (string, required): Severity of on the alert notification, can be: `Critical`, `Error`, `Warning` or `Info`.
 * - `eventAction` (string, required): Event [action type](https://v2.developer.pagerduty.com/docs/events-api-v2#event-action), which can be `trigger`, `resolve`, or `acknowledge`.
 * - `dedupKey` (string, optional): Groups alert notifications with the same PagerDuty alert.
 * - `timestamp` (DateTime, optional): ISO-8601 format [timestamp](https://v2.developer.pagerduty.com/docs/types#datetime).
 * - `component` (string, optional): Source machine component responsible for the event, for example `security-solution`.
 * - `group` (string, optional): Enables logical grouping of service components.
 * - `source` (string, optional): The affected system. Defaults to the Kibana saved object ID of the action.
 * - `summary` (string, options): Summary of the event. Defaults to `No summary provided`. Maximum length is 1024 characters.
 * - `class` (string, optional): Value indicating the class/type of the event.
 *
 */
export const security_detections_api_rule_action_params = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'Object containing the allowed connector fields, which varies according to the connector type.\n\nFor Slack:\n\n  - `message` (string, required): The notification message.\n\nFor email:\n\n  - `to`, `cc`, `bcc` (string): Email addresses to which the notifications are sent. At least one field must have a value.\n  - `subject` (string, optional): Email subject line.\n  - `message` (string, required): Email body text.\n\nFor Webhook:\n\n  - `body` (string, required): JSON payload.\n\nFor PagerDuty:\n\n  - `severity` (string, required): Severity of on the alert notification, can be: `Critical`, `Error`, `Warning` or `Info`.\n  - `eventAction` (string, required): Event [action type](https://v2.developer.pagerduty.com/docs/events-api-v2#event-action), which can be `trigger`, `resolve`, or `acknowledge`.\n  - `dedupKey` (string, optional): Groups alert notifications with the same PagerDuty alert.\n  - `timestamp` (DateTime, optional): ISO-8601 format [timestamp](https://v2.developer.pagerduty.com/docs/types#datetime).\n  - `component` (string, optional): Source machine component responsible for the event, for example `security-solution`.\n  - `group` (string, optional): Enables logical grouping of service components.\n  - `source` (string, optional): The affected system. Defaults to the Kibana saved object ID of the action.\n  - `summary` (string, options): Summary of the event. Defaults to `No summary provided`. Maximum length is 1024 characters.\n  - `class` (string, optional): Value indicating the class/type of the event.\n',
  });

/**
 * Defines how often rule actions are taken.
 */
export const security_detections_api_rule_action_throttle = z.union([
  z.literal('no_actions'),
  z.literal('rule'),
  z
    .string()
    .regex(/^[1-9]\d*[smhd]$/)
    .register(z.globalRegistry, {
      description: 'Time interval in seconds, minutes, hours, or days.',
    }),
]);

/**
 * The action frequency defines when the action runs (for example, only on rule execution or at specific time intervals).
 */
export const security_detections_api_rule_action_frequency = z
  .object({
    notifyWhen: security_detections_api_rule_action_notify_when,
    summary: z.boolean().register(z.globalRegistry, {
      description:
        'Action summary indicates whether we will send a summary notification about all the generate alerts or notification per individual alert',
    }),
    throttle: security_detections_api_rule_action_throttle,
  })
  .register(z.globalRegistry, {
    description:
      'The action frequency defines when the action runs (for example, only on rule execution or at specific time intervals).',
  });

export const security_detections_api_normalized_rule_action = z.object({
  alerts_filter: z.optional(security_detections_api_rule_action_alerts_filter),
  frequency: z.optional(security_detections_api_rule_action_frequency),
  group: z.optional(security_detections_api_rule_action_group),
  id: security_detections_api_rule_action_id,
  params: security_detections_api_rule_action_params,
});

export const security_detections_api_rule_action = z.object({
  action_type_id: z.string().register(z.globalRegistry, {
    description:
      'The action type used for sending notifications, can be:\n\n  - `.slack`\n  - `.slack_api`\n  - `.email`\n  - `.index`\n  - `.pagerduty`\n  - `.swimlane`\n  - `.webhook`\n  - `.servicenow`\n  - `.servicenow-itom`\n  - `.servicenow-sir`\n  - `.jira`\n  - `.resilient`\n  - `.opsgenie`\n  - `.teams`\n  - `.torq`\n  - `.tines`\n  - `.d3security`\n',
  }),
  alerts_filter: z.optional(security_detections_api_rule_action_alerts_filter),
  frequency: z.optional(security_detections_api_rule_action_frequency),
  group: z.optional(security_detections_api_rule_action_group),
  id: security_detections_api_rule_action_id,
  params: security_detections_api_rule_action_params,
  uuid: z.optional(security_detections_api_non_empty_string),
});

/**
 * The rules author.
 */
export const security_detections_api_rule_author_array = z
  .array(z.string())
  .register(z.globalRegistry, {
    description: 'The rules author.',
  });

/**
 * The rules description.
 */
export const security_detections_api_rule_description = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: 'The rules description.',
  });

export const security_detections_api_rule_details_in_error = z.object({
  id: z.string(),
  name: z.optional(z.string()),
});

export const security_detections_api_normalized_rule_error = z.object({
  err_code: z.optional(security_detections_api_bulk_actions_dry_run_err_code),
  message: z.string(),
  rules: z.array(security_detections_api_rule_details_in_error),
  status_code: z.int(),
});

/**
 * Array of [exception containers](https://www.elastic.co/guide/en/security/current/exceptions-api-overview.html), which define exceptions that prevent the rule from generating alerts even when its other criteria are met.
 *
 */
export const security_detections_api_rule_exception_list = z
  .object({
    id: z.string().min(1).register(z.globalRegistry, {
      description: 'ID of the exception container',
    }),
    list_id: z.string().min(1).register(z.globalRegistry, {
      description: 'List ID of the exception container',
    }),
    namespace_type: z.enum(['agnostic', 'single']).register(z.globalRegistry, {
      description: "Determines the exceptions validity in rule's Kibana space",
    }),
    type: security_detections_api_exception_list_type,
  })
  .register(z.globalRegistry, {
    description:
      'Array of [exception containers](https://www.elastic.co/guide/en/security/current/exceptions-api-overview.html), which define exceptions that prevent the rule from generating alerts even when its other criteria are met.\n',
  });

export const security_detections_api_rule_execution_metrics = z.object({
  execution_gap_duration_s: z.optional(
    z.int().gte(0).register(z.globalRegistry, {
      description: 'Duration in seconds of execution gap',
    })
  ),
  frozen_indices_queried_count: z.optional(
    z.int().gte(0).register(z.globalRegistry, {
      description:
        'Count of frozen indices queried during the rule execution. These indices could not be entirely excluded after applying the time range filter.',
    })
  ),
  gap_range: z.optional(
    z
      .object({
        gte: z.string().register(z.globalRegistry, {
          description: 'Start date of the execution gap',
        }),
        lte: z.string().register(z.globalRegistry, {
          description: 'End date of the execution gap',
        }),
      })
      .register(z.globalRegistry, {
        description: 'Range of the execution gap',
      })
  ),
  total_enrichment_duration_ms: z.optional(
    z.int().gte(0).register(z.globalRegistry, {
      description: 'Total time spent enriching documents during current rule execution cycle',
    })
  ),
  total_indexing_duration_ms: z.optional(
    z.int().gte(0).register(z.globalRegistry, {
      description: 'Total time spent indexing documents during current rule execution cycle',
    })
  ),
  total_search_duration_ms: z.optional(
    z.int().gte(0).register(z.globalRegistry, {
      description:
        'Total time spent performing ES searches as measured by Kibana; includes network latency and time spent serializing/deserializing request/response',
    })
  ),
});

/**
 * Custom execution status of Security rules that is different from the status used in the Alerting Framework. We merge our custom status with the Framework's status to determine the resulting status of a rule.
 * - going to run - @deprecated Replaced by the 'running' status but left for backwards compatibility with rule execution events already written to Event Log in the prior versions of Kibana. Don't use when writing rule status changes.
 * - running - Rule execution started but not reached any intermediate or final status.
 * - partial failure - Rule can partially fail for various reasons either in the middle of an execution (in this case we update its status right away) or in the end of it. So currently this status can be both intermediate and final at the same time. A typical reason for a partial failure: not all the indices that the rule searches over actually exist.
 * - failed - Rule failed to execute due to unhandled exception or a reason defined in the business logic of its executor function.
 * - succeeded - Rule executed successfully without any issues. Note: this status is just an indication of a rule's "health". The rule might or might not generate any alerts despite of it.
 */
export const security_detections_api_rule_execution_status = z
  .enum(['going to run', 'running', 'partial failure', 'failed', 'succeeded'])
  .register(z.globalRegistry, {
    description:
      "Custom execution status of Security rules that is different from the status used in the Alerting Framework. We merge our custom status with the Framework's status to determine the resulting status of a rule.\n- going to run - @deprecated Replaced by the 'running' status but left for backwards compatibility with rule execution events already written to Event Log in the prior versions of Kibana. Don't use when writing rule status changes.\n- running - Rule execution started but not reached any intermediate or final status.\n- partial failure - Rule can partially fail for various reasons either in the middle of an execution (in this case we update its status right away) or in the end of it. So currently this status can be both intermediate and final at the same time. A typical reason for a partial failure: not all the indices that the rule searches over actually exist.\n- failed - Rule failed to execute due to unhandled exception or a reason defined in the business logic of its executor function.\n- succeeded - Rule executed successfully without any issues. Note: this status is just an indication of a rule's \"health\". The rule might or might not generate any alerts despite of it.",
  });

export const security_detections_api_rule_execution_status_order = z.int();

/**
 * Summary of the last execution of a rule.
 * > info
 * > This field is under development and its usage or schema may change
 *
 */
export const security_detections_api_rule_execution_summary = z
  .object({
    last_execution: z.object({
      date: z.iso.datetime().register(z.globalRegistry, {
        description: 'Date of the last execution',
      }),
      message: z.string(),
      metrics: security_detections_api_rule_execution_metrics,
      status: security_detections_api_rule_execution_status,
      status_order: security_detections_api_rule_execution_status_order,
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Summary of the last execution of a rule.\n> info\n> This field is under development and its usage or schema may change\n',
  });

/**
 * String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
 */
export const security_detections_api_rule_false_positive_array = z
  .array(z.string())
  .register(z.globalRegistry, {
    description:
      'String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.',
  });

/**
 * The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
 * > info
 * > This field is not supported for ES|QL rules.
 *
 */
export const security_detections_api_rule_filter_array = z
  .array(z.unknown())
  .register(z.globalRegistry, {
    description:
      'The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.\n> info\n> This field is not supported for ES|QL rules.\n',
  });

export const security_detections_api_new_terms_rule_optional_fields = z.object({
  alert_suppression: z.optional(security_detections_api_alert_suppression),
  data_view_id: z.optional(security_detections_api_data_view_id),
  filters: z.optional(security_detections_api_rule_filter_array),
  index: z.optional(security_detections_api_index_pattern_array),
});

/**
 * Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
 */
export const security_detections_api_rule_interval = z.string().register(z.globalRegistry, {
  description:
    'Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).',
});

/**
 * Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
 */
export const security_detections_api_rule_interval_from = z.string().register(z.globalRegistry, {
  description:
    'Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).',
});

export const security_detections_api_rule_interval_to = z.string();

/**
 * The rule's license.
 */
export const security_detections_api_rule_license = z.string().register(z.globalRegistry, {
  description: "The rule's license.",
});

/**
 * Placeholder for metadata about the rule.
 * > info
 * > This field is overwritten when you save changes to the rules settings.
 *
 */
export const security_detections_api_rule_metadata = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'Placeholder for metadata about the rule.\n> info\n> This field is overwritten when you save changes to the rules settings.\n',
  });

/**
 * A human-readable name for the rule.
 */
export const security_detections_api_rule_name = z.string().min(1).register(z.globalRegistry, {
  description: 'A human-readable name for the rule.',
});

/**
 * Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
 */
export const security_detections_api_rule_name_override = z.string().register(z.globalRegistry, {
  description:
    "Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.",
});

export const security_detections_api_rule_preview_logged_request = z.object({
  description: z.optional(security_detections_api_non_empty_string),
  duration: z.optional(z.int()),
  request: z.optional(security_detections_api_non_empty_string),
  request_type: z.optional(security_detections_api_non_empty_string),
});

export const security_detections_api_rule_preview_logs = z.object({
  duration: z.int().register(z.globalRegistry, {
    description: 'Execution duration in milliseconds',
  }),
  errors: z.array(security_detections_api_non_empty_string),
  requests: z.optional(z.array(security_detections_api_rule_preview_logged_request)),
  startedAt: z.optional(security_detections_api_non_empty_string),
  warnings: z.array(security_detections_api_non_empty_string),
});

export const security_detections_api_rule_preview_params = z.object({
  invocationCount: z.int(),
  timeframeEnd: z.iso.datetime(),
});

/**
 * [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
 *
 * - For indicator match rules, only the querys results are used to determine whether an alert is generated.
 * - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
 *
 */
export const security_detections_api_rule_query = z.string().register(z.globalRegistry, {
  description:
    '[Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.\n\n- For indicator match rules, only the querys results are used to determine whether an alert is generated.\n- ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.\n',
});

export const security_detections_api_eql_required_fields = z.object({
  language: security_detections_api_eql_query_language,
  query: security_detections_api_rule_query,
  type: z.enum(['eql']).register(z.globalRegistry, {
    description: 'Rule type',
  }),
});

export const security_detections_api_esql_rule_required_fields = z.object({
  language: security_detections_api_esql_query_language,
  query: security_detections_api_rule_query,
  type: z.enum(['esql']).register(z.globalRegistry, {
    description: 'Rule type',
  }),
});

export const security_detections_api_esql_rule_create_fields =
  security_detections_api_esql_rule_optional_fields.and(
    security_detections_api_esql_rule_required_fields
  );

export const security_detections_api_esql_rule_response_fields =
  security_detections_api_esql_rule_optional_fields.and(
    security_detections_api_esql_rule_required_fields
  );

export const security_detections_api_new_terms_rule_patch_fields = z
  .object({
    history_window_start: z.optional(security_detections_api_history_window_start),
    new_terms_fields: z.optional(security_detections_api_new_terms_fields),
    query: z.optional(security_detections_api_rule_query),
    type: z.optional(
      z.enum(['new_terms']).register(z.globalRegistry, {
        description: 'Rule type',
      })
    ),
  })
  .and(security_detections_api_new_terms_rule_optional_fields)
  .and(security_detections_api_new_terms_rule_defaultable_fields);

export const security_detections_api_new_terms_rule_required_fields = z.object({
  history_window_start: security_detections_api_history_window_start,
  new_terms_fields: security_detections_api_new_terms_fields,
  query: security_detections_api_rule_query,
  type: z.enum(['new_terms']).register(z.globalRegistry, {
    description: 'Rule type',
  }),
});

export const security_detections_api_new_terms_rule_create_fields =
  security_detections_api_new_terms_rule_required_fields
    .and(security_detections_api_new_terms_rule_optional_fields)
    .and(security_detections_api_new_terms_rule_defaultable_fields);

export const security_detections_api_new_terms_rule_response_fields =
  security_detections_api_new_terms_rule_required_fields
    .and(security_detections_api_new_terms_rule_optional_fields)
    .and(
      z.object({
        language: security_detections_api_kql_query_language,
      })
    );

export const security_detections_api_query_rule_defaultable_fields = z.object({
  language: z.optional(security_detections_api_kql_query_language),
  query: z.optional(security_detections_api_rule_query),
});

/**
 * Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
 */
export const security_detections_api_rule_reference_array = z
  .array(z.string())
  .register(z.globalRegistry, {
    description:
      'Array containing notes about or references to relevant information about the rule. Defaults to an empty array.',
  });

/**
 * The rule's revision number.
 *
 * It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
 * > info
 * > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
 *
 */
export const security_detections_api_rule_revision = z.int().gte(0).register(z.globalRegistry, {
  description:
    "The rule's revision number.\n\nIt represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.\n> info\n> Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.\n",
});

/**
 * A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
 */
export const security_detections_api_rule_signature_id = z.string().register(z.globalRegistry, {
  description:
    'A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.',
});

export const security_detections_api_error_schema = z.object({
  error: z.object({
    message: z.string(),
    status_code: z.int().gte(400),
  }),
  id: z.optional(z.string()),
  item_id: z.optional(z.string().min(1)),
  list_id: z.optional(z.string().min(1)),
  rule_id: z.optional(security_detections_api_rule_signature_id),
});

/**
 * Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
 */
export const security_detections_api_rule_source = z.union([
  z
    .object({
      type: z.literal('Security_Detections_API_ExternalRuleSource'),
    })
    .and(security_detections_api_external_rule_source),
  z
    .object({
      type: z.literal('Security_Detections_API_InternalRuleSource'),
    })
    .and(security_detections_api_internal_rule_source),
]);

/**
 * String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
 */
export const security_detections_api_rule_tag_array = z
  .array(z.string())
  .register(z.globalRegistry, {
    description:
      'String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.',
  });

/**
 * Edits tags of rules.
 *
 * - `add_tags` adds tags to rules. If a tag already exists for a rule, no changes are made.
 * - `delete_tags` removes tags from rules. If a tag does not exist for a rule, no changes are made.
 * - `set_tags` sets tags for rules, overwriting any existing tags. If the set of tags is the same as the existing tags, no changes are made.
 *
 */
export const security_detections_api_bulk_action_edit_payload_tags = z
  .object({
    type: z.enum(['add_tags', 'delete_tags', 'set_tags']),
    value: security_detections_api_rule_tag_array,
  })
  .register(z.globalRegistry, {
    description:
      'Edits tags of rules.\n\n- `add_tags` adds tags to rules. If a tag already exists for a rule, no changes are made.\n- `delete_tags` removes tags from rules. If a tag does not exist for a rule, no changes are made.\n- `set_tags` sets tags for rules, overwriting any existing tags. If the set of tags is the same as the existing tags, no changes are made.\n',
  });

/**
 * The rule's version number.
 *
 * - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
 * - For custom rules it is set to `1` when the rule is created.
 * > info
 * > It is not incremented on each update. Compare this to the `revision` field.
 *
 */
export const security_detections_api_rule_version = z.int().gte(1).register(z.globalRegistry, {
  description:
    "The rule's version number.\n\n- For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules). \n- For custom rules it is set to `1` when the rule is created. \n> info\n> It is not incremented on each update. Compare this to the `revision` field.\n",
});

export const security_detections_api_saved_object_resolve_alias_purpose = z.enum([
  'savedObjectConversion',
  'savedObjectImport',
]);

export const security_detections_api_saved_object_resolve_alias_target_id = z.string();

export const security_detections_api_saved_object_resolve_outcome = z.enum([
  'exactMatch',
  'aliasMatch',
  'conflict',
]);

/**
 * Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
 */
export const security_detections_api_saved_query_id = z.string().register(z.globalRegistry, {
  description:
    'Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.',
});

export const security_detections_api_query_rule_optional_fields = z.object({
  alert_suppression: z.optional(security_detections_api_alert_suppression),
  data_view_id: z.optional(security_detections_api_data_view_id),
  filters: z.optional(security_detections_api_rule_filter_array),
  index: z.optional(security_detections_api_index_pattern_array),
  saved_id: z.optional(security_detections_api_saved_query_id),
});

export const security_detections_api_query_rule_create_fields =
  security_detections_api_query_rule_required_fields
    .and(security_detections_api_query_rule_optional_fields)
    .and(security_detections_api_query_rule_defaultable_fields);

export const security_detections_api_query_rule_patch_fields = z
  .object({
    type: z.optional(
      z.enum(['query']).register(z.globalRegistry, {
        description: 'Rule type',
      })
    ),
  })
  .and(security_detections_api_query_rule_optional_fields)
  .and(security_detections_api_query_rule_defaultable_fields);

export const security_detections_api_query_rule_response_fields =
  security_detections_api_query_rule_required_fields
    .and(security_detections_api_query_rule_optional_fields)
    .and(
      z.object({
        language: security_detections_api_kql_query_language,
        query: security_detections_api_rule_query,
      })
    );

export const security_detections_api_saved_query_rule_defaultable_fields = z.object({
  language: z.optional(security_detections_api_kql_query_language),
});

export const security_detections_api_saved_query_rule_optional_fields = z.object({
  alert_suppression: z.optional(security_detections_api_alert_suppression),
  data_view_id: z.optional(security_detections_api_data_view_id),
  filters: z.optional(security_detections_api_rule_filter_array),
  index: z.optional(security_detections_api_index_pattern_array),
  query: z.optional(security_detections_api_rule_query),
});

export const security_detections_api_saved_query_rule_patch_fields = z
  .object({
    saved_id: z.optional(security_detections_api_saved_query_id),
    type: z.optional(
      z.enum(['saved_query']).register(z.globalRegistry, {
        description: 'Rule type',
      })
    ),
  })
  .and(security_detections_api_saved_query_rule_optional_fields)
  .and(security_detections_api_saved_query_rule_defaultable_fields);

export const security_detections_api_saved_query_rule_required_fields = z.object({
  saved_id: security_detections_api_saved_query_id,
  type: z.enum(['saved_query']).register(z.globalRegistry, {
    description: 'Rule type',
  }),
});

export const security_detections_api_saved_query_rule_create_fields =
  security_detections_api_saved_query_rule_required_fields
    .and(security_detections_api_saved_query_rule_optional_fields)
    .and(security_detections_api_saved_query_rule_defaultable_fields);

export const security_detections_api_saved_query_rule_response_fields =
  security_detections_api_saved_query_rule_required_fields
    .and(security_detections_api_saved_query_rule_optional_fields)
    .and(
      z.object({
        language: security_detections_api_kql_query_language,
      })
    );

export const security_detections_api_set_alerts_status_by_ids_base = z.object({
  signal_ids: z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
    description:
      'List of alert ids. Use field `_id` on alert document or `kibana.alert.uuid`. Note: signals are a deprecated term for alerts.',
  }),
  status: security_detections_api_alert_status_except_closed,
});

export const security_detections_api_set_alerts_status_by_ids = z.union([
  z
    .object({
      status: z.literal('closed'),
    })
    .and(security_detections_api_close_alerts_by_ids),
  z
    .object({
      status: z.literal('Security_Detections_API_SetAlertsStatusByIdsBase'),
    })
    .and(security_detections_api_set_alerts_status_by_ids_base),
]);

export const security_detections_api_set_alerts_status_by_query_base = z.object({
  conflicts: z.optional(z.enum(['abort', 'proceed'])),
  query: z.record(z.string(), z.unknown()),
  status: security_detections_api_alert_status_except_closed,
});

export const security_detections_api_set_alerts_status_by_query = z.union([
  z
    .object({
      status: z.literal('closed'),
    })
    .and(security_detections_api_close_alerts_by_query),
  z
    .object({
      status: z.literal('Security_Detections_API_SetAlertsStatusByQueryBase'),
    })
    .and(security_detections_api_set_alerts_status_by_query_base),
]);

/**
 * Object with list of tags to add and remove.
 */
export const security_detections_api_set_alert_tags = z
  .object({
    tags_to_add: security_detections_api_alert_tags,
    tags_to_remove: security_detections_api_alert_tags,
  })
  .register(z.globalRegistry, {
    description: 'Object with list of tags to add and remove.',
  });

/**
 * Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
 */
export const security_detections_api_setup_guide = z.string().register(z.globalRegistry, {
  description:
    'Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.',
});

/**
 * Severity level of alerts produced by the rule, which must be one of the following:
 * * `low`: Alerts that are of interest but generally not considered to be security incidents
 * * `medium`: Alerts that require investigation
 * * `high`: Alerts that require immediate investigation
 * * `critical`: Alerts that indicate it is highly likely a security incident has occurred
 *
 */
export const security_detections_api_severity = z
  .enum(['low', 'medium', 'high', 'critical'])
  .register(z.globalRegistry, {
    description:
      'Severity level of alerts produced by the rule, which must be one of the following:\n* `low`: Alerts that are of interest but generally not considered to be security incidents\n* `medium`: Alerts that require investigation\n* `high`: Alerts that require immediate investigation\n* `critical`: Alerts that indicate it is highly likely a security incident has occurred\n',
  });

/**
 * Overrides generated alerts' severity with values from the source event
 */
export const security_detections_api_severity_mapping = z
  .array(
    z.object({
      field: z.string().register(z.globalRegistry, {
        description: 'Source event field used to override the default `severity`.',
      }),
      operator: z.enum(['equals']),
      severity: security_detections_api_severity,
      value: z.string(),
    })
  )
  .register(z.globalRegistry, {
    description: "Overrides generated alerts' severity with values from the source event",
  });

export const security_detections_api_siem_error_response = z.object({
  message: z.string(),
  status_code: z.int(),
});

export const security_detections_api_skipped_alerts_index_migration = z.object({
  index: z.string(),
});

export const security_detections_api_sort_order = z.enum(['asc', 'desc']);

export const security_detections_api_threat_filters = z.array(
  z.unknown().register(z.globalRegistry, {
    description:
      'Query and filter context array used to filter documents from the Elasticsearch index containing the threat values',
  })
);

/**
 * Elasticsearch indices used to check which field values generate alerts.
 */
export const security_detections_api_threat_index = z.array(z.string()).register(z.globalRegistry, {
  description: 'Elasticsearch indices used to check which field values generate alerts.',
});

/**
 * Defines the path to the threat indicator in the indicator documents (optional)
 */
export const security_detections_api_threat_indicator_path = z.string().register(z.globalRegistry, {
  description: 'Defines the path to the threat indicator in the indicator documents (optional)',
});

export const security_detections_api_threat_mapping_entry = z.object({
  field: security_detections_api_non_empty_string,
  negate: z.optional(z.boolean()),
  type: z.enum(['mapping']),
  value: security_detections_api_non_empty_string,
});

/**
 * Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index. Each entries object must contain these fields:
 *
 * - field: field from the event indices on which the rule runs
 * - type: must be mapping
 * - value: field from the Elasticsearch threat index
 *
 * You can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See Example of Threat Match rule which uses both `and` and `or` logic.
 *
 */
export const security_detections_api_threat_mapping = z
  .array(
    z.object({
      entries: z.array(security_detections_api_threat_mapping_entry),
    })
  )
  .min(1)
  .register(z.globalRegistry, {
    description:
      'Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index. Each entries object must contain these fields:\n\n- field: field from the event indices on which the rule runs\n- type: must be mapping\n- value: field from the Elasticsearch threat index\n  \nYou can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See Example of Threat Match rule which uses both `and` and `or` logic.\n',
  });

export const security_detections_api_threat_match_rule_defaultable_fields = z.object({
  language: z.optional(security_detections_api_kql_query_language),
});

export const security_detections_api_threat_match_rule_optional_fields = z.object({
  alert_suppression: z.optional(security_detections_api_alert_suppression),
  concurrent_searches: z.optional(security_detections_api_concurrent_searches),
  data_view_id: z.optional(security_detections_api_data_view_id),
  filters: z.optional(security_detections_api_rule_filter_array),
  index: z.optional(security_detections_api_index_pattern_array),
  items_per_search: z.optional(security_detections_api_items_per_search),
  saved_id: z.optional(security_detections_api_saved_query_id),
  threat_filters: z.optional(security_detections_api_threat_filters),
  threat_indicator_path: z.optional(security_detections_api_threat_indicator_path),
  threat_language: z.optional(security_detections_api_kql_query_language),
});

/**
 * Query used to determine which fields in the Elasticsearch index are used for generating alerts.
 */
export const security_detections_api_threat_query = z.string().register(z.globalRegistry, {
  description:
    'Query used to determine which fields in the Elasticsearch index are used for generating alerts.',
});

export const security_detections_api_threat_match_rule_patch_fields = z
  .object({
    query: z.optional(security_detections_api_rule_query),
    threat_index: z.optional(security_detections_api_threat_index),
    threat_mapping: z.optional(security_detections_api_threat_mapping),
    threat_query: z.optional(security_detections_api_threat_query),
    type: z.optional(
      z.enum(['threat_match']).register(z.globalRegistry, {
        description: 'Rule type',
      })
    ),
  })
  .and(security_detections_api_threat_match_rule_optional_fields)
  .and(security_detections_api_threat_match_rule_defaultable_fields);

export const security_detections_api_threat_match_rule_required_fields = z.object({
  query: security_detections_api_rule_query,
  threat_index: security_detections_api_threat_index,
  threat_mapping: security_detections_api_threat_mapping,
  threat_query: security_detections_api_threat_query,
  type: z.enum(['threat_match']).register(z.globalRegistry, {
    description: 'Rule type',
  }),
});

export const security_detections_api_threat_match_rule_create_fields =
  security_detections_api_threat_match_rule_required_fields
    .and(security_detections_api_threat_match_rule_optional_fields)
    .and(security_detections_api_threat_match_rule_defaultable_fields);

export const security_detections_api_threat_match_rule_response_fields =
  security_detections_api_threat_match_rule_required_fields
    .and(security_detections_api_threat_match_rule_optional_fields)
    .and(
      z.object({
        language: security_detections_api_kql_query_language,
      })
    );

export const security_detections_api_threat_subtechnique = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'Subtechnique ID',
  }),
  name: z.string().register(z.globalRegistry, {
    description: 'Subtechnique name',
  }),
  reference: z.string().register(z.globalRegistry, {
    description: 'Subtechnique reference',
  }),
});

/**
 * Object containing information on the attack type
 *
 */
export const security_detections_api_threat_tactic = z
  .object({
    id: z.string().register(z.globalRegistry, {
      description: 'Tactic ID',
    }),
    name: z.string().register(z.globalRegistry, {
      description: 'Tactic name',
    }),
    reference: z.string().register(z.globalRegistry, {
      description: 'Tactic reference',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Object containing information on the attack type\n',
  });

export const security_detections_api_threat_technique = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'Technique ID',
  }),
  name: z.string().register(z.globalRegistry, {
    description: 'Technique name',
  }),
  reference: z.string().register(z.globalRegistry, {
    description: 'Technique reference',
  }),
  subtechnique: z.optional(
    z.array(security_detections_api_threat_subtechnique).register(z.globalRegistry, {
      description: 'Array containing more specific information on the attack technique.\n',
    })
  ),
});

/**
 * > info
 * > Currently, only threats described using the MITRE ATT&CK&trade; framework are supported.
 *
 */
export const security_detections_api_threat = z
  .object({
    framework: z.string().register(z.globalRegistry, {
      description: 'Relevant attack framework',
    }),
    tactic: security_detections_api_threat_tactic,
    technique: z.optional(
      z.array(security_detections_api_threat_technique).register(z.globalRegistry, {
        description: 'Array containing information on the attack techniques (optional)',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      '> info\n> Currently, only threats described using the MITRE ATT&CK&trade; framework are supported.\n',
  });

export const security_detections_api_threat_array = z.array(security_detections_api_threat);

/**
 * Defines alert suppression configuration.
 */
export const security_detections_api_threshold_alert_suppression = z
  .object({
    duration: security_detections_api_alert_suppression_duration,
  })
  .register(z.globalRegistry, {
    description: 'Defines alert suppression configuration.',
  });

export const security_detections_api_bulk_action_edit_payload_set_alert_suppression_for_threshold =
  z.object({
    type: z.enum(['set_alert_suppression_for_threshold']),
    value: security_detections_api_threshold_alert_suppression,
  });

export const security_detections_api_bulk_action_edit_payload_alert_suppression = z.union([
  security_detections_api_bulk_action_edit_payload_set_alert_suppression,
  security_detections_api_bulk_action_edit_payload_set_alert_suppression_for_threshold,
  security_detections_api_bulk_action_edit_payload_delete_alert_suppression,
]);

/**
 * The field on which the cardinality is applied.
 */
export const security_detections_api_threshold_cardinality = z
  .array(
    z.object({
      field: z.string().register(z.globalRegistry, {
        description: 'The field on which to calculate and compare the cardinality.',
      }),
      value: z.int().gte(0).register(z.globalRegistry, {
        description:
          'The threshold value from which an alert is generated based on unique number of values of cardinality.field.',
      }),
    })
  )
  .register(z.globalRegistry, {
    description: 'The field on which the cardinality is applied.',
  });

/**
 * The field on which the threshold is applied. If you specify an empty array ([]), alerts are generated when the query returns at least the number of results specified in the value field.
 */
export const security_detections_api_threshold_field = z.union([
  z.string(),
  z.array(z.string()).min(0).max(5),
]);

export const security_detections_api_threshold_rule_defaultable_fields = z.object({
  language: z.optional(security_detections_api_kql_query_language),
});

export const security_detections_api_threshold_rule_optional_fields = z.object({
  alert_suppression: z.optional(security_detections_api_threshold_alert_suppression),
  data_view_id: z.optional(security_detections_api_data_view_id),
  filters: z.optional(security_detections_api_rule_filter_array),
  index: z.optional(security_detections_api_index_pattern_array),
  saved_id: z.optional(security_detections_api_saved_query_id),
});

/**
 * The threshold value from which an alert is generated.
 */
export const security_detections_api_threshold_value = z.int().gte(1).register(z.globalRegistry, {
  description: 'The threshold value from which an alert is generated.',
});

export const security_detections_api_threshold = z.object({
  cardinality: z.optional(security_detections_api_threshold_cardinality),
  field: security_detections_api_threshold_field,
  value: security_detections_api_threshold_value,
});

export const security_detections_api_threshold_rule_patch_fields = z
  .object({
    query: z.optional(security_detections_api_rule_query),
    threshold: z.optional(security_detections_api_threshold),
    type: z.optional(
      z.enum(['threshold']).register(z.globalRegistry, {
        description: 'Rule type',
      })
    ),
  })
  .and(security_detections_api_threshold_rule_optional_fields)
  .and(security_detections_api_threshold_rule_defaultable_fields);

export const security_detections_api_threshold_rule_required_fields = z.object({
  query: security_detections_api_rule_query,
  threshold: security_detections_api_threshold,
  type: z.enum(['threshold']).register(z.globalRegistry, {
    description: 'Rule type',
  }),
});

export const security_detections_api_threshold_rule_create_fields =
  security_detections_api_threshold_rule_required_fields
    .and(security_detections_api_threshold_rule_optional_fields)
    .and(security_detections_api_threshold_rule_defaultable_fields);

export const security_detections_api_threshold_rule_response_fields =
  security_detections_api_threshold_rule_required_fields
    .and(security_detections_api_threshold_rule_optional_fields)
    .and(
      z.object({
        language: security_detections_api_kql_query_language,
      })
    );

/**
 * Defines the maximum interval in which a rules actions are executed.
 * > info
 * > The rule level `throttle` field is deprecated in Elastic Security 8.8 and will remain active for at least the next 12 months.
 * > In Elastic Security 8.8 and later, you can use the `frequency` field to define frequencies for individual actions. Actions without frequencies will acquire a converted version of the rules `throttle` field. In the response, the converted `throttle` setting appears in the individual actions' `frequency` field.
 *
 */
export const security_detections_api_throttle_for_bulk_actions = z
  .enum(['rule', '1h', '1d', '7d'])
  .register(z.globalRegistry, {
    description:
      "Defines the maximum interval in which a rules actions are executed.\n> info\n> The rule level `throttle` field is deprecated in Elastic Security 8.8 and will remain active for at least the next 12 months.\n> In Elastic Security 8.8 and later, you can use the `frequency` field to define frequencies for individual actions. Actions without frequencies will acquire a converted version of the rules `throttle` field. In the response, the converted `throttle` setting appears in the individual actions' `frequency` field.\n",
  });

/**
 * Edits rule actions of rules.
 *
 * - `add_rule_actions` adds rule actions to rules. This action is non-idempotent, meaning that even if the same rule action already exists for a rule, it will be added again with a new unique ID.
 * - `set_rule_actions` sets rule actions for rules. This action is non-idempotent, meaning that even if the same set of rule actions already exists for a rule, it will be set again and the actions will receive new unique IDs.
 *
 */
export const security_detections_api_bulk_action_edit_payload_rule_actions = z
  .object({
    type: z.enum(['add_rule_actions', 'set_rule_actions']),
    value: z.object({
      actions: z.array(security_detections_api_normalized_rule_action),
      throttle: z.optional(security_detections_api_throttle_for_bulk_actions),
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Edits rule actions of rules.\n\n- `add_rule_actions` adds rule actions to rules. This action is non-idempotent, meaning that even if the same rule action already exists for a rule, it will be added again with a new unique ID.\n- `set_rule_actions` sets rule actions for rules. This action is non-idempotent, meaning that even if the same set of rule actions already exists for a rule, it will be set again and the actions will receive new unique IDs.\n',
  });

/**
 * Sets a secondary field for sorting events
 */
export const security_detections_api_tiebreaker_field = z.string().register(z.globalRegistry, {
  description: 'Sets a secondary field for sorting events',
});

/**
 * Timeline template ID
 */
export const security_detections_api_timeline_template_id = z.string().register(z.globalRegistry, {
  description: 'Timeline template ID',
});

/**
 * Timeline template title
 */
export const security_detections_api_timeline_template_title = z
  .string()
  .register(z.globalRegistry, {
    description: 'Timeline template title',
  });

/**
 * Edits timeline of rules.
 *
 * - `set_timeline` sets a timeline for rules. If the same timeline already exists for a rule, no changes are made.
 *
 */
export const security_detections_api_bulk_action_edit_payload_timeline = z
  .object({
    type: z.enum(['set_timeline']),
    value: z.object({
      timeline_id: security_detections_api_timeline_template_id,
      timeline_title: security_detections_api_timeline_template_title,
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Edits timeline of rules.\n\n- `set_timeline` sets a timeline for rules. If the same timeline already exists for a rule, no changes are made.\n',
  });

export const security_detections_api_bulk_action_edit_payload = z.union([
  security_detections_api_bulk_action_edit_payload_tags,
  security_detections_api_bulk_action_edit_payload_index_patterns,
  security_detections_api_bulk_action_edit_payload_investigation_fields,
  security_detections_api_bulk_action_edit_payload_timeline,
  security_detections_api_bulk_action_edit_payload_rule_actions,
  security_detections_api_bulk_action_edit_payload_schedule,
  security_detections_api_bulk_action_edit_payload_alert_suppression,
]);

export const security_detections_api_bulk_edit_rules = z.object({
  action: z.enum(['edit']),
  edit: z
    .array(security_detections_api_bulk_action_edit_payload)
    .min(1)
    .register(z.globalRegistry, {
      description: 'Array of objects containing the edit operations',
    }),
  gaps_range_end: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range end, valid only when query is provided',
    })
  ),
  gaps_range_start: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Gaps range start, valid only when query is provided',
    })
  ),
  ids: z.optional(
    z.array(z.string()).min(1).register(z.globalRegistry, {
      description:
        "Array of rule `id`s to which a bulk action will be applied. Do not use rule's `rule_id` here.\nOnly valid when query property is undefined.\n",
    })
  ),
  query: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Query to filter rules.',
    })
  ),
});

/**
 * Specifies the name of the event timestamp field used for sorting a sequence of events. Not to be confused with `timestamp_override`, which specifies the more general field used for querying events within a range. Defaults to the @timestamp ECS field.
 */
export const security_detections_api_timestamp_field = z.string().register(z.globalRegistry, {
  description:
    'Specifies the name of the event timestamp field used for sorting a sequence of events. Not to be confused with `timestamp_override`, which specifies the more general field used for querying events within a range. Defaults to the @timestamp ECS field.',
});

export const security_detections_api_eql_optional_fields = z.object({
  alert_suppression: z.optional(security_detections_api_alert_suppression),
  data_view_id: z.optional(security_detections_api_data_view_id),
  event_category_override: z.optional(security_detections_api_event_category_override),
  filters: z.optional(security_detections_api_rule_filter_array),
  index: z.optional(security_detections_api_index_pattern_array),
  tiebreaker_field: z.optional(security_detections_api_tiebreaker_field),
  timestamp_field: z.optional(security_detections_api_timestamp_field),
});

export const security_detections_api_eql_rule_create_fields =
  security_detections_api_eql_required_fields.and(security_detections_api_eql_optional_fields);

export const security_detections_api_eql_rule_patch_fields = z
  .object({
    language: z.optional(security_detections_api_eql_query_language),
    query: z.optional(security_detections_api_rule_query),
    type: z.optional(
      z.enum(['eql']).register(z.globalRegistry, {
        description: 'Rule type',
      })
    ),
  })
  .and(security_detections_api_eql_optional_fields);

export const security_detections_api_eql_rule_response_fields =
  security_detections_api_eql_required_fields.and(security_detections_api_eql_optional_fields);

/**
 * Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
 */
export const security_detections_api_timestamp_override = z.string().register(z.globalRegistry, {
  description:
    'Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.',
});

/**
 * Disables the fallback to the event's @timestamp field
 */
export const security_detections_api_timestamp_override_fallback_disabled = z
  .boolean()
  .register(z.globalRegistry, {
    description: "Disables the fallback to the event's @timestamp field",
  });

export const security_detections_api_eql_rule_create_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_eql_rule_create_fields);

export const security_detections_api_esql_rule_create_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_esql_rule_create_fields);

export const security_detections_api_machine_learning_rule_create_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_machine_learning_rule_create_fields);

export const security_detections_api_new_terms_rule_create_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_new_terms_rule_create_fields);

export const security_detections_api_query_rule_create_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_query_rule_create_fields);

export const security_detections_api_saved_query_rule_create_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_saved_query_rule_create_fields);

export const security_detections_api_threat_match_rule_create_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_threat_match_rule_create_fields);

export const security_detections_api_threshold_rule_create_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_threshold_rule_create_fields);

export const security_detections_api_rule_create_props = z.union([
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_EqlRuleCreateProps')),
    })
    .and(security_detections_api_eql_rule_create_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_QueryRuleCreateProps')),
    })
    .and(security_detections_api_query_rule_create_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_SavedQueryRuleCreateProps')),
    })
    .and(security_detections_api_saved_query_rule_create_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_ThresholdRuleCreateProps')),
    })
    .and(security_detections_api_threshold_rule_create_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_ThreatMatchRuleCreateProps')),
    })
    .and(security_detections_api_threat_match_rule_create_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_MachineLearningRuleCreateProps')),
    })
    .and(security_detections_api_machine_learning_rule_create_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_NewTermsRuleCreateProps')),
    })
    .and(security_detections_api_new_terms_rule_create_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_EsqlRuleCreateProps')),
    })
    .and(security_detections_api_esql_rule_create_props),
]);

/**
 * A universally unique identifier
 */
export const security_detections_api_uuid = z.uuid().register(z.globalRegistry, {
  description: 'A universally unique identifier',
});

export const security_detections_api_eql_rule_patch_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: z.optional(security_detections_api_rule_description),
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: z.optional(security_detections_api_rule_name),
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: z.optional(security_detections_api_risk_score),
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: z.optional(security_detections_api_severity),
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_eql_rule_patch_fields);

export const security_detections_api_eql_rule_update_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_eql_rule_create_fields);

export const security_detections_api_esql_rule_patch_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: z.optional(security_detections_api_rule_description),
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    language: z.optional(security_detections_api_esql_query_language),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: z.optional(security_detections_api_rule_name),
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    query: z.optional(security_detections_api_rule_query),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: z.optional(security_detections_api_risk_score),
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: z.optional(security_detections_api_severity),
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    type: z.optional(
      z.enum(['esql']).register(z.globalRegistry, {
        description: 'Rule type',
      })
    ),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_esql_rule_optional_fields);

export const security_detections_api_esql_rule_update_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_esql_rule_create_fields);

export const security_detections_api_machine_learning_rule_patch_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: z.optional(security_detections_api_rule_description),
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: z.optional(security_detections_api_rule_name),
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: z.optional(security_detections_api_risk_score),
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: z.optional(security_detections_api_severity),
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_machine_learning_rule_patch_fields);

export const security_detections_api_machine_learning_rule_update_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_machine_learning_rule_create_fields);

export const security_detections_api_new_terms_rule_patch_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: z.optional(security_detections_api_rule_description),
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: z.optional(security_detections_api_rule_name),
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: z.optional(security_detections_api_risk_score),
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: z.optional(security_detections_api_severity),
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_new_terms_rule_patch_fields);

export const security_detections_api_new_terms_rule_update_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_new_terms_rule_create_fields);

export const security_detections_api_query_rule_patch_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: z.optional(security_detections_api_rule_description),
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: z.optional(security_detections_api_rule_name),
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: z.optional(security_detections_api_risk_score),
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: z.optional(security_detections_api_severity),
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_query_rule_patch_fields);

export const security_detections_api_query_rule_update_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_query_rule_create_fields);

export const security_detections_api_response_fields = z.object({
  created_at: z.iso.datetime(),
  created_by: z.string(),
  execution_summary: z.optional(security_detections_api_rule_execution_summary),
  id: security_detections_api_uuid,
  immutable: security_detections_api_is_rule_immutable,
  required_fields: security_detections_api_required_field_array,
  revision: security_detections_api_rule_revision,
  rule_id: security_detections_api_rule_signature_id,
  rule_source: security_detections_api_rule_source,
  updated_at: z.iso.datetime(),
  updated_by: z.string(),
});

export const security_detections_api_eql_rule = z
  .object({
    actions: z.array(security_detections_api_rule_action).register(z.globalRegistry, {
      description:
        'Array defining the automated actions (notifications) taken when alerts are generated.',
    }),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: security_detections_api_rule_author_array,
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: security_detections_api_is_rule_enabled,
    exceptions_list: z.array(security_detections_api_rule_exception_list),
    false_positives: security_detections_api_rule_false_positive_array,
    from: security_detections_api_rule_interval_from,
    interval: security_detections_api_rule_interval,
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: security_detections_api_max_signals,
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: security_detections_api_rule_reference_array,
    related_integrations: security_detections_api_related_integration_array,
    required_fields: z
      .array(security_detections_api_required_field_input)
      .register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      }),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: security_detections_api_risk_score_mapping,
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: security_detections_api_setup_guide,
    severity: security_detections_api_severity,
    severity_mapping: security_detections_api_severity_mapping,
    tags: security_detections_api_rule_tag_array,
    threat: security_detections_api_threat_array,
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: security_detections_api_rule_interval_to,
    version: security_detections_api_rule_version,
  })
  .and(security_detections_api_response_fields)
  .and(security_detections_api_eql_rule_response_fields);

export const security_detections_api_esql_rule = z
  .object({
    actions: z.array(security_detections_api_rule_action).register(z.globalRegistry, {
      description:
        'Array defining the automated actions (notifications) taken when alerts are generated.',
    }),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: security_detections_api_rule_author_array,
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: security_detections_api_is_rule_enabled,
    exceptions_list: z.array(security_detections_api_rule_exception_list),
    false_positives: security_detections_api_rule_false_positive_array,
    from: security_detections_api_rule_interval_from,
    interval: security_detections_api_rule_interval,
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: security_detections_api_max_signals,
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: security_detections_api_rule_reference_array,
    related_integrations: security_detections_api_related_integration_array,
    required_fields: z
      .array(security_detections_api_required_field_input)
      .register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      }),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: security_detections_api_risk_score_mapping,
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: security_detections_api_setup_guide,
    severity: security_detections_api_severity,
    severity_mapping: security_detections_api_severity_mapping,
    tags: security_detections_api_rule_tag_array,
    threat: security_detections_api_threat_array,
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: security_detections_api_rule_interval_to,
    version: security_detections_api_rule_version,
  })
  .and(security_detections_api_response_fields)
  .and(security_detections_api_esql_rule_response_fields);

export const security_detections_api_machine_learning_rule = z
  .object({
    actions: z.array(security_detections_api_rule_action).register(z.globalRegistry, {
      description:
        'Array defining the automated actions (notifications) taken when alerts are generated.',
    }),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: security_detections_api_rule_author_array,
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: security_detections_api_is_rule_enabled,
    exceptions_list: z.array(security_detections_api_rule_exception_list),
    false_positives: security_detections_api_rule_false_positive_array,
    from: security_detections_api_rule_interval_from,
    interval: security_detections_api_rule_interval,
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: security_detections_api_max_signals,
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: security_detections_api_rule_reference_array,
    related_integrations: security_detections_api_related_integration_array,
    required_fields: z
      .array(security_detections_api_required_field_input)
      .register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      }),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: security_detections_api_risk_score_mapping,
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: security_detections_api_setup_guide,
    severity: security_detections_api_severity,
    severity_mapping: security_detections_api_severity_mapping,
    tags: security_detections_api_rule_tag_array,
    threat: security_detections_api_threat_array,
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: security_detections_api_rule_interval_to,
    version: security_detections_api_rule_version,
  })
  .and(security_detections_api_response_fields)
  .and(security_detections_api_machine_learning_rule_response_fields);

export const security_detections_api_new_terms_rule = z
  .object({
    actions: z.array(security_detections_api_rule_action).register(z.globalRegistry, {
      description:
        'Array defining the automated actions (notifications) taken when alerts are generated.',
    }),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: security_detections_api_rule_author_array,
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: security_detections_api_is_rule_enabled,
    exceptions_list: z.array(security_detections_api_rule_exception_list),
    false_positives: security_detections_api_rule_false_positive_array,
    from: security_detections_api_rule_interval_from,
    interval: security_detections_api_rule_interval,
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: security_detections_api_max_signals,
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: security_detections_api_rule_reference_array,
    related_integrations: security_detections_api_related_integration_array,
    required_fields: z
      .array(security_detections_api_required_field_input)
      .register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      }),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: security_detections_api_risk_score_mapping,
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: security_detections_api_setup_guide,
    severity: security_detections_api_severity,
    severity_mapping: security_detections_api_severity_mapping,
    tags: security_detections_api_rule_tag_array,
    threat: security_detections_api_threat_array,
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: security_detections_api_rule_interval_to,
    version: security_detections_api_rule_version,
  })
  .and(security_detections_api_response_fields)
  .and(security_detections_api_new_terms_rule_response_fields);

export const security_detections_api_query_rule = z
  .object({
    actions: z.array(security_detections_api_rule_action).register(z.globalRegistry, {
      description:
        'Array defining the automated actions (notifications) taken when alerts are generated.',
    }),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: security_detections_api_rule_author_array,
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: security_detections_api_is_rule_enabled,
    exceptions_list: z.array(security_detections_api_rule_exception_list),
    false_positives: security_detections_api_rule_false_positive_array,
    from: security_detections_api_rule_interval_from,
    interval: security_detections_api_rule_interval,
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: security_detections_api_max_signals,
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: security_detections_api_rule_reference_array,
    related_integrations: security_detections_api_related_integration_array,
    required_fields: z
      .array(security_detections_api_required_field_input)
      .register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      }),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: security_detections_api_risk_score_mapping,
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: security_detections_api_setup_guide,
    severity: security_detections_api_severity,
    severity_mapping: security_detections_api_severity_mapping,
    tags: security_detections_api_rule_tag_array,
    threat: security_detections_api_threat_array,
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: security_detections_api_rule_interval_to,
    version: security_detections_api_rule_version,
  })
  .and(security_detections_api_response_fields)
  .and(security_detections_api_query_rule_response_fields);

export const security_detections_api_rule_object_id = security_detections_api_uuid;

export const security_detections_api_saved_query_rule = z
  .object({
    actions: z.array(security_detections_api_rule_action).register(z.globalRegistry, {
      description:
        'Array defining the automated actions (notifications) taken when alerts are generated.',
    }),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: security_detections_api_rule_author_array,
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: security_detections_api_is_rule_enabled,
    exceptions_list: z.array(security_detections_api_rule_exception_list),
    false_positives: security_detections_api_rule_false_positive_array,
    from: security_detections_api_rule_interval_from,
    interval: security_detections_api_rule_interval,
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: security_detections_api_max_signals,
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: security_detections_api_rule_reference_array,
    related_integrations: security_detections_api_related_integration_array,
    required_fields: z
      .array(security_detections_api_required_field_input)
      .register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      }),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: security_detections_api_risk_score_mapping,
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: security_detections_api_setup_guide,
    severity: security_detections_api_severity,
    severity_mapping: security_detections_api_severity_mapping,
    tags: security_detections_api_rule_tag_array,
    threat: security_detections_api_threat_array,
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: security_detections_api_rule_interval_to,
    version: security_detections_api_rule_version,
  })
  .and(security_detections_api_response_fields)
  .and(security_detections_api_saved_query_rule_response_fields);

export const security_detections_api_saved_query_rule_patch_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: z.optional(security_detections_api_rule_description),
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: z.optional(security_detections_api_rule_name),
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: z.optional(security_detections_api_risk_score),
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: z.optional(security_detections_api_severity),
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_saved_query_rule_patch_fields);

export const security_detections_api_saved_query_rule_update_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_saved_query_rule_create_fields);

export const security_detections_api_threat_match_rule = z
  .object({
    actions: z.array(security_detections_api_rule_action).register(z.globalRegistry, {
      description:
        'Array defining the automated actions (notifications) taken when alerts are generated.',
    }),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: security_detections_api_rule_author_array,
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: security_detections_api_is_rule_enabled,
    exceptions_list: z.array(security_detections_api_rule_exception_list),
    false_positives: security_detections_api_rule_false_positive_array,
    from: security_detections_api_rule_interval_from,
    interval: security_detections_api_rule_interval,
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: security_detections_api_max_signals,
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: security_detections_api_rule_reference_array,
    related_integrations: security_detections_api_related_integration_array,
    required_fields: z
      .array(security_detections_api_required_field_input)
      .register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      }),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: security_detections_api_risk_score_mapping,
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: security_detections_api_setup_guide,
    severity: security_detections_api_severity,
    severity_mapping: security_detections_api_severity_mapping,
    tags: security_detections_api_rule_tag_array,
    threat: security_detections_api_threat_array,
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: security_detections_api_rule_interval_to,
    version: security_detections_api_rule_version,
  })
  .and(security_detections_api_response_fields)
  .and(security_detections_api_threat_match_rule_response_fields);

export const security_detections_api_threat_match_rule_patch_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: z.optional(security_detections_api_rule_description),
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: z.optional(security_detections_api_rule_name),
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: z.optional(security_detections_api_risk_score),
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: z.optional(security_detections_api_severity),
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_threat_match_rule_patch_fields);

export const security_detections_api_threat_match_rule_update_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_threat_match_rule_create_fields);

export const security_detections_api_threshold_rule = z
  .object({
    actions: z.array(security_detections_api_rule_action).register(z.globalRegistry, {
      description:
        'Array defining the automated actions (notifications) taken when alerts are generated.',
    }),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: security_detections_api_rule_author_array,
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: security_detections_api_is_rule_enabled,
    exceptions_list: z.array(security_detections_api_rule_exception_list),
    false_positives: security_detections_api_rule_false_positive_array,
    from: security_detections_api_rule_interval_from,
    interval: security_detections_api_rule_interval,
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: security_detections_api_max_signals,
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: security_detections_api_rule_reference_array,
    related_integrations: security_detections_api_related_integration_array,
    required_fields: z
      .array(security_detections_api_required_field_input)
      .register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      }),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: security_detections_api_risk_score_mapping,
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: security_detections_api_setup_guide,
    severity: security_detections_api_severity,
    severity_mapping: security_detections_api_severity_mapping,
    tags: security_detections_api_rule_tag_array,
    threat: security_detections_api_threat_array,
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: security_detections_api_rule_interval_to,
    version: security_detections_api_rule_version,
  })
  .and(security_detections_api_response_fields)
  .and(security_detections_api_threshold_rule_response_fields);

export const security_detections_api_rule_response = z.union([
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_EqlRule')),
    })
    .and(security_detections_api_eql_rule),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_QueryRule')),
    })
    .and(security_detections_api_query_rule),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_SavedQueryRule')),
    })
    .and(security_detections_api_saved_query_rule),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_ThresholdRule')),
    })
    .and(security_detections_api_threshold_rule),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_ThreatMatchRule')),
    })
    .and(security_detections_api_threat_match_rule),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_MachineLearningRule')),
    })
    .and(security_detections_api_machine_learning_rule),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_NewTermsRule')),
    })
    .and(security_detections_api_new_terms_rule),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_EsqlRule')),
    })
    .and(security_detections_api_esql_rule),
]);

export const security_detections_api_bulk_edit_action_results = z.object({
  created: z.array(security_detections_api_rule_response),
  deleted: z.array(security_detections_api_rule_response),
  skipped: z.array(security_detections_api_bulk_action_skip_result),
  updated: z.array(security_detections_api_rule_response),
});

export const security_detections_api_bulk_edit_action_response = z.object({
  attributes: z.object({
    errors: z.optional(z.array(security_detections_api_normalized_rule_error)),
    results: security_detections_api_bulk_edit_action_results,
    summary: security_detections_api_bulk_edit_action_summary,
  }),
  message: z.optional(z.string()),
  rules_count: z.optional(z.int()),
  status_code: z.optional(z.int()),
  success: z.optional(z.boolean()),
});

export const security_detections_api_threshold_rule_patch_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: z.optional(security_detections_api_rule_description),
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: z.optional(security_detections_api_rule_name),
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: z.optional(security_detections_api_risk_score),
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: z.optional(security_detections_api_severity),
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_threshold_rule_patch_fields);

export const security_detections_api_rule_patch_props = z.union([
  security_detections_api_eql_rule_patch_props,
  security_detections_api_query_rule_patch_props,
  security_detections_api_saved_query_rule_patch_props,
  security_detections_api_threshold_rule_patch_props,
  security_detections_api_threat_match_rule_patch_props,
  security_detections_api_machine_learning_rule_patch_props,
  security_detections_api_new_terms_rule_patch_props,
  security_detections_api_esql_rule_patch_props,
]);

export const security_detections_api_threshold_rule_update_props = z
  .object({
    actions: z.optional(
      z.array(security_detections_api_rule_action).register(z.globalRegistry, {
        description:
          'Array defining the automated actions (notifications) taken when alerts are generated.',
      })
    ),
    alias_purpose: z.optional(security_detections_api_saved_object_resolve_alias_purpose),
    alias_target_id: z.optional(security_detections_api_saved_object_resolve_alias_target_id),
    author: z.optional(security_detections_api_rule_author_array),
    building_block_type: z.optional(security_detections_api_building_block_type),
    description: security_detections_api_rule_description,
    enabled: z.optional(security_detections_api_is_rule_enabled),
    exceptions_list: z.optional(z.array(security_detections_api_rule_exception_list)),
    false_positives: z.optional(security_detections_api_rule_false_positive_array),
    from: z.optional(security_detections_api_rule_interval_from),
    id: z.optional(security_detections_api_uuid),
    interval: z.optional(security_detections_api_rule_interval),
    investigation_fields: z.optional(security_detections_api_investigation_fields),
    license: z.optional(security_detections_api_rule_license),
    max_signals: z.optional(security_detections_api_max_signals),
    meta: z.optional(security_detections_api_rule_metadata),
    name: security_detections_api_rule_name,
    namespace: z.optional(security_detections_api_alerts_index_namespace),
    note: z.optional(security_detections_api_investigation_guide),
    outcome: z.optional(security_detections_api_saved_object_resolve_outcome),
    output_index: z.optional(security_detections_api_alerts_index),
    references: z.optional(security_detections_api_rule_reference_array),
    related_integrations: z.optional(security_detections_api_related_integration_array),
    required_fields: z.optional(
      z.array(security_detections_api_required_field_input).register(z.globalRegistry, {
        description:
          'Elasticsearch fields and their types that need to be present for the rule to function.\n> info\n> The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.\n',
      })
    ),
    response_actions: z.optional(z.array(security_detections_api_response_action)),
    risk_score: security_detections_api_risk_score,
    risk_score_mapping: z.optional(security_detections_api_risk_score_mapping),
    rule_id: z.optional(security_detections_api_rule_signature_id),
    rule_name_override: z.optional(security_detections_api_rule_name_override),
    setup: z.optional(security_detections_api_setup_guide),
    severity: security_detections_api_severity,
    severity_mapping: z.optional(security_detections_api_severity_mapping),
    tags: z.optional(security_detections_api_rule_tag_array),
    threat: z.optional(security_detections_api_threat_array),
    throttle: z.optional(security_detections_api_rule_action_throttle),
    timeline_id: z.optional(security_detections_api_timeline_template_id),
    timeline_title: z.optional(security_detections_api_timeline_template_title),
    timestamp_override: z.optional(security_detections_api_timestamp_override),
    timestamp_override_fallback_disabled: z.optional(
      security_detections_api_timestamp_override_fallback_disabled
    ),
    to: z.optional(security_detections_api_rule_interval_to),
    version: z.optional(security_detections_api_rule_version),
  })
  .and(security_detections_api_threshold_rule_create_fields);

export const security_detections_api_rule_update_props = z.union([
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_EqlRuleUpdateProps')),
    })
    .and(security_detections_api_eql_rule_update_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_QueryRuleUpdateProps')),
    })
    .and(security_detections_api_query_rule_update_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_SavedQueryRuleUpdateProps')),
    })
    .and(security_detections_api_saved_query_rule_update_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_ThresholdRuleUpdateProps')),
    })
    .and(security_detections_api_threshold_rule_update_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_ThreatMatchRuleUpdateProps')),
    })
    .and(security_detections_api_threat_match_rule_update_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_MachineLearningRuleUpdateProps')),
    })
    .and(security_detections_api_machine_learning_rule_update_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_NewTermsRuleUpdateProps')),
    })
    .and(security_detections_api_new_terms_rule_update_props),
  z
    .object({
      type: z.optional(z.literal('Security_Detections_API_EsqlRuleUpdateProps')),
    })
    .and(security_detections_api_esql_rule_update_props),
]);

export const security_detections_api_warning_schema = z.object({
  actionPath: z.string(),
  buttonLabel: z.optional(z.string()),
  message: z.string(),
  type: z.string(),
});

/**
 * Describes the exception list.
 */
export const security_endpoint_exceptions_api_exception_list_description = z
  .string()
  .register(z.globalRegistry, {
    description: 'Describes the exception list.',
  });

/**
 * The exception list's human readable string identifier, `endpoint_list`.
 */
export const security_endpoint_exceptions_api_exception_list_human_id = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: "The exception list's human readable string identifier, `endpoint_list`.",
  });

/**
 * Exception list's identifier.
 */
export const security_endpoint_exceptions_api_exception_list_id = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: "Exception list's identifier.",
  });

/**
 * Describes the exception list.
 */
export const security_endpoint_exceptions_api_exception_list_item_description = z
  .string()
  .register(z.globalRegistry, {
    description: 'Describes the exception list.',
  });

export const security_endpoint_exceptions_api_exception_list_item_entry_operator = z.enum([
  'excluded',
  'included',
]);

/**
 * The exception items expiration date, in ISO format. This field is only available for regular exception items, not endpoint exceptions.
 */
export const security_endpoint_exceptions_api_exception_list_item_expire_time = z.iso
  .datetime()
  .register(z.globalRegistry, {
    description:
      'The exception items expiration date, in ISO format. This field is only available for regular exception items, not endpoint exceptions.',
  });

/**
 * Human readable string identifier, e.g. `trusted-linux-processes`
 */
export const security_endpoint_exceptions_api_exception_list_item_human_id = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: 'Human readable string identifier, e.g. `trusted-linux-processes`',
  });

/**
 * Exception's identifier.
 */
export const security_endpoint_exceptions_api_exception_list_item_id = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: "Exception's identifier.",
  });

export const security_endpoint_exceptions_api_exception_list_item_meta = z.record(
  z.string(),
  z.unknown()
);

/**
 * Exception list name.
 */
export const security_endpoint_exceptions_api_exception_list_item_name = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: 'Exception list name.',
  });

export const security_endpoint_exceptions_api_exception_list_item_tags = z.array(
  z.string().min(1).register(z.globalRegistry, {
    description: 'String array containing words and phrases to help categorize exception items.',
  })
);

export const security_endpoint_exceptions_api_exception_list_item_type = z.enum(['simple']);

/**
 * Placeholder for metadata about the list container.
 */
export const security_endpoint_exceptions_api_exception_list_meta = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Placeholder for metadata about the list container.',
  });

/**
 * The name of the exception list.
 */
export const security_endpoint_exceptions_api_exception_list_name = z
  .string()
  .register(z.globalRegistry, {
    description: 'The name of the exception list.',
  });

/**
 * Use this field to specify the operating system.
 */
export const security_endpoint_exceptions_api_exception_list_os_type = z
  .enum(['linux', 'macos', 'windows'])
  .register(z.globalRegistry, {
    description: 'Use this field to specify the operating system.',
  });

export const security_endpoint_exceptions_api_exception_list_item_os_type_array = z.array(
  security_endpoint_exceptions_api_exception_list_os_type
);

/**
 * Use this field to specify the operating system. Only enter one value.
 */
export const security_endpoint_exceptions_api_exception_list_os_type_array = z
  .array(security_endpoint_exceptions_api_exception_list_os_type)
  .register(z.globalRegistry, {
    description: 'Use this field to specify the operating system. Only enter one value.',
  });

/**
 * String array containing words and phrases to help categorize exception containers.
 */
export const security_endpoint_exceptions_api_exception_list_tags = z
  .array(z.string())
  .register(z.globalRegistry, {
    description:
      'String array containing words and phrases to help categorize exception containers.',
  });

/**
 * The type of exception list to be created. Different list types may denote where they can be utilized.
 */
export const security_endpoint_exceptions_api_exception_list_type = z
  .enum([
    'detection',
    'rule_default',
    'endpoint',
    'endpoint_trusted_apps',
    'endpoint_trusted_devices',
    'endpoint_events',
    'endpoint_host_isolation_exceptions',
    'endpoint_blocklists',
  ])
  .register(z.globalRegistry, {
    description:
      'The type of exception list to be created. Different list types may denote where they can be utilized.',
  });

/**
 * The document version, automatically increasd on updates.
 */
export const security_endpoint_exceptions_api_exception_list_version = z
  .int()
  .gte(1)
  .register(z.globalRegistry, {
    description: 'The document version, automatically increasd on updates.',
  });

/**
 * Determines whether the exception container is available in all Kibana spaces or just the space
 * in which it is created, where:
 *
 * - `single`: Only available in the Kibana space in which it is created.
 * - `agnostic`: Available in all Kibana spaces.
 *
 */
export const security_endpoint_exceptions_api_exception_namespace_type = z
  .enum(['agnostic', 'single'])
  .register(z.globalRegistry, {
    description:
      'Determines whether the exception container is available in all Kibana spaces or just the space\nin which it is created, where:\n\n- `single`: Only available in the Kibana space in which it is created.\n- `agnostic`: Available in all Kibana spaces.\n',
  });

export const security_endpoint_exceptions_api_exception_list = z.object({
  _version: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The version id, normally returned by the API when the item was retrieved. Use it ensure updates are done against the latest version.',
    })
  ),
  created_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of object creation.',
  }),
  created_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that created object.',
  }),
  description: security_endpoint_exceptions_api_exception_list_description,
  id: security_endpoint_exceptions_api_exception_list_id,
  immutable: z.boolean(),
  list_id: security_endpoint_exceptions_api_exception_list_human_id,
  meta: z.optional(security_endpoint_exceptions_api_exception_list_meta),
  name: security_endpoint_exceptions_api_exception_list_name,
  namespace_type: security_endpoint_exceptions_api_exception_namespace_type,
  os_types: z.optional(security_endpoint_exceptions_api_exception_list_os_type_array),
  tags: z.optional(security_endpoint_exceptions_api_exception_list_tags),
  tie_breaker_id: z.string().register(z.globalRegistry, {
    description: 'Field used in search to ensure all containers are sorted and returned correctly.',
  }),
  type: security_endpoint_exceptions_api_exception_list_type,
  updated_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of last object update.',
  }),
  updated_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that last updated object.',
  }),
  version: security_endpoint_exceptions_api_exception_list_version,
});

export const security_endpoint_exceptions_api_endpoint_list = z.union([
  security_endpoint_exceptions_api_exception_list,
  z.record(z.string(), z.never()),
]);

/**
 * Value list's identifier.
 */
export const security_endpoint_exceptions_api_list_id = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: "Value list's identifier.",
  });

/**
 * Specifies the Elasticsearch data type of excludes the list container holds. Some common examples:
 *
 * - `keyword`: Many ECS fields are Elasticsearch keywords
 * - `ip`: IP addresses
 * - `ip_range`: Range of IP addresses (supports IPv4, IPv6, and CIDR notation)
 *
 */
export const security_endpoint_exceptions_api_list_type = z
  .enum([
    'binary',
    'boolean',
    'byte',
    'date',
    'date_nanos',
    'date_range',
    'double',
    'double_range',
    'float',
    'float_range',
    'geo_point',
    'geo_shape',
    'half_float',
    'integer',
    'integer_range',
    'ip',
    'ip_range',
    'keyword',
    'long',
    'long_range',
    'shape',
    'short',
    'text',
  ])
  .register(z.globalRegistry, {
    description:
      'Specifies the Elasticsearch data type of excludes the list container holds. Some common examples:\n\n- `keyword`: Many ECS fields are Elasticsearch keywords\n- `ip`: IP addresses\n- `ip_range`: Range of IP addresses (supports IPv4, IPv6, and CIDR notation)\n',
  });

/**
 * A string that does not contain only whitespace characters
 */
export const security_endpoint_exceptions_api_non_empty_string = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: 'A string that does not contain only whitespace characters',
  });

export const security_endpoint_exceptions_api_exception_list_item_comment = z.object({
  comment: security_endpoint_exceptions_api_non_empty_string,
  created_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of object creation.',
  }),
  created_by: security_endpoint_exceptions_api_non_empty_string,
  id: security_endpoint_exceptions_api_non_empty_string,
  updated_at: z.optional(
    z.iso.datetime().register(z.globalRegistry, {
      description: 'Autogenerated date of last object update.',
    })
  ),
  updated_by: z.optional(security_endpoint_exceptions_api_non_empty_string),
});

/**
 * Array of comment fields:
 *
 * - comment (string): Comments about the exception item.
 *
 */
export const security_endpoint_exceptions_api_exception_list_item_comment_array = z
  .array(security_endpoint_exceptions_api_exception_list_item_comment)
  .register(z.globalRegistry, {
    description:
      'Array of comment fields:\n\n- comment (string): Comments about the exception item.\n',
  });

export const security_endpoint_exceptions_api_exception_list_item_entry_exists = z.object({
  field: security_endpoint_exceptions_api_non_empty_string,
  operator: security_endpoint_exceptions_api_exception_list_item_entry_operator,
  type: z.enum(['exists']),
});

export const security_endpoint_exceptions_api_exception_list_item_entry_list = z.object({
  field: security_endpoint_exceptions_api_non_empty_string,
  list: z.object({
    id: security_endpoint_exceptions_api_list_id,
    type: security_endpoint_exceptions_api_list_type,
  }),
  operator: security_endpoint_exceptions_api_exception_list_item_entry_operator,
  type: z.enum(['list']),
});

export const security_endpoint_exceptions_api_exception_list_item_entry_match = z.object({
  field: security_endpoint_exceptions_api_non_empty_string,
  operator: security_endpoint_exceptions_api_exception_list_item_entry_operator,
  type: z.enum(['match']),
  value: security_endpoint_exceptions_api_non_empty_string,
});

export const security_endpoint_exceptions_api_exception_list_item_entry_match_any = z.object({
  field: security_endpoint_exceptions_api_non_empty_string,
  operator: security_endpoint_exceptions_api_exception_list_item_entry_operator,
  type: z.enum(['match_any']),
  value: z.array(security_endpoint_exceptions_api_non_empty_string).min(1),
});

export const security_endpoint_exceptions_api_exception_list_item_entry_match_wildcard = z.object({
  field: security_endpoint_exceptions_api_non_empty_string,
  operator: security_endpoint_exceptions_api_exception_list_item_entry_operator,
  type: z.enum(['wildcard']),
  value: security_endpoint_exceptions_api_non_empty_string,
});

export const security_endpoint_exceptions_api_exception_list_item_entry_nested_entry_item = z.union(
  [
    security_endpoint_exceptions_api_exception_list_item_entry_match,
    security_endpoint_exceptions_api_exception_list_item_entry_match_any,
    security_endpoint_exceptions_api_exception_list_item_entry_exists,
  ]
);

export const security_endpoint_exceptions_api_exception_list_item_entry_nested = z.object({
  entries: z
    .array(security_endpoint_exceptions_api_exception_list_item_entry_nested_entry_item)
    .min(1),
  field: security_endpoint_exceptions_api_non_empty_string,
  type: z.enum(['nested']),
});

export const security_endpoint_exceptions_api_exception_list_item_entry = z.union([
  z
    .object({
      type: z.optional(z.literal('Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatch')),
    })
    .and(security_endpoint_exceptions_api_exception_list_item_entry_match),
  z
    .object({
      type: z.optional(
        z.literal('Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatchAny')
      ),
    })
    .and(security_endpoint_exceptions_api_exception_list_item_entry_match_any),
  z
    .object({
      type: z.optional(z.literal('Security_Endpoint_Exceptions_API_ExceptionListItemEntryList')),
    })
    .and(security_endpoint_exceptions_api_exception_list_item_entry_list),
  z
    .object({
      type: z.optional(z.literal('Security_Endpoint_Exceptions_API_ExceptionListItemEntryExists')),
    })
    .and(security_endpoint_exceptions_api_exception_list_item_entry_exists),
  z
    .object({
      type: z.optional(z.literal('Security_Endpoint_Exceptions_API_ExceptionListItemEntryNested')),
    })
    .and(security_endpoint_exceptions_api_exception_list_item_entry_nested),
  z
    .object({
      type: z.optional(
        z.literal('Security_Endpoint_Exceptions_API_ExceptionListItemEntryMatchWildcard')
      ),
    })
    .and(security_endpoint_exceptions_api_exception_list_item_entry_match_wildcard),
]);

export const security_endpoint_exceptions_api_exception_list_item_entry_array = z.array(
  security_endpoint_exceptions_api_exception_list_item_entry
);

export const security_endpoint_exceptions_api_exception_list_item = z.object({
  _version: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The version id, normally returned by the API when the item was retrieved. Use it ensure updates are done against the latest version.',
    })
  ),
  comments: security_endpoint_exceptions_api_exception_list_item_comment_array,
  created_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of object creation.',
  }),
  created_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that created object.',
  }),
  description: security_endpoint_exceptions_api_exception_list_item_description,
  entries: security_endpoint_exceptions_api_exception_list_item_entry_array,
  expire_time: z.optional(security_endpoint_exceptions_api_exception_list_item_expire_time),
  id: security_endpoint_exceptions_api_exception_list_item_id,
  item_id: security_endpoint_exceptions_api_exception_list_item_human_id,
  list_id: security_endpoint_exceptions_api_exception_list_human_id,
  meta: z.optional(security_endpoint_exceptions_api_exception_list_item_meta),
  name: security_endpoint_exceptions_api_exception_list_item_name,
  namespace_type: security_endpoint_exceptions_api_exception_namespace_type,
  os_types: z.optional(security_endpoint_exceptions_api_exception_list_item_os_type_array),
  tags: z.optional(security_endpoint_exceptions_api_exception_list_item_tags),
  tie_breaker_id: z.string().register(z.globalRegistry, {
    description: 'Field used in search to ensure all containers are sorted and returned correctly.',
  }),
  type: security_endpoint_exceptions_api_exception_list_item_type,
  updated_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of last object update.',
  }),
  updated_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that last updated object.',
  }),
});

export const security_endpoint_exceptions_api_endpoint_list_item =
  security_endpoint_exceptions_api_exception_list_item;

export const security_endpoint_exceptions_api_find_endpoint_list_items_filter =
  security_endpoint_exceptions_api_non_empty_string;

export const security_endpoint_exceptions_api_platform_error_response = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.int(),
});

export const security_endpoint_exceptions_api_siem_error_response = z.object({
  message: z.string(),
  status_code: z.int(),
});

export const security_endpoint_management_api_action_state_success_response = z.object({
  body: z.object({
    data: z.object({
      canEncrypt: z.optional(z.boolean()),
    }),
  }),
});

/**
 * Agent ID
 */
export const security_endpoint_management_api_agent_id = z.string().register(z.globalRegistry, {
  description: 'Agent ID',
});

/**
 * A list of agent IDs. Max of 50.
 */
export const security_endpoint_management_api_agent_ids = z.union([
  z.array(z.string().min(1)).min(1).max(50),
  z.string().min(1),
]);

/**
 * List of agent types to retrieve. Defaults to `endpoint`.
 */
export const security_endpoint_management_api_agent_types = z
  .enum(['endpoint', 'sentinel_one', 'crowdstrike', 'microsoft_defender_endpoint'])
  .register(z.globalRegistry, {
    description: 'List of agent types to retrieve. Defaults to `endpoint`.',
  });

export const security_endpoint_management_api_cloud_file_script_parameters = z.object({
  cloudFile: z.string().min(1).register(z.globalRegistry, {
    description: 'Script name in cloud storage.',
  }),
  commandLine: z.optional(
    z.string().min(1).register(z.globalRegistry, {
      description: 'Command line arguments.',
    })
  ),
  timeout: z.optional(
    z.int().gte(1).register(z.globalRegistry, {
      description: 'Timeout in seconds.',
    })
  ),
});

/**
 * The command for the response action
 */
export const security_endpoint_management_api_command = z
  .enum([
    'isolate',
    'unisolate',
    'kill-process',
    'suspend-process',
    'running-processes',
    'get-file',
    'execute',
    'upload',
    'scan',
    'runscript',
    'cancel',
  ])
  .register(z.globalRegistry, {
    description: 'The command for the response action',
  });

/**
 * A list of response action command names.
 */
export const security_endpoint_management_api_commands = z
  .array(security_endpoint_management_api_command)
  .register(z.globalRegistry, {
    description: 'A list of response action command names.',
  });

/**
 * Optional comment
 */
export const security_endpoint_management_api_comment = z.string().register(z.globalRegistry, {
  description: 'Optional comment',
});

export const security_endpoint_management_api_download_uri = z.object({
  downloadUri: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The server relative URI to download the file associated with the output of the response action.\nURI does **not** include the space prefix\n',
    })
  ),
});

/**
 * An end date in ISO format or Date Math format.
 */
export const security_endpoint_management_api_end_date = z.string().register(z.globalRegistry, {
  description: 'An end date in ISO format or Date Math format.',
});

/**
 * List of endpoint IDs (cannot contain empty strings)
 */
export const security_endpoint_management_api_endpoint_ids = z
  .array(z.string().min(1))
  .min(1)
  .register(z.globalRegistry, {
    description: 'List of endpoint IDs (cannot contain empty strings)',
  });

export const security_endpoint_management_api_endpoint_metadata_response = z.record(
  z.string(),
  z.unknown()
);

export const security_endpoint_management_api_execute_route_response = z.record(
  z.string(),
  z.unknown()
);

export const security_endpoint_management_api_get_endpoint_action_list_response = z.record(
  z.string(),
  z.unknown()
);

export const security_endpoint_management_api_get_file_route_response = z.record(
  z.string(),
  z.unknown()
);

export const security_endpoint_management_api_get_processes_route_response = z.record(
  z.string(),
  z.unknown()
);

export const security_endpoint_management_api_host_path_script_parameters = z.object({
  commandLine: z.optional(
    z.string().min(1).register(z.globalRegistry, {
      description: 'Command line arguments.',
    })
  ),
  hostPath: z.string().min(1).register(z.globalRegistry, {
    description: 'Absolute or relative path of script on host machine.',
  }),
  timeout: z.optional(
    z.int().gte(1).register(z.globalRegistry, {
      description: 'Timeout in seconds.',
    })
  ),
});

/**
 * A set of agent health statuses to filter by.
 */
export const security_endpoint_management_api_host_statuses = z
  .array(z.enum(['healthy', 'offline', 'updating', 'inactive', 'unenrolled']))
  .register(z.globalRegistry, {
    description: 'A set of agent health statuses to filter by.',
  });

export const security_endpoint_management_api_isolate_route_response = z.record(
  z.string(),
  z.unknown()
);

export const security_endpoint_management_api_kill_process_route_response = z.record(
  z.string(),
  z.unknown()
);

/**
 * A KQL string.
 */
export const security_endpoint_management_api_kuery = z.string().register(z.globalRegistry, {
  description: 'A KQL string.',
});

/**
 * Microsoft Defender Endpoint Run Script Parameters
 *
 * Parameters for Run Script response action against Microsoft Defender Endpoint agent type.
 */
export const security_endpoint_management_api_mde_run_script_parameters = z
  .object({
    args: z.optional(
      z.string().min(1).register(z.globalRegistry, {
        description: 'Optional command line arguments for the script.',
      })
    ),
    scriptName: z.string().min(1).register(z.globalRegistry, {
      description: 'The name of the script to execute from the cloud storage.',
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Parameters for Run Script response action against Microsoft Defender Endpoint agent type.',
  });

export const security_endpoint_management_api_metadata_list_response = z.record(
  z.string(),
  z.unknown()
);

/**
 * Page number
 */
export const security_endpoint_management_api_page = z
  .int()
  .gte(1)
  .register(z.globalRegistry, {
    description: 'Page number',
  })
  .default(1);

/**
 * Number of items per page
 */
export const security_endpoint_management_api_page_size = z
  .int()
  .gte(1)
  .lte(100)
  .register(z.globalRegistry, {
    description: 'Number of items per page',
  })
  .default(10);

/**
 * Optional parameters object
 */
export const security_endpoint_management_api_parameters = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Optional parameters object',
  });

export const security_endpoint_management_api_cancel_route_request_body = z
  .object({
    agent_type: z.optional(security_endpoint_management_api_agent_types),
    alert_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description:
          'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
      })
    ),
    case_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'The IDs of cases where the action taken will be logged.',
      })
    ),
    comment: z.optional(security_endpoint_management_api_comment),
    endpoint_ids: security_endpoint_management_api_endpoint_ids,
    parameters: z.optional(security_endpoint_management_api_parameters),
  })
  .and(
    z.object({
      parameters: z.object({
        id: z.string().min(1).register(z.globalRegistry, {
          description: 'ID of the response action to cancel',
        }),
      }),
    })
  );

export const security_endpoint_management_api_get_file_route_request_body = z
  .object({
    agent_type: z.optional(security_endpoint_management_api_agent_types),
    alert_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description:
          'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
      })
    ),
    case_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'The IDs of cases where the action taken will be logged.',
      })
    ),
    comment: z.optional(security_endpoint_management_api_comment),
    endpoint_ids: security_endpoint_management_api_endpoint_ids,
    parameters: z.optional(security_endpoint_management_api_parameters),
  })
  .and(
    z.object({
      parameters: z.object({
        path: z.string(),
      }),
    })
  );

export const security_endpoint_management_api_get_processes_route_request_body = z.object({
  agent_type: z.optional(security_endpoint_management_api_agent_types),
  alert_ids: z.optional(
    z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
      description:
        'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
    })
  ),
  case_ids: z.optional(
    z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
      description: 'The IDs of cases where the action taken will be logged.',
    })
  ),
  comment: z.optional(security_endpoint_management_api_comment),
  endpoint_ids: security_endpoint_management_api_endpoint_ids,
  parameters: z.optional(security_endpoint_management_api_parameters),
});

export const security_endpoint_management_api_kill_process_route_request_body = z
  .object({
    agent_type: z.optional(security_endpoint_management_api_agent_types),
    alert_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description:
          'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
      })
    ),
    case_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'The IDs of cases where the action taken will be logged.',
      })
    ),
    comment: z.optional(security_endpoint_management_api_comment),
    endpoint_ids: security_endpoint_management_api_endpoint_ids,
    parameters: z.optional(security_endpoint_management_api_parameters),
  })
  .and(
    z.object({
      parameters: z.union([
        z.object({
          pid: z.optional(
            z.int().gte(1).register(z.globalRegistry, {
              description: 'The process ID (PID) of the process to terminate.',
            })
          ),
        }),
        z.object({
          entity_id: z.optional(
            z.string().min(1).register(z.globalRegistry, {
              description: 'The entity ID of the process to terminate.',
            })
          ),
        }),
        z.object({
          process_name: z.optional(
            z.string().min(1).register(z.globalRegistry, {
              description:
                'The name of the process to terminate. Valid for SentinelOne agent type only.',
            })
          ),
        }),
      ]),
    })
  );

export const security_endpoint_management_api_pending_action_data_type = z.int();

export const security_endpoint_management_api_pending_actions_schema = z.union([
  z.object({
    execute: z.optional(security_endpoint_management_api_pending_action_data_type),
    'get-file': z.optional(security_endpoint_management_api_pending_action_data_type),
    isolate: z.optional(security_endpoint_management_api_pending_action_data_type),
    'kill-process': z.optional(security_endpoint_management_api_pending_action_data_type),
    'running-processes': z.optional(security_endpoint_management_api_pending_action_data_type),
    scan: z.optional(security_endpoint_management_api_pending_action_data_type),
    'suspend-process': z.optional(security_endpoint_management_api_pending_action_data_type),
    unisolate: z.optional(security_endpoint_management_api_pending_action_data_type),
    upload: z.optional(security_endpoint_management_api_pending_action_data_type),
  }),
  z.record(z.string(), z.unknown()),
]);

export const security_endpoint_management_api_action_status_success_response = z.object({
  body: z.object({
    data: z.object({
      agent_id: security_endpoint_management_api_agent_id,
      pending_actions: security_endpoint_management_api_pending_actions_schema,
    }),
  }),
});

export const security_endpoint_management_api_protection_updates_note_response = z.object({
  note: z.optional(z.string()),
});

export const security_endpoint_management_api_raw_script_parameters = z.object({
  commandLine: z.optional(
    z.string().min(1).register(z.globalRegistry, {
      description: 'Command line arguments.',
    })
  ),
  raw: z.string().min(1).register(z.globalRegistry, {
    description: 'Raw script content.',
  }),
  timeout: z.optional(
    z.int().gte(1).register(z.globalRegistry, {
      description: 'Timeout in seconds.',
    })
  ),
});

export const security_endpoint_management_api_response_action_details = z.object({
  agents: z.optional(
    z.array(z.uuid()).register(z.globalRegistry, {
      description: 'The agent IDs for the hosts that the response action was sent to',
    })
  ),
  agentState: z.optional(
    z
      .record(
        z.string(),
        z.object({
          completedAt: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The date and time the response action was completed for the agent ID',
            })
          ),
          isCompleted: z.optional(
            z.boolean().register(z.globalRegistry, {
              description: 'Whether the response action is completed for the agent ID',
            })
          ),
          wasSuccessful: z.optional(
            z.boolean().register(z.globalRegistry, {
              description: 'Whether the response action was successful for the agent ID',
            })
          ),
        })
      )
      .register(z.globalRegistry, {
        description: 'The state of the response action for each agent ID that it was sent to',
      })
  ),
  agentType: z.optional(security_endpoint_management_api_agent_types),
  command: security_endpoint_management_api_command,
  completedAt: z.optional(
    z.iso.datetime().register(z.globalRegistry, {
      description: 'The response action completion time',
    })
  ),
  createdBy: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The user who created the response action',
    })
  ),
  hosts: z.optional(
    z
      .record(
        z.string(),
        z.object({
          name: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The host name',
            })
          ),
        })
      )
      .register(z.globalRegistry, {
        description:
          'An object containing the host names associated with the agent IDs the response action was sent to',
      })
  ),
  id: z.optional(
    z.uuid().register(z.globalRegistry, {
      description: 'The response action ID',
    })
  ),
  isComplete: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether the response action is complete',
    })
  ),
  isExpired: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether the response action is expired',
    })
  ),
  outputs: z.optional(
    z
      .record(
        z.string(),
        z
          .object({
            content: z.union([z.record(z.string(), z.unknown()), z.string()]),
            type: z.enum(['json', 'text']),
          })
          .register(z.globalRegistry, {
            description: 'The agent id',
          })
      )
      .register(z.globalRegistry, {
        description:
          'The outputs of the response action for each agent ID that it was sent to. Content different depending on the\nresponse action command and will only be present for agents that have responded to the response action\n',
      })
  ),
  parameters: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'The parameters of the response action. Content different depending on the response action command',
    })
  ),
  startedAt: z.optional(
    z.iso.datetime().register(z.globalRegistry, {
      description: 'The response action start time',
    })
  ),
  status: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The response action status',
    })
  ),
  wasSuccessful: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether the response action was successful',
    })
  ),
});

export const security_endpoint_management_api_cancel =
  security_endpoint_management_api_response_action_details.and(
    z.object({
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            content: z.optional(
              z.object({
                code: z.optional(z.string()),
              })
            ),
          })
        )
      ),
      parameters: z.optional(
        z.object({
          id: z.optional(z.uuid()),
        })
      ),
    })
  );

export const security_endpoint_management_api_execute =
  security_endpoint_management_api_response_action_details.and(
    z.object({
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            content: z.optional(
              security_endpoint_management_api_download_uri.and(
                z.object({
                  code: z.optional(z.string()),
                  cwd: z.optional(z.string()),
                  output_file_id: z.optional(z.string()),
                  output_file_stderr_truncated: z.optional(z.boolean()),
                  output_file_stdout_truncated: z.optional(z.boolean()),
                  shell_code: z.optional(z.number()),
                  stderr: z.optional(z.string()),
                  stderr_truncated: z.optional(z.boolean()),
                  stdout: z.optional(z.string()),
                  stdout_truncated: z.optional(z.boolean()),
                })
              )
            ),
          })
        )
      ),
      parameters: z.optional(
        z.object({
          command: z.optional(z.string()),
          timeout: z.optional(z.number()),
        })
      ),
    })
  );

export const security_endpoint_management_api_get_file =
  security_endpoint_management_api_response_action_details.and(
    z.object({
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            content: z.optional(
              security_endpoint_management_api_download_uri.and(
                z.object({
                  code: z.optional(z.string()),
                  contents: z.optional(
                    z.array(
                      z.object({
                        file_name: z.optional(z.string()),
                        path: z.optional(z.string()),
                        sha256: z.optional(z.string()),
                        size: z.optional(z.number()),
                        type: z.optional(z.string()),
                      })
                    )
                  ),
                  zip_size: z.optional(z.number()),
                })
              )
            ),
          })
        )
      ),
      parameters: z.optional(
        z.object({
          path: z.optional(z.string()),
        })
      ),
    })
  );

export const security_endpoint_management_api_isolate =
  security_endpoint_management_api_response_action_details;

export const security_endpoint_management_api_kill_process =
  security_endpoint_management_api_response_action_details.and(
    z.object({
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            content: z.optional(
              z.union([
                z.object({
                  code: z.optional(z.string()),
                  command: z.optional(z.string()),
                  pid: z.optional(z.number()),
                }),
                z.object({
                  code: z.optional(z.string()),
                  command: z.optional(z.string()),
                  entity_id: z.optional(z.string()),
                }),
                z.object({
                  code: z.optional(z.string()),
                  command: z.optional(z.string()),
                  process_name: z.optional(z.string()),
                }),
              ])
            ),
          })
        )
      ),
      parameters: z.optional(
        z.union([
          z.object({
            pid: z.optional(
              z.number().gte(1).register(z.globalRegistry, {
                description: 'The process ID (PID) of the process to terminate.',
              })
            ),
          }),
          z.object({
            entity_id: z.optional(
              z.string().min(1).register(z.globalRegistry, {
                description: 'The entity ID of the process to terminate.',
              })
            ),
          }),
          z.object({
            process_name: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The name of the process to terminate. Valid for SentinelOne agent type only.',
              })
            ),
          }),
        ])
      ),
    })
  );

export const security_endpoint_management_api_response_action_create_success_response = z.object({
  data: z.optional(security_endpoint_management_api_response_action_details),
});

/**
 * Processes output for `agentType` of `endpoint`
 */
export const security_endpoint_management_api_running_processes_output_endpoint = z
  .object({
    code: z.optional(z.string()),
    entries: z.optional(
      z.array(
        z.object({
          command: z.optional(z.string()),
          entity_id: z.optional(z.string()),
          pid: z.optional(z.number()),
          user: z.optional(z.string()),
        })
      )
    ),
  })
  .register(z.globalRegistry, {
    description: 'Processes output for `agentType` of `endpoint`',
  });

export const security_endpoint_management_api_running_processes_output_sentinel_one =
  security_endpoint_management_api_download_uri.and(
    z
      .object({
        code: z.optional(z.string()),
      })
      .register(z.globalRegistry, {
        description: 'Processes output for `agentType` of `sentinel_one`',
      })
  );

export const security_endpoint_management_api_running_processes =
  security_endpoint_management_api_response_action_details.and(
    z.object({
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            content: z.optional(
              z.union([
                security_endpoint_management_api_running_processes_output_endpoint,
                security_endpoint_management_api_running_processes_output_sentinel_one,
              ])
            ),
          })
        )
      ),
    })
  );

export const security_endpoint_management_api_runscript_params_crowd_strike = z.object({
  cloudFile: z.optional(z.string()),
  commandLine: z.optional(z.string()),
  hostPath: z.optional(z.string()),
  raw: z.optional(z.string()),
  timeout: z.optional(z.number()),
});

export const security_endpoint_management_api_runscript_params_microsoft = z.object({
  args: z.optional(z.string()),
  scriptName: z.optional(z.string()),
});

export const security_endpoint_management_api_runscript_params_sentinel_one = z.object({
  scriptId: z.optional(z.string()),
  scriptInput: z.optional(z.string()),
});

export const security_endpoint_management_api_runscript =
  security_endpoint_management_api_response_action_details.and(
    z.object({
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            content: z.optional(
              security_endpoint_management_api_download_uri.and(
                z.object({
                  code: z.optional(z.string()),
                  stderr: z.optional(z.string()),
                  stdout: z.optional(z.string()),
                })
              )
            ),
          })
        )
      ),
      parameters: z.optional(
        z.union([
          security_endpoint_management_api_runscript_params_crowd_strike,
          security_endpoint_management_api_runscript_params_microsoft,
          security_endpoint_management_api_runscript_params_sentinel_one,
        ])
      ),
    })
  );

export const security_endpoint_management_api_scan =
  security_endpoint_management_api_response_action_details.and(
    z.object({
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            content: z.optional(
              z.object({
                code: z.optional(z.string()),
              })
            ),
          })
        )
      ),
      parameters: z.optional(
        z.object({
          path: z.optional(z.string()),
        })
      ),
    })
  );

export const security_endpoint_management_api_scan_route_request_body = z
  .object({
    agent_type: z.optional(security_endpoint_management_api_agent_types),
    alert_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description:
          'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
      })
    ),
    case_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'The IDs of cases where the action taken will be logged.',
      })
    ),
    comment: z.optional(security_endpoint_management_api_comment),
    endpoint_ids: security_endpoint_management_api_endpoint_ids,
    parameters: z.optional(security_endpoint_management_api_parameters),
  })
  .and(
    z.object({
      parameters: z.object({
        path: z.string().register(z.globalRegistry, {
          description: 'The folder or files full path (including the file name).',
        }),
      }),
    })
  );

export const security_endpoint_management_api_scan_route_response = z.record(
  z.string(),
  z.unknown()
);

/**
 * SentinelOne Run Script Parameters
 *
 * Parameters for Run Script response action against SentinelOne agent type.
 */
export const security_endpoint_management_api_sentinel_one_run_script_parameters = z
  .object({
    inputParams: z.optional(
      z.string().min(1).register(z.globalRegistry, {
        description: 'The input parameter arguments for the script that was selected.',
      })
    ),
    script: z.string().min(1).register(z.globalRegistry, {
      description: 'The script ID from SentinelOne scripts library that will be executed.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Parameters for Run Script response action against SentinelOne agent type.',
  });

export const security_endpoint_management_api_run_script_route_request_body = z
  .object({
    agent_type: z.optional(security_endpoint_management_api_agent_types),
    alert_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description:
          'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
      })
    ),
    case_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'The IDs of cases where the action taken will be logged.',
      })
    ),
    comment: z.optional(security_endpoint_management_api_comment),
    endpoint_ids: security_endpoint_management_api_endpoint_ids,
    parameters: z.optional(security_endpoint_management_api_parameters),
  })
  .and(
    z.object({
      parameters: z.union([
        security_endpoint_management_api_raw_script_parameters,
        security_endpoint_management_api_host_path_script_parameters,
        security_endpoint_management_api_cloud_file_script_parameters,
        security_endpoint_management_api_sentinel_one_run_script_parameters,
        security_endpoint_management_api_mde_run_script_parameters,
      ]),
    })
  );

/**
 * Determines the sort order.
 */
export const security_endpoint_management_api_sort_direction = z
  .enum(['asc', 'desc'])
  .register(z.globalRegistry, {
    description: 'Determines the sort order.',
  });

/**
 * Determines which field is used to sort the results.
 */
export const security_endpoint_management_api_sort_field = z
  .enum([
    'enrolled_at',
    'metadata.host.hostname',
    'host_status',
    'metadata.Endpoint.policy.applied.name',
    'metadata.Endpoint.policy.applied.status',
    'metadata.host.os.name',
    'metadata.host.ip',
    'metadata.agent.version',
    'last_checkin',
  ])
  .register(z.globalRegistry, {
    description: 'Determines which field is used to sort the results.',
  });

/**
 * A start date in ISO 8601 format or Date Math format.
 */
export const security_endpoint_management_api_start_date = z.string().register(z.globalRegistry, {
  description: 'A start date in ISO 8601 format or Date Math format.',
});

export const security_endpoint_management_api_success_response = z.record(z.string(), z.unknown());

export const security_endpoint_management_api_suspend_process =
  security_endpoint_management_api_response_action_details.and(
    z.object({
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            content: z.optional(
              z.union([
                z.object({
                  code: z.optional(z.string()),
                  command: z.optional(z.string()),
                  pid: z.optional(z.number()),
                }),
                z.object({
                  code: z.optional(z.string()),
                  command: z.optional(z.string()),
                  entity_id: z.optional(z.string()),
                }),
              ])
            ),
          })
        )
      ),
      parameters: z.optional(
        z.union([
          z.object({
            pid: z.optional(
              z.number().gte(1).register(z.globalRegistry, {
                description: 'The process ID (PID) of the process to terminate.',
              })
            ),
          }),
          z.object({
            entity_id: z.optional(
              z.string().min(1).register(z.globalRegistry, {
                description: 'The entity ID of the process to terminate.',
              })
            ),
          }),
        ])
      ),
    })
  );

export const security_endpoint_management_api_suspend_process_route_request_body = z
  .object({
    agent_type: z.optional(security_endpoint_management_api_agent_types),
    alert_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description:
          'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
      })
    ),
    case_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'The IDs of cases where the action taken will be logged.',
      })
    ),
    comment: z.optional(security_endpoint_management_api_comment),
    endpoint_ids: security_endpoint_management_api_endpoint_ids,
    parameters: z.optional(security_endpoint_management_api_parameters),
  })
  .and(
    z.object({
      parameters: z.union([
        z.object({
          pid: z.optional(
            z.int().gte(1).register(z.globalRegistry, {
              description: 'The process ID (PID) of the process to suspend.',
            })
          ),
        }),
        z.object({
          entity_id: z.optional(
            z.string().min(1).register(z.globalRegistry, {
              description: 'The entity ID of the process to suspend.',
            })
          ),
        }),
      ]),
    })
  );

export const security_endpoint_management_api_suspend_process_route_response = z.record(
  z.string(),
  z.unknown()
);

/**
 * The maximum timeout value in milliseconds (optional)
 */
export const security_endpoint_management_api_timeout = z.int().gte(1).register(z.globalRegistry, {
  description: 'The maximum timeout value in milliseconds (optional)',
});

export const security_endpoint_management_api_execute_route_request_body = z
  .object({
    agent_type: z.optional(security_endpoint_management_api_agent_types),
    alert_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description:
          'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
      })
    ),
    case_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'The IDs of cases where the action taken will be logged.',
      })
    ),
    comment: z.optional(security_endpoint_management_api_comment),
    endpoint_ids: security_endpoint_management_api_endpoint_ids,
    parameters: z.optional(security_endpoint_management_api_parameters),
  })
  .and(
    z.object({
      parameters: z.object({
        command: security_endpoint_management_api_command,
        timeout: z.optional(security_endpoint_management_api_timeout),
      }),
    })
  );

/**
 * Type of response action
 */
export const security_endpoint_management_api_type = z
  .enum(['automated', 'manual'])
  .register(z.globalRegistry, {
    description: 'Type of response action',
  });

/**
 * List of types of response actions
 */
export const security_endpoint_management_api_types = z
  .array(security_endpoint_management_api_type)
  .register(z.globalRegistry, {
    description: 'List of types of response actions',
  });

export const security_endpoint_management_api_unisolate =
  security_endpoint_management_api_response_action_details;

export const security_endpoint_management_api_unisolate_route_response = z.record(
  z.string(),
  z.unknown()
);

export const security_endpoint_management_api_upload =
  security_endpoint_management_api_response_action_details.and(
    z.object({
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            content: z.optional(
              z.object({
                code: z.optional(z.string()),
                disk_free_space: z.optional(z.number()),
                path: z.optional(z.string()),
              })
            ),
          })
        )
      ),
      parameters: z.optional(
        z
          .object({
            file_id: z.optional(z.string()),
            file_name: z.optional(z.string()),
            file_sha256: z.optional(z.string()),
            file_size: z.optional(z.number()),
          })
          .register(z.globalRegistry, {
            description:
              'The parameters for upload returned on the details are derived via the API from the file that\nwas uploaded at the time that the response action was submitted\n',
          })
      ),
    })
  );

export const security_endpoint_management_api_action_details_response = z.union([
  z
    .object({
      command: z.literal('kill-process'),
    })
    .and(security_endpoint_management_api_kill_process),
  z
    .object({
      command: z.literal('get-file'),
    })
    .and(security_endpoint_management_api_get_file),
  z
    .object({
      command: z.literal('execute'),
    })
    .and(security_endpoint_management_api_execute),
  z
    .object({
      command: z.literal('runscript'),
    })
    .and(security_endpoint_management_api_runscript),
  z
    .object({
      command: z.literal('upload'),
    })
    .and(security_endpoint_management_api_upload),
  z
    .object({
      command: z.literal('scan'),
    })
    .and(security_endpoint_management_api_scan),
  z
    .object({
      command: z.literal('cancel'),
    })
    .and(security_endpoint_management_api_cancel),
  z
    .object({
      command: z.union([z.literal('isolate'), z.literal('unisolate')]),
    })
    .and(security_endpoint_management_api_response_action_details),
  z
    .object({
      command: z.union([z.literal('isolate'), z.literal('unisolate')]),
    })
    .and(security_endpoint_management_api_response_action_details),
  z
    .object({
      command: z.literal('suspend-process'),
    })
    .and(security_endpoint_management_api_suspend_process),
  z
    .object({
      command: z.literal('running-processes'),
    })
    .and(security_endpoint_management_api_running_processes),
]);

export const security_endpoint_management_api_upload_route_request_body = z
  .object({
    agent_type: z.optional(security_endpoint_management_api_agent_types),
    alert_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description:
          'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
      })
    ),
    case_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'The IDs of cases where the action taken will be logged.',
      })
    ),
    comment: z.optional(security_endpoint_management_api_comment),
    endpoint_ids: security_endpoint_management_api_endpoint_ids,
    parameters: z.optional(security_endpoint_management_api_parameters),
  })
  .and(
    z.object({
      file: z.string().register(z.globalRegistry, {
        description: 'The binary content of the file.',
      }),
      parameters: z.object({
        overwrite: z
          .optional(
            z.boolean().register(z.globalRegistry, {
              description: 'Overwrite the file on the host if it already exists.',
            })
          )
          .default(false),
      }),
    })
  );

export const security_endpoint_management_api_upload_route_response = z.record(
  z.string(),
  z.unknown()
);

/**
 * A list of user IDs.
 */
export const security_endpoint_management_api_user_ids = z.union([
  z.array(z.string().min(1)).min(1),
  z.string().min(1),
]);

/**
 * A list of action IDs that should include the complete output of the action.
 */
export const security_endpoint_management_api_with_outputs = z.union([
  z.array(z.string().min(1)).min(1),
  z.string().min(1),
]);

export const security_entity_analytics_api_asset_criticality_bulk_upload_error_item = z.object({
  index: z.int(),
  message: z.string(),
});

export const security_entity_analytics_api_asset_criticality_bulk_upload_stats = z.object({
  failed: z.int(),
  successful: z.int(),
  total: z.int(),
});

/**
 * The criticality level of the asset.
 */
export const security_entity_analytics_api_asset_criticality_level = z
  .enum(['low_impact', 'medium_impact', 'high_impact', 'extreme_impact'])
  .register(z.globalRegistry, {
    description: 'The criticality level of the asset.',
  });

export const security_entity_analytics_api_asset = z.object({
  business_unit: z.optional(z.string()),
  criticality: z.optional(security_entity_analytics_api_asset_criticality_level),
  environment: z.optional(z.string()),
  id: z.optional(z.string()),
  model: z.optional(z.string()),
  name: z.optional(z.string()),
  owner: z.optional(z.string()),
  serial_number: z.optional(z.string()),
  vendor: z.optional(z.string()),
});

/**
 * The criticality level of the asset for bulk upload. The value `unassigned` is used to indicate that the criticality level is not assigned and is only used for bulk upload.
 */
export const security_entity_analytics_api_asset_criticality_levels_for_bulk_upload = z
  .enum(['low_impact', 'medium_impact', 'high_impact', 'extreme_impact', 'unassigned'])
  .register(z.globalRegistry, {
    description:
      'The criticality level of the asset for bulk upload. The value `unassigned` is used to indicate that the criticality level is not assigned and is only used for bulk upload.',
  });

export const security_entity_analytics_api_asset_criticality_record_ecs_parts = z.object({
  asset: z.object({
    criticality: z.optional(security_entity_analytics_api_asset_criticality_level),
  }),
  entity: z.optional(
    z.object({
      asset: z.optional(
        z.object({
          criticality: security_entity_analytics_api_asset_criticality_level,
        })
      ),
      id: z.string(),
    })
  ),
  host: z.optional(
    z.object({
      asset: z.optional(
        z.object({
          criticality: security_entity_analytics_api_asset_criticality_level,
        })
      ),
      name: z.string(),
    })
  ),
  service: z.optional(
    z.object({
      asset: z.optional(
        z.object({
          criticality: security_entity_analytics_api_asset_criticality_level,
        })
      ),
      name: z.string(),
    })
  ),
  user: z.optional(
    z.object({
      asset: z.optional(
        z.object({
          criticality: security_entity_analytics_api_asset_criticality_level,
        })
      ),
      name: z.string(),
    })
  ),
});

export const security_entity_analytics_api_clean_up_risk_engine_error_response = z.object({
  cleanup_successful: z.boolean(),
  errors: z.array(
    z.object({
      error: z.string(),
      seq: z.int(),
    })
  ),
});

export const security_entity_analytics_api_configure_risk_engine_saved_object_error_response =
  z.object({
    errors: z.array(
      z.object({
        error: z.string(),
        seq: z.int(),
      })
    ),
    risk_engine_saved_object_configured: z.boolean(),
  });

export const security_entity_analytics_api_engine_component_resource = z.enum([
  'entity_engine',
  'entity_definition',
  'index',
  'data_stream',
  'component_template',
  'index_template',
  'ingest_pipeline',
  'enrich_policy',
  'task',
  'transform',
  'ilm_policy',
]);

export const security_entity_analytics_api_engine_dataview_update_result = z.object({
  changes: z.optional(
    z.object({
      indexPatterns: z.optional(z.array(z.string())),
    })
  ),
  type: z.string(),
});

export const security_entity_analytics_api_engine_metadata = z.object({
  Type: z.string(),
});

export const security_entity_analytics_api_engine_status = z.enum([
  'installing',
  'started',
  'stopped',
  'updating',
  'error',
]);

export const security_entity_analytics_api_entity_analytics_privileges = z.object({
  has_all_required: z.boolean(),
  has_read_permissions: z.optional(z.boolean()),
  has_write_permissions: z.optional(z.boolean()),
  privileges: z.object({
    elasticsearch: z.object({
      cluster: z.optional(z.record(z.string(), z.boolean())),
      index: z.optional(z.record(z.string(), z.record(z.string(), z.boolean()))),
    }),
    kibana: z.optional(z.record(z.string(), z.boolean())),
  }),
});

export const security_entity_analytics_api_entity_risk_levels = z.enum([
  'Unknown',
  'Low',
  'Moderate',
  'High',
  'Critical',
]);

export const security_entity_analytics_api_entity_field = z.object({
  attributes: z.optional(
    z.object({
      asset: z.optional(z.boolean()),
      managed: z.optional(z.boolean()),
      mfa_enabled: z.optional(z.boolean()),
      privileged: z.optional(z.boolean()),
    })
  ),
  behaviors: z.optional(
    z.object({
      brute_force_victim: z.optional(z.boolean()),
      new_country_login: z.optional(z.boolean()),
      used_usb_device: z.optional(z.boolean()),
    })
  ),
  EngineMetadata: z.optional(security_entity_analytics_api_engine_metadata),
  id: z.string(),
  lifecycle: z.optional(
    z.object({
      first_seen: z.optional(z.iso.datetime()),
      last_activity: z.optional(z.iso.datetime()),
    })
  ),
  name: z.optional(z.string()),
  relationships: z.optional(
    z.object({
      accessed_frequently_by: z.optional(z.array(z.string())),
      accesses_frequently: z.optional(z.array(z.string())),
      communicates_with: z.optional(z.array(z.string())),
      dependent_of: z.optional(z.array(z.string())),
      depends_on: z.optional(z.array(z.string())),
      owned_by: z.optional(z.array(z.string())),
      owns: z.optional(z.array(z.string())),
      supervised_by: z.optional(z.array(z.string())),
      supervises: z.optional(z.array(z.string())),
    })
  ),
  risk: z.optional(
    z.object({
      calculated_level: z.optional(security_entity_analytics_api_entity_risk_levels),
      calculated_score: z.optional(
        z.number().register(z.globalRegistry, {
          description: "The raw numeric value of the given entity's risk score.",
        })
      ),
      calculated_score_norm: z.optional(
        z.number().gte(0).lte(100).register(z.globalRegistry, {
          description:
            "The normalized numeric value of the given entity's risk score. Useful for comparing with other entities.",
        })
      ),
    })
  ),
  source: z.optional(z.string()),
  sub_type: z.optional(z.string()),
  type: z.optional(z.string()),
});

export const security_entity_analytics_api_entity_type = z.enum([
  'user',
  'host',
  'service',
  'generic',
]);

export const security_entity_analytics_api_generic_entity = z.object({
  '@timestamp': z.optional(z.iso.datetime()),
  asset: z.optional(security_entity_analytics_api_asset),
  entity: security_entity_analytics_api_entity_field,
});

export const security_entity_analytics_api_id_field = z.enum([
  'host.name',
  'user.name',
  'service.name',
  'entity.id',
]);

export const security_entity_analytics_api_asset_criticality_record_id_parts = z.object({
  id_field: security_entity_analytics_api_id_field,
  id_value: z.string().register(z.globalRegistry, {
    description: 'The ID value of the asset.',
  }),
});

export const security_entity_analytics_api_create_asset_criticality_record =
  security_entity_analytics_api_asset_criticality_record_id_parts.and(
    z.object({
      criticality_level: security_entity_analytics_api_asset_criticality_level,
    })
  );

export const security_entity_analytics_api_asset_criticality_record =
  security_entity_analytics_api_create_asset_criticality_record
    .and(security_entity_analytics_api_asset_criticality_record_ecs_parts)
    .and(
      z.object({
        '@timestamp': z.iso.datetime().register(z.globalRegistry, {
          description: 'The time the record was created or updated.',
        }),
      })
    );

export const security_entity_analytics_api_index_pattern = z.string();

export const security_entity_analytics_api_engine_descriptor = z.object({
  delay: z.optional(z.string().regex(/[smdh]$/)).default('1m'),
  docsPerSecond: z.optional(z.int()),
  error: z.optional(
    z.object({
      action: z.enum(['init']),
      message: z.string(),
    })
  ),
  fieldHistoryLength: z.int(),
  filter: z.optional(z.string()),
  frequency: z.optional(z.string().regex(/[smdh]$/)).default('1m'),
  indexPattern: security_entity_analytics_api_index_pattern,
  lookbackPeriod: z.optional(z.string().regex(/[smdh]$/)).default('24h'),
  status: security_entity_analytics_api_engine_status,
  timeout: z.optional(z.string().regex(/[smdh]$/)).default('180s'),
  timestampField: z.optional(z.string()),
  type: security_entity_analytics_api_entity_type,
});

export const security_entity_analytics_api_inspect_query = z.object({
  dsl: z.array(z.string()),
  response: z.array(z.string()),
});

/**
 * Interval in which enrich policy runs. For example, `"1h"` means the rule runs every hour. Must be less than or equal to half the duration of the lookback period,
 */
export const security_entity_analytics_api_interval = z
  .string()
  .regex(/^[1-9]\d*[smh]$/)
  .register(z.globalRegistry, {
    description:
      'Interval in which enrich policy runs. For example, `"1h"` means the rule runs every hour. Must be less than or equal to half the duration of the lookback period,',
  });

export const security_entity_analytics_api_monitoring_label = z.object({
  field: z.string(),
  source: z.string(),
  value: z.string(),
});

export const security_entity_analytics_api_monitored_user_update_doc = z.object({
  entity_analytics_monitoring: z.optional(
    z.object({
      labels: z.optional(z.array(security_entity_analytics_api_monitoring_label)),
    })
  ),
  id: z.optional(z.string()),
  labels: z.optional(
    z.object({
      source_ids: z.optional(z.array(z.string())),
      source_integrations: z.optional(z.array(z.string())),
      sources: z.optional(z.array(z.enum(['csv', 'index_sync', 'api']))),
    })
  ),
  user: z.optional(
    z.object({
      is_privileged: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Indicates if the user is privileged.',
        })
      ),
      name: z.optional(z.string()),
    })
  ),
});

export const security_entity_analytics_api_monitored_user_doc =
  security_entity_analytics_api_monitored_user_update_doc.and(
    z.object({
      '@timestamp': z.optional(z.iso.datetime()),
      event: z.optional(
        z.object({
          ingested: z.optional(z.iso.datetime()),
        })
      ),
      user: z.optional(
        z.object({
          entity: z.optional(
            z.object({
              attributes: z.optional(
                z.object({
                  Privileged: z.optional(
                    z.boolean().register(z.globalRegistry, {
                      description: 'Indicates if the user is privileged.',
                    })
                  ),
                })
              ),
            })
          ),
          is_privileged: z.optional(
            z.boolean().register(z.globalRegistry, {
              description: 'Indicates if the user is privileged.',
            })
          ),
          name: z.optional(z.string()),
        })
      ),
    })
  );

/**
 * The status of the Privilege Monitoring Engine
 */
export const security_entity_analytics_api_privilege_monitoring_engine_status = z
  .enum(['started', 'error', 'disabled', 'not_installed'])
  .register(z.globalRegistry, {
    description: 'The status of the Privilege Monitoring Engine',
  });

export const security_entity_analytics_api_monitoring_engine_descriptor = z.object({
  error: z.optional(
    z.object({
      message: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Error message typically only present if the engine is in error state',
        })
      ),
    })
  ),
  status: security_entity_analytics_api_privilege_monitoring_engine_status,
});

export const security_entity_analytics_api_privmon_user_csv_upload_error_item = z.object({
  index: z.union([z.int(), z.null()]),
  message: z.string(),
  username: z.union([z.string(), z.null()]),
});

export const security_entity_analytics_api_privmon_user_csv_upload_stats = z.object({
  failed: z.int(),
  successful: z.int(),
  total: z.int(),
});

export const security_entity_analytics_api_risk_engine_schedule_now_error_response = z.object({
  full_error: z.string(),
  message: z.string(),
});

export const security_entity_analytics_api_risk_engine_schedule_now_response = z.object({
  success: z.optional(z.boolean()),
});

/**
 * A generic representation of a document contributing to a Risk Score.
 */
export const security_entity_analytics_api_risk_score_input = z
  .object({
    category: z.string().register(z.globalRegistry, {
      description: 'The risk category of the risk input document.',
    }),
    contribution_score: z.optional(z.number()),
    description: z.string().register(z.globalRegistry, {
      description: 'A human-readable description of the risk input document.',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The unique identifier (`_id`) of the original source document',
    }),
    index: z.string().register(z.globalRegistry, {
      description: 'The unique index (`_index`) of the original source document',
    }),
    risk_score: z.optional(
      z.number().gte(0).lte(100).register(z.globalRegistry, {
        description: 'The weighted risk score of the risk input document.',
      })
    ),
    timestamp: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The @timestamp of the risk input document.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'A generic representation of a document contributing to a Risk Score.',
  });

export const security_entity_analytics_api_entity_risk_score_record = z.object({
  '@timestamp': z.iso.datetime().register(z.globalRegistry, {
    description: 'The time at which the risk score was calculated.',
  }),
  calculated_level: security_entity_analytics_api_entity_risk_levels,
  calculated_score: z.number().register(z.globalRegistry, {
    description: "The raw numeric value of the given entity's risk score.",
  }),
  calculated_score_norm: z.number().gte(0).lte(100).register(z.globalRegistry, {
    description:
      "The normalized numeric value of the given entity's risk score. Useful for comparing with other entities.",
  }),
  category_1_count: z.int().register(z.globalRegistry, {
    description:
      'The number of risk input documents that contributed to the Category 1 score (`category_1_score`).',
  }),
  category_1_score: z.number().register(z.globalRegistry, {
    description:
      'The contribution of Category 1 to the overall risk score (`calculated_score`). Category 1 contains Detection Engine Alerts.',
  }),
  category_2_count: z.optional(z.int()),
  category_2_score: z.optional(z.number()),
  criticality_level: z.optional(security_entity_analytics_api_asset_criticality_level),
  criticality_modifier: z.optional(z.number()),
  id_field: z.string().register(z.globalRegistry, {
    description:
      'The identifier field defining this risk score. Coupled with `id_value`, uniquely identifies the entity being scored.',
  }),
  id_value: z.string().register(z.globalRegistry, {
    description:
      'The identifier value defining this risk score. Coupled with `id_field`, uniquely identifies the entity being scored.',
  }),
  inputs: z.array(security_entity_analytics_api_risk_score_input).register(z.globalRegistry, {
    description:
      'A list of the highest-risk documents contributing to this risk score. Useful for investigative purposes.',
  }),
  notes: z.array(z.string()),
});

export const security_entity_analytics_api_host_entity = z.object({
  '@timestamp': z.optional(z.iso.datetime()),
  asset: z.optional(security_entity_analytics_api_asset),
  entity: security_entity_analytics_api_entity_field,
  event: z.optional(
    z.object({
      ingested: z.optional(z.iso.datetime()),
    })
  ),
  host: z.optional(
    z.object({
      architecture: z.optional(z.array(z.string())),
      domain: z.optional(z.array(z.string())),
      entity: z.optional(security_entity_analytics_api_entity_field),
      hostname: z.optional(z.array(z.string())),
      id: z.optional(z.array(z.string())),
      ip: z.optional(z.array(z.string())),
      mac: z.optional(z.array(z.string())),
      name: z.string(),
      risk: z.optional(security_entity_analytics_api_entity_risk_score_record),
      type: z.optional(z.array(z.string())),
    })
  ),
});

export const security_entity_analytics_api_service_entity = z.object({
  '@timestamp': z.optional(z.iso.datetime()),
  asset: z.optional(security_entity_analytics_api_asset),
  entity: security_entity_analytics_api_entity_field,
  event: z.optional(
    z.object({
      ingested: z.optional(z.iso.datetime()),
    })
  ),
  service: z.optional(
    z.object({
      entity: z.optional(security_entity_analytics_api_entity_field),
      name: z.string(),
      risk: z.optional(security_entity_analytics_api_entity_risk_score_record),
    })
  ),
});

export const security_entity_analytics_api_store_status = z.enum([
  'not_installed',
  'installing',
  'running',
  'stopped',
  'error',
]);

/**
 * Task manager is unavailable
 */
export const security_entity_analytics_api_task_manager_unavailable_response = z
  .object({
    message: z.string(),
    status_code: z.int().gte(400),
  })
  .register(z.globalRegistry, {
    description: 'Task manager is unavailable',
  });

export const security_entity_analytics_api_transform_stats_metadata = z.object({
  delete_time_in_ms: z.optional(z.int()),
  documents_deleted: z.optional(z.int()),
  documents_indexed: z.int(),
  documents_processed: z.int(),
  exponential_avg_checkpoint_duration_ms: z.int(),
  exponential_avg_documents_indexed: z.int(),
  exponential_avg_documents_processed: z.int(),
  index_failures: z.int(),
  index_time_in_ms: z.int(),
  index_total: z.int(),
  pages_processed: z.int(),
  processing_time_in_ms: z.int(),
  processing_total: z.int(),
  search_failures: z.int(),
  search_time_in_ms: z.int(),
  search_total: z.int(),
  trigger_count: z.int(),
});

export const security_entity_analytics_api_engine_component_status = z.object({
  errors: z.optional(
    z.array(
      z.object({
        message: z.optional(z.string()),
        title: z.optional(z.string()),
      })
    )
  ),
  health: z.optional(z.enum(['green', 'yellow', 'red', 'unavailable', 'unknown'])),
  id: z.string(),
  installed: z.boolean(),
  metadata: z.optional(security_entity_analytics_api_transform_stats_metadata),
  resource: security_entity_analytics_api_engine_component_resource,
});

export const security_entity_analytics_api_metadata =
  security_entity_analytics_api_transform_stats_metadata;

export const security_entity_analytics_api_user_entity = z.object({
  '@timestamp': z.optional(z.iso.datetime()),
  asset: z.optional(security_entity_analytics_api_asset),
  entity: security_entity_analytics_api_entity_field,
  event: z.optional(
    z.object({
      ingested: z.optional(z.iso.datetime()),
    })
  ),
  user: z.optional(
    z.object({
      domain: z.optional(z.array(z.string())),
      email: z.optional(z.array(z.string())),
      full_name: z.optional(z.array(z.string())),
      hash: z.optional(z.array(z.string())),
      id: z.optional(z.array(z.string())),
      name: z.string(),
      risk: z.optional(security_entity_analytics_api_entity_risk_score_record),
      roles: z.optional(z.array(z.string())),
    })
  ),
});

export const security_entity_analytics_api_entity = z.union([
  security_entity_analytics_api_user_entity,
  security_entity_analytics_api_host_entity,
  security_entity_analytics_api_service_entity,
  security_entity_analytics_api_generic_entity,
]);

export const security_entity_analytics_api_entity_container = z.object({
  record: security_entity_analytics_api_entity,
  type: security_entity_analytics_api_entity_type,
});

export const security_entity_analytics_api_entities_container = z.object({
  entities: z.array(security_entity_analytics_api_entity_container),
});

export const security_entity_analytics_api_user_name = z.object({
  user: z.optional(
    z.object({
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The name of the user.',
        })
      ),
    })
  ),
});

/**
 * Describes the exception list.
 */
export const security_exceptions_api_exception_list_description = z
  .string()
  .register(z.globalRegistry, {
    description: 'Describes the exception list.',
  });

/**
 * The exception list's human readable string identifier, `endpoint_list`.
 */
export const security_exceptions_api_exception_list_human_id = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: "The exception list's human readable string identifier, `endpoint_list`.",
  });

/**
 * Exception list's identifier.
 */
export const security_exceptions_api_exception_list_id = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: "Exception list's identifier.",
  });

/**
 * Describes the exception list.
 */
export const security_exceptions_api_exception_list_item_description = z
  .string()
  .register(z.globalRegistry, {
    description: 'Describes the exception list.',
  });

export const security_exceptions_api_exception_list_item_entry_operator = z.enum([
  'excluded',
  'included',
]);

/**
 * The exception items expiration date, in ISO format. This field is only available for regular exception items, not endpoint exceptions.
 */
export const security_exceptions_api_exception_list_item_expire_time = z.iso
  .datetime()
  .register(z.globalRegistry, {
    description:
      'The exception items expiration date, in ISO format. This field is only available for regular exception items, not endpoint exceptions.',
  });

/**
 * Human readable string identifier, e.g. `trusted-linux-processes`
 */
export const security_exceptions_api_exception_list_item_human_id = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: 'Human readable string identifier, e.g. `trusted-linux-processes`',
  });

/**
 * Exception's identifier.
 */
export const security_exceptions_api_exception_list_item_id = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: "Exception's identifier.",
  });

export const security_exceptions_api_exception_list_item_meta = z.record(z.string(), z.unknown());

/**
 * Exception list name.
 */
export const security_exceptions_api_exception_list_item_name = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: 'Exception list name.',
  });

export const security_exceptions_api_exception_list_item_tags = z.array(
  z.string().min(1).register(z.globalRegistry, {
    description: 'String array containing words and phrases to help categorize exception items.',
  })
);

export const security_exceptions_api_exception_list_item_type = z.enum(['simple']);

/**
 * Placeholder for metadata about the list container.
 */
export const security_exceptions_api_exception_list_meta = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Placeholder for metadata about the list container.',
  });

/**
 * The name of the exception list.
 */
export const security_exceptions_api_exception_list_name = z.string().register(z.globalRegistry, {
  description: 'The name of the exception list.',
});

/**
 * Use this field to specify the operating system.
 */
export const security_exceptions_api_exception_list_os_type = z
  .enum(['linux', 'macos', 'windows'])
  .register(z.globalRegistry, {
    description: 'Use this field to specify the operating system.',
  });

export const security_exceptions_api_exception_list_item_os_type_array = z.array(
  security_exceptions_api_exception_list_os_type
);

/**
 * Use this field to specify the operating system. Only enter one value.
 */
export const security_exceptions_api_exception_list_os_type_array = z
  .array(security_exceptions_api_exception_list_os_type)
  .register(z.globalRegistry, {
    description: 'Use this field to specify the operating system. Only enter one value.',
  });

export const security_exceptions_api_exception_lists_import_bulk_error = z.object({
  error: z.object({
    message: z.string(),
    status_code: z.int(),
  }),
  id: z.optional(security_exceptions_api_exception_list_id),
  item_id: z.optional(security_exceptions_api_exception_list_item_human_id),
  list_id: z.optional(security_exceptions_api_exception_list_human_id),
});

export const security_exceptions_api_exception_lists_import_bulk_error_array = z.array(
  security_exceptions_api_exception_lists_import_bulk_error
);

/**
 * String array containing words and phrases to help categorize exception containers.
 */
export const security_exceptions_api_exception_list_tags = z
  .array(z.string())
  .register(z.globalRegistry, {
    description:
      'String array containing words and phrases to help categorize exception containers.',
  });

/**
 * The type of exception list to be created. Different list types may denote where they can be utilized.
 */
export const security_exceptions_api_exception_list_type = z
  .enum([
    'detection',
    'rule_default',
    'endpoint',
    'endpoint_trusted_apps',
    'endpoint_trusted_devices',
    'endpoint_events',
    'endpoint_host_isolation_exceptions',
    'endpoint_blocklists',
  ])
  .register(z.globalRegistry, {
    description:
      'The type of exception list to be created. Different list types may denote where they can be utilized.',
  });

/**
 * The document version, automatically increasd on updates.
 */
export const security_exceptions_api_exception_list_version = z
  .int()
  .gte(1)
  .register(z.globalRegistry, {
    description: 'The document version, automatically increasd on updates.',
  });

/**
 * Determines whether the exception container is available in all Kibana spaces or just the space
 * in which it is created, where:
 *
 * - `single`: Only available in the Kibana space in which it is created.
 * - `agnostic`: Available in all Kibana spaces.
 *
 */
export const security_exceptions_api_exception_namespace_type = z
  .enum(['agnostic', 'single'])
  .register(z.globalRegistry, {
    description:
      'Determines whether the exception container is available in all Kibana spaces or just the space\nin which it is created, where:\n\n- `single`: Only available in the Kibana space in which it is created.\n- `agnostic`: Available in all Kibana spaces.\n',
  });

export const security_exceptions_api_exception_list = z.object({
  _version: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The version id, normally returned by the API when the item was retrieved. Use it ensure updates are done against the latest version.',
    })
  ),
  created_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of object creation.',
  }),
  created_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that created object.',
  }),
  description: security_exceptions_api_exception_list_description,
  id: security_exceptions_api_exception_list_id,
  immutable: z.boolean(),
  list_id: security_exceptions_api_exception_list_human_id,
  meta: z.optional(security_exceptions_api_exception_list_meta),
  name: security_exceptions_api_exception_list_name,
  namespace_type: security_exceptions_api_exception_namespace_type,
  os_types: z.optional(security_exceptions_api_exception_list_os_type_array),
  tags: z.optional(security_exceptions_api_exception_list_tags),
  tie_breaker_id: z.string().register(z.globalRegistry, {
    description: 'Field used in search to ensure all containers are sorted and returned correctly.',
  }),
  type: security_exceptions_api_exception_list_type,
  updated_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of last object update.',
  }),
  updated_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that last updated object.',
  }),
  version: security_exceptions_api_exception_list_version,
});

export const security_exceptions_api_find_exception_lists_filter = z.string();

/**
 * Value list's identifier.
 */
export const security_exceptions_api_list_id = z.string().min(1).register(z.globalRegistry, {
  description: "Value list's identifier.",
});

/**
 * Specifies the Elasticsearch data type of excludes the list container holds. Some common examples:
 *
 * - `keyword`: Many ECS fields are Elasticsearch keywords
 * - `ip`: IP addresses
 * - `ip_range`: Range of IP addresses (supports IPv4, IPv6, and CIDR notation)
 *
 */
export const security_exceptions_api_list_type = z
  .enum([
    'binary',
    'boolean',
    'byte',
    'date',
    'date_nanos',
    'date_range',
    'double',
    'double_range',
    'float',
    'float_range',
    'geo_point',
    'geo_shape',
    'half_float',
    'integer',
    'integer_range',
    'ip',
    'ip_range',
    'keyword',
    'long',
    'long_range',
    'shape',
    'short',
    'text',
  ])
  .register(z.globalRegistry, {
    description:
      'Specifies the Elasticsearch data type of excludes the list container holds. Some common examples:\n\n- `keyword`: Many ECS fields are Elasticsearch keywords\n- `ip`: IP addresses\n- `ip_range`: Range of IP addresses (supports IPv4, IPv6, and CIDR notation)\n',
  });

/**
 * A string that does not contain only whitespace characters
 */
export const security_exceptions_api_non_empty_string = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description: 'A string that does not contain only whitespace characters',
  });

export const security_exceptions_api_create_exception_list_item_comment = z.object({
  comment: security_exceptions_api_non_empty_string,
});

export const security_exceptions_api_create_exception_list_item_comment_array = z.array(
  security_exceptions_api_create_exception_list_item_comment
);

export const security_exceptions_api_create_rule_exception_list_item_comment = z.object({
  comment: security_exceptions_api_non_empty_string,
});

export const security_exceptions_api_create_rule_exception_list_item_comment_array = z.array(
  security_exceptions_api_create_rule_exception_list_item_comment
);

export const security_exceptions_api_exception_list_item_comment = z.object({
  comment: security_exceptions_api_non_empty_string,
  created_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of object creation.',
  }),
  created_by: security_exceptions_api_non_empty_string,
  id: security_exceptions_api_non_empty_string,
  updated_at: z.optional(
    z.iso.datetime().register(z.globalRegistry, {
      description: 'Autogenerated date of last object update.',
    })
  ),
  updated_by: z.optional(security_exceptions_api_non_empty_string),
});

/**
 * Array of comment fields:
 *
 * - comment (string): Comments about the exception item.
 *
 */
export const security_exceptions_api_exception_list_item_comment_array = z
  .array(security_exceptions_api_exception_list_item_comment)
  .register(z.globalRegistry, {
    description:
      'Array of comment fields:\n\n- comment (string): Comments about the exception item.\n',
  });

export const security_exceptions_api_exception_list_item_entry_exists = z.object({
  field: security_exceptions_api_non_empty_string,
  operator: security_exceptions_api_exception_list_item_entry_operator,
  type: z.enum(['exists']),
});

export const security_exceptions_api_exception_list_item_entry_list = z.object({
  field: security_exceptions_api_non_empty_string,
  list: z.object({
    id: security_exceptions_api_list_id,
    type: security_exceptions_api_list_type,
  }),
  operator: security_exceptions_api_exception_list_item_entry_operator,
  type: z.enum(['list']),
});

export const security_exceptions_api_exception_list_item_entry_match = z.object({
  field: security_exceptions_api_non_empty_string,
  operator: security_exceptions_api_exception_list_item_entry_operator,
  type: z.enum(['match']),
  value: security_exceptions_api_non_empty_string,
});

export const security_exceptions_api_exception_list_item_entry_match_any = z.object({
  field: security_exceptions_api_non_empty_string,
  operator: security_exceptions_api_exception_list_item_entry_operator,
  type: z.enum(['match_any']),
  value: z.array(security_exceptions_api_non_empty_string).min(1),
});

export const security_exceptions_api_exception_list_item_entry_match_wildcard = z.object({
  field: security_exceptions_api_non_empty_string,
  operator: security_exceptions_api_exception_list_item_entry_operator,
  type: z.enum(['wildcard']),
  value: security_exceptions_api_non_empty_string,
});

export const security_exceptions_api_exception_list_item_entry_nested_entry_item = z.union([
  security_exceptions_api_exception_list_item_entry_match,
  security_exceptions_api_exception_list_item_entry_match_any,
  security_exceptions_api_exception_list_item_entry_exists,
]);

export const security_exceptions_api_exception_list_item_entry_nested = z.object({
  entries: z.array(security_exceptions_api_exception_list_item_entry_nested_entry_item).min(1),
  field: security_exceptions_api_non_empty_string,
  type: z.enum(['nested']),
});

export const security_exceptions_api_exception_list_item_entry = z.union([
  z
    .object({
      type: z.optional(z.literal('Security_Exceptions_API_ExceptionListItemEntryMatch')),
    })
    .and(security_exceptions_api_exception_list_item_entry_match),
  z
    .object({
      type: z.optional(z.literal('Security_Exceptions_API_ExceptionListItemEntryMatchAny')),
    })
    .and(security_exceptions_api_exception_list_item_entry_match_any),
  z
    .object({
      type: z.optional(z.literal('Security_Exceptions_API_ExceptionListItemEntryList')),
    })
    .and(security_exceptions_api_exception_list_item_entry_list),
  z
    .object({
      type: z.optional(z.literal('Security_Exceptions_API_ExceptionListItemEntryExists')),
    })
    .and(security_exceptions_api_exception_list_item_entry_exists),
  z
    .object({
      type: z.optional(z.literal('Security_Exceptions_API_ExceptionListItemEntryNested')),
    })
    .and(security_exceptions_api_exception_list_item_entry_nested),
  z
    .object({
      type: z.optional(z.literal('Security_Exceptions_API_ExceptionListItemEntryMatchWildcard')),
    })
    .and(security_exceptions_api_exception_list_item_entry_match_wildcard),
]);

export const security_exceptions_api_exception_list_item_entry_array = z.array(
  security_exceptions_api_exception_list_item_entry
);

export const security_exceptions_api_create_rule_exception_list_item_props = z.object({
  comments: z.optional(security_exceptions_api_create_rule_exception_list_item_comment_array),
  description: security_exceptions_api_exception_list_item_description,
  entries: security_exceptions_api_exception_list_item_entry_array,
  expire_time: z.optional(z.iso.datetime()),
  item_id: z.optional(security_exceptions_api_exception_list_item_human_id),
  meta: z.optional(security_exceptions_api_exception_list_item_meta),
  name: security_exceptions_api_exception_list_item_name,
  namespace_type: z.optional(security_exceptions_api_exception_namespace_type),
  os_types: z.optional(security_exceptions_api_exception_list_item_os_type_array),
  tags: z.optional(security_exceptions_api_exception_list_item_tags),
  type: security_exceptions_api_exception_list_item_type,
});

export const security_exceptions_api_exception_list_item = z.object({
  _version: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The version id, normally returned by the API when the item was retrieved. Use it ensure updates are done against the latest version.',
    })
  ),
  comments: security_exceptions_api_exception_list_item_comment_array,
  created_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of object creation.',
  }),
  created_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that created object.',
  }),
  description: security_exceptions_api_exception_list_item_description,
  entries: security_exceptions_api_exception_list_item_entry_array,
  expire_time: z.optional(security_exceptions_api_exception_list_item_expire_time),
  id: security_exceptions_api_exception_list_item_id,
  item_id: security_exceptions_api_exception_list_item_human_id,
  list_id: security_exceptions_api_exception_list_human_id,
  meta: z.optional(security_exceptions_api_exception_list_item_meta),
  name: security_exceptions_api_exception_list_item_name,
  namespace_type: security_exceptions_api_exception_namespace_type,
  os_types: z.optional(security_exceptions_api_exception_list_item_os_type_array),
  tags: z.optional(security_exceptions_api_exception_list_item_tags),
  tie_breaker_id: z.string().register(z.globalRegistry, {
    description: 'Field used in search to ensure all containers are sorted and returned correctly.',
  }),
  type: security_exceptions_api_exception_list_item_type,
  updated_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of last object update.',
  }),
  updated_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that last updated object.',
  }),
});

export const security_exceptions_api_find_exception_list_items_filter =
  security_exceptions_api_non_empty_string;

export const security_exceptions_api_platform_error_response = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.int(),
});

export const security_exceptions_api_siem_error_response = z.object({
  message: z.string(),
  status_code: z.int(),
});

export const security_exceptions_api_update_exception_list_item_comment = z.object({
  comment: security_exceptions_api_non_empty_string,
  id: z.optional(security_exceptions_api_non_empty_string),
});

export const security_exceptions_api_update_exception_list_item_comment_array = z.array(
  security_exceptions_api_update_exception_list_item_comment
);

/**
 * A universally unique identifier
 */
export const security_exceptions_api_uuid = z.uuid().register(z.globalRegistry, {
  description: 'A universally unique identifier',
});

export const security_exceptions_api_rule_id = security_exceptions_api_uuid;

/**
 * Returns the items that come after the last item returned in the previous call (use the `cursor` value returned in the previous call). This parameter uses the `tie_breaker_id` field to ensure all items are sorted and returned correctly.
 */
export const security_lists_api_find_list_items_cursor = z
  .string()
  .min(1)
  .register(z.globalRegistry, {
    description:
      'Returns the items that come after the last item returned in the previous call (use the `cursor` value returned in the previous call). This parameter uses the `tie_breaker_id` field to ensure all items are sorted and returned correctly.',
  });

export const security_lists_api_find_list_items_filter = z.string();

export const security_lists_api_find_lists_cursor = z.string().min(1);

export const security_lists_api_find_lists_filter = z.string();

/**
 * Describes the value list.
 */
export const security_lists_api_list_description = z.string().min(1).register(z.globalRegistry, {
  description: 'Describes the value list.',
});

/**
 * Determines how retrieved list item values are presented. By default list items are presented using these Handelbar expressions:
 *
 * - `{{{value}}}` - Single value item types, such as `ip`, `long`, `date`, `keyword`, and `text`.
 * - `{{{gte}}}-{{{lte}}}` - Range value item types, such as `ip_range`, `double_range`, `float_range`, `integer_range`, and `long_range`.
 * - `{{{gte}}},{{{lte}}}` - Date range values.
 *
 */
export const security_lists_api_list_deserializer = z.string().register(z.globalRegistry, {
  description:
    'Determines how retrieved list item values are presented. By default list items are presented using these Handelbar expressions:\n\n- `{{{value}}}` - Single value item types, such as `ip`, `long`, `date`, `keyword`, and `text`.\n- `{{{gte}}}-{{{lte}}}` - Range value item types, such as `ip_range`, `double_range`, `float_range`, `integer_range`, and `long_range`.\n- `{{{gte}}},{{{lte}}}` - Date range values.\n',
});

/**
 * Value list's identifier.
 */
export const security_lists_api_list_id = z.string().min(1).register(z.globalRegistry, {
  description: "Value list's identifier.",
});

/**
 * Value list item's identifier.
 */
export const security_lists_api_list_item_id = z.string().min(1).register(z.globalRegistry, {
  description: "Value list item's identifier.",
});

/**
 * Placeholder for metadata about the value list item.
 */
export const security_lists_api_list_item_metadata = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Placeholder for metadata about the value list item.',
  });

export const security_lists_api_list_item_privileges = z.object({
  application: z.record(z.string(), z.boolean()),
  cluster: z.record(z.string(), z.boolean()),
  has_all_requested: z.boolean(),
  index: z.record(z.string(), z.record(z.string(), z.boolean())),
  username: z.string(),
});

/**
 * The value used to evaluate exceptions.
 */
export const security_lists_api_list_item_value = z.string().min(1).register(z.globalRegistry, {
  description: 'The value used to evaluate exceptions.',
});

/**
 * Placeholder for metadata about the value list.
 */
export const security_lists_api_list_metadata = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Placeholder for metadata about the value list.',
  });

/**
 * Value list's name.
 */
export const security_lists_api_list_name = z.string().min(1).register(z.globalRegistry, {
  description: "Value list's name.",
});

export const security_lists_api_list_privileges = z.object({
  application: z.record(z.string(), z.boolean()),
  cluster: z.record(z.string(), z.boolean()),
  has_all_requested: z.boolean(),
  index: z.record(z.string(), z.record(z.string(), z.boolean())),
  username: z.string(),
});

/**
 * Determines how uploaded list item values are parsed. By default, list items are parsed using these named regex groups:
 *
 * - `(?<value>.+)` - Single value item types, such as ip, long, date, keyword, and text.
 * - `(?<gte>.+)-(?<lte>.+)|(?<value>.+)` - Range value item types, such as `date_range`, `ip_range`, `double_range`, `float_range`, `integer_range`, and `long_range`.
 *
 */
export const security_lists_api_list_serializer = z.string().register(z.globalRegistry, {
  description:
    'Determines how uploaded list item values are parsed. By default, list items are parsed using these named regex groups:\n\n- `(?<value>.+)` - Single value item types, such as ip, long, date, keyword, and text.\n- `(?<gte>.+)-(?<lte>.+)|(?<value>.+)` - Range value item types, such as `date_range`, `ip_range`, `double_range`, `float_range`, `integer_range`, and `long_range`.\n',
});

/**
 * Specifies the Elasticsearch data type of excludes the list container holds. Some common examples:
 *
 * - `keyword`: Many ECS fields are Elasticsearch keywords
 * - `ip`: IP addresses
 * - `ip_range`: Range of IP addresses (supports IPv4, IPv6, and CIDR notation)
 *
 */
export const security_lists_api_list_type = z
  .enum([
    'binary',
    'boolean',
    'byte',
    'date',
    'date_nanos',
    'date_range',
    'double',
    'double_range',
    'float',
    'float_range',
    'geo_point',
    'geo_shape',
    'half_float',
    'integer',
    'integer_range',
    'ip',
    'ip_range',
    'keyword',
    'long',
    'long_range',
    'shape',
    'short',
    'text',
  ])
  .register(z.globalRegistry, {
    description:
      'Specifies the Elasticsearch data type of excludes the list container holds. Some common examples:\n\n- `keyword`: Many ECS fields are Elasticsearch keywords\n- `ip`: IP addresses\n- `ip_range`: Range of IP addresses (supports IPv4, IPv6, and CIDR notation)\n',
  });

/**
 * The document version number.
 */
export const security_lists_api_list_version = z.int().gte(1).register(z.globalRegistry, {
  description: 'The document version number.',
});

/**
 * The version id, normally returned by the API when the document is retrieved. Use it ensure updates are done against the latest version.
 *
 */
export const security_lists_api_list_version_id = z.string().register(z.globalRegistry, {
  description:
    'The version id, normally returned by the API when the document is retrieved. Use it ensure updates are done against the latest version.\n',
});

export const security_lists_api_list = z.object({
  _version: z.optional(security_lists_api_list_version_id),
  '@timestamp': z.optional(z.iso.datetime()),
  created_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of object creation.',
  }),
  created_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that created object.',
  }),
  description: security_lists_api_list_description,
  deserializer: z.optional(security_lists_api_list_deserializer),
  id: security_lists_api_list_id,
  immutable: z.boolean(),
  meta: z.optional(security_lists_api_list_metadata),
  name: security_lists_api_list_name,
  serializer: z.optional(security_lists_api_list_serializer),
  tie_breaker_id: z.string().register(z.globalRegistry, {
    description: 'Field used in search to ensure all containers are sorted and returned correctly.',
  }),
  type: security_lists_api_list_type,
  updated_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of last object update.',
  }),
  updated_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that last updated object.',
  }),
  version: security_lists_api_list_version,
});

export const security_lists_api_list_item = z.object({
  _version: z.optional(security_lists_api_list_version_id),
  '@timestamp': z.optional(z.iso.datetime()),
  created_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of object creation.',
  }),
  created_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that created object.',
  }),
  deserializer: z.optional(security_lists_api_list_deserializer),
  id: security_lists_api_list_item_id,
  list_id: security_lists_api_list_id,
  meta: z.optional(security_lists_api_list_item_metadata),
  serializer: z.optional(security_lists_api_list_serializer),
  tie_breaker_id: z.string().register(z.globalRegistry, {
    description: 'Field used in search to ensure all containers are sorted and returned correctly.',
  }),
  type: security_lists_api_list_type,
  updated_at: z.iso.datetime().register(z.globalRegistry, {
    description: 'Autogenerated date of last object update.',
  }),
  updated_by: z.string().register(z.globalRegistry, {
    description: 'Autogenerated value - user that last updated object.',
  }),
  value: security_lists_api_list_item_value,
});

export const security_lists_api_platform_error_response = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.int(),
});

export const security_lists_api_siem_error_response = z.object({
  message: z.string(),
  status_code: z.int(),
});

export const security_osquery_api_create_live_query_response = z.record(z.string(), z.unknown());

export const security_osquery_api_create_packs_response = z.record(z.string(), z.unknown());

export const security_osquery_api_create_saved_query_response = z.record(z.string(), z.unknown());

export const security_osquery_api_default_success_response = z.record(z.string(), z.unknown());

export const security_osquery_api_ecs_mapping_item = z.object({
  field: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The ECS field to map to.',
    })
  ),
  value: z.optional(z.union([z.string(), z.array(z.string())])),
});

/**
 * Map osquery results columns or static values to Elastic Common Schema (ECS) fields
 */
export const security_osquery_api_ecs_mapping = z
  .record(z.string(), security_osquery_api_ecs_mapping_item)
  .register(z.globalRegistry, {
    description:
      'Map osquery results columns or static values to Elastic Common Schema (ECS) fields',
  });

export const security_osquery_api_ecs_mapping_or_undefined = security_osquery_api_ecs_mapping;

/**
 * Enables the pack.
 */
export const security_osquery_api_enabled = z.boolean().register(z.globalRegistry, {
  description: 'Enables the pack.',
});

export const security_osquery_api_enabled_or_undefined = security_osquery_api_enabled;

export const security_osquery_api_find_live_query_details_response = z.record(
  z.string(),
  z.unknown()
);

export const security_osquery_api_find_live_query_response = z.record(z.string(), z.unknown());

export const security_osquery_api_find_pack_response = z.record(z.string(), z.unknown());

export const security_osquery_api_find_packs_response = z.record(z.string(), z.unknown());

export const security_osquery_api_find_saved_query_detail_response = z.record(
  z.string(),
  z.unknown()
);

export const security_osquery_api_find_saved_query_response = z.record(z.string(), z.unknown());

/**
 * The response for getting live query results.
 */
export const security_osquery_api_get_live_query_results_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'The response for getting live query results.',
  });

/**
 * An interval, in seconds, on which to run the query.
 */
export const security_osquery_api_interval = z.string().register(z.globalRegistry, {
  description: 'An interval, in seconds, on which to run the query.',
});

export const security_osquery_api_interval_or_undefined = security_osquery_api_interval;

/**
 * The kuery to filter the results by.
 */
export const security_osquery_api_kuery_or_undefined = z.union([z.string(), z.null()]);

/**
 * The pack description.
 */
export const security_osquery_api_pack_description = z.string().register(z.globalRegistry, {
  description: 'The pack description.',
});

export const security_osquery_api_pack_description_or_undefined =
  security_osquery_api_pack_description;

/**
 * The ID of the pack you want to run, retrieve, update, or delete.
 */
export const security_osquery_api_pack_id = z.string().register(z.globalRegistry, {
  description: 'The ID of the pack you want to run, retrieve, update, or delete.',
});

export const security_osquery_api_pack_id_or_undefined = security_osquery_api_pack_id;

/**
 * The pack name.
 */
export const security_osquery_api_pack_name = z.string().register(z.globalRegistry, {
  description: 'The pack name.',
});

/**
 * The page number to return. The default is 1.
 */
export const security_osquery_api_page_or_undefined = z.union([z.int(), z.null()]);

/**
 * The number of results to return per page. The default is 20.
 */
export const security_osquery_api_page_size_or_undefined = z.union([z.int(), z.null()]);

/**
 * Restricts the query to a specified platform. The default is all platforms. To specify multiple platforms, use commas. For example, `linux,darwin`.
 */
export const security_osquery_api_platform = z.string().register(z.globalRegistry, {
  description:
    'Restricts the query to a specified platform. The default is all platforms. To specify multiple platforms, use commas. For example, `linux,darwin`.',
});

export const security_osquery_api_platform_or_undefined = security_osquery_api_platform;

/**
 * A list of agents policy IDs.
 */
export const security_osquery_api_policy_ids = z.array(z.string()).register(z.globalRegistry, {
  description: 'A list of agents policy IDs.',
});

export const security_osquery_api_policy_ids_or_undefined = security_osquery_api_policy_ids;

/**
 * The SQL query you want to run.
 */
export const security_osquery_api_query = z.string().register(z.globalRegistry, {
  description: 'The SQL query you want to run.',
});

/**
 * The ID of the query.
 */
export const security_osquery_api_query_id = z.string().register(z.globalRegistry, {
  description: 'The ID of the query.',
});

export const security_osquery_api_query_or_undefined = security_osquery_api_query;

/**
 * Indicates whether the query is removed.
 */
export const security_osquery_api_removed = z.boolean().register(z.globalRegistry, {
  description: 'Indicates whether the query is removed.',
});

export const security_osquery_api_removed_or_undefined = security_osquery_api_removed;

/**
 * The saved query description.
 */
export const security_osquery_api_saved_query_description = z.string().register(z.globalRegistry, {
  description: 'The saved query description.',
});

export const security_osquery_api_saved_query_description_or_undefined =
  security_osquery_api_saved_query_description;

/**
 * The ID of a saved query.
 */
export const security_osquery_api_saved_query_id = z.string().register(z.globalRegistry, {
  description: 'The ID of a saved query.',
});

export const security_osquery_api_saved_query_id_or_undefined = security_osquery_api_saved_query_id;

/**
 * An object with shard configuration for policies included in the pack. For each policy, set the shard configuration to a percentage (1100) of target hosts.
 */
export const security_osquery_api_shards = z
  .record(z.string(), z.number())
  .register(z.globalRegistry, {
    description:
      'An object with shard configuration for policies included in the pack. For each policy, set the shard configuration to a percentage (1100) of target hosts.',
  });

/**
 * Indicates whether the query is a snapshot.
 */
export const security_osquery_api_snapshot = z.boolean().register(z.globalRegistry, {
  description: 'Indicates whether the query is a snapshot.',
});

export const security_osquery_api_snapshot_or_undefined = security_osquery_api_snapshot;

/**
 * Specifies the sort order.
 */
export const security_osquery_api_sort_order_or_undefined = z
  .enum(['asc', 'desc'])
  .register(z.globalRegistry, {
    description: 'Specifies the sort order.',
  });

/**
 * The field that is used to sort the results.
 */
export const security_osquery_api_sort_or_undefined = z
  .union([z.string().default('createdAt'), z.null()])
  .default('createdAt');

export const security_osquery_api_update_packs_response = z.record(z.string(), z.unknown());

export const security_osquery_api_update_saved_query_response = z.record(z.string(), z.unknown());

/**
 * Uses the Osquery versions greater than or equal to the specified version string.
 */
export const security_osquery_api_version = z.string().register(z.globalRegistry, {
  description: 'Uses the Osquery versions greater than or equal to the specified version string.',
});

export const security_osquery_api_array_queries_item = z.object({
  ecs_mapping: z.optional(security_osquery_api_ecs_mapping),
  id: z.optional(security_osquery_api_query_id),
  platform: z.optional(security_osquery_api_platform),
  query: z.optional(security_osquery_api_query),
  removed: z.optional(security_osquery_api_removed),
  snapshot: z.optional(security_osquery_api_snapshot),
  version: z.optional(security_osquery_api_version),
});

/**
 * An array of queries to run.
 */
export const security_osquery_api_array_queries = z
  .array(security_osquery_api_array_queries_item)
  .register(z.globalRegistry, {
    description: 'An array of queries to run.',
  });

export const security_osquery_api_create_live_query_request_body = z.object({
  agent_all: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'When `true`, the query runs on all agents.',
    })
  ),
  agent_ids: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'A list of agent IDs to run the query on.',
    })
  ),
  agent_platforms: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'A list of agent platforms to run the query on.',
    })
  ),
  agent_policy_ids: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'A list of agent policy IDs to run the query on.',
    })
  ),
  alert_ids: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'A list of alert IDs associated with the live query.',
    })
  ),
  case_ids: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'A list of case IDs associated with the live query.',
    })
  ),
  ecs_mapping: z.optional(security_osquery_api_ecs_mapping),
  event_ids: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'A list of event IDs associated with the live query.',
    })
  ),
  metadata: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
  pack_id: z.optional(security_osquery_api_pack_id),
  queries: z.optional(security_osquery_api_array_queries),
  query: z.optional(security_osquery_api_query),
  saved_query_id: z.optional(security_osquery_api_saved_query_id),
});

export const security_osquery_api_create_saved_query_request_body = z.object({
  description: z.optional(security_osquery_api_saved_query_description),
  ecs_mapping: z.optional(security_osquery_api_ecs_mapping),
  id: z.optional(security_osquery_api_saved_query_id),
  interval: z.optional(security_osquery_api_interval),
  platform: z.optional(security_osquery_api_platform),
  query: z.optional(security_osquery_api_query),
  removed: z.optional(security_osquery_api_removed),
  snapshot: z.optional(security_osquery_api_snapshot),
  version: z.optional(security_osquery_api_version),
});

export const security_osquery_api_object_queries_item = z.object({
  ecs_mapping: z.optional(security_osquery_api_ecs_mapping),
  id: z.optional(security_osquery_api_query_id),
  platform: z.optional(security_osquery_api_platform),
  query: z.optional(security_osquery_api_query),
  removed: z.optional(security_osquery_api_removed),
  saved_query_id: z.optional(security_osquery_api_saved_query_id),
  snapshot: z.optional(security_osquery_api_snapshot),
  version: z.optional(security_osquery_api_version),
});

/**
 * An object of queries.
 */
export const security_osquery_api_object_queries = z
  .record(z.string(), security_osquery_api_object_queries_item)
  .register(z.globalRegistry, {
    description: 'An object of queries.',
  });

export const security_osquery_api_create_packs_request_body = z.object({
  description: z.optional(security_osquery_api_pack_description),
  enabled: z.optional(security_osquery_api_enabled),
  name: z.optional(security_osquery_api_pack_name),
  policy_ids: z.optional(security_osquery_api_policy_ids),
  queries: z.optional(security_osquery_api_object_queries),
  shards: z.optional(security_osquery_api_shards),
});

export const security_osquery_api_update_packs_request_body = z.object({
  description: z.optional(security_osquery_api_pack_description),
  enabled: z.optional(security_osquery_api_enabled),
  name: z.optional(security_osquery_api_pack_name),
  policy_ids: z.optional(security_osquery_api_policy_ids),
  queries: z.optional(security_osquery_api_object_queries),
  shards: z.optional(security_osquery_api_shards),
});

export const security_osquery_api_update_saved_query_request_body = z.object({
  description: z.optional(security_osquery_api_saved_query_description),
  ecs_mapping: z.optional(security_osquery_api_ecs_mapping),
  id: z.optional(security_osquery_api_saved_query_id),
  interval: z.optional(security_osquery_api_interval),
  platform: z.optional(security_osquery_api_platform),
  query: z.optional(security_osquery_api_query),
  removed: z.optional(security_osquery_api_removed),
  snapshot: z.optional(security_osquery_api_snapshot),
  version: z.optional(security_osquery_api_version),
});

export const security_osquery_api_version_or_undefined = security_osquery_api_version;

/**
 * Filter notes based on their association with a document or saved object.
 */
export const security_timeline_api_associated_filter_type = z
  .enum(['all', 'document_only', 'saved_object_only', 'document_and_saved_object', 'orphan'])
  .register(z.globalRegistry, {
    description: 'Filter notes based on their association with a document or saved object.',
  });

export const security_timeline_api_column_header_result = z.object({
  aggregatable: z.optional(z.union([z.boolean(), z.null()])),
  category: z.optional(z.union([z.string(), z.null()])),
  columnHeaderType: z.optional(z.union([z.string(), z.null()])),
  description: z.optional(z.union([z.string(), z.null()])),
  example: z.optional(z.union([z.string(), z.null()])),
  id: z.optional(z.union([z.string(), z.null()])),
  indexes: z.optional(z.union([z.array(z.string()), z.null()])),
  name: z.optional(z.union([z.string(), z.null()])),
  placeholder: z.optional(z.union([z.string(), z.null()])),
  searchable: z.optional(z.union([z.boolean(), z.null()])),
  type: z.optional(z.union([z.string(), z.null()])),
});

/**
 * The type of data provider.
 */
export const security_timeline_api_data_provider_type = z
  .enum(['default', 'template'])
  .register(z.globalRegistry, {
    description: 'The type of data provider.',
  });

export const security_timeline_api_document_ids = z.union([z.array(z.string()), z.string()]);

/**
 * Indicates when and who marked a Timeline as a favorite.
 */
export const security_timeline_api_favorite_timeline_result = z
  .object({
    favoriteDate: z.optional(z.union([z.number(), z.null()])),
    fullName: z.optional(z.union([z.string(), z.null()])),
    userName: z.optional(z.union([z.string(), z.null()])),
  })
  .register(z.globalRegistry, {
    description: 'Indicates when and who marked a Timeline as a favorite.',
  });

export const security_timeline_api_filter_timeline_result = z.object({
  exists: z.optional(z.union([z.string(), z.null()])),
  match_all: z.optional(z.union([z.string(), z.null()])),
  meta: z.optional(
    z.union([
      z.object({
        alias: z.optional(z.union([z.string(), z.null()])),
        controlledBy: z.optional(z.union([z.string(), z.null()])),
        disabled: z.optional(z.union([z.boolean(), z.null()])),
        field: z.optional(z.union([z.string(), z.null()])),
        formattedValue: z.optional(z.union([z.string(), z.null()])),
        index: z.optional(z.union([z.string(), z.null()])),
        key: z.optional(z.union([z.string(), z.null()])),
        negate: z.optional(z.union([z.boolean(), z.null()])),
        params: z.optional(z.union([z.string(), z.null()])),
        type: z.optional(z.union([z.string(), z.null()])),
        value: z.optional(z.union([z.string(), z.null()])),
      }),
      z.null(),
    ])
  ),
  missing: z.optional(z.union([z.string(), z.null()])),
  query: z.optional(z.union([z.string(), z.null()])),
  range: z.optional(z.union([z.string(), z.null()])),
  script: z.optional(z.union([z.string(), z.null()])),
});

export const security_timeline_api_import_timeline_result = z.object({
  errors: z.optional(
    z
      .array(
        z.object({
          error: z.optional(
            z
              .object({
                message: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'The reason why the timeline could not be imported',
                  })
                ),
                status_code: z.optional(
                  z.number().register(z.globalRegistry, {
                    description: 'The HTTP status code of the error',
                  })
                ),
              })
              .register(z.globalRegistry, {
                description:
                  'The error containing the reason why the timeline could not be imported',
              })
          ),
          id: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The ID of the timeline that failed to import',
            })
          ),
        })
      )
      .register(z.globalRegistry, {
        description: 'The list of failed Timeline imports',
      })
  ),
  success: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether any of the Timelines were successfully imports',
    })
  ),
  success_count: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The amount of successfully imported/updated Timelines',
    })
  ),
  timelines_installed: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The amount of successfully installed Timelines',
    })
  ),
  timelines_updated: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The amount of successfully updated Timelines',
    })
  ),
});

export const security_timeline_api_note_created_and_updated_metadata = z.object({
  created: z.optional(z.union([z.number(), z.null()])),
  createdBy: z.optional(z.union([z.string(), z.null()])),
  updated: z.optional(z.union([z.number(), z.null()])),
  updatedBy: z.optional(z.union([z.string(), z.null()])),
});

export const security_timeline_api_bare_note =
  security_timeline_api_note_created_and_updated_metadata.and(
    z.object({
      eventId: z.optional(z.union([z.string(), z.null()])),
      note: z.optional(z.union([z.string(), z.null()])),
      timelineId: z.string().register(z.globalRegistry, {
        description: 'The `savedObjectId` of the Timeline that this note is associated with',
      }),
    })
  );

export const security_timeline_api_note = security_timeline_api_bare_note.and(
  z.object({
    noteId: z.string().register(z.globalRegistry, {
      description: 'The `savedObjectId` of the note',
    }),
    version: z.string().register(z.globalRegistry, {
      description: 'The version of the note',
    }),
  })
);

export const security_timeline_api_get_notes_result = z.object({
  notes: z.array(security_timeline_api_note),
  totalCount: z.number(),
});

export const security_timeline_api_pinned_event_created_and_updated_metadata = z.object({
  created: z.optional(z.union([z.number(), z.null()])),
  createdBy: z.optional(z.union([z.string(), z.null()])),
  updated: z.optional(z.union([z.number(), z.null()])),
  updatedBy: z.optional(z.union([z.string(), z.null()])),
});

export const security_timeline_api_bare_pinned_event =
  security_timeline_api_pinned_event_created_and_updated_metadata.and(
    z.object({
      eventId: z.string().register(z.globalRegistry, {
        description: 'The `_id` of the associated event for this pinned event.',
      }),
      timelineId: z.string().register(z.globalRegistry, {
        description:
          'The `savedObjectId` of the timeline that this pinned event is associated with',
      }),
    })
  );

export const security_timeline_api_pinned_event = security_timeline_api_bare_pinned_event.and(
  z.object({
    pinnedEventId: z.string().register(z.globalRegistry, {
      description: 'The `savedObjectId` of this pinned event',
    }),
    version: z.string().register(z.globalRegistry, {
      description: 'The version of this pinned event',
    }),
  })
);

export const security_timeline_api_persist_pinned_event_response = z.union([
  security_timeline_api_pinned_event,
  z.object({
    unpinned: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the event was successfully unpinned',
    }),
  }),
]);

export const security_timeline_api_query_match_result = z.object({
  displayField: z.optional(z.union([z.string(), z.null()])),
  displayValue: z.optional(z.union([z.string(), z.null()])),
  field: z.optional(z.union([z.string(), z.null()])),
  operator: z.optional(z.union([z.string(), z.null()])),
  value: z.optional(z.union([z.string(), z.null(), z.array(z.string())])),
});

export const security_timeline_api_data_provider_query_match = z.object({
  enabled: z.optional(z.union([z.boolean(), z.null()])),
  excluded: z.optional(z.union([z.boolean(), z.null()])),
  id: z.optional(z.union([z.string(), z.null()])),
  kqlQuery: z.optional(z.union([z.string(), z.null()])),
  name: z.optional(z.union([z.string(), z.null()])),
  queryMatch: z.optional(security_timeline_api_query_match_result),
  type: z.optional(security_timeline_api_data_provider_type),
});

export const security_timeline_api_data_provider_result = z.object({
  and: z.optional(z.union([z.array(security_timeline_api_data_provider_query_match), z.null()])),
  enabled: z.optional(z.union([z.boolean(), z.null()])),
  excluded: z.optional(z.union([z.boolean(), z.null()])),
  id: z.optional(z.union([z.string(), z.null()])),
  kqlQuery: z.optional(z.union([z.string(), z.null()])),
  name: z.optional(z.union([z.string(), z.null()])),
  queryMatch: z.optional(security_timeline_api_query_match_result),
  type: z.optional(security_timeline_api_data_provider_type),
});

export const security_timeline_api_response_note = z.object({
  note: security_timeline_api_note,
});

/**
 * Identifies the available row renderers
 */
export const security_timeline_api_row_renderer_id = z
  .enum([
    'alert',
    'alerts',
    'auditd',
    'auditd_file',
    'library',
    'netflow',
    'plain',
    'registry',
    'suricata',
    'system',
    'system_dns',
    'system_endgame_process',
    'system_file',
    'system_fim',
    'system_security_event',
    'system_socket',
    'threat_match',
    'zeek',
  ])
  .register(z.globalRegistry, {
    description: 'Identifies the available row renderers',
  });

export const security_timeline_api_saved_object_ids = z.union([z.array(z.string()), z.string()]);

export const security_timeline_api_saved_object_resolve_alias_purpose = z.enum([
  'savedObjectConversion',
  'savedObjectImport',
]);

export const security_timeline_api_saved_object_resolve_outcome = z.enum([
  'exactMatch',
  'aliasMatch',
  'conflict',
]);

/**
 * KQL bar query.
 */
export const security_timeline_api_serialized_filter_query_result = z
  .object({
    filterQuery: z.optional(
      z.union([
        z.object({
          kuery: z.optional(
            z.union([
              z.object({
                expression: z.optional(z.union([z.string(), z.null()])),
                kind: z.optional(z.union([z.string(), z.null()])),
              }),
              z.null(),
            ])
          ),
          serializedQuery: z.optional(z.union([z.string(), z.null()])),
        }),
        z.null(),
      ])
    ),
  })
  .register(z.globalRegistry, {
    description: 'KQL bar query.',
  });

/**
 * The field to sort the timelines by.
 */
export const security_timeline_api_sort_field_timeline = z
  .enum(['title', 'description', 'updated', 'created'])
  .register(z.globalRegistry, {
    description: 'The field to sort the timelines by.',
  });

/**
 * Object indicating how rows are sorted in the Timeline's grid
 */
export const security_timeline_api_sort_object = z
  .object({
    columnId: z.optional(z.union([z.string(), z.null()])),
    columnType: z.optional(z.union([z.string(), z.null()])),
    sortDirection: z.optional(z.union([z.string(), z.null()])),
  })
  .register(z.globalRegistry, {
    description: "Object indicating how rows are sorted in the Timeline's grid",
  });

export const security_timeline_api_sort = z.union([
  security_timeline_api_sort_object,
  z.array(security_timeline_api_sort_object),
]);

/**
 * The status of the Timeline.
 */
export const security_timeline_api_timeline_status = z
  .enum(['active', 'draft', 'immutable'])
  .register(z.globalRegistry, {
    description: 'The status of the Timeline.',
  });

/**
 * The type of Timeline.
 */
export const security_timeline_api_timeline_type = z
  .enum(['default', 'template'])
  .register(z.globalRegistry, {
    description: 'The type of Timeline.',
  });

export const security_timeline_api_favorite_timeline_response = z.object({
  favorite: z.optional(z.array(security_timeline_api_favorite_timeline_result)),
  savedObjectId: z.string(),
  templateTimelineId: z.optional(z.union([z.string(), z.null()])),
  templateTimelineVersion: z.optional(z.union([z.number(), z.null()])),
  timelineType: z.optional(security_timeline_api_timeline_type),
  version: z.string(),
});

export const security_timeline_api_saved_timeline = z.object({
  columns: z.optional(z.union([z.array(security_timeline_api_column_header_result), z.null()])),
  created: z.optional(z.union([z.number(), z.null()])),
  createdBy: z.optional(z.union([z.string(), z.null()])),
  dataProviders: z.optional(
    z.union([z.array(security_timeline_api_data_provider_result), z.null()])
  ),
  dataViewId: z.optional(z.union([z.string(), z.null()])),
  dateRange: z.optional(
    z.union([
      z.object({
        end: z.optional(z.union([z.string(), z.null(), z.number()])),
        start: z.optional(z.union([z.string(), z.null(), z.number()])),
      }),
      z.null(),
    ])
  ),
  description: z.optional(z.union([z.string(), z.null()])),
  eqlOptions: z.optional(
    z.union([
      z.object({
        eventCategoryField: z.optional(z.union([z.string(), z.null()])),
        query: z.optional(z.union([z.string(), z.null()])),
        size: z.optional(z.union([z.string(), z.null(), z.number()])),
        tiebreakerField: z.optional(z.union([z.string(), z.null()])),
        timestampField: z.optional(z.union([z.string(), z.null()])),
      }),
      z.null(),
    ])
  ),
  eventType: z.optional(z.union([z.string(), z.null()])),
  excludedRowRendererIds: z.optional(
    z.union([z.array(security_timeline_api_row_renderer_id), z.null()])
  ),
  favorite: z.optional(
    z.union([z.array(security_timeline_api_favorite_timeline_result), z.null()])
  ),
  filters: z.optional(z.union([z.array(security_timeline_api_filter_timeline_result), z.null()])),
  indexNames: z.optional(z.union([z.array(z.string()), z.null()])),
  kqlMode: z.optional(z.union([z.string(), z.null()])),
  kqlQuery: z.optional(security_timeline_api_serialized_filter_query_result),
  savedQueryId: z.optional(z.union([z.string(), z.null()])),
  savedSearchId: z.optional(z.union([z.string(), z.null()])),
  sort: z.optional(security_timeline_api_sort),
  status: z.optional(security_timeline_api_timeline_status),
  templateTimelineId: z.optional(z.union([z.string(), z.null()])),
  templateTimelineVersion: z.optional(z.union([z.number(), z.null()])),
  timelineType: z.optional(security_timeline_api_timeline_type),
  title: z.optional(z.union([z.string(), z.null()])),
  updated: z.optional(z.union([z.number(), z.null()])),
  updatedBy: z.optional(z.union([z.string(), z.null()])),
});

export const security_timeline_api_import_timelines = security_timeline_api_saved_timeline.and(
  z.object({
    eventNotes: z.union([z.array(security_timeline_api_bare_note), z.null()]),
    globalNotes: z.union([z.array(security_timeline_api_bare_note), z.null()]),
    pinnedEventIds: z.union([z.array(z.string()), z.null()]),
    savedObjectId: z.union([z.string(), z.null()]),
    version: z.union([z.string(), z.null()]),
  })
);

export const security_timeline_api_saved_timeline_with_saved_object_id =
  security_timeline_api_saved_timeline.and(
    z.object({
      savedObjectId: z.string().register(z.globalRegistry, {
        description: 'The `savedObjectId` of the Timeline or Timeline template',
      }),
      version: z.string().register(z.globalRegistry, {
        description: 'The version of the Timeline or Timeline template',
      }),
    })
  );

export const security_timeline_api_timeline_response = security_timeline_api_saved_timeline
  .and(security_timeline_api_saved_timeline_with_saved_object_id)
  .and(
    z.object({
      eventIdToNoteIds: z.optional(z.union([z.array(security_timeline_api_note), z.null()])),
      noteIds: z.optional(z.union([z.array(z.string()), z.null()])),
      notes: z.optional(z.union([z.array(security_timeline_api_note), z.null()])),
      pinnedEventIds: z.optional(z.union([z.array(z.string()), z.null()])),
      pinnedEventsSaveObject: z.optional(
        z.union([z.array(security_timeline_api_pinned_event), z.null()])
      ),
    })
  );

export const security_timeline_api_persist_timeline_response =
  security_timeline_api_timeline_response;

export const security_timeline_api_timeline_saved_to_return_object =
  security_timeline_api_saved_timeline.and(
    z.object({
      eventIdToNoteIds: z.optional(z.union([z.array(security_timeline_api_note), z.null()])),
      noteIds: z.optional(z.union([z.array(z.string()), z.null()])),
      notes: z.optional(z.union([z.array(security_timeline_api_note), z.null()])),
      pinnedEventIds: z.optional(z.union([z.array(z.string()), z.null()])),
      pinnedEventsSaveObject: z.optional(
        z.union([z.array(security_timeline_api_pinned_event), z.null()])
      ),
      savedObjectId: z.string(),
      version: z.string(),
    })
  );

export const security_timeline_api_resolved_timeline = z.object({
  alias_purpose: z.optional(security_timeline_api_saved_object_resolve_alias_purpose),
  alias_target_id: z.optional(z.string()),
  outcome: security_timeline_api_saved_object_resolve_outcome,
  timeline: security_timeline_api_timeline_saved_to_return_object,
});

export const short_url_ap_is_url_response = z.object({
  accessCount: z.optional(z.int()),
  accessDate: z.optional(z.string()),
  createDate: z.optional(z.string()),
  id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The identifier for the short URL.',
    })
  ),
  locator: z.optional(
    z.object({
      id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The identifier for the locator.',
        })
      ),
      state: z.optional(
        z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description: 'The locator parameters.',
        })
      ),
      version: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of Kibana when the short URL was created.',
        })
      ),
    })
  ),
  slug: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'A random human-readable slug is automatically generated if the `humanReadableSlug` parameter is set to `true`. If it is set to `false`, a random short string is generated.\n',
    })
  ),
});

/**
 * Bad request
 */
export const sl_os_400_response = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.number(),
});

/**
 * Unauthorized
 */
export const sl_os_401_response = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.number(),
});

/**
 * Unauthorized
 */
export const sl_os_403_response = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.number(),
});

/**
 * Not found
 */
export const sl_os_404_response = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.number(),
});

/**
 * Conflict
 */
export const sl_os_409_response = z.object({
  error: z.string(),
  message: z.string(),
  statusCode: z.number(),
});

/**
 * Artifacts
 *
 * Links to related assets for the SLO
 */
export const sl_os_artifacts = z
  .object({
    dashboards: z.optional(
      z
        .array(
          z.object({
            id: z.string().register(z.globalRegistry, {
              description: 'Dashboard saved-object id',
            }),
          })
        )
        .register(z.globalRegistry, {
          description: 'Array of dashboard references',
        })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Links to related assets for the SLO',
  });

/**
 * Budgeting method
 *
 * The budgeting method to use when computing the rollup data.
 */
export const sl_os_budgeting_method = z
  .enum(['occurrences', 'timeslices'])
  .register(z.globalRegistry, {
    description: 'The budgeting method to use when computing the rollup data.',
  });

/**
 * Bulk delete SLO request
 *
 * The bulk delete SLO request takes a list of SLOs Definition id to delete.
 *
 */
export const sl_os_bulk_delete_request = z
  .object({
    list: z
      .array(
        z.string().register(z.globalRegistry, {
          description: 'The SLO Definition id',
        })
      )
      .register(z.globalRegistry, {
        description: 'An array of SLO Definition id',
      }),
  })
  .register(z.globalRegistry, {
    description: 'The bulk delete SLO request takes a list of SLOs Definition id to delete.\n',
  });

/**
 * Bulk delete SLO response
 *
 * The bulk delete SLO response returns a taskId that can be used to poll for its status
 *
 */
export const sl_os_bulk_delete_response = z
  .object({
    taskId: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The taskId of the bulk delete operation',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'The bulk delete SLO response returns a taskId that can be used to poll for its status\n',
  });

/**
 * The status of the bulk deletion
 *
 * Indicates if the bulk deletion is completed, with the detailed results of the operation.
 */
export const sl_os_bulk_delete_status_response = z
  .object({
    error: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The error message if the bulk deletion operation failed',
      })
    ),
    isDone: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Indicates if the bulk deletion operation is completed',
      })
    ),
    results: z.optional(
      z
        .array(
          z.object({
            error: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The error message if the deletion operation failed for this SLO',
              })
            ),
            id: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The ID of the SLO that was deleted',
              })
            ),
            success: z.optional(
              z.boolean().register(z.globalRegistry, {
                description: 'The result of the deletion operation for this SLO',
              })
            ),
          })
        )
        .register(z.globalRegistry, {
          description:
            'The results of the bulk deletion operation, including the success status and any errors for each SLO',
        })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'Indicates if the bulk deletion is completed, with the detailed results of the operation.',
  });

/**
 * Bulk Purge Rollup data request
 *
 * The bulk purge rollup data request takes a list of SLO ids and a purge policy, then deletes the rollup data according to the purge policy. This API can be used to remove the staled data of an instance SLO that no longer get updated.
 *
 */
export const sl_os_bulk_purge_rollup_request = z
  .object({
    list: z
      .array(
        z.string().register(z.globalRegistry, {
          description: 'The SLO Definition id',
        })
      )
      .register(z.globalRegistry, {
        description: 'An array of slo ids',
      }),
    purgePolicy: z.union([
      z.object({
        age: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'The duration to determine which documents to purge, formatted as {duration}{unit}. This value should be greater than or equal to the time window of every SLO provided.',
          })
        ),
        purgeType: z.optional(
          z.enum(['fixed-age']).register(z.globalRegistry, {
            description:
              'Specifies whether documents will be purged based on a specific age or on a timestamp',
          })
        ),
      }),
      z.object({
        purgeType: z.optional(
          z.enum(['fixed-time']).register(z.globalRegistry, {
            description:
              'Specifies whether documents will be purged based on a specific age or on a timestamp',
          })
        ),
        timestamp: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'The timestamp to determine which documents to purge, formatted in ISO. This value should be older than the applicable time window of every SLO provided.',
          })
        ),
      }),
    ]),
  })
  .register(z.globalRegistry, {
    description:
      'The bulk purge rollup data request takes a list of SLO ids and a purge policy, then deletes the rollup data according to the purge policy. This API can be used to remove the staled data of an instance SLO that no longer get updated.\n',
  });

/**
 * Bulk Purge Rollup data response
 *
 * The bulk purge rollup data response returns a task id from the elasticsearch deleteByQuery response.
 *
 */
export const sl_os_bulk_purge_rollup_response = z
  .object({
    taskId: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The task id of the purge operation',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'The bulk purge rollup data response returns a task id from the elasticsearch deleteByQuery response.\n',
  });

/**
 * Create SLO response
 */
export const sl_os_create_slo_response = z.object({
  id: z.string(),
});

/**
 * Delete SLO instances request
 *
 * The delete SLO instances request takes a list of SLO id and instance id, then delete the rollup and summary data. This API can be used to remove the staled data of an instance SLO that no longer get updated.
 *
 */
export const sl_os_delete_slo_instances_request = z
  .object({
    list: z
      .array(
        z.object({
          instanceId: z.string().register(z.globalRegistry, {
            description: 'The SLO instance identifier',
          }),
          sloId: z.string().register(z.globalRegistry, {
            description: 'The SLO unique identifier',
          }),
        })
      )
      .register(z.globalRegistry, {
        description: 'An array of slo id and instance id',
      }),
  })
  .register(z.globalRegistry, {
    description:
      'The delete SLO instances request takes a list of SLO id and instance id, then delete the rollup and summary data. This API can be used to remove the staled data of an instance SLO that no longer get updated.\n',
  });

/**
 * Error budget
 */
export const sl_os_error_budget = z.object({
  consumed: z.number().register(z.globalRegistry, {
    description: 'The error budget consummed, as a percentage of the initial value.',
  }),
  initial: z.number().register(z.globalRegistry, {
    description: 'The initial error budget, as 1 - objective',
  }),
  isEstimated: z.boolean().register(z.globalRegistry, {
    description:
      'Only for SLO defined with occurrences budgeting method and calendar aligned time window.',
  }),
  remaining: z.number().register(z.globalRegistry, {
    description: 'The error budget remaining, as a percentage of the initial value.',
  }),
});

/**
 * FilterMeta
 *
 * Defines properties for a filter
 */
export const sl_os_filter_meta = z
  .object({
    alias: z.optional(z.union([z.string(), z.null()])),
    controlledBy: z.optional(z.string()),
    disabled: z.optional(z.boolean()),
    field: z.optional(z.string()),
    group: z.optional(z.string()),
    index: z.optional(z.string()),
    isMultiIndex: z.optional(z.boolean()),
    key: z.optional(z.string()),
    negate: z.optional(z.boolean()),
    params: z.optional(z.record(z.string(), z.unknown())),
    type: z.optional(z.string()),
    value: z.optional(z.string()),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for a filter',
  });

/**
 * Filter
 *
 * Defines properties for a filter
 */
export const sl_os_filter = z
  .object({
    meta: z.optional(sl_os_filter_meta),
    query: z.optional(z.record(z.string(), z.unknown())),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for a filter',
  });

/**
 * Group by
 *
 * optional group by field or fields to use to generate an SLO per distinct value
 */
export const sl_os_group_by = z.union([z.string(), z.array(z.string())]);

/**
 * APM availability
 *
 * Defines properties for the APM availability indicator type
 */
export const sl_os_indicator_properties_apm_availability = z
  .object({
    params: z
      .object({
        environment: z.string().register(z.globalRegistry, {
          description: 'The APM service environment or "*"',
        }),
        filter: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'KQL query used for filtering the data',
          })
        ),
        index: z.string().register(z.globalRegistry, {
          description: 'The index used by APM metrics',
        }),
        service: z.string().register(z.globalRegistry, {
          description: 'The APM service name',
        }),
        transactionName: z.string().register(z.globalRegistry, {
          description: 'The APM transaction name or "*"',
        }),
        transactionType: z.string().register(z.globalRegistry, {
          description: 'The APM transaction type or "*"',
        }),
      })
      .register(z.globalRegistry, {
        description: 'An object containing the indicator parameters.',
      }),
    type: z.string().register(z.globalRegistry, {
      description: 'The type of indicator.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for the APM availability indicator type',
  });

/**
 * APM latency
 *
 * Defines properties for the APM latency indicator type
 */
export const sl_os_indicator_properties_apm_latency = z
  .object({
    params: z
      .object({
        environment: z.string().register(z.globalRegistry, {
          description: 'The APM service environment or "*"',
        }),
        filter: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'KQL query used for filtering the data',
          })
        ),
        index: z.string().register(z.globalRegistry, {
          description: 'The index used by APM metrics',
        }),
        service: z.string().register(z.globalRegistry, {
          description: 'The APM service name',
        }),
        threshold: z.number().register(z.globalRegistry, {
          description: 'The latency threshold in milliseconds',
        }),
        transactionName: z.string().register(z.globalRegistry, {
          description: 'The APM transaction name or "*"',
        }),
        transactionType: z.string().register(z.globalRegistry, {
          description: 'The APM transaction type or "*"',
        }),
      })
      .register(z.globalRegistry, {
        description: 'An object containing the indicator parameters.',
      }),
    type: z.string().register(z.globalRegistry, {
      description: 'The type of indicator.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for the APM latency indicator type',
  });

/**
 * Custom metric
 *
 * Defines properties for a custom metric indicator type
 */
export const sl_os_indicator_properties_custom_metric = z
  .object({
    params: z
      .object({
        dataViewId: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.',
          })
        ),
        filter: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'the KQL query to filter the documents with.',
          })
        ),
        good: z
          .object({
            equation: z.string().register(z.globalRegistry, {
              description: 'The equation to calculate the "good" metric.',
            }),
            metrics: z
              .array(
                z.union([
                  z.object({
                    aggregation: z.enum(['sum']).register(z.globalRegistry, {
                      description: 'The aggregation type of the metric.',
                    }),
                    field: z.string().register(z.globalRegistry, {
                      description: 'The field of the metric.',
                    }),
                    filter: z.optional(
                      z.string().register(z.globalRegistry, {
                        description: 'The filter to apply to the metric.',
                      })
                    ),
                    name: z
                      .string()
                      .regex(/^[A-Z]$/)
                      .register(z.globalRegistry, {
                        description: 'The name of the metric. Only valid options are A-Z',
                      }),
                  }),
                  z.object({
                    aggregation: z.enum(['doc_count']).register(z.globalRegistry, {
                      description: 'The aggregation type of the metric.',
                    }),
                    filter: z.optional(
                      z.string().register(z.globalRegistry, {
                        description: 'The filter to apply to the metric.',
                      })
                    ),
                    name: z
                      .string()
                      .regex(/^[A-Z]$/)
                      .register(z.globalRegistry, {
                        description: 'The name of the metric. Only valid options are A-Z',
                      }),
                  }),
                ])
              )
              .register(z.globalRegistry, {
                description: 'List of metrics with their name, aggregation type, and field.',
              }),
          })
          .register(z.globalRegistry, {
            description: 'An object defining the "good" metrics and equation\n',
          }),
        index: z.string().register(z.globalRegistry, {
          description: 'The index or index pattern to use',
        }),
        timestampField: z.string().register(z.globalRegistry, {
          description: 'The timestamp field used in the source indice.\n',
        }),
        total: z
          .object({
            equation: z.string().register(z.globalRegistry, {
              description: 'The equation to calculate the "total" metric.',
            }),
            metrics: z
              .array(
                z.union([
                  z.object({
                    aggregation: z.enum(['sum']).register(z.globalRegistry, {
                      description: 'The aggregation type of the metric.',
                    }),
                    field: z.string().register(z.globalRegistry, {
                      description: 'The field of the metric.',
                    }),
                    filter: z.optional(
                      z.string().register(z.globalRegistry, {
                        description: 'The filter to apply to the metric.',
                      })
                    ),
                    name: z
                      .string()
                      .regex(/^[A-Z]$/)
                      .register(z.globalRegistry, {
                        description: 'The name of the metric. Only valid options are A-Z',
                      }),
                  }),
                  z.object({
                    aggregation: z.enum(['doc_count']).register(z.globalRegistry, {
                      description: 'The aggregation type of the metric.',
                    }),
                    filter: z.optional(
                      z.string().register(z.globalRegistry, {
                        description: 'The filter to apply to the metric.',
                      })
                    ),
                    name: z
                      .string()
                      .regex(/^[A-Z]$/)
                      .register(z.globalRegistry, {
                        description: 'The name of the metric. Only valid options are A-Z',
                      }),
                  }),
                ])
              )
              .register(z.globalRegistry, {
                description: 'List of metrics with their name, aggregation type, and field.',
              }),
          })
          .register(z.globalRegistry, {
            description: 'An object defining the "total" metrics and equation\n',
          }),
      })
      .register(z.globalRegistry, {
        description: 'An object containing the indicator parameters.',
      }),
    type: z.string().register(z.globalRegistry, {
      description: 'The type of indicator.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for a custom metric indicator type',
  });

/**
 * Histogram indicator
 *
 * Defines properties for a histogram indicator type
 */
export const sl_os_indicator_properties_histogram = z
  .object({
    params: z
      .object({
        dataViewId: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.',
          })
        ),
        filter: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'the KQL query to filter the documents with.',
          })
        ),
        good: z
          .object({
            aggregation: z.enum(['value_count', 'range']).register(z.globalRegistry, {
              description: 'The type of aggregation to use.',
            }),
            field: z.string().register(z.globalRegistry, {
              description: 'The field use to aggregate the good events.',
            }),
            filter: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The filter for good events.',
              })
            ),
            from: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'The starting value of the range. Only required for "range" aggregations.',
              })
            ),
            to: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'The ending value of the range. Only required for "range" aggregations.',
              })
            ),
          })
          .register(z.globalRegistry, {
            description: 'An object defining the "good" events\n',
          }),
        index: z.string().register(z.globalRegistry, {
          description: 'The index or index pattern to use',
        }),
        timestampField: z.string().register(z.globalRegistry, {
          description: 'The timestamp field used in the source indice.\n',
        }),
        total: z
          .object({
            aggregation: z.enum(['value_count', 'range']).register(z.globalRegistry, {
              description: 'The type of aggregation to use.',
            }),
            field: z.string().register(z.globalRegistry, {
              description: 'The field use to aggregate the good events.',
            }),
            filter: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The filter for total events.',
              })
            ),
            from: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'The starting value of the range. Only required for "range" aggregations.',
              })
            ),
            to: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'The ending value of the range. Only required for "range" aggregations.',
              })
            ),
          })
          .register(z.globalRegistry, {
            description: 'An object defining the "total" events\n',
          }),
      })
      .register(z.globalRegistry, {
        description: 'An object containing the indicator parameters.',
      }),
    type: z.string().register(z.globalRegistry, {
      description: 'The type of indicator.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for a histogram indicator type',
  });

/**
 * KQL with filters
 *
 * Defines properties for a filter
 */
export const sl_os_kql_with_filters = z.union([
  z.string().register(z.globalRegistry, {
    description: 'the KQL query to filter the documents with.',
  }),
  z.object({
    filters: z.optional(z.array(sl_os_filter)),
    kqlQuery: z.optional(z.string()),
  }),
]);

/**
 * KQL query for good events
 *
 * The KQL query used to define the good events.
 */
export const sl_os_kql_with_filters_good = z.union([
  z.string().register(z.globalRegistry, {
    description: 'the KQL query to filter the documents with.',
  }),
  z.object({
    filters: z.optional(z.array(sl_os_filter)),
    kqlQuery: z.optional(z.string()),
  }),
]);

/**
 * KQL query for all events
 *
 * The KQL query used to define all events.
 */
export const sl_os_kql_with_filters_total = z.union([
  z.string().register(z.globalRegistry, {
    description: 'the KQL query to filter the documents with.',
  }),
  z.object({
    filters: z.optional(z.array(sl_os_filter)),
    kqlQuery: z.optional(z.string()),
  }),
]);

/**
 * Custom Query
 *
 * Defines properties for a custom query indicator type
 */
export const sl_os_indicator_properties_custom_kql = z
  .object({
    params: z
      .object({
        dataViewId: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.',
          })
        ),
        filter: z.optional(sl_os_kql_with_filters),
        good: sl_os_kql_with_filters_good,
        index: z.string().register(z.globalRegistry, {
          description: 'The index or index pattern to use',
        }),
        timestampField: z.string().register(z.globalRegistry, {
          description: 'The timestamp field used in the source indice.\n',
        }),
        total: sl_os_kql_with_filters_total,
      })
      .register(z.globalRegistry, {
        description: 'An object containing the indicator parameters.',
      }),
    type: z.string().register(z.globalRegistry, {
      description: 'The type of indicator.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for a custom query indicator type',
  });

/**
 * Objective
 *
 * Defines properties for the SLO objective
 */
export const sl_os_objective = z
  .object({
    target: z.number().gt(0).lt(100).register(z.globalRegistry, {
      description: 'the target objective between 0 and 1 excluded',
    }),
    timesliceTarget: z.optional(
      z.number().gte(0).lte(100).register(z.globalRegistry, {
        description: 'the target objective for each slice when using a timeslices budgeting method',
      })
    ),
    timesliceWindow: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'the duration of each slice when using a timeslices budgeting method, as {duraton}{unit}',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for the SLO objective',
  });

/**
 * Settings
 *
 * Defines properties for SLO settings.
 */
export const sl_os_settings = z
  .object({
    frequency: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'The interval between checks for changes in the source data. The minimum value is 1m and the maximum is 59m. The default value is 1 minute.',
        })
      )
      .default('1m'),
    preventInitialBackfill: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Start aggregating data from the time the SLO is created, instead of backfilling data from the beginning of the time window.',
        })
      )
      .default(false),
    syncDelay: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'The time delay in minutes between the current time and the latest source data time. Increasing the value will delay any alerting. The default value is 1 minute. The minimum value is 1m and the maximum is 359m. It should always be greater then source index refresh interval.',
        })
      )
      .default('1m'),
    syncField: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The date field that is used to identify new documents in the source. It is strongly recommended to use a field that contains the ingest timestamp. If you use a different field, you might need to set the delay such that it accounts for data transmission delays. When unspecified, we use the indicator timestamp field.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for SLO settings.',
  });

/**
 * summary status
 */
export const sl_os_summary_status = z.enum(['NO_DATA', 'HEALTHY', 'DEGRADING', 'VIOLATED']);

/**
 * Summary
 *
 * The SLO computed data
 */
export const sl_os_summary = z
  .object({
    errorBudget: sl_os_error_budget,
    sliValue: z.number(),
    status: sl_os_summary_status,
  })
  .register(z.globalRegistry, {
    description: 'The SLO computed data',
  });

/**
 * Time window
 *
 * Defines properties for the SLO time window
 */
export const sl_os_time_window = z
  .object({
    duration: z.string().register(z.globalRegistry, {
      description:
        'the duration formatted as {duration}{unit}. Accepted values for rolling: 7d, 30d, 90d. Accepted values for calendar aligned: 1w (weekly) or 1M (monthly)',
    }),
    type: z.enum(['rolling', 'calendarAligned']).register(z.globalRegistry, {
      description:
        'Indicates weither the time window is a rolling or a calendar aligned time window.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for the SLO time window',
  });

/**
 * Timeslice Metric Basic Metric with Field
 */
export const sl_os_timeslice_metric_basic_metric_with_field = z.object({
  aggregation: z
    .enum(['sum', 'avg', 'min', 'max', 'std_deviation', 'last_value', 'cardinality'])
    .register(z.globalRegistry, {
      description: 'The aggregation type of the metric.',
    }),
  field: z.string().register(z.globalRegistry, {
    description: 'The field of the metric.',
  }),
  filter: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The filter to apply to the metric.',
    })
  ),
  name: z
    .string()
    .regex(/^[A-Z]$/)
    .register(z.globalRegistry, {
      description: 'The name of the metric. Only valid options are A-Z',
    }),
});

/**
 * Timeslice Metric Doc Count Metric
 */
export const sl_os_timeslice_metric_doc_count_metric = z.object({
  aggregation: z.enum(['doc_count']).register(z.globalRegistry, {
    description: 'The aggregation type of the metric. Only valid option is "doc_count"',
  }),
  filter: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The filter to apply to the metric.',
    })
  ),
  name: z
    .string()
    .regex(/^[A-Z]$/)
    .register(z.globalRegistry, {
      description: 'The name of the metric. Only valid options are A-Z',
    }),
});

/**
 * Timeslice Metric Percentile Metric
 */
export const sl_os_timeslice_metric_percentile_metric = z.object({
  aggregation: z.enum(['percentile']).register(z.globalRegistry, {
    description: 'The aggregation type of the metric. Only valid option is "percentile"',
  }),
  field: z.string().register(z.globalRegistry, {
    description: 'The field of the metric.',
  }),
  filter: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The filter to apply to the metric.',
    })
  ),
  name: z
    .string()
    .regex(/^[A-Z]$/)
    .register(z.globalRegistry, {
      description: 'The name of the metric. Only valid options are A-Z',
    }),
  percentile: z.number().register(z.globalRegistry, {
    description: 'The percentile value.',
  }),
});

/**
 * Timeslice metric
 *
 * Defines properties for a timeslice metric indicator type
 */
export const sl_os_indicator_properties_timeslice_metric = z
  .object({
    params: z
      .object({
        dataViewId: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.',
          })
        ),
        filter: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'the KQL query to filter the documents with.',
          })
        ),
        index: z.string().register(z.globalRegistry, {
          description: 'The index or index pattern to use',
        }),
        metric: z
          .object({
            comparator: z.enum(['GT', 'GTE', 'LT', 'LTE']).register(z.globalRegistry, {
              description: 'The comparator to use to compare the equation to the threshold.',
            }),
            equation: z.string().register(z.globalRegistry, {
              description: 'The equation to calculate the metric.',
            }),
            metrics: z
              .array(
                z.union([
                  z
                    .object({
                      aggregation: z.optional(
                        z.union([
                          z.literal('avg'),
                          z.literal('cardinality'),
                          z.literal('last_value'),
                          z.literal('max'),
                          z.literal('min'),
                          z.literal('std_deviation'),
                          z.literal('sum'),
                        ])
                      ),
                    })
                    .and(sl_os_timeslice_metric_basic_metric_with_field),
                  z
                    .object({
                      aggregation: z.optional(z.literal('percentile')),
                    })
                    .and(sl_os_timeslice_metric_percentile_metric),
                  z
                    .object({
                      aggregation: z.optional(z.literal('doc_count')),
                    })
                    .and(sl_os_timeslice_metric_doc_count_metric),
                ])
              )
              .register(z.globalRegistry, {
                description: 'List of metrics with their name, aggregation type, and field.',
              }),
            threshold: z.number().register(z.globalRegistry, {
              description: 'The threshold used to determine if the metric is a good slice or not.',
            }),
          })
          .register(z.globalRegistry, {
            description:
              "An object defining the metrics, equation, and threshold to determine if it's a good slice or not\n",
          }),
        timestampField: z.string().register(z.globalRegistry, {
          description: 'The timestamp field used in the source indice.\n',
        }),
      })
      .register(z.globalRegistry, {
        description: 'An object containing the indicator parameters.',
      }),
    type: z.string().register(z.globalRegistry, {
      description: 'The type of indicator.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for a timeslice metric indicator type',
  });

/**
 * Create SLO request
 *
 * The create SLO API request body varies depending on the type of indicator, time window and budgeting method.
 *
 */
export const sl_os_create_slo_request = z
  .object({
    artifacts: z.optional(sl_os_artifacts),
    budgetingMethod: sl_os_budgeting_method,
    description: z.string().register(z.globalRegistry, {
      description: 'A description for the SLO.',
    }),
    groupBy: z.optional(sl_os_group_by),
    id: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'A optional and unique identifier for the SLO. Must be between 8 and 36 chars',
      })
    ),
    indicator: z.union([
      sl_os_indicator_properties_custom_kql,
      sl_os_indicator_properties_apm_availability,
      sl_os_indicator_properties_apm_latency,
      sl_os_indicator_properties_custom_metric,
      sl_os_indicator_properties_histogram,
      sl_os_indicator_properties_timeslice_metric,
    ]),
    name: z.string().register(z.globalRegistry, {
      description: 'A name for the SLO.',
    }),
    objective: sl_os_objective,
    settings: z.optional(sl_os_settings),
    tags: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description: 'List of tags',
      })
    ),
    timeWindow: sl_os_time_window,
  })
  .register(z.globalRegistry, {
    description:
      'The create SLO API request body varies depending on the type of indicator, time window and budgeting method.\n',
  });

/**
 * SLO definition response
 */
export const sl_os_slo_definition_response = z.object({
  artifacts: z.optional(sl_os_artifacts),
  budgetingMethod: sl_os_budgeting_method,
  createdAt: z.string().register(z.globalRegistry, {
    description: 'The creation date',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the SLO.',
  }),
  enabled: z.boolean().register(z.globalRegistry, {
    description: 'Indicate if the SLO is enabled',
  }),
  groupBy: sl_os_group_by,
  id: z.string().register(z.globalRegistry, {
    description: 'The identifier of the SLO.',
  }),
  indicator: z.union([
    z
      .object({
        type: z.literal('sli.kql.custom'),
      })
      .and(sl_os_indicator_properties_custom_kql),
    z
      .object({
        type: z.literal('sli.apm.transactionErrorRate'),
      })
      .and(sl_os_indicator_properties_apm_availability),
    z
      .object({
        type: z.literal('sli.apm.transactionDuration'),
      })
      .and(sl_os_indicator_properties_apm_latency),
    z
      .object({
        type: z.literal('sli.metric.custom'),
      })
      .and(sl_os_indicator_properties_custom_metric),
    z
      .object({
        type: z.literal('sli.histogram.custom'),
      })
      .and(sl_os_indicator_properties_histogram),
    z
      .object({
        type: z.literal('sli.metric.timeslice'),
      })
      .and(sl_os_indicator_properties_timeslice_metric),
  ]),
  name: z.string().register(z.globalRegistry, {
    description: 'The name of the SLO.',
  }),
  objective: sl_os_objective,
  revision: z.number().register(z.globalRegistry, {
    description: 'The SLO revision',
  }),
  settings: sl_os_settings,
  tags: z.array(z.string()).register(z.globalRegistry, {
    description: 'List of tags',
  }),
  timeWindow: sl_os_time_window,
  updatedAt: z.string().register(z.globalRegistry, {
    description: 'The last update date',
  }),
  version: z.number().register(z.globalRegistry, {
    description: 'The internal SLO version',
  }),
});

/**
 * SLO response
 */
export const sl_os_slo_with_summary_response = z.object({
  budgetingMethod: sl_os_budgeting_method,
  createdAt: z.string().register(z.globalRegistry, {
    description: 'The creation date',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the SLO.',
  }),
  enabled: z.boolean().register(z.globalRegistry, {
    description: 'Indicate if the SLO is enabled',
  }),
  groupBy: sl_os_group_by,
  id: z.string().register(z.globalRegistry, {
    description: 'The identifier of the SLO.',
  }),
  indicator: z.union([
    z
      .object({
        type: z.literal('sli.kql.custom'),
      })
      .and(sl_os_indicator_properties_custom_kql),
    z
      .object({
        type: z.literal('sli.apm.transactionErrorRate'),
      })
      .and(sl_os_indicator_properties_apm_availability),
    z
      .object({
        type: z.literal('sli.apm.transactionDuration'),
      })
      .and(sl_os_indicator_properties_apm_latency),
    z
      .object({
        type: z.literal('sli.metric.custom'),
      })
      .and(sl_os_indicator_properties_custom_metric),
    z
      .object({
        type: z.literal('sli.histogram.custom'),
      })
      .and(sl_os_indicator_properties_histogram),
    z
      .object({
        type: z.literal('sli.metric.timeslice'),
      })
      .and(sl_os_indicator_properties_timeslice_metric),
  ]),
  instanceId: z.string().register(z.globalRegistry, {
    description: "the value derived from the groupBy field, if present, otherwise '*'",
  }),
  name: z.string().register(z.globalRegistry, {
    description: 'The name of the SLO.',
  }),
  objective: sl_os_objective,
  revision: z.number().register(z.globalRegistry, {
    description: 'The SLO revision',
  }),
  settings: sl_os_settings,
  summary: sl_os_summary,
  tags: z.array(z.string()).register(z.globalRegistry, {
    description: 'List of tags',
  }),
  timeWindow: sl_os_time_window,
  updatedAt: z.string().register(z.globalRegistry, {
    description: 'The last update date',
  }),
  version: z.number().register(z.globalRegistry, {
    description: 'The internal SLO version',
  }),
});

/**
 * Find SLO definitions response
 *
 * A paginated response of SLO definitions matching the query.
 *
 */
export const sl_os_find_slo_definitions_response = z.union([
  z.object({
    page: z.optional(z.number()),
    perPage: z.optional(z.number()),
    results: z.optional(z.array(sl_os_slo_with_summary_response)),
    total: z.optional(z.number()),
  }),
  z.object({
    page: z
      .optional(
        z.number().register(z.globalRegistry, {
          description: 'for backward compability',
        })
      )
      .default(1),
    perPage: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'for backward compability',
      })
    ),
    results: z.optional(z.array(sl_os_slo_with_summary_response)),
    searchAfter: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description: 'the cursor to provide to get the next paged results',
      })
    ),
    size: z.optional(z.number()),
    total: z.optional(z.number()),
  }),
]);

/**
 * Find SLO response
 *
 * A paginated response of SLOs matching the query.
 *
 */
export const sl_os_find_slo_response = z
  .object({
    page: z.optional(z.number()),
    perPage: z.optional(z.number()),
    results: z.optional(z.array(sl_os_slo_with_summary_response)),
    searchAfter: z.optional(z.string()),
    size: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'Size provided for cursor based pagination',
      })
    ),
    total: z.optional(z.number()),
  })
  .register(z.globalRegistry, {
    description: 'A paginated response of SLOs matching the query.\n',
  });

/**
 * Update SLO request
 *
 * The update SLO API request body varies depending on the type of indicator, time window and budgeting method. Partial update is handled.
 *
 */
export const sl_os_update_slo_request = z
  .object({
    artifacts: z.optional(sl_os_artifacts),
    budgetingMethod: z.optional(sl_os_budgeting_method),
    description: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'A description for the SLO.',
      })
    ),
    groupBy: z.optional(sl_os_group_by),
    indicator: z.optional(
      z.union([
        sl_os_indicator_properties_custom_kql,
        sl_os_indicator_properties_apm_availability,
        sl_os_indicator_properties_apm_latency,
        sl_os_indicator_properties_custom_metric,
        sl_os_indicator_properties_histogram,
        sl_os_indicator_properties_timeslice_metric,
      ])
    ),
    name: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'A name for the SLO.',
      })
    ),
    objective: z.optional(sl_os_objective),
    settings: z.optional(sl_os_settings),
    tags: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description: 'List of tags',
      })
    ),
    timeWindow: z.optional(sl_os_time_window),
  })
  .register(z.globalRegistry, {
    description:
      'The update SLO API request body varies depending on the type of indicator, time window and budgeting method. Partial update is handled.\n',
  });

/**
 * Common monitor fields
 */
export const synthetics_common_monitor_fields = z.object({
  alert: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'The alert configuration. The default is `{ status: { enabled: true }, tls: { enabled: true } }`.\n',
    })
  ),
  enabled: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Specify whether the monitor is enabled.',
      })
    )
    .default(true),
  labels: z.optional(
    z.record(z.string(), z.string()).register(z.globalRegistry, {
      description:
        'Key-value pairs of labels to associate with the monitor. Labels can be used for filtering and grouping monitors.\n',
    })
  ),
  locations: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "The location to deploy the monitor.\nMonitors can be deployed in multiple locations so that you can detect differences in availability and response times across those locations.\nTo list available locations you can:\n\n- Run the `elastic-synthetics locations` command with the deployment's Kibana URL.\n- Go to *Synthetics > Management* and click *Create monitor*. Locations will be listed in *Locations*.\n",
    })
  ),
  name: z.string().register(z.globalRegistry, {
    description: 'The monitor name.',
  }),
  namespace: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The namespace field should be lowercase and not contain spaces. The namespace must not include any of the following characters: `*`, `\\`, `/`, `?`, `"`, `<`, `>`, `|`, whitespace, `,`, `#`, `:`, or `-`.\n',
      })
    )
    .default('default'),
  params: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The monitor parameters.',
    })
  ),
  private_locations: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "The private locations to which the monitors will be deployed.\nThese private locations refer to locations hosted and managed by you, whereas `locations` are hosted by Elastic.\nYou can specify a private location using the location's name.\nTo list available private locations you can:\n\n- Run the `elastic-synthetics locations` command with the deployment's Kibana URL.\n- Go to *Synthetics > Settings* and click *Private locationsr*. Private locations will be listed in the table.\n\n> info\n> You can provide `locations` or `private_locations` or both. At least one is required.\n",
    })
  ),
  retest_on_failure: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Turn retesting for when a monitor fails on or off. By default, monitors are automatically retested if the monitor goes from "up" to "down". If the result of the retest is also "down", an error will be created and if configured, an alert sent. The monitor will then resume running according to the defined schedule. Using `retest_on_failure` can reduce noise related to transient problems.\n',
      })
    )
    .default(true),
  schedule: z.optional(
    z.number().register(z.globalRegistry, {
      description:
        "The monitor's schedule in minutes. Supported values are `1`, `3`, `5`, `10`, `15`, `30`, `60`, `120`, and `240`. The default value is `3` minutes for HTTP, TCP, and ICMP monitors. The default value is `10` minutes for Browser monitors.\n",
    })
  ),
  'service.name': z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The APM service name.',
    })
  ),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'An array of tags.',
    })
  ),
  timeout: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "The monitor timeout in seconds. The monitor will fail if it doesn't complete within this time.\n",
      })
    )
    .default(16),
});

/**
 * Browser monitor fields
 */
export const synthetics_browser_monitor_fields = synthetics_common_monitor_fields.and(
  z.object({
    ignore_https_errors: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Ignore HTTPS errors.',
        })
      )
      .default(false),
    inline_script: z.string().register(z.globalRegistry, {
      description: 'The inline script.',
    }),
    playwright_options: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Playwright options.',
      })
    ),
    screenshots: z.optional(
      z.enum(['on', 'off', 'only-on-failure']).register(z.globalRegistry, {
        description: 'The screenshot option.',
      })
    ),
    synthetics_args: z.optional(
      z.array(z.unknown()).register(z.globalRegistry, {
        description: 'Synthetics agent CLI arguments.',
      })
    ),
    type: z.enum(['browser']).register(z.globalRegistry, {
      description: 'The monitor type.',
    }),
  })
);

/**
 * Get parameter response
 */
export const synthetics_get_parameter_response = z.object({
  description: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The description of the parameter. It is included in the response if the user has read-only permissions to the Synthetics app.\n',
    })
  ),
  id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the parameter.',
    })
  ),
  key: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The key of the parameter.',
    })
  ),
  namespaces: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'The namespaces associated with the parameter. It is included in the response if the user has read-only permissions to the Synthetics app.\n',
    })
  ),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'An array of tags associated with the parameter. It is included in the response if the user has read-only permissions to the Synthetics app.\n',
    })
  ),
  value: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The value associated with the parameter. It will be included in the response if the user has write permissions.  \n',
    })
  ),
});

/**
 * Post a private location
 */
export const synthetics_get_private_location = z.object({
  agentPolicyId: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The ID of the agent policy associated with the private location.',
    })
  ),
  geo: z.optional(
    z
      .object({
        lat: z.number().register(z.globalRegistry, {
          description: 'The latitude of the location.',
        }),
        lon: z.number().register(z.globalRegistry, {
          description: 'The longitude of the location.',
        }),
      })
      .register(z.globalRegistry, {
        description: 'Geographic coordinates (WGS84) for the location.',
      })
  ),
  id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the private location.',
    })
  ),
  isInvalid: z.optional(
    z.boolean().register(z.globalRegistry, {
      description:
        'Indicates whether the location is invalid. If `true`, the location is invalid, which means the agent policy associated with the location is deleted.\n',
    })
  ),
  label: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A label for the private location.',
    })
  ),
  namespace: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The namespace of the location, which is the same as the namespace of the agent policy associated with the location.',
    })
  ),
});

/**
 * HTTP monitor fields
 */
export const synthetics_http_monitor_fields = synthetics_common_monitor_fields.and(
  z.object({
    check: z.optional(
      z
        .object({
          request: z.optional(
            z
              .object({
                body: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'Optional request body content.',
                  })
                ),
                headers: z.optional(
                  z.record(z.string(), z.unknown()).register(z.globalRegistry, {
                    description:
                      'A dictionary of additional HTTP headers to send. By default, Synthetics will set the User-Agent header to identify itself.\n',
                  })
                ),
                method: z.optional(
                  z.enum(['HEAD', 'GET', 'POST', 'OPTIONS']).register(z.globalRegistry, {
                    description: 'The HTTP method to use.',
                  })
                ),
              })
              .register(z.globalRegistry, {
                description: 'An optional request to send to the remote host.',
              })
          ),
          response: z.optional(
            z
              .object({
                body: z.optional(z.record(z.string(), z.unknown())),
                headers: z.optional(
                  z.record(z.string(), z.unknown()).register(z.globalRegistry, {
                    description:
                      'A dictionary of expected HTTP headers. If the header is not found, the check fails.',
                  })
                ),
              })
              .register(z.globalRegistry, {
                description: 'The expected response.',
              })
          ),
        })
        .register(z.globalRegistry, {
          description: 'The check request settings.',
        })
    ),
    ipv4: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If `true`, ping using the ipv4 protocol.',
        })
      )
      .default(true),
    ipv6: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If `true`, ping using the ipv6 protocol.',
        })
      )
      .default(true),
    max_redirects: z
      .optional(
        z.number().register(z.globalRegistry, {
          description: 'The maximum number of redirects to follow.',
        })
      )
      .default(0),
    mode: z.optional(
      z.enum(['all', 'any']).register(z.globalRegistry, {
        description:
          "The mode of the monitor. If it is `all`, the monitor pings all resolvable IPs for a hostname. If it is `any`, the monitor pings only one IP address for a hostname. If you're using a DNS-load balancer and want to ping every IP address for the specified hostname, you should use `all`.\n",
      })
    ),
    password: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The password for authenticating with the server. The credentials are passed with the request.\n',
      })
    ),
    proxy_headers: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Additional headers to send to proxies during CONNECT requests.',
      })
    ),
    proxy_url: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The URL of the proxy to use for this monitor.',
      })
    ),
    response: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description:
          'Controls the indexing of the HTTP response body contents to the `http.response.body.contents field`.',
      })
    ),
    ssl: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description:
          "The TLS/SSL connection settings for use with the HTTPS endpoint. If you don't specify settings, the system defaults are used.\n",
      })
    ),
    type: z.enum(['http']).register(z.globalRegistry, {
      description: 'The monitor type.',
    }),
    url: z.string().register(z.globalRegistry, {
      description: 'The URL to monitor.',
    }),
    username: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The username for authenticating with the server. The credentials are passed with the request.\n',
      })
    ),
  })
);

/**
 * ICMP monitor fields
 */
export const synthetics_icmp_monitor_fields = synthetics_common_monitor_fields.and(
  z.object({
    host: z.string().register(z.globalRegistry, {
      description: 'The host to ping.',
    }),
    type: z.enum(['icmp']).register(z.globalRegistry, {
      description: 'The monitor type.',
    }),
    wait: z
      .optional(
        z.number().register(z.globalRegistry, {
          description: 'The wait time in seconds.',
        })
      )
      .default(1),
  })
);

/**
 * Parameter request
 */
export const synthetics_parameter_request = z.object({
  description: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A description of the parameter.',
    })
  ),
  key: z.string().register(z.globalRegistry, {
    description: 'The key of the parameter.',
  }),
  share_across_spaces: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Specify whether the parameter should be shared across spaces.',
    })
  ),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'An array of tags to categorize the parameter.',
    })
  ),
  value: z.string().register(z.globalRegistry, {
    description: 'The value associated with the parameter.',
  }),
});

/**
 * Post parameter response
 */
export const synthetics_post_parameter_response = z.object({
  description: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A description of the parameter.',
    })
  ),
  id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The unique identifier for the parameter.',
    })
  ),
  key: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The parameter key.',
    })
  ),
  share_across_spaces: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the parameter is shared across spaces.',
    })
  ),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'An array of tags associated with the parameter.',
    })
  ),
  value: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The value associated with the parameter.',
    })
  ),
});

/**
 * TCP monitor fields
 */
export const synthetics_tcp_monitor_fields = synthetics_common_monitor_fields.and(
  z.object({
    host: z.string().register(z.globalRegistry, {
      description:
        'The host to monitor; it can be an IP address or a hostname. The host can include the port using a colon, for example "example.com:9200".\n',
    }),
    proxy_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The URL of the SOCKS5 proxy to use when connecting to the server. The value must be a URL with a scheme of `socks5://`. If the SOCKS5 proxy server requires client authentication, then a username and password can be embedded in the URL. When using a proxy, hostnames are resolved on the proxy server instead of on the client. You can change this behavior by setting the `proxy_use_local_resolver` option.\n',
      })
    ),
    proxy_use_local_resolver: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Specify that hostnames are resolved locally instead of being resolved on the proxy server. If `false`, name resolution occurs on the proxy server.\n',
        })
      )
      .default(false),
    ssl: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description:
          "The TLS/SSL connection settings for use with the HTTPS endpoint. If you don't specify settings, the system defaults are used.\n",
      })
    ),
    type: z.enum(['tcp']).register(z.globalRegistry, {
      description: 'The monitor type.',
    }),
  })
);

/**
 * This object summarizes the current configuration of Task Manager. This includes dynamic configurations that change over time, such as `poll_interval` and `max_workers`, which can adjust in reaction to changing load on the system.
 *
 */
export const task_manager_health_ap_is_configuration = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'This object summarizes the current configuration of Task Manager. This includes dynamic configurations that change over time, such as `poll_interval` and `max_workers`, which can adjust in reaction to changing load on the system.\n',
  });

/**
 * This object summarizes the work load across the cluster, including the tasks in the system, their types, and current status.
 *
 */
export const task_manager_health_ap_is_workload = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'This object summarizes the work load across the cluster, including the tasks in the system, their types, and current status.\n',
  });

/**
 * Task health response properties
 */
export const task_manager_health_ap_is_health_response = z.object({
  id: z.optional(z.string()),
  last_update: z.optional(z.string()),
  stats: z.optional(
    z.object({
      capacity_estimation: z.optional(
        z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description:
            'This object provides a rough estimate about the sufficiency of its capacity. These are estimates based on historical data and should not be used as predictions.\n',
        })
      ),
      configuration: z.optional(task_manager_health_ap_is_configuration),
      runtime: z.optional(
        z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description:
            'This object tracks runtime performance of Task Manager, tracking task drift, worker load, and stats broken down by type, including duration and run results.\n',
        })
      ),
      workload: z.optional(task_manager_health_ap_is_workload),
    })
  ),
  status: z.optional(z.string()),
  timestamp: z.optional(z.string()),
});

/**
 * Connector request properties for an Amazon Bedrock connector
 *
 * Defines properties for connectors when type is `.bedrock`.
 */
export const bedrock_config = z
  .object({
    apiUrl: z.string().register(z.globalRegistry, {
      description: 'The Amazon Bedrock request URL.',
    }),
    defaultModel: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'The generative artificial intelligence model for Amazon Bedrock to use. Current support is for the Anthropic Claude models.\n',
        })
      )
      .default('us.anthropic.claude-sonnet-4-5-20250929-v1:0'),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.bedrock`.',
  });

/**
 * Connector request config properties for a Crowdstrike connector
 *
 * Defines config properties for connectors when type is `.crowdstrike`.
 */
export const crowdstrike_config = z
  .object({
    url: z.string().register(z.globalRegistry, {
      description:
        'The CrowdStrike tenant URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines config properties for connectors when type is `.crowdstrike`.',
  });

/**
 * Connector request properties for a D3 Security connector
 *
 * Defines properties for connectors when type is `.d3security`.
 */
export const d3security_config = z
  .object({
    url: z.string().register(z.globalRegistry, {
      description:
        'The D3 Security API request URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.d3security`.',
  });

/**
 * Connector request properties for an email connector
 *
 * Defines properties for connectors when type is `.email`.
 */
export const email_config = z
  .object({
    clientId: z.optional(z.union([z.string(), z.null()])),
    from: z.string().register(z.globalRegistry, {
      description:
        'The from address for all emails sent by the connector. It must be specified in `user@host-name` format.\n',
    }),
    hasAuth: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Specifies whether a user and password are required inside the secrets configuration.\n',
        })
      )
      .default(true),
    host: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "The host name of the service provider. If the `service` is `elastic_cloud` (for Elastic Cloud notifications) or one of Nodemailer's well-known email service providers, this property is ignored. If `service` is `other`, this property must be defined.\n",
      })
    ),
    oauthTokenUrl: z.optional(z.union([z.string(), z.null()])),
    port: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "The port to connect to on the service provider. If the `service` is `elastic_cloud` (for Elastic Cloud notifications) or one of Nodemailer's well-known email service providers, this property is ignored. If `service` is `other`, this property must be defined.\n",
      })
    ),
    secure: z.optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Specifies whether the connection to the service provider will use TLS. If the `service` is `elastic_cloud` (for Elastic Cloud notifications) or one of Nodemailer's well-known email service providers, this property is ignored.\n",
      })
    ),
    service: z.optional(
      z
        .enum(['elastic_cloud', 'exchange_server', 'gmail', 'other', 'outlook365', 'ses'])
        .register(z.globalRegistry, {
          description: 'The name of the email service.\n',
        })
    ),
    tenantId: z.optional(z.union([z.string(), z.null()])),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.email`.',
  });

/**
 * Connector request properties for an Google Gemini connector
 *
 * Defines properties for connectors when type is `.gemini`.
 */
export const gemini_config = z
  .object({
    apiUrl: z.string().register(z.globalRegistry, {
      description: 'The Google Gemini request URL.',
    }),
    defaultModel: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The generative artificial intelligence model for Google Gemini to use.',
        })
      )
      .default('gemini-2.5-pro'),
    gcpRegion: z.string().register(z.globalRegistry, {
      description: 'The GCP region where the Vertex AI endpoint enabled.',
    }),
    gcpProjectID: z.string().register(z.globalRegistry, {
      description: 'The Google ProjectID that has Vertex AI endpoint enabled.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.gemini`.',
  });

/**
 * Connector request properties for a IBM Resilient connector
 *
 * Defines properties for connectors when type is `.resilient`.
 */
export const resilient_config = z
  .object({
    apiUrl: z.string().register(z.globalRegistry, {
      description: 'The IBM Resilient instance URL.',
    }),
    orgId: z.string().register(z.globalRegistry, {
      description: 'The IBM Resilient organization ID.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.resilient`.',
  });

/**
 * Connector request properties for an index connector
 *
 * Defines properties for connectors when type is `.index`.
 */
export const index_config = z
  .object({
    executionTimeField: z.optional(z.union([z.string(), z.null()])).default(null),
    index: z.string().register(z.globalRegistry, {
      description: 'The Elasticsearch index to be written to.',
    }),
    refresh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'The refresh policy for the write request, which affects when changes are made visible to search. Refer to the refresh setting for Elasticsearch document APIs.\n',
        })
      )
      .default(false),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.index`.',
  });

/**
 * Connector request properties for a Jira connector
 *
 * Defines properties for connectors when type is `.jira`.
 */
export const jira_config = z
  .object({
    apiUrl: z.string().register(z.globalRegistry, {
      description: 'The Jira instance URL.',
    }),
    projectKey: z.string().register(z.globalRegistry, {
      description: 'The Jira project key.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.jira`.',
  });

/**
 * Connector request properties for a Microsoft Defender for Endpoint connector
 *
 * Defines properties for connectors when type is `.microsoft_defender_endpoint`.
 */
export const defender_config = z
  .object({
    apiUrl: z.string().register(z.globalRegistry, {
      description:
        'The URL of the Microsoft Defender for Endpoint API. If you are using the `xpack.actions.allowedHosts` setting, make sure the hostname is added to the allowed hosts.\n',
    }),
    clientId: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The application (client) identifier for your app in the Azure portal.',
      })
    ),
    oAuthScope: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The OAuth scopes or permission sets for the Microsoft Defender for Endpoint API.',
      })
    ),
    oAuthServerUrl: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The OAuth server URL where authentication is sent and received for the Microsoft Defender for Endpoint API.',
      })
    ),
    tenantId: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The tenant identifier for your app in the Azure portal.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.microsoft_defender_endpoint`.',
  });

/**
 * Connector request properties for an OpenAI connector that uses Azure OpenAI
 *
 * Defines properties for connectors when type is `.gen-ai` and the API provider is `Azure OpenAI`.
 *
 */
export const genai_azure_config = z
  .object({
    apiProvider: z.enum(['Azure OpenAI']).register(z.globalRegistry, {
      description: 'The OpenAI API provider.',
    }),
    apiUrl: z.string().register(z.globalRegistry, {
      description: 'The OpenAI API endpoint.',
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Defines properties for connectors when type is `.gen-ai` and the API provider is `Azure OpenAI`.\n',
  });

/**
 * Connector request properties for an OpenAI connector
 *
 * Defines properties for connectors when type is `.gen-ai` and the API provider is `OpenAI`.
 *
 */
export const genai_openai_config = z
  .object({
    apiProvider: z.enum(['OpenAI']).register(z.globalRegistry, {
      description: 'The OpenAI API provider.',
    }),
    apiUrl: z.string().register(z.globalRegistry, {
      description: 'The OpenAI API endpoint.',
    }),
    defaultModel: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The default model to use for requests.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'Defines properties for connectors when type is `.gen-ai` and the API provider is `OpenAI`.\n',
  });

/**
 * Connector request properties for an Opsgenie connector
 *
 * Defines properties for connectors when type is `.opsgenie`.
 */
export const opsgenie_config = z
  .object({
    apiUrl: z.string().register(z.globalRegistry, {
      description:
        'The Opsgenie URL. For example, `https://api.opsgenie.com` or `https://api.eu.opsgenie.com`. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.opsgenie`.',
  });

/**
 * Connector request properties for a PagerDuty connector
 *
 * Defines properties for connectors when type is `.pagerduty`.
 */
export const pagerduty_config = z
  .object({
    apiUrl: z.optional(z.union([z.string(), z.null()])),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.pagerduty`.',
  });

/**
 * Connector request properties for a SentinelOne connector
 *
 * Defines properties for connectors when type is `.sentinelone`.
 */
export const sentinelone_config = z
  .object({
    url: z.string().register(z.globalRegistry, {
      description:
        'The SentinelOne tenant URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.sentinelone`.',
  });

/**
 * Connector request properties for a ServiceNow ITSM connector
 *
 * Defines properties for connectors when type is `.servicenow`.
 */
export const servicenow_config = z
  .object({
    apiUrl: z.string().register(z.globalRegistry, {
      description: 'The ServiceNow instance URL.',
    }),
    clientId: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The client ID assigned to your OAuth application. This property is required when `isOAuth` is `true`.\n',
      })
    ),
    isOAuth: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'The type of authentication to use. The default value is false, which means basic authentication is used instead of open authorization (OAuth).\n',
        })
      )
      .default(false),
    jwtKeyId: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The key identifier assigned to the JWT verifier map of your OAuth application. This property is required when `isOAuth` is `true`.\n',
      })
    ),
    userIdentifierValue: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "The identifier to use for OAuth authentication. This identifier should be the user field you selected when you created an OAuth JWT API endpoint for external clients in your ServiceNow instance. For example, if the selected user field is `Email`, the user identifier should be the user's email address. This property is required when `isOAuth` is `true`.\n",
      })
    ),
    usesTableApi: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Determines whether the connector uses the Table API or the Import Set API. This property is supported only for ServiceNow ITSM and ServiceNow SecOps connectors.  NOTE: If this property is set to `false`, the Elastic application should be installed in ServiceNow.\n',
        })
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.servicenow`.',
  });

/**
 * Connector request properties for a ServiceNow ITOM connector
 *
 * Defines properties for connectors when type is `.servicenow-itom`.
 */
export const servicenow_itom_config = z
  .object({
    apiUrl: z.string().register(z.globalRegistry, {
      description: 'The ServiceNow instance URL.',
    }),
    clientId: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The client ID assigned to your OAuth application. This property is required when `isOAuth` is `true`.\n',
      })
    ),
    isOAuth: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'The type of authentication to use. The default value is false, which means basic authentication is used instead of open authorization (OAuth).\n',
        })
      )
      .default(false),
    jwtKeyId: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The key identifier assigned to the JWT verifier map of your OAuth application. This property is required when `isOAuth` is `true`.\n',
      })
    ),
    userIdentifierValue: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "The identifier to use for OAuth authentication. This identifier should be the user field you selected when you created an OAuth JWT API endpoint for external clients in your ServiceNow instance. For example, if the selected user field is `Email`, the user identifier should be the user's email address. This property is required when `isOAuth` is `true`.\n",
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.servicenow-itom`.',
  });

/**
 * Connector request properties for a Slack connector
 *
 * Defines properties for connectors when type is `.slack_api`.
 */
export const slack_api_config = z
  .object({
    allowedChannels: z.optional(
      z
        .array(
          z.object({
            id: z.string().min(1).register(z.globalRegistry, {
              description: 'The Slack channel ID.',
            }),
            name: z.string().min(1).register(z.globalRegistry, {
              description: 'The Slack channel name.',
            }),
          })
        )
        .register(z.globalRegistry, {
          description: 'A list of valid Slack channels.',
        })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.slack_api`.',
  });

/**
 * Connector request properties for a Swimlane connector
 *
 * Defines properties for connectors when type is `.swimlane`.
 */
export const swimlane_config = z
  .object({
    apiUrl: z.string().register(z.globalRegistry, {
      description: 'The Swimlane instance URL.',
    }),
    appId: z.string().register(z.globalRegistry, {
      description: 'The Swimlane application ID.',
    }),
    connectorType: z.enum(['all', 'alerts', 'cases']).register(z.globalRegistry, {
      description: 'The type of connector. Valid values are `all`, `alerts`, and `cases`.',
    }),
    mappings: z.optional(
      z
        .object({
          alertIdConfig: z.optional(
            z
              .object({
                fieldType: z.string().register(z.globalRegistry, {
                  description: 'The type of field in Swimlane.',
                }),
                id: z.string().register(z.globalRegistry, {
                  description: 'The identifier for the field in Swimlane.',
                }),
                key: z.string().register(z.globalRegistry, {
                  description: 'The key for the field in Swimlane.',
                }),
                name: z.string().register(z.globalRegistry, {
                  description: 'The name of the field in Swimlane.',
                }),
              })
              .register(z.globalRegistry, {
                description: 'Mapping for the alert ID.',
              })
          ),
          caseIdConfig: z.optional(
            z
              .object({
                fieldType: z.string().register(z.globalRegistry, {
                  description: 'The type of field in Swimlane.',
                }),
                id: z.string().register(z.globalRegistry, {
                  description: 'The identifier for the field in Swimlane.',
                }),
                key: z.string().register(z.globalRegistry, {
                  description: 'The key for the field in Swimlane.',
                }),
                name: z.string().register(z.globalRegistry, {
                  description: 'The name of the field in Swimlane.',
                }),
              })
              .register(z.globalRegistry, {
                description: 'Mapping for the case ID.',
              })
          ),
          caseNameConfig: z.optional(
            z
              .object({
                fieldType: z.string().register(z.globalRegistry, {
                  description: 'The type of field in Swimlane.',
                }),
                id: z.string().register(z.globalRegistry, {
                  description: 'The identifier for the field in Swimlane.',
                }),
                key: z.string().register(z.globalRegistry, {
                  description: 'The key for the field in Swimlane.',
                }),
                name: z.string().register(z.globalRegistry, {
                  description: 'The name of the field in Swimlane.',
                }),
              })
              .register(z.globalRegistry, {
                description: 'Mapping for the case name.',
              })
          ),
          commentsConfig: z.optional(
            z
              .object({
                fieldType: z.string().register(z.globalRegistry, {
                  description: 'The type of field in Swimlane.',
                }),
                id: z.string().register(z.globalRegistry, {
                  description: 'The identifier for the field in Swimlane.',
                }),
                key: z.string().register(z.globalRegistry, {
                  description: 'The key for the field in Swimlane.',
                }),
                name: z.string().register(z.globalRegistry, {
                  description: 'The name of the field in Swimlane.',
                }),
              })
              .register(z.globalRegistry, {
                description: 'Mapping for the case comments.',
              })
          ),
          descriptionConfig: z.optional(
            z
              .object({
                fieldType: z.string().register(z.globalRegistry, {
                  description: 'The type of field in Swimlane.',
                }),
                id: z.string().register(z.globalRegistry, {
                  description: 'The identifier for the field in Swimlane.',
                }),
                key: z.string().register(z.globalRegistry, {
                  description: 'The key for the field in Swimlane.',
                }),
                name: z.string().register(z.globalRegistry, {
                  description: 'The name of the field in Swimlane.',
                }),
              })
              .register(z.globalRegistry, {
                description: 'Mapping for the case description.',
              })
          ),
          ruleNameConfig: z.optional(
            z
              .object({
                fieldType: z.string().register(z.globalRegistry, {
                  description: 'The type of field in Swimlane.',
                }),
                id: z.string().register(z.globalRegistry, {
                  description: 'The identifier for the field in Swimlane.',
                }),
                key: z.string().register(z.globalRegistry, {
                  description: 'The key for the field in Swimlane.',
                }),
                name: z.string().register(z.globalRegistry, {
                  description: 'The name of the field in Swimlane.',
                }),
              })
              .register(z.globalRegistry, {
                description: "Mapping for the name of the alert's rule.",
              })
          ),
          severityConfig: z.optional(
            z
              .object({
                fieldType: z.string().register(z.globalRegistry, {
                  description: 'The type of field in Swimlane.',
                }),
                id: z.string().register(z.globalRegistry, {
                  description: 'The identifier for the field in Swimlane.',
                }),
                key: z.string().register(z.globalRegistry, {
                  description: 'The key for the field in Swimlane.',
                }),
                name: z.string().register(z.globalRegistry, {
                  description: 'The name of the field in Swimlane.',
                }),
              })
              .register(z.globalRegistry, {
                description: 'Mapping for the severity.',
              })
          ),
        })
        .register(z.globalRegistry, {
          description: 'The field mapping.',
        })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.swimlane`.',
  });

/**
 * Connector request properties for a TheHive connector
 *
 * Defines configuration properties for connectors when type is `.thehive`.
 */
export const thehive_config = z
  .object({
    organisation: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The organisation in TheHive that will contain the alerts or cases. By default, the connector uses the default organisation of the user account that created the API key.\n',
      })
    ),
    url: z.string().register(z.globalRegistry, {
      description:
        'The instance URL in TheHive. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines configuration properties for connectors when type is `.thehive`.',
  });

/**
 * Connector request properties for a Tines connector
 *
 * Defines properties for connectors when type is `.tines`.
 */
export const tines_config = z
  .object({
    url: z.string().register(z.globalRegistry, {
      description:
        'The Tines tenant URL. If you are using the `xpack.actions.allowedHosts` setting, make sure this hostname is added to the allowed hosts.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.tines`.',
  });

/**
 * Connector request properties for a Torq connector
 *
 * Defines properties for connectors when type is `.torq`.
 */
export const torq_config = z
  .object({
    webhookIntegrationUrl: z.string().register(z.globalRegistry, {
      description: 'The endpoint URL of the Elastic Security integration in Torq.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.torq`.',
  });

/**
 * Authentication type
 *
 * The type of authentication to use: basic, SSL, or none.
 *
 */
export const auth_type = z
  .enum(['webhook-authentication-basic', 'webhook-authentication-ssl'])
  .register(z.globalRegistry, {
    description: 'The type of authentication to use: basic, SSL, or none.\n',
  });

/**
 * Certificate authority
 *
 * A base64 encoded version of the certificate authority file that the connector can trust to sign and validate certificates. This option is available for all authentication types.
 *
 */
export const ca = z.string().register(z.globalRegistry, {
  description:
    'A base64 encoded version of the certificate authority file that the connector can trust to sign and validate certificates. This option is available for all authentication types.\n',
});

/**
 * Certificate type
 *
 * If the `authType` is `webhook-authentication-ssl`, specifies whether the certificate authentication data is in a CRT and key file format or a PFX file format.
 *
 */
export const cert_type = z.enum(['ssl-crt-key', 'ssl-pfx']).register(z.globalRegistry, {
  description:
    'If the `authType` is `webhook-authentication-ssl`, specifies whether the certificate authentication data is in a CRT and key file format or a PFX file format.\n',
});

/**
 * Has authentication
 *
 * If true, a username and password for login type authentication must be provided.
 */
export const has_auth = z
  .boolean()
  .register(z.globalRegistry, {
    description: 'If true, a username and password for login type authentication must be provided.',
  })
  .default(true);

/**
 * Verification mode
 *
 * Controls the verification of certificates. Use `full` to validate that the certificate has an issue date within the `not_before` and `not_after` dates, chains to a trusted certificate authority (CA), and has a hostname or IP address that matches the names within the certificate. Use `certificate` to validate the certificate and verify that it is signed by a trusted authority; this option does not check the certificate hostname. Use `none` to skip certificate validation.
 *
 */
export const verification_mode = z
  .enum(['certificate', 'full', 'none'])
  .register(z.globalRegistry, {
    description:
      'Controls the verification of certificates. Use `full` to validate that the certificate has an issue date within the `not_before` and `not_after` dates, chains to a trusted certificate authority (CA), and has a hostname or IP address that matches the names within the certificate. Use `certificate` to validate the certificate and verify that it is signed by a trusted authority; this option does not check the certificate hostname. Use `none` to skip certificate validation.\n',
  });

/**
 * Connector request properties for a Webhook connector
 *
 * Defines properties for connectors when type is `.webhook`.
 */
export const webhook_config = z
  .object({
    authType: z.optional(auth_type),
    ca: z.optional(ca),
    certType: z.optional(cert_type),
    hasAuth: z.optional(has_auth),
    headers: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
    method: z.optional(
      z.enum(['post', 'put']).register(z.globalRegistry, {
        description: 'The HTTP request method, either `post` or `put`.\n',
      })
    ),
    url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The request URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.\n',
      })
    ),
    verificationMode: z.optional(verification_mode),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.webhook`.',
  });

/**
 * Connector request properties for Webhook - Case Management connector
 *
 * Defines properties for connectors when type is `.cases-webhook`.
 */
export const cases_webhook_config = z
  .object({
    authType: z.optional(auth_type),
    ca: z.optional(ca),
    certType: z.optional(cert_type),
    createCommentJson: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A JSON payload sent to the create comment URL to create a case comment. You can use variables to add Kibana Cases data to the payload. The required variable is `case.comment`. Due to Mustache template variables (the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated once the Mustache variables have been placed when the REST method runs. Manually ensure that the JSON is valid, disregarding the Mustache variables, so the later validation will pass.\n',
      })
    ),
    createCommentMethod: z.optional(
      z.enum(['patch', 'post', 'put']).register(z.globalRegistry, {
        description:
          'The REST API HTTP request method to create a case comment in the third-party system. Valid values are `patch`, `post`, and `put`.\n',
      })
    ),
    createCommentUrl: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The REST API URL to create a case comment by ID in the third-party system. You can use a variable to add the external system ID to the URL. If you are using the `xpack.actions.allowedHosts setting`, add the hostname to the allowed hosts.\n',
      })
    ),
    createIncidentJson: z.string().register(z.globalRegistry, {
      description:
        'A JSON payload sent to the create case URL to create a case. You can use variables to add case data to the payload. Required variables are `case.title` and `case.description`. Due to Mustache template variables (which is the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated after the Mustache variables have been placed when REST method runs. Manually ensure that the JSON is valid to avoid future validation errors; disregard Mustache variables during your review.\n',
    }),
    createIncidentMethod: z.optional(
      z.enum(['patch', 'post', 'put']).register(z.globalRegistry, {
        description:
          'The REST API HTTP request method to create a case in the third-party system. Valid values are `patch`, `post`, and `put`.\n',
      })
    ),
    createIncidentResponseKey: z.string().register(z.globalRegistry, {
      description: 'The JSON key in the create external case response that contains the case ID.',
    }),
    createIncidentUrl: z.string().register(z.globalRegistry, {
      description:
        'The REST API URL to create a case in the third-party system. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.\n',
    }),
    getIncidentResponseExternalTitleKey: z.string().register(z.globalRegistry, {
      description: 'The JSON key in get external case response that contains the case title.',
    }),
    getIncidentUrl: z.string().register(z.globalRegistry, {
      description:
        'The REST API URL to get the case by ID from the third-party system. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts. You can use a variable to add the external system ID to the URL. Due to Mustache template variables (the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated after the Mustache variables have been placed when REST method runs. Manually ensure that the JSON is valid, disregarding the Mustache variables, so the later validation will pass.\n',
    }),
    hasAuth: z.optional(has_auth),
    headers: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A set of key-value pairs sent as headers with the request URLs for the create case, update case, get case, and create comment methods.\n',
      })
    ),
    updateIncidentJson: z.string().register(z.globalRegistry, {
      description:
        'The JSON payload sent to the update case URL to update the case. You can use variables to add Kibana Cases data to the payload. Required variables are `case.title` and `case.description`. Due to Mustache template variables (which is the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated after the Mustache variables have been placed when REST method runs. Manually ensure that the JSON is valid to avoid future validation errors; disregard Mustache variables during your review.\n',
    }),
    updateIncidentMethod: z.optional(
      z.enum(['patch', 'post', 'put']).register(z.globalRegistry, {
        description:
          'The REST API HTTP request method to update the case in the third-party system. Valid values are `patch`, `post`, and `put`.\n',
      })
    ),
    updateIncidentUrl: z.string().register(z.globalRegistry, {
      description:
        'The REST API URL to update the case by ID in the third-party system. You can use a variable to add the external system ID to the URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.\n',
    }),
    verificationMode: z.optional(verification_mode),
    viewIncidentUrl: z.string().register(z.globalRegistry, {
      description:
        'The URL to view the case in the external system. You can use variables to add the external system ID or external system title to the URL.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.cases-webhook`.',
  });

/**
 * Connector request properties for an xMatters connector
 *
 * Defines properties for connectors when type is `.xmatters`.
 */
export const xmatters_config = z
  .object({
    configUrl: z.optional(z.union([z.string(), z.null()])),
    usesBasic: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Specifies whether the connector uses HTTP basic authentication (`true`) or URL authentication (`false`).',
        })
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.xmatters`.',
  });

/**
 * Connector secrets properties for an Amazon Bedrock connector
 *
 * Defines secrets for connectors when type is `.bedrock`.
 */
export const bedrock_secrets = z
  .object({
    accessKey: z.string().register(z.globalRegistry, {
      description: 'The AWS access key for authentication.',
    }),
    secret: z.string().register(z.globalRegistry, {
      description: 'The AWS secret for authentication.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.bedrock`.',
  });

/**
 * Connector secrets properties for a Crowdstrike connector
 *
 * Defines secrets for connectors when type is `.crowdstrike`.
 */
export const crowdstrike_secrets = z
  .object({
    clientId: z.string().register(z.globalRegistry, {
      description: 'The CrowdStrike API client identifier.',
    }),
    clientSecret: z.string().register(z.globalRegistry, {
      description: 'The CrowdStrike API client secret to authenticate the `clientId`.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.crowdstrike`.',
  });

/**
 * Connector secrets properties for a D3 Security connector
 *
 * Defines secrets for connectors when type is `.d3security`.
 */
export const d3security_secrets = z
  .object({
    token: z.string().register(z.globalRegistry, {
      description: 'The D3 Security token.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.d3security`.',
  });

/**
 * Connector secrets properties for an email connector
 *
 * Defines secrets for connectors when type is `.email`.
 */
export const email_secrets = z
  .object({
    clientSecret: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The Microsoft Exchange Client secret for OAuth 2.0 client credentials authentication. It must be URL-encoded. If `service` is `exchange_server`, this property is required.\n',
      })
    ),
    password: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The password for HTTP basic authentication. If `hasAuth` is set to `true`, this property is required.\n',
      })
    ),
    user: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The username for HTTP basic authentication. If `hasAuth` is set to `true`, this property is required.\n',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.email`.',
  });

/**
 * Connector secrets properties for a Google Gemini connector
 *
 * Defines secrets for connectors when type is `.gemini`.
 */
export const gemini_secrets = z
  .object({
    credentialsJson: z.string().register(z.globalRegistry, {
      description:
        'The service account credentials JSON file. The service account should have Vertex AI user IAM role assigned to it.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.gemini`.',
  });

/**
 * Connector secrets properties for IBM Resilient connector
 *
 * Defines secrets for connectors when type is `.resilient`.
 */
export const resilient_secrets = z
  .object({
    apiKeyId: z.string().register(z.globalRegistry, {
      description: 'The authentication key ID for HTTP Basic authentication.',
    }),
    apiKeySecret: z.string().register(z.globalRegistry, {
      description: 'The authentication key secret for HTTP Basic authentication.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.resilient`.',
  });

/**
 * Connector secrets properties for a Jira connector
 *
 * Defines secrets for connectors when type is `.jira`.
 */
export const jira_secrets = z
  .object({
    apiToken: z.string().register(z.globalRegistry, {
      description: 'The Jira API authentication token for HTTP basic authentication.',
    }),
    email: z.string().register(z.globalRegistry, {
      description: 'The account email for HTTP Basic authentication.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.jira`.',
  });

/**
 * Connector secrets properties for a Microsoft Teams connector
 *
 * Defines secrets for connectors when type is `.teams`.
 */
export const teams_secrets = z
  .object({
    webhookUrl: z.string().register(z.globalRegistry, {
      description:
        'The URL of the incoming webhook. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.teams`.',
  });

/**
 * Connector secrets properties for an OpenAI connector
 *
 * Defines secrets for connectors when type is `.gen-ai`. Supports both API key authentication (OpenAI, Azure OpenAI, and `Other`) and PKI authentication (`Other` provider only). PKI fields must be base64-encoded PEM content.
 *
 */
export const genai_secrets = z
  .object({
    apiKey: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The API key for authentication. For OpenAI and Azure OpenAI providers, it is required. For the `Other` provider, it is required if you do not use PKI authentication. With PKI, you can also optionally include an API key if the OpenAI-compatible service supports or requires one.\n',
      })
    ),
    certificateData: z.optional(
      z.string().min(1).register(z.globalRegistry, {
        description:
          'Base64-encoded PEM certificate content for PKI authentication (Other provider only). Required for PKI.\n',
      })
    ),
    privateKeyData: z.optional(
      z.string().min(1).register(z.globalRegistry, {
        description:
          'Base64-encoded PEM private key content for PKI authentication (Other provider only). Required for PKI.\n',
      })
    ),
    caData: z.optional(
      z.string().min(1).register(z.globalRegistry, {
        description:
          'Base64-encoded PEM CA certificate content for PKI authentication (Other provider only). Optional.\n',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'Defines secrets for connectors when type is `.gen-ai`. Supports both API key authentication (OpenAI, Azure OpenAI, and `Other`) and PKI authentication (`Other` provider only). PKI fields must be base64-encoded PEM content.\n',
  });

/**
 * Connector secrets properties for an Opsgenie connector
 *
 * Defines secrets for connectors when type is `.opsgenie`.
 */
export const opsgenie_secrets = z
  .object({
    apiKey: z.string().register(z.globalRegistry, {
      description: 'The Opsgenie API authentication key for HTTP Basic authentication.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.opsgenie`.',
  });

/**
 * Connector secrets properties for a PagerDuty connector
 *
 * Defines secrets for connectors when type is `.pagerduty`.
 */
export const pagerduty_secrets = z
  .object({
    routingKey: z.string().register(z.globalRegistry, {
      description: 'A 32 character PagerDuty Integration Key for an integration on a service.\n',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.pagerduty`.',
  });

/**
 * Connector secrets properties for a SentinelOne connector
 *
 * Defines secrets for connectors when type is `.sentinelone`.
 */
export const sentinelone_secrets = z
  .object({
    token: z.string().register(z.globalRegistry, {
      description: 'The A SentinelOne API token.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.sentinelone`.',
  });

/**
 * Connector secrets properties for ServiceNow ITOM, ServiceNow ITSM, and ServiceNow SecOps connectors
 *
 * Defines secrets for connectors when type is `.servicenow`, `.servicenow-sir`, or `.servicenow-itom`.
 */
export const servicenow_secrets = z
  .object({
    clientSecret: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The client secret assigned to your OAuth application. This property is required when `isOAuth` is `true`.',
      })
    ),
    password: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The password for HTTP basic authentication. This property is required when `isOAuth` is `false`.',
      })
    ),
    privateKey: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The RSA private key that you created for use in ServiceNow. This property is required when `isOAuth` is `true`.',
      })
    ),
    privateKeyPassword: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The password for the RSA private key. This property is required when `isOAuth` is `true` and you set a password on your private key.',
      })
    ),
    username: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The username for HTTP basic authentication. This property is required when `isOAuth` is `false`.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'Defines secrets for connectors when type is `.servicenow`, `.servicenow-sir`, or `.servicenow-itom`.',
  });

/**
 * Connector secrets properties for a Web API Slack connector
 *
 * Defines secrets for connectors when type is `.slack`.
 */
export const slack_api_secrets = z
  .object({
    token: z.string().register(z.globalRegistry, {
      description: 'Slack bot user OAuth token.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.slack`.',
  });

/**
 * Connector secrets properties for a Swimlane connector
 *
 * Defines secrets for connectors when type is `.swimlane`.
 */
export const swimlane_secrets = z
  .object({
    apiToken: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Swimlane API authentication token.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.swimlane`.',
  });

/**
 * Connector secrets properties for a TheHive connector
 *
 * Defines secrets for connectors when type is `.thehive`.
 */
export const thehive_secrets = z
  .object({
    apiKey: z.string().register(z.globalRegistry, {
      description: 'The API key for authentication in TheHive.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.thehive`.',
  });

/**
 * Connector secrets properties for a Tines connector
 *
 * Defines secrets for connectors when type is `.tines`.
 */
export const tines_secrets = z
  .object({
    email: z.string().register(z.globalRegistry, {
      description: 'The email used to sign in to Tines.',
    }),
    token: z.string().register(z.globalRegistry, {
      description: 'The Tines API token.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.tines`.',
  });

/**
 * Connector secrets properties for a Torq connector
 *
 * Defines secrets for connectors when type is `.torq`.
 */
export const torq_secrets = z
  .object({
    token: z.string().register(z.globalRegistry, {
      description: 'The secret of the webhook authentication header.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.torq`.',
  });

/**
 * Certificate
 *
 * If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-crt-key`, it is a base64 encoded version of the CRT or CERT file.
 */
export const crt = z.string().register(z.globalRegistry, {
  description:
    'If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-crt-key`, it is a base64 encoded version of the CRT or CERT file.',
});

/**
 * Certificate key
 *
 * If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-crt-key`, it is a base64 encoded version of the KEY file.
 */
export const key = z.string().register(z.globalRegistry, {
  description:
    'If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-crt-key`, it is a base64 encoded version of the KEY file.',
});

/**
 * Personal information exchange
 *
 * If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-pfx`, it is a base64 encoded version of the PFX or P12 file.
 */
export const pfx = z.string().register(z.globalRegistry, {
  description:
    'If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-pfx`, it is a base64 encoded version of the PFX or P12 file.',
});

/**
 * Connector secrets properties for a Webhook connector
 *
 * Defines secrets for connectors when type is `.webhook`.
 */
export const webhook_secrets = z
  .object({
    crt: z.optional(crt),
    key: z.optional(key),
    pfx: z.optional(pfx),
    password: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The password for HTTP basic authentication or the passphrase for the SSL certificate files. If `hasAuth` is set to `true` and `authType` is `webhook-authentication-basic`, this property is required.\n',
      })
    ),
    user: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The username for HTTP basic authentication. If `hasAuth` is set to `true`  and `authType` is `webhook-authentication-basic`, this property is required.\n',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.webhook`.',
  });

/**
 * Connector secrets properties for Webhook - Case Management connector
 */
export const cases_webhook_secrets = z.object({
  crt: z.optional(crt),
  key: z.optional(key),
  pfx: z.optional(pfx),
  password: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The password for HTTP basic authentication. If `hasAuth` is set to `true` and and `authType` is `webhook-authentication-basic`, this property is required.\n',
    })
  ),
  user: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The username for HTTP basic authentication. If `hasAuth` is set to `true` and `authType` is `webhook-authentication-basic`, this property is required.\n',
    })
  ),
});

/**
 * Connector secrets properties for an xMatters connector
 *
 * Defines secrets for connectors when type is `.xmatters`.
 */
export const xmatters_secrets = z
  .object({
    password: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A user name for HTTP basic authentication. It is applicable only when `usesBasic` is `true`.\n',
      })
    ),
    secretsUrl: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The request URL for the Elastic Alerts trigger in xMatters with the API key included in the URL. It is applicable only when `usesBasic` is `false`.\n',
      })
    ),
    user: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A password for HTTP basic authentication. It is applicable only when `usesBasic` is `true`.\n',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `.xmatters`.',
  });

/**
 * Connector request properties for an OpenAI connector with Other provider
 *
 * Defines properties for connectors when type is `.gen-ai` and the API provider is `Other` (OpenAI-compatible service), including optional PKI authentication.
 *
 */
export const genai_openai_other_config = z
  .object({
    apiProvider: z.enum(['Other']).register(z.globalRegistry, {
      description: 'The OpenAI API provider.',
    }),
    apiUrl: z.string().register(z.globalRegistry, {
      description: 'The OpenAI-compatible API endpoint.',
    }),
    defaultModel: z.string().register(z.globalRegistry, {
      description: 'The default model to use for requests.',
    }),
    certificateData: z.optional(
      z.string().min(1).register(z.globalRegistry, {
        description: 'PEM-encoded certificate content.',
      })
    ),
    privateKeyData: z.optional(
      z.string().min(1).register(z.globalRegistry, {
        description: 'PEM-encoded private key content.',
      })
    ),
    caData: z.optional(
      z.string().min(1).register(z.globalRegistry, {
        description: 'PEM-encoded CA certificate content.',
      })
    ),
    verificationMode: z.optional(
      z.enum(['full', 'certificate', 'none']).register(z.globalRegistry, {
        description: 'SSL verification mode for PKI authentication.',
      })
    ),
    headers: z.optional(
      z.record(z.string(), z.string()).register(z.globalRegistry, {
        description: 'Custom headers to include in requests.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'Defines properties for connectors when type is `.gen-ai` and the API provider is `Other` (OpenAI-compatible service), including optional PKI authentication.\n',
  });

/**
 * Connector secrets properties for a Microsoft Defender for Endpoint connector
 *
 * Defines secrets for connectors when type is `..microsoft_defender_endpoint`.
 */
export const defender_secrets = z
  .object({
    clientSecret: z.string().register(z.globalRegistry, {
      description: 'The client secret for your app in the Azure portal.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Defines secrets for connectors when type is `..microsoft_defender_endpoint`.',
  });

/**
 * PagerDuty connector parameters
 *
 * Test an action that acknowledges or resolves a PagerDuty alert.
 */
export const run_acknowledge_resolve_pagerduty = z
  .object({
    dedupKey: z.string().max(255).register(z.globalRegistry, {
      description: 'The deduplication key for the PagerDuty alert.',
    }),
    eventAction: z.enum(['acknowledge', 'resolve']).register(z.globalRegistry, {
      description: 'The type of event.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Test an action that acknowledges or resolves a PagerDuty alert.',
  });

/**
 * Index connector parameters
 *
 * Test an action that indexes a document into Elasticsearch.
 */
export const run_documents = z
  .object({
    documents: z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
      description: 'The documents in JSON format for index connectors.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Test an action that indexes a document into Elasticsearch.',
  });

/**
 * Email connector parameters
 *
 * Test an action that sends an email message. There must be at least one recipient in `to`, `cc`, or `bcc`.
 *
 */
export const run_message_email = z
  .object({
    bcc: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          'A list of "blind carbon copy" email addresses. Addresses can be specified in `user@host-name` format or in name `<user@host-name>` format\n',
      })
    ),
    cc: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          'A list of "carbon copy" email addresses. Addresses can be specified in `user@host-name` format or in name `<user@host-name>` format \n',
      })
    ),
    message: z.string().register(z.globalRegistry, {
      description: 'The email message text. Markdown format is supported.',
    }),
    subject: z.string().register(z.globalRegistry, {
      description: 'The subject line of the email.',
    }),
    to: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          'A list of email addresses. Addresses can be specified in `user@host-name` format or in name `<user@host-name>` format.\n',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'Test an action that sends an email message. There must be at least one recipient in `to`, `cc`, or `bcc`.\n',
  });

/**
 * Server log connector parameters
 *
 * Test an action that writes an entry to the Kibana server log.
 */
export const run_message_serverlog = z
  .object({
    level: z.optional(
      z.enum(['debug', 'error', 'fatal', 'info', 'trace', 'warn']).register(z.globalRegistry, {
        description: 'The log level of the message for server log connectors.',
      })
    ),
    message: z.string().register(z.globalRegistry, {
      description: 'The message for server log connectors.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Test an action that writes an entry to the Kibana server log.',
  });

/**
 * Slack connector parameters
 *
 * Test an action that sends a message to Slack. It is applicable only when the connector type is `.slack`.
 *
 */
export const run_message_slack = z
  .object({
    message: z.string().register(z.globalRegistry, {
      description:
        'The Slack message text, which cannot contain Markdown, images, or other advanced formatting.',
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Test an action that sends a message to Slack. It is applicable only when the connector type is `.slack`.\n',
  });

/**
 * PagerDuty connector parameters
 *
 * Test an action that triggers a PagerDuty alert.
 */
export const run_trigger_pagerduty = z
  .object({
    class: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The class or type of the event.',
      })
    ),
    component: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The component of the source machine that is responsible for the event.',
      })
    ),
    customDetails: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Additional details to add to the event.',
      })
    ),
    dedupKey: z.optional(
      z.string().max(255).register(z.globalRegistry, {
        description:
          'All actions sharing this key will be associated with the same PagerDuty alert. This value is used to correlate trigger and resolution.\n',
      })
    ),
    eventAction: z.enum(['trigger']).register(z.globalRegistry, {
      description: 'The type of event.',
    }),
    group: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The logical grouping of components of a service.',
      })
    ),
    links: z.optional(
      z
        .array(
          z.object({
            href: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The URL for the link.',
              })
            ),
            text: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'A plain text description of the purpose of the link.',
              })
            ),
          })
        )
        .register(z.globalRegistry, {
          description: 'A list of links to add to the event.',
        })
    ),
    severity: z.optional(
      z.enum(['critical', 'error', 'info', 'warning']).register(z.globalRegistry, {
        description: 'The severity of the event on the affected system.',
      })
    ),
    source: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The affected system, such as a hostname or fully qualified domain name. Defaults to the Kibana saved object id of the action.\n',
      })
    ),
    summary: z.optional(
      z.string().max(1024).register(z.globalRegistry, {
        description: 'A summery of the event.',
      })
    ),
    timestamp: z.optional(
      z.iso.datetime().register(z.globalRegistry, {
        description:
          'An ISO-8601 timestamp that indicates when the event was detected or generated.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Test an action that triggers a PagerDuty alert.',
  });

/**
 * The addEvent subaction
 *
 * The `addEvent` subaction for ServiceNow ITOM connectors.
 */
export const run_addevent = z
  .object({
    subAction: z.enum(['addEvent']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z.optional(
      z
        .object({
          additional_info: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Additional information about the event.',
            })
          ),
          description: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The details about the event.',
            })
          ),
          event_class: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'A specific instance of the source.',
            })
          ),
          message_key: z.optional(
            z.string().register(z.globalRegistry, {
              description:
                'All actions sharing this key are associated with the same ServiceNow alert. The default value is `<rule ID>:<alert instance ID>`.',
            })
          ),
          metric_name: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The name of the metric.',
            })
          ),
          node: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The host that the event was triggered for.',
            })
          ),
          resource: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The name of the resource.',
            })
          ),
          severity: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The severity of the event.',
            })
          ),
          source: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The name of the event source type.',
            })
          ),
          time_of_event: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The time of the event.',
            })
          ),
          type: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The type of event.',
            })
          ),
        })
        .register(z.globalRegistry, {
          description: 'The set of configuration properties for the action.',
        })
    ),
  })
  .register(z.globalRegistry, {
    description: 'The `addEvent` subaction for ServiceNow ITOM connectors.',
  });

/**
 * The closeAlert subaction
 *
 * The `closeAlert` subaction for Opsgenie connectors.
 */
export const run_closealert = z
  .object({
    subAction: z.enum(['closeAlert']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z.object({
      alias: z.string().register(z.globalRegistry, {
        description:
          'The unique identifier used for alert deduplication in Opsgenie. The alias must match the value used when creating the alert.',
      }),
      note: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Additional information for the alert.',
        })
      ),
      source: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The display name for the source of the alert.',
        })
      ),
      user: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The display name for the owner.',
        })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'The `closeAlert` subaction for Opsgenie connectors.',
  });

/**
 * The closeIncident subaction
 *
 * The `closeIncident` subaction for ServiceNow ITSM connectors.
 */
export const run_closeincident = z
  .object({
    subAction: z.enum(['closeIncident']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z.object({
      incident: z.intersection(
        z.unknown(),
        z.object({
          correlation_id: z
            .optional(z.union([z.string().max(100).default('{{rule.id}}:{{alert.id}}'), z.null()]))
            .default('{{rule.id}}:{{alert.id}}'),
          externalId: z.optional(z.union([z.string(), z.null()])),
        })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'The `closeIncident` subaction for ServiceNow ITSM connectors.',
  });

/**
 * The createAlert subaction
 *
 * The `createAlert` subaction for Opsgenie and TheHive connectors.
 */
export const run_createalert = z
  .object({
    subAction: z.enum(['createAlert']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z.object({
      actions: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'The custom actions available to the alert in Opsgenie connectors.',
        })
      ),
      alias: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The unique identifier used for alert deduplication in Opsgenie.',
        })
      ),
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'A description that provides detailed information about the alert.',
        })
      ),
      details: z.optional(
        z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description: 'The custom properties of the alert in Opsgenie connectors.',
        })
      ),
      entity: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The domain of the alert in Opsgenie connectors. For example, the application or server name.',
        })
      ),
      message: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The alert message in Opsgenie connectors.',
        })
      ),
      note: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Additional information for the alert in Opsgenie connectors.',
        })
      ),
      priority: z.optional(
        z.enum(['P1', 'P2', 'P3', 'P4', 'P5']).register(z.globalRegistry, {
          description: 'The priority level for the alert in Opsgenie connectors.',
        })
      ),
      responders: z.optional(
        z
          .array(
            z.object({
              id: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'The identifier for the entity.',
                })
              ),
              name: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'The name of the entity.',
                })
              ),
              type: z.optional(
                z.enum(['escalation', 'schedule', 'team', 'user']).register(z.globalRegistry, {
                  description: 'The type of responders, in this case `escalation`.',
                })
              ),
              username: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'A valid email address for the user.',
                })
              ),
            })
          )
          .register(z.globalRegistry, {
            description:
              'The entities to receive notifications about the alert in Opsgenie connectors. If `type` is `user`, either `id` or `username` is required. If `type` is `team`, either `id` or `name` is required.\n',
          })
      ),
      severity: z.optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description:
            'The severity of the incident for TheHive connectors. The value ranges from 1 (low) to 4 (critical) with a default value of 2 (medium).\n',
        })
      ),
      source: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The display name for the source of the alert in Opsgenie and TheHive connectors.',
        })
      ),
      sourceRef: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'A source reference for the alert in TheHive connectors.',
        })
      ),
      tags: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'The tags for the alert in Opsgenie and TheHive connectors.',
        })
      ),
      title: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A title for the incident for TheHive connectors. It is used for searching the contents of the knowledge base.\n',
        })
      ),
      tlp: z
        .optional(
          z.int().gte(0).lte(4).register(z.globalRegistry, {
            description:
              'The traffic light protocol designation for the incident in TheHive connectors. Valid values include: 0 (clear), 1 (green), 2 (amber), 3 (amber and strict), and 4 (red).\n',
          })
        )
        .default(2),
      type: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The type of alert in TheHive connectors.',
        })
      ),
      user: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The display name for the owner.',
        })
      ),
      visibleTo: z.optional(
        z
          .array(
            z.object({
              id: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'The identifier for the entity.',
                })
              ),
              name: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'The name of the entity.',
                })
              ),
              type: z.enum(['team', 'user']).register(z.globalRegistry, {
                description: 'Valid values are `team` and `user`.',
              }),
              username: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The user name. This property is required only when the `type` is `user`.',
                })
              ),
            })
          )
          .register(z.globalRegistry, {
            description:
              'The teams and users that the alert will be visible to without sending a notification. Only one of `id`, `name`, or `username` is required.',
          })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'The `createAlert` subaction for Opsgenie and TheHive connectors.',
  });

/**
 * The fieldsByIssueType subaction
 *
 * The `fieldsByIssueType` subaction for Jira connectors.
 */
export const run_fieldsbyissuetype = z
  .object({
    subAction: z.enum(['fieldsByIssueType']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z.object({
      id: z.string().register(z.globalRegistry, {
        description: 'The Jira issue type identifier.',
      }),
    }),
  })
  .register(z.globalRegistry, {
    description: 'The `fieldsByIssueType` subaction for Jira connectors.',
  });

/**
 * The getAgentDetails subaction
 *
 * The `getAgentDetails` subaction for CrowdStrike connectors.
 */
export const run_getagentdetails = z
  .object({
    subAction: z.enum(['getAgentDetails']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z
      .object({
        ids: z.array(z.string()).register(z.globalRegistry, {
          description: 'An array of CrowdStrike agent identifiers.',
        }),
      })
      .register(z.globalRegistry, {
        description: 'The set of configuration properties for the action.',
      }),
  })
  .register(z.globalRegistry, {
    description: 'The `getAgentDetails` subaction for CrowdStrike connectors.',
  });

/**
 * The getAgents subaction
 *
 * The `getAgents` subaction for SentinelOne connectors.
 */
export const run_getagents = z
  .object({
    subAction: z.enum(['getAgents']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'The `getAgents` subaction for SentinelOne connectors.',
  });

/**
 * The getChoices subaction
 *
 * The `getChoices` subaction for ServiceNow ITOM, ServiceNow ITSM, and ServiceNow SecOps connectors.
 */
export const run_getchoices = z
  .object({
    subAction: z.enum(['getChoices']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z
      .object({
        fields: z.array(z.string()).register(z.globalRegistry, {
          description: 'An array of fields.',
        }),
      })
      .register(z.globalRegistry, {
        description: 'The set of configuration properties for the action.',
      }),
  })
  .register(z.globalRegistry, {
    description:
      'The `getChoices` subaction for ServiceNow ITOM, ServiceNow ITSM, and ServiceNow SecOps connectors.',
  });

/**
 * The getFields subaction
 *
 * The `getFields` subaction for Jira, ServiceNow ITSM, and ServiceNow SecOps connectors.
 */
export const run_getfields = z
  .object({
    subAction: z.enum(['getFields']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
  })
  .register(z.globalRegistry, {
    description:
      'The `getFields` subaction for Jira, ServiceNow ITSM, and ServiceNow SecOps connectors.',
  });

/**
 * The getIncident subaction
 *
 * The `getIncident` subaction for Jira, ServiceNow ITSM, and ServiceNow SecOps connectors.
 */
export const run_getincident = z
  .object({
    subAction: z.enum(['getIncident']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z.object({
      externalId: z.string().register(z.globalRegistry, {
        description: 'The Jira, ServiceNow ITSM, or ServiceNow SecOps issue identifier.',
      }),
    }),
  })
  .register(z.globalRegistry, {
    description:
      'The `getIncident` subaction for Jira, ServiceNow ITSM, and ServiceNow SecOps connectors.',
  });

/**
 * The issue subaction
 *
 * The `issue` subaction for Jira connectors.
 */
export const run_issue = z
  .object({
    subAction: z.enum(['issue']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z.optional(
      z.object({
        id: z.string().register(z.globalRegistry, {
          description: 'The Jira issue identifier.',
        }),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'The `issue` subaction for Jira connectors.',
  });

/**
 * The issues subaction
 *
 * The `issues` subaction for Jira connectors.
 */
export const run_issues = z
  .object({
    subAction: z.enum(['issues']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z.object({
      title: z.string().register(z.globalRegistry, {
        description: 'The title of the Jira issue.',
      }),
    }),
  })
  .register(z.globalRegistry, {
    description: 'The `issues` subaction for Jira connectors.',
  });

/**
 * The issueTypes subaction
 *
 * The `issueTypes` subaction for Jira connectors.
 */
export const run_issuetypes = z
  .object({
    subAction: z.enum(['issueTypes']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'The `issueTypes` subaction for Jira connectors.',
  });

/**
 * The postMessage subaction
 *
 * Test an action that sends a message to Slack. It is applicable only when the connector type is `.slack_api`.
 *
 */
export const run_postmessage = z
  .object({
    subAction: z.enum(['postMessage']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z
      .object({
        channelIds: z.optional(
          z.array(z.string()).max(1).register(z.globalRegistry, {
            description:
              'The Slack channel identifier, which must be one of the `allowedChannels` in the connector configuration.\n',
          })
        ),
        channels: z.optional(
          z.array(z.string()).max(1).register(z.globalRegistry, {
            description: 'The name of a channel that your Slack app has access to.\n',
          })
        ),
        text: z.optional(
          z.string().min(1).register(z.globalRegistry, {
            description:
              'The Slack message text. If it is a Slack webhook connector, the text cannot contain Markdown, images, or other advanced formatting. If it is a Slack web API connector, it can contain either plain text or block kit messages.\n',
          })
        ),
      })
      .register(z.globalRegistry, {
        description: 'The set of configuration properties for the action.',
      }),
  })
  .register(z.globalRegistry, {
    description:
      'Test an action that sends a message to Slack. It is applicable only when the connector type is `.slack_api`.\n',
  });

/**
 * The pushToService subaction
 *
 * The `pushToService` subaction for Jira, ServiceNow ITSM, ServiceNow SecOps, Swimlane, TheHive, and Webhook - Case Management connectors.
 */
export const run_pushtoservice = z
  .object({
    subAction: z.enum(['pushToService']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z
      .object({
        comments: z.optional(
          z
            .array(
              z.object({
                comment: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      'A comment related to the incident. For example, describe how to troubleshoot the issue.',
                  })
                ),
                commentId: z.optional(
                  z.int().register(z.globalRegistry, {
                    description: 'A unique identifier for the comment.',
                  })
                ),
              })
            )
            .register(z.globalRegistry, {
              description:
                'Additional information that is sent to Jira, ServiceNow ITSM, ServiceNow SecOps, Swimlane, or TheHive.',
            })
        ),
        incident: z.optional(
          z
            .object({
              additional_fields: z.optional(z.union([z.string().max(20), z.null()])),
              alertId: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'The alert identifier for Swimlane connectors.',
                })
              ),
              caseId: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'The case identifier for the incident for Swimlane connectors.',
                })
              ),
              caseName: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'The case name for the incident for Swimlane connectors.',
                })
              ),
              category: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The category of the incident for ServiceNow ITSM and ServiceNow SecOps connectors.',
                })
              ),
              correlation_display: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'A descriptive label of the alert for correlation purposes for ServiceNow ITSM and ServiceNow SecOps connectors.',
                })
              ),
              correlation_id: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The correlation identifier for the security incident for ServiceNow ITSM and ServiveNow SecOps connectors. Connectors using the same correlation ID are associated with the same ServiceNow incident. This value determines whether a new ServiceNow incident is created or an existing one is updated. Modifying this value is optional; if not modified, the rule ID and alert ID are combined as `{{ruleID}}:{{alert ID}}` to form the correlation ID value in ServiceNow. The maximum character length for this value is 100 characters. NOTE: Using the default configuration of `{{ruleID}}:{{alert ID}}` ensures that ServiceNow creates a separate incident record for every generated alert that uses a unique alert ID. If the rule generates multiple alerts that use the same alert IDs, ServiceNow creates and continually updates a single incident record for the alert.\n',
                })
              ),
              description: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The description of the incident for Jira, ServiceNow ITSM, ServiceNow SecOps, Swimlane, TheHive, and Webhook - Case Management connectors.',
                })
              ),
              dest_ip: z.optional(z.union([z.string(), z.array(z.string())])),
              externalId: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The Jira, ServiceNow ITSM, or ServiceNow SecOps issue identifier. If present, the incident is updated. Otherwise, a new incident is created.\n',
                })
              ),
              id: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The external case identifier for Webhook - Case Management connectors.',
                })
              ),
              impact: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'The impact of the incident for ServiceNow ITSM connectors.',
                })
              ),
              issueType: z.optional(
                z.int().register(z.globalRegistry, {
                  description:
                    'The type of incident for Jira connectors. For example, 10006. To obtain the list of valid values, set `subAction` to `issueTypes`.',
                })
              ),
              labels: z.optional(
                z.array(z.string()).register(z.globalRegistry, {
                  description:
                    'The labels for the incident for Jira connectors. NOTE: Labels cannot contain spaces.\n',
                })
              ),
              malware_hash: z.optional(z.union([z.string(), z.array(z.string())])),
              malware_url: z.optional(z.union([z.string(), z.array(z.string())])),
              otherFields: z.optional(
                z.record(z.string(), z.unknown()).register(z.globalRegistry, {
                  description: 'Custom field identifiers and their values for Jira connectors.\n',
                })
              ),
              parent: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The ID or key of the parent issue for Jira connectors. Applies only to `Sub-task` types of issues.',
                })
              ),
              priority: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The priority of the incident in Jira and ServiceNow SecOps connectors.',
                })
              ),
              ruleName: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'The rule name for Swimlane connectors.',
                })
              ),
              severity: z.optional(
                z.int().register(z.globalRegistry, {
                  description:
                    'The severity of the incident for ServiceNow ITSM, Swimlane, and TheHive connectors. In TheHive connectors, the severity value ranges from 1 (low) to 4 (critical) with a default value of 2 (medium).\n',
                })
              ),
              short_description: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'A short description of the incident for ServiceNow ITSM and ServiceNow SecOps connectors. It is used for searching the contents of the knowledge base.\n',
                })
              ),
              source_ip: z.optional(z.union([z.string(), z.array(z.string())])),
              status: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The status of the incident for Webhook - Case Management connectors.',
                })
              ),
              subcategory: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The subcategory of the incident for ServiceNow ITSM and ServiceNow SecOps connectors.',
                })
              ),
              summary: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'A summary of the incident for Jira connectors.',
                })
              ),
              tags: z.optional(
                z.array(z.string()).register(z.globalRegistry, {
                  description:
                    'A list of tags for TheHive and Webhook - Case Management connectors.',
                })
              ),
              title: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'A title for the incident for Jira, TheHive, and Webhook - Case Management connectors. It is used for searching the contents of the knowledge base.\n',
                })
              ),
              tlp: z
                .optional(
                  z.int().gte(0).lte(4).register(z.globalRegistry, {
                    description:
                      'The traffic light protocol designation for the incident in TheHive connectors. Valid values include: 0 (clear), 1 (green), 2 (amber), 3 (amber and strict), and 4 (red).\n',
                  })
                )
                .default(2),
              urgency: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'The urgency of the incident for ServiceNow ITSM connectors.',
                })
              ),
            })
            .register(z.globalRegistry, {
              description:
                'Information necessary to create or update a Jira, ServiceNow ITSM, ServiveNow SecOps, Swimlane, or TheHive incident.',
            })
        ),
      })
      .register(z.globalRegistry, {
        description: 'The set of configuration properties for the action.',
      }),
  })
  .register(z.globalRegistry, {
    description:
      'The `pushToService` subaction for Jira, ServiceNow ITSM, ServiceNow SecOps, Swimlane, TheHive, and Webhook - Case Management connectors.',
  });

/**
 * The validChannelId subaction
 *
 * Retrieves information about a valid Slack channel identifier. It is applicable only when the connector type is `.slack_api`.
 *
 */
export const run_validchannelid = z
  .object({
    subAction: z.enum(['validChannelId']).register(z.globalRegistry, {
      description: 'The action to test.',
    }),
    subActionParams: z.object({
      channelId: z.string().register(z.globalRegistry, {
        description: 'The Slack channel identifier.',
      }),
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Retrieves information about a valid Slack channel identifier. It is applicable only when the connector type is `.slack_api`.\n',
  });

/**
 * APM anomaly
 *
 * The parameters for the APM anomaly rule. These parameters are appropriate when `rule_type_id` is `apm.rules.anomaly`.
 *
 */
export const params_property_apm_anomaly = z
  .object({
    serviceName: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Filter the rule to apply to a specific service name.',
      })
    ),
    transactionType: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Filter the rule to apply to a specific transaction type.',
      })
    ),
    windowSize: z.number().register(z.globalRegistry, {
      description:
        'The size of the time window (in `windowUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.\n',
    }),
    windowUnit: z.enum(['m', 'h', 'd']).register(z.globalRegistry, {
      description: 'The type of units for the time window. For example: minutes, hours, or days.\n',
    }),
    environment: z.string().register(z.globalRegistry, {
      description: 'Filter the rule to apply to a specific environment.',
    }),
    anomalySeverityType: z
      .enum(['critical', 'major', 'minor', 'warning'])
      .register(z.globalRegistry, {
        description:
          'The severity of anomalies that will generate alerts: critical, major, minor, or warning.\n',
      }),
  })
  .register(z.globalRegistry, {
    description:
      'The parameters for the APM anomaly rule. These parameters are appropriate when `rule_type_id` is `apm.rules.anomaly`.\n',
  });

/**
 * APM error count
 *
 * The parameters for the APM error count rule. These parameters are appropriate when `rule_type_id` is `apm.error_rate`.
 *
 */
export const params_property_apm_error_count = z
  .object({
    serviceName: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Filter the errors coming from your application to apply the rule to a specific service.',
      })
    ),
    windowSize: z.number().register(z.globalRegistry, {
      description:
        'The time frame in which the errors must occur (in `windowUnit` units). Generally it should be a value higher than the rule check interval to avoid gaps in detection.\n',
    }),
    windowUnit: z.enum(['m', 'h', 'd']).register(z.globalRegistry, {
      description: 'The type of units for the time window: minutes, hours, or days.\n',
    }),
    environment: z.string().register(z.globalRegistry, {
      description:
        'Filter the errors coming from your application to apply the rule to a specific environment.',
    }),
    threshold: z.number().register(z.globalRegistry, {
      description: 'The error count threshold.',
    }),
    groupBy: z
      .optional(
        z
          .array(
            z.enum([
              'service.name',
              'service.environment',
              'transaction.name',
              'error.grouping_key',
            ])
          )
          .register(z.globalRegistry, {
            description:
              'Perform a composite aggregation against the selected fields. When any of these groups match the selected rule conditions, an alert is triggered per group.\n',
          })
      )
      .default(['service.name', 'service.environment']),
    errorGroupingKey: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Filter the errors coming from your application to apply the rule to a specific error grouping key, which is a hash of the stack trace and other properties.\n',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'The parameters for the APM error count rule. These parameters are appropriate when `rule_type_id` is `apm.error_rate`.\n',
  });

/**
 * APM transaction duration
 *
 * The parameters for the APM transaction duration rule. These parameters are appropriate when `rule_type_id` is `apm.transaction_duration`.
 *
 */
export const params_property_apm_transaction_duration = z
  .object({
    serviceName: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Filter the rule to apply to a specific service.',
      })
    ),
    transactionType: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Filter the rule to apply to a specific transaction type.',
      })
    ),
    transactionName: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Filter the rule to apply to a specific transaction name.',
      })
    ),
    windowSize: z.number().register(z.globalRegistry, {
      description:
        'The size of the time window (in `windowUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.\n',
    }),
    windowUnit: z.enum(['m', 'h', 'd']).register(z.globalRegistry, {
      description: 'The type of units for the time window. For example: minutes, hours, or days.\n',
    }),
    environment: z.string().register(z.globalRegistry, {
      description: 'Filter the rule to apply to a specific environment.',
    }),
    threshold: z.number().register(z.globalRegistry, {
      description: 'The latency threshold value.',
    }),
    groupBy: z
      .optional(
        z
          .array(
            z.enum(['service.name', 'service.environment', 'transaction.type', 'transaction.name'])
          )
          .register(z.globalRegistry, {
            description:
              'Perform a composite aggregation against the selected fields. When any of these groups match the selected rule conditions, an alert is triggered per group.\n',
          })
      )
      .default(['service.name', 'service.environment', 'transaction.type']),
    aggregationType: z.enum(['avg', '95th', '99th']).register(z.globalRegistry, {
      description: 'The type of aggregation to perform.',
    }),
  })
  .register(z.globalRegistry, {
    description:
      'The parameters for the APM transaction duration rule. These parameters are appropriate when `rule_type_id` is `apm.transaction_duration`.\n',
  });

/**
 * APM transaction error rate
 *
 * The parameters for the APM transaction error rate rule. These parameters are appropriate when `rule_type_id` is `apm.transaction_error_rate`.
 *
 */
export const params_property_apm_transaction_error_rate = z
  .object({
    serviceName: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The service name from APM',
      })
    ),
    transactionType: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The transaction type from APM',
      })
    ),
    transactionName: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The transaction name from APM',
      })
    ),
    windowSize: z.number().register(z.globalRegistry, {
      description: 'The window size',
    }),
    windowUnit: z.enum(['m', 'h', 'd']).register(z.globalRegistry, {
      description: 'The window size unit',
    }),
    environment: z.string().register(z.globalRegistry, {
      description: 'The environment from APM',
    }),
    threshold: z.number().register(z.globalRegistry, {
      description: 'The error rate threshold value',
    }),
    groupBy: z
      .optional(
        z.array(
          z.enum(['service.name', 'service.environment', 'transaction.type', 'transaction.name'])
        )
      )
      .default(['service.name', 'service.environment', 'transaction.type']),
  })
  .register(z.globalRegistry, {
    description:
      'The parameters for the APM transaction error rate rule. These parameters are appropriate when `rule_type_id` is `apm.transaction_error_rate`.\n',
  });

/**
 * The name of the numeric field that is used in the aggregation. This property is required when `aggType` is `avg`, `max`, `min` or `sum`.
 *
 */
export const aggfield = z.string().register(z.globalRegistry, {
  description:
    'The name of the numeric field that is used in the aggregation. This property is required when `aggType` is `avg`, `max`, `min` or `sum`.\n',
});

/**
 * The type of aggregation to perform.
 */
export const aggtype = z.enum(['avg', 'count', 'max', 'min', 'sum']).register(z.globalRegistry, {
  description: 'The type of aggregation to perform.',
});

/**
 * Indicates whether to exclude matches from previous runs. If `true`, you can avoid alert duplication by excluding documents that have already been detected by the previous rule run. This option is not available when a grouping field is specified.
 *
 */
export const excludehitsfrompreviousrun = z.boolean().register(z.globalRegistry, {
  description:
    'Indicates whether to exclude matches from previous runs. If `true`, you can avoid alert duplication by excluding documents that have already been detected by the previous rule run. This option is not available when a grouping field is specified.\n',
});

/**
 * Indicates whether the aggregation is applied over all documents (`all`) or split into groups (`top`) using a grouping field (`termField`). If grouping is used, an alert will be created for each group when it exceeds the threshold; only the top groups (up to `termSize` number of groups) are checked.
 *
 */
export const groupby = z.enum(['all', 'top']).register(z.globalRegistry, {
  description:
    'Indicates whether the aggregation is applied over all documents (`all`) or split into groups (`top`) using a grouping field (`termField`). If grouping is used, an alert will be created for each group when it exceeds the threshold; only the top groups (up to `termSize` number of groups) are checked.\n',
});

/**
 * The number of documents to pass to the configured actions when the threshold condition is met.
 *
 */
export const size = z.int().register(z.globalRegistry, {
  description:
    'The number of documents to pass to the configured actions when the threshold condition is met.\n',
});

/**
 * The names of up to four fields that are used for grouping the aggregation. This property is required when `groupBy` is `top`.
 *
 */
export const termfield = z.union([z.string(), z.array(z.string()).max(4)]);

/**
 * This property is required when `groupBy` is `top`. It specifies the number of groups to check against the threshold and therefore limits the number of alerts on high cardinality fields.
 *
 */
export const termsize = z.int().register(z.globalRegistry, {
  description:
    'This property is required when `groupBy` is `top`. It specifies the number of groups to check against the threshold and therefore limits the number of alerts on high cardinality fields.\n',
});

/**
 * The threshold value that is used with the `thresholdComparator`. If the `thresholdComparator` is `between` or `notBetween`, you must specify the boundary values.
 *
 */
export const threshold = z.array(z.int()).register(z.globalRegistry, {
  description:
    'The threshold value that is used with the `thresholdComparator`. If the `thresholdComparator` is `between` or `notBetween`, you must specify the boundary values.\n',
});

/**
 * The comparison function for the threshold. For example, "is above", "is above or equals", "is below", "is below or equals", "is between", and "is not between".
 */
export const thresholdcomparator = z
  .enum(['>', '>=', '<', '<=', 'between', 'notBetween'])
  .register(z.globalRegistry, {
    description:
      'The comparison function for the threshold. For example, "is above", "is above or equals", "is below", "is below or equals", "is between", and "is not between".',
  });

/**
 * The field that is used to calculate the time window.
 */
export const timefield = z.string().register(z.globalRegistry, {
  description: 'The field that is used to calculate the time window.',
});

/**
 * The size of the time window (in `timeWindowUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.
 *
 */
export const timewindowsize = z.int().register(z.globalRegistry, {
  description:
    'The size of the time window (in `timeWindowUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.\n',
});

/**
 * The type of units for the time window: seconds, minutes, hours, or days.
 *
 */
export const timewindowunit = z.enum(['s', 'm', 'h', 'd']).register(z.globalRegistry, {
  description: 'The type of units for the time window: seconds, minutes, hours, or days.\n',
});

/**
 * Elasticsearch DSL query rule params
 *
 * An Elasticsearch query rule can run a query defined in Elasticsearch Query DSL and compare the number of matches to a configured threshold. These parameters are appropriate when `rule_type_id` is `.es-query`.
 *
 */
export const params_es_query_dsl_rule = z
  .object({
    aggField: z.optional(aggfield),
    aggType: z.optional(aggtype),
    esQuery: z.string().register(z.globalRegistry, {
      description: 'The query definition, which uses Elasticsearch Query DSL.',
    }),
    excludeHitsFromPreviousRun: z.optional(excludehitsfrompreviousrun),
    groupBy: z.optional(groupby),
    index: z.union([z.array(z.string()), z.string()]),
    searchType: z.optional(
      z.enum(['esQuery']).register(z.globalRegistry, {
        description: 'The type of query, in this case a query that uses Elasticsearch Query DSL.',
      })
    ),
    size: z.optional(size),
    termField: z.optional(termfield),
    termSize: z.optional(termsize),
    threshold,
    thresholdComparator: thresholdcomparator,
    timeField: timefield,
    timeWindowSize: timewindowsize,
    timeWindowUnit: timewindowunit,
  })
  .register(z.globalRegistry, {
    description:
      'An Elasticsearch query rule can run a query defined in Elasticsearch Query DSL and compare the number of matches to a configured threshold. These parameters are appropriate when `rule_type_id` is `.es-query`.\n',
  });

/**
 * Elasticsearch ES|QL query rule params
 *
 * An Elasticsearch query rule can run an ES|QL query and compare the number of matches to a configured threshold. These parameters are appropriate when `rule_type_id` is `.es-query`.
 *
 */
export const params_es_query_esql_rule = z
  .object({
    aggField: z.optional(aggfield),
    aggType: z.optional(aggtype),
    esqlQuery: z.object({
      esql: z.string().register(z.globalRegistry, {
        description: 'The query definition, which uses Elasticsearch Query Language.',
      }),
    }),
    excludeHitsFromPreviousRun: z.optional(excludehitsfrompreviousrun),
    groupBy: z.optional(groupby),
    searchType: z.enum(['esqlQuery']).register(z.globalRegistry, {
      description:
        'The type of query, in this case a query that uses Elasticsearch Query Language (ES|QL).',
    }),
    size: z.int().register(z.globalRegistry, {
      description:
        'When `searchType` is `esqlQuery`, this property is required but it does not affect the rule behavior.\n',
    }),
    termSize: z.optional(termsize),
    threshold: z.array(z.int().gte(0).lte(0)).register(z.globalRegistry, {
      description:
        'The threshold value that is used with the `thresholdComparator`. When `searchType` is `esqlQuery`, this property is required and must be set to zero.\n',
    }),
    thresholdComparator: z.enum(['>']).register(z.globalRegistry, {
      description:
        'The comparison function for the threshold. When `searchType` is `esqlQuery`, this property is required and must be set to ">". Since the `threshold` value must be `0`, the result is that an alert occurs whenever the query returns results.\n',
    }),
    timeField: z.optional(timefield),
    timeWindowSize: timewindowsize,
    timeWindowUnit: timewindowunit,
  })
  .register(z.globalRegistry, {
    description:
      'An Elasticsearch query rule can run an ES|QL query and compare the number of matches to a configured threshold. These parameters are appropriate when `rule_type_id` is `.es-query`.\n',
  });

/**
 * A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.
 */
export const filter = z
  .object({
    meta: z.optional(
      z.object({
        alias: z.optional(z.union([z.string(), z.null()])),
        controlledBy: z.optional(z.string()),
        disabled: z.optional(z.boolean()),
        field: z.optional(z.string()),
        group: z.optional(z.string()),
        index: z.optional(z.string()),
        isMultiIndex: z.optional(z.boolean()),
        key: z.optional(z.string()),
        negate: z.optional(z.boolean()),
        params: z.optional(z.record(z.string(), z.unknown())),
        type: z.optional(z.string()),
        value: z.optional(z.string()),
      })
    ),
    query: z.optional(z.record(z.string(), z.unknown())),
    $state: z.optional(z.record(z.string(), z.unknown())),
  })
  .register(z.globalRegistry, {
    description:
      'A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.',
  });

/**
 * Elasticsearch KQL query rule params
 *
 * An Elasticsearch query rule can run a query defined in KQL or Lucene and compare the number of matches to a configured threshold. These parameters are appropriate when `rule_type_id` is `.es-query`.
 *
 */
export const params_es_query_kql_rule = z
  .object({
    aggField: z.optional(aggfield),
    aggType: z.optional(aggtype),
    excludeHitsFromPreviousRun: z.optional(excludehitsfrompreviousrun),
    groupBy: z.optional(groupby),
    searchConfiguration: z.optional(
      z
        .object({
          filter: z.optional(z.array(filter)),
          index: z.optional(z.union([z.string(), z.array(z.string())])),
          query: z.optional(
            z.object({
              language: z.optional(z.string()),
              query: z.optional(z.string()),
            })
          ),
        })
        .register(z.globalRegistry, {
          description:
            'The query definition, which uses KQL or Lucene to fetch the documents from Elasticsearch.',
        })
    ),
    searchType: z.enum(['searchSource']).register(z.globalRegistry, {
      description: 'The type of query, in this case a text-based query that uses KQL or Lucene.',
    }),
    size,
    termField: z.optional(termfield),
    termSize: z.optional(termsize),
    threshold,
    thresholdComparator: thresholdcomparator,
    timeField: z.optional(timefield),
    timeWindowSize: timewindowsize,
    timeWindowUnit: timewindowunit,
  })
  .register(z.globalRegistry, {
    description:
      'An Elasticsearch query rule can run a query defined in KQL or Lucene and compare the number of matches to a configured threshold. These parameters are appropriate when `rule_type_id` is `.es-query`.\n',
  });

/**
 * Index threshold rule params
 *
 * An index threshold rule runs an Elasticsearch query, aggregates field values from documents, compares them to threshold values, and schedules actions to run when the thresholds are met. These parameters are appropriate when `rule_type_id` is `.index-threshold`.
 */
export const params_index_threshold_rule = z
  .object({
    aggField: z.optional(aggfield),
    aggType: z.optional(aggtype),
    filterKuery: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'A KQL expression thats limits the scope of alerts.',
      })
    ),
    groupBy: z.optional(groupby),
    index: z.array(z.string()).register(z.globalRegistry, {
      description: 'The indices to query.',
    }),
    termField: z.optional(termfield),
    termSize: z.optional(termsize),
    threshold,
    thresholdComparator: thresholdcomparator,
    timeField: timefield,
    timeWindowSize: timewindowsize,
    timeWindowUnit: timewindowunit,
  })
  .register(z.globalRegistry, {
    description:
      'An index threshold rule runs an Elasticsearch query, aggregates field values from documents, compares them to threshold values, and schedules actions to run when the thresholds are met. These parameters are appropriate when `rule_type_id` is `.index-threshold`.',
  });

/**
 * Inventory
 *
 * The parameters for the infrastructure inventory rule. These parameters are appropriate when `rule_type_id` is `metrics.alert.inventory.threshold`.
 *
 */
export const params_property_infra_inventory = z
  .object({
    criteria: z.optional(
      z.array(
        z.object({
          metric: z.optional(
            z.enum([
              'count',
              'cpu',
              'diskLatency',
              'load',
              'memory',
              'memoryTotal',
              'tx',
              'rx',
              'logRate',
              'diskIOReadBytes',
              'diskIOWriteBytes',
              's3TotalRequests',
              's3NumberOfObjects',
              's3BucketSize',
              's3DownloadBytes',
              's3UploadBytes',
              'rdsConnections',
              'rdsQueriesExecuted',
              'rdsActiveTransactions',
              'rdsLatency',
              'sqsMessagesVisible',
              'sqsMessagesDelayed',
              'sqsMessagesSent',
              'sqsMessagesEmpty',
              'sqsOldestMessage',
              'custom',
            ])
          ),
          timeSize: z.optional(z.number()),
          timeUnit: z.optional(z.enum(['s', 'm', 'h', 'd'])),
          sourceId: z.optional(z.string()),
          threshold: z.optional(z.array(z.number())),
          comparator: z.optional(z.enum(['<', '<=', '>', '>=', 'between', 'outside'])),
          customMetric: z.optional(
            z.object({
              type: z.optional(z.enum(['custom'])),
              field: z.optional(z.string()),
              aggregation: z.optional(z.enum(['avg', 'max', 'min', 'rate'])),
              id: z.optional(z.string()),
              label: z.optional(z.string()),
            })
          ),
          warningThreshold: z.optional(z.array(z.number())),
          warningComparator: z.optional(z.enum(['<', '<=', '>', '>=', 'between', 'outside'])),
        })
      )
    ),
    filterQuery: z.optional(z.string()),
    filterQueryText: z.optional(z.string()),
    nodeType: z.optional(
      z.enum(['host', 'pod', 'container', 'awsEC2', 'awsS3', 'awsSQS', 'awsRDS'])
    ),
    sourceId: z.optional(z.string()),
    alertOnNoData: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description:
      'The parameters for the infrastructure inventory rule. These parameters are appropriate when `rule_type_id` is `metrics.alert.inventory.threshold`.\n',
  });

export const params_property_log_threshold = z.union([
  z
    .object({
      criteria: z.optional(
        z.array(
          z.object({
            field: z.optional(z.string()),
            comparator: z.optional(
              z.enum([
                'more than',
                'more than or equals',
                'less than',
                'less than or equals',
                'equals',
                'does not equal',
                'matches',
                'does not match',
                'matches phrase',
                'does not match phrase',
              ])
            ),
            value: z.optional(z.union([z.number(), z.string()])),
          })
        )
      ),
      count: z.object({
        comparator: z.optional(
          z.enum([
            'more than',
            'more than or equals',
            'less than',
            'less than or equals',
            'equals',
            'does not equal',
            'matches',
            'does not match',
            'matches phrase',
            'does not match phrase',
          ])
        ),
        value: z.optional(z.number()),
      }),
      timeSize: z.number(),
      timeUnit: z.enum(['s', 'm', 'h', 'd']),
      logView: z.object({
        logViewId: z.optional(z.string()),
        type: z.optional(z.enum(['log-view-reference'])),
      }),
      groupBy: z.optional(z.array(z.string())),
    })
    .register(z.globalRegistry, {
      description:
        'The parameters for a log threshold rule that counts the number of log entries that match the criteria. These parameters are appropriate when `rule_type_id` is `logs.alert.document.count`.\n',
    }),
  z
    .object({
      criteria: z.optional(
        z.array(
          z.tuple([
            z.object({
              field: z.optional(z.string()),
              comparator: z.optional(
                z.enum([
                  'more than',
                  'more than or equals',
                  'less than',
                  'less than or equals',
                  'equals',
                  'does not equal',
                  'matches',
                  'does not match',
                  'matches phrase',
                  'does not match phrase',
                ])
              ),
              value: z.optional(z.union([z.number(), z.string()])),
            }),
            z.object({
              field: z.optional(z.string()),
              comparator: z.optional(
                z.enum([
                  'more than',
                  'more than or equals',
                  'less than',
                  'less than or equals',
                  'equals',
                  'does not equal',
                  'matches',
                  'does not match',
                  'matches phrase',
                  'does not match phrase',
                ])
              ),
              value: z.optional(z.union([z.number(), z.string()])),
            }),
          ])
        )
      ),
      count: z.object({
        comparator: z.optional(
          z.enum([
            'more than',
            'more than or equals',
            'less than',
            'less than or equals',
            'equals',
            'does not equal',
            'matches',
            'does not match',
            'matches phrase',
            'does not match phrase',
          ])
        ),
        value: z.optional(z.number()),
      }),
      timeSize: z.number(),
      timeUnit: z.enum(['s', 'm', 'h', 'd']),
      logView: z.object({
        logViewId: z.optional(z.string()),
        type: z.optional(z.enum(['log-view-reference'])),
      }),
      groupBy: z.optional(z.array(z.string())),
    })
    .register(z.globalRegistry, {
      description:
        'The parameters for a log threshold rule that calculates the ratio of log entries that match the criteria. These parameters are appropriate when `rule_type_id` is `logs.alert.document.count`.\n',
    }),
]);

/**
 * Metric threshold
 *
 * The parameters for the metric threshold rule. These parameters are appropriate when `rule_type_id` is `metrics.alert.threshold`.
 *
 */
export const params_property_infra_metric_threshold = z
  .object({
    criteria: z.optional(
      z.array(
        z.union([
          z.object({
            threshold: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description:
                  'The threshold value that is used with the `comparator`. If the `comparator` is `between`, you must specify the boundary values.\n',
              })
            ),
            comparator: z.optional(
              z.enum(['<', '<=', '>', '>=', 'between', 'outside']).register(z.globalRegistry, {
                description:
                  'The comparison function for the threshold. For example, "is above", "is above or equals", "is below", "is below or equals", "is between", and "outside".\n',
              })
            ),
            timeUnit: z.optional(
              z.enum(['s', 'm', 'h', 'd']).register(z.globalRegistry, {
                description:
                  'The type of units for the time window: seconds, minutes, hours, or days.\n',
              })
            ),
            timeSize: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'The size of the time window (in `timeUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.\n',
              })
            ),
            warningThreshold: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description:
                  'The threshold value that is used with the `warningComparator`. If the `warningComparator` is `between`, you must specify the boundary values.\n',
              })
            ),
            warningComparator: z.optional(z.enum(['<', '<=', '>', '>=', 'between', 'outside'])),
            metric: z.optional(z.string()),
            aggType: z.optional(
              z.enum([
                'avg',
                'max',
                'min',
                'cardinality',
                'rate',
                'count',
                'sum',
                'p95',
                'p99',
                'custom',
              ])
            ),
          }),
          z.object({
            threshold: z.optional(z.array(z.number())),
            comparator: z.optional(z.enum(['<', '<=', '>', '>=', 'between', 'outside'])),
            timeUnit: z.optional(
              z.enum(['s', 'm', 'h', 'd']).register(z.globalRegistry, {
                description:
                  'The type of units for the time window: seconds, minutes, hours, or days.\n',
              })
            ),
            timeSize: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'The size of the time window (in `timeUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.\n',
              })
            ),
            warningThreshold: z.optional(z.array(z.number())),
            warningComparator: z.optional(z.enum(['<', '<=', '>', '>=', 'between', 'outside'])),
            aggType: z.optional(z.enum(['count'])),
          }),
          z.object({
            threshold: z.optional(z.array(z.number())),
            comparator: z.optional(z.enum(['<', '<=', '>', '>=', 'between', 'outside'])),
            timeUnit: z.optional(
              z.enum(['s', 'm', 'h', 'd']).register(z.globalRegistry, {
                description:
                  'The type of units for the time window: seconds, minutes, hours, or days.\n',
              })
            ),
            timeSize: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'The size of the time window (in `timeUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.\n',
              })
            ),
            warningThreshold: z.optional(z.array(z.number())),
            warningComparator: z.optional(z.enum(['<', '<=', '>', '>=', 'between', 'outside'])),
            aggType: z.optional(z.enum(['custom'])),
            customMetric: z.optional(
              z.array(
                z.union([
                  z.object({
                    name: z.optional(z.string()),
                    aggType: z.optional(
                      z
                        .enum(['avg', 'sum', 'max', 'min', 'cardinality'])
                        .register(z.globalRegistry, {
                          description:
                            'An aggregation to gather data for the rule. For example, find the average, highest or lowest value of a numeric field. Or use a cardinality aggregation to find the approximate number of unique values in a field. \n',
                        })
                    ),
                    field: z.optional(z.string()),
                  }),
                  z.object({
                    name: z.optional(z.string()),
                    aggType: z.optional(z.enum(['count'])),
                    filter: z.optional(z.string()),
                  }),
                ])
              )
            ),
            equation: z.optional(z.string()),
            label: z.optional(z.string()),
          }),
        ])
      )
    ),
    groupBy: z.optional(z.union([z.string(), z.array(z.string())])),
    filterQuery: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A query that limits the scope of the rule. The rule evaluates only metric data that matches the query.\n',
      })
    ),
    sourceId: z.optional(z.string()),
    alertOnNoData: z.optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, an alert occurs if the metrics do not report any data over the expected period or if the query fails.',
      })
    ),
    alertOnGroupDisappear: z.optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, an alert occurs if a group that previously reported metrics does not report them again over the expected time period. This check is not recommended for dynamically scaling infrastructures that might rapidly start and stop nodes automatically.\n',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'The parameters for the metric threshold rule. These parameters are appropriate when `rule_type_id` is `metrics.alert.threshold`.\n',
  });

/**
 * SLO burn rate
 *
 * The parameters for the SLO burn rate rule. These parameters are appropriate when `rule_type_id` is `slo.rules.burnRate`.
 *
 */
export const params_property_slo_burn_rate = z
  .object({
    sloId: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The SLO identifier used by the rule',
      })
    ),
    burnRateThreshold: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'The burn rate threshold used to trigger the alert',
      })
    ),
    maxBurnRateThreshold: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'The maximum burn rate threshold value defined by the SLO error budget',
      })
    ),
    longWindow: z.optional(
      z
        .object({
          value: z.optional(
            z.number().register(z.globalRegistry, {
              description: 'The duration value',
            })
          ),
          unit: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The duration unit',
            })
          ),
        })
        .register(z.globalRegistry, {
          description: 'The duration of the long window used to compute the burn rate',
        })
    ),
    shortWindow: z.optional(
      z
        .object({
          value: z.optional(
            z.number().register(z.globalRegistry, {
              description: 'The duration value',
            })
          ),
          unit: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The duration unit',
            })
          ),
        })
        .register(z.globalRegistry, {
          description: 'The duration of the short window used to compute the burn rate',
        })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'The parameters for the SLO burn rate rule. These parameters are appropriate when `rule_type_id` is `slo.rules.burnRate`.\n',
  });

/**
 * Synthetics TLS certificate
 *
 * The parameters for the synthetics TLS certificate rule. These parameters are appropriate when `rule_type_id` is `xpack.uptime.alerts.tls`.
 *
 */
export const params_property_synthetics_uptime_tls = z
  .object({
    search: z.optional(z.string()),
    certExpirationThreshold: z.optional(z.number()),
    certAgeThreshold: z.optional(z.number()),
  })
  .register(z.globalRegistry, {
    description:
      'The parameters for the synthetics TLS certificate rule. These parameters are appropriate when `rule_type_id` is `xpack.uptime.alerts.tls`.\n',
  });

/**
 * Synthetics monitor status
 *
 * The parameters for the Synthetics monitor status rule. These parameters are appropriate when `rule_type_id` is `xpack.uptime.alerts.monitorStatus`.
 *
 */
export const params_property_synthetics_monitor_status = z
  .object({
    availability: z.optional(
      z.object({
        range: z.optional(z.number()),
        rangeUnit: z.optional(z.string()),
        threshold: z.optional(z.string()),
      })
    ),
    filters: z.optional(
      z.union([
        z.string(),
        z.object({
          'monitor.type': z.optional(z.array(z.string())),
          'observer.geo.name': z.optional(z.array(z.string())),
          tags: z.optional(z.array(z.string())),
          'url.port': z.optional(z.array(z.string())),
        }),
      ])
    ),
    locations: z.optional(z.array(z.string())),
    numTimes: z.number(),
    search: z.optional(z.string()),
    shouldCheckStatus: z.boolean(),
    shouldCheckAvailability: z.boolean(),
    timerangeCount: z.optional(z.number()),
    timerangeUnit: z.optional(z.string()),
    timerange: z.optional(
      z.object({
        from: z.optional(z.string()),
        to: z.optional(z.string()),
      })
    ),
    version: z.optional(z.number()),
    isAutoGenerated: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description:
      'The parameters for the Synthetics monitor status rule. These parameters are appropriate when `rule_type_id` is `xpack.uptime.alerts.monitorStatus`.\n',
  });

/**
 * The version of the API to use
 */
export const apm_ui_elastic_api_version = z.enum(['2023-10-31']).register(z.globalRegistry, {
  description: 'The version of the API to use',
});

/**
 * A required header to protect against CSRF attacks
 */
export const apm_ui_kbn_xsrf = z.string().register(z.globalRegistry, {
  description: 'A required header to protect against CSRF attacks',
});

/**
 * An identifier for the alert.
 */
export const cases_alert_id = z.string().register(z.globalRegistry, {
  description: 'An identifier for the alert.',
});

/**
 * Filters the returned cases by assignees. Valid values are `none` or unique identifiers for the user profiles. These identifiers can be found by using the suggest user profile API.
 *
 */
export const cases_assignees_filter = z.union([cases_string, cases_string_array]);

/**
 * The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.
 */
export const cases_case_id = z.string().register(z.globalRegistry, {
  description:
    'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
});

/**
 * Filters the returned cases by category.
 */
export const cases_category = z.union([cases_case_category, cases_case_categories]);

/**
 * The identifier for the comment. To retrieve comment IDs, use the get case or find cases APIs.
 *
 */
export const cases_comment_id = z.string().register(z.globalRegistry, {
  description:
    'The identifier for the comment. To retrieve comment IDs, use the get case or find cases APIs.\n',
});

/**
 * An identifier for the configuration.
 */
export const cases_configuration_id = z.string().register(z.globalRegistry, {
  description: 'An identifier for the configuration.',
});

/**
 * An identifier for the connector. To retrieve connector IDs, use the find connectors API.
 */
export const cases_connector_id = z.string().register(z.globalRegistry, {
  description:
    'An identifier for the connector. To retrieve connector IDs, use the find connectors API.',
});

/**
 * he default operator to use for the simple_query_string.
 */
export const cases_default_search_operator = z
  .string()
  .register(z.globalRegistry, {
    description: 'he default operator to use for the simple_query_string.',
  })
  .default('OR');

/**
 * Returns only cases that were created after a specific date. The date must be specified as a KQL data range or date match expression.
 *
 */
export const cases_from = z.string().register(z.globalRegistry, {
  description:
    'Returns only cases that were created after a specific date. The date must be specified as a KQL data range or date match expression.\n',
});

/**
 * The cases that you want to removed. All non-ASCII characters must be URL encoded.
 *
 */
export const cases_ids = z.array(z.string()).register(z.globalRegistry, {
  description:
    'The cases that you want to removed. All non-ASCII characters must be URL encoded.\n',
});

/**
 * Cross-site request forgery protection
 */
export const cases_kbn_xsrf = z.string().register(z.globalRegistry, {
  description: 'Cross-site request forgery protection',
});

/**
 * A filter to limit the response to a specific set of applications. If this parameter is omitted, the response contains information about all the cases that the user has access to read.
 *
 */
export const cases_owner_filter = z.union([cases_owner, cases_owners]);

/**
 * The page number to return.
 */
export const cases_page_index = z
  .int()
  .register(z.globalRegistry, {
    description: 'The page number to return.',
  })
  .default(1);

/**
 * The number of items to return. Limited to 100 items.
 */
export const cases_page_size = z
  .int()
  .lte(100)
  .register(z.globalRegistry, {
    description: 'The number of items to return. Limited to 100 items.',
  })
  .default(20);

/**
 * Filters the returned cases by the user name of the reporter.
 */
export const cases_reporters = z.union([cases_string, cases_string_array]);

/**
 * An Elasticsearch simple_query_string query that filters the objects in the response.
 */
export const cases_search = z.string().register(z.globalRegistry, {
  description:
    'An Elasticsearch simple_query_string query that filters the objects in the response.',
});

/**
 * The fields to perform the simple_query_string parsed query against.
 */
export const cases_search_fields = z.union([
  cases_search_fields_type,
  cases_search_fields_type_array,
]);

/**
 * The severity of the case.
 */
export const cases_severity = z
  .enum(['critical', 'high', 'low', 'medium'])
  .register(z.globalRegistry, {
    description: 'The severity of the case.',
  });

/**
 * Determines the sort order.
 */
export const cases_sort_order = z.enum(['asc', 'desc']).register(z.globalRegistry, {
  description: 'Determines the sort order.',
});

/**
 * Determines which field is used to sort the results.
 */
export const cases_sort_field = z
  .enum(['createdAt', 'updatedAt', 'closedAt', 'title', 'category', 'status', 'severity'])
  .register(z.globalRegistry, {
    description: 'Determines which field is used to sort the results.',
  });

/**
 * Filters the returned cases by state.
 */
export const cases_status = z.enum(['closed', 'in-progress', 'open']).register(z.globalRegistry, {
  description: 'Filters the returned cases by state.',
});

/**
 * Filters the returned cases by tags.
 */
export const cases_tags = z.union([cases_string, cases_string_array]);

/**
 * Returns only cases that were created before a specific date. The date must be specified as a KQL data range or date match expression.
 *
 */
export const cases_to = z.string().register(z.globalRegistry, {
  description:
    'Returns only cases that were created before a specific date. The date must be specified as a KQL data range or date match expression.\n',
});

/**
 * Determines the types of user actions to return.
 */
export const cases_user_action_types = z
  .array(
    z.enum([
      'action',
      'alert',
      'assignees',
      'attachment',
      'comment',
      'connector',
      'create_case',
      'description',
      'pushed',
      'settings',
      'severity',
      'status',
      'tags',
      'title',
      'user',
    ])
  )
  .register(z.globalRegistry, {
    description: 'Determines the types of user actions to return.',
  });

/**
 * The name of the runtime field.
 */
export const data_views_field_name = z.string().register(z.globalRegistry, {
  description: 'The name of the runtime field.',
});

/**
 * Cross-site request forgery protection
 */
export const data_views_kbn_xsrf = z.string().register(z.globalRegistry, {
  description: 'Cross-site request forgery protection',
});

/**
 * An identifier for the data view.
 */
export const data_views_view_id = z.string().register(z.globalRegistry, {
  description: 'An identifier for the data view.',
});

/**
 * When true, simulates the synchronization by returning only the list of actions that would be performed.
 */
export const machine_learning_ap_is_simulate_param = z.boolean().register(z.globalRegistry, {
  description:
    'When true, simulates the synchronization by returning only the list of actions that would be performed.',
});

/**
 * Cross-site request forgery protection
 */
export const saved_objects_kbn_xsrf = z.string().register(z.globalRegistry, {
  description: 'Cross-site request forgery protection',
});

/**
 * An identifier for the saved object.
 */
export const saved_objects_saved_object_id = z.string().register(z.globalRegistry, {
  description: 'An identifier for the saved object.',
});

/**
 * Valid options include `visualization`, `dashboard`, `search`, `index-pattern`, `config`.
 */
export const saved_objects_saved_object_type = z.string().register(z.globalRegistry, {
  description:
    'Valid options include `visualization`, `dashboard`, `search`, `index-pattern`, `config`.',
});

/**
 * The identifier for the short URL.
 */
export const short_url_ap_is_id_param = z.string().register(z.globalRegistry, {
  description: 'The identifier for the short URL.',
});

/**
 * Cross-site request forgery protection
 */
export const sl_os_kbn_xsrf = z.string().register(z.globalRegistry, {
  description: 'Cross-site request forgery protection',
});

/**
 * An identifier for the slo.
 */
export const sl_os_slo_id = z.string().register(z.globalRegistry, {
  description: 'An identifier for the slo.',
});

/**
 * An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
 */
export const sl_os_space_id = z.string().register(z.globalRegistry, {
  description:
    'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
});

export const get_actions_connector_types_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      feature_id: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A filter to limit the retrieved connector types to those that support a specific feature (such as alerting or cases).',
        })
      ),
    })
  ),
});

export const delete_actions_connector_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the connector.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const delete_actions_connector_id_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const get_actions_connector_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the connector.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_actions_connector_id_response = z
  .object({
    config: z.optional(z.record(z.string(), z.unknown())),
    connector_type_id: z.string().register(z.globalRegistry, {
      description: 'The connector type identifier.',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the connector.',
    }),
    is_deprecated: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the connector is deprecated.',
    }),
    is_missing_secrets: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the connector is missing secrets.',
      })
    ),
    is_preconfigured: z.boolean().register(z.globalRegistry, {
      description:
        'Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response. ',
    }),
    is_system_action: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the connector is used for system actions.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: ' The name of the rule.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const post_actions_connector_id_request = z.object({
  body: z.optional(
    z.object({
      connector_type_id: z.string().register(z.globalRegistry, {
        description: 'The type of connector.',
      }),
      name: z.string().register(z.globalRegistry, {
        description: 'The display name for the connector.',
      }),
      config: z.optional(
        z.union([
          bedrock_config,
          crowdstrike_config,
          d3security_config,
          email_config,
          gemini_config,
          resilient_config,
          index_config,
          jira_config,
          genai_azure_config,
          genai_openai_config,
          genai_openai_other_config,
          opsgenie_config,
          pagerduty_config,
          sentinelone_config,
          servicenow_config,
          servicenow_itom_config,
          slack_api_config,
          swimlane_config,
          thehive_config,
          tines_config,
          torq_config,
          webhook_config,
          cases_webhook_config,
          xmatters_config,
        ])
      ),
      secrets: z.optional(
        z.union([
          bedrock_secrets,
          crowdstrike_secrets,
          d3security_secrets,
          email_secrets,
          gemini_secrets,
          resilient_secrets,
          jira_secrets,
          defender_secrets,
          teams_secrets,
          genai_secrets,
          opsgenie_secrets,
          pagerduty_secrets,
          sentinelone_secrets,
          servicenow_secrets,
          slack_api_secrets,
          swimlane_secrets,
          thehive_secrets,
          tines_secrets,
          torq_secrets,
          webhook_secrets,
          cases_webhook_secrets,
          xmatters_secrets,
        ])
      ),
    })
  ),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the connector.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_actions_connector_id_response = z
  .object({
    config: z.optional(z.record(z.string(), z.unknown())),
    connector_type_id: z.string().register(z.globalRegistry, {
      description: 'The connector type identifier.',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the connector.',
    }),
    is_deprecated: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the connector is deprecated.',
    }),
    is_missing_secrets: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the connector is missing secrets.',
      })
    ),
    is_preconfigured: z.boolean().register(z.globalRegistry, {
      description:
        'Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response. ',
    }),
    is_system_action: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the connector is used for system actions.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: ' The name of the rule.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const put_actions_connector_id_request = z.object({
  body: z.optional(
    z.object({
      name: z.string().register(z.globalRegistry, {
        description: 'The display name for the connector.',
      }),
      config: z.optional(
        z.union([
          bedrock_config,
          crowdstrike_config,
          d3security_config,
          email_config,
          gemini_config,
          resilient_config,
          index_config,
          jira_config,
          defender_config,
          genai_azure_config,
          genai_openai_config,
          opsgenie_config,
          pagerduty_config,
          sentinelone_config,
          servicenow_config,
          servicenow_itom_config,
          slack_api_config,
          swimlane_config,
          thehive_config,
          tines_config,
          torq_config,
          webhook_config,
          cases_webhook_config,
          xmatters_config,
        ])
      ),
      secrets: z.optional(
        z.union([
          bedrock_secrets,
          crowdstrike_secrets,
          d3security_secrets,
          email_secrets,
          gemini_secrets,
          resilient_secrets,
          jira_secrets,
          teams_secrets,
          genai_secrets,
          opsgenie_secrets,
          pagerduty_secrets,
          sentinelone_secrets,
          servicenow_secrets,
          slack_api_secrets,
          swimlane_secrets,
          thehive_secrets,
          tines_secrets,
          torq_secrets,
          webhook_secrets,
          cases_webhook_secrets,
          xmatters_secrets,
        ])
      ),
    })
  ),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the connector.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const put_actions_connector_id_response = z
  .object({
    config: z.optional(z.record(z.string(), z.unknown())),
    connector_type_id: z.string().register(z.globalRegistry, {
      description: 'The connector type identifier.',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the connector.',
    }),
    is_deprecated: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the connector is deprecated.',
    }),
    is_missing_secrets: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the connector is missing secrets.',
      })
    ),
    is_preconfigured: z.boolean().register(z.globalRegistry, {
      description:
        'Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response. ',
    }),
    is_system_action: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the connector is used for system actions.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: ' The name of the rule.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const post_actions_connector_id_execute_request = z.object({
  body: z.optional(
    z.object({
      params: z.union([
        run_acknowledge_resolve_pagerduty,
        run_documents,
        run_message_email,
        run_message_serverlog,
        run_message_slack,
        run_trigger_pagerduty,
        run_addevent,
        run_closealert,
        run_closeincident,
        run_createalert,
        run_fieldsbyissuetype,
        run_getagentdetails,
        run_getagents,
        run_getchoices,
        run_getfields,
        run_getincident,
        run_issue,
        run_issues,
        run_issuetypes,
        run_postmessage,
        run_pushtoservice,
        run_validchannelid,
      ]),
    })
  ),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the connector.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_actions_connector_id_execute_response = z
  .object({
    config: z.optional(z.record(z.string(), z.unknown())),
    connector_type_id: z.string().register(z.globalRegistry, {
      description: 'The connector type identifier.',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the connector.',
    }),
    is_deprecated: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the connector is deprecated.',
    }),
    is_missing_secrets: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the connector is missing secrets.',
      })
    ),
    is_preconfigured: z.boolean().register(z.globalRegistry, {
      description:
        'Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response. ',
    }),
    is_system_action: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether the connector is used for system actions.',
    }),
    name: z.string().register(z.globalRegistry, {
      description: ' The name of the rule.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_actions_connectors_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const post_agent_builder_a2a_agentid_request = z.object({
  body: z.optional(z.unknown()),
  path: z.object({
    agentId: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the agent to send the A2A task to.',
    }),
  }),
  query: z.optional(z.never()),
});

export const get_agent_builder_a2a_agentid_json_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    agentId: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the agent to get A2A metadata for.',
    }),
  }),
  query: z.optional(z.never()),
});

export const get_agent_builder_agents_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const post_agent_builder_agents_request = z.object({
  body: z.optional(
    z.object({
      avatar_color: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Optional hex color code for the agent avatar.',
        })
      ),
      avatar_symbol: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Optional symbol/initials for the agent avatar.',
        })
      ),
      configuration: z
        .object({
          instructions: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Optional system instructions that define the agent behavior.',
            })
          ),
          tools: z.array(
            z
              .object({
                tool_ids: z
                  .array(
                    z.string().register(z.globalRegistry, {
                      description: 'Tool ID to be available to the agent.',
                    })
                  )
                  .register(z.globalRegistry, {
                    description: 'Array of tool IDs that the agent can use.',
                  }),
              })
              .register(z.globalRegistry, {
                description: 'Tool selection configuration for the agent.',
              })
          ),
        })
        .register(z.globalRegistry, {
          description: 'Configuration settings for the agent.',
        }),
      description: z.string().register(z.globalRegistry, {
        description: 'Description of what the agent does.',
      }),
      id: z.string().register(z.globalRegistry, {
        description: 'Unique identifier for the agent.',
      }),
      labels: z.optional(
        z
          .array(
            z.string().register(z.globalRegistry, {
              description: 'Label for categorizing the agent.',
            })
          )
          .register(z.globalRegistry, {
            description: 'Optional labels for categorizing and organizing agents.',
          })
      ),
      name: z.string().register(z.globalRegistry, {
        description: 'Display name for the agent.',
      }),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const delete_agent_builder_agents_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the agent to delete.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_agent_builder_agents_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the agent to retrieve.',
    }),
  }),
  query: z.optional(z.never()),
});

export const put_agent_builder_agents_id_request = z.object({
  body: z.optional(
    z.object({
      avatar_color: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Updated hex color code for the agent avatar.',
        })
      ),
      avatar_symbol: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Updated symbol/initials for the agent avatar.',
        })
      ),
      configuration: z.optional(
        z
          .object({
            instructions: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'Updated system instructions that define the agent behavior.',
              })
            ),
            tools: z.optional(
              z.array(
                z
                  .object({
                    tool_ids: z
                      .array(
                        z.string().register(z.globalRegistry, {
                          description: 'Tool ID to be available to the agent.',
                        })
                      )
                      .register(z.globalRegistry, {
                        description: 'Array of tool IDs that the agent can use.',
                      }),
                  })
                  .register(z.globalRegistry, {
                    description: 'Tool selection configuration for the agent.',
                  })
              )
            ),
          })
          .register(z.globalRegistry, {
            description: 'Updated configuration settings for the agent.',
          })
      ),
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Updated description of what the agent does.',
        })
      ),
      labels: z.optional(
        z
          .array(
            z.string().register(z.globalRegistry, {
              description: 'Updated label for categorizing the agent.',
            })
          )
          .register(z.globalRegistry, {
            description: 'Updated labels for categorizing and organizing agents.',
          })
      ),
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Updated display name for the agent.',
        })
      ),
    })
  ),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the agent to update.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_agent_builder_conversations_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      agent_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Optional agent ID to filter conversations by a specific agent.',
        })
      ),
    })
  ),
});

export const delete_agent_builder_conversations_conversation_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    conversation_id: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the conversation to delete.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_agent_builder_conversations_conversation_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    conversation_id: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the conversation to retrieve.',
    }),
  }),
  query: z.optional(z.never()),
});

export const post_agent_builder_converse_request = z.object({
  body: z.optional(
    z.object({
      agent_id: z
        .optional(
          z.string().register(z.globalRegistry, {
            description:
              'The ID of the agent to chat with. Defaults to the default Elastic AI agent.',
          })
        )
        .default('elastic-ai-agent'),
      attachments: z.optional(
        z
          .array(
            z.object({
              data: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
                description: 'Payload of the attachment.',
              }),
              hidden: z.optional(
                z.boolean().register(z.globalRegistry, {
                  description: 'When true, the attachment will not be displayed in the UI.',
                })
              ),
              id: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'Optional id for the attachment.',
                })
              ),
              type: z.string().register(z.globalRegistry, {
                description: 'Type of the attachment.',
              }),
            })
          )
          .register(z.globalRegistry, {
            description: 'Optional attachments to send with the message.',
          })
      ),
      browser_api_tools: z.optional(
        z
          .array(
            z.object({
              description: z.string().register(z.globalRegistry, {
                description: 'Description of what the browser API tool does.',
              }),
              id: z.string().register(z.globalRegistry, {
                description: 'Unique identifier for the browser API tool.',
              }),
              schema: z.unknown(),
            })
          )
          .register(z.globalRegistry, {
            description:
              'Optional browser API tools to be registered as LLM tools with browser.* namespace. These tools execute on the client side.',
          })
      ),
      capabilities: z.optional(
        z
          .object({
            visualizations: z.optional(
              z.boolean().register(z.globalRegistry, {
                description:
                  'When true, allows the agent to render tabular data from tool results as interactive visualizations using custom XML elements in responses.',
              })
            ),
          })
          .register(z.globalRegistry, {
            description:
              'Controls agent capabilities during conversation. Currently supports visualization rendering for tabular tool results.',
          })
      ),
      connector_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Optional connector ID for the agent to use for external integrations.',
        })
      ),
      conversation_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Optional existing conversation ID to continue a previous conversation.',
        })
      ),
      input: z.string().register(z.globalRegistry, {
        description: 'The user input message to send to the agent.',
      }),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_agent_builder_converse_async_request = z.object({
  body: z.optional(
    z.object({
      agent_id: z
        .optional(
          z.string().register(z.globalRegistry, {
            description:
              'The ID of the agent to chat with. Defaults to the default Elastic AI agent.',
          })
        )
        .default('elastic-ai-agent'),
      attachments: z.optional(
        z
          .array(
            z.object({
              data: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
                description: 'Payload of the attachment.',
              }),
              hidden: z.optional(
                z.boolean().register(z.globalRegistry, {
                  description: 'When true, the attachment will not be displayed in the UI.',
                })
              ),
              id: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'Optional id for the attachment.',
                })
              ),
              type: z.string().register(z.globalRegistry, {
                description: 'Type of the attachment.',
              }),
            })
          )
          .register(z.globalRegistry, {
            description: 'Optional attachments to send with the message.',
          })
      ),
      browser_api_tools: z.optional(
        z
          .array(
            z.object({
              description: z.string().register(z.globalRegistry, {
                description: 'Description of what the browser API tool does.',
              }),
              id: z.string().register(z.globalRegistry, {
                description: 'Unique identifier for the browser API tool.',
              }),
              schema: z.unknown(),
            })
          )
          .register(z.globalRegistry, {
            description:
              'Optional browser API tools to be registered as LLM tools with browser.* namespace. These tools execute on the client side.',
          })
      ),
      capabilities: z.optional(
        z
          .object({
            visualizations: z.optional(
              z.boolean().register(z.globalRegistry, {
                description:
                  'When true, allows the agent to render tabular data from tool results as interactive visualizations using custom XML elements in responses.',
              })
            ),
          })
          .register(z.globalRegistry, {
            description:
              'Controls agent capabilities during conversation. Currently supports visualization rendering for tabular tool results.',
          })
      ),
      connector_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Optional connector ID for the agent to use for external integrations.',
        })
      ),
      conversation_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Optional existing conversation ID to continue a previous conversation.',
        })
      ),
      input: z.string().register(z.globalRegistry, {
        description: 'The user input message to send to the agent.',
      }),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_agent_builder_mcp_request = z.object({
  body: z.optional(z.unknown()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const get_agent_builder_tools_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const post_agent_builder_tools_request = z.object({
  body: z.optional(
    z.object({
      configuration: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Tool-specific configuration parameters. See examples for details.',
      }),
      description: z
        .optional(
          z.string().register(z.globalRegistry, {
            description: 'Description of what the tool does.',
          })
        )
        .default(''),
      id: z.string().register(z.globalRegistry, {
        description: 'Unique identifier for the tool.',
      }),
      tags: z
        .optional(
          z
            .array(
              z.string().register(z.globalRegistry, {
                description: 'Tag for categorizing the tool.',
              })
            )
            .register(z.globalRegistry, {
              description: 'Optional tags for categorizing and organizing tools.',
            })
        )
        .default([]),
      type: z.enum(['esql', 'index_search', 'workflow']).register(z.globalRegistry, {
        description: 'The type of tool to create (e.g., esql, index_search).',
      }),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_agent_builder_tools_execute_request = z.object({
  body: z.optional(
    z.object({
      connector_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Optional connector ID for tools that require external integrations.',
        })
      ),
      tool_id: z.string().register(z.globalRegistry, {
        description: 'The ID of the tool to execute.',
      }),
      tool_params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Parameters to pass to the tool execution. See examples for details',
      }),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const delete_agent_builder_tools_toolid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    toolId: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the tool to delete.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_agent_builder_tools_toolid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    toolId: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the tool to retrieve.',
    }),
  }),
  query: z.optional(z.never()),
});

export const put_agent_builder_tools_toolid_request = z.object({
  body: z.optional(
    z.object({
      configuration: z.optional(
        z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description: 'Updated tool-specific configuration parameters. See examples for details.',
        })
      ),
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Updated description of what the tool does.',
        })
      ),
      tags: z.optional(
        z
          .array(
            z.string().register(z.globalRegistry, {
              description: 'Updated tag for categorizing the tool.',
            })
          )
          .register(z.globalRegistry, {
            description: 'Updated tags for categorizing and organizing tools.',
          })
      ),
    })
  ),
  path: z.object({
    toolId: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the tool to update.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_alerting_health_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_alerting_health_response = z
  .object({
    alerting_framework_health: z.optional(
      z
        .object({
          decryption_health: z.optional(
            z
              .object({
                status: z.optional(z.enum(['error', 'ok', 'warn'])),
                timestamp: z.optional(z.iso.datetime()),
              })
              .register(z.globalRegistry, {
                description: 'The timestamp and status of the rule decryption.',
              })
          ),
          execution_health: z.optional(
            z
              .object({
                status: z.optional(z.enum(['error', 'ok', 'warn'])),
                timestamp: z.optional(z.iso.datetime()),
              })
              .register(z.globalRegistry, {
                description: 'The timestamp and status of the rule run.',
              })
          ),
          read_health: z.optional(
            z
              .object({
                status: z.optional(z.enum(['error', 'ok', 'warn'])),
                timestamp: z.optional(z.iso.datetime()),
              })
              .register(z.globalRegistry, {
                description: 'The timestamp and status of the rule reading events.',
              })
          ),
        })
        .register(z.globalRegistry, {
          description:
            'Three substates identify the health of the alerting framework: `decryption_health`, `execution_health`, and `read_health`.\n',
        })
    ),
    has_permanent_encryption_key: z.optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `false`, the encrypted saved object plugin does not have a permanent encryption key.',
      })
    ),
    is_sufficiently_secure: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If `false`, security is enabled but TLS is not.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_rule_types_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_rule_types_response = z
  .array(
    z.object({
      action_groups: z.optional(
        z
          .array(
            z.object({
              id: z.optional(z.string()),
              name: z.optional(z.string()),
            })
          )
          .register(z.globalRegistry, {
            description:
              "An explicit list of groups for which the rule type can schedule actions, each with the action group's unique ID and human readable name. Rule actions validation uses this configuration to ensure that groups are valid.\n",
          })
      ),
      action_variables: z.optional(
        z
          .object({
            context: z.optional(
              z.array(
                z.object({
                  description: z.optional(z.string()),
                  name: z.optional(z.string()),
                  useWithTripleBracesInTemplates: z.optional(z.boolean()),
                })
              )
            ),
            params: z.optional(
              z.array(
                z.object({
                  description: z.optional(z.string()),
                  name: z.optional(z.string()),
                })
              )
            ),
            state: z.optional(
              z.array(
                z.object({
                  description: z.optional(z.string()),
                  name: z.optional(z.string()),
                })
              )
            ),
          })
          .register(z.globalRegistry, {
            description:
              'A list of action variables that the rule type makes available via context and state in action parameter templates, and a short human readable description. When you create a rule in Kibana, it uses this information to prompt you for these variables in action parameter editors.\n',
          })
      ),
      alerts: z.optional(
        z
          .object({
            context: z.optional(
              z
                .enum([
                  'ml.anomaly-detection',
                  'observability.apm',
                  'observability.logs',
                  'observability.metrics',
                  'observability.slo',
                  'observability.threshold',
                  'observability.uptime',
                  'security',
                  'stack',
                ])
                .register(z.globalRegistry, {
                  description: 'The namespace for this rule type.\n',
                })
            ),
            dynamic: z.optional(
              z.enum(['false', 'runtime', 'strict', 'true']).register(z.globalRegistry, {
                description: 'Indicates whether new fields are added dynamically.',
              })
            ),
            isSpaceAware: z.optional(
              z.boolean().register(z.globalRegistry, {
                description:
                  'Indicates whether the alerts are space-aware. If true, space-specific alert indices are used.\n',
              })
            ),
            mappings: z.optional(
              z.object({
                fieldMap: z.optional(
                  z.record(z.string(), alerting_fieldmap_properties).register(z.globalRegistry, {
                    description:
                      'Mapping information for each field supported in alerts as data documents for this rule type. For more information about mapping parameters, refer to the Elasticsearch documentation.\n',
                  })
                ),
              })
            ),
            secondaryAlias: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'A secondary alias. It is typically used to support the signals alias for detection rules.\n',
              })
            ),
            shouldWrite: z.optional(
              z.boolean().register(z.globalRegistry, {
                description: 'Indicates whether the rule should write out alerts as data.\n',
              })
            ),
            useEcs: z.optional(
              z.boolean().register(z.globalRegistry, {
                description:
                  'Indicates whether to include the ECS component template for the alerts.\n',
              })
            ),
            useLegacyAlerts: z
              .optional(
                z.boolean().register(z.globalRegistry, {
                  description:
                    'Indicates whether to include the legacy component template for the alerts.\n',
                })
              )
              .default(false),
          })
          .register(z.globalRegistry, {
            description: 'Details for writing alerts as data documents for this rule type.\n',
          })
      ),
      authorized_consumers: z.optional(
        z
          .object({
            alerts: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
            apm: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
            discover: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
            infrastructure: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
            logs: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
            ml: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
            monitoring: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
            siem: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
            slo: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
            stackAlerts: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
            uptime: z.optional(
              z.object({
                all: z.optional(z.boolean()),
                read: z.optional(z.boolean()),
              })
            ),
          })
          .register(z.globalRegistry, {
            description: 'The list of the plugins IDs that have access to the rule type.',
          })
      ),
      category: z.optional(
        z.enum(['management', 'observability', 'securitySolution']).register(z.globalRegistry, {
          description:
            'The rule category, which is used by features such as category-specific maintenance windows.',
        })
      ),
      default_action_group_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The default identifier for the rule type group.',
        })
      ),
      does_set_recovery_context: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Indicates whether the rule passes context variables to its recovery action.',
        })
      ),
      enabled_in_license: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Indicates whether the rule type is enabled or disabled based on the subscription.',
        })
      ),
      has_alerts_mappings: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Indicates whether the rule type has custom mappings for the alert data.',
        })
      ),
      has_fields_for_a_a_d: z.optional(z.boolean()),
      id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The unique identifier for the rule type.',
        })
      ),
      is_exportable: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Indicates whether the rule type is exportable in **Stack Management > Saved Objects**.',
        })
      ),
      minimum_license_required: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The subscriptions required to use the rule type.',
        })
      ),
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The descriptive name of the rule type.',
        })
      ),
      producer: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'An identifier for the application that produces this rule type.',
        })
      ),
      recovery_action_group: z.optional(
        z
          .object({
            id: z.optional(z.string()),
            name: z.optional(z.string()),
          })
          .register(z.globalRegistry, {
            description:
              'An action group to use when an alert goes from an active state to an inactive one.',
          })
      ),
      rule_task_timeout: z.optional(z.string()),
    })
  )
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const delete_alerting_rule_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const delete_alerting_rule_id_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const get_alerting_rule_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_alerting_rule_id_response = z
  .object({
    actions: z.array(
      z.object({
        alerts_filter: z.optional(
          z
            .object({
              query: z.optional(
                z.object({
                  dsl: z.optional(
                    z.string().register(z.globalRegistry, {
                      description:
                        'A filter written in Elasticsearch Query Domain Specific Language (DSL).',
                    })
                  ),
                  filters: z
                    .array(
                      z.object({
                        $state: z.optional(
                          z.object({
                            store: z.enum(['appState', 'globalState']).register(z.globalRegistry, {
                              description:
                                'A filter can be either specific to an application context or applied globally.',
                            }),
                          })
                        ),
                        meta: z.record(z.string(), z.unknown()),
                        query: z.optional(z.record(z.string(), z.unknown())),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.',
                    }),
                  kql: z.string().register(z.globalRegistry, {
                    description: 'A filter written in Kibana Query Language (KQL).',
                  }),
                })
              ),
              timeframe: z.optional(
                z.object({
                  days: z
                    .array(
                      z.union([
                        z.literal(1),
                        z.literal(2),
                        z.literal(3),
                        z.literal(4),
                        z.literal(5),
                        z.literal(6),
                        z.literal(7),
                      ])
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.',
                    }),
                  hours: z.object({
                    end: z.string().register(z.globalRegistry, {
                      description: 'The end of the time frame in 24-hour notation (`hh:mm`).',
                    }),
                    start: z.string().register(z.globalRegistry, {
                      description: 'The start of the time frame in 24-hour notation (`hh:mm`).',
                    }),
                  }),
                  timezone: z.string().register(z.globalRegistry, {
                    description:
                      'The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.',
                  }),
                })
              ),
            })
            .register(z.globalRegistry, {
              description: 'Defines a period that limits whether the action runs.',
            })
        ),
        connector_type_id: z.string().register(z.globalRegistry, {
          description:
            'The type of connector. This property appears in responses but cannot be set in requests.',
        }),
        frequency: z.optional(
          z.object({
            notify_when: z
              .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
              .register(z.globalRegistry, {
                description:
                  'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
              }),
            summary: z.boolean().register(z.globalRegistry, {
              description: 'Indicates whether the action is a summary.',
            }),
            throttle: z.union([z.string(), z.null()]),
          })
        ),
        group: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              "The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.",
          })
        ),
        id: z.string().register(z.globalRegistry, {
          description: 'The identifier for the connector saved object.',
        }),
        params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description:
            'The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.',
        }),
        use_alert_data_for_template: z.optional(
          z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether to use alert data as a template.',
          })
        ),
        uuid: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'A universally unique identifier (UUID) for the action.',
          })
        ),
      })
    ),
    active_snoozes: z.optional(
      z.array(
        z.string().register(z.globalRegistry, {
          description: 'List of active snoozes for the rule.',
        })
      )
    ),
    alert_delay: z.optional(
      z
        .object({
          active: z.number().register(z.globalRegistry, {
            description: 'The number of consecutive runs that must meet the rule conditions.',
          }),
        })
        .register(z.globalRegistry, {
          description:
            'Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.',
        })
    ),
    api_key_created_by_user: z.optional(z.union([z.boolean(), z.null()])),
    api_key_owner: z.union([z.string(), z.null()]),
    artifacts: z.optional(
      z.object({
        dashboards: z.optional(
          z.array(
            z.object({
              id: z.string(),
            })
          )
        ),
        investigation_guide: z.optional(
          z.object({
            blob: z.string().register(z.globalRegistry, {
              description: 'User-created content that describes alert causes and remdiation.',
            }),
          })
        ),
      })
    ),
    consumer: z.string().register(z.globalRegistry, {
      description:
        'The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.',
    }),
    created_at: z.string().register(z.globalRegistry, {
      description: 'The date and time that the rule was created.',
    }),
    created_by: z.union([z.string(), z.null()]),
    enabled: z.boolean().register(z.globalRegistry, {
      description:
        'Indicates whether you want to run the rule on an interval basis after it is created.',
    }),
    execution_status: z.object({
      error: z.optional(
        z.object({
          message: z.string().register(z.globalRegistry, {
            description: 'Error message.',
          }),
          reason: z
            .enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
            ])
            .register(z.globalRegistry, {
              description: 'Reason for error.',
            }),
        })
      ),
      last_duration: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Duration of last execution of the rule.',
        })
      ),
      last_execution_date: z.string().register(z.globalRegistry, {
        description: 'The date and time when rule was executed last.',
      }),
      status: z
        .enum(['ok', 'active', 'error', 'warning', 'pending', 'unknown'])
        .register(z.globalRegistry, {
          description: 'Status of rule execution.',
        }),
      warning: z.optional(
        z.object({
          message: z.string().register(z.globalRegistry, {
            description: 'Warning message.',
          }),
          reason: z
            .enum(['maxExecutableActions', 'maxAlerts', 'maxQueuedActions', 'ruleExecution'])
            .register(z.globalRegistry, {
              description: 'Reason for warning.',
            }),
        })
      ),
    }),
    flapping: z.optional(
      z.union([
        z.object({
          look_back_window: z.number().gte(2).lte(20).register(z.globalRegistry, {
            description: 'The minimum number of runs in which the threshold must be met.',
          }),
          status_change_threshold: z.number().gte(2).lte(20).register(z.globalRegistry, {
            description:
              'The minimum number of times an alert must switch states in the look back window.',
          }),
        }),
        z.null(),
      ])
    ),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
    is_snoozed_until: z.optional(z.union([z.string(), z.null()])),
    last_run: z.optional(
      z.union([
        z.object({
          alerts_count: z.object({
            active: z.optional(z.union([z.number(), z.null()])),
            ignored: z.optional(z.union([z.number(), z.null()])),
            new: z.optional(z.union([z.number(), z.null()])),
            recovered: z.optional(z.union([z.number(), z.null()])),
          }),
          outcome: z.enum(['succeeded', 'warning', 'failed']).register(z.globalRegistry, {
            description:
              'Outcome of last run of the rule. Value could be succeeded, warning or failed.',
          }),
          outcome_msg: z.optional(
            z.union([
              z.array(
                z.string().register(z.globalRegistry, {
                  description: 'Outcome message generated during last rule run.',
                })
              ),
              z.null(),
            ])
          ),
          outcome_order: z.optional(
            z.number().register(z.globalRegistry, {
              description: 'Order of the outcome.',
            })
          ),
          warning: z.optional(
            z
              .enum([
                'read',
                'decrypt',
                'execute',
                'unknown',
                'license',
                'timeout',
                'disabled',
                'validate',
                'maxExecutableActions',
                'maxAlerts',
                'maxQueuedActions',
                'ruleExecution',
              ])
              .register(z.globalRegistry, {
                description: 'Warning of last rule execution.',
              })
          ),
        }),
        z.null(),
      ])
    ),
    mapped_params: z.optional(z.record(z.string(), z.unknown())),
    monitoring: z.optional(
      z
        .object({
          run: z
            .object({
              calculated_metrics: z
                .object({
                  p50: z.optional(z.number()),
                  p95: z.optional(z.number()),
                  p99: z.optional(z.number()),
                  success_ratio: z.number(),
                })
                .register(z.globalRegistry, {
                  description: 'Calculation of different percentiles and success ratio.',
                }),
              history: z
                .array(
                  z.object({
                    duration: z.optional(
                      z.number().register(z.globalRegistry, {
                        description: 'Duration of the rule run.',
                      })
                    ),
                    outcome: z.optional(
                      z.enum(['succeeded', 'warning', 'failed']).register(z.globalRegistry, {
                        description:
                          'Outcome of last run of the rule. Value could be succeeded, warning or failed.',
                      })
                    ),
                    success: z.boolean().register(z.globalRegistry, {
                      description: 'Indicates whether the rule run was successful.',
                    }),
                    timestamp: z.number().register(z.globalRegistry, {
                      description: 'Time of rule run.',
                    }),
                  })
                )
                .register(z.globalRegistry, {
                  description: 'History of the rule run.',
                }),
              last_run: z.object({
                metrics: z.object({
                  duration: z.optional(
                    z.number().register(z.globalRegistry, {
                      description: 'Duration of most recent rule run.',
                    })
                  ),
                  gap_duration_s: z.optional(z.union([z.number(), z.null()])),
                  gap_range: z.optional(
                    z.union([
                      z.object({
                        gte: z.string().register(z.globalRegistry, {
                          description: 'End of the gap range.',
                        }),
                        lte: z.string().register(z.globalRegistry, {
                          description: 'Start of the gap range.',
                        }),
                      }),
                      z.null(),
                    ])
                  ),
                  total_alerts_created: z.optional(z.union([z.number(), z.null()])),
                  total_alerts_detected: z.optional(z.union([z.number(), z.null()])),
                  total_indexing_duration_ms: z.optional(z.union([z.number(), z.null()])),
                  total_search_duration_ms: z.optional(z.union([z.number(), z.null()])),
                }),
                timestamp: z.string().register(z.globalRegistry, {
                  description: 'Time of the most recent rule run.',
                }),
              }),
            })
            .register(z.globalRegistry, {
              description: 'Rule run details.',
            }),
        })
        .register(z.globalRegistry, {
          description: 'Monitoring details of the rule.',
        })
    ),
    mute_all: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether all alerts are muted.',
    }),
    muted_alert_ids: z.array(
      z.string().register(z.globalRegistry, {
        description: 'List of identifiers of muted alerts. ',
      })
    ),
    name: z.string().register(z.globalRegistry, {
      description: ' The name of the rule.',
    }),
    next_run: z.optional(z.union([z.string(), z.null()])),
    notify_when: z.optional(
      z
        .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
        .register(z.globalRegistry, {
          description:
            'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
        })
    ),
    params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The parameters for the rule.',
    }),
    revision: z.number().register(z.globalRegistry, {
      description: 'The rule revision number.',
    }),
    rule_type_id: z.string().register(z.globalRegistry, {
      description: 'The rule type identifier.',
    }),
    running: z.optional(z.union([z.boolean(), z.null()])),
    schedule: z.object({
      interval: z.string().register(z.globalRegistry, {
        description: 'The interval is specified in seconds, minutes, hours, or days.',
      }),
    }),
    scheduled_task_id: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Identifier of the scheduled task.',
      })
    ),
    snooze_schedule: z.optional(
      z.array(
        z.object({
          duration: z.number().register(z.globalRegistry, {
            description: 'Duration of the rule snooze schedule.',
          }),
          id: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Identifier of the rule snooze schedule.',
            })
          ),
          rRule: z.object({
            byhour: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates hours of the day to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            byminute: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates minutes of the hour to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bymonth: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates months of the year that this rule should recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bymonthday: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates the days of the month to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bysecond: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates seconds of the day to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bysetpos: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description:
                      'A positive or negative integer affecting the nth day of the month. For example, -2 combined with `byweekday` of FR is 2nd to last Friday of the month. It is recommended to not set this manually and just use `byweekday`.',
                  })
                ),
                z.null(),
              ])
            ),
            byweekday: z.optional(
              z.union([
                z.array(z.union([z.string(), z.number()])).register(z.globalRegistry, {
                  description:
                    'Indicates the days of the week to recur or else nth-day-of-month strings. For example, "+2TU" second Tuesday of month, "-1FR" last Friday of the month, which are internally converted to a `byweekday/bysetpos` combination.',
                }),
                z.null(),
              ])
            ),
            byweekno: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates number of the week hours to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            byyearday: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates the days of the year that this rule should recur.',
                  })
                ),
                z.null(),
              ])
            ),
            count: z.optional(
              z.number().register(z.globalRegistry, {
                description: 'Number of times the rule should recur until it stops.',
              })
            ),
            dtstart: z.string().register(z.globalRegistry, {
              description: 'Rule start date in Coordinated Universal Time (UTC).',
            }),
            freq: z.optional(
              z
                .union([
                  z.literal(0),
                  z.literal(1),
                  z.literal(2),
                  z.literal(3),
                  z.literal(4),
                  z.literal(5),
                  z.literal(6),
                ])
                .register(z.globalRegistry, {
                  description:
                    'Indicates frequency of the rule. Options are YEARLY, MONTHLY, WEEKLY, DAILY.',
                })
            ),
            interval: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'Indicates the interval of frequency. For example, 1 and YEARLY is every 1 year, 2 and WEEKLY is every 2 weeks.',
              })
            ),
            tzid: z.string().register(z.globalRegistry, {
              description: 'Indicates timezone abbreviation.',
            }),
            until: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'Recur the rule until this date.',
              })
            ),
            wkst: z.optional(
              z.enum(['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU']).register(z.globalRegistry, {
                description: 'Indicates the start of week, defaults to Monday.',
              })
            ),
          }),
          skipRecurrences: z.optional(
            z.array(
              z.string().register(z.globalRegistry, {
                description: 'Skips recurrence of rule on this date.',
              })
            )
          ),
        })
      )
    ),
    tags: z.array(
      z.string().register(z.globalRegistry, {
        description: 'The tags for the rule.',
      })
    ),
    throttle: z.optional(z.union([z.string(), z.null()])),
    updated_at: z.string().register(z.globalRegistry, {
      description: 'The date and time that the rule was updated most recently.',
    }),
    updated_by: z.union([z.string(), z.null()]),
    view_in_app_relative_url: z.optional(z.union([z.string(), z.null()])),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const post_alerting_rule_id_request = z.object({
  body: z.optional(
    z.object({
      actions: z
        .optional(
          z.array(
            z
              .object({
                alerts_filter: z.optional(
                  z
                    .object({
                      query: z.optional(
                        z.object({
                          dsl: z.optional(
                            z.string().register(z.globalRegistry, {
                              description:
                                'A filter written in Elasticsearch Query Domain Specific Language (DSL).',
                            })
                          ),
                          filters: z
                            .array(
                              z.object({
                                $state: z.optional(
                                  z.object({
                                    store: z
                                      .enum(['appState', 'globalState'])
                                      .register(z.globalRegistry, {
                                        description:
                                          'A filter can be either specific to an application context or applied globally.',
                                      }),
                                  })
                                ),
                                meta: z.record(z.string(), z.unknown()),
                                query: z.optional(z.record(z.string(), z.unknown())),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.',
                            }),
                          kql: z.string().register(z.globalRegistry, {
                            description: 'A filter written in Kibana Query Language (KQL).',
                          }),
                        })
                      ),
                      timeframe: z.optional(
                        z
                          .object({
                            days: z
                              .array(
                                z.union([
                                  z.literal(1),
                                  z.literal(2),
                                  z.literal(3),
                                  z.literal(4),
                                  z.literal(5),
                                  z.literal(6),
                                  z.literal(7),
                                ])
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.',
                              }),
                            hours: z
                              .object({
                                end: z.string().register(z.globalRegistry, {
                                  description:
                                    'The end of the time frame in 24-hour notation (`hh:mm`).',
                                }),
                                start: z.string().register(z.globalRegistry, {
                                  description:
                                    'The start of the time frame in 24-hour notation (`hh:mm`).',
                                }),
                              })
                              .register(z.globalRegistry, {
                                description:
                                  'Defines the range of time in a day that the action can run. If the `start` value is `00:00` and the `end` value is `24:00`, actions be generated all day.',
                              }),
                            timezone: z.string().register(z.globalRegistry, {
                              description:
                                'The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.',
                            }),
                          })
                          .register(z.globalRegistry, {
                            description: 'Defines a period that limits whether the action runs.',
                          })
                      ),
                    })
                    .register(z.globalRegistry, {
                      description:
                        'Conditions that affect whether the action runs. If you specify multiple conditions, all conditions must be met for the action to run. For example, if an alert occurs within the specified time frame and matches the query, the action runs.',
                    })
                ),
                frequency: z.optional(
                  z.object({
                    notify_when: z
                      .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
                      .register(z.globalRegistry, {
                        description:
                          'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
                      }),
                    summary: z.boolean().register(z.globalRegistry, {
                      description: 'Indicates whether the action is a summary.',
                    }),
                    throttle: z.union([z.string(), z.null()]),
                  })
                ),
                group: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      "The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.",
                  })
                ),
                id: z.string().register(z.globalRegistry, {
                  description: 'The identifier for the connector saved object.',
                }),
                params: z
                  .optional(
                    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
                      description:
                        'The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.',
                    })
                  )
                  .default({}),
                use_alert_data_for_template: z.optional(
                  z.boolean().register(z.globalRegistry, {
                    description: 'Indicates whether to use alert data as a template.',
                  })
                ),
                uuid: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'A universally unique identifier (UUID) for the action.',
                  })
                ),
              })
              .register(z.globalRegistry, {
                description: 'An action that runs under defined conditions.',
              })
          )
        )
        .default([]),
      alert_delay: z.optional(
        z
          .object({
            active: z.number().register(z.globalRegistry, {
              description: 'The number of consecutive runs that must meet the rule conditions.',
            }),
          })
          .register(z.globalRegistry, {
            description:
              'Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.',
          })
      ),
      artifacts: z.optional(
        z.object({
          dashboards: z.optional(
            z
              .array(
                z.object({
                  id: z.string(),
                })
              )
              .max(10)
          ),
          investigation_guide: z.optional(
            z.object({
              blob: z.string().max(10000),
            })
          ),
        })
      ),
      consumer: z.string().register(z.globalRegistry, {
        description:
          'The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.',
      }),
      enabled: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Indicates whether you want to run the rule on an interval basis after it is created.',
          })
        )
        .default(true),
      flapping: z.optional(
        z.union([
          z.object({
            look_back_window: z.number().gte(2).lte(20).register(z.globalRegistry, {
              description: 'The minimum number of runs in which the threshold must be met.',
            }),
            status_change_threshold: z.number().gte(2).lte(20).register(z.globalRegistry, {
              description:
                'The minimum number of times an alert must switch states in the look back window.',
            }),
          }),
          z.null(),
        ])
      ),
      name: z.string().register(z.globalRegistry, {
        description:
          'The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.',
      }),
      notify_when: z.optional(
        z
          .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
          .register(z.globalRegistry, {
            description:
              'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
          })
      ),
      rule_type_id: z.string().register(z.globalRegistry, {
        description: 'The rule type identifier.',
      }),
      schedule: z
        .object({
          interval: z.string().register(z.globalRegistry, {
            description: 'The interval is specified in seconds, minutes, hours, or days.',
          }),
        })
        .register(z.globalRegistry, {
          description:
            'The check interval, which specifies how frequently the rule conditions are checked.',
        }),
      tags: z
        .optional(
          z.array(z.string()).register(z.globalRegistry, {
            description: 'The tags for the rule.',
          })
        )
        .default([]),
      throttle: z.optional(z.union([z.string(), z.null()])),
      params: z.optional(
        z.union([
          params_property_apm_anomaly,
          params_property_apm_error_count,
          params_property_apm_transaction_duration,
          params_property_apm_transaction_error_rate,
          params_es_query_dsl_rule,
          params_es_query_esql_rule,
          params_es_query_kql_rule,
          params_index_threshold_rule,
          params_property_infra_inventory,
          params_property_log_threshold,
          params_property_infra_metric_threshold,
          params_property_slo_burn_rate,
          params_property_synthetics_uptime_tls,
          params_property_synthetics_monitor_status,
        ])
      ),
    })
  ),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule. If it is omitted, an ID is randomly generated.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_alerting_rule_id_response = z
  .object({
    actions: z.array(
      z.object({
        alerts_filter: z.optional(
          z
            .object({
              query: z.optional(
                z.object({
                  dsl: z.optional(
                    z.string().register(z.globalRegistry, {
                      description:
                        'A filter written in Elasticsearch Query Domain Specific Language (DSL).',
                    })
                  ),
                  filters: z
                    .array(
                      z.object({
                        $state: z.optional(
                          z.object({
                            store: z.enum(['appState', 'globalState']).register(z.globalRegistry, {
                              description:
                                'A filter can be either specific to an application context or applied globally.',
                            }),
                          })
                        ),
                        meta: z.record(z.string(), z.unknown()),
                        query: z.optional(z.record(z.string(), z.unknown())),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.',
                    }),
                  kql: z.string().register(z.globalRegistry, {
                    description: 'A filter written in Kibana Query Language (KQL).',
                  }),
                })
              ),
              timeframe: z.optional(
                z.object({
                  days: z
                    .array(
                      z.union([
                        z.literal(1),
                        z.literal(2),
                        z.literal(3),
                        z.literal(4),
                        z.literal(5),
                        z.literal(6),
                        z.literal(7),
                      ])
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.',
                    }),
                  hours: z.object({
                    end: z.string().register(z.globalRegistry, {
                      description: 'The end of the time frame in 24-hour notation (`hh:mm`).',
                    }),
                    start: z.string().register(z.globalRegistry, {
                      description: 'The start of the time frame in 24-hour notation (`hh:mm`).',
                    }),
                  }),
                  timezone: z.string().register(z.globalRegistry, {
                    description:
                      'The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.',
                  }),
                })
              ),
            })
            .register(z.globalRegistry, {
              description: 'Defines a period that limits whether the action runs.',
            })
        ),
        connector_type_id: z.string().register(z.globalRegistry, {
          description:
            'The type of connector. This property appears in responses but cannot be set in requests.',
        }),
        frequency: z.optional(
          z.object({
            notify_when: z
              .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
              .register(z.globalRegistry, {
                description:
                  'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
              }),
            summary: z.boolean().register(z.globalRegistry, {
              description: 'Indicates whether the action is a summary.',
            }),
            throttle: z.union([z.string(), z.null()]),
          })
        ),
        group: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              "The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.",
          })
        ),
        id: z.string().register(z.globalRegistry, {
          description: 'The identifier for the connector saved object.',
        }),
        params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description:
            'The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.',
        }),
        use_alert_data_for_template: z.optional(
          z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether to use alert data as a template.',
          })
        ),
        uuid: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'A universally unique identifier (UUID) for the action.',
          })
        ),
      })
    ),
    active_snoozes: z.optional(
      z.array(
        z.string().register(z.globalRegistry, {
          description: 'List of active snoozes for the rule.',
        })
      )
    ),
    alert_delay: z.optional(
      z
        .object({
          active: z.number().register(z.globalRegistry, {
            description: 'The number of consecutive runs that must meet the rule conditions.',
          }),
        })
        .register(z.globalRegistry, {
          description:
            'Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.',
        })
    ),
    api_key_created_by_user: z.optional(z.union([z.boolean(), z.null()])),
    api_key_owner: z.union([z.string(), z.null()]),
    artifacts: z.optional(
      z.object({
        dashboards: z.optional(
          z.array(
            z.object({
              id: z.string(),
            })
          )
        ),
        investigation_guide: z.optional(
          z.object({
            blob: z.string().register(z.globalRegistry, {
              description: 'User-created content that describes alert causes and remdiation.',
            }),
          })
        ),
      })
    ),
    consumer: z.string().register(z.globalRegistry, {
      description:
        'The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.',
    }),
    created_at: z.string().register(z.globalRegistry, {
      description: 'The date and time that the rule was created.',
    }),
    created_by: z.union([z.string(), z.null()]),
    enabled: z.boolean().register(z.globalRegistry, {
      description:
        'Indicates whether you want to run the rule on an interval basis after it is created.',
    }),
    execution_status: z.object({
      error: z.optional(
        z.object({
          message: z.string().register(z.globalRegistry, {
            description: 'Error message.',
          }),
          reason: z
            .enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
            ])
            .register(z.globalRegistry, {
              description: 'Reason for error.',
            }),
        })
      ),
      last_duration: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Duration of last execution of the rule.',
        })
      ),
      last_execution_date: z.string().register(z.globalRegistry, {
        description: 'The date and time when rule was executed last.',
      }),
      status: z
        .enum(['ok', 'active', 'error', 'warning', 'pending', 'unknown'])
        .register(z.globalRegistry, {
          description: 'Status of rule execution.',
        }),
      warning: z.optional(
        z.object({
          message: z.string().register(z.globalRegistry, {
            description: 'Warning message.',
          }),
          reason: z
            .enum(['maxExecutableActions', 'maxAlerts', 'maxQueuedActions', 'ruleExecution'])
            .register(z.globalRegistry, {
              description: 'Reason for warning.',
            }),
        })
      ),
    }),
    flapping: z.optional(
      z.union([
        z.object({
          look_back_window: z.number().gte(2).lte(20).register(z.globalRegistry, {
            description: 'The minimum number of runs in which the threshold must be met.',
          }),
          status_change_threshold: z.number().gte(2).lte(20).register(z.globalRegistry, {
            description:
              'The minimum number of times an alert must switch states in the look back window.',
          }),
        }),
        z.null(),
      ])
    ),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
    is_snoozed_until: z.optional(z.union([z.string(), z.null()])),
    last_run: z.optional(
      z.union([
        z.object({
          alerts_count: z.object({
            active: z.optional(z.union([z.number(), z.null()])),
            ignored: z.optional(z.union([z.number(), z.null()])),
            new: z.optional(z.union([z.number(), z.null()])),
            recovered: z.optional(z.union([z.number(), z.null()])),
          }),
          outcome: z.enum(['succeeded', 'warning', 'failed']).register(z.globalRegistry, {
            description:
              'Outcome of last run of the rule. Value could be succeeded, warning or failed.',
          }),
          outcome_msg: z.optional(
            z.union([
              z.array(
                z.string().register(z.globalRegistry, {
                  description: 'Outcome message generated during last rule run.',
                })
              ),
              z.null(),
            ])
          ),
          outcome_order: z.optional(
            z.number().register(z.globalRegistry, {
              description: 'Order of the outcome.',
            })
          ),
          warning: z.optional(
            z
              .enum([
                'read',
                'decrypt',
                'execute',
                'unknown',
                'license',
                'timeout',
                'disabled',
                'validate',
                'maxExecutableActions',
                'maxAlerts',
                'maxQueuedActions',
                'ruleExecution',
              ])
              .register(z.globalRegistry, {
                description: 'Warning of last rule execution.',
              })
          ),
        }),
        z.null(),
      ])
    ),
    mapped_params: z.optional(z.record(z.string(), z.unknown())),
    monitoring: z.optional(
      z
        .object({
          run: z
            .object({
              calculated_metrics: z
                .object({
                  p50: z.optional(z.number()),
                  p95: z.optional(z.number()),
                  p99: z.optional(z.number()),
                  success_ratio: z.number(),
                })
                .register(z.globalRegistry, {
                  description: 'Calculation of different percentiles and success ratio.',
                }),
              history: z
                .array(
                  z.object({
                    duration: z.optional(
                      z.number().register(z.globalRegistry, {
                        description: 'Duration of the rule run.',
                      })
                    ),
                    outcome: z.optional(
                      z.enum(['succeeded', 'warning', 'failed']).register(z.globalRegistry, {
                        description:
                          'Outcome of last run of the rule. Value could be succeeded, warning or failed.',
                      })
                    ),
                    success: z.boolean().register(z.globalRegistry, {
                      description: 'Indicates whether the rule run was successful.',
                    }),
                    timestamp: z.number().register(z.globalRegistry, {
                      description: 'Time of rule run.',
                    }),
                  })
                )
                .register(z.globalRegistry, {
                  description: 'History of the rule run.',
                }),
              last_run: z.object({
                metrics: z.object({
                  duration: z.optional(
                    z.number().register(z.globalRegistry, {
                      description: 'Duration of most recent rule run.',
                    })
                  ),
                  gap_duration_s: z.optional(z.union([z.number(), z.null()])),
                  gap_range: z.optional(
                    z.union([
                      z.object({
                        gte: z.string().register(z.globalRegistry, {
                          description: 'End of the gap range.',
                        }),
                        lte: z.string().register(z.globalRegistry, {
                          description: 'Start of the gap range.',
                        }),
                      }),
                      z.null(),
                    ])
                  ),
                  total_alerts_created: z.optional(z.union([z.number(), z.null()])),
                  total_alerts_detected: z.optional(z.union([z.number(), z.null()])),
                  total_indexing_duration_ms: z.optional(z.union([z.number(), z.null()])),
                  total_search_duration_ms: z.optional(z.union([z.number(), z.null()])),
                }),
                timestamp: z.string().register(z.globalRegistry, {
                  description: 'Time of the most recent rule run.',
                }),
              }),
            })
            .register(z.globalRegistry, {
              description: 'Rule run details.',
            }),
        })
        .register(z.globalRegistry, {
          description: 'Monitoring details of the rule.',
        })
    ),
    mute_all: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether all alerts are muted.',
    }),
    muted_alert_ids: z.array(
      z.string().register(z.globalRegistry, {
        description: 'List of identifiers of muted alerts. ',
      })
    ),
    name: z.string().register(z.globalRegistry, {
      description: ' The name of the rule.',
    }),
    next_run: z.optional(z.union([z.string(), z.null()])),
    notify_when: z.optional(
      z
        .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
        .register(z.globalRegistry, {
          description:
            'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
        })
    ),
    params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The parameters for the rule.',
    }),
    revision: z.number().register(z.globalRegistry, {
      description: 'The rule revision number.',
    }),
    rule_type_id: z.string().register(z.globalRegistry, {
      description: 'The rule type identifier.',
    }),
    running: z.optional(z.union([z.boolean(), z.null()])),
    schedule: z.object({
      interval: z.string().register(z.globalRegistry, {
        description: 'The interval is specified in seconds, minutes, hours, or days.',
      }),
    }),
    scheduled_task_id: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Identifier of the scheduled task.',
      })
    ),
    snooze_schedule: z.optional(
      z.array(
        z.object({
          duration: z.number().register(z.globalRegistry, {
            description: 'Duration of the rule snooze schedule.',
          }),
          id: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Identifier of the rule snooze schedule.',
            })
          ),
          rRule: z.object({
            byhour: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates hours of the day to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            byminute: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates minutes of the hour to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bymonth: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates months of the year that this rule should recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bymonthday: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates the days of the month to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bysecond: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates seconds of the day to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bysetpos: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description:
                      'A positive or negative integer affecting the nth day of the month. For example, -2 combined with `byweekday` of FR is 2nd to last Friday of the month. It is recommended to not set this manually and just use `byweekday`.',
                  })
                ),
                z.null(),
              ])
            ),
            byweekday: z.optional(
              z.union([
                z.array(z.union([z.string(), z.number()])).register(z.globalRegistry, {
                  description:
                    'Indicates the days of the week to recur or else nth-day-of-month strings. For example, "+2TU" second Tuesday of month, "-1FR" last Friday of the month, which are internally converted to a `byweekday/bysetpos` combination.',
                }),
                z.null(),
              ])
            ),
            byweekno: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates number of the week hours to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            byyearday: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates the days of the year that this rule should recur.',
                  })
                ),
                z.null(),
              ])
            ),
            count: z.optional(
              z.number().register(z.globalRegistry, {
                description: 'Number of times the rule should recur until it stops.',
              })
            ),
            dtstart: z.string().register(z.globalRegistry, {
              description: 'Rule start date in Coordinated Universal Time (UTC).',
            }),
            freq: z.optional(
              z
                .union([
                  z.literal(0),
                  z.literal(1),
                  z.literal(2),
                  z.literal(3),
                  z.literal(4),
                  z.literal(5),
                  z.literal(6),
                ])
                .register(z.globalRegistry, {
                  description:
                    'Indicates frequency of the rule. Options are YEARLY, MONTHLY, WEEKLY, DAILY.',
                })
            ),
            interval: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'Indicates the interval of frequency. For example, 1 and YEARLY is every 1 year, 2 and WEEKLY is every 2 weeks.',
              })
            ),
            tzid: z.string().register(z.globalRegistry, {
              description: 'Indicates timezone abbreviation.',
            }),
            until: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'Recur the rule until this date.',
              })
            ),
            wkst: z.optional(
              z.enum(['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU']).register(z.globalRegistry, {
                description: 'Indicates the start of week, defaults to Monday.',
              })
            ),
          }),
          skipRecurrences: z.optional(
            z.array(
              z.string().register(z.globalRegistry, {
                description: 'Skips recurrence of rule on this date.',
              })
            )
          ),
        })
      )
    ),
    tags: z.array(
      z.string().register(z.globalRegistry, {
        description: 'The tags for the rule.',
      })
    ),
    throttle: z.optional(z.union([z.string(), z.null()])),
    updated_at: z.string().register(z.globalRegistry, {
      description: 'The date and time that the rule was updated most recently.',
    }),
    updated_by: z.union([z.string(), z.null()]),
    view_in_app_relative_url: z.optional(z.union([z.string(), z.null()])),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const put_alerting_rule_id_request = z.object({
  body: z.optional(
    z.object({
      actions: z
        .optional(
          z.array(
            z
              .object({
                alerts_filter: z.optional(
                  z.object({
                    query: z.optional(
                      z.object({
                        dsl: z.optional(
                          z.string().register(z.globalRegistry, {
                            description:
                              'A filter written in Elasticsearch Query Domain Specific Language (DSL).',
                          })
                        ),
                        filters: z
                          .array(
                            z.object({
                              $state: z.optional(
                                z.object({
                                  store: z
                                    .enum(['appState', 'globalState'])
                                    .register(z.globalRegistry, {
                                      description:
                                        'A filter can be either specific to an application context or applied globally.',
                                    }),
                                })
                              ),
                              meta: z.record(z.string(), z.unknown()),
                              query: z.optional(z.record(z.string(), z.unknown())),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.',
                          }),
                        kql: z.string().register(z.globalRegistry, {
                          description: 'A filter written in Kibana Query Language (KQL).',
                        }),
                      })
                    ),
                    timeframe: z.optional(
                      z
                        .object({
                          days: z
                            .array(
                              z.union([
                                z.literal(1),
                                z.literal(2),
                                z.literal(3),
                                z.literal(4),
                                z.literal(5),
                                z.literal(6),
                                z.literal(7),
                              ])
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.',
                            }),
                          hours: z
                            .object({
                              end: z.string().register(z.globalRegistry, {
                                description:
                                  'The end of the time frame in 24-hour notation (`hh:mm`).',
                              }),
                              start: z.string().register(z.globalRegistry, {
                                description:
                                  'The start of the time frame in 24-hour notation (`hh:mm`).',
                              }),
                            })
                            .register(z.globalRegistry, {
                              description:
                                'Defines the range of time in a day that the action can run. If the `start` value is `00:00` and the `end` value is `24:00`, actions be generated all day.',
                            }),
                          timezone: z.string().register(z.globalRegistry, {
                            description:
                              'The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.',
                          }),
                        })
                        .register(z.globalRegistry, {
                          description: 'Defines a period that limits whether the action runs.',
                        })
                    ),
                  })
                ),
                frequency: z.optional(
                  z.object({
                    notify_when: z
                      .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
                      .register(z.globalRegistry, {
                        description:
                          'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
                      }),
                    summary: z.boolean().register(z.globalRegistry, {
                      description: 'Indicates whether the action is a summary.',
                    }),
                    throttle: z.union([z.string(), z.null()]),
                  })
                ),
                group: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      "The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.",
                  })
                ),
                id: z.string().register(z.globalRegistry, {
                  description: 'The identifier for the connector saved object.',
                }),
                params: z
                  .optional(
                    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
                      description:
                        'The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.',
                    })
                  )
                  .default({}),
                use_alert_data_for_template: z.optional(
                  z.boolean().register(z.globalRegistry, {
                    description: 'Indicates whether to use alert data as a template.',
                  })
                ),
                uuid: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'A universally unique identifier (UUID) for the action.',
                  })
                ),
              })
              .register(z.globalRegistry, {
                description: 'An action that runs under defined conditions.',
              })
          )
        )
        .default([]),
      alert_delay: z.optional(
        z
          .object({
            active: z.number().register(z.globalRegistry, {
              description: 'The number of consecutive runs that must meet the rule conditions.',
            }),
          })
          .register(z.globalRegistry, {
            description:
              'Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.',
          })
      ),
      artifacts: z.optional(
        z.object({
          dashboards: z.optional(
            z
              .array(
                z.object({
                  id: z.string(),
                })
              )
              .max(10)
          ),
          investigation_guide: z.optional(
            z.object({
              blob: z.string().max(10000),
            })
          ),
        })
      ),
      flapping: z.optional(
        z.union([
          z.object({
            look_back_window: z.number().gte(2).lte(20).register(z.globalRegistry, {
              description: 'The minimum number of runs in which the threshold must be met.',
            }),
            status_change_threshold: z.number().gte(2).lte(20).register(z.globalRegistry, {
              description:
                'The minimum number of times an alert must switch states in the look back window.',
            }),
          }),
          z.null(),
        ])
      ),
      name: z.string().register(z.globalRegistry, {
        description:
          'The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.',
      }),
      notify_when: z.optional(
        z
          .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
          .register(z.globalRegistry, {
            description:
              'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
          })
      ),
      params: z
        .optional(
          z.record(z.string(), z.unknown()).register(z.globalRegistry, {
            description: 'The parameters for the rule.',
          })
        )
        .default({}),
      schedule: z.object({
        interval: z.string().register(z.globalRegistry, {
          description: 'The interval is specified in seconds, minutes, hours, or days.',
        }),
      }),
      tags: z
        .optional(
          z.array(
            z.string().register(z.globalRegistry, {
              description: 'The tags for the rule.',
            })
          )
        )
        .default([]),
      throttle: z.optional(z.union([z.string(), z.null()])),
    })
  ),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const put_alerting_rule_id_response = z
  .object({
    actions: z.array(
      z.object({
        alerts_filter: z.optional(
          z
            .object({
              query: z.optional(
                z.object({
                  dsl: z.optional(
                    z.string().register(z.globalRegistry, {
                      description:
                        'A filter written in Elasticsearch Query Domain Specific Language (DSL).',
                    })
                  ),
                  filters: z
                    .array(
                      z.object({
                        $state: z.optional(
                          z.object({
                            store: z.enum(['appState', 'globalState']).register(z.globalRegistry, {
                              description:
                                'A filter can be either specific to an application context or applied globally.',
                            }),
                          })
                        ),
                        meta: z.record(z.string(), z.unknown()),
                        query: z.optional(z.record(z.string(), z.unknown())),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.',
                    }),
                  kql: z.string().register(z.globalRegistry, {
                    description: 'A filter written in Kibana Query Language (KQL).',
                  }),
                })
              ),
              timeframe: z.optional(
                z.object({
                  days: z
                    .array(
                      z.union([
                        z.literal(1),
                        z.literal(2),
                        z.literal(3),
                        z.literal(4),
                        z.literal(5),
                        z.literal(6),
                        z.literal(7),
                      ])
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.',
                    }),
                  hours: z.object({
                    end: z.string().register(z.globalRegistry, {
                      description: 'The end of the time frame in 24-hour notation (`hh:mm`).',
                    }),
                    start: z.string().register(z.globalRegistry, {
                      description: 'The start of the time frame in 24-hour notation (`hh:mm`).',
                    }),
                  }),
                  timezone: z.string().register(z.globalRegistry, {
                    description:
                      'The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.',
                  }),
                })
              ),
            })
            .register(z.globalRegistry, {
              description: 'Defines a period that limits whether the action runs.',
            })
        ),
        connector_type_id: z.string().register(z.globalRegistry, {
          description:
            'The type of connector. This property appears in responses but cannot be set in requests.',
        }),
        frequency: z.optional(
          z.object({
            notify_when: z
              .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
              .register(z.globalRegistry, {
                description:
                  'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
              }),
            summary: z.boolean().register(z.globalRegistry, {
              description: 'Indicates whether the action is a summary.',
            }),
            throttle: z.union([z.string(), z.null()]),
          })
        ),
        group: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              "The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.",
          })
        ),
        id: z.string().register(z.globalRegistry, {
          description: 'The identifier for the connector saved object.',
        }),
        params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description:
            'The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.',
        }),
        use_alert_data_for_template: z.optional(
          z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether to use alert data as a template.',
          })
        ),
        uuid: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'A universally unique identifier (UUID) for the action.',
          })
        ),
      })
    ),
    active_snoozes: z.optional(
      z.array(
        z.string().register(z.globalRegistry, {
          description: 'List of active snoozes for the rule.',
        })
      )
    ),
    alert_delay: z.optional(
      z
        .object({
          active: z.number().register(z.globalRegistry, {
            description: 'The number of consecutive runs that must meet the rule conditions.',
          }),
        })
        .register(z.globalRegistry, {
          description:
            'Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.',
        })
    ),
    api_key_created_by_user: z.optional(z.union([z.boolean(), z.null()])),
    api_key_owner: z.union([z.string(), z.null()]),
    artifacts: z.optional(
      z.object({
        dashboards: z.optional(
          z.array(
            z.object({
              id: z.string(),
            })
          )
        ),
        investigation_guide: z.optional(
          z.object({
            blob: z.string().register(z.globalRegistry, {
              description: 'User-created content that describes alert causes and remdiation.',
            }),
          })
        ),
      })
    ),
    consumer: z.string().register(z.globalRegistry, {
      description:
        'The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.',
    }),
    created_at: z.string().register(z.globalRegistry, {
      description: 'The date and time that the rule was created.',
    }),
    created_by: z.union([z.string(), z.null()]),
    enabled: z.boolean().register(z.globalRegistry, {
      description:
        'Indicates whether you want to run the rule on an interval basis after it is created.',
    }),
    execution_status: z.object({
      error: z.optional(
        z.object({
          message: z.string().register(z.globalRegistry, {
            description: 'Error message.',
          }),
          reason: z
            .enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
            ])
            .register(z.globalRegistry, {
              description: 'Reason for error.',
            }),
        })
      ),
      last_duration: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Duration of last execution of the rule.',
        })
      ),
      last_execution_date: z.string().register(z.globalRegistry, {
        description: 'The date and time when rule was executed last.',
      }),
      status: z
        .enum(['ok', 'active', 'error', 'warning', 'pending', 'unknown'])
        .register(z.globalRegistry, {
          description: 'Status of rule execution.',
        }),
      warning: z.optional(
        z.object({
          message: z.string().register(z.globalRegistry, {
            description: 'Warning message.',
          }),
          reason: z
            .enum(['maxExecutableActions', 'maxAlerts', 'maxQueuedActions', 'ruleExecution'])
            .register(z.globalRegistry, {
              description: 'Reason for warning.',
            }),
        })
      ),
    }),
    flapping: z.optional(
      z.union([
        z.object({
          look_back_window: z.number().gte(2).lte(20).register(z.globalRegistry, {
            description: 'The minimum number of runs in which the threshold must be met.',
          }),
          status_change_threshold: z.number().gte(2).lte(20).register(z.globalRegistry, {
            description:
              'The minimum number of times an alert must switch states in the look back window.',
          }),
        }),
        z.null(),
      ])
    ),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
    is_snoozed_until: z.optional(z.union([z.string(), z.null()])),
    last_run: z.optional(
      z.union([
        z.object({
          alerts_count: z.object({
            active: z.optional(z.union([z.number(), z.null()])),
            ignored: z.optional(z.union([z.number(), z.null()])),
            new: z.optional(z.union([z.number(), z.null()])),
            recovered: z.optional(z.union([z.number(), z.null()])),
          }),
          outcome: z.enum(['succeeded', 'warning', 'failed']).register(z.globalRegistry, {
            description:
              'Outcome of last run of the rule. Value could be succeeded, warning or failed.',
          }),
          outcome_msg: z.optional(
            z.union([
              z.array(
                z.string().register(z.globalRegistry, {
                  description: 'Outcome message generated during last rule run.',
                })
              ),
              z.null(),
            ])
          ),
          outcome_order: z.optional(
            z.number().register(z.globalRegistry, {
              description: 'Order of the outcome.',
            })
          ),
          warning: z.optional(
            z
              .enum([
                'read',
                'decrypt',
                'execute',
                'unknown',
                'license',
                'timeout',
                'disabled',
                'validate',
                'maxExecutableActions',
                'maxAlerts',
                'maxQueuedActions',
                'ruleExecution',
              ])
              .register(z.globalRegistry, {
                description: 'Warning of last rule execution.',
              })
          ),
        }),
        z.null(),
      ])
    ),
    mapped_params: z.optional(z.record(z.string(), z.unknown())),
    monitoring: z.optional(
      z
        .object({
          run: z
            .object({
              calculated_metrics: z
                .object({
                  p50: z.optional(z.number()),
                  p95: z.optional(z.number()),
                  p99: z.optional(z.number()),
                  success_ratio: z.number(),
                })
                .register(z.globalRegistry, {
                  description: 'Calculation of different percentiles and success ratio.',
                }),
              history: z
                .array(
                  z.object({
                    duration: z.optional(
                      z.number().register(z.globalRegistry, {
                        description: 'Duration of the rule run.',
                      })
                    ),
                    outcome: z.optional(
                      z.enum(['succeeded', 'warning', 'failed']).register(z.globalRegistry, {
                        description:
                          'Outcome of last run of the rule. Value could be succeeded, warning or failed.',
                      })
                    ),
                    success: z.boolean().register(z.globalRegistry, {
                      description: 'Indicates whether the rule run was successful.',
                    }),
                    timestamp: z.number().register(z.globalRegistry, {
                      description: 'Time of rule run.',
                    }),
                  })
                )
                .register(z.globalRegistry, {
                  description: 'History of the rule run.',
                }),
              last_run: z.object({
                metrics: z.object({
                  duration: z.optional(
                    z.number().register(z.globalRegistry, {
                      description: 'Duration of most recent rule run.',
                    })
                  ),
                  gap_duration_s: z.optional(z.union([z.number(), z.null()])),
                  gap_range: z.optional(
                    z.union([
                      z.object({
                        gte: z.string().register(z.globalRegistry, {
                          description: 'End of the gap range.',
                        }),
                        lte: z.string().register(z.globalRegistry, {
                          description: 'Start of the gap range.',
                        }),
                      }),
                      z.null(),
                    ])
                  ),
                  total_alerts_created: z.optional(z.union([z.number(), z.null()])),
                  total_alerts_detected: z.optional(z.union([z.number(), z.null()])),
                  total_indexing_duration_ms: z.optional(z.union([z.number(), z.null()])),
                  total_search_duration_ms: z.optional(z.union([z.number(), z.null()])),
                }),
                timestamp: z.string().register(z.globalRegistry, {
                  description: 'Time of the most recent rule run.',
                }),
              }),
            })
            .register(z.globalRegistry, {
              description: 'Rule run details.',
            }),
        })
        .register(z.globalRegistry, {
          description: 'Monitoring details of the rule.',
        })
    ),
    mute_all: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether all alerts are muted.',
    }),
    muted_alert_ids: z.array(
      z.string().register(z.globalRegistry, {
        description: 'List of identifiers of muted alerts. ',
      })
    ),
    name: z.string().register(z.globalRegistry, {
      description: ' The name of the rule.',
    }),
    next_run: z.optional(z.union([z.string(), z.null()])),
    notify_when: z.optional(
      z
        .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
        .register(z.globalRegistry, {
          description:
            'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
        })
    ),
    params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The parameters for the rule.',
    }),
    revision: z.number().register(z.globalRegistry, {
      description: 'The rule revision number.',
    }),
    rule_type_id: z.string().register(z.globalRegistry, {
      description: 'The rule type identifier.',
    }),
    running: z.optional(z.union([z.boolean(), z.null()])),
    schedule: z.object({
      interval: z.string().register(z.globalRegistry, {
        description: 'The interval is specified in seconds, minutes, hours, or days.',
      }),
    }),
    scheduled_task_id: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Identifier of the scheduled task.',
      })
    ),
    snooze_schedule: z.optional(
      z.array(
        z.object({
          duration: z.number().register(z.globalRegistry, {
            description: 'Duration of the rule snooze schedule.',
          }),
          id: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Identifier of the rule snooze schedule.',
            })
          ),
          rRule: z.object({
            byhour: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates hours of the day to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            byminute: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates minutes of the hour to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bymonth: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates months of the year that this rule should recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bymonthday: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates the days of the month to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bysecond: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates seconds of the day to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bysetpos: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description:
                      'A positive or negative integer affecting the nth day of the month. For example, -2 combined with `byweekday` of FR is 2nd to last Friday of the month. It is recommended to not set this manually and just use `byweekday`.',
                  })
                ),
                z.null(),
              ])
            ),
            byweekday: z.optional(
              z.union([
                z.array(z.union([z.string(), z.number()])).register(z.globalRegistry, {
                  description:
                    'Indicates the days of the week to recur or else nth-day-of-month strings. For example, "+2TU" second Tuesday of month, "-1FR" last Friday of the month, which are internally converted to a `byweekday/bysetpos` combination.',
                }),
                z.null(),
              ])
            ),
            byweekno: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates number of the week hours to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            byyearday: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates the days of the year that this rule should recur.',
                  })
                ),
                z.null(),
              ])
            ),
            count: z.optional(
              z.number().register(z.globalRegistry, {
                description: 'Number of times the rule should recur until it stops.',
              })
            ),
            dtstart: z.string().register(z.globalRegistry, {
              description: 'Rule start date in Coordinated Universal Time (UTC).',
            }),
            freq: z.optional(
              z
                .union([
                  z.literal(0),
                  z.literal(1),
                  z.literal(2),
                  z.literal(3),
                  z.literal(4),
                  z.literal(5),
                  z.literal(6),
                ])
                .register(z.globalRegistry, {
                  description:
                    'Indicates frequency of the rule. Options are YEARLY, MONTHLY, WEEKLY, DAILY.',
                })
            ),
            interval: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'Indicates the interval of frequency. For example, 1 and YEARLY is every 1 year, 2 and WEEKLY is every 2 weeks.',
              })
            ),
            tzid: z.string().register(z.globalRegistry, {
              description: 'Indicates timezone abbreviation.',
            }),
            until: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'Recur the rule until this date.',
              })
            ),
            wkst: z.optional(
              z.enum(['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU']).register(z.globalRegistry, {
                description: 'Indicates the start of week, defaults to Monday.',
              })
            ),
          }),
          skipRecurrences: z.optional(
            z.array(
              z.string().register(z.globalRegistry, {
                description: 'Skips recurrence of rule on this date.',
              })
            )
          ),
        })
      )
    ),
    tags: z.array(
      z.string().register(z.globalRegistry, {
        description: 'The tags for the rule.',
      })
    ),
    throttle: z.optional(z.union([z.string(), z.null()])),
    updated_at: z.string().register(z.globalRegistry, {
      description: 'The date and time that the rule was updated most recently.',
    }),
    updated_by: z.union([z.string(), z.null()]),
    view_in_app_relative_url: z.optional(z.union([z.string(), z.null()])),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const post_alerting_rule_id_disable_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        untrack: z.optional(
          z.boolean().register(z.globalRegistry, {
            description: "Defines whether this rule's alerts should be untracked.",
          })
        ),
      }),
      z.null(),
    ])
  ),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_alerting_rule_id_disable_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const post_alerting_rule_id_enable_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_alerting_rule_id_enable_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const post_alerting_rule_id_mute_all_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_alerting_rule_id_mute_all_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const post_alerting_rule_id_unmute_all_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_alerting_rule_id_unmute_all_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const post_alerting_rule_id_update_api_key_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_alerting_rule_id_update_api_key_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const post_alerting_rule_id_snooze_schedule_request = z.object({
  body: z.optional(
    z.object({
      schedule: z.object({
        custom: z.optional(
          z.object({
            duration: z.string().register(z.globalRegistry, {
              description:
                'The duration of the schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `h`, `m`, or `s` for hours, minutes, seconds. For example: `1d`, `5h`, `30m`, `5000s`.',
            }),
            recurring: z.optional(
              z.object({
                end: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The end date of a recurring schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-04-01T00:00:00.000Z`.',
                  })
                ),
                every: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The interval and frequency of a recurring schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `w`, `M`, or `y` for days, weeks, months, years. For example: `15d`, `2w`, `3m`, `1y`.',
                  })
                ),
                occurrences: z.optional(
                  z.number().gte(1).register(z.globalRegistry, {
                    description: 'The total number of recurrences of the schedule.',
                  })
                ),
                onMonth: z.optional(
                  z.array(z.number().gte(1).lte(12)).min(1).register(z.globalRegistry, {
                    description:
                      'The specific months for a recurring schedule. Valid values are 1-12.',
                  })
                ),
                onMonthDay: z.optional(
                  z.array(z.number().gte(1).lte(31)).min(1).register(z.globalRegistry, {
                    description:
                      'The specific days of the month for a recurring schedule. Valid values are 1-31.',
                  })
                ),
                onWeekDay: z.optional(
                  z.array(z.string()).min(1).register(z.globalRegistry, {
                    description:
                      'The specific days of the week (`[MO,TU,WE,TH,FR,SA,SU]`) or nth day of month (`[+1MO, -3FR, +2WE, -4SA, -5SU]`) for a recurring schedule.',
                  })
                ),
              })
            ),
            start: z.string().register(z.globalRegistry, {
              description:
                'The start date and time of the schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-03-12T12:00:00.000Z`.',
            }),
            timezone: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The timezone of the schedule. The default timezone is UTC.',
              })
            ),
          })
        ),
      }),
    })
  ),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'Identifier of the rule.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_alerting_rule_id_snooze_schedule_response = z
  .object({
    body: z.object({
      schedule: z.object({
        custom: z.optional(
          z.object({
            duration: z.string().register(z.globalRegistry, {
              description:
                'The duration of the schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `h`, `m`, or `s` for hours, minutes, seconds. For example: `1d`, `5h`, `30m`, `5000s`.',
            }),
            recurring: z.optional(
              z.object({
                end: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The end date of a recurring schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-04-01T00:00:00.000Z`.',
                  })
                ),
                every: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The interval and frequency of a recurring schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `w`, `M`, or `y` for days, weeks, months, years. For example: `15d`, `2w`, `3m`, `1y`.',
                  })
                ),
                occurrences: z.optional(
                  z.number().gte(1).register(z.globalRegistry, {
                    description: 'The total number of recurrences of the schedule.',
                  })
                ),
                onMonth: z.optional(
                  z.array(z.number().gte(1).lte(12)).min(1).register(z.globalRegistry, {
                    description:
                      'The specific months for a recurring schedule. Valid values are 1-12.',
                  })
                ),
                onMonthDay: z.optional(
                  z.array(z.number().gte(1).lte(31)).min(1).register(z.globalRegistry, {
                    description:
                      'The specific days of the month for a recurring schedule. Valid values are 1-31.',
                  })
                ),
                onWeekDay: z.optional(
                  z.array(z.string()).min(1).register(z.globalRegistry, {
                    description:
                      'The specific days of the week (`[MO,TU,WE,TH,FR,SA,SU]`) or nth day of month (`[+1MO, -3FR, +2WE, -4SA, -5SU]`) for a recurring schedule.',
                  })
                ),
              })
            ),
            start: z.string().register(z.globalRegistry, {
              description:
                'The start date and time of the schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-03-12T12:00:00.000Z`.',
            }),
            timezone: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The timezone of the schedule. The default timezone is UTC.',
              })
            ),
          })
        ),
        id: z.string().register(z.globalRegistry, {
          description: 'Identifier of the snooze schedule.',
        }),
      }),
    }),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const post_alerting_rule_rule_id_alert_alert_id_mute_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    rule_id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
    alert_id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the alert.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_alerting_rule_rule_id_alert_alert_id_mute_response = z
  .void()
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const post_alerting_rule_rule_id_alert_alert_id_unmute_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    rule_id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
    alert_id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the alert.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_alerting_rule_rule_id_alert_alert_id_unmute_response = z
  .void()
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const delete_alerting_rule_ruleid_snooze_schedule_scheduleid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    ruleId: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
    scheduleId: z.string().register(z.globalRegistry, {
      description: 'The identifier for the snooze schedule.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const delete_alerting_rule_ruleid_snooze_schedule_scheduleid_response = z
  .void()
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_alerting_rules_find_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      per_page: z
        .optional(
          z.number().gte(0).register(z.globalRegistry, {
            description: 'The number of rules to return per page.',
          })
        )
        .default(10),
      page: z
        .optional(
          z.number().gte(1).register(z.globalRegistry, {
            description: 'The page number to return.',
          })
        )
        .default(1),
      search: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'An Elasticsearch simple_query_string query that filters the objects in the response.',
        })
      ),
      default_search_operator: z.optional(
        z.enum(['OR', 'AND']).register(z.globalRegistry, {
          description: 'The default operator to use for the simple_query_string.',
        })
      ),
      search_fields: z.optional(z.union([z.array(z.string()), z.string()])),
      sort_field: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Determines which field is used to sort the results. The field must exist in the `attributes` key of the response.',
        })
      ),
      sort_order: z.optional(
        z.enum(['asc', 'desc']).register(z.globalRegistry, {
          description: 'Determines the sort order.',
        })
      ),
      has_reference: z.optional(
        z.union([
          z.object({
            id: z.string(),
            type: z.string(),
          }),
          z.null(),
        ])
      ),
      fields: z.optional(z.union([z.array(z.string()), z.string()])),
      filter: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A KQL string that you filter with an attribute from your saved object. It should look like `savedObjectType.attributes.title: "myTitle"`. However, if you used a direct attribute of a saved object, such as `updatedAt`, you must define your filter, for example, `savedObjectType.updatedAt > 2018-12-22`.',
        })
      ),
      filter_consumers: z.optional(
        z.array(
          z.string().register(z.globalRegistry, {
            description: 'List of consumers to filter.',
          })
        )
      ),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const get_alerting_rules_find_response = z
  .object({
    actions: z.array(
      z.object({
        alerts_filter: z.optional(
          z
            .object({
              query: z.optional(
                z.object({
                  dsl: z.optional(
                    z.string().register(z.globalRegistry, {
                      description:
                        'A filter written in Elasticsearch Query Domain Specific Language (DSL).',
                    })
                  ),
                  filters: z
                    .array(
                      z.object({
                        $state: z.optional(
                          z.object({
                            store: z.enum(['appState', 'globalState']).register(z.globalRegistry, {
                              description:
                                'A filter can be either specific to an application context or applied globally.',
                            }),
                          })
                        ),
                        meta: z.record(z.string(), z.unknown()),
                        query: z.optional(z.record(z.string(), z.unknown())),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.',
                    }),
                  kql: z.string().register(z.globalRegistry, {
                    description: 'A filter written in Kibana Query Language (KQL).',
                  }),
                })
              ),
              timeframe: z.optional(
                z.object({
                  days: z
                    .array(
                      z.union([
                        z.literal(1),
                        z.literal(2),
                        z.literal(3),
                        z.literal(4),
                        z.literal(5),
                        z.literal(6),
                        z.literal(7),
                      ])
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.',
                    }),
                  hours: z.object({
                    end: z.string().register(z.globalRegistry, {
                      description: 'The end of the time frame in 24-hour notation (`hh:mm`).',
                    }),
                    start: z.string().register(z.globalRegistry, {
                      description: 'The start of the time frame in 24-hour notation (`hh:mm`).',
                    }),
                  }),
                  timezone: z.string().register(z.globalRegistry, {
                    description:
                      'The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.',
                  }),
                })
              ),
            })
            .register(z.globalRegistry, {
              description: 'Defines a period that limits whether the action runs.',
            })
        ),
        connector_type_id: z.string().register(z.globalRegistry, {
          description:
            'The type of connector. This property appears in responses but cannot be set in requests.',
        }),
        frequency: z.optional(
          z.object({
            notify_when: z
              .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
              .register(z.globalRegistry, {
                description:
                  'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
              }),
            summary: z.boolean().register(z.globalRegistry, {
              description: 'Indicates whether the action is a summary.',
            }),
            throttle: z.union([z.string(), z.null()]),
          })
        ),
        group: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              "The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.",
          })
        ),
        id: z.string().register(z.globalRegistry, {
          description: 'The identifier for the connector saved object.',
        }),
        params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description:
            'The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.',
        }),
        use_alert_data_for_template: z.optional(
          z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether to use alert data as a template.',
          })
        ),
        uuid: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'A universally unique identifier (UUID) for the action.',
          })
        ),
      })
    ),
    active_snoozes: z.optional(
      z.array(
        z.string().register(z.globalRegistry, {
          description: 'List of active snoozes for the rule.',
        })
      )
    ),
    alert_delay: z.optional(
      z
        .object({
          active: z.number().register(z.globalRegistry, {
            description: 'The number of consecutive runs that must meet the rule conditions.',
          }),
        })
        .register(z.globalRegistry, {
          description:
            'Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.',
        })
    ),
    api_key_created_by_user: z.optional(z.union([z.boolean(), z.null()])),
    api_key_owner: z.union([z.string(), z.null()]),
    artifacts: z.optional(
      z.object({
        dashboards: z.optional(
          z.array(
            z.object({
              id: z.string(),
            })
          )
        ),
        investigation_guide: z.optional(
          z.object({
            blob: z.string().register(z.globalRegistry, {
              description: 'User-created content that describes alert causes and remdiation.',
            }),
          })
        ),
      })
    ),
    consumer: z.string().register(z.globalRegistry, {
      description:
        'The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.',
    }),
    created_at: z.string().register(z.globalRegistry, {
      description: 'The date and time that the rule was created.',
    }),
    created_by: z.union([z.string(), z.null()]),
    enabled: z.boolean().register(z.globalRegistry, {
      description:
        'Indicates whether you want to run the rule on an interval basis after it is created.',
    }),
    execution_status: z.object({
      error: z.optional(
        z.object({
          message: z.string().register(z.globalRegistry, {
            description: 'Error message.',
          }),
          reason: z
            .enum([
              'read',
              'decrypt',
              'execute',
              'unknown',
              'license',
              'timeout',
              'disabled',
              'validate',
            ])
            .register(z.globalRegistry, {
              description: 'Reason for error.',
            }),
        })
      ),
      last_duration: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Duration of last execution of the rule.',
        })
      ),
      last_execution_date: z.string().register(z.globalRegistry, {
        description: 'The date and time when rule was executed last.',
      }),
      status: z
        .enum(['ok', 'active', 'error', 'warning', 'pending', 'unknown'])
        .register(z.globalRegistry, {
          description: 'Status of rule execution.',
        }),
      warning: z.optional(
        z.object({
          message: z.string().register(z.globalRegistry, {
            description: 'Warning message.',
          }),
          reason: z
            .enum(['maxExecutableActions', 'maxAlerts', 'maxQueuedActions', 'ruleExecution'])
            .register(z.globalRegistry, {
              description: 'Reason for warning.',
            }),
        })
      ),
    }),
    flapping: z.optional(
      z.union([
        z.object({
          look_back_window: z.number().gte(2).lte(20).register(z.globalRegistry, {
            description: 'The minimum number of runs in which the threshold must be met.',
          }),
          status_change_threshold: z.number().gte(2).lte(20).register(z.globalRegistry, {
            description:
              'The minimum number of times an alert must switch states in the look back window.',
          }),
        }),
        z.null(),
      ])
    ),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the rule.',
    }),
    is_snoozed_until: z.optional(z.union([z.string(), z.null()])),
    last_run: z.optional(
      z.union([
        z.object({
          alerts_count: z.object({
            active: z.optional(z.union([z.number(), z.null()])),
            ignored: z.optional(z.union([z.number(), z.null()])),
            new: z.optional(z.union([z.number(), z.null()])),
            recovered: z.optional(z.union([z.number(), z.null()])),
          }),
          outcome: z.enum(['succeeded', 'warning', 'failed']).register(z.globalRegistry, {
            description:
              'Outcome of last run of the rule. Value could be succeeded, warning or failed.',
          }),
          outcome_msg: z.optional(
            z.union([
              z.array(
                z.string().register(z.globalRegistry, {
                  description: 'Outcome message generated during last rule run.',
                })
              ),
              z.null(),
            ])
          ),
          outcome_order: z.optional(
            z.number().register(z.globalRegistry, {
              description: 'Order of the outcome.',
            })
          ),
          warning: z.optional(
            z
              .enum([
                'read',
                'decrypt',
                'execute',
                'unknown',
                'license',
                'timeout',
                'disabled',
                'validate',
                'maxExecutableActions',
                'maxAlerts',
                'maxQueuedActions',
                'ruleExecution',
              ])
              .register(z.globalRegistry, {
                description: 'Warning of last rule execution.',
              })
          ),
        }),
        z.null(),
      ])
    ),
    mapped_params: z.optional(z.record(z.string(), z.unknown())),
    monitoring: z.optional(
      z
        .object({
          run: z
            .object({
              calculated_metrics: z
                .object({
                  p50: z.optional(z.number()),
                  p95: z.optional(z.number()),
                  p99: z.optional(z.number()),
                  success_ratio: z.number(),
                })
                .register(z.globalRegistry, {
                  description: 'Calculation of different percentiles and success ratio.',
                }),
              history: z
                .array(
                  z.object({
                    duration: z.optional(
                      z.number().register(z.globalRegistry, {
                        description: 'Duration of the rule run.',
                      })
                    ),
                    outcome: z.optional(
                      z.enum(['succeeded', 'warning', 'failed']).register(z.globalRegistry, {
                        description:
                          'Outcome of last run of the rule. Value could be succeeded, warning or failed.',
                      })
                    ),
                    success: z.boolean().register(z.globalRegistry, {
                      description: 'Indicates whether the rule run was successful.',
                    }),
                    timestamp: z.number().register(z.globalRegistry, {
                      description: 'Time of rule run.',
                    }),
                  })
                )
                .register(z.globalRegistry, {
                  description: 'History of the rule run.',
                }),
              last_run: z.object({
                metrics: z.object({
                  duration: z.optional(
                    z.number().register(z.globalRegistry, {
                      description: 'Duration of most recent rule run.',
                    })
                  ),
                  gap_duration_s: z.optional(z.union([z.number(), z.null()])),
                  gap_range: z.optional(
                    z.union([
                      z.object({
                        gte: z.string().register(z.globalRegistry, {
                          description: 'End of the gap range.',
                        }),
                        lte: z.string().register(z.globalRegistry, {
                          description: 'Start of the gap range.',
                        }),
                      }),
                      z.null(),
                    ])
                  ),
                  total_alerts_created: z.optional(z.union([z.number(), z.null()])),
                  total_alerts_detected: z.optional(z.union([z.number(), z.null()])),
                  total_indexing_duration_ms: z.optional(z.union([z.number(), z.null()])),
                  total_search_duration_ms: z.optional(z.union([z.number(), z.null()])),
                }),
                timestamp: z.string().register(z.globalRegistry, {
                  description: 'Time of the most recent rule run.',
                }),
              }),
            })
            .register(z.globalRegistry, {
              description: 'Rule run details.',
            }),
        })
        .register(z.globalRegistry, {
          description: 'Monitoring details of the rule.',
        })
    ),
    mute_all: z.boolean().register(z.globalRegistry, {
      description: 'Indicates whether all alerts are muted.',
    }),
    muted_alert_ids: z.array(
      z.string().register(z.globalRegistry, {
        description: 'List of identifiers of muted alerts. ',
      })
    ),
    name: z.string().register(z.globalRegistry, {
      description: ' The name of the rule.',
    }),
    next_run: z.optional(z.union([z.string(), z.null()])),
    notify_when: z.optional(
      z
        .enum(['onActionGroupChange', 'onActiveAlert', 'onThrottleInterval'])
        .register(z.globalRegistry, {
          description:
            'Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.',
        })
    ),
    params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The parameters for the rule.',
    }),
    revision: z.number().register(z.globalRegistry, {
      description: 'The rule revision number.',
    }),
    rule_type_id: z.string().register(z.globalRegistry, {
      description: 'The rule type identifier.',
    }),
    running: z.optional(z.union([z.boolean(), z.null()])),
    schedule: z.object({
      interval: z.string().register(z.globalRegistry, {
        description: 'The interval is specified in seconds, minutes, hours, or days.',
      }),
    }),
    scheduled_task_id: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Identifier of the scheduled task.',
      })
    ),
    snooze_schedule: z.optional(
      z.array(
        z.object({
          duration: z.number().register(z.globalRegistry, {
            description: 'Duration of the rule snooze schedule.',
          }),
          id: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Identifier of the rule snooze schedule.',
            })
          ),
          rRule: z.object({
            byhour: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates hours of the day to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            byminute: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates minutes of the hour to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bymonth: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates months of the year that this rule should recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bymonthday: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates the days of the month to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bysecond: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates seconds of the day to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            bysetpos: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description:
                      'A positive or negative integer affecting the nth day of the month. For example, -2 combined with `byweekday` of FR is 2nd to last Friday of the month. It is recommended to not set this manually and just use `byweekday`.',
                  })
                ),
                z.null(),
              ])
            ),
            byweekday: z.optional(
              z.union([
                z.array(z.union([z.string(), z.number()])).register(z.globalRegistry, {
                  description:
                    'Indicates the days of the week to recur or else nth-day-of-month strings. For example, "+2TU" second Tuesday of month, "-1FR" last Friday of the month, which are internally converted to a `byweekday/bysetpos` combination.',
                }),
                z.null(),
              ])
            ),
            byweekno: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates number of the week hours to recur.',
                  })
                ),
                z.null(),
              ])
            ),
            byyearday: z.optional(
              z.union([
                z.array(
                  z.number().register(z.globalRegistry, {
                    description: 'Indicates the days of the year that this rule should recur.',
                  })
                ),
                z.null(),
              ])
            ),
            count: z.optional(
              z.number().register(z.globalRegistry, {
                description: 'Number of times the rule should recur until it stops.',
              })
            ),
            dtstart: z.string().register(z.globalRegistry, {
              description: 'Rule start date in Coordinated Universal Time (UTC).',
            }),
            freq: z.optional(
              z
                .union([
                  z.literal(0),
                  z.literal(1),
                  z.literal(2),
                  z.literal(3),
                  z.literal(4),
                  z.literal(5),
                  z.literal(6),
                ])
                .register(z.globalRegistry, {
                  description:
                    'Indicates frequency of the rule. Options are YEARLY, MONTHLY, WEEKLY, DAILY.',
                })
            ),
            interval: z.optional(
              z.number().register(z.globalRegistry, {
                description:
                  'Indicates the interval of frequency. For example, 1 and YEARLY is every 1 year, 2 and WEEKLY is every 2 weeks.',
              })
            ),
            tzid: z.string().register(z.globalRegistry, {
              description: 'Indicates timezone abbreviation.',
            }),
            until: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'Recur the rule until this date.',
              })
            ),
            wkst: z.optional(
              z.enum(['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU']).register(z.globalRegistry, {
                description: 'Indicates the start of week, defaults to Monday.',
              })
            ),
          }),
          skipRecurrences: z.optional(
            z.array(
              z.string().register(z.globalRegistry, {
                description: 'Skips recurrence of rule on this date.',
              })
            )
          ),
        })
      )
    ),
    tags: z.array(
      z.string().register(z.globalRegistry, {
        description: 'The tags for the rule.',
      })
    ),
    throttle: z.optional(z.union([z.string(), z.null()])),
    updated_at: z.string().register(z.globalRegistry, {
      description: 'The date and time that the rule was updated most recently.',
    }),
    updated_by: z.union([z.string(), z.null()]),
    view_in_app_relative_url: z.optional(z.union([z.string(), z.null()])),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const create_agent_key_request = z.object({
  body: apm_ui_agent_keys_object,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Agent key created successfully
 */
export const create_agent_key_response = apm_ui_agent_keys_response;

export const save_apm_server_schema_request = z.object({
  body: z.object({
    schema: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Schema object',
      })
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Successful response
 */
export const save_apm_server_schema_response = z
  .record(z.string(), z.never())
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const create_annotation_request = z.object({
  body: apm_ui_create_annotation_object,
  path: z.object({
    serviceName: z.string().register(z.globalRegistry, {
      description: 'The name of the service',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Annotation created successfully
 */
export const create_annotation_response = apm_ui_create_annotation_response;

export const get_annotation_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    serviceName: z.string().register(z.globalRegistry, {
      description: 'The name of the service',
    }),
  }),
  query: z.optional(
    z.object({
      environment: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The environment to filter annotations by',
        })
      ),
      start: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The start date for the search',
        })
      ),
      end: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The end date for the search',
        })
      ),
    })
  ),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
  }),
});

/**
 * Successful response
 */
export const get_annotation_response = apm_ui_annotation_search_response;

export const delete_agent_configuration_request = z.object({
  body: apm_ui_delete_service_object,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Successful response
 */
export const delete_agent_configuration_response = apm_ui_delete_agent_configurations_response;

export const get_agent_configurations_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
  }),
});

/**
 * Successful response
 */
export const get_agent_configurations_response = apm_ui_agent_configurations_response;

export const create_update_agent_configuration_request = z.object({
  body: apm_ui_agent_configuration_intake_object,
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      overwrite: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If the config exists ?overwrite=true is required',
        })
      ),
    })
  ),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Successful response
 */
export const create_update_agent_configuration_response = z
  .record(z.string(), z.never())
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const get_agent_name_for_service_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    serviceName: z.string().register(z.globalRegistry, {
      description: 'The name of the service',
    }),
  }),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
  }),
});

/**
 * Successful response
 */
export const get_agent_name_for_service_response = apm_ui_service_agent_name_response;

export const get_environments_for_service_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      serviceName: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The name of the service',
        })
      ),
    })
  ),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
  }),
});

/**
 * Successful response
 */
export const get_environments_for_service_response = apm_ui_service_environments_response;

export const search_single_configuration_request = z.object({
  body: apm_ui_search_agent_configuration_object,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Successful response
 */
export const search_single_configuration_response = apm_ui_search_agent_configuration_response;

export const get_single_agent_configuration_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Service name',
        })
      ),
      environment: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Service environment',
        })
      ),
    })
  ),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
  }),
});

/**
 * Successful response
 */
export const get_single_agent_configuration_response = apm_ui_single_agent_configuration_response;

export const get_source_maps_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Page number',
        })
      ),
      perPage: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Number of records per page',
        })
      ),
    })
  ),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
  }),
});

/**
 * Successful response
 */
export const get_source_maps_response = apm_ui_source_maps_response;

export const upload_source_map_request = z.object({
  body: apm_ui_upload_source_map_object,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Successful response
 */
export const upload_source_map_response = apm_ui_upload_source_maps_response;

export const delete_source_map_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'Source map identifier',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'elastic-api-version': z.enum(['2023-10-31']).register(z.globalRegistry, {
      description: 'The version of the API to use',
    }),
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Successful response
 */
export const delete_source_map_response = z
  .record(z.string(), z.never())
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const delete_asset_criticality_record_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    id_value: z.string().register(z.globalRegistry, {
      description: 'The ID value of the asset.',
    }),
    id_field: security_entity_analytics_api_id_field,
    refresh: z.optional(
      z.enum(['wait_for']).register(z.globalRegistry, {
        description: "If 'wait_for' the request will wait for the index refresh.",
      })
    ),
  }),
});

/**
 * Successful response
 */
export const delete_asset_criticality_record_response = z
  .object({
    deleted: z.boolean().register(z.globalRegistry, {
      description: 'True if the record was deleted or false if the record did not exist.',
    }),
    record: z.optional(security_entity_analytics_api_asset_criticality_record),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const get_asset_criticality_record_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    id_value: z.string().register(z.globalRegistry, {
      description: 'The ID value of the asset.',
    }),
    id_field: security_entity_analytics_api_id_field,
  }),
});

/**
 * Successful response
 */
export const get_asset_criticality_record_response =
  security_entity_analytics_api_asset_criticality_record;

export const create_asset_criticality_record_request = z.object({
  body: security_entity_analytics_api_create_asset_criticality_record.and(
    z.object({
      refresh: z.optional(
        z.enum(['wait_for']).register(z.globalRegistry, {
          description: "If 'wait_for' the request will wait for the index refresh.",
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_asset_criticality_record_response =
  security_entity_analytics_api_asset_criticality_record;

export const bulk_upsert_asset_criticality_records_request = z.object({
  body: z.optional(
    z.object({
      records: z
        .array(
          security_entity_analytics_api_asset_criticality_record_id_parts.and(
            z.object({
              criticality_level:
                security_entity_analytics_api_asset_criticality_levels_for_bulk_upload,
            })
          )
        )
        .min(1)
        .max(1000),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Bulk upload successful
 */
export const bulk_upsert_asset_criticality_records_response = z
  .object({
    errors: z.array(security_entity_analytics_api_asset_criticality_bulk_upload_error_item),
    stats: security_entity_analytics_api_asset_criticality_bulk_upload_stats,
  })
  .register(z.globalRegistry, {
    description: 'Bulk upload successful',
  });

export const find_asset_criticality_records_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      sort_field: z.optional(
        z
          .enum(['id_value', 'id_field', 'criticality_level', '@timestamp'])
          .register(z.globalRegistry, {
            description: 'The field to sort by.',
          })
      ),
      sort_direction: z.optional(
        z.enum(['asc', 'desc']).register(z.globalRegistry, {
          description: 'The order to sort by.',
        })
      ),
      page: z.optional(
        z.int().gte(1).register(z.globalRegistry, {
          description: 'The page number to return.',
        })
      ),
      per_page: z.optional(
        z.int().gte(1).lte(1000).register(z.globalRegistry, {
          description: 'The number of records to return per page.',
        })
      ),
      kuery: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The kuery to filter by.',
        })
      ),
    })
  ),
});

/**
 * Successfully retrieved asset criticality records
 */
export const find_asset_criticality_records_response = z
  .object({
    page: z.int().gte(1),
    per_page: z.int().gte(1).lte(1000),
    records: z.array(security_entity_analytics_api_asset_criticality_record),
    total: z.int().gte(0),
  })
  .register(z.globalRegistry, {
    description: 'Successfully retrieved asset criticality records',
  });

export const post_attack_discovery_bulk_request = z.object({
  body: z
    .object({
      update: z
        .object({
          enable_field_rendering: z
            .optional(
              z.boolean().register(z.globalRegistry, {
                description:
                  'Enables a markdown syntax used to render pivot fields, for example `{{ user.name james }}`. When disabled, the same example would be rendered as `james`. This is primarily used for Attack discovery views within Kibana. Defaults to `false`.',
              })
            )
            .default(false),
          ids: z.array(z.string()).register(z.globalRegistry, {
            description: 'Array of Attack discovery IDs to update',
          }),
          kibana_alert_workflow_status: z.optional(
            z.enum(['open', 'acknowledged', 'closed']).register(z.globalRegistry, {
              description:
                'When provided, update the kibana.alert.workflow_status of the attack discovery alerts',
            })
          ),
          visibility: z.optional(
            z.enum(['not_shared', 'shared']).register(z.globalRegistry, {
              description:
                'When provided, update the visibility of the alert, as determined by the kibana.alert.attack_discovery.users field',
            })
          ),
          with_replacements: z
            .optional(
              z.boolean().register(z.globalRegistry, {
                description:
                  'When true, returns the updated Attack discoveries with text replacements applied to the detailsMarkdown, entitySummaryMarkdown, summaryMarkdown, and title fields. This substitutes anonymized values with human-readable equivalents. Defaults to `true`.',
              })
            )
            .default(true),
        })
        .register(z.globalRegistry, {
          description:
            'Configuration object containing all parameters for the bulk update operation',
        }),
    })
    .register(z.globalRegistry, {
      description: 'Bulk update parameters for Attack discoveries',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response containing the updated Attack discovery alerts
 */
export const post_attack_discovery_bulk_response = z
  .object({
    data: z
      .array(security_attack_discovery_api_attack_discovery_api_alert)
      .register(z.globalRegistry, {
        description:
          'Array of updated Attack discovery alert objects. Each item includes the applied modifications from the bulk update request.',
      }),
  })
  .register(z.globalRegistry, {
    description: 'Successful response containing the updated Attack discovery alerts',
  });

export const attack_discovery_find_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      alert_ids: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description:
            'Filter results to Attack discoveries that include any of the provided alert IDs',
        })
      ),
      connector_names: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description:
            'Filter results to Attack discoveries created by any of the provided human readable connector names. Note that values must match the human readable `connector_name` property of an Attack discovery, e.g. "GPT-5 Chat", which are distinct from `connector_id` values used to generate Attack discoveries.',
        })
      ),
      enable_field_rendering: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Enables a markdown syntax used to render pivot fields, for example `{{ user.name james }}`. When disabled, the same example would be rendered as `james`. This is primarily used for Attack discovery views within Kibana. Defaults to `false`.',
          })
        )
        .default(false),
      end: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'End of the time range for the search. Accepts absolute timestamps (ISO 8601) or relative date math (e.g. "now", "now-24h").',
        })
      ),
      ids: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'Filter results to the Attack discoveries with the specified IDs',
        })
      ),
      include_unique_alert_ids: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If `true`, the response will include `unique_alert_ids` and `unique_alert_ids_count` aggregated across the matched Attack discoveries',
        })
      ),
      page: z
        .optional(
          z.int().gte(1).register(z.globalRegistry, {
            description: 'Page number to return (used for pagination). Defaults to 1.',
          })
        )
        .default(1),
      per_page: z
        .optional(
          z.int().gte(1).register(z.globalRegistry, {
            description:
              'Number of Attack discoveries to return per page (used for pagination). Defaults to 10.',
          })
        )
        .default(10),
      search: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Free-text search query applied to relevant text fields of Attack discoveries (title, description, tags, etc.)',
        })
      ),
      shared: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to filter by shared visibility. If omitted, both shared and privately visible Attack discoveries are returned. Use `true` to return only shared discoveries, `false` to return only those visible to the current user.',
        })
      ),
      sort_field: z.optional(security_attack_discovery_api_attack_discovery_find_sort_field),
      sort_order: z.optional(security_attack_discovery_api_sort_order),
      start: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Start of the time range for the search. Accepts absolute timestamps (ISO 8601) or relative date math (e.g. "now-7d").',
        })
      ),
      status: z.optional(
        z.array(z.enum(['acknowledged', 'closed', 'open'])).register(z.globalRegistry, {
          description:
            'Filter by alert workflow status. Provide one or more of the allowed workflow states.',
        })
      ),
      with_replacements: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'When true, return the created Attack discoveries with text replacements applied to the detailsMarkdown, entitySummaryMarkdown, summaryMarkdown, and title fields. Defaults to `true`.',
          })
        )
        .default(true),
    })
  ),
});

/**
 * Successful response
 */
export const attack_discovery_find_response = z
  .object({
    connector_names: z.array(z.string()).register(z.globalRegistry, {
      description:
        'List of human readable connector names that are present in the matched Attack discoveries. Useful for building client filters or summaries.',
    }),
    data: z
      .array(security_attack_discovery_api_attack_discovery_api_alert)
      .register(z.globalRegistry, {
        description:
          'Array of matched Attack discovery objects. Each item follows the `AttackDiscoveryApiAlert` schema.',
      }),
    page: z.int().register(z.globalRegistry, {
      description: 'Current page number of the paginated result set.',
    }),
    per_page: z.int().register(z.globalRegistry, {
      description: 'Number of items requested per page.',
    }),
    total: z.int().register(z.globalRegistry, {
      description: 'Total number of Attack discoveries matching the query (across all pages).',
    }),
    unique_alert_ids: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          'List of unique alert IDs aggregated from the matched Attack discoveries. Only present if `include_unique_alert_ids=true` in the request.',
      })
    ),
    unique_alert_ids_count: z.int().register(z.globalRegistry, {
      description:
        'Number of unique alert IDs across all matched Attack discoveries. Only present if `include_unique_alert_ids=true` in the request.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const post_attack_discovery_generate_request = z.object({
  body: security_attack_discovery_api_attack_discovery_generation_config,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Attack discovery generation initiated successfully
 */
export const post_attack_discovery_generate_response = z
  .object({
    execution_uuid: security_attack_discovery_api_non_empty_string,
  })
  .register(z.globalRegistry, {
    description: 'Attack discovery generation initiated successfully',
  });

export const get_attack_discovery_generations_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      end: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'End of the time range for filtering generations. Accepts absolute timestamps (ISO 8601) or relative date math (e.g. "now", "now-24h").',
        })
      ),
      size: z
        .optional(
          z.number().gte(1).register(z.globalRegistry, {
            description: 'The maximum number of generations to retrieve',
          })
        )
        .default(50),
      start: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Start of the time range for filtering generations. Accepts absolute timestamps (ISO 8601) or relative date math (e.g. "now-7d").',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const get_attack_discovery_generations_response = z
  .object({
    generations: z
      .array(security_attack_discovery_api_attack_discovery_generation)
      .register(z.globalRegistry, {
        description: 'List of attack discovery generations',
      }),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const get_attack_discovery_generation_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    execution_uuid: security_attack_discovery_api_non_empty_string,
  }),
  query: z.optional(
    z.object({
      enable_field_rendering: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Enables a markdown syntax used to render pivot fields, for example `{{ user.name james }}`. When disabled, the same example would be rendered as `james`. This is primarily used for Attack discovery views within Kibana. Defaults to `false`.',
          })
        )
        .default(false),
      with_replacements: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'When true, return the created Attack discoveries with text replacements applied to the detailsMarkdown, entitySummaryMarkdown, summaryMarkdown, and title fields. Defaults to `true`.',
          })
        )
        .default(true),
    })
  ),
});

/**
 * Successful response
 */
export const get_attack_discovery_generation_response = z
  .object({
    data: z
      .array(security_attack_discovery_api_attack_discovery_api_alert)
      .register(z.globalRegistry, {
        description: 'Array of Attack discoveries generated during this execution.',
      }),
    generation: z.optional(security_attack_discovery_api_attack_discovery_generation),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const post_attack_discovery_generations_dismiss_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    execution_uuid: security_attack_discovery_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Successful response - The attack discovery generation has been dismissed
 */
export const post_attack_discovery_generations_dismiss_response = z
  .object({
    alerts_context_count: z.optional(
      z.number().register(z.globalRegistry, {
        description:
          'The number of alerts that were sent as context to the LLM for this generation.',
      })
    ),
    connector_id: z.string().register(z.globalRegistry, {
      description:
        'The unique identifier of the connector used to generate the attack discoveries.',
    }),
    connector_stats: z.optional(
      z
        .object({
          average_successful_duration_nanoseconds: z.optional(
            z.number().register(z.globalRegistry, {
              description:
                'The average duration in nanoseconds for successful generations using this connector by the current user.',
            })
          ),
          successful_generations: z.optional(
            z.number().register(z.globalRegistry, {
              description:
                'The total number of Attack discoveries successfully created for this generation',
            })
          ),
        })
        .register(z.globalRegistry, {
          description:
            "Statistical information about the connector's performance for this user, providing insights into usage patterns and success rates.",
        })
    ),
    discoveries: z.number().register(z.globalRegistry, {
      description: 'The number of attack discoveries that were generated during this execution.',
    }),
    end: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "The timestamp when the generation process completed, in ISO 8601 format. This field may be absent for generations that haven't finished.",
      })
    ),
    execution_uuid: z.string().register(z.globalRegistry, {
      description:
        'The unique identifier for this attack discovery generation execution. This UUID can be used to reference this specific generation in other API calls.',
    }),
    loading_message: z.string().register(z.globalRegistry, {
      description:
        'A human-readable message describing the current state or progress of the generation process. Provides context about what the AI is analyzing.',
    }),
    reason: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Additional context or reasoning provided when a generation fails or encounters issues. This field helps diagnose problems with the generation process.',
      })
    ),
    start: z.string().register(z.globalRegistry, {
      description:
        'The timestamp when the generation process began, in ISO 8601 format. This marks the beginning of the AI analysis.',
    }),
    status: z
      .enum(['canceled', 'dismissed', 'failed', 'started', 'succeeded'])
      .register(z.globalRegistry, {
        description:
          'The current status of the attack discovery generation. After dismissing, this will be set to "dismissed".',
      }),
  })
  .register(z.globalRegistry, {
    description: 'Successful response - The attack discovery generation has been dismissed',
  });

export const create_attack_discovery_schedules_request = z.object({
  body: security_attack_discovery_api_attack_discovery_api_schedule_create_props,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successfully created Attack discovery schedule
 */
export const create_attack_discovery_schedules_response =
  security_attack_discovery_api_attack_discovery_api_schedule;

export const find_attack_discovery_schedules_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Page number to return (used for pagination). Defaults to 1.',
        })
      ),
      per_page: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Number of Attack discovery schedules to return per page (used for pagination). Defaults to 10.',
        })
      ),
      sort_field: z.optional(security_attack_discovery_api_non_empty_string),
      sort_direction: z.optional(
        z.enum(['asc', 'desc']).register(z.globalRegistry, {
          description:
            "Sort order direction. Use 'asc' for ascending or 'desc' for descending. Defaults to 'asc'.",
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const find_attack_discovery_schedules_response = z
  .object({
    data: z
      .array(security_attack_discovery_api_attack_discovery_api_schedule)
      .register(z.globalRegistry, {
        description: 'Array of matched Attack discovery schedule objects.',
      }),
    page: z.number().register(z.globalRegistry, {
      description: 'Current page number of the paginated result set.',
    }),
    per_page: z.number().register(z.globalRegistry, {
      description: 'Number of items requested per page.',
    }),
    total: z.number().register(z.globalRegistry, {
      description:
        'Total number of Attack discovery schedules matching the query (across all pages).',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const delete_attack_discovery_schedules_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_attack_discovery_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Successfully deleted Attack Discovery schedule, returning the ID of the deleted schedule for confirmation
 */
export const delete_attack_discovery_schedules_response = z
  .object({
    id: security_attack_discovery_api_non_empty_string,
  })
  .register(z.globalRegistry, {
    description:
      'Successfully deleted Attack Discovery schedule, returning the ID of the deleted schedule for confirmation',
  });

export const get_attack_discovery_schedules_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_attack_discovery_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Successfully retrieved Attack Discovery schedule with complete configuration and metadata
 */
export const get_attack_discovery_schedules_response =
  security_attack_discovery_api_attack_discovery_api_schedule;

export const update_attack_discovery_schedules_request = z.object({
  body: security_attack_discovery_api_attack_discovery_api_schedule_update_props,
  path: z.object({
    id: security_attack_discovery_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Successfully updated Attack Discovery schedule with the new configuration and metadata
 */
export const update_attack_discovery_schedules_response =
  security_attack_discovery_api_attack_discovery_api_schedule;

export const disable_attack_discovery_schedules_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_attack_discovery_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Successfully disabled Attack Discovery schedule, returning the schedule ID for confirmation
 */
export const disable_attack_discovery_schedules_response = z
  .object({
    id: security_attack_discovery_api_non_empty_string,
  })
  .register(z.globalRegistry, {
    description:
      'Successfully disabled Attack Discovery schedule, returning the schedule ID for confirmation',
  });

export const enable_attack_discovery_schedules_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_attack_discovery_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Successfully enabled Attack Discovery schedule, returning the schedule ID for confirmation
 */
export const enable_attack_discovery_schedules_response = z
  .object({
    id: security_attack_discovery_api_non_empty_string,
  })
  .register(z.globalRegistry, {
    description:
      'Successfully enabled Attack Discovery schedule, returning the schedule ID for confirmation',
  });

export const delete_case_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    ids: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The cases that you want to removed. All non-ASCII characters must be URL encoded.\n',
    }),
  }),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const delete_case_default_space_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const update_case_default_space_request = z.object({
  body: z.optional(cases_update_case_request),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const update_case_default_space_response = z
  .array(cases_case_response_properties)
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const create_case_default_space_request = z.object({
  body: cases_create_case_request,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const create_case_default_space_response = cases_case_response_properties;

export const find_cases_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      assignees: z.optional(z.union([cases_string, cases_string_array])),
      category: z.optional(z.union([cases_case_category, cases_case_categories])),
      defaultSearchOperator: z
        .optional(
          z.string().register(z.globalRegistry, {
            description: 'he default operator to use for the simple_query_string.',
          })
        )
        .default('OR'),
      from: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Returns only cases that were created after a specific date. The date must be specified as a KQL data range or date match expression.\n',
        })
      ),
      owner: z.optional(z.union([cases_owner, cases_owners])),
      page: z
        .optional(
          z.int().register(z.globalRegistry, {
            description: 'The page number to return.',
          })
        )
        .default(1),
      perPage: z
        .optional(
          z.int().lte(100).register(z.globalRegistry, {
            description: 'The number of items to return. Limited to 100 items.',
          })
        )
        .default(20),
      reporters: z.optional(z.union([cases_string, cases_string_array])),
      search: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'An Elasticsearch simple_query_string query that filters the objects in the response.',
        })
      ),
      searchFields: z.optional(z.union([cases_search_fields_type, cases_search_fields_type_array])),
      severity: z.optional(
        z.enum(['critical', 'high', 'low', 'medium']).register(z.globalRegistry, {
          description: 'The severity of the case.',
        })
      ),
      sortField: z.optional(
        z
          .enum(['createdAt', 'updatedAt', 'closedAt', 'title', 'category', 'status', 'severity'])
          .register(z.globalRegistry, {
            description: 'Determines which field is used to sort the results.',
          })
      ),
      sortOrder: z.optional(
        z.enum(['asc', 'desc']).register(z.globalRegistry, {
          description: 'Determines the sort order.',
        })
      ),
      status: z.optional(
        z.enum(['closed', 'in-progress', 'open']).register(z.globalRegistry, {
          description: 'Filters the returned cases by state.',
        })
      ),
      tags: z.optional(z.union([cases_string, cases_string_array])),
      to: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Returns only cases that were created before a specific date. The date must be specified as a KQL data range or date match expression.\n',
        })
      ),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const find_cases_default_space_response = z
  .object({
    cases: z.optional(z.array(cases_case_response_properties).max(10000)),
    count_closed_cases: z.optional(z.int()),
    count_in_progress_cases: z.optional(z.int()),
    count_open_cases: z.optional(z.int()),
    page: z.optional(z.int()),
    per_page: z.optional(z.int()),
    total: z.optional(z.int()),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_case_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_case_default_space_response = cases_case_response_properties;

export const get_case_alerts_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_case_alerts_default_space_response = z
  .array(cases_alert_response_properties)
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const delete_case_comments_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const delete_case_comments_default_space_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const update_case_comment_default_space_request = z.object({
  body: cases_update_case_comment_request,
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const update_case_comment_default_space_response = cases_case_response_properties;

export const add_case_comment_default_space_request = z.object({
  body: cases_add_case_comment_request,
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const add_case_comment_default_space_response = cases_case_response_properties;

export const find_case_comments_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
  }),
  query: z.optional(
    z.object({
      page: z
        .optional(
          z.int().register(z.globalRegistry, {
            description: 'The page number to return.',
          })
        )
        .default(1),
      perPage: z
        .optional(
          z.int().lte(100).register(z.globalRegistry, {
            description: 'The number of items to return. Limited to 100 items.',
          })
        )
        .default(20),
      sortOrder: z.optional(
        z.enum(['asc', 'desc']).register(z.globalRegistry, {
          description: 'Determines the sort order.',
        })
      ),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const find_case_comments_default_space_response = cases_case_response_properties;

export const delete_case_comment_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
    commentId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the comment. To retrieve comment IDs, use the get case or find cases APIs.\n',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const delete_case_comment_default_space_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const get_case_comment_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
    commentId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the comment. To retrieve comment IDs, use the get case or find cases APIs.\n',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_case_comment_default_space_response = z.union([
  cases_alert_comment_response_properties,
  cases_user_comment_response_properties,
]);

export const push_case_default_space_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
    connectorId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the connector. To retrieve connector IDs, use the find connectors API.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const push_case_default_space_response = cases_case_response_properties;

export const add_case_file_default_space_request = z.object({
  body: cases_add_case_file_request,
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const add_case_file_default_space_response = cases_case_response_properties;

export const find_case_activity_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    caseId: z.string().register(z.globalRegistry, {
      description:
        'The identifier for the case. To retrieve case IDs, use the find cases API. All non-ASCII characters must be URL encoded.',
    }),
  }),
  query: z.optional(
    z.object({
      page: z
        .optional(
          z.int().register(z.globalRegistry, {
            description: 'The page number to return.',
          })
        )
        .default(1),
      perPage: z
        .optional(
          z.int().lte(100).register(z.globalRegistry, {
            description: 'The number of items to return. Limited to 100 items.',
          })
        )
        .default(20),
      sortOrder: z.optional(
        z.enum(['asc', 'desc']).register(z.globalRegistry, {
          description: 'Determines the sort order.',
        })
      ),
      types: z.optional(
        z
          .array(
            z.enum([
              'action',
              'alert',
              'assignees',
              'attachment',
              'comment',
              'connector',
              'create_case',
              'description',
              'pushed',
              'settings',
              'severity',
              'status',
              'tags',
              'title',
              'user',
            ])
          )
          .register(z.globalRegistry, {
            description: 'Determines the types of user actions to return.',
          })
      ),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const find_case_activity_default_space_response = z
  .object({
    page: z.optional(z.int()),
    perPage: z.optional(z.int()),
    total: z.optional(z.int()),
    userActions: z.optional(z.array(cases_user_actions_find_response_properties).max(10000)),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_cases_by_alert_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    alertId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the alert.',
    }),
  }),
  query: z.optional(
    z.object({
      owner: z.optional(z.union([cases_owner, cases_owners])),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const get_cases_by_alert_default_space_response = z
  .array(
    z.object({
      id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The case identifier.',
        })
      ),
      title: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The case title.',
        })
      ),
    })
  )
  .max(10000)
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_case_configuration_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      owner: z.optional(z.union([cases_owner, cases_owners])),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const get_case_configuration_default_space_response = z
  .array(
    z.object({
      closure_type: z.optional(cases_closure_types),
      connector: z.optional(
        z.object({
          fields: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
          id: z.optional(
            z.string().register(z.globalRegistry, {
              description:
                'The identifier for the connector. If you do not want a default connector, use `none`. To retrieve connector IDs, use the find connectors API.',
            })
          ),
          name: z.optional(
            z.string().register(z.globalRegistry, {
              description:
                'The name of the connector. If you do not want a default connector, use `none`. To retrieve connector names, use the find connectors API.',
            })
          ),
          type: z.optional(cases_connector_types),
        })
      ),
      created_at: z.optional(z.iso.datetime()),
      created_by: z.optional(
        z.object({
          email: z.union([z.string(), z.null()]),
          full_name: z.union([z.string(), z.null()]),
          profile_uid: z.optional(z.string()),
          username: z.union([z.string(), z.null()]),
        })
      ),
      customFields: z.optional(
        z
          .array(
            z.object({
              defaultValue: z.optional(z.union([z.string(), z.boolean()])),
              key: z.optional(
                z.string().min(1).max(36).register(z.globalRegistry, {
                  description:
                    "A unique key for the custom field. Must be lower case and composed only of a-z, 0-9, '_', and '-' characters. It is used in API calls to refer to a specific custom field.\n",
                })
              ),
              label: z.optional(
                z.string().min(1).max(50).register(z.globalRegistry, {
                  description: 'The custom field label that is displayed in the case.',
                })
              ),
              type: z.optional(
                z.enum(['text', 'toggle']).register(z.globalRegistry, {
                  description: 'The type of the custom field.',
                })
              ),
              required: z.optional(
                z.boolean().register(z.globalRegistry, {
                  description:
                    'Indicates whether the field is required. If `false`, the custom field can be set to null or omitted when a case is created or updated.\n',
                })
              ),
            })
          )
          .register(z.globalRegistry, {
            description: 'Custom fields configuration details.',
          })
      ),
      error: z.optional(z.union([z.string(), z.null()])),
      id: z.optional(z.string()),
      mappings: z.optional(
        z.array(
          z.object({
            action_type: z.optional(z.string()),
            source: z.optional(z.string()),
            target: z.optional(z.string()),
          })
        )
      ),
      owner: z.optional(cases_owner),
      templates: z.optional(cases_templates),
      updated_at: z.optional(z.union([z.iso.datetime(), z.null()])),
      updated_by: z.optional(
        z.union([
          z.object({
            email: z.union([z.string(), z.null()]),
            full_name: z.union([z.string(), z.null()]),
            profile_uid: z.optional(z.string()),
            username: z.union([z.string(), z.null()]),
          }),
          z.null(),
        ])
      ),
      version: z.optional(z.string()),
    })
  )
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const set_case_configuration_default_space_request = z.object({
  body: z.optional(cases_set_case_configuration_request),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const set_case_configuration_default_space_response = z
  .object({
    closure_type: z.optional(cases_closure_types),
    connector: z.optional(
      z.object({
        fields: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
        id: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'The identifier for the connector. If you do not want a default connector, use `none`. To retrieve connector IDs, use the find connectors API.',
          })
        ),
        name: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'The name of the connector. If you do not want a default connector, use `none`. To retrieve connector names, use the find connectors API.',
          })
        ),
        type: z.optional(cases_connector_types),
      })
    ),
    created_at: z.optional(z.iso.datetime()),
    created_by: z.optional(
      z.object({
        email: z.union([z.string(), z.null()]),
        full_name: z.union([z.string(), z.null()]),
        profile_uid: z.optional(z.string()),
        username: z.union([z.string(), z.null()]),
      })
    ),
    customFields: z.optional(
      z
        .array(
          z.object({
            defaultValue: z.optional(z.union([z.string(), z.boolean()])),
            key: z.optional(
              z.string().min(1).max(36).register(z.globalRegistry, {
                description:
                  "A unique key for the custom field. Must be lower case and composed only of a-z, 0-9, '_', and '-' characters. It is used in API calls to refer to a specific custom field.\n",
              })
            ),
            label: z.optional(
              z.string().min(1).max(50).register(z.globalRegistry, {
                description: 'The custom field label that is displayed in the case.',
              })
            ),
            type: z.optional(
              z.enum(['text', 'toggle']).register(z.globalRegistry, {
                description: 'The type of the custom field.',
              })
            ),
            required: z.optional(
              z.boolean().register(z.globalRegistry, {
                description:
                  'Indicates whether the field is required. If `false`, the custom field can be set to null or omitted when a case is created or updated.\n',
              })
            ),
          })
        )
        .register(z.globalRegistry, {
          description: 'Custom fields configuration details.',
        })
    ),
    error: z.optional(z.union([z.string(), z.null()])),
    id: z.optional(z.string()),
    mappings: z.optional(
      z.array(
        z.object({
          action_type: z.optional(z.string()),
          source: z.optional(z.string()),
          target: z.optional(z.string()),
        })
      )
    ),
    owner: z.optional(cases_owner),
    templates: z.optional(cases_templates),
    updated_at: z.optional(z.union([z.iso.datetime(), z.null()])),
    updated_by: z.optional(
      z.union([
        z.object({
          email: z.union([z.string(), z.null()]),
          full_name: z.union([z.string(), z.null()]),
          profile_uid: z.optional(z.string()),
          username: z.union([z.string(), z.null()]),
        }),
        z.null(),
      ])
    ),
    version: z.optional(z.string()),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const update_case_configuration_default_space_request = z.object({
  body: z.optional(cases_update_case_configuration_request),
  path: z.object({
    configurationId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the configuration.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const update_case_configuration_default_space_response = z
  .object({
    closure_type: z.optional(cases_closure_types),
    connector: z.optional(
      z.object({
        fields: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
        id: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'The identifier for the connector. If you do not want a default connector, use `none`. To retrieve connector IDs, use the find connectors API.',
          })
        ),
        name: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'The name of the connector. If you do not want a default connector, use `none`. To retrieve connector names, use the find connectors API.',
          })
        ),
        type: z.optional(cases_connector_types),
      })
    ),
    created_at: z.optional(z.iso.datetime()),
    created_by: z.optional(
      z.object({
        email: z.union([z.string(), z.null()]),
        full_name: z.union([z.string(), z.null()]),
        profile_uid: z.optional(z.string()),
        username: z.union([z.string(), z.null()]),
      })
    ),
    customFields: z.optional(
      z
        .array(
          z.object({
            defaultValue: z.optional(z.union([z.string(), z.boolean()])),
            key: z.optional(
              z.string().min(1).max(36).register(z.globalRegistry, {
                description:
                  "A unique key for the custom field. Must be lower case and composed only of a-z, 0-9, '_', and '-' characters. It is used in API calls to refer to a specific custom field.\n",
              })
            ),
            label: z.optional(
              z.string().min(1).max(50).register(z.globalRegistry, {
                description: 'The custom field label that is displayed in the case.',
              })
            ),
            type: z.optional(
              z.enum(['text', 'toggle']).register(z.globalRegistry, {
                description: 'The type of the custom field.',
              })
            ),
            required: z.optional(
              z.boolean().register(z.globalRegistry, {
                description:
                  'Indicates whether the field is required. If `false`, the custom field can be set to null or omitted when a case is created or updated.\n',
              })
            ),
          })
        )
        .register(z.globalRegistry, {
          description: 'Custom fields configuration details.',
        })
    ),
    error: z.optional(z.union([z.string(), z.null()])),
    id: z.optional(z.string()),
    mappings: z.optional(
      z.array(
        z.object({
          action_type: z.optional(z.string()),
          source: z.optional(z.string()),
          target: z.optional(z.string()),
        })
      )
    ),
    owner: z.optional(cases_owner),
    templates: z.optional(cases_templates),
    updated_at: z.optional(z.union([z.iso.datetime(), z.null()])),
    updated_by: z.optional(
      z.union([
        z.object({
          email: z.union([z.string(), z.null()]),
          full_name: z.union([z.string(), z.null()]),
          profile_uid: z.optional(z.string()),
          username: z.union([z.string(), z.null()]),
        }),
        z.null(),
      ])
    ),
    version: z.optional(z.string()),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const find_case_connectors_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const find_case_connectors_default_space_response = z
  .array(
    z.object({
      actionTypeId: z.optional(cases_connector_types),
      config: z.optional(
        z.object({
          apiUrl: z.optional(z.string()),
          projectKey: z.optional(z.string()),
        })
      ),
      id: z.optional(z.string()),
      isDeprecated: z.optional(z.boolean()),
      isMissingSecrets: z.optional(z.boolean()),
      isPreconfigured: z.optional(z.boolean()),
      name: z.optional(z.string()),
      referencedByCount: z.optional(z.int()),
    })
  )
  .max(1000)
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_case_reporters_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      owner: z.optional(z.union([cases_owner, cases_owners])),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const get_case_reporters_default_space_response = z
  .array(
    z.object({
      email: z.union([z.string(), z.null()]),
      full_name: z.union([z.string(), z.null()]),
      profile_uid: z.optional(z.string()),
      username: z.union([z.string(), z.null()]),
    })
  )
  .max(10000)
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_case_tags_default_space_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      owner: z.optional(z.union([cases_owner, cases_owners])),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const get_case_tags_default_space_response = z
  .array(z.string())
  .max(10000)
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_all_data_views_default_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_all_data_views_default_response = z
  .object({
    data_view: z.optional(
      z.array(
        z.object({
          id: z.optional(z.string()),
          name: z.optional(z.string()),
          namespaces: z.optional(z.array(z.string())),
          title: z.optional(z.string()),
          typeMeta: z.optional(z.record(z.string(), z.unknown())),
        })
      )
    ),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const create_data_view_defaultw_request = z.object({
  body: data_views_create_data_view_request_object,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const create_data_view_defaultw_response = data_views_data_view_response_object;

export const delete_data_view_default_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    viewId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the data view.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const delete_data_view_default_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const get_data_view_default_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    viewId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the data view.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_data_view_default_response = data_views_data_view_response_object;

export const update_data_view_default_request = z.object({
  body: data_views_update_data_view_request_object,
  path: z.object({
    viewId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the data view.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const update_data_view_default_response = data_views_data_view_response_object;

export const update_fields_metadata_default_request = z.object({
  body: z.object({
    fields: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The field object.',
    }),
  }),
  path: z.object({
    viewId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the data view.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const update_fields_metadata_default_response = z
  .object({
    acknowledged: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const create_runtime_field_default_request = z.object({
  body: z.object({
    name: z.string().register(z.globalRegistry, {
      description: 'The name for a runtime field.\n',
    }),
    runtimeField: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The runtime field definition object.\n',
    }),
  }),
  path: z.object({
    viewId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the data view.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const create_runtime_field_default_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const create_update_runtime_field_default_request = z.object({
  body: z.object({
    name: z.string().register(z.globalRegistry, {
      description: 'The name for a runtime field.\n',
    }),
    runtimeField: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The runtime field definition object.\n',
    }),
  }),
  path: z.object({
    viewId: z.string().register(z.globalRegistry, {
      description: 'The ID of the data view fields you want to update.\n',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const create_update_runtime_field_default_response = z
  .object({
    data_view: z.optional(z.record(z.string(), z.unknown())),
    fields: z.optional(z.array(z.record(z.string(), z.unknown()))),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const delete_runtime_field_default_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    fieldName: z.string().register(z.globalRegistry, {
      description: 'The name of the runtime field.',
    }),
    viewId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the data view.',
    }),
  }),
  query: z.optional(z.never()),
});

export const get_runtime_field_default_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    fieldName: z.string().register(z.globalRegistry, {
      description: 'The name of the runtime field.',
    }),
    viewId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the data view.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_runtime_field_default_response = z
  .object({
    data_view: z.optional(z.record(z.string(), z.unknown())),
    fields: z.optional(z.array(z.record(z.string(), z.unknown()))),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const update_runtime_field_default_request = z.object({
  body: z.object({
    runtimeField: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'The runtime field definition object.\n\nYou can update following fields:\n\n- `type`\n- `script`\n',
    }),
  }),
  path: z.object({
    fieldName: z.string().register(z.globalRegistry, {
      description: 'The name of the runtime field.',
    }),
    viewId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the data view.',
    }),
  }),
  query: z.optional(z.never()),
});

export const get_default_data_view_default_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_default_data_view_default_response = z
  .object({
    data_view_id: z.optional(z.string()),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const set_default_datail_view_default_request = z.object({
  body: z.object({
    data_view_id: z.union([z.string(), z.null()]),
    force: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Update an existing default data view identifier.',
        })
      )
      .default(false),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const set_default_datail_view_default_response = z
  .object({
    acknowledged: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const swap_data_views_default_request = z.object({
  body: data_views_swap_data_view_request_object,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const swap_data_views_default_response = z
  .object({
    deleteStatus: z.optional(
      z.object({
        deletePerformed: z.optional(z.boolean()),
        remainingRefs: z.optional(z.int()),
      })
    ),
    result: z.optional(
      z.array(
        z.object({
          id: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'A saved object identifier.',
            })
          ),
          type: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The saved object type.',
            })
          ),
        })
      )
    ),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const preview_swap_data_views_default_request = z.object({
  body: data_views_swap_data_view_request_object,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const preview_swap_data_views_default_response = z
  .object({
    result: z.optional(
      z.array(
        z.object({
          id: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'A saved object identifier.',
            })
          ),
          type: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The saved object type.',
            })
          ),
        })
      )
    ),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const delete_alerts_index_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const delete_alerts_index_response = z
  .object({
    acknowledged: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const read_alerts_index_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const read_alerts_index_response = z
  .object({
    index_mapping_outdated: z.union([z.boolean(), z.null()]),
    name: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const create_alerts_index_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_alerts_index_response = z
  .object({
    acknowledged: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const read_privileges_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const read_privileges_response = z
  .object({
    has_encryption_key: z.boolean(),
    is_authenticated: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const delete_rule_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_detections_api_uuid),
      rule_id: z.optional(security_detections_api_rule_signature_id),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const delete_rule_response = security_detections_api_rule_response;

export const read_rule_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_detections_api_uuid),
      rule_id: z.optional(security_detections_api_rule_signature_id),
    })
  ),
});

/**
 * Indicates a successful call.
 * > info
 * > These fields are under development and their usage or schema may change: execution_summary.
 *
 */
export const read_rule_response = security_detections_api_rule_response;

export const patch_rule_request = z.object({
  body: security_detections_api_rule_patch_props,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const patch_rule_response = security_detections_api_rule_response;

export const create_rule_request = z.object({
  body: security_detections_api_rule_create_props,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const create_rule_response = security_detections_api_rule_response;

export const update_rule_request = z.object({
  body: security_detections_api_rule_update_props,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const update_rule_response = security_detections_api_rule_response;

export const perform_rules_bulk_action_request = z.object({
  body: z.optional(
    z.union([
      security_detections_api_bulk_delete_rules,
      security_detections_api_bulk_disable_rules,
      security_detections_api_bulk_enable_rules,
      security_detections_api_bulk_export_rules,
      security_detections_api_bulk_duplicate_rules,
      security_detections_api_bulk_manual_rule_run,
      security_detections_api_bulk_manual_rule_fill_gaps,
      security_detections_api_bulk_edit_rules,
    ])
  ),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      dry_run: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Enables dry run mode for the request call.\n\nEnable dry run mode to verify that bulk actions can be applied to specified rules. Certain rules, such as prebuilt Elastic rules on a Basic subscription, cant be edited and will return errors in the request response. Error details will contain an explanation, the rule name and/or ID, and additional troubleshooting information.\n\nTo enable dry run mode on a request, add the query parameter `dry_run=true` to the end of the request URL. Rules specified in the request will be temporarily updated. These updates wont be written to Elasticsearch.\n> info\n> Dry run mode is not supported for the `export` bulk action. A 400 error will be returned in the request response.\n',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const perform_rules_bulk_action_response = z.union([
  security_detections_api_bulk_edit_action_response,
  security_detections_api_bulk_export_action_response,
]);

export const export_rules_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        objects: z
          .array(
            z.object({
              rule_id: security_detections_api_rule_signature_id,
            })
          )
          .register(z.globalRegistry, {
            description:
              "Array of objects with a rule's `rule_id` field. Do not use rule's `id` here. Exports all rules when unspecified.",
          }),
      }),
      z.null(),
    ])
  ),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      exclude_export_details: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description: 'Determines whether a summary of the exported rules is returned.',
          })
        )
        .default(false),
      file_name: z
        .optional(
          z.string().register(z.globalRegistry, {
            description:
              'File name for saving the exported rules.\n> info\n> When using cURL to export rules to a file, use the -O and -J options to save the rules to the file name specified in the URL.\n',
          })
        )
        .default('export.ndjson'),
    })
  ),
});

/**
 * An `.ndjson` file containing the returned rules.
 *
 * Each line in the file represents an object (a rule, exception list parent container, or exception list item), and the last line includes a summary of what was exported.
 *
 */
export const export_rules_response = z.string().register(z.globalRegistry, {
  description:
    'An `.ndjson` file containing the returned rules.\n\nEach line in the file represents an object (a rule, exception list parent container, or exception list item), and the last line includes a summary of what was exported.\n',
});

export const find_rules_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      fields: z.optional(z.array(z.string())),
      filter: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Search query\n\nFilters the returned results according to the value of the specified field, using the alert.attributes.<field name>:<field value> syntax, where <field name> can be:\n- name\n- enabled\n- tags\n- createdBy\n- interval\n- updatedBy\n> info\n> Even though the JSON rule object uses created_by and updated_by fields, you must use createdBy and updatedBy fields in the filter.\n',
        })
      ),
      sort_field: z.optional(security_detections_api_find_rules_sort_field),
      sort_order: z.optional(security_detections_api_sort_order),
      page: z
        .optional(
          z.int().gte(1).register(z.globalRegistry, {
            description: 'Page number',
          })
        )
        .default(1),
      per_page: z
        .optional(
          z.int().gte(0).register(z.globalRegistry, {
            description: 'Rules per page',
          })
        )
        .default(20),
      gaps_range_start: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Gaps range start',
        })
      ),
      gaps_range_end: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Gaps range end',
        })
      ),
    })
  ),
});

/**
 * Successful response
 * > info
 * > These fields are under development and their usage or schema may change: execution_summary.
 *
 */
export const find_rules_response = z
  .object({
    data: z.array(security_detections_api_rule_response),
    page: z.int(),
    perPage: z.int(),
    total: z.int(),
  })
  .register(z.globalRegistry, {
    description:
      'Successful response\n> info\n> These fields are under development and their usage or schema may change: execution_summary.\n',
  });

export const import_rules_request = z.object({
  body: z.object({
    file: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The `.ndjson` file containing the rules.',
      })
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      overwrite: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Determines whether existing rules with the same `rule_id` are overwritten.',
          })
        )
        .default(false),
      overwrite_exceptions: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Determines whether existing exception lists with the same `list_id` are overwritten. Both the exception list container and its items are overwritten.',
          })
        )
        .default(false),
      overwrite_action_connectors: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Determines whether existing actions with the same `kibana.alert.rule.actions.id` are overwritten.',
          })
        )
        .default(false),
      as_new_list: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description: 'Generates a new list ID for each imported exception list.',
          })
        )
        .default(false),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const import_rules_response = z
  .object({
    action_connectors_errors: z.array(security_detections_api_error_schema),
    action_connectors_success: z.boolean(),
    action_connectors_success_count: z.int().gte(0),
    action_connectors_warnings: z.array(security_detections_api_warning_schema),
    errors: z.array(security_detections_api_error_schema),
    exceptions_errors: z.array(security_detections_api_error_schema),
    exceptions_success: z.boolean(),
    exceptions_success_count: z.int().gte(0),
    rules_count: z.int().gte(0),
    success: z.boolean(),
    success_count: z.int().gte(0),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const create_rule_exception_list_items_request = z.object({
  body: z
    .object({
      items: z.array(security_exceptions_api_create_rule_exception_list_item_props),
    })
    .register(z.globalRegistry, {
      description: 'Rule exception items.',
    }),
  path: z.object({
    id: security_exceptions_api_uuid,
  }),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_rule_exception_list_items_response = z
  .array(security_exceptions_api_exception_list_item)
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const install_prebuilt_rules_and_timelines_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const install_prebuilt_rules_and_timelines_response = z
  .object({
    rules_installed: z.int().gte(0).register(z.globalRegistry, {
      description: 'The number of rules installed',
    }),
    rules_updated: z.int().gte(0).register(z.globalRegistry, {
      description: 'The number of rules updated',
    }),
    timelines_installed: z.int().gte(0).register(z.globalRegistry, {
      description: 'The number of timelines installed',
    }),
    timelines_updated: z.int().gte(0).register(z.globalRegistry, {
      description: 'The number of timelines updated',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call',
  });

export const read_prebuilt_rules_and_timelines_status_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const read_prebuilt_rules_and_timelines_status_response = z
  .object({
    rules_custom_installed: z.int().gte(0).register(z.globalRegistry, {
      description: 'The total number of custom rules',
    }),
    rules_installed: z.int().gte(0).register(z.globalRegistry, {
      description: 'The total number of installed prebuilt rules',
    }),
    rules_not_installed: z.int().gte(0).register(z.globalRegistry, {
      description: 'The total number of available prebuilt rules that are not installed',
    }),
    rules_not_updated: z.int().gte(0).register(z.globalRegistry, {
      description: 'The total number of outdated prebuilt rules',
    }),
    timelines_installed: z.int().gte(0).register(z.globalRegistry, {
      description: 'The total number of installed prebuilt timelines',
    }),
    timelines_not_installed: z.int().gte(0).register(z.globalRegistry, {
      description: 'The total number of available prebuilt timelines that are not installed',
    }),
    timelines_not_updated: z.int().gte(0).register(z.globalRegistry, {
      description: 'The total number of outdated prebuilt timelines',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call',
  });

export const rule_preview_request = z.object({
  body: z.union([
    security_detections_api_eql_rule_create_props.and(security_detections_api_rule_preview_params),
    security_detections_api_query_rule_create_props.and(
      security_detections_api_rule_preview_params
    ),
    security_detections_api_saved_query_rule_create_props.and(
      security_detections_api_rule_preview_params
    ),
    security_detections_api_threshold_rule_create_props.and(
      security_detections_api_rule_preview_params
    ),
    security_detections_api_threat_match_rule_create_props.and(
      security_detections_api_rule_preview_params
    ),
    security_detections_api_machine_learning_rule_create_props.and(
      security_detections_api_rule_preview_params
    ),
    security_detections_api_new_terms_rule_create_props.and(
      security_detections_api_rule_preview_params
    ),
    security_detections_api_esql_rule_create_props.and(security_detections_api_rule_preview_params),
  ]),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      enable_logged_requests: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Enables logging and returning in response ES queries, performed during rule execution',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const rule_preview_response = z
  .object({
    isAborted: z.optional(z.boolean()),
    logs: z.array(security_detections_api_rule_preview_logs),
    previewId: z.optional(security_detections_api_non_empty_string),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const set_alert_assignees_request = z.object({
  body: z.object({
    assignees: security_detections_api_alert_assignees,
    ids: security_detections_api_alert_ids,
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const finalize_alerts_migration_request = z.object({
  body: z
    .object({
      migration_ids: z.array(z.string()).min(1).register(z.globalRegistry, {
        description: 'Array of `migration_id`s to finalize.',
      }),
    })
    .register(z.globalRegistry, {
      description: 'Array of `migration_id`s to finalize',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const finalize_alerts_migration_response = z
  .array(security_detections_api_migration_finalization_result)
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const alerts_migration_cleanup_request = z.object({
  body: z
    .object({
      migration_ids: z.array(z.string()).min(1).register(z.globalRegistry, {
        description: 'Array of `migration_id`s to cleanup.',
      }),
    })
    .register(z.globalRegistry, {
      description: 'Array of `migration_id`s to cleanup',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const alerts_migration_cleanup_response = z
  .array(security_detections_api_migration_cleanup_result)
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const create_alerts_migration_request = z.object({
  body: z
    .object({
      index: z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'Array of index names to migrate.',
      }),
    })
    .and(security_detections_api_alerts_reindex_options),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_alerts_migration_response = z
  .object({
    indices: z.array(
      z.union([
        security_detections_api_alerts_index_migration_success,
        security_detections_api_alerts_index_migration_error,
        security_detections_api_skipped_alerts_index_migration,
      ])
    ),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const read_alerts_migration_status_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    from: z.string().register(z.globalRegistry, {
      description:
        'Time from which data is analyzed. For example, now-4200s means the rule analyzes data from 70 minutes\nbefore its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).\n',
    }),
  }),
});

/**
 * Successful response
 */
export const read_alerts_migration_status_response = z
  .object({
    indices: z.array(security_detections_api_index_migration_status),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const search_alerts_request = z.object({
  body: z
    .object({
      _source: z.optional(z.union([z.boolean(), z.string(), z.array(z.string())])),
      aggs: z.optional(z.record(z.string(), z.unknown())),
      fields: z.optional(z.array(z.string())),
      query: z.optional(z.record(z.string(), z.unknown())),
      runtime_mappings: z.optional(z.record(z.string(), z.unknown())),
      size: z.optional(z.int().gte(0)),
      sort: z.optional(security_detections_api_alerts_sort),
      track_total_hits: z.optional(z.boolean()),
    })
    .register(z.globalRegistry, {
      description: 'Elasticsearch query and aggregation request',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Elasticsearch search response
 */
export const search_alerts_response = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
  description: 'Elasticsearch search response',
});

export const set_alerts_status_request = z.object({
  body: z.union([
    security_detections_api_set_alerts_status_by_ids,
    security_detections_api_set_alerts_status_by_query,
  ]),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Elasticsearch update by query response
 */
export const set_alerts_status_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Elasticsearch update by query response',
  });

export const set_alert_tags_request = z.object({
  body: z
    .object({
      ids: security_detections_api_alert_ids,
      tags: security_detections_api_set_alert_tags,
    })
    .register(z.globalRegistry, {
      description:
        'An object containing tags to add or remove and alert ids the changes will be applied',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Elasticsearch update by query response
 */
export const set_alert_tags_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Elasticsearch update by query response',
  });

export const read_tags_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const read_tags_response = security_detections_api_rule_tag_array;

export const rotate_encryption_key_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      batch_size: z
        .optional(
          z.number().register(z.globalRegistry, {
            description:
              'Specifies a maximum number of saved objects that Kibana can process in a single batch. Bulk key rotation is an iterative process since Kibana may not be able to fetch and process all required saved objects in one go and splits processing into consequent batches. By default, the batch size is 10000, which is also a maximum allowed value.\n',
          })
        )
        .default(10000),
      type: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Limits encryption key rotation only to the saved objects with the specified type. By default, Kibana tries to rotate the encryption key for all saved object types that may contain encrypted attributes.\n',
        })
      ),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const rotate_encryption_key_response = z
  .object({
    failed: z.optional(
      z.number().register(z.globalRegistry, {
        description:
          'Indicates the number of the saved objects that were still encrypted with one of the old encryption keys that Kibana failed to re-encrypt with the primary key.\n',
      })
    ),
    successful: z.optional(
      z.number().register(z.globalRegistry, {
        description:
          'Indicates the total number of all encrypted saved objects (optionally filtered by the requested `type`), regardless of the key Kibana used for encryption.\n\nNOTE: In most cases, `total` will be greater than `successful` even if `failed` is zero. The reason is that Kibana may not need or may not be able to rotate encryption keys for all encrypted saved objects.\n',
      })
    ),
    total: z.optional(
      z.number().register(z.globalRegistry, {
        description:
          'Indicates the total number of all encrypted saved objects (optionally filtered by the requested `type`), regardless of the key Kibana used for encryption.\n',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const create_endpoint_list_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_endpoint_list_response = security_endpoint_exceptions_api_endpoint_list;

export const delete_endpoint_list_item_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_endpoint_exceptions_api_exception_list_item_id),
      item_id: z.optional(security_endpoint_exceptions_api_exception_list_item_human_id),
    })
  ),
});

/**
 * Successful response
 */
export const delete_endpoint_list_item_response =
  security_endpoint_exceptions_api_exception_list_item;

export const read_endpoint_list_item_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_endpoint_exceptions_api_exception_list_item_id),
      item_id: z.optional(security_endpoint_exceptions_api_exception_list_item_human_id),
    })
  ),
});

/**
 * Successful response
 */
export const read_endpoint_list_item_response = z
  .array(security_endpoint_exceptions_api_exception_list_item)
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const create_endpoint_list_item_request = z.object({
  body: z
    .object({
      comments: z.optional(security_endpoint_exceptions_api_exception_list_item_comment_array),
      description: security_endpoint_exceptions_api_exception_list_item_description,
      entries: security_endpoint_exceptions_api_exception_list_item_entry_array,
      item_id: z.optional(security_endpoint_exceptions_api_exception_list_item_human_id),
      meta: z.optional(security_endpoint_exceptions_api_exception_list_item_meta),
      name: security_endpoint_exceptions_api_exception_list_item_name,
      os_types: z.optional(security_endpoint_exceptions_api_exception_list_item_os_type_array),
      tags: z.optional(security_endpoint_exceptions_api_exception_list_item_tags),
      type: security_endpoint_exceptions_api_exception_list_item_type,
    })
    .register(z.globalRegistry, {
      description: "Exception list item's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_endpoint_list_item_response =
  security_endpoint_exceptions_api_exception_list_item;

export const update_endpoint_list_item_request = z.object({
  body: z
    .object({
      _version: z.optional(z.string()),
      comments: z.optional(security_endpoint_exceptions_api_exception_list_item_comment_array),
      description: security_endpoint_exceptions_api_exception_list_item_description,
      entries: security_endpoint_exceptions_api_exception_list_item_entry_array,
      id: z.optional(security_endpoint_exceptions_api_exception_list_item_id),
      item_id: z.optional(security_endpoint_exceptions_api_exception_list_item_human_id),
      meta: z.optional(security_endpoint_exceptions_api_exception_list_item_meta),
      name: security_endpoint_exceptions_api_exception_list_item_name,
      os_types: z.optional(security_endpoint_exceptions_api_exception_list_item_os_type_array),
      tags: z.optional(security_endpoint_exceptions_api_exception_list_item_tags),
      type: security_endpoint_exceptions_api_exception_list_item_type,
    })
    .register(z.globalRegistry, {
      description: "Exception list item's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const update_endpoint_list_item_response =
  security_endpoint_exceptions_api_exception_list_item;

export const find_endpoint_list_items_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      filter: z.optional(security_endpoint_exceptions_api_non_empty_string),
      page: z.optional(
        z.int().gte(0).register(z.globalRegistry, {
          description: 'The page number to return',
        })
      ),
      per_page: z.optional(
        z.int().gte(0).register(z.globalRegistry, {
          description: 'The number of exception list items to return per page',
        })
      ),
      sort_field: z.optional(security_endpoint_exceptions_api_non_empty_string),
      sort_order: z.optional(
        z.enum(['desc', 'asc']).register(z.globalRegistry, {
          description: 'Determines the sort order, which can be `desc` or `asc`',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const find_endpoint_list_items_response = z
  .object({
    data: z.array(security_endpoint_exceptions_api_exception_list_item),
    page: z.int().gte(0),
    per_page: z.int().gte(0),
    pit: z.optional(z.string()),
    total: z.int().gte(0),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const endpoint_get_actions_list_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(security_endpoint_management_api_page),
      pageSize: z.optional(security_endpoint_management_api_page_size),
      commands: z.optional(security_endpoint_management_api_commands),
      agentIds: z.optional(security_endpoint_management_api_agent_ids),
      userIds: z.optional(security_endpoint_management_api_user_ids),
      startDate: z.optional(security_endpoint_management_api_start_date),
      endDate: z.optional(security_endpoint_management_api_end_date),
      agentTypes: z.optional(security_endpoint_management_api_agent_types),
      withOutputs: z.optional(security_endpoint_management_api_with_outputs),
      types: z.optional(security_endpoint_management_api_types),
    })
  ),
});

/**
 * OK
 */
export const endpoint_get_actions_list_response =
  security_endpoint_management_api_get_endpoint_action_list_response;

export const endpoint_get_actions_status_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    query: z.object({
      agent_ids: z.optional(security_endpoint_management_api_agent_ids),
    }),
  }),
});

/**
 * OK
 */
export const endpoint_get_actions_status_response =
  security_endpoint_management_api_action_status_success_response;

export const endpoint_get_actions_details_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    action_id: z.string().register(z.globalRegistry, {
      description: 'The ID of the action to retrieve.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_get_actions_details_response =
  security_endpoint_management_api_action_details_response;

export const endpoint_file_info_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    action_id: z.string(),
    file_id: z.string().register(z.globalRegistry, {
      description:
        'The file identifier is constructed in one of two ways:\n- For Elastic Defend agents (`agentType` of `endpoint`): combine the `action_id` and `agent_id` values using a dot (`.`) separator:\n`{file_id}` = `{action_id}.{agent_id}`\n- For all other agent types: the `file_id` is the `agent_id` for which the response action was sent to.\n',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_file_info_response = z
  .object({
    data: z.optional(
      z.object({
        actionId: z.optional(z.string()),
        agentId: z.optional(z.string()),
        agentType: z.optional(z.string()),
        created: z.optional(z.iso.datetime()),
        id: z.optional(z.string()),
        mimeType: z.optional(z.string()),
        name: z.optional(z.string()),
        size: z.optional(z.number()),
        status: z.optional(
          z.enum(['AWAITING_UPLOAD', 'UPLOADING', 'READY', 'UPLOAD_ERROR', 'DELETED'])
        ),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK',
  });

export const endpoint_file_download_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    action_id: z.string(),
    file_id: z.string().register(z.globalRegistry, {
      description:
        'The file identifier is constructed in one of two ways:\n- For Elastic Defend agents (`agentType` of `endpoint`): combine the `action_id` and `agent_id` values using a dot (`.`) separator:\n`{file_id}` = `{action_id}.{agent_id}`\n- For all other agent types: the `file_id` is the `agent_id` for which the response action was sent to.\n',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_file_download_response = z.string().register(z.globalRegistry, {
  description: 'OK',
});

export const cancel_action_request = z.object({
  body: security_endpoint_management_api_cancel_route_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successfully cancelled the response action
 */
export const cancel_action_response =
  security_endpoint_management_api_response_action_create_success_response;

export const endpoint_execute_action_request = z.object({
  body: security_endpoint_management_api_execute_route_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_execute_action_response =
  security_endpoint_management_api_execute_route_response;

export const endpoint_get_file_action_request = z.object({
  body: security_endpoint_management_api_get_file_route_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_get_file_action_response =
  security_endpoint_management_api_get_file_route_response;

export const endpoint_isolate_action_request = z.object({
  body: z.object({
    agent_type: z.optional(security_endpoint_management_api_agent_types),
    alert_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description:
          'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
      })
    ),
    case_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'The IDs of cases where the action taken will be logged.',
      })
    ),
    comment: z.optional(security_endpoint_management_api_comment),
    endpoint_ids: security_endpoint_management_api_endpoint_ids,
    parameters: z.optional(security_endpoint_management_api_parameters),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_isolate_action_response =
  security_endpoint_management_api_isolate_route_response;

export const endpoint_kill_process_action_request = z.object({
  body: security_endpoint_management_api_kill_process_route_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_kill_process_action_response =
  security_endpoint_management_api_kill_process_route_response;

export const endpoint_get_processes_action_request = z.object({
  body: security_endpoint_management_api_get_processes_route_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_get_processes_action_response =
  security_endpoint_management_api_get_processes_route_response;

export const run_script_action_request = z.object({
  body: security_endpoint_management_api_run_script_route_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Action request was successfully created
 */
export const run_script_action_response =
  security_endpoint_management_api_response_action_create_success_response;

export const endpoint_scan_action_request = z.object({
  body: security_endpoint_management_api_scan_route_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_scan_action_response = security_endpoint_management_api_scan_route_response;

export const endpoint_get_actions_state_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_get_actions_state_response =
  security_endpoint_management_api_action_state_success_response;

export const endpoint_suspend_process_action_request = z.object({
  body: security_endpoint_management_api_suspend_process_route_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_suspend_process_action_response =
  security_endpoint_management_api_suspend_process_route_response;

export const endpoint_unisolate_action_request = z.object({
  body: z.object({
    agent_type: z.optional(security_endpoint_management_api_agent_types),
    alert_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description:
          'If this action is associated with any alerts, they can be specified here. The action will be logged in any cases associated with the specified alerts.',
      })
    ),
    case_ids: z.optional(
      z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'The IDs of cases where the action taken will be logged.',
      })
    ),
    comment: z.optional(security_endpoint_management_api_comment),
    endpoint_ids: security_endpoint_management_api_endpoint_ids,
    parameters: z.optional(security_endpoint_management_api_parameters),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_unisolate_action_response =
  security_endpoint_management_api_unisolate_route_response;

export const endpoint_upload_action_request = z.object({
  body: security_endpoint_management_api_upload_route_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const endpoint_upload_action_response =
  security_endpoint_management_api_upload_route_response;

export const get_endpoint_metadata_list_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    page: z.optional(security_endpoint_management_api_page),
    pageSize: z.optional(security_endpoint_management_api_page_size),
    kuery: z.optional(security_endpoint_management_api_kuery),
    hostStatuses: security_endpoint_management_api_host_statuses,
    sortField: z.optional(security_endpoint_management_api_sort_field),
    sortDirection: z.optional(security_endpoint_management_api_sort_direction),
  }),
});

/**
 * OK
 */
export const get_endpoint_metadata_list_response =
  security_endpoint_management_api_metadata_list_response;

export const get_endpoint_metadata_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const get_endpoint_metadata_response =
  security_endpoint_management_api_endpoint_metadata_response;

export const get_policy_response_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    query: z.object({
      agentId: z.optional(security_endpoint_management_api_agent_id),
    }),
  }),
});

/**
 * OK
 */
export const get_policy_response_response = security_endpoint_management_api_success_response;

export const get_protection_updates_note_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    package_policy_id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const get_protection_updates_note_response =
  security_endpoint_management_api_protection_updates_note_response;

export const create_update_protection_updates_note_request = z.object({
  body: z.object({
    note: z.optional(z.string()),
  }),
  path: z.object({
    package_policy_id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const create_update_protection_updates_note_response =
  security_endpoint_management_api_protection_updates_note_response;

export const delete_monitoring_engine_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      data: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description: 'Whether to delete all the privileged user data',
          })
        )
        .default(false),
    })
  ),
});

/**
 * Successful response
 */
export const delete_monitoring_engine_response = z
  .object({
    deleted: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const disable_monitoring_engine_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const disable_monitoring_engine_response =
  security_entity_analytics_api_monitoring_engine_descriptor;

export const init_monitoring_engine_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const init_monitoring_engine_response =
  security_entity_analytics_api_monitoring_engine_descriptor;

export const schedule_monitoring_engine_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const schedule_monitoring_engine_response = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Indicates the scheduling was successful',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const priv_mon_health_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const priv_mon_health_response = z
  .object({
    error: z.optional(
      z.object({
        message: z.optional(z.string()),
      })
    ),
    status: security_entity_analytics_api_privilege_monitoring_engine_status,
    users: z.optional(
      z
        .object({
          current_count: z.int().register(z.globalRegistry, {
            description: 'Current number of privileged users being monitored',
          }),
          max_allowed: z.int().register(z.globalRegistry, {
            description: 'Maximum number of privileged users allowed to be monitored',
          }),
        })
        .register(z.globalRegistry, {
          description: 'User statistics for privilege monitoring',
        })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const priv_mon_privileges_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const priv_mon_privileges_response =
  security_entity_analytics_api_entity_analytics_privileges;

export const create_priv_mon_user_request = z.object({
  body: security_entity_analytics_api_user_name,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * User created successfully
 */
export const create_priv_mon_user_response = security_entity_analytics_api_monitored_user_doc;

export const privmon_bulk_upload_users_csv_request = z.object({
  body: z.optional(
    z.object({
      file: z.string().register(z.globalRegistry, {
        description: 'The CSV file to upload.',
      }),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Bulk upload successful
 */
export const privmon_bulk_upload_users_csv_response = z
  .object({
    errors: z.array(security_entity_analytics_api_privmon_user_csv_upload_error_item),
    stats: security_entity_analytics_api_privmon_user_csv_upload_stats,
  })
  .register(z.globalRegistry, {
    description: 'Bulk upload successful',
  });

export const delete_priv_mon_user_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * User deleted successfully
 */
export const delete_priv_mon_user_response = z
  .object({
    acknowledged: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Indicates if the deletion was successful',
      })
    ),
    message: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'A message providing additional information about the deletion status',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'User deleted successfully',
  });

export const update_priv_mon_user_request = z.object({
  body: security_entity_analytics_api_monitored_user_update_doc,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * User updated successfully
 */
export const update_priv_mon_user_response = security_entity_analytics_api_monitored_user_doc;

export const list_priv_mon_users_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      kql: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'KQL query to filter the list of monitored users',
        })
      ),
    })
  ),
});

/**
 * List of monitored users
 */
export const list_priv_mon_users_response = z
  .array(security_entity_analytics_api_monitored_user_doc)
  .register(z.globalRegistry, {
    description: 'List of monitored users',
  });

export const install_privileged_access_detection_package_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const install_privileged_access_detection_package_response = z
  .object({
    message: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const get_privileged_access_detection_package_status_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Privileged access detection status retrieved
 */
export const get_privileged_access_detection_package_status_response = z
  .object({
    jobs: z.array(
      z.object({
        description: z.optional(z.string()),
        job_id: z.string(),
        state: z.enum(['closing', 'closed', 'opened', 'failed', 'opening']),
      })
    ),
    ml_module_setup_status: z.enum(['complete', 'incomplete']),
    package_installation_status: z.enum(['complete', 'incomplete']),
  })
  .register(z.globalRegistry, {
    description: 'Privileged access detection status retrieved',
  });

export const init_entity_store_request = z.object({
  body: z
    .object({
      delay: z
        .optional(
          z
            .string()
            .regex(/[smdh]$/)
            .register(z.globalRegistry, {
              description: 'The delay before the transform will run.',
            })
        )
        .default('1m'),
      docsPerSecond: z
        .optional(
          z.int().register(z.globalRegistry, {
            description: 'The number of documents per second to process.',
          })
        )
        .default(-1),
      enrichPolicyExecutionInterval: z.optional(security_entity_analytics_api_interval),
      entityTypes: z.optional(z.array(security_entity_analytics_api_entity_type)),
      fieldHistoryLength: z
        .optional(
          z.int().register(z.globalRegistry, {
            description: 'The number of historical values to keep for each field.',
          })
        )
        .default(10),
      filter: z.optional(z.string()),
      frequency: z
        .optional(
          z
            .string()
            .regex(/[smdh]$/)
            .register(z.globalRegistry, {
              description: 'The frequency at which the transform will run.',
            })
        )
        .default('1m'),
      indexPattern: z.optional(security_entity_analytics_api_index_pattern),
      lookbackPeriod: z
        .optional(
          z
            .string()
            .regex(/[smdh]$/)
            .register(z.globalRegistry, {
              description:
                'The amount of time the transform looks back to calculate the aggregations.',
            })
        )
        .default('3h'),
      maxPageSearchSize: z
        .optional(
          z.int().register(z.globalRegistry, {
            description:
              'The initial page size to use for the composite aggregation of each checkpoint.',
          })
        )
        .default(500),
      timeout: z
        .optional(
          z
            .string()
            .regex(/[smdh]$/)
            .register(z.globalRegistry, {
              description: 'The timeout for initializing the aggregating transform.',
            })
        )
        .default('180s'),
      timestampField: z
        .optional(
          z.string().register(z.globalRegistry, {
            description: 'The field to use as the timestamp.',
          })
        )
        .default('@timestamp'),
    })
    .register(z.globalRegistry, {
      description: 'Schema for the entity store initialization',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const init_entity_store_response = z
  .object({
    engines: z.optional(z.array(security_entity_analytics_api_engine_descriptor)),
    succeeded: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const delete_entity_engines_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      entityTypes: z.optional(
        z.array(security_entity_analytics_api_entity_type).register(z.globalRegistry, {
          description:
            'Array of engine types to delete. Empty by default, which results in all the engines being deleted.',
        })
      ),
      delete_data: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Control flag to also delete the entity data.',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const delete_entity_engines_response = z
  .object({
    deleted: z.optional(z.array(security_entity_analytics_api_entity_type)),
    still_running: z.optional(z.array(security_entity_analytics_api_entity_type)),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const list_entity_engines_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const list_entity_engines_response = z
  .object({
    count: z.optional(z.int()),
    engines: z.optional(z.array(security_entity_analytics_api_engine_descriptor)),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const delete_entity_engine_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    entityType: security_entity_analytics_api_entity_type,
  }),
  query: z.optional(
    z.object({
      delete_data: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Control flag to also delete the entity data.',
        })
      ),
      data: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Control flag to also delete the entity data.',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const delete_entity_engine_response = z
  .object({
    deleted: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const get_entity_engine_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    entityType: security_entity_analytics_api_entity_type,
  }),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const get_entity_engine_response = security_entity_analytics_api_engine_descriptor;

export const init_entity_engine_request = z.object({
  body: z
    .object({
      delay: z
        .optional(
          z
            .string()
            .regex(/[smdh]$/)
            .register(z.globalRegistry, {
              description: 'The delay before the transform will run.',
            })
        )
        .default('1m'),
      docsPerSecond: z
        .optional(
          z.int().register(z.globalRegistry, {
            description: 'The number of documents per second to process.',
          })
        )
        .default(-1),
      enrichPolicyExecutionInterval: z.optional(security_entity_analytics_api_interval),
      fieldHistoryLength: z
        .optional(
          z.int().register(z.globalRegistry, {
            description: 'The number of historical values to keep for each field.',
          })
        )
        .default(10),
      filter: z.optional(z.string()),
      frequency: z
        .optional(
          z
            .string()
            .regex(/[smdh]$/)
            .register(z.globalRegistry, {
              description: 'The frequency at which the transform will run.',
            })
        )
        .default('1m'),
      indexPattern: z.optional(security_entity_analytics_api_index_pattern),
      lookbackPeriod: z
        .optional(
          z
            .string()
            .regex(/[smdh]$/)
            .register(z.globalRegistry, {
              description:
                'The amount of time the transform looks back to calculate the aggregations.',
            })
        )
        .default('3h'),
      maxPageSearchSize: z
        .optional(
          z.int().register(z.globalRegistry, {
            description:
              'The initial page size to use for the composite aggregation of each checkpoint.',
          })
        )
        .default(500),
      timeout: z
        .optional(
          z
            .string()
            .regex(/[smdh]$/)
            .register(z.globalRegistry, {
              description: 'The timeout for initializing the aggregating transform.',
            })
        )
        .default('180s'),
      timestampField: z
        .optional(
          z.string().register(z.globalRegistry, {
            description: 'The field to use as the timestamp for the entity type.',
          })
        )
        .default('@timestamp'),
    })
    .register(z.globalRegistry, {
      description: 'Schema for the engine initialization',
    }),
  path: z.object({
    entityType: security_entity_analytics_api_entity_type,
  }),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const init_entity_engine_response = security_entity_analytics_api_engine_descriptor;

export const start_entity_engine_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    entityType: security_entity_analytics_api_entity_type,
  }),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const start_entity_engine_response = z
  .object({
    started: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const stop_entity_engine_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    entityType: security_entity_analytics_api_entity_type,
  }),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const stop_entity_engine_response = z
  .object({
    stopped: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const apply_entity_engine_dataview_indices_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const apply_entity_engine_dataview_indices_response = z.union([
  z
    .object({
      result: z.optional(z.array(security_entity_analytics_api_engine_dataview_update_result)),
      success: z.optional(z.boolean()),
    })
    .register(z.globalRegistry, {
      description: 'Successful response',
    }),
  z
    .object({
      errors: z.optional(z.array(z.string())),
      result: z.optional(z.array(security_entity_analytics_api_engine_dataview_update_result)),
      success: z.optional(z.boolean()),
    })
    .register(z.globalRegistry, {
      description: 'Partial successful response',
    }),
]);

export const delete_single_entity_request = z.object({
  body: z
    .object({
      id: z.string().register(z.globalRegistry, {
        description: 'Identifier of the entity to be deleted, commonly entity.id value.',
      }),
    })
    .register(z.globalRegistry, {
      description: 'Schema for the deleting entity',
    }),
  path: z.object({
    entityType: security_entity_analytics_api_entity_type,
  }),
  query: z.optional(z.never()),
});

/**
 * Successful response. Entity deleted.
 */
export const delete_single_entity_response = z
  .object({
    deleted: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description: 'Successful response. Entity deleted.',
  });

export const upsert_entity_request = z.object({
  body: security_entity_analytics_api_entity,
  path: z.object({
    entityType: security_entity_analytics_api_entity_type,
  }),
  query: z.optional(
    z.object({
      force: z.optional(z.boolean()).default(false),
    })
  ),
});

/**
 * Entity updated or created
 */
export const upsert_entity_response = security_entity_analytics_api_entity;

export const upsert_entities_bulk_request = z.object({
  body: security_entity_analytics_api_entities_container,
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      force: z.optional(z.boolean()).default(false),
    })
  ),
});

export const list_entities_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    sort_field: z.optional(z.string()),
    sort_order: z.optional(z.enum(['asc', 'desc'])),
    page: z.optional(z.int().gte(1)),
    per_page: z.optional(z.int().gte(1).lte(10000)),
    filterQuery: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'An ES query to filter by.',
      })
    ),
    entity_types: z.array(security_entity_analytics_api_entity_type),
  }),
});

/**
 * Entities returned successfully
 */
export const list_entities_response = z
  .object({
    inspect: z.optional(security_entity_analytics_api_inspect_query),
    page: z.int().gte(1),
    per_page: z.int().gte(1).lte(1000),
    records: z.array(security_entity_analytics_api_entity),
    total: z.int().gte(0),
  })
  .register(z.globalRegistry, {
    description: 'Entities returned successfully',
  });

export const get_entity_store_status_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      include_components: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If true returns a detailed status of the engine including all it's components",
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const get_entity_store_status_response = z
  .object({
    engines: z.array(
      security_entity_analytics_api_engine_descriptor.and(
        z.object({
          components: z.optional(z.array(security_entity_analytics_api_engine_component_status)),
        })
      )
    ),
    status: security_entity_analytics_api_store_status,
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const delete_exception_list_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_exceptions_api_exception_list_id),
      list_id: z.optional(security_exceptions_api_exception_list_human_id),
      namespace_type: z.optional(security_exceptions_api_exception_namespace_type),
    })
  ),
});

/**
 * Successful response
 */
export const delete_exception_list_response = security_exceptions_api_exception_list;

export const read_exception_list_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_exceptions_api_exception_list_id),
      list_id: z.optional(security_exceptions_api_exception_list_human_id),
      namespace_type: z.optional(security_exceptions_api_exception_namespace_type),
    })
  ),
});

/**
 * Successful response
 */
export const read_exception_list_response = security_exceptions_api_exception_list;

export const create_exception_list_request = z.object({
  body: z
    .object({
      description: security_exceptions_api_exception_list_description,
      list_id: z.optional(security_exceptions_api_exception_list_human_id),
      meta: z.optional(security_exceptions_api_exception_list_meta),
      name: security_exceptions_api_exception_list_name,
      namespace_type: z.optional(security_exceptions_api_exception_namespace_type),
      os_types: z.optional(security_exceptions_api_exception_list_os_type_array),
      tags: z.optional(security_exceptions_api_exception_list_tags),
      type: security_exceptions_api_exception_list_type,
      version: z.optional(security_exceptions_api_exception_list_version),
    })
    .register(z.globalRegistry, {
      description: "Exception list's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_exception_list_response = security_exceptions_api_exception_list;

export const update_exception_list_request = z.object({
  body: z
    .object({
      _version: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The version id, normally returned by the API when the item was retrieved. Use it ensure updates are done against the latest version.',
        })
      ),
      description: security_exceptions_api_exception_list_description,
      id: z.optional(security_exceptions_api_exception_list_id),
      list_id: z.optional(security_exceptions_api_exception_list_human_id),
      meta: z.optional(security_exceptions_api_exception_list_meta),
      name: security_exceptions_api_exception_list_name,
      namespace_type: z.optional(security_exceptions_api_exception_namespace_type),
      os_types: z.optional(security_exceptions_api_exception_list_os_type_array),
      tags: z.optional(security_exceptions_api_exception_list_tags),
      type: security_exceptions_api_exception_list_type,
      version: z.optional(security_exceptions_api_exception_list_version),
    })
    .register(z.globalRegistry, {
      description: "Exception list's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const update_exception_list_response = security_exceptions_api_exception_list;

export const duplicate_exception_list_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    list_id: security_exceptions_api_exception_list_human_id,
    namespace_type: security_exceptions_api_exception_namespace_type,
    include_expired_exceptions: z.enum(['true', 'false']).register(z.globalRegistry, {
      description:
        'Determines whether to include expired exceptions in the duplicated list. Expiration date defined by `expire_time`.',
    }),
  }),
});

/**
 * Successful response
 */
export const duplicate_exception_list_response = security_exceptions_api_exception_list;

export const export_exception_list_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    id: security_exceptions_api_exception_list_id,
    list_id: security_exceptions_api_exception_list_human_id,
    namespace_type: security_exceptions_api_exception_namespace_type,
    include_expired_exceptions: z.enum(['true', 'false']).register(z.globalRegistry, {
      description:
        'Determines whether to include expired exceptions in the exported list. Expiration date defined by `expire_time`.',
    }),
  }),
});

/**
 * A `.ndjson` file containing specified exception list and its items
 */
export const export_exception_list_response = z.string().register(z.globalRegistry, {
  description: 'A `.ndjson` file containing specified exception list and its items',
});

export const find_exception_lists_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      filter: z.optional(security_exceptions_api_find_exception_lists_filter),
      namespace_type: z
        .optional(
          z.array(security_exceptions_api_exception_namespace_type).register(z.globalRegistry, {
            description:
              'Determines whether the returned containers are Kibana associated with a Kibana space\nor available in all spaces (`agnostic` or `single`)\n',
          })
        )
        .default(['single']),
      page: z.optional(
        z.int().gte(1).register(z.globalRegistry, {
          description: 'The page number to return',
        })
      ),
      per_page: z.optional(
        z.int().gte(1).register(z.globalRegistry, {
          description: 'The number of exception lists to return per page',
        })
      ),
      sort_field: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Determines which field is used to sort the results.',
        })
      ),
      sort_order: z.optional(
        z.enum(['desc', 'asc']).register(z.globalRegistry, {
          description: 'Determines the sort order, which can be `desc` or `asc`.',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const find_exception_lists_response = z
  .object({
    data: z.array(security_exceptions_api_exception_list),
    page: z.int().gte(1),
    per_page: z.int().gte(1),
    total: z.int().gte(0),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const import_exception_list_request = z.object({
  body: z.object({
    file: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'A `.ndjson` file containing the exception list',
      })
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      overwrite: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Determines whether existing exception lists with the same `list_id` are overwritten.\nIf any exception items have the same `item_id`, those are also overwritten.\n',
          })
        )
        .default(false),
      as_new_list: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              "Determines whether the list being imported will have a new `list_id` generated.\nAdditional `item_id`'s are generated for each exception item. Both the exception\nlist and its items are overwritten.\n",
          })
        )
        .default(false),
    })
  ),
});

/**
 * Successful response
 */
export const import_exception_list_response = z
  .object({
    errors: security_exceptions_api_exception_lists_import_bulk_error_array,
    success: z.boolean(),
    success_count: z.int().gte(0),
    success_count_exception_list_items: z.int().gte(0),
    success_count_exception_lists: z.int().gte(0),
    success_exception_list_items: z.boolean(),
    success_exception_lists: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const delete_exception_list_item_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_exceptions_api_exception_list_item_id),
      item_id: z.optional(security_exceptions_api_exception_list_item_human_id),
      namespace_type: z.optional(security_exceptions_api_exception_namespace_type),
    })
  ),
});

/**
 * Successful response
 */
export const delete_exception_list_item_response = security_exceptions_api_exception_list_item;

export const read_exception_list_item_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_exceptions_api_exception_list_item_id),
      item_id: z.optional(security_exceptions_api_exception_list_item_human_id),
      namespace_type: z.optional(security_exceptions_api_exception_namespace_type),
    })
  ),
});

/**
 * Successful response
 */
export const read_exception_list_item_response = security_exceptions_api_exception_list_item;

export const create_exception_list_item_request = z.object({
  body: z
    .object({
      comments: z.optional(security_exceptions_api_create_exception_list_item_comment_array),
      description: security_exceptions_api_exception_list_item_description,
      entries: security_exceptions_api_exception_list_item_entry_array,
      expire_time: z.optional(security_exceptions_api_exception_list_item_expire_time),
      item_id: z.optional(security_exceptions_api_exception_list_item_human_id),
      list_id: security_exceptions_api_exception_list_human_id,
      meta: z.optional(security_exceptions_api_exception_list_item_meta),
      name: security_exceptions_api_exception_list_item_name,
      namespace_type: z.optional(security_exceptions_api_exception_namespace_type),
      os_types: z.optional(security_exceptions_api_exception_list_item_os_type_array),
      tags: z.optional(security_exceptions_api_exception_list_item_tags),
      type: security_exceptions_api_exception_list_item_type,
    })
    .register(z.globalRegistry, {
      description: "Exception list item's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_exception_list_item_response = security_exceptions_api_exception_list_item;

export const update_exception_list_item_request = z.object({
  body: z
    .object({
      _version: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The version id, normally returned by the API when the item was retrieved. Use it ensure updates are done against the latest version.',
        })
      ),
      comments: z.optional(security_exceptions_api_update_exception_list_item_comment_array),
      description: security_exceptions_api_exception_list_item_description,
      entries: security_exceptions_api_exception_list_item_entry_array,
      expire_time: z.optional(security_exceptions_api_exception_list_item_expire_time),
      id: z.optional(security_exceptions_api_exception_list_item_id),
      item_id: z.optional(security_exceptions_api_exception_list_item_human_id),
      list_id: z.optional(security_exceptions_api_exception_list_human_id),
      meta: z.optional(security_exceptions_api_exception_list_item_meta),
      name: security_exceptions_api_exception_list_item_name,
      namespace_type: z.optional(security_exceptions_api_exception_namespace_type),
      os_types: z.optional(security_exceptions_api_exception_list_item_os_type_array),
      tags: z.optional(security_exceptions_api_exception_list_item_tags),
      type: security_exceptions_api_exception_list_item_type,
    })
    .register(z.globalRegistry, {
      description: "Exception list item's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const update_exception_list_item_response = security_exceptions_api_exception_list_item;

export const find_exception_list_items_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    list_id: z.array(security_exceptions_api_exception_list_human_id).register(z.globalRegistry, {
      description: 'The `list_id`s of the items to fetch.',
    }),
    filter: z
      .optional(
        z.array(security_exceptions_api_non_empty_string).register(z.globalRegistry, {
          description:
            'Filters the returned results according to the value of the specified field,\nusing the `<field name>:<field value>` syntax.\n',
        })
      )
      .default([]),
    namespace_type: z
      .optional(
        z.array(security_exceptions_api_exception_namespace_type).register(z.globalRegistry, {
          description:
            'Determines whether the returned containers are Kibana associated with a Kibana space\nor available in all spaces (`agnostic` or `single`)\n',
        })
      )
      .default(['single']),
    search: z.optional(z.string()),
    page: z.optional(
      z.int().gte(0).register(z.globalRegistry, {
        description: 'The page number to return',
      })
    ),
    per_page: z.optional(
      z.int().gte(0).register(z.globalRegistry, {
        description: 'The number of exception list items to return per page',
      })
    ),
    sort_field: z.optional(security_exceptions_api_non_empty_string),
    sort_order: z.optional(
      z.enum(['desc', 'asc']).register(z.globalRegistry, {
        description: 'Determines the sort order, which can be `desc` or `asc`.',
      })
    ),
  }),
});

/**
 * Successful response
 */
export const find_exception_list_items_response = z
  .object({
    data: z.array(security_exceptions_api_exception_list_item),
    page: z.int().gte(1),
    per_page: z.int().gte(1),
    pit: z.optional(z.string()),
    total: z.int().gte(0),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const read_exception_list_summary_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_exceptions_api_exception_list_id),
      list_id: z.optional(security_exceptions_api_exception_list_human_id),
      namespace_type: z.optional(security_exceptions_api_exception_namespace_type),
      filter: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Search filter clause',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const read_exception_list_summary_response = z
  .object({
    linux: z.optional(z.int().gte(0)),
    macos: z.optional(z.int().gte(0)),
    total: z.optional(z.int().gte(0)),
    windows: z.optional(z.int().gte(0)),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const create_shared_exception_list_request = z.object({
  body: z.object({
    description: security_exceptions_api_exception_list_description,
    name: security_exceptions_api_exception_list_name,
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_shared_exception_list_response = security_exceptions_api_exception_list;

export const get_features_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const get_features_response = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
  description: 'Indicates a successful call',
});

export const get_fleet_agent_download_sources_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agent_download_sources_response = z
  .object({
    items: z.array(
      z.object({
        host: z.url(),
        id: z.string(),
        is_default: z.optional(z.boolean()).default(false),
        name: z.string(),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        ssl: z.optional(
          z.object({
            certificate: z.optional(z.string()),
            certificate_authorities: z.optional(z.array(z.string())),
            key: z.optional(z.string()),
          })
        ),
      })
    ),
    page: z.number(),
    perPage: z.number(),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agent_download_sources_request = z.object({
  body: z.optional(
    z.object({
      host: z.url(),
      id: z.optional(z.string()),
      is_default: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_id: z.optional(z.union([z.string(), z.null()])),
      secrets: z.optional(
        z.object({
          ssl: z.optional(
            z.object({
              key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
            })
          ),
        })
      ),
      ssl: z.optional(
        z.object({
          certificate: z.optional(z.string()),
          certificate_authorities: z.optional(z.array(z.string())),
          key: z.optional(z.string()),
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agent_download_sources_response = z
  .object({
    item: z.object({
      host: z.url(),
      id: z.string(),
      is_default: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_id: z.optional(z.union([z.string(), z.null()])),
      secrets: z.optional(
        z.object({
          ssl: z.optional(
            z.object({
              key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
            })
          ),
        })
      ),
      ssl: z.optional(
        z.object({
          certificate: z.optional(z.string()),
          certificate_authorities: z.optional(z.array(z.string())),
          key: z.optional(z.string()),
        })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_agent_download_sources_sourceid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    sourceId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_agent_download_sources_sourceid_response = z
  .object({
    id: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agent_download_sources_sourceid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    sourceId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agent_download_sources_sourceid_response = z
  .object({
    item: z.object({
      host: z.url(),
      id: z.string(),
      is_default: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_id: z.optional(z.union([z.string(), z.null()])),
      secrets: z.optional(
        z.object({
          ssl: z.optional(
            z.object({
              key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
            })
          ),
        })
      ),
      ssl: z.optional(
        z.object({
          certificate: z.optional(z.string()),
          certificate_authorities: z.optional(z.array(z.string())),
          key: z.optional(z.string()),
        })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_agent_download_sources_sourceid_request = z.object({
  body: z.optional(
    z.object({
      host: z.url(),
      id: z.optional(z.string()),
      is_default: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_id: z.optional(z.union([z.string(), z.null()])),
      secrets: z.optional(
        z.object({
          ssl: z.optional(
            z.object({
              key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
            })
          ),
        })
      ),
      ssl: z.optional(
        z.object({
          certificate: z.optional(z.string()),
          certificate_authorities: z.optional(z.array(z.string())),
          key: z.optional(z.string()),
        })
      ),
    })
  ),
  path: z.object({
    sourceId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_agent_download_sources_sourceid_response = z
  .object({
    item: z.object({
      host: z.url(),
      id: z.string(),
      is_default: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_id: z.optional(z.union([z.string(), z.null()])),
      secrets: z.optional(
        z.object({
          ssl: z.optional(
            z.object({
              key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
            })
          ),
        })
      ),
      ssl: z.optional(
        z.object({
          certificate: z.optional(z.string()),
          certificate_authorities: z.optional(z.array(z.string())),
          key: z.optional(z.string()),
        })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agent_policies_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(z.number()),
      perPage: z.optional(z.number()),
      sortField: z.optional(z.string()),
      sortOrder: z.optional(z.enum(['desc', 'asc'])),
      showUpgradeable: z.optional(z.boolean()),
      kuery: z.optional(z.string()),
      noAgentCount: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'use withAgentCount instead',
        })
      ),
      withAgentCount: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'get policies with agent count',
        })
      ),
      full: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'get full policies with package policies populated',
        })
      ),
      format: z.optional(z.enum(['simplified', 'legacy'])),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agent_policies_response = z
  .object({
    items: z.array(
      z.object({
        advanced_settings: z.optional(
          z.object({
            agent_download_target_directory: z.optional(z.unknown()),
            agent_download_timeout: z.optional(z.unknown()),
            agent_limits_go_max_procs: z.optional(z.unknown()),
            agent_logging_files_interval: z.optional(z.unknown()),
            agent_logging_files_keepfiles: z.optional(z.unknown()),
            agent_logging_files_rotateeverybytes: z.optional(z.unknown()),
            agent_logging_level: z.optional(z.unknown()),
            agent_logging_metrics_period: z.optional(z.unknown()),
            agent_logging_to_files: z.optional(z.unknown()),
            agent_monitoring_runtime_experimental: z.optional(z.unknown()),
          })
        ),
        agent_features: z.optional(
          z.array(
            z.object({
              enabled: z.boolean(),
              name: z.string(),
            })
          )
        ),
        agentless: z.optional(
          z.object({
            cloud_connectors: z.optional(
              z.object({
                enabled: z.boolean(),
                target_csp: z.optional(z.string()),
              })
            ),
            resources: z.optional(
              z.object({
                requests: z.optional(
                  z.object({
                    cpu: z.optional(z.string()),
                    memory: z.optional(z.string()),
                  })
                ),
              })
            ),
          })
        ),
        agents: z.optional(z.number()),
        data_output_id: z.optional(z.union([z.string(), z.null()])),
        description: z.optional(z.string()),
        download_source_id: z.optional(z.union([z.string(), z.null()])),
        fips_agents: z.optional(z.number()),
        fleet_server_host_id: z.optional(z.union([z.string(), z.null()])),
        global_data_tags: z.optional(
          z
            .array(
              z.object({
                name: z.string(),
                value: z.union([z.string(), z.number()]),
              })
            )
            .register(z.globalRegistry, {
              description:
                'User defined data tags that are added to all of the inputs. The values can be strings or numbers.',
            })
        ),
        has_fleet_server: z.optional(z.boolean()),
        id: z.string(),
        inactivity_timeout: z.optional(z.number().gte(0)).default(1209600),
        is_default: z.optional(z.boolean()),
        is_default_fleet_server: z.optional(z.boolean()),
        is_managed: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        is_protected: z.boolean().register(z.globalRegistry, {
          description:
            'Indicates whether the agent policy has tamper protection enabled. Default false.',
        }),
        keep_monitoring_alive: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        monitoring_diagnostics: z.optional(
          z.object({
            limit: z.optional(
              z.object({
                burst: z.optional(z.number()),
                interval: z.optional(z.string()),
              })
            ),
            uploader: z.optional(
              z.object({
                init_dur: z.optional(z.string()),
                max_dur: z.optional(z.string()),
                max_retries: z.optional(z.number()),
              })
            ),
          })
        ),
        monitoring_enabled: z.optional(z.array(z.enum(['logs', 'metrics', 'traces']))),
        monitoring_http: z.optional(
          z.object({
            buffer: z.optional(
              z.object({
                enabled: z.optional(z.boolean()).default(false),
              })
            ),
            enabled: z.optional(z.boolean()),
            host: z.optional(z.string()),
            port: z.optional(z.number().gte(0).lte(65353)),
          })
        ),
        monitoring_output_id: z.optional(z.union([z.string(), z.null()])),
        monitoring_pprof_enabled: z.optional(z.boolean()),
        name: z.string().min(1),
        namespace: z.string().min(1),
        overrides: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
        package_policies: z.optional(
          z.union([
            z.array(z.string()),
            z
              .array(
                z.object({
                  additional_datastreams_permissions: z.optional(
                    z.union([z.array(z.string()), z.null()])
                  ),
                  agents: z.optional(z.number()),
                  cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
                  created_at: z.string(),
                  created_by: z.string(),
                  description: z.optional(
                    z.string().register(z.globalRegistry, {
                      description: 'Package policy description',
                    })
                  ),
                  elasticsearch: z.optional(
                    z.object({
                      privileges: z.optional(
                        z.object({
                          cluster: z.optional(z.array(z.string())),
                        })
                      ),
                    })
                  ),
                  enabled: z.boolean(),
                  id: z.string().register(z.globalRegistry, {
                    description: 'Package policy unique identifier.',
                  }),
                  inputs: z.union([
                    z.array(
                      z.object({
                        compiled_input: z.unknown(),
                        config: z.optional(
                          z
                            .record(
                              z.string(),
                              z.object({
                                frozen: z.optional(z.boolean()),
                                type: z.optional(z.string()),
                                value: z.unknown(),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Package variable (see integration documentation for more information)',
                            })
                        ),
                        enabled: z.boolean(),
                        id: z.optional(z.string()),
                        keep_enabled: z.optional(z.boolean()),
                        policy_template: z.optional(z.string()),
                        streams: z.array(
                          z.object({
                            compiled_stream: z.unknown(),
                            config: z.optional(
                              z
                                .record(
                                  z.string(),
                                  z.object({
                                    frozen: z.optional(z.boolean()),
                                    type: z.optional(z.string()),
                                    value: z.unknown(),
                                  })
                                )
                                .register(z.globalRegistry, {
                                  description:
                                    'Package variable (see integration documentation for more information)',
                                })
                            ),
                            data_stream: z.object({
                              dataset: z.string(),
                              elasticsearch: z.optional(
                                z.object({
                                  dynamic_dataset: z.optional(z.boolean()),
                                  dynamic_namespace: z.optional(z.boolean()),
                                  privileges: z.optional(
                                    z.object({
                                      indices: z.optional(z.array(z.string())),
                                    })
                                  ),
                                })
                              ),
                              type: z.string(),
                            }),
                            enabled: z.boolean(),
                            id: z.optional(z.string()),
                            keep_enabled: z.optional(z.boolean()),
                            release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                            vars: z.optional(
                              z
                                .record(
                                  z.string(),
                                  z.object({
                                    frozen: z.optional(z.boolean()),
                                    type: z.optional(z.string()),
                                    value: z.unknown(),
                                  })
                                )
                                .register(z.globalRegistry, {
                                  description:
                                    'Package variable (see integration documentation for more information)',
                                })
                            ),
                          })
                        ),
                        type: z.string(),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.object({
                                frozen: z.optional(z.boolean()),
                                type: z.optional(z.string()),
                                value: z.unknown(),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Package variable (see integration documentation for more information)',
                            })
                        ),
                      })
                    ),
                    z
                      .record(
                        z.string(),
                        z.object({
                          enabled: z.optional(
                            z.boolean().register(z.globalRegistry, {
                              description:
                                'Enable or disable that input. Defaults to `true` (enabled).',
                            })
                          ),
                          streams: z.optional(
                            z
                              .record(
                                z.string(),
                                z.object({
                                  enabled: z.optional(
                                    z.boolean().register(z.globalRegistry, {
                                      description:
                                        'Enable or disable that stream. Defaults to `true` (enabled).',
                                    })
                                  ),
                                  vars: z.optional(
                                    z
                                      .record(
                                        z.string(),
                                        z.union([
                                          z.boolean(),
                                          z.string(),
                                          z.number(),
                                          z.array(z.string()),
                                          z.array(z.number()),
                                          z.object({
                                            id: z.string(),
                                            isSecretRef: z.boolean(),
                                          }),
                                          z.null(),
                                        ])
                                      )
                                      .register(z.globalRegistry, {
                                        description:
                                          'Input/stream level variable. Refer to the integration documentation for more information.',
                                      })
                                  ),
                                })
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Input streams. Refer to the integration documentation to know which streams are available.',
                              })
                          ),
                          vars: z.optional(
                            z
                              .record(
                                z.string(),
                                z.union([
                                  z.boolean(),
                                  z.string(),
                                  z.number(),
                                  z.array(z.string()),
                                  z.array(z.number()),
                                  z.object({
                                    id: z.string(),
                                    isSecretRef: z.boolean(),
                                  }),
                                  z.null(),
                                ])
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Input/stream level variable. Refer to the integration documentation for more information.',
                              })
                          ),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
                      }),
                  ]),
                  is_managed: z.optional(z.boolean()),
                  name: z.string().register(z.globalRegistry, {
                    description: 'Unique name for the package policy.',
                  }),
                  namespace: z.optional(
                    z.string().register(z.globalRegistry, {
                      description:
                        "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
                    })
                  ),
                  output_id: z.optional(z.union([z.string(), z.null()])),
                  overrides: z.optional(
                    z.union([
                      z.object({
                        inputs: z.optional(z.record(z.string(), z.unknown())),
                      }),
                      z.null(),
                    ])
                  ),
                  package: z.optional(
                    z.object({
                      experimental_data_stream_features: z.optional(
                        z.array(
                          z.object({
                            data_stream: z.string(),
                            features: z.object({
                              doc_value_only_numeric: z.optional(z.boolean()),
                              doc_value_only_other: z.optional(z.boolean()),
                              synthetic_source: z.optional(z.boolean()),
                              tsdb: z.optional(z.boolean()),
                            }),
                          })
                        )
                      ),
                      fips_compatible: z.optional(z.boolean()),
                      name: z.string().register(z.globalRegistry, {
                        description: 'Package name',
                      }),
                      requires_root: z.optional(z.boolean()),
                      title: z.optional(z.string()),
                      version: z.string().register(z.globalRegistry, {
                        description: 'Package version',
                      }),
                    })
                  ),
                  policy_id: z.optional(z.union([z.string(), z.null()])),
                  policy_ids: z.optional(
                    z.array(
                      z.string().register(z.globalRegistry, {
                        description:
                          'IDs of the agent policies which that package policy will be added to.',
                      })
                    )
                  ),
                  revision: z.number().register(z.globalRegistry, {
                    description: 'Package policy revision.',
                  }),
                  secret_references: z.optional(
                    z.array(
                      z.object({
                        id: z.string(),
                      })
                    )
                  ),
                  spaceIds: z.optional(z.array(z.string())),
                  supports_agentless: z
                    .optional(z.union([z.boolean().default(false), z.null()]))
                    .default(false),
                  supports_cloud_connector: z
                    .optional(z.union([z.boolean().default(false), z.null()]))
                    .default(false),
                  updated_at: z.string(),
                  updated_by: z.string(),
                  vars: z.optional(
                    z.union([
                      z
                        .record(
                          z.string(),
                          z.object({
                            frozen: z.optional(z.boolean()),
                            type: z.optional(z.string()),
                            value: z.unknown(),
                          })
                        )
                        .register(z.globalRegistry, {
                          description:
                            'Package variable (see integration documentation for more information)',
                        }),
                      z
                        .record(
                          z.string(),
                          z.union([
                            z.boolean(),
                            z.string(),
                            z.number(),
                            z.array(z.string()),
                            z.array(z.number()),
                            z.object({
                              id: z.string(),
                              isSecretRef: z.boolean(),
                            }),
                            z.null(),
                          ])
                        )
                        .register(z.globalRegistry, {
                          description:
                            'Input/stream level variable. Refer to the integration documentation for more information.',
                        }),
                    ])
                  ),
                  version: z.optional(
                    z.string().register(z.globalRegistry, {
                      description: 'Package policy ES version.',
                    })
                  ),
                })
              )
              .register(z.globalRegistry, {
                description:
                  'This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter',
              }),
          ])
        ),
        required_versions: z.optional(
          z.union([
            z.array(
              z.object({
                percentage: z.number().gte(0).lte(100).register(z.globalRegistry, {
                  description: 'Target percentage of agents to auto upgrade',
                }),
                version: z.string().register(z.globalRegistry, {
                  description: 'Target version for automatic agent upgrade',
                }),
              })
            ),
            z.null(),
          ])
        ),
        revision: z.number(),
        schema_version: z.optional(z.string()),
        space_ids: z.optional(z.array(z.string())),
        status: z.enum(['active', 'inactive']),
        supports_agentless: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        unenroll_timeout: z.optional(z.number().gte(0)),
        unprivileged_agents: z.optional(z.number()),
        updated_at: z.string(),
        updated_by: z.string(),
        version: z.optional(z.string()),
      })
    ),
    page: z.number(),
    perPage: z.number(),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agent_policies_request = z.object({
  body: z.optional(
    z.object({
      advanced_settings: z.optional(
        z.object({
          agent_download_target_directory: z.optional(z.unknown()),
          agent_download_timeout: z.optional(z.unknown()),
          agent_limits_go_max_procs: z.optional(z.unknown()),
          agent_logging_files_interval: z.optional(z.unknown()),
          agent_logging_files_keepfiles: z.optional(z.unknown()),
          agent_logging_files_rotateeverybytes: z.optional(z.unknown()),
          agent_logging_level: z.optional(z.unknown()),
          agent_logging_metrics_period: z.optional(z.unknown()),
          agent_logging_to_files: z.optional(z.unknown()),
          agent_monitoring_runtime_experimental: z.optional(z.unknown()),
        })
      ),
      agent_features: z.optional(
        z.array(
          z.object({
            enabled: z.boolean(),
            name: z.string(),
          })
        )
      ),
      agentless: z.optional(
        z.object({
          cloud_connectors: z.optional(
            z.object({
              enabled: z.boolean(),
              target_csp: z.optional(z.string()),
            })
          ),
          resources: z.optional(
            z.object({
              requests: z.optional(
                z.object({
                  cpu: z.optional(z.string()),
                  memory: z.optional(z.string()),
                })
              ),
            })
          ),
        })
      ),
      data_output_id: z.optional(z.union([z.string(), z.null()])),
      description: z.optional(z.string()),
      download_source_id: z.optional(z.union([z.string(), z.null()])),
      fleet_server_host_id: z.optional(z.union([z.string(), z.null()])),
      force: z.optional(z.boolean()),
      global_data_tags: z.optional(
        z
          .array(
            z.object({
              name: z.string(),
              value: z.union([z.string(), z.number()]),
            })
          )
          .register(z.globalRegistry, {
            description:
              'User defined data tags that are added to all of the inputs. The values can be strings or numbers.',
          })
      ),
      has_fleet_server: z.optional(z.boolean()),
      id: z.optional(z.string()),
      inactivity_timeout: z.optional(z.number().gte(0)).default(1209600),
      is_default: z.optional(z.boolean()),
      is_default_fleet_server: z.optional(z.boolean()),
      is_managed: z.optional(z.boolean()),
      is_protected: z.optional(z.boolean()),
      keep_monitoring_alive: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      monitoring_diagnostics: z.optional(
        z.object({
          limit: z.optional(
            z.object({
              burst: z.optional(z.number()),
              interval: z.optional(z.string()),
            })
          ),
          uploader: z.optional(
            z.object({
              init_dur: z.optional(z.string()),
              max_dur: z.optional(z.string()),
              max_retries: z.optional(z.number()),
            })
          ),
        })
      ),
      monitoring_enabled: z.optional(z.array(z.enum(['logs', 'metrics', 'traces']))),
      monitoring_http: z.optional(
        z.object({
          buffer: z.optional(
            z.object({
              enabled: z.optional(z.boolean()).default(false),
            })
          ),
          enabled: z.optional(z.boolean()),
          host: z.optional(z.string()),
          port: z.optional(z.number().gte(0).lte(65353)),
        })
      ),
      monitoring_output_id: z.optional(z.union([z.string(), z.null()])),
      monitoring_pprof_enabled: z.optional(z.boolean()),
      name: z.string().min(1),
      namespace: z.string().min(1),
      overrides: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
      required_versions: z.optional(
        z.union([
          z.array(
            z.object({
              percentage: z.number().gte(0).lte(100).register(z.globalRegistry, {
                description: 'Target percentage of agents to auto upgrade',
              }),
              version: z.string().register(z.globalRegistry, {
                description: 'Target version for automatic agent upgrade',
              }),
            })
          ),
          z.null(),
        ])
      ),
      space_ids: z.optional(z.array(z.string())),
      supports_agentless: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      unenroll_timeout: z.optional(z.number().gte(0)),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      sys_monitoring: z.optional(z.boolean()),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agent_policies_response = z
  .object({
    item: z.object({
      advanced_settings: z.optional(
        z.object({
          agent_download_target_directory: z.optional(z.unknown()),
          agent_download_timeout: z.optional(z.unknown()),
          agent_limits_go_max_procs: z.optional(z.unknown()),
          agent_logging_files_interval: z.optional(z.unknown()),
          agent_logging_files_keepfiles: z.optional(z.unknown()),
          agent_logging_files_rotateeverybytes: z.optional(z.unknown()),
          agent_logging_level: z.optional(z.unknown()),
          agent_logging_metrics_period: z.optional(z.unknown()),
          agent_logging_to_files: z.optional(z.unknown()),
          agent_monitoring_runtime_experimental: z.optional(z.unknown()),
        })
      ),
      agent_features: z.optional(
        z.array(
          z.object({
            enabled: z.boolean(),
            name: z.string(),
          })
        )
      ),
      agentless: z.optional(
        z.object({
          cloud_connectors: z.optional(
            z.object({
              enabled: z.boolean(),
              target_csp: z.optional(z.string()),
            })
          ),
          resources: z.optional(
            z.object({
              requests: z.optional(
                z.object({
                  cpu: z.optional(z.string()),
                  memory: z.optional(z.string()),
                })
              ),
            })
          ),
        })
      ),
      agents: z.optional(z.number()),
      data_output_id: z.optional(z.union([z.string(), z.null()])),
      description: z.optional(z.string()),
      download_source_id: z.optional(z.union([z.string(), z.null()])),
      fips_agents: z.optional(z.number()),
      fleet_server_host_id: z.optional(z.union([z.string(), z.null()])),
      global_data_tags: z.optional(
        z
          .array(
            z.object({
              name: z.string(),
              value: z.union([z.string(), z.number()]),
            })
          )
          .register(z.globalRegistry, {
            description:
              'User defined data tags that are added to all of the inputs. The values can be strings or numbers.',
          })
      ),
      has_fleet_server: z.optional(z.boolean()),
      id: z.string(),
      inactivity_timeout: z.optional(z.number().gte(0)).default(1209600),
      is_default: z.optional(z.boolean()),
      is_default_fleet_server: z.optional(z.boolean()),
      is_managed: z.optional(z.boolean()),
      is_preconfigured: z.optional(z.boolean()),
      is_protected: z.boolean().register(z.globalRegistry, {
        description:
          'Indicates whether the agent policy has tamper protection enabled. Default false.',
      }),
      keep_monitoring_alive: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      monitoring_diagnostics: z.optional(
        z.object({
          limit: z.optional(
            z.object({
              burst: z.optional(z.number()),
              interval: z.optional(z.string()),
            })
          ),
          uploader: z.optional(
            z.object({
              init_dur: z.optional(z.string()),
              max_dur: z.optional(z.string()),
              max_retries: z.optional(z.number()),
            })
          ),
        })
      ),
      monitoring_enabled: z.optional(z.array(z.enum(['logs', 'metrics', 'traces']))),
      monitoring_http: z.optional(
        z.object({
          buffer: z.optional(
            z.object({
              enabled: z.optional(z.boolean()).default(false),
            })
          ),
          enabled: z.optional(z.boolean()),
          host: z.optional(z.string()),
          port: z.optional(z.number().gte(0).lte(65353)),
        })
      ),
      monitoring_output_id: z.optional(z.union([z.string(), z.null()])),
      monitoring_pprof_enabled: z.optional(z.boolean()),
      name: z.string().min(1),
      namespace: z.string().min(1),
      overrides: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
      package_policies: z.optional(
        z.union([
          z.array(z.string()),
          z
            .array(
              z.object({
                additional_datastreams_permissions: z.optional(
                  z.union([z.array(z.string()), z.null()])
                ),
                agents: z.optional(z.number()),
                cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
                created_at: z.string(),
                created_by: z.string(),
                description: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'Package policy description',
                  })
                ),
                elasticsearch: z.optional(
                  z.object({
                    privileges: z.optional(
                      z.object({
                        cluster: z.optional(z.array(z.string())),
                      })
                    ),
                  })
                ),
                enabled: z.boolean(),
                id: z.string().register(z.globalRegistry, {
                  description: 'Package policy unique identifier.',
                }),
                inputs: z.union([
                  z.array(
                    z.object({
                      compiled_input: z.unknown(),
                      config: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              frozen: z.optional(z.boolean()),
                              type: z.optional(z.string()),
                              value: z.unknown(),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Package variable (see integration documentation for more information)',
                          })
                      ),
                      enabled: z.boolean(),
                      id: z.optional(z.string()),
                      keep_enabled: z.optional(z.boolean()),
                      policy_template: z.optional(z.string()),
                      streams: z.array(
                        z.object({
                          compiled_stream: z.unknown(),
                          config: z.optional(
                            z
                              .record(
                                z.string(),
                                z.object({
                                  frozen: z.optional(z.boolean()),
                                  type: z.optional(z.string()),
                                  value: z.unknown(),
                                })
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Package variable (see integration documentation for more information)',
                              })
                          ),
                          data_stream: z.object({
                            dataset: z.string(),
                            elasticsearch: z.optional(
                              z.object({
                                dynamic_dataset: z.optional(z.boolean()),
                                dynamic_namespace: z.optional(z.boolean()),
                                privileges: z.optional(
                                  z.object({
                                    indices: z.optional(z.array(z.string())),
                                  })
                                ),
                              })
                            ),
                            type: z.string(),
                          }),
                          enabled: z.boolean(),
                          id: z.optional(z.string()),
                          keep_enabled: z.optional(z.boolean()),
                          release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                          vars: z.optional(
                            z
                              .record(
                                z.string(),
                                z.object({
                                  frozen: z.optional(z.boolean()),
                                  type: z.optional(z.string()),
                                  value: z.unknown(),
                                })
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Package variable (see integration documentation for more information)',
                              })
                          ),
                        })
                      ),
                      type: z.string(),
                      vars: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              frozen: z.optional(z.boolean()),
                              type: z.optional(z.string()),
                              value: z.unknown(),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Package variable (see integration documentation for more information)',
                          })
                      ),
                    })
                  ),
                  z
                    .record(
                      z.string(),
                      z.object({
                        enabled: z.optional(
                          z.boolean().register(z.globalRegistry, {
                            description:
                              'Enable or disable that input. Defaults to `true` (enabled).',
                          })
                        ),
                        streams: z.optional(
                          z
                            .record(
                              z.string(),
                              z.object({
                                enabled: z.optional(
                                  z.boolean().register(z.globalRegistry, {
                                    description:
                                      'Enable or disable that stream. Defaults to `true` (enabled).',
                                  })
                                ),
                                vars: z.optional(
                                  z
                                    .record(
                                      z.string(),
                                      z.union([
                                        z.boolean(),
                                        z.string(),
                                        z.number(),
                                        z.array(z.string()),
                                        z.array(z.number()),
                                        z.object({
                                          id: z.string(),
                                          isSecretRef: z.boolean(),
                                        }),
                                        z.null(),
                                      ])
                                    )
                                    .register(z.globalRegistry, {
                                      description:
                                        'Input/stream level variable. Refer to the integration documentation for more information.',
                                    })
                                ),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input streams. Refer to the integration documentation to know which streams are available.',
                            })
                        ),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({
                                  id: z.string(),
                                  isSecretRef: z.boolean(),
                                }),
                                z.null(),
                              ])
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input/stream level variable. Refer to the integration documentation for more information.',
                            })
                        ),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
                    }),
                ]),
                is_managed: z.optional(z.boolean()),
                name: z.string().register(z.globalRegistry, {
                  description: 'Unique name for the package policy.',
                }),
                namespace: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
                  })
                ),
                output_id: z.optional(z.union([z.string(), z.null()])),
                overrides: z.optional(
                  z.union([
                    z.object({
                      inputs: z.optional(z.record(z.string(), z.unknown())),
                    }),
                    z.null(),
                  ])
                ),
                package: z.optional(
                  z.object({
                    experimental_data_stream_features: z.optional(
                      z.array(
                        z.object({
                          data_stream: z.string(),
                          features: z.object({
                            doc_value_only_numeric: z.optional(z.boolean()),
                            doc_value_only_other: z.optional(z.boolean()),
                            synthetic_source: z.optional(z.boolean()),
                            tsdb: z.optional(z.boolean()),
                          }),
                        })
                      )
                    ),
                    fips_compatible: z.optional(z.boolean()),
                    name: z.string().register(z.globalRegistry, {
                      description: 'Package name',
                    }),
                    requires_root: z.optional(z.boolean()),
                    title: z.optional(z.string()),
                    version: z.string().register(z.globalRegistry, {
                      description: 'Package version',
                    }),
                  })
                ),
                policy_id: z.optional(z.union([z.string(), z.null()])),
                policy_ids: z.optional(
                  z.array(
                    z.string().register(z.globalRegistry, {
                      description:
                        'IDs of the agent policies which that package policy will be added to.',
                    })
                  )
                ),
                revision: z.number().register(z.globalRegistry, {
                  description: 'Package policy revision.',
                }),
                secret_references: z.optional(
                  z.array(
                    z.object({
                      id: z.string(),
                    })
                  )
                ),
                spaceIds: z.optional(z.array(z.string())),
                supports_agentless: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                supports_cloud_connector: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                updated_at: z.string(),
                updated_by: z.string(),
                vars: z.optional(
                  z.union([
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      }),
                    z
                      .record(
                        z.string(),
                        z.union([
                          z.boolean(),
                          z.string(),
                          z.number(),
                          z.array(z.string()),
                          z.array(z.number()),
                          z.object({
                            id: z.string(),
                            isSecretRef: z.boolean(),
                          }),
                          z.null(),
                        ])
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Input/stream level variable. Refer to the integration documentation for more information.',
                      }),
                  ])
                ),
                version: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'Package policy ES version.',
                  })
                ),
              })
            )
            .register(z.globalRegistry, {
              description:
                'This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter',
            }),
        ])
      ),
      required_versions: z.optional(
        z.union([
          z.array(
            z.object({
              percentage: z.number().gte(0).lte(100).register(z.globalRegistry, {
                description: 'Target percentage of agents to auto upgrade',
              }),
              version: z.string().register(z.globalRegistry, {
                description: 'Target version for automatic agent upgrade',
              }),
            })
          ),
          z.null(),
        ])
      ),
      revision: z.number(),
      schema_version: z.optional(z.string()),
      space_ids: z.optional(z.array(z.string())),
      status: z.enum(['active', 'inactive']),
      supports_agentless: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      unenroll_timeout: z.optional(z.number().gte(0)),
      unprivileged_agents: z.optional(z.number()),
      updated_at: z.string(),
      updated_by: z.string(),
      version: z.optional(z.string()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agent_policies_bulk_get_request = z.object({
  body: z.optional(
    z.object({
      full: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'get full policies with package policies populated',
        })
      ),
      ids: z.array(z.string()).register(z.globalRegistry, {
        description: 'list of package policy ids',
      }),
      ignoreMissing: z.optional(z.boolean()),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      format: z.optional(z.enum(['simplified', 'legacy'])),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agent_policies_bulk_get_response = z
  .object({
    items: z.array(
      z.object({
        advanced_settings: z.optional(
          z.object({
            agent_download_target_directory: z.optional(z.unknown()),
            agent_download_timeout: z.optional(z.unknown()),
            agent_limits_go_max_procs: z.optional(z.unknown()),
            agent_logging_files_interval: z.optional(z.unknown()),
            agent_logging_files_keepfiles: z.optional(z.unknown()),
            agent_logging_files_rotateeverybytes: z.optional(z.unknown()),
            agent_logging_level: z.optional(z.unknown()),
            agent_logging_metrics_period: z.optional(z.unknown()),
            agent_logging_to_files: z.optional(z.unknown()),
            agent_monitoring_runtime_experimental: z.optional(z.unknown()),
          })
        ),
        agent_features: z.optional(
          z.array(
            z.object({
              enabled: z.boolean(),
              name: z.string(),
            })
          )
        ),
        agentless: z.optional(
          z.object({
            cloud_connectors: z.optional(
              z.object({
                enabled: z.boolean(),
                target_csp: z.optional(z.string()),
              })
            ),
            resources: z.optional(
              z.object({
                requests: z.optional(
                  z.object({
                    cpu: z.optional(z.string()),
                    memory: z.optional(z.string()),
                  })
                ),
              })
            ),
          })
        ),
        agents: z.optional(z.number()),
        data_output_id: z.optional(z.union([z.string(), z.null()])),
        description: z.optional(z.string()),
        download_source_id: z.optional(z.union([z.string(), z.null()])),
        fips_agents: z.optional(z.number()),
        fleet_server_host_id: z.optional(z.union([z.string(), z.null()])),
        global_data_tags: z.optional(
          z
            .array(
              z.object({
                name: z.string(),
                value: z.union([z.string(), z.number()]),
              })
            )
            .register(z.globalRegistry, {
              description:
                'User defined data tags that are added to all of the inputs. The values can be strings or numbers.',
            })
        ),
        has_fleet_server: z.optional(z.boolean()),
        id: z.string(),
        inactivity_timeout: z.optional(z.number().gte(0)).default(1209600),
        is_default: z.optional(z.boolean()),
        is_default_fleet_server: z.optional(z.boolean()),
        is_managed: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        is_protected: z.boolean().register(z.globalRegistry, {
          description:
            'Indicates whether the agent policy has tamper protection enabled. Default false.',
        }),
        keep_monitoring_alive: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        monitoring_diagnostics: z.optional(
          z.object({
            limit: z.optional(
              z.object({
                burst: z.optional(z.number()),
                interval: z.optional(z.string()),
              })
            ),
            uploader: z.optional(
              z.object({
                init_dur: z.optional(z.string()),
                max_dur: z.optional(z.string()),
                max_retries: z.optional(z.number()),
              })
            ),
          })
        ),
        monitoring_enabled: z.optional(z.array(z.enum(['logs', 'metrics', 'traces']))),
        monitoring_http: z.optional(
          z.object({
            buffer: z.optional(
              z.object({
                enabled: z.optional(z.boolean()).default(false),
              })
            ),
            enabled: z.optional(z.boolean()),
            host: z.optional(z.string()),
            port: z.optional(z.number().gte(0).lte(65353)),
          })
        ),
        monitoring_output_id: z.optional(z.union([z.string(), z.null()])),
        monitoring_pprof_enabled: z.optional(z.boolean()),
        name: z.string().min(1),
        namespace: z.string().min(1),
        overrides: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
        package_policies: z.optional(
          z.union([
            z.array(z.string()),
            z
              .array(
                z.object({
                  additional_datastreams_permissions: z.optional(
                    z.union([z.array(z.string()), z.null()])
                  ),
                  agents: z.optional(z.number()),
                  cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
                  created_at: z.string(),
                  created_by: z.string(),
                  description: z.optional(
                    z.string().register(z.globalRegistry, {
                      description: 'Package policy description',
                    })
                  ),
                  elasticsearch: z.optional(
                    z.object({
                      privileges: z.optional(
                        z.object({
                          cluster: z.optional(z.array(z.string())),
                        })
                      ),
                    })
                  ),
                  enabled: z.boolean(),
                  id: z.string().register(z.globalRegistry, {
                    description: 'Package policy unique identifier.',
                  }),
                  inputs: z.union([
                    z.array(
                      z.object({
                        compiled_input: z.unknown(),
                        config: z.optional(
                          z
                            .record(
                              z.string(),
                              z.object({
                                frozen: z.optional(z.boolean()),
                                type: z.optional(z.string()),
                                value: z.unknown(),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Package variable (see integration documentation for more information)',
                            })
                        ),
                        enabled: z.boolean(),
                        id: z.optional(z.string()),
                        keep_enabled: z.optional(z.boolean()),
                        policy_template: z.optional(z.string()),
                        streams: z.array(
                          z.object({
                            compiled_stream: z.unknown(),
                            config: z.optional(
                              z
                                .record(
                                  z.string(),
                                  z.object({
                                    frozen: z.optional(z.boolean()),
                                    type: z.optional(z.string()),
                                    value: z.unknown(),
                                  })
                                )
                                .register(z.globalRegistry, {
                                  description:
                                    'Package variable (see integration documentation for more information)',
                                })
                            ),
                            data_stream: z.object({
                              dataset: z.string(),
                              elasticsearch: z.optional(
                                z.object({
                                  dynamic_dataset: z.optional(z.boolean()),
                                  dynamic_namespace: z.optional(z.boolean()),
                                  privileges: z.optional(
                                    z.object({
                                      indices: z.optional(z.array(z.string())),
                                    })
                                  ),
                                })
                              ),
                              type: z.string(),
                            }),
                            enabled: z.boolean(),
                            id: z.optional(z.string()),
                            keep_enabled: z.optional(z.boolean()),
                            release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                            vars: z.optional(
                              z
                                .record(
                                  z.string(),
                                  z.object({
                                    frozen: z.optional(z.boolean()),
                                    type: z.optional(z.string()),
                                    value: z.unknown(),
                                  })
                                )
                                .register(z.globalRegistry, {
                                  description:
                                    'Package variable (see integration documentation for more information)',
                                })
                            ),
                          })
                        ),
                        type: z.string(),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.object({
                                frozen: z.optional(z.boolean()),
                                type: z.optional(z.string()),
                                value: z.unknown(),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Package variable (see integration documentation for more information)',
                            })
                        ),
                      })
                    ),
                    z
                      .record(
                        z.string(),
                        z.object({
                          enabled: z.optional(
                            z.boolean().register(z.globalRegistry, {
                              description:
                                'Enable or disable that input. Defaults to `true` (enabled).',
                            })
                          ),
                          streams: z.optional(
                            z
                              .record(
                                z.string(),
                                z.object({
                                  enabled: z.optional(
                                    z.boolean().register(z.globalRegistry, {
                                      description:
                                        'Enable or disable that stream. Defaults to `true` (enabled).',
                                    })
                                  ),
                                  vars: z.optional(
                                    z
                                      .record(
                                        z.string(),
                                        z.union([
                                          z.boolean(),
                                          z.string(),
                                          z.number(),
                                          z.array(z.string()),
                                          z.array(z.number()),
                                          z.object({
                                            id: z.string(),
                                            isSecretRef: z.boolean(),
                                          }),
                                          z.null(),
                                        ])
                                      )
                                      .register(z.globalRegistry, {
                                        description:
                                          'Input/stream level variable. Refer to the integration documentation for more information.',
                                      })
                                  ),
                                })
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Input streams. Refer to the integration documentation to know which streams are available.',
                              })
                          ),
                          vars: z.optional(
                            z
                              .record(
                                z.string(),
                                z.union([
                                  z.boolean(),
                                  z.string(),
                                  z.number(),
                                  z.array(z.string()),
                                  z.array(z.number()),
                                  z.object({
                                    id: z.string(),
                                    isSecretRef: z.boolean(),
                                  }),
                                  z.null(),
                                ])
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Input/stream level variable. Refer to the integration documentation for more information.',
                              })
                          ),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
                      }),
                  ]),
                  is_managed: z.optional(z.boolean()),
                  name: z.string().register(z.globalRegistry, {
                    description: 'Unique name for the package policy.',
                  }),
                  namespace: z.optional(
                    z.string().register(z.globalRegistry, {
                      description:
                        "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
                    })
                  ),
                  output_id: z.optional(z.union([z.string(), z.null()])),
                  overrides: z.optional(
                    z.union([
                      z.object({
                        inputs: z.optional(z.record(z.string(), z.unknown())),
                      }),
                      z.null(),
                    ])
                  ),
                  package: z.optional(
                    z.object({
                      experimental_data_stream_features: z.optional(
                        z.array(
                          z.object({
                            data_stream: z.string(),
                            features: z.object({
                              doc_value_only_numeric: z.optional(z.boolean()),
                              doc_value_only_other: z.optional(z.boolean()),
                              synthetic_source: z.optional(z.boolean()),
                              tsdb: z.optional(z.boolean()),
                            }),
                          })
                        )
                      ),
                      fips_compatible: z.optional(z.boolean()),
                      name: z.string().register(z.globalRegistry, {
                        description: 'Package name',
                      }),
                      requires_root: z.optional(z.boolean()),
                      title: z.optional(z.string()),
                      version: z.string().register(z.globalRegistry, {
                        description: 'Package version',
                      }),
                    })
                  ),
                  policy_id: z.optional(z.union([z.string(), z.null()])),
                  policy_ids: z.optional(
                    z.array(
                      z.string().register(z.globalRegistry, {
                        description:
                          'IDs of the agent policies which that package policy will be added to.',
                      })
                    )
                  ),
                  revision: z.number().register(z.globalRegistry, {
                    description: 'Package policy revision.',
                  }),
                  secret_references: z.optional(
                    z.array(
                      z.object({
                        id: z.string(),
                      })
                    )
                  ),
                  spaceIds: z.optional(z.array(z.string())),
                  supports_agentless: z
                    .optional(z.union([z.boolean().default(false), z.null()]))
                    .default(false),
                  supports_cloud_connector: z
                    .optional(z.union([z.boolean().default(false), z.null()]))
                    .default(false),
                  updated_at: z.string(),
                  updated_by: z.string(),
                  vars: z.optional(
                    z.union([
                      z
                        .record(
                          z.string(),
                          z.object({
                            frozen: z.optional(z.boolean()),
                            type: z.optional(z.string()),
                            value: z.unknown(),
                          })
                        )
                        .register(z.globalRegistry, {
                          description:
                            'Package variable (see integration documentation for more information)',
                        }),
                      z
                        .record(
                          z.string(),
                          z.union([
                            z.boolean(),
                            z.string(),
                            z.number(),
                            z.array(z.string()),
                            z.array(z.number()),
                            z.object({
                              id: z.string(),
                              isSecretRef: z.boolean(),
                            }),
                            z.null(),
                          ])
                        )
                        .register(z.globalRegistry, {
                          description:
                            'Input/stream level variable. Refer to the integration documentation for more information.',
                        }),
                    ])
                  ),
                  version: z.optional(
                    z.string().register(z.globalRegistry, {
                      description: 'Package policy ES version.',
                    })
                  ),
                })
              )
              .register(z.globalRegistry, {
                description:
                  'This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter',
              }),
          ])
        ),
        required_versions: z.optional(
          z.union([
            z.array(
              z.object({
                percentage: z.number().gte(0).lte(100).register(z.globalRegistry, {
                  description: 'Target percentage of agents to auto upgrade',
                }),
                version: z.string().register(z.globalRegistry, {
                  description: 'Target version for automatic agent upgrade',
                }),
              })
            ),
            z.null(),
          ])
        ),
        revision: z.number(),
        schema_version: z.optional(z.string()),
        space_ids: z.optional(z.array(z.string())),
        status: z.enum(['active', 'inactive']),
        supports_agentless: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        unenroll_timeout: z.optional(z.number().gte(0)),
        unprivileged_agents: z.optional(z.number()),
        updated_at: z.string(),
        updated_by: z.string(),
        version: z.optional(z.string()),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agent_policies_agentpolicyid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    agentPolicyId: z.string(),
  }),
  query: z.optional(
    z.object({
      format: z.optional(z.enum(['simplified', 'legacy'])),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agent_policies_agentpolicyid_response = z
  .object({
    item: z.object({
      advanced_settings: z.optional(
        z.object({
          agent_download_target_directory: z.optional(z.unknown()),
          agent_download_timeout: z.optional(z.unknown()),
          agent_limits_go_max_procs: z.optional(z.unknown()),
          agent_logging_files_interval: z.optional(z.unknown()),
          agent_logging_files_keepfiles: z.optional(z.unknown()),
          agent_logging_files_rotateeverybytes: z.optional(z.unknown()),
          agent_logging_level: z.optional(z.unknown()),
          agent_logging_metrics_period: z.optional(z.unknown()),
          agent_logging_to_files: z.optional(z.unknown()),
          agent_monitoring_runtime_experimental: z.optional(z.unknown()),
        })
      ),
      agent_features: z.optional(
        z.array(
          z.object({
            enabled: z.boolean(),
            name: z.string(),
          })
        )
      ),
      agentless: z.optional(
        z.object({
          cloud_connectors: z.optional(
            z.object({
              enabled: z.boolean(),
              target_csp: z.optional(z.string()),
            })
          ),
          resources: z.optional(
            z.object({
              requests: z.optional(
                z.object({
                  cpu: z.optional(z.string()),
                  memory: z.optional(z.string()),
                })
              ),
            })
          ),
        })
      ),
      agents: z.optional(z.number()),
      data_output_id: z.optional(z.union([z.string(), z.null()])),
      description: z.optional(z.string()),
      download_source_id: z.optional(z.union([z.string(), z.null()])),
      fips_agents: z.optional(z.number()),
      fleet_server_host_id: z.optional(z.union([z.string(), z.null()])),
      global_data_tags: z.optional(
        z
          .array(
            z.object({
              name: z.string(),
              value: z.union([z.string(), z.number()]),
            })
          )
          .register(z.globalRegistry, {
            description:
              'User defined data tags that are added to all of the inputs. The values can be strings or numbers.',
          })
      ),
      has_fleet_server: z.optional(z.boolean()),
      id: z.string(),
      inactivity_timeout: z.optional(z.number().gte(0)).default(1209600),
      is_default: z.optional(z.boolean()),
      is_default_fleet_server: z.optional(z.boolean()),
      is_managed: z.optional(z.boolean()),
      is_preconfigured: z.optional(z.boolean()),
      is_protected: z.boolean().register(z.globalRegistry, {
        description:
          'Indicates whether the agent policy has tamper protection enabled. Default false.',
      }),
      keep_monitoring_alive: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      monitoring_diagnostics: z.optional(
        z.object({
          limit: z.optional(
            z.object({
              burst: z.optional(z.number()),
              interval: z.optional(z.string()),
            })
          ),
          uploader: z.optional(
            z.object({
              init_dur: z.optional(z.string()),
              max_dur: z.optional(z.string()),
              max_retries: z.optional(z.number()),
            })
          ),
        })
      ),
      monitoring_enabled: z.optional(z.array(z.enum(['logs', 'metrics', 'traces']))),
      monitoring_http: z.optional(
        z.object({
          buffer: z.optional(
            z.object({
              enabled: z.optional(z.boolean()).default(false),
            })
          ),
          enabled: z.optional(z.boolean()),
          host: z.optional(z.string()),
          port: z.optional(z.number().gte(0).lte(65353)),
        })
      ),
      monitoring_output_id: z.optional(z.union([z.string(), z.null()])),
      monitoring_pprof_enabled: z.optional(z.boolean()),
      name: z.string().min(1),
      namespace: z.string().min(1),
      overrides: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
      package_policies: z.optional(
        z.union([
          z.array(z.string()),
          z
            .array(
              z.object({
                additional_datastreams_permissions: z.optional(
                  z.union([z.array(z.string()), z.null()])
                ),
                agents: z.optional(z.number()),
                cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
                created_at: z.string(),
                created_by: z.string(),
                description: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'Package policy description',
                  })
                ),
                elasticsearch: z.optional(
                  z.object({
                    privileges: z.optional(
                      z.object({
                        cluster: z.optional(z.array(z.string())),
                      })
                    ),
                  })
                ),
                enabled: z.boolean(),
                id: z.string().register(z.globalRegistry, {
                  description: 'Package policy unique identifier.',
                }),
                inputs: z.union([
                  z.array(
                    z.object({
                      compiled_input: z.unknown(),
                      config: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              frozen: z.optional(z.boolean()),
                              type: z.optional(z.string()),
                              value: z.unknown(),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Package variable (see integration documentation for more information)',
                          })
                      ),
                      enabled: z.boolean(),
                      id: z.optional(z.string()),
                      keep_enabled: z.optional(z.boolean()),
                      policy_template: z.optional(z.string()),
                      streams: z.array(
                        z.object({
                          compiled_stream: z.unknown(),
                          config: z.optional(
                            z
                              .record(
                                z.string(),
                                z.object({
                                  frozen: z.optional(z.boolean()),
                                  type: z.optional(z.string()),
                                  value: z.unknown(),
                                })
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Package variable (see integration documentation for more information)',
                              })
                          ),
                          data_stream: z.object({
                            dataset: z.string(),
                            elasticsearch: z.optional(
                              z.object({
                                dynamic_dataset: z.optional(z.boolean()),
                                dynamic_namespace: z.optional(z.boolean()),
                                privileges: z.optional(
                                  z.object({
                                    indices: z.optional(z.array(z.string())),
                                  })
                                ),
                              })
                            ),
                            type: z.string(),
                          }),
                          enabled: z.boolean(),
                          id: z.optional(z.string()),
                          keep_enabled: z.optional(z.boolean()),
                          release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                          vars: z.optional(
                            z
                              .record(
                                z.string(),
                                z.object({
                                  frozen: z.optional(z.boolean()),
                                  type: z.optional(z.string()),
                                  value: z.unknown(),
                                })
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Package variable (see integration documentation for more information)',
                              })
                          ),
                        })
                      ),
                      type: z.string(),
                      vars: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              frozen: z.optional(z.boolean()),
                              type: z.optional(z.string()),
                              value: z.unknown(),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Package variable (see integration documentation for more information)',
                          })
                      ),
                    })
                  ),
                  z
                    .record(
                      z.string(),
                      z.object({
                        enabled: z.optional(
                          z.boolean().register(z.globalRegistry, {
                            description:
                              'Enable or disable that input. Defaults to `true` (enabled).',
                          })
                        ),
                        streams: z.optional(
                          z
                            .record(
                              z.string(),
                              z.object({
                                enabled: z.optional(
                                  z.boolean().register(z.globalRegistry, {
                                    description:
                                      'Enable or disable that stream. Defaults to `true` (enabled).',
                                  })
                                ),
                                vars: z.optional(
                                  z
                                    .record(
                                      z.string(),
                                      z.union([
                                        z.boolean(),
                                        z.string(),
                                        z.number(),
                                        z.array(z.string()),
                                        z.array(z.number()),
                                        z.object({
                                          id: z.string(),
                                          isSecretRef: z.boolean(),
                                        }),
                                        z.null(),
                                      ])
                                    )
                                    .register(z.globalRegistry, {
                                      description:
                                        'Input/stream level variable. Refer to the integration documentation for more information.',
                                    })
                                ),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input streams. Refer to the integration documentation to know which streams are available.',
                            })
                        ),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({
                                  id: z.string(),
                                  isSecretRef: z.boolean(),
                                }),
                                z.null(),
                              ])
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input/stream level variable. Refer to the integration documentation for more information.',
                            })
                        ),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
                    }),
                ]),
                is_managed: z.optional(z.boolean()),
                name: z.string().register(z.globalRegistry, {
                  description: 'Unique name for the package policy.',
                }),
                namespace: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
                  })
                ),
                output_id: z.optional(z.union([z.string(), z.null()])),
                overrides: z.optional(
                  z.union([
                    z.object({
                      inputs: z.optional(z.record(z.string(), z.unknown())),
                    }),
                    z.null(),
                  ])
                ),
                package: z.optional(
                  z.object({
                    experimental_data_stream_features: z.optional(
                      z.array(
                        z.object({
                          data_stream: z.string(),
                          features: z.object({
                            doc_value_only_numeric: z.optional(z.boolean()),
                            doc_value_only_other: z.optional(z.boolean()),
                            synthetic_source: z.optional(z.boolean()),
                            tsdb: z.optional(z.boolean()),
                          }),
                        })
                      )
                    ),
                    fips_compatible: z.optional(z.boolean()),
                    name: z.string().register(z.globalRegistry, {
                      description: 'Package name',
                    }),
                    requires_root: z.optional(z.boolean()),
                    title: z.optional(z.string()),
                    version: z.string().register(z.globalRegistry, {
                      description: 'Package version',
                    }),
                  })
                ),
                policy_id: z.optional(z.union([z.string(), z.null()])),
                policy_ids: z.optional(
                  z.array(
                    z.string().register(z.globalRegistry, {
                      description:
                        'IDs of the agent policies which that package policy will be added to.',
                    })
                  )
                ),
                revision: z.number().register(z.globalRegistry, {
                  description: 'Package policy revision.',
                }),
                secret_references: z.optional(
                  z.array(
                    z.object({
                      id: z.string(),
                    })
                  )
                ),
                spaceIds: z.optional(z.array(z.string())),
                supports_agentless: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                supports_cloud_connector: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                updated_at: z.string(),
                updated_by: z.string(),
                vars: z.optional(
                  z.union([
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      }),
                    z
                      .record(
                        z.string(),
                        z.union([
                          z.boolean(),
                          z.string(),
                          z.number(),
                          z.array(z.string()),
                          z.array(z.number()),
                          z.object({
                            id: z.string(),
                            isSecretRef: z.boolean(),
                          }),
                          z.null(),
                        ])
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Input/stream level variable. Refer to the integration documentation for more information.',
                      }),
                  ])
                ),
                version: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'Package policy ES version.',
                  })
                ),
              })
            )
            .register(z.globalRegistry, {
              description:
                'This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter',
            }),
        ])
      ),
      required_versions: z.optional(
        z.union([
          z.array(
            z.object({
              percentage: z.number().gte(0).lte(100).register(z.globalRegistry, {
                description: 'Target percentage of agents to auto upgrade',
              }),
              version: z.string().register(z.globalRegistry, {
                description: 'Target version for automatic agent upgrade',
              }),
            })
          ),
          z.null(),
        ])
      ),
      revision: z.number(),
      schema_version: z.optional(z.string()),
      space_ids: z.optional(z.array(z.string())),
      status: z.enum(['active', 'inactive']),
      supports_agentless: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      unenroll_timeout: z.optional(z.number().gte(0)),
      unprivileged_agents: z.optional(z.number()),
      updated_at: z.string(),
      updated_by: z.string(),
      version: z.optional(z.string()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_agent_policies_agentpolicyid_request = z.object({
  body: z.optional(
    z.object({
      advanced_settings: z.optional(
        z.object({
          agent_download_target_directory: z.optional(z.unknown()),
          agent_download_timeout: z.optional(z.unknown()),
          agent_limits_go_max_procs: z.optional(z.unknown()),
          agent_logging_files_interval: z.optional(z.unknown()),
          agent_logging_files_keepfiles: z.optional(z.unknown()),
          agent_logging_files_rotateeverybytes: z.optional(z.unknown()),
          agent_logging_level: z.optional(z.unknown()),
          agent_logging_metrics_period: z.optional(z.unknown()),
          agent_logging_to_files: z.optional(z.unknown()),
          agent_monitoring_runtime_experimental: z.optional(z.unknown()),
        })
      ),
      agent_features: z.optional(
        z.array(
          z.object({
            enabled: z.boolean(),
            name: z.string(),
          })
        )
      ),
      agentless: z.optional(
        z.object({
          cloud_connectors: z.optional(
            z.object({
              enabled: z.boolean(),
              target_csp: z.optional(z.string()),
            })
          ),
          resources: z.optional(
            z.object({
              requests: z.optional(
                z.object({
                  cpu: z.optional(z.string()),
                  memory: z.optional(z.string()),
                })
              ),
            })
          ),
        })
      ),
      bumpRevision: z.optional(z.boolean()),
      data_output_id: z.optional(z.union([z.string(), z.null()])),
      description: z.optional(z.string()),
      download_source_id: z.optional(z.union([z.string(), z.null()])),
      fleet_server_host_id: z.optional(z.union([z.string(), z.null()])),
      force: z.optional(z.boolean()),
      global_data_tags: z.optional(
        z
          .array(
            z.object({
              name: z.string(),
              value: z.union([z.string(), z.number()]),
            })
          )
          .register(z.globalRegistry, {
            description:
              'User defined data tags that are added to all of the inputs. The values can be strings or numbers.',
          })
      ),
      has_fleet_server: z.optional(z.boolean()),
      id: z.optional(z.string()),
      inactivity_timeout: z.optional(z.number().gte(0)).default(1209600),
      is_default: z.optional(z.boolean()),
      is_default_fleet_server: z.optional(z.boolean()),
      is_managed: z.optional(z.boolean()),
      is_protected: z.optional(z.boolean()),
      keep_monitoring_alive: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      monitoring_diagnostics: z.optional(
        z.object({
          limit: z.optional(
            z.object({
              burst: z.optional(z.number()),
              interval: z.optional(z.string()),
            })
          ),
          uploader: z.optional(
            z.object({
              init_dur: z.optional(z.string()),
              max_dur: z.optional(z.string()),
              max_retries: z.optional(z.number()),
            })
          ),
        })
      ),
      monitoring_enabled: z.optional(z.array(z.enum(['logs', 'metrics', 'traces']))),
      monitoring_http: z.optional(
        z.object({
          buffer: z.optional(
            z.object({
              enabled: z.optional(z.boolean()).default(false),
            })
          ),
          enabled: z.optional(z.boolean()),
          host: z.optional(z.string()),
          port: z.optional(z.number().gte(0).lte(65353)),
        })
      ),
      monitoring_output_id: z.optional(z.union([z.string(), z.null()])),
      monitoring_pprof_enabled: z.optional(z.boolean()),
      name: z.string().min(1),
      namespace: z.string().min(1),
      overrides: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
      required_versions: z.optional(
        z.union([
          z.array(
            z.object({
              percentage: z.number().gte(0).lte(100).register(z.globalRegistry, {
                description: 'Target percentage of agents to auto upgrade',
              }),
              version: z.string().register(z.globalRegistry, {
                description: 'Target version for automatic agent upgrade',
              }),
            })
          ),
          z.null(),
        ])
      ),
      space_ids: z.optional(z.array(z.string())),
      supports_agentless: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      unenroll_timeout: z.optional(z.number().gte(0)),
    })
  ),
  path: z.object({
    agentPolicyId: z.string(),
  }),
  query: z.optional(
    z.object({
      format: z.optional(z.enum(['simplified', 'legacy'])),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_agent_policies_agentpolicyid_response = z
  .object({
    item: z.object({
      advanced_settings: z.optional(
        z.object({
          agent_download_target_directory: z.optional(z.unknown()),
          agent_download_timeout: z.optional(z.unknown()),
          agent_limits_go_max_procs: z.optional(z.unknown()),
          agent_logging_files_interval: z.optional(z.unknown()),
          agent_logging_files_keepfiles: z.optional(z.unknown()),
          agent_logging_files_rotateeverybytes: z.optional(z.unknown()),
          agent_logging_level: z.optional(z.unknown()),
          agent_logging_metrics_period: z.optional(z.unknown()),
          agent_logging_to_files: z.optional(z.unknown()),
          agent_monitoring_runtime_experimental: z.optional(z.unknown()),
        })
      ),
      agent_features: z.optional(
        z.array(
          z.object({
            enabled: z.boolean(),
            name: z.string(),
          })
        )
      ),
      agentless: z.optional(
        z.object({
          cloud_connectors: z.optional(
            z.object({
              enabled: z.boolean(),
              target_csp: z.optional(z.string()),
            })
          ),
          resources: z.optional(
            z.object({
              requests: z.optional(
                z.object({
                  cpu: z.optional(z.string()),
                  memory: z.optional(z.string()),
                })
              ),
            })
          ),
        })
      ),
      agents: z.optional(z.number()),
      data_output_id: z.optional(z.union([z.string(), z.null()])),
      description: z.optional(z.string()),
      download_source_id: z.optional(z.union([z.string(), z.null()])),
      fips_agents: z.optional(z.number()),
      fleet_server_host_id: z.optional(z.union([z.string(), z.null()])),
      global_data_tags: z.optional(
        z
          .array(
            z.object({
              name: z.string(),
              value: z.union([z.string(), z.number()]),
            })
          )
          .register(z.globalRegistry, {
            description:
              'User defined data tags that are added to all of the inputs. The values can be strings or numbers.',
          })
      ),
      has_fleet_server: z.optional(z.boolean()),
      id: z.string(),
      inactivity_timeout: z.optional(z.number().gte(0)).default(1209600),
      is_default: z.optional(z.boolean()),
      is_default_fleet_server: z.optional(z.boolean()),
      is_managed: z.optional(z.boolean()),
      is_preconfigured: z.optional(z.boolean()),
      is_protected: z.boolean().register(z.globalRegistry, {
        description:
          'Indicates whether the agent policy has tamper protection enabled. Default false.',
      }),
      keep_monitoring_alive: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      monitoring_diagnostics: z.optional(
        z.object({
          limit: z.optional(
            z.object({
              burst: z.optional(z.number()),
              interval: z.optional(z.string()),
            })
          ),
          uploader: z.optional(
            z.object({
              init_dur: z.optional(z.string()),
              max_dur: z.optional(z.string()),
              max_retries: z.optional(z.number()),
            })
          ),
        })
      ),
      monitoring_enabled: z.optional(z.array(z.enum(['logs', 'metrics', 'traces']))),
      monitoring_http: z.optional(
        z.object({
          buffer: z.optional(
            z.object({
              enabled: z.optional(z.boolean()).default(false),
            })
          ),
          enabled: z.optional(z.boolean()),
          host: z.optional(z.string()),
          port: z.optional(z.number().gte(0).lte(65353)),
        })
      ),
      monitoring_output_id: z.optional(z.union([z.string(), z.null()])),
      monitoring_pprof_enabled: z.optional(z.boolean()),
      name: z.string().min(1),
      namespace: z.string().min(1),
      overrides: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
      package_policies: z.optional(
        z.union([
          z.array(z.string()),
          z
            .array(
              z.object({
                additional_datastreams_permissions: z.optional(
                  z.union([z.array(z.string()), z.null()])
                ),
                agents: z.optional(z.number()),
                cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
                created_at: z.string(),
                created_by: z.string(),
                description: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'Package policy description',
                  })
                ),
                elasticsearch: z.optional(
                  z.object({
                    privileges: z.optional(
                      z.object({
                        cluster: z.optional(z.array(z.string())),
                      })
                    ),
                  })
                ),
                enabled: z.boolean(),
                id: z.string().register(z.globalRegistry, {
                  description: 'Package policy unique identifier.',
                }),
                inputs: z.union([
                  z.array(
                    z.object({
                      compiled_input: z.unknown(),
                      config: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              frozen: z.optional(z.boolean()),
                              type: z.optional(z.string()),
                              value: z.unknown(),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Package variable (see integration documentation for more information)',
                          })
                      ),
                      enabled: z.boolean(),
                      id: z.optional(z.string()),
                      keep_enabled: z.optional(z.boolean()),
                      policy_template: z.optional(z.string()),
                      streams: z.array(
                        z.object({
                          compiled_stream: z.unknown(),
                          config: z.optional(
                            z
                              .record(
                                z.string(),
                                z.object({
                                  frozen: z.optional(z.boolean()),
                                  type: z.optional(z.string()),
                                  value: z.unknown(),
                                })
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Package variable (see integration documentation for more information)',
                              })
                          ),
                          data_stream: z.object({
                            dataset: z.string(),
                            elasticsearch: z.optional(
                              z.object({
                                dynamic_dataset: z.optional(z.boolean()),
                                dynamic_namespace: z.optional(z.boolean()),
                                privileges: z.optional(
                                  z.object({
                                    indices: z.optional(z.array(z.string())),
                                  })
                                ),
                              })
                            ),
                            type: z.string(),
                          }),
                          enabled: z.boolean(),
                          id: z.optional(z.string()),
                          keep_enabled: z.optional(z.boolean()),
                          release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                          vars: z.optional(
                            z
                              .record(
                                z.string(),
                                z.object({
                                  frozen: z.optional(z.boolean()),
                                  type: z.optional(z.string()),
                                  value: z.unknown(),
                                })
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Package variable (see integration documentation for more information)',
                              })
                          ),
                        })
                      ),
                      type: z.string(),
                      vars: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              frozen: z.optional(z.boolean()),
                              type: z.optional(z.string()),
                              value: z.unknown(),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Package variable (see integration documentation for more information)',
                          })
                      ),
                    })
                  ),
                  z
                    .record(
                      z.string(),
                      z.object({
                        enabled: z.optional(
                          z.boolean().register(z.globalRegistry, {
                            description:
                              'Enable or disable that input. Defaults to `true` (enabled).',
                          })
                        ),
                        streams: z.optional(
                          z
                            .record(
                              z.string(),
                              z.object({
                                enabled: z.optional(
                                  z.boolean().register(z.globalRegistry, {
                                    description:
                                      'Enable or disable that stream. Defaults to `true` (enabled).',
                                  })
                                ),
                                vars: z.optional(
                                  z
                                    .record(
                                      z.string(),
                                      z.union([
                                        z.boolean(),
                                        z.string(),
                                        z.number(),
                                        z.array(z.string()),
                                        z.array(z.number()),
                                        z.object({
                                          id: z.string(),
                                          isSecretRef: z.boolean(),
                                        }),
                                        z.null(),
                                      ])
                                    )
                                    .register(z.globalRegistry, {
                                      description:
                                        'Input/stream level variable. Refer to the integration documentation for more information.',
                                    })
                                ),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input streams. Refer to the integration documentation to know which streams are available.',
                            })
                        ),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({
                                  id: z.string(),
                                  isSecretRef: z.boolean(),
                                }),
                                z.null(),
                              ])
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input/stream level variable. Refer to the integration documentation for more information.',
                            })
                        ),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
                    }),
                ]),
                is_managed: z.optional(z.boolean()),
                name: z.string().register(z.globalRegistry, {
                  description: 'Unique name for the package policy.',
                }),
                namespace: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
                  })
                ),
                output_id: z.optional(z.union([z.string(), z.null()])),
                overrides: z.optional(
                  z.union([
                    z.object({
                      inputs: z.optional(z.record(z.string(), z.unknown())),
                    }),
                    z.null(),
                  ])
                ),
                package: z.optional(
                  z.object({
                    experimental_data_stream_features: z.optional(
                      z.array(
                        z.object({
                          data_stream: z.string(),
                          features: z.object({
                            doc_value_only_numeric: z.optional(z.boolean()),
                            doc_value_only_other: z.optional(z.boolean()),
                            synthetic_source: z.optional(z.boolean()),
                            tsdb: z.optional(z.boolean()),
                          }),
                        })
                      )
                    ),
                    fips_compatible: z.optional(z.boolean()),
                    name: z.string().register(z.globalRegistry, {
                      description: 'Package name',
                    }),
                    requires_root: z.optional(z.boolean()),
                    title: z.optional(z.string()),
                    version: z.string().register(z.globalRegistry, {
                      description: 'Package version',
                    }),
                  })
                ),
                policy_id: z.optional(z.union([z.string(), z.null()])),
                policy_ids: z.optional(
                  z.array(
                    z.string().register(z.globalRegistry, {
                      description:
                        'IDs of the agent policies which that package policy will be added to.',
                    })
                  )
                ),
                revision: z.number().register(z.globalRegistry, {
                  description: 'Package policy revision.',
                }),
                secret_references: z.optional(
                  z.array(
                    z.object({
                      id: z.string(),
                    })
                  )
                ),
                spaceIds: z.optional(z.array(z.string())),
                supports_agentless: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                supports_cloud_connector: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                updated_at: z.string(),
                updated_by: z.string(),
                vars: z.optional(
                  z.union([
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      }),
                    z
                      .record(
                        z.string(),
                        z.union([
                          z.boolean(),
                          z.string(),
                          z.number(),
                          z.array(z.string()),
                          z.array(z.number()),
                          z.object({
                            id: z.string(),
                            isSecretRef: z.boolean(),
                          }),
                          z.null(),
                        ])
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Input/stream level variable. Refer to the integration documentation for more information.',
                      }),
                  ])
                ),
                version: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'Package policy ES version.',
                  })
                ),
              })
            )
            .register(z.globalRegistry, {
              description:
                'This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter',
            }),
        ])
      ),
      required_versions: z.optional(
        z.union([
          z.array(
            z.object({
              percentage: z.number().gte(0).lte(100).register(z.globalRegistry, {
                description: 'Target percentage of agents to auto upgrade',
              }),
              version: z.string().register(z.globalRegistry, {
                description: 'Target version for automatic agent upgrade',
              }),
            })
          ),
          z.null(),
        ])
      ),
      revision: z.number(),
      schema_version: z.optional(z.string()),
      space_ids: z.optional(z.array(z.string())),
      status: z.enum(['active', 'inactive']),
      supports_agentless: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      unenroll_timeout: z.optional(z.number().gte(0)),
      unprivileged_agents: z.optional(z.number()),
      updated_at: z.string(),
      updated_by: z.string(),
      version: z.optional(z.string()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agent_policies_agentpolicyid_auto_upgrade_agents_status_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    agentPolicyId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agent_policies_agentpolicyid_auto_upgrade_agents_status_response = z
  .object({
    currentVersions: z.array(
      z.object({
        agents: z.number().register(z.globalRegistry, {
          description: 'Number of agents that upgraded to this version',
        }),
        failedUpgradeActionIds: z.optional(
          z.array(z.string()).register(z.globalRegistry, {
            description: 'List of action IDs related to failed upgrades',
          })
        ),
        failedUpgradeAgents: z.number().register(z.globalRegistry, {
          description: 'Number of agents that failed to upgrade to this version',
        }),
        inProgressUpgradeActionIds: z.optional(
          z.array(z.string()).register(z.globalRegistry, {
            description: 'List of action IDs related to in-progress upgrades',
          })
        ),
        inProgressUpgradeAgents: z.number().register(z.globalRegistry, {
          description: 'Number of agents that are upgrading to this version',
        }),
        version: z.string().register(z.globalRegistry, {
          description: 'Agent version',
        }),
      })
    ),
    totalAgents: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agent_policies_agentpolicyid_copy_request = z.object({
  body: z.optional(
    z.object({
      description: z.optional(z.string()),
      name: z.string().min(1),
    })
  ),
  path: z.object({
    agentPolicyId: z.string(),
  }),
  query: z.optional(
    z.object({
      format: z.optional(z.enum(['simplified', 'legacy'])),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agent_policies_agentpolicyid_copy_response = z
  .object({
    item: z.object({
      advanced_settings: z.optional(
        z.object({
          agent_download_target_directory: z.optional(z.unknown()),
          agent_download_timeout: z.optional(z.unknown()),
          agent_limits_go_max_procs: z.optional(z.unknown()),
          agent_logging_files_interval: z.optional(z.unknown()),
          agent_logging_files_keepfiles: z.optional(z.unknown()),
          agent_logging_files_rotateeverybytes: z.optional(z.unknown()),
          agent_logging_level: z.optional(z.unknown()),
          agent_logging_metrics_period: z.optional(z.unknown()),
          agent_logging_to_files: z.optional(z.unknown()),
          agent_monitoring_runtime_experimental: z.optional(z.unknown()),
        })
      ),
      agent_features: z.optional(
        z.array(
          z.object({
            enabled: z.boolean(),
            name: z.string(),
          })
        )
      ),
      agentless: z.optional(
        z.object({
          cloud_connectors: z.optional(
            z.object({
              enabled: z.boolean(),
              target_csp: z.optional(z.string()),
            })
          ),
          resources: z.optional(
            z.object({
              requests: z.optional(
                z.object({
                  cpu: z.optional(z.string()),
                  memory: z.optional(z.string()),
                })
              ),
            })
          ),
        })
      ),
      agents: z.optional(z.number()),
      data_output_id: z.optional(z.union([z.string(), z.null()])),
      description: z.optional(z.string()),
      download_source_id: z.optional(z.union([z.string(), z.null()])),
      fips_agents: z.optional(z.number()),
      fleet_server_host_id: z.optional(z.union([z.string(), z.null()])),
      global_data_tags: z.optional(
        z
          .array(
            z.object({
              name: z.string(),
              value: z.union([z.string(), z.number()]),
            })
          )
          .register(z.globalRegistry, {
            description:
              'User defined data tags that are added to all of the inputs. The values can be strings or numbers.',
          })
      ),
      has_fleet_server: z.optional(z.boolean()),
      id: z.string(),
      inactivity_timeout: z.optional(z.number().gte(0)).default(1209600),
      is_default: z.optional(z.boolean()),
      is_default_fleet_server: z.optional(z.boolean()),
      is_managed: z.optional(z.boolean()),
      is_preconfigured: z.optional(z.boolean()),
      is_protected: z.boolean().register(z.globalRegistry, {
        description:
          'Indicates whether the agent policy has tamper protection enabled. Default false.',
      }),
      keep_monitoring_alive: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      monitoring_diagnostics: z.optional(
        z.object({
          limit: z.optional(
            z.object({
              burst: z.optional(z.number()),
              interval: z.optional(z.string()),
            })
          ),
          uploader: z.optional(
            z.object({
              init_dur: z.optional(z.string()),
              max_dur: z.optional(z.string()),
              max_retries: z.optional(z.number()),
            })
          ),
        })
      ),
      monitoring_enabled: z.optional(z.array(z.enum(['logs', 'metrics', 'traces']))),
      monitoring_http: z.optional(
        z.object({
          buffer: z.optional(
            z.object({
              enabled: z.optional(z.boolean()).default(false),
            })
          ),
          enabled: z.optional(z.boolean()),
          host: z.optional(z.string()),
          port: z.optional(z.number().gte(0).lte(65353)),
        })
      ),
      monitoring_output_id: z.optional(z.union([z.string(), z.null()])),
      monitoring_pprof_enabled: z.optional(z.boolean()),
      name: z.string().min(1),
      namespace: z.string().min(1),
      overrides: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
      package_policies: z.optional(
        z.union([
          z.array(z.string()),
          z
            .array(
              z.object({
                additional_datastreams_permissions: z.optional(
                  z.union([z.array(z.string()), z.null()])
                ),
                agents: z.optional(z.number()),
                cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
                created_at: z.string(),
                created_by: z.string(),
                description: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'Package policy description',
                  })
                ),
                elasticsearch: z.optional(
                  z.object({
                    privileges: z.optional(
                      z.object({
                        cluster: z.optional(z.array(z.string())),
                      })
                    ),
                  })
                ),
                enabled: z.boolean(),
                id: z.string().register(z.globalRegistry, {
                  description: 'Package policy unique identifier.',
                }),
                inputs: z.union([
                  z.array(
                    z.object({
                      compiled_input: z.unknown(),
                      config: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              frozen: z.optional(z.boolean()),
                              type: z.optional(z.string()),
                              value: z.unknown(),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Package variable (see integration documentation for more information)',
                          })
                      ),
                      enabled: z.boolean(),
                      id: z.optional(z.string()),
                      keep_enabled: z.optional(z.boolean()),
                      policy_template: z.optional(z.string()),
                      streams: z.array(
                        z.object({
                          compiled_stream: z.unknown(),
                          config: z.optional(
                            z
                              .record(
                                z.string(),
                                z.object({
                                  frozen: z.optional(z.boolean()),
                                  type: z.optional(z.string()),
                                  value: z.unknown(),
                                })
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Package variable (see integration documentation for more information)',
                              })
                          ),
                          data_stream: z.object({
                            dataset: z.string(),
                            elasticsearch: z.optional(
                              z.object({
                                dynamic_dataset: z.optional(z.boolean()),
                                dynamic_namespace: z.optional(z.boolean()),
                                privileges: z.optional(
                                  z.object({
                                    indices: z.optional(z.array(z.string())),
                                  })
                                ),
                              })
                            ),
                            type: z.string(),
                          }),
                          enabled: z.boolean(),
                          id: z.optional(z.string()),
                          keep_enabled: z.optional(z.boolean()),
                          release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                          vars: z.optional(
                            z
                              .record(
                                z.string(),
                                z.object({
                                  frozen: z.optional(z.boolean()),
                                  type: z.optional(z.string()),
                                  value: z.unknown(),
                                })
                              )
                              .register(z.globalRegistry, {
                                description:
                                  'Package variable (see integration documentation for more information)',
                              })
                          ),
                        })
                      ),
                      type: z.string(),
                      vars: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              frozen: z.optional(z.boolean()),
                              type: z.optional(z.string()),
                              value: z.unknown(),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Package variable (see integration documentation for more information)',
                          })
                      ),
                    })
                  ),
                  z
                    .record(
                      z.string(),
                      z.object({
                        enabled: z.optional(
                          z.boolean().register(z.globalRegistry, {
                            description:
                              'Enable or disable that input. Defaults to `true` (enabled).',
                          })
                        ),
                        streams: z.optional(
                          z
                            .record(
                              z.string(),
                              z.object({
                                enabled: z.optional(
                                  z.boolean().register(z.globalRegistry, {
                                    description:
                                      'Enable or disable that stream. Defaults to `true` (enabled).',
                                  })
                                ),
                                vars: z.optional(
                                  z
                                    .record(
                                      z.string(),
                                      z.union([
                                        z.boolean(),
                                        z.string(),
                                        z.number(),
                                        z.array(z.string()),
                                        z.array(z.number()),
                                        z.object({
                                          id: z.string(),
                                          isSecretRef: z.boolean(),
                                        }),
                                        z.null(),
                                      ])
                                    )
                                    .register(z.globalRegistry, {
                                      description:
                                        'Input/stream level variable. Refer to the integration documentation for more information.',
                                    })
                                ),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input streams. Refer to the integration documentation to know which streams are available.',
                            })
                        ),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({
                                  id: z.string(),
                                  isSecretRef: z.boolean(),
                                }),
                                z.null(),
                              ])
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input/stream level variable. Refer to the integration documentation for more information.',
                            })
                        ),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
                    }),
                ]),
                is_managed: z.optional(z.boolean()),
                name: z.string().register(z.globalRegistry, {
                  description: 'Unique name for the package policy.',
                }),
                namespace: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
                  })
                ),
                output_id: z.optional(z.union([z.string(), z.null()])),
                overrides: z.optional(
                  z.union([
                    z.object({
                      inputs: z.optional(z.record(z.string(), z.unknown())),
                    }),
                    z.null(),
                  ])
                ),
                package: z.optional(
                  z.object({
                    experimental_data_stream_features: z.optional(
                      z.array(
                        z.object({
                          data_stream: z.string(),
                          features: z.object({
                            doc_value_only_numeric: z.optional(z.boolean()),
                            doc_value_only_other: z.optional(z.boolean()),
                            synthetic_source: z.optional(z.boolean()),
                            tsdb: z.optional(z.boolean()),
                          }),
                        })
                      )
                    ),
                    fips_compatible: z.optional(z.boolean()),
                    name: z.string().register(z.globalRegistry, {
                      description: 'Package name',
                    }),
                    requires_root: z.optional(z.boolean()),
                    title: z.optional(z.string()),
                    version: z.string().register(z.globalRegistry, {
                      description: 'Package version',
                    }),
                  })
                ),
                policy_id: z.optional(z.union([z.string(), z.null()])),
                policy_ids: z.optional(
                  z.array(
                    z.string().register(z.globalRegistry, {
                      description:
                        'IDs of the agent policies which that package policy will be added to.',
                    })
                  )
                ),
                revision: z.number().register(z.globalRegistry, {
                  description: 'Package policy revision.',
                }),
                secret_references: z.optional(
                  z.array(
                    z.object({
                      id: z.string(),
                    })
                  )
                ),
                spaceIds: z.optional(z.array(z.string())),
                supports_agentless: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                supports_cloud_connector: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                updated_at: z.string(),
                updated_by: z.string(),
                vars: z.optional(
                  z.union([
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      }),
                    z
                      .record(
                        z.string(),
                        z.union([
                          z.boolean(),
                          z.string(),
                          z.number(),
                          z.array(z.string()),
                          z.array(z.number()),
                          z.object({
                            id: z.string(),
                            isSecretRef: z.boolean(),
                          }),
                          z.null(),
                        ])
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Input/stream level variable. Refer to the integration documentation for more information.',
                      }),
                  ])
                ),
                version: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'Package policy ES version.',
                  })
                ),
              })
            )
            .register(z.globalRegistry, {
              description:
                'This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter',
            }),
        ])
      ),
      required_versions: z.optional(
        z.union([
          z.array(
            z.object({
              percentage: z.number().gte(0).lte(100).register(z.globalRegistry, {
                description: 'Target percentage of agents to auto upgrade',
              }),
              version: z.string().register(z.globalRegistry, {
                description: 'Target version for automatic agent upgrade',
              }),
            })
          ),
          z.null(),
        ])
      ),
      revision: z.number(),
      schema_version: z.optional(z.string()),
      space_ids: z.optional(z.array(z.string())),
      status: z.enum(['active', 'inactive']),
      supports_agentless: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      unenroll_timeout: z.optional(z.number().gte(0)),
      unprivileged_agents: z.optional(z.number()),
      updated_at: z.string(),
      updated_by: z.string(),
      version: z.optional(z.string()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agent_policies_agentpolicyid_download_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    agentPolicyId: z.string(),
  }),
  query: z.optional(
    z.object({
      download: z.optional(z.boolean()),
      standalone: z.optional(z.boolean()),
      kubernetes: z.optional(z.boolean()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agent_policies_agentpolicyid_download_response = z
  .string()
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agent_policies_agentpolicyid_full_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    agentPolicyId: z.string(),
  }),
  query: z.optional(
    z.object({
      download: z.optional(z.boolean()),
      standalone: z.optional(z.boolean()),
      kubernetes: z.optional(z.boolean()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agent_policies_agentpolicyid_full_response = z
  .object({
    item: z.union([
      z.string(),
      z.object({
        agent: z.optional(
          z.object({
            download: z.object({
              proxy_headers: z.optional(
                z.union([
                  z.record(z.string(), z.union([z.string(), z.boolean(), z.number()])),
                  z.null(),
                ])
              ),
              proxy_url: z.optional(z.string()),
              secrets: z.optional(
                z.object({
                  ssl: z.optional(
                    z.object({
                      key: z.object({
                        id: z.optional(z.string()),
                      }),
                    })
                  ),
                })
              ),
              sourceURI: z.string(),
              ssl: z.optional(
                z.object({
                  certificate: z.optional(z.string()),
                  certificate_authorities: z.optional(z.array(z.string())),
                  key: z.optional(z.string()),
                  renegotiation: z.optional(z.string()),
                  verification_mode: z.optional(z.string()),
                })
              ),
              target_directory: z.optional(z.string()),
              timeout: z.optional(z.string()),
            }),
            features: z.record(
              z.string(),
              z.object({
                enabled: z.boolean(),
              })
            ),
            limits: z.optional(
              z.object({
                go_max_procs: z.optional(z.number()),
              })
            ),
            logging: z.optional(
              z.object({
                files: z.optional(
                  z.object({
                    interval: z.optional(z.string()),
                    keepfiles: z.optional(z.number()),
                    rotateeverybytes: z.optional(z.number()),
                  })
                ),
                level: z.optional(z.string()),
                metrics: z.optional(
                  z.object({
                    period: z.optional(z.string()),
                  })
                ),
                to_files: z.optional(z.boolean()),
              })
            ),
            monitoring: z.object({
              _runtime_experimental: z.optional(z.string()),
              apm: z.unknown(),
              diagnostics: z.optional(
                z.object({
                  limit: z.optional(
                    z.object({
                      burst: z.optional(z.number()),
                      interval: z.optional(z.string()),
                    })
                  ),
                  uploader: z.optional(
                    z.object({
                      init_dur: z.optional(z.string()),
                      max_dur: z.optional(z.string()),
                      max_retries: z.optional(z.number()),
                    })
                  ),
                })
              ),
              enabled: z.boolean(),
              http: z.optional(
                z.object({
                  enabled: z.optional(z.boolean()),
                  host: z.optional(z.string()),
                  port: z.optional(z.number()),
                })
              ),
              logs: z.boolean(),
              metrics: z.boolean(),
              namespace: z.optional(z.string()),
              pprof: z.optional(
                z.object({
                  enabled: z.boolean(),
                })
              ),
              traces: z.boolean(),
              use_output: z.optional(z.string()),
            }),
            protection: z.optional(
              z.object({
                enabled: z.boolean(),
                signing_key: z.string(),
                uninstall_token_hash: z.string(),
              })
            ),
          })
        ),
        connectors: z.optional(z.record(z.string(), z.unknown())),
        exporters: z.optional(z.record(z.string(), z.unknown())),
        extensions: z.optional(z.record(z.string(), z.unknown())),
        fleet: z.optional(
          z.union([
            z.object({
              hosts: z.array(z.string()),
              proxy_headers: z.optional(
                z.union([
                  z.record(z.string(), z.union([z.string(), z.boolean(), z.number()])),
                  z.null(),
                ])
              ),
              proxy_url: z.optional(z.string()),
              secrets: z.optional(
                z.object({
                  ssl: z.optional(
                    z.object({
                      key: z.object({
                        id: z.optional(z.string()),
                      }),
                    })
                  ),
                })
              ),
              ssl: z.optional(
                z.object({
                  certificate: z.optional(z.string()),
                  certificate_authorities: z.optional(z.array(z.string())),
                  key: z.optional(z.string()),
                  renegotiation: z.optional(z.string()),
                  verification_mode: z.optional(z.string()),
                })
              ),
            }),
            z.object({
              kibana: z.object({
                hosts: z.array(z.string()),
                path: z.optional(z.string()),
                protocol: z.string(),
              }),
            }),
          ])
        ),
        id: z.string(),
        inputs: z.array(
          z.object({
            data_stream: z.object({
              namespace: z.string(),
            }),
            id: z.string(),
            meta: z.optional(
              z.object({
                package: z.optional(
                  z.object({
                    name: z.string(),
                    version: z.string(),
                  })
                ),
              })
            ),
            name: z.string(),
            package_policy_id: z.string(),
            processors: z.optional(
              z.array(
                z.object({
                  add_fields: z.object({
                    fields: z.record(z.string(), z.union([z.string(), z.number()])),
                    target: z.string(),
                  }),
                })
              )
            ),
            revision: z.number(),
            streams: z.optional(
              z.array(
                z.object({
                  data_stream: z.object({
                    dataset: z.string(),
                    type: z.optional(z.string()),
                  }),
                  id: z.string(),
                })
              )
            ),
            type: z.string(),
            use_output: z.string(),
          })
        ),
        namespaces: z.optional(z.array(z.string())),
        output_permissions: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
        outputs: z.record(
          z.string(),
          z.object({
            ca_sha256: z.optional(z.union([z.string(), z.null()])),
            hosts: z.optional(z.array(z.string())),
            proxy_headers: z.optional(
              z.union([
                z.record(z.string(), z.union([z.string(), z.boolean(), z.number()])),
                z.null(),
              ])
            ),
            proxy_url: z.optional(z.string()),
            type: z.string(),
          })
        ),
        processors: z.optional(z.record(z.string(), z.unknown())),
        receivers: z.optional(z.record(z.string(), z.unknown())),
        revision: z.optional(z.number()),
        secret_references: z.optional(
          z.array(
            z.object({
              id: z.string(),
            })
          )
        ),
        service: z.optional(
          z.object({
            extensions: z.optional(z.array(z.string())),
            pipelines: z.optional(
              z.record(
                z.string(),
                z.object({
                  exporters: z.optional(z.array(z.string())),
                  processors: z.optional(z.array(z.string())),
                  receivers: z.optional(z.array(z.string())),
                })
              )
            ),
          })
        ),
        signed: z.optional(
          z.object({
            data: z.string(),
            signature: z.string(),
          })
        ),
      }),
    ]),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agent_policies_agentpolicyid_outputs_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    agentPolicyId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agent_policies_agentpolicyid_outputs_response = z
  .object({
    item: z.object({
      agentPolicyId: z.optional(z.string()),
      data: z.object({
        integrations: z.optional(
          z.array(
            z.object({
              id: z.optional(z.string()),
              integrationPolicyName: z.optional(z.string()),
              name: z.optional(z.string()),
              pkgName: z.optional(z.string()),
            })
          )
        ),
        output: z.object({
          id: z.string(),
          name: z.string(),
        }),
      }),
      monitoring: z.object({
        output: z.object({
          id: z.string(),
          name: z.string(),
        }),
      }),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agent_policies_delete_request = z.object({
  body: z.optional(
    z.object({
      agentPolicyId: z.string(),
      force: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'bypass validation checks that can prevent agent policy deletion',
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agent_policies_delete_response = z
  .object({
    id: z.string(),
    name: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agent_policies_outputs_request = z.object({
  body: z.optional(
    z.object({
      ids: z.array(z.string()).register(z.globalRegistry, {
        description: 'list of package policy ids',
      }),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agent_policies_outputs_response = z
  .object({
    items: z.array(
      z.object({
        agentPolicyId: z.optional(z.string()),
        data: z.object({
          integrations: z.optional(
            z.array(
              z.object({
                id: z.optional(z.string()),
                integrationPolicyName: z.optional(z.string()),
                name: z.optional(z.string()),
                pkgName: z.optional(z.string()),
              })
            )
          ),
          output: z.object({
            id: z.string(),
            name: z.string(),
          }),
        }),
        monitoring: z.object({
          output: z.object({
            id: z.string(),
            name: z.string(),
          }),
        }),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agent_status_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      policyId: z.optional(z.string()),
      policyIds: z.optional(z.union([z.array(z.string()), z.string()])),
      kuery: z.optional(z.string()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agent_status_response = z
  .object({
    results: z.object({
      active: z.number(),
      all: z.number(),
      error: z.number(),
      events: z.number(),
      inactive: z.number(),
      offline: z.number(),
      online: z.number(),
      orphaned: z.optional(z.number()),
      other: z.number(),
      unenrolled: z.number(),
      uninstalled: z.optional(z.number()),
      updating: z.number(),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agent_status_data_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    agentsIds: z.union([z.array(z.string()), z.string()]),
    pkgName: z.optional(z.string()),
    pkgVersion: z.optional(z.string()),
    previewData: z.optional(z.boolean()).default(false),
  }),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agent_status_data_response = z
  .object({
    dataPreview: z.array(z.unknown()),
    items: z.array(
      z.record(
        z.string(),
        z.object({
          data: z.boolean(),
        })
      )
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agentless_policies_request = z.object({
  body: z.optional(
    z.object({
      additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Policy description.',
        })
      ),
      force: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Force package policy creation even if the package is not verified, or if the agent policy is managed.',
        })
      ),
      id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Policy unique identifier.',
        })
      ),
      inputs: z.optional(
        z
          .record(
            z.string(),
            z.object({
              enabled: z.optional(
                z.boolean().register(z.globalRegistry, {
                  description: 'Enable or disable that input. Defaults to `true` (enabled).',
                })
              ),
              streams: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      enabled: z.optional(
                        z.boolean().register(z.globalRegistry, {
                          description:
                            'Enable or disable that stream. Defaults to `true` (enabled).',
                        })
                      ),
                      vars: z.optional(
                        z
                          .record(
                            z.string(),
                            z.union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({
                                id: z.string(),
                                isSecretRef: z.boolean(),
                              }),
                              z.null(),
                            ])
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Input/stream level variable. Refer to the integration documentation for more information.',
                          })
                      ),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Input streams. Refer to the integration documentation to know which streams are available.',
                  })
              ),
              vars: z.optional(
                z
                  .record(
                    z.string(),
                    z.union([
                      z.boolean(),
                      z.string(),
                      z.number(),
                      z.array(z.string()),
                      z.array(z.number()),
                      z.object({
                        id: z.string(),
                        isSecretRef: z.boolean(),
                      }),
                      z.null(),
                    ])
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Input/stream level variable. Refer to the integration documentation for more information.',
                  })
              ),
            })
          )
          .register(z.globalRegistry, {
            description:
              'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
          })
      ),
      name: z.string().register(z.globalRegistry, {
        description: 'Unique name for the policy.',
      }),
      namespace: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Policy namespace. When not specified, it inherits the agent policy namespace.',
        })
      ),
      package: z.object({
        experimental_data_stream_features: z.optional(
          z.array(
            z.object({
              data_stream: z.string(),
              features: z.object({
                doc_value_only_numeric: z.optional(z.boolean()),
                doc_value_only_other: z.optional(z.boolean()),
                synthetic_source: z.optional(z.boolean()),
                tsdb: z.optional(z.boolean()),
              }),
            })
          )
        ),
        fips_compatible: z.optional(z.boolean()),
        name: z.string().register(z.globalRegistry, {
          description: 'Package name',
        }),
        requires_root: z.optional(z.boolean()),
        title: z.optional(z.string()),
        version: z.string().register(z.globalRegistry, {
          description: 'Package version',
        }),
      }),
      vars: z.optional(
        z
          .record(
            z.string(),
            z.union([
              z.boolean(),
              z.string(),
              z.number(),
              z.array(z.string()),
              z.array(z.number()),
              z.object({
                id: z.string(),
                isSecretRef: z.boolean(),
              }),
              z.null(),
            ])
          )
          .register(z.globalRegistry, {
            description:
              'Input/stream level variable. Refer to the integration documentation for more information.',
          })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      format: z.optional(
        z.enum(['legacy', 'simplified']).register(z.globalRegistry, {
          description: 'The format of the response package policy.',
        })
      ),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful response
 */
export const post_fleet_agentless_policies_response = z
  .object({
    item: z
      .object({
        additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
        agents: z.optional(z.number()),
        cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
        created_at: z.string(),
        created_by: z.string(),
        description: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Package policy description',
          })
        ),
        elasticsearch: z.optional(
          z.object({
            privileges: z.optional(
              z.object({
                cluster: z.optional(z.array(z.string())),
              })
            ),
          })
        ),
        enabled: z.boolean(),
        id: z.string().register(z.globalRegistry, {
          description: 'Package policy unique identifier.',
        }),
        inputs: z.union([
          z.array(
            z.object({
              compiled_input: z.unknown(),
              config: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      frozen: z.optional(z.boolean()),
                      type: z.optional(z.string()),
                      value: z.unknown(),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Package variable (see integration documentation for more information)',
                  })
              ),
              enabled: z.boolean(),
              id: z.optional(z.string()),
              keep_enabled: z.optional(z.boolean()),
              policy_template: z.optional(z.string()),
              streams: z.array(
                z.object({
                  compiled_stream: z.unknown(),
                  config: z.optional(
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      })
                  ),
                  data_stream: z.object({
                    dataset: z.string(),
                    elasticsearch: z.optional(
                      z.object({
                        dynamic_dataset: z.optional(z.boolean()),
                        dynamic_namespace: z.optional(z.boolean()),
                        privileges: z.optional(
                          z.object({
                            indices: z.optional(z.array(z.string())),
                          })
                        ),
                      })
                    ),
                    type: z.string(),
                  }),
                  enabled: z.boolean(),
                  id: z.optional(z.string()),
                  keep_enabled: z.optional(z.boolean()),
                  release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                  vars: z.optional(
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      })
                  ),
                })
              ),
              type: z.string(),
              vars: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      frozen: z.optional(z.boolean()),
                      type: z.optional(z.string()),
                      value: z.unknown(),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Package variable (see integration documentation for more information)',
                  })
              ),
            })
          ),
          z
            .record(
              z.string(),
              z.object({
                enabled: z.optional(
                  z.boolean().register(z.globalRegistry, {
                    description: 'Enable or disable that input. Defaults to `true` (enabled).',
                  })
                ),
                streams: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        enabled: z.optional(
                          z.boolean().register(z.globalRegistry, {
                            description:
                              'Enable or disable that stream. Defaults to `true` (enabled).',
                          })
                        ),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({
                                  id: z.string(),
                                  isSecretRef: z.boolean(),
                                }),
                                z.null(),
                              ])
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input/stream level variable. Refer to the integration documentation for more information.',
                            })
                        ),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input streams. Refer to the integration documentation to know which streams are available.',
                    })
                ),
                vars: z.optional(
                  z
                    .record(
                      z.string(),
                      z.union([
                        z.boolean(),
                        z.string(),
                        z.number(),
                        z.array(z.string()),
                        z.array(z.number()),
                        z.object({
                          id: z.string(),
                          isSecretRef: z.boolean(),
                        }),
                        z.null(),
                      ])
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input/stream level variable. Refer to the integration documentation for more information.',
                    })
                ),
              })
            )
            .register(z.globalRegistry, {
              description:
                'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
            }),
        ]),
        is_managed: z.optional(z.boolean()),
        name: z.string().register(z.globalRegistry, {
          description: 'Unique name for the package policy.',
        }),
        namespace: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
          })
        ),
        output_id: z.optional(z.union([z.string(), z.null()])),
        overrides: z.optional(
          z.union([
            z.object({
              inputs: z.optional(z.record(z.string(), z.unknown())),
            }),
            z.null(),
          ])
        ),
        package: z.optional(
          z.object({
            experimental_data_stream_features: z.optional(
              z.array(
                z.object({
                  data_stream: z.string(),
                  features: z.object({
                    doc_value_only_numeric: z.optional(z.boolean()),
                    doc_value_only_other: z.optional(z.boolean()),
                    synthetic_source: z.optional(z.boolean()),
                    tsdb: z.optional(z.boolean()),
                  }),
                })
              )
            ),
            fips_compatible: z.optional(z.boolean()),
            name: z.string().register(z.globalRegistry, {
              description: 'Package name',
            }),
            requires_root: z.optional(z.boolean()),
            title: z.optional(z.string()),
            version: z.string().register(z.globalRegistry, {
              description: 'Package version',
            }),
          })
        ),
        policy_id: z.optional(z.union([z.string(), z.null()])),
        policy_ids: z.optional(
          z.array(
            z.string().register(z.globalRegistry, {
              description: 'IDs of the agent policies which that package policy will be added to.',
            })
          )
        ),
        revision: z.number().register(z.globalRegistry, {
          description: 'Package policy revision.',
        }),
        secret_references: z.optional(
          z.array(
            z.object({
              id: z.string(),
            })
          )
        ),
        spaceIds: z.optional(z.array(z.string())),
        supports_agentless: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        supports_cloud_connector: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        updated_at: z.string(),
        updated_by: z.string(),
        vars: z.optional(
          z.union([
            z
              .record(
                z.string(),
                z.object({
                  frozen: z.optional(z.boolean()),
                  type: z.optional(z.string()),
                  value: z.unknown(),
                })
              )
              .register(z.globalRegistry, {
                description:
                  'Package variable (see integration documentation for more information)',
              }),
            z
              .record(
                z.string(),
                z.union([
                  z.boolean(),
                  z.string(),
                  z.number(),
                  z.array(z.string()),
                  z.array(z.number()),
                  z.object({
                    id: z.string(),
                    isSecretRef: z.boolean(),
                  }),
                  z.null(),
                ])
              )
              .register(z.globalRegistry, {
                description:
                  'Input/stream level variable. Refer to the integration documentation for more information.',
              }),
          ])
        ),
        version: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Package policy ES version.',
          })
        ),
      })
      .register(z.globalRegistry, {
        description: 'The created agentless package policy.',
      }),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful response',
  });

export const delete_fleet_agentless_policies_policyid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    policyId: z.string().register(z.globalRegistry, {
      description: 'The ID of the policy to delete.',
    }),
  }),
  query: z.optional(
    z.object({
      force: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Force delete the policy even if the policy is managed.',
        })
      ),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Response for deleting an agentless package policy.
 */
export const delete_fleet_agentless_policies_policyid_response = z
  .object({
    id: z.string().register(z.globalRegistry, {
      description: 'The ID of the deleted agentless package policy.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Response for deleting an agentless package policy.',
  });

export const get_fleet_agents_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(z.number()),
      perPage: z.optional(z.number()).default(20),
      kuery: z.optional(z.string()),
      showAgentless: z.optional(z.boolean()).default(true),
      showInactive: z.optional(z.boolean()).default(false),
      withMetrics: z.optional(z.boolean()).default(false),
      showUpgradeable: z.optional(z.boolean()).default(false),
      getStatusSummary: z.optional(z.boolean()).default(false),
      sortField: z.optional(z.string()),
      sortOrder: z.optional(z.enum(['asc', 'desc'])),
      searchAfter: z.optional(z.string()),
      openPit: z.optional(z.boolean()),
      pitId: z.optional(z.string()),
      pitKeepAlive: z.optional(z.string()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agents_response = z
  .object({
    items: z.array(
      z.object({
        access_api_key: z.optional(z.string()),
        access_api_key_id: z.optional(z.string()),
        active: z.boolean(),
        agent: z.optional(
          z.object({
            id: z.string(),
            version: z.string(),
          })
        ),
        audit_unenrolled_reason: z.optional(z.string()),
        components: z.optional(
          z.array(
            z.object({
              id: z.string(),
              message: z.string(),
              status: z.enum([
                'STARTING',
                'CONFIGURING',
                'HEALTHY',
                'DEGRADED',
                'FAILED',
                'STOPPING',
                'STOPPED',
              ]),
              type: z.string(),
              units: z.optional(
                z.array(
                  z.object({
                    id: z.string(),
                    message: z.string(),
                    payload: z.optional(z.record(z.string(), z.unknown())),
                    status: z.enum([
                      'STARTING',
                      'CONFIGURING',
                      'HEALTHY',
                      'DEGRADED',
                      'FAILED',
                      'STOPPING',
                      'STOPPED',
                    ]),
                    type: z.enum(['input', 'output', '']),
                  })
                )
              ),
            })
          )
        ),
        default_api_key: z.optional(z.string()),
        default_api_key_history: z.optional(
          z.array(
            z.object({
              id: z.string(),
              retired_at: z.string(),
            })
          )
        ),
        default_api_key_id: z.optional(z.string()),
        enrolled_at: z.string(),
        id: z.string(),
        last_checkin: z.optional(z.string()),
        last_checkin_message: z.optional(z.string()),
        last_checkin_status: z.optional(
          z.enum(['error', 'online', 'degraded', 'updating', 'starting'])
        ),
        last_known_status: z.optional(
          z.enum([
            'offline',
            'error',
            'online',
            'inactive',
            'enrolling',
            'unenrolling',
            'unenrolled',
            'updating',
            'degraded',
            'uninstalled',
            'orphaned',
          ])
        ),
        local_metadata: z.record(z.string(), z.unknown()),
        metrics: z.optional(
          z.object({
            cpu_avg: z.optional(z.number()),
            memory_size_byte_avg: z.optional(z.number()),
          })
        ),
        namespaces: z.optional(z.array(z.string())),
        outputs: z.optional(
          z.record(
            z.string(),
            z.object({
              api_key_id: z.optional(z.string()),
              to_retire_api_key_ids: z.optional(
                z.array(
                  z.object({
                    id: z.string(),
                    retired_at: z.string(),
                  })
                )
              ),
              type: z.optional(z.string()),
            })
          )
        ),
        packages: z.array(z.string()),
        policy_id: z.optional(z.string()),
        policy_revision: z.optional(z.union([z.number(), z.null()])),
        sort: z.optional(z.array(z.unknown())),
        status: z.optional(
          z.enum([
            'offline',
            'error',
            'online',
            'inactive',
            'enrolling',
            'unenrolling',
            'unenrolled',
            'updating',
            'degraded',
            'uninstalled',
            'orphaned',
          ])
        ),
        tags: z.optional(z.array(z.string())),
        type: z.enum(['PERMANENT', 'EPHEMERAL', 'TEMPORARY']),
        unenrolled_at: z.optional(z.string()),
        unenrollment_started_at: z.optional(z.string()),
        unhealthy_reason: z.optional(
          z.union([z.array(z.enum(['input', 'output', 'other'])), z.null()])
        ),
        upgrade_attempts: z.optional(z.union([z.array(z.string()), z.null()])),
        upgrade_details: z.optional(
          z.union([
            z.object({
              action_id: z.string(),
              metadata: z.optional(
                z.object({
                  download_percent: z.optional(z.number()),
                  download_rate: z.optional(z.number()),
                  error_msg: z.optional(z.string()),
                  failed_state: z.optional(
                    z.enum([
                      'UPG_REQUESTED',
                      'UPG_SCHEDULED',
                      'UPG_DOWNLOADING',
                      'UPG_EXTRACTING',
                      'UPG_REPLACING',
                      'UPG_RESTARTING',
                      'UPG_FAILED',
                      'UPG_WATCHING',
                      'UPG_ROLLBACK',
                    ])
                  ),
                  retry_error_msg: z.optional(z.string()),
                  retry_until: z.optional(z.string()),
                  scheduled_at: z.optional(z.string()),
                })
              ),
              state: z.enum([
                'UPG_REQUESTED',
                'UPG_SCHEDULED',
                'UPG_DOWNLOADING',
                'UPG_EXTRACTING',
                'UPG_REPLACING',
                'UPG_RESTARTING',
                'UPG_FAILED',
                'UPG_WATCHING',
                'UPG_ROLLBACK',
              ]),
              target_version: z.string(),
            }),
            z.null(),
          ])
        ),
        upgrade_started_at: z.optional(z.union([z.string(), z.null()])),
        upgraded_at: z.optional(z.union([z.string(), z.null()])),
        user_provided_metadata: z.optional(z.record(z.string(), z.unknown())),
      })
    ),
    nextSearchAfter: z.optional(z.string()),
    page: z.number(),
    perPage: z.number(),
    pit: z.optional(z.string()),
    statusSummary: z.optional(z.record(z.string(), z.number())),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_request = z.object({
  body: z.optional(
    z.object({
      actionIds: z.array(z.string()),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_response = z
  .object({
    items: z.array(z.string()),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_agents_agentid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    agentId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_agents_agentid_response = z
  .object({
    action: z.enum(['deleted']),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agents_agentid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    agentId: z.string(),
  }),
  query: z.optional(
    z.object({
      withMetrics: z.optional(z.boolean()).default(false),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agents_agentid_response = z
  .object({
    item: z.object({
      access_api_key: z.optional(z.string()),
      access_api_key_id: z.optional(z.string()),
      active: z.boolean(),
      agent: z.optional(
        z.object({
          id: z.string(),
          version: z.string(),
        })
      ),
      audit_unenrolled_reason: z.optional(z.string()),
      components: z.optional(
        z.array(
          z.object({
            id: z.string(),
            message: z.string(),
            status: z.enum([
              'STARTING',
              'CONFIGURING',
              'HEALTHY',
              'DEGRADED',
              'FAILED',
              'STOPPING',
              'STOPPED',
            ]),
            type: z.string(),
            units: z.optional(
              z.array(
                z.object({
                  id: z.string(),
                  message: z.string(),
                  payload: z.optional(z.record(z.string(), z.unknown())),
                  status: z.enum([
                    'STARTING',
                    'CONFIGURING',
                    'HEALTHY',
                    'DEGRADED',
                    'FAILED',
                    'STOPPING',
                    'STOPPED',
                  ]),
                  type: z.enum(['input', 'output', '']),
                })
              )
            ),
          })
        )
      ),
      default_api_key: z.optional(z.string()),
      default_api_key_history: z.optional(
        z.array(
          z.object({
            id: z.string(),
            retired_at: z.string(),
          })
        )
      ),
      default_api_key_id: z.optional(z.string()),
      enrolled_at: z.string(),
      id: z.string(),
      last_checkin: z.optional(z.string()),
      last_checkin_message: z.optional(z.string()),
      last_checkin_status: z.optional(
        z.enum(['error', 'online', 'degraded', 'updating', 'starting'])
      ),
      last_known_status: z.optional(
        z.enum([
          'offline',
          'error',
          'online',
          'inactive',
          'enrolling',
          'unenrolling',
          'unenrolled',
          'updating',
          'degraded',
          'uninstalled',
          'orphaned',
        ])
      ),
      local_metadata: z.record(z.string(), z.unknown()),
      metrics: z.optional(
        z.object({
          cpu_avg: z.optional(z.number()),
          memory_size_byte_avg: z.optional(z.number()),
        })
      ),
      namespaces: z.optional(z.array(z.string())),
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            api_key_id: z.optional(z.string()),
            to_retire_api_key_ids: z.optional(
              z.array(
                z.object({
                  id: z.string(),
                  retired_at: z.string(),
                })
              )
            ),
            type: z.optional(z.string()),
          })
        )
      ),
      packages: z.array(z.string()),
      policy_id: z.optional(z.string()),
      policy_revision: z.optional(z.union([z.number(), z.null()])),
      sort: z.optional(z.array(z.unknown())),
      status: z.optional(
        z.enum([
          'offline',
          'error',
          'online',
          'inactive',
          'enrolling',
          'unenrolling',
          'unenrolled',
          'updating',
          'degraded',
          'uninstalled',
          'orphaned',
        ])
      ),
      tags: z.optional(z.array(z.string())),
      type: z.enum(['PERMANENT', 'EPHEMERAL', 'TEMPORARY']),
      unenrolled_at: z.optional(z.string()),
      unenrollment_started_at: z.optional(z.string()),
      unhealthy_reason: z.optional(
        z.union([z.array(z.enum(['input', 'output', 'other'])), z.null()])
      ),
      upgrade_attempts: z.optional(z.union([z.array(z.string()), z.null()])),
      upgrade_details: z.optional(
        z.union([
          z.object({
            action_id: z.string(),
            metadata: z.optional(
              z.object({
                download_percent: z.optional(z.number()),
                download_rate: z.optional(z.number()),
                error_msg: z.optional(z.string()),
                failed_state: z.optional(
                  z.enum([
                    'UPG_REQUESTED',
                    'UPG_SCHEDULED',
                    'UPG_DOWNLOADING',
                    'UPG_EXTRACTING',
                    'UPG_REPLACING',
                    'UPG_RESTARTING',
                    'UPG_FAILED',
                    'UPG_WATCHING',
                    'UPG_ROLLBACK',
                  ])
                ),
                retry_error_msg: z.optional(z.string()),
                retry_until: z.optional(z.string()),
                scheduled_at: z.optional(z.string()),
              })
            ),
            state: z.enum([
              'UPG_REQUESTED',
              'UPG_SCHEDULED',
              'UPG_DOWNLOADING',
              'UPG_EXTRACTING',
              'UPG_REPLACING',
              'UPG_RESTARTING',
              'UPG_FAILED',
              'UPG_WATCHING',
              'UPG_ROLLBACK',
            ]),
            target_version: z.string(),
          }),
          z.null(),
        ])
      ),
      upgrade_started_at: z.optional(z.union([z.string(), z.null()])),
      upgraded_at: z.optional(z.union([z.string(), z.null()])),
      user_provided_metadata: z.optional(z.record(z.string(), z.unknown())),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_agents_agentid_request = z.object({
  body: z.optional(
    z.object({
      tags: z.optional(z.array(z.string())),
      user_provided_metadata: z.optional(z.record(z.string(), z.unknown())),
    })
  ),
  path: z.object({
    agentId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_agents_agentid_response = z
  .object({
    item: z.object({
      access_api_key: z.optional(z.string()),
      access_api_key_id: z.optional(z.string()),
      active: z.boolean(),
      agent: z.optional(
        z.object({
          id: z.string(),
          version: z.string(),
        })
      ),
      audit_unenrolled_reason: z.optional(z.string()),
      components: z.optional(
        z.array(
          z.object({
            id: z.string(),
            message: z.string(),
            status: z.enum([
              'STARTING',
              'CONFIGURING',
              'HEALTHY',
              'DEGRADED',
              'FAILED',
              'STOPPING',
              'STOPPED',
            ]),
            type: z.string(),
            units: z.optional(
              z.array(
                z.object({
                  id: z.string(),
                  message: z.string(),
                  payload: z.optional(z.record(z.string(), z.unknown())),
                  status: z.enum([
                    'STARTING',
                    'CONFIGURING',
                    'HEALTHY',
                    'DEGRADED',
                    'FAILED',
                    'STOPPING',
                    'STOPPED',
                  ]),
                  type: z.enum(['input', 'output', '']),
                })
              )
            ),
          })
        )
      ),
      default_api_key: z.optional(z.string()),
      default_api_key_history: z.optional(
        z.array(
          z.object({
            id: z.string(),
            retired_at: z.string(),
          })
        )
      ),
      default_api_key_id: z.optional(z.string()),
      enrolled_at: z.string(),
      id: z.string(),
      last_checkin: z.optional(z.string()),
      last_checkin_message: z.optional(z.string()),
      last_checkin_status: z.optional(
        z.enum(['error', 'online', 'degraded', 'updating', 'starting'])
      ),
      last_known_status: z.optional(
        z.enum([
          'offline',
          'error',
          'online',
          'inactive',
          'enrolling',
          'unenrolling',
          'unenrolled',
          'updating',
          'degraded',
          'uninstalled',
          'orphaned',
        ])
      ),
      local_metadata: z.record(z.string(), z.unknown()),
      metrics: z.optional(
        z.object({
          cpu_avg: z.optional(z.number()),
          memory_size_byte_avg: z.optional(z.number()),
        })
      ),
      namespaces: z.optional(z.array(z.string())),
      outputs: z.optional(
        z.record(
          z.string(),
          z.object({
            api_key_id: z.optional(z.string()),
            to_retire_api_key_ids: z.optional(
              z.array(
                z.object({
                  id: z.string(),
                  retired_at: z.string(),
                })
              )
            ),
            type: z.optional(z.string()),
          })
        )
      ),
      packages: z.array(z.string()),
      policy_id: z.optional(z.string()),
      policy_revision: z.optional(z.union([z.number(), z.null()])),
      sort: z.optional(z.array(z.unknown())),
      status: z.optional(
        z.enum([
          'offline',
          'error',
          'online',
          'inactive',
          'enrolling',
          'unenrolling',
          'unenrolled',
          'updating',
          'degraded',
          'uninstalled',
          'orphaned',
        ])
      ),
      tags: z.optional(z.array(z.string())),
      type: z.enum(['PERMANENT', 'EPHEMERAL', 'TEMPORARY']),
      unenrolled_at: z.optional(z.string()),
      unenrollment_started_at: z.optional(z.string()),
      unhealthy_reason: z.optional(
        z.union([z.array(z.enum(['input', 'output', 'other'])), z.null()])
      ),
      upgrade_attempts: z.optional(z.union([z.array(z.string()), z.null()])),
      upgrade_details: z.optional(
        z.union([
          z.object({
            action_id: z.string(),
            metadata: z.optional(
              z.object({
                download_percent: z.optional(z.number()),
                download_rate: z.optional(z.number()),
                error_msg: z.optional(z.string()),
                failed_state: z.optional(
                  z.enum([
                    'UPG_REQUESTED',
                    'UPG_SCHEDULED',
                    'UPG_DOWNLOADING',
                    'UPG_EXTRACTING',
                    'UPG_REPLACING',
                    'UPG_RESTARTING',
                    'UPG_FAILED',
                    'UPG_WATCHING',
                    'UPG_ROLLBACK',
                  ])
                ),
                retry_error_msg: z.optional(z.string()),
                retry_until: z.optional(z.string()),
                scheduled_at: z.optional(z.string()),
              })
            ),
            state: z.enum([
              'UPG_REQUESTED',
              'UPG_SCHEDULED',
              'UPG_DOWNLOADING',
              'UPG_EXTRACTING',
              'UPG_REPLACING',
              'UPG_RESTARTING',
              'UPG_FAILED',
              'UPG_WATCHING',
              'UPG_ROLLBACK',
            ]),
            target_version: z.string(),
          }),
          z.null(),
        ])
      ),
      upgrade_started_at: z.optional(z.union([z.string(), z.null()])),
      upgraded_at: z.optional(z.union([z.string(), z.null()])),
      user_provided_metadata: z.optional(z.record(z.string(), z.unknown())),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_agentid_actions_request = z.object({
  body: z.optional(
    z.object({
      action: z.union([
        z.object({
          ack_data: z.unknown(),
          data: z.unknown(),
          type: z.enum(['UNENROLL', 'UPGRADE', 'POLICY_REASSIGN']),
        }),
        z.object({
          data: z.object({
            log_level: z.enum(['debug', 'info', 'warning', 'error']),
          }),
          type: z.enum(['SETTINGS']),
        }),
      ]),
    })
  ),
  path: z.object({
    agentId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_agentid_actions_response = z
  .object({
    item: z.object({
      ack_data: z.unknown(),
      agents: z.optional(z.array(z.string())),
      created_at: z.string(),
      data: z.unknown(),
      expiration: z.optional(z.string()),
      id: z.string(),
      minimum_execution_duration: z.optional(z.number()),
      namespaces: z.optional(z.array(z.string())),
      rollout_duration_seconds: z.optional(z.number()),
      sent_at: z.optional(z.string()),
      source_uri: z.optional(z.string()),
      start_time: z.optional(z.string()),
      total: z.optional(z.number()),
      type: z.string(),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_agentid_migrate_request = z.object({
  body: z.optional(
    z.object({
      enrollment_token: z.string(),
      settings: z.optional(
        z.object({
          ca_sha256: z.optional(z.string()),
          certificate_authorities: z.optional(z.string()),
          elastic_agent_cert: z.optional(z.string()),
          elastic_agent_cert_key: z.optional(z.string()),
          elastic_agent_cert_key_passphrase: z.optional(z.string()),
          headers: z.optional(z.record(z.string(), z.string())),
          insecure: z.optional(z.boolean()),
          proxy_disabled: z.optional(z.boolean()),
          proxy_headers: z.optional(z.record(z.string(), z.string())),
          proxy_url: z.optional(z.string()),
          replace_token: z.optional(z.string()),
          staging: z.optional(z.string()),
          tags: z.optional(z.array(z.string())),
        })
      ),
      uri: z.url(),
    })
  ),
  path: z.object({
    agentId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_agentid_migrate_response = z
  .object({
    actionId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_agentid_reassign_request = z.object({
  body: z.optional(
    z.object({
      policy_id: z.string(),
    })
  ),
  path: z.object({
    agentId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_agentid_reassign_response = z
  .record(z.string(), z.never())
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_agentid_request_diagnostics_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        additional_metrics: z.optional(z.array(z.enum(['CPU']))),
      }),
      z.null(),
    ])
  ),
  path: z.object({
    agentId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_agentid_request_diagnostics_response = z
  .object({
    actionId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_agentid_unenroll_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        force: z.optional(z.boolean()),
        revoke: z.optional(z.boolean()),
      }),
      z.null(),
    ])
  ),
  path: z.object({
    agentId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_fleet_agents_agentid_upgrade_request = z.object({
  body: z.optional(
    z.object({
      force: z.optional(z.boolean()),
      skipRateLimitCheck: z.optional(z.boolean()),
      source_uri: z.optional(z.string()),
      version: z.string(),
    })
  ),
  path: z.object({
    agentId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_agentid_upgrade_response = z
  .record(z.string(), z.never())
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agents_agentid_uploads_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    agentId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agents_agentid_uploads_response = z
  .object({
    items: z.array(
      z.object({
        actionId: z.string(),
        createTime: z.string(),
        error: z.optional(z.string()),
        filePath: z.string(),
        id: z.string(),
        name: z.string(),
        status: z.enum(['READY', 'AWAITING_UPLOAD', 'DELETED', 'EXPIRED', 'IN_PROGRESS', 'FAILED']),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agents_action_status_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(z.number()).default(0),
      perPage: z.optional(z.number()).default(20),
      date: z.optional(z.string()),
      latest: z.optional(z.number()),
      errorSize: z.optional(z.number()).default(5),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agents_action_status_response = z
  .object({
    items: z.array(
      z.object({
        actionId: z.string(),
        cancellationTime: z.optional(z.string()),
        completionTime: z.optional(z.string()),
        creationTime: z.string().register(z.globalRegistry, {
          description: 'creation time of action',
        }),
        expiration: z.optional(z.string()),
        hasRolloutPeriod: z.optional(z.boolean()),
        is_automatic: z.optional(z.boolean()),
        latestErrors: z.optional(
          z.array(
            z
              .object({
                agentId: z.string(),
                error: z.string(),
                hostname: z.optional(z.string()),
                timestamp: z.string(),
              })
              .register(z.globalRegistry, {
                description: 'latest errors that happened when the agents executed the action',
              })
          )
        ),
        nbAgentsAck: z.number().register(z.globalRegistry, {
          description: 'number of agents that acknowledged the action',
        }),
        nbAgentsActionCreated: z.number().register(z.globalRegistry, {
          description: 'number of agents included in action from kibana',
        }),
        nbAgentsActioned: z.number().register(z.globalRegistry, {
          description: 'number of agents actioned',
        }),
        nbAgentsFailed: z.number().register(z.globalRegistry, {
          description: 'number of agents that failed to execute the action',
        }),
        newPolicyId: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'new policy id (POLICY_REASSIGN action)',
          })
        ),
        policyId: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'policy id (POLICY_CHANGE action)',
          })
        ),
        revision: z.optional(
          z.number().register(z.globalRegistry, {
            description: 'new policy revision (POLICY_CHANGE action)',
          })
        ),
        startTime: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'start time of action (scheduled actions)',
          })
        ),
        status: z.enum([
          'COMPLETE',
          'EXPIRED',
          'CANCELLED',
          'FAILED',
          'IN_PROGRESS',
          'ROLLOUT_PASSED',
        ]),
        type: z.enum([
          'UPGRADE',
          'UNENROLL',
          'SETTINGS',
          'POLICY_REASSIGN',
          'CANCEL',
          'FORCE_UNENROLL',
          'REQUEST_DIAGNOSTICS',
          'UPDATE_TAGS',
          'POLICY_CHANGE',
          'INPUT_ACTION',
          'MIGRATE',
          'PRIVILEGE_LEVEL_CHANGE',
        ]),
        version: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'agent version number (UPGRADE action)',
          })
        ),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_actions_actionid_cancel_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    actionId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_actions_actionid_cancel_response = z
  .object({
    item: z.object({
      ack_data: z.unknown(),
      agents: z.optional(z.array(z.string())),
      created_at: z.string(),
      data: z.unknown(),
      expiration: z.optional(z.string()),
      id: z.string(),
      minimum_execution_duration: z.optional(z.number()),
      namespaces: z.optional(z.array(z.string())),
      rollout_duration_seconds: z.optional(z.number()),
      sent_at: z.optional(z.string()),
      source_uri: z.optional(z.string()),
      start_time: z.optional(z.string()),
      total: z.optional(z.number()),
      type: z.string(),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agents_available_versions_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agents_available_versions_response = z
  .object({
    items: z.array(z.string()),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_bulk_migrate_request = z.object({
  body: z.optional(
    z.object({
      agents: z.union([z.array(z.string()), z.string()]),
      batchSize: z.optional(z.number()),
      enrollment_token: z.string(),
      settings: z.optional(
        z.object({
          ca_sha256: z.optional(z.string()),
          certificate_authorities: z.optional(z.string()),
          elastic_agent_cert: z.optional(z.string()),
          elastic_agent_cert_key: z.optional(z.string()),
          elastic_agent_cert_key_passphrase: z.optional(z.string()),
          headers: z.optional(z.record(z.string(), z.string())),
          insecure: z.optional(z.boolean()),
          proxy_disabled: z.optional(z.boolean()),
          proxy_headers: z.optional(z.record(z.string(), z.string())),
          proxy_url: z.optional(z.string()),
          staging: z.optional(z.string()),
          tags: z.optional(z.array(z.string())),
        })
      ),
      uri: z.url(),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_bulk_migrate_response = z
  .object({
    actionId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_bulk_reassign_request = z.object({
  body: z.optional(
    z.object({
      agents: z.union([z.array(z.string()), z.string()]),
      batchSize: z.optional(z.number()),
      includeInactive: z.optional(z.boolean()).default(false),
      policy_id: z.string(),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_bulk_reassign_response = z
  .object({
    actionId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_bulk_request_diagnostics_request = z.object({
  body: z.optional(
    z.object({
      additional_metrics: z.optional(z.array(z.enum(['CPU']))),
      agents: z.union([z.array(z.string()), z.string()]),
      batchSize: z.optional(z.number()),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_bulk_request_diagnostics_response = z
  .object({
    actionId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_bulk_unenroll_request = z.object({
  body: z.optional(
    z.object({
      agents: z.union([
        z.array(
          z.string().register(z.globalRegistry, {
            description: 'KQL query string, leave empty to action all agents',
          })
        ),
        z.string().register(z.globalRegistry, {
          description: 'list of agent IDs',
        }),
      ]),
      batchSize: z.optional(z.number()),
      force: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Unenrolls hosted agents too',
        })
      ),
      includeInactive: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'When passing agents by KQL query, unenrolls inactive agents too',
        })
      ),
      revoke: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Revokes API keys of agents',
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_bulk_unenroll_response = z
  .object({
    actionId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_bulk_update_agent_tags_request = z.object({
  body: z.optional(
    z.object({
      agents: z.union([z.array(z.string()), z.string()]),
      batchSize: z.optional(z.number()),
      includeInactive: z.optional(z.boolean()).default(false),
      tagsToAdd: z.optional(z.array(z.string())),
      tagsToRemove: z.optional(z.array(z.string())),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_bulk_update_agent_tags_response = z
  .object({
    actionId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_agents_bulk_upgrade_request = z.object({
  body: z.optional(
    z.object({
      agents: z.union([z.array(z.string()), z.string()]),
      batchSize: z.optional(z.number()),
      force: z.optional(z.boolean()),
      includeInactive: z.optional(z.boolean()).default(false),
      rollout_duration_seconds: z.optional(z.number().gte(600)),
      skipRateLimitCheck: z.optional(z.boolean()),
      source_uri: z.optional(z.string()),
      start_time: z.optional(z.string()),
      version: z.string(),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_agents_bulk_upgrade_response = z
  .object({
    actionId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_agents_files_fileid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    fileId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_agents_files_fileid_response = z
  .object({
    deleted: z.boolean(),
    id: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agents_files_fileid_filename_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    fileId: z.string(),
    fileName: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agents_files_fileid_filename_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_agents_setup_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * A summary of the agent setup status. `isReady` indicates whether the setup is ready. If the setup is not ready, `missing_requirements` lists which requirements are missing.
 */
export const get_fleet_agents_setup_response = z
  .object({
    is_action_secrets_storage_enabled: z.optional(z.boolean()),
    is_secrets_storage_enabled: z.optional(z.boolean()),
    is_space_awareness_enabled: z.optional(z.boolean()),
    isReady: z.boolean(),
    missing_optional_features: z.array(z.enum(['encrypted_saved_object_encryption_key_required'])),
    missing_requirements: z.array(
      z.enum(['security_required', 'tls_required', 'api_keys', 'fleet_admin_user', 'fleet_server'])
    ),
    package_verification_key_id: z.optional(z.string()),
  })
  .register(z.globalRegistry, {
    description:
      'A summary of the agent setup status. `isReady` indicates whether the setup is ready. If the setup is not ready, `missing_requirements` lists which requirements are missing.',
  });

export const post_fleet_agents_setup_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * A summary of the result of Fleet's `setup` lifecycle. If `isInitialized` is true, Fleet is ready to accept agent enrollment. `nonFatalErrors` may include useful insight into non-blocking issues with Fleet setup.
 */
export const post_fleet_agents_setup_response = z
  .object({
    isInitialized: z.boolean(),
    nonFatalErrors: z.array(
      z.object({
        message: z.string(),
        name: z.string(),
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      "A summary of the result of Fleet's `setup` lifecycle. If `isInitialized` is true, Fleet is ready to accept agent enrollment. `nonFatalErrors` may include useful insight into non-blocking issues with Fleet setup.",
  });

export const get_fleet_agents_tags_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      kuery: z.optional(z.string()),
      showInactive: z.optional(z.boolean()).default(false),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_agents_tags_response = z
  .object({
    items: z.array(z.string()),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_check_permissions_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      fleetServerSetup: z.optional(z.boolean()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_check_permissions_response = z
  .object({
    error: z.optional(
      z.enum(['MISSING_SECURITY', 'MISSING_PRIVILEGES', 'MISSING_FLEET_SERVER_SETUP_PRIVILEGES'])
    ),
    success: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_cloud_connectors_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The page number for pagination.',
        })
      ),
      perPage: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The number of items per page.',
        })
      ),
      kuery: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'KQL query to filter cloud connectors.',
        })
      ),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_cloud_connectors_response = z
  .object({
    items: z.array(
      z.object({
        cloudProvider: z.string(),
        created_at: z.string(),
        id: z.string(),
        name: z.string(),
        namespace: z.optional(z.string()),
        packagePolicyCount: z.number(),
        updated_at: z.string(),
        vars: z.record(z.string(), z.unknown()),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_cloud_connectors_request = z.object({
  body: z.optional(
    z.object({
      cloudProvider: z.enum(['aws', 'azure', 'gcp']).register(z.globalRegistry, {
        description: 'The cloud provider type: aws, azure, or gcp.',
      }),
      name: z.string().min(1).max(255).register(z.globalRegistry, {
        description: 'The name of the cloud connector.',
      }),
      vars: z.record(
        z.string(),
        z.union([
          z.string().max(1000),
          z.number(),
          z.boolean(),
          z.object({
            frozen: z.optional(z.boolean()),
            type: z.string().max(50),
            value: z.union([
              z.string().max(1000),
              z.object({
                id: z.string().max(255),
                isSecretRef: z.boolean(),
              }),
            ]),
          }),
        ])
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_cloud_connectors_response = z
  .object({
    item: z.object({
      cloudProvider: z.string(),
      created_at: z.string(),
      id: z.string(),
      name: z.string(),
      namespace: z.optional(z.string()),
      packagePolicyCount: z.number(),
      updated_at: z.string(),
      vars: z.record(z.string(), z.unknown()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_cloud_connectors_cloudconnectorid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    cloudConnectorId: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the cloud connector to delete.',
    }),
  }),
  query: z.optional(
    z.object({
      force: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If true, forces deletion even if the cloud connector is in use.',
        })
      ),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_cloud_connectors_cloudconnectorid_response = z
  .object({
    id: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_cloud_connectors_cloudconnectorid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    cloudConnectorId: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the cloud connector.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_cloud_connectors_cloudconnectorid_response = z
  .object({
    item: z.object({
      cloudProvider: z.string(),
      created_at: z.string(),
      id: z.string(),
      name: z.string(),
      namespace: z.optional(z.string()),
      packagePolicyCount: z.number(),
      updated_at: z.string(),
      vars: z.record(z.string(), z.unknown()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_cloud_connectors_cloudconnectorid_request = z.object({
  body: z.optional(
    z.object({
      name: z.optional(
        z.string().min(1).max(255).register(z.globalRegistry, {
          description: 'The name of the cloud connector.',
        })
      ),
      vars: z.optional(
        z.record(
          z.string(),
          z.union([
            z.string().max(1000),
            z.number(),
            z.boolean(),
            z.object({
              frozen: z.optional(z.boolean()),
              type: z.string().max(50),
              value: z.union([
                z.string().max(1000),
                z.object({
                  id: z.string().max(255),
                  isSecretRef: z.boolean(),
                }),
              ]),
            }),
          ])
        )
      ),
    })
  ),
  path: z.object({
    cloudConnectorId: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the cloud connector to update.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_cloud_connectors_cloudconnectorid_response = z
  .object({
    item: z.object({
      cloudProvider: z.string(),
      created_at: z.string(),
      id: z.string(),
      name: z.string(),
      namespace: z.optional(z.string()),
      packagePolicyCount: z.number(),
      updated_at: z.string(),
      vars: z.record(z.string(), z.unknown()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_data_streams_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_data_streams_response = z
  .object({
    data_streams: z.array(
      z.object({
        dashboards: z.array(
          z.object({
            id: z.string(),
            title: z.string(),
          })
        ),
        dataset: z.string(),
        index: z.string(),
        last_activity_ms: z.number(),
        namespace: z.string(),
        package: z.string(),
        package_version: z.string(),
        serviceDetails: z.union([
          z.object({
            environment: z.string(),
            serviceName: z.string(),
          }),
          z.null(),
        ]),
        size_in_bytes: z.number(),
        size_in_bytes_formatted: z.union([z.number(), z.string()]),
        type: z.string(),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_enrollment_api_keys_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(z.number()).default(1),
      perPage: z.optional(z.number()).default(20),
      kuery: z.optional(z.string()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_enrollment_api_keys_response = z
  .object({
    items: z.array(
      z.object({
        active: z.boolean().register(z.globalRegistry, {
          description:
            'When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.',
        }),
        api_key: z.string().register(z.globalRegistry, {
          description: 'The enrollment API key (token) used for enrolling Elastic Agents.',
        }),
        api_key_id: z.string().register(z.globalRegistry, {
          description: 'The ID of the API key in the Security API.',
        }),
        created_at: z.string(),
        hidden: z.optional(z.boolean()),
        id: z.string(),
        name: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'The name of the enrollment API key.',
          })
        ),
        policy_id: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'The ID of the agent policy the Elastic Agent will be enrolled in.',
          })
        ),
      })
    ),
    list: z.array(
      z.object({
        active: z.boolean().register(z.globalRegistry, {
          description:
            'When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.',
        }),
        api_key: z.string().register(z.globalRegistry, {
          description: 'The enrollment API key (token) used for enrolling Elastic Agents.',
        }),
        api_key_id: z.string().register(z.globalRegistry, {
          description: 'The ID of the API key in the Security API.',
        }),
        created_at: z.string(),
        hidden: z.optional(z.boolean()),
        id: z.string(),
        name: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'The name of the enrollment API key.',
          })
        ),
        policy_id: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'The ID of the agent policy the Elastic Agent will be enrolled in.',
          })
        ),
      })
    ),
    page: z.number(),
    perPage: z.number(),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_enrollment_api_keys_request = z.object({
  body: z.optional(
    z.object({
      expiration: z.optional(z.string()),
      name: z.optional(z.string()),
      policy_id: z.string(),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_enrollment_api_keys_response = z
  .object({
    action: z.enum(['created']),
    item: z.object({
      active: z.boolean().register(z.globalRegistry, {
        description:
          'When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.',
      }),
      api_key: z.string().register(z.globalRegistry, {
        description: 'The enrollment API key (token) used for enrolling Elastic Agents.',
      }),
      api_key_id: z.string().register(z.globalRegistry, {
        description: 'The ID of the API key in the Security API.',
      }),
      created_at: z.string(),
      hidden: z.optional(z.boolean()),
      id: z.string(),
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The name of the enrollment API key.',
        })
      ),
      policy_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The ID of the agent policy the Elastic Agent will be enrolled in.',
        })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_enrollment_api_keys_keyid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    keyId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_enrollment_api_keys_keyid_response = z
  .object({
    action: z.enum(['deleted']),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_enrollment_api_keys_keyid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    keyId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_enrollment_api_keys_keyid_response = z
  .object({
    item: z.object({
      active: z.boolean().register(z.globalRegistry, {
        description:
          'When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.',
      }),
      api_key: z.string().register(z.globalRegistry, {
        description: 'The enrollment API key (token) used for enrolling Elastic Agents.',
      }),
      api_key_id: z.string().register(z.globalRegistry, {
        description: 'The ID of the API key in the Security API.',
      }),
      created_at: z.string(),
      hidden: z.optional(z.boolean()),
      id: z.string(),
      name: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The name of the enrollment API key.',
        })
      ),
      policy_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The ID of the agent policy the Elastic Agent will be enrolled in.',
        })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_bulk_assets_request = z.object({
  body: z.optional(
    z.object({
      assetIds: z.array(
        z.object({
          id: z.string(),
          type: z.string(),
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_bulk_assets_response = z
  .object({
    items: z.array(
      z.object({
        appLink: z.optional(z.string()),
        attributes: z.object({
          description: z.optional(z.string()),
          service: z.optional(z.string()),
          title: z.optional(z.string()),
        }),
        id: z.string(),
        type: z.string(),
        updatedAt: z.optional(z.string()),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_categories_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      prerelease: z.optional(z.boolean()),
      include_policy_templates: z.optional(z.boolean()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_categories_response = z
  .object({
    items: z.array(
      z.object({
        count: z.number(),
        id: z.string(),
        parent_id: z.optional(z.string()),
        parent_title: z.optional(z.string()),
        title: z.string(),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_custom_integrations_request = z.object({
  body: z.optional(
    z.object({
      datasets: z.array(
        z.object({
          name: z.string(),
          type: z.enum(['logs', 'metrics', 'traces', 'synthetics', 'profiling']),
        })
      ),
      force: z.optional(z.boolean()),
      integrationName: z.string(),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_custom_integrations_response = z
  .object({
    _meta: z.object({
      install_source: z.string(),
      name: z.string(),
    }),
    items: z.array(
      z.union([
        z.object({
          deferred: z.optional(z.boolean()),
          id: z.string(),
          originId: z.optional(z.string()),
          type: z.union([
            z.enum([
              'dashboard',
              'lens',
              'visualization',
              'search',
              'index-pattern',
              'map',
              'ml-module',
              'security-rule',
              'csp-rule-template',
              'osquery-pack-asset',
              'osquery-saved-query',
              'tag',
            ]),
            z.string(),
          ]),
        }),
        z.object({
          deferred: z.optional(z.boolean()),
          id: z.string(),
          type: z.enum([
            'index',
            'index_template',
            'component_template',
            'ingest_pipeline',
            'ilm_policy',
            'data_stream_ilm_policy',
            'transform',
            'ml_model',
            'knowledge_base',
          ]),
          version: z.optional(z.string()),
        }),
      ])
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_epm_custom_integrations_pkgname_request = z.object({
  body: z.optional(
    z.object({
      categories: z.optional(z.array(z.string())),
      readMeData: z.string(),
    })
  ),
  path: z.object({
    pkgName: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_fleet_epm_data_streams_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      type: z.optional(z.enum(['logs', 'metrics', 'traces', 'synthetics', 'profiling'])),
      datasetQuery: z.optional(z.string()),
      sortOrder: z.optional(z.enum(['asc', 'desc'])),
      uncategorisedOnly: z.optional(z.boolean()).default(false),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_data_streams_response = z
  .object({
    items: z.array(
      z.object({
        name: z.string(),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_packages_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      category: z.optional(z.string()),
      prerelease: z.optional(z.boolean()),
      excludeInstallStatus: z.optional(z.boolean()),
      withPackagePoliciesCount: z.optional(z.boolean()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_packages_response = z
  .object({
    items: z.array(
      z.object({
        categories: z.optional(z.array(z.string())),
        conditions: z.optional(
          z.object({
            elastic: z.optional(
              z.object({
                capabilities: z.optional(z.array(z.string())),
                subscription: z.optional(z.string()),
              })
            ),
            kibana: z.optional(
              z.object({
                version: z.optional(z.string()),
              })
            ),
          })
        ),
        data_streams: z.optional(z.array(z.record(z.string(), z.unknown()))),
        description: z.optional(z.string()),
        discovery: z.optional(
          z.object({
            datasets: z.optional(
              z.array(
                z.object({
                  name: z.string(),
                })
              )
            ),
            fields: z.optional(
              z.array(
                z.object({
                  name: z.string(),
                })
              )
            ),
          })
        ),
        download: z.optional(z.string()),
        format_version: z.optional(z.string()),
        icons: z.optional(
          z.array(
            z.object({
              dark_mode: z.optional(z.boolean()),
              path: z.optional(z.string()),
              size: z.optional(z.string()),
              src: z.string(),
              title: z.optional(z.string()),
              type: z.optional(z.string()),
            })
          )
        ),
        id: z.string(),
        installationInfo: z.optional(
          z.object({
            additional_spaces_installed_kibana: z.optional(
              z.record(
                z.string(),
                z.array(
                  z.object({
                    deferred: z.optional(z.boolean()),
                    id: z.string(),
                    originId: z.optional(z.string()),
                    type: z.union([
                      z.enum([
                        'dashboard',
                        'lens',
                        'visualization',
                        'search',
                        'index-pattern',
                        'map',
                        'ml-module',
                        'security-rule',
                        'csp-rule-template',
                        'osquery-pack-asset',
                        'osquery-saved-query',
                        'tag',
                      ]),
                      z.string(),
                    ]),
                  })
                )
              )
            ),
            created_at: z.optional(z.string()),
            experimental_data_stream_features: z.optional(
              z.array(
                z.object({
                  data_stream: z.string(),
                  features: z.object({
                    doc_value_only_numeric: z.optional(z.boolean()),
                    doc_value_only_other: z.optional(z.boolean()),
                    synthetic_source: z.optional(z.boolean()),
                    tsdb: z.optional(z.boolean()),
                  }),
                })
              )
            ),
            install_format_schema_version: z.optional(z.string()),
            install_source: z.enum(['registry', 'upload', 'bundled', 'custom']),
            install_status: z.enum(['installed', 'installing', 'install_failed']),
            installed_es: z.array(
              z.object({
                deferred: z.optional(z.boolean()),
                id: z.string(),
                type: z.enum([
                  'index',
                  'index_template',
                  'component_template',
                  'ingest_pipeline',
                  'ilm_policy',
                  'data_stream_ilm_policy',
                  'transform',
                  'ml_model',
                  'knowledge_base',
                ]),
                version: z.optional(z.string()),
              })
            ),
            installed_kibana: z.array(
              z.object({
                deferred: z.optional(z.boolean()),
                id: z.string(),
                originId: z.optional(z.string()),
                type: z.union([
                  z.enum([
                    'dashboard',
                    'lens',
                    'visualization',
                    'search',
                    'index-pattern',
                    'map',
                    'ml-module',
                    'security-rule',
                    'csp-rule-template',
                    'osquery-pack-asset',
                    'osquery-saved-query',
                    'tag',
                  ]),
                  z.string(),
                ]),
              })
            ),
            installed_kibana_space_id: z.optional(z.string()),
            is_rollback_ttl_expired: z.optional(z.boolean()),
            latest_executed_state: z.optional(
              z.object({
                error: z.optional(z.string()),
                name: z.optional(z.string()),
                started_at: z.optional(z.string()),
              })
            ),
            latest_install_failed_attempts: z.optional(
              z.array(
                z.object({
                  created_at: z.string(),
                  error: z.object({
                    message: z.string(),
                    name: z.string(),
                    stack: z.optional(z.string()),
                  }),
                  target_version: z.string(),
                })
              )
            ),
            name: z.string(),
            namespaces: z.optional(z.array(z.string())),
            previous_version: z.optional(z.union([z.string(), z.null()])),
            rolled_back: z.optional(z.boolean()),
            type: z.string(),
            updated_at: z.optional(z.string()),
            verification_key_id: z.optional(z.union([z.string(), z.null()])),
            verification_status: z.enum(['unverified', 'verified', 'unknown']),
            version: z.string(),
          })
        ),
        integration: z.optional(z.string()),
        internal: z.optional(z.boolean()),
        latestVersion: z.optional(z.string()),
        name: z.string(),
        owner: z.optional(
          z.object({
            github: z.optional(z.string()),
            type: z.optional(z.enum(['elastic', 'partner', 'community'])),
          })
        ),
        path: z.optional(z.string()),
        policy_templates: z.optional(z.array(z.record(z.string(), z.unknown()))),
        readme: z.optional(z.string()),
        release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
        signature_path: z.optional(z.string()),
        source: z.optional(
          z.object({
            license: z.string(),
          })
        ),
        status: z.optional(z.string()),
        title: z.string(),
        type: z.optional(
          z.union([z.enum(['integration']), z.enum(['input']), z.enum(['content']), z.string()])
        ),
        vars: z.optional(z.array(z.record(z.string(), z.unknown()))),
        version: z.string(),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_packages_request = z.object({
  body: z.optional(z.string()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      ignoreMappingUpdateErrors: z.optional(z.boolean()).default(false),
      skipDataStreamRollover: z.optional(z.boolean()).default(false),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_packages_response = z
  .object({
    _meta: z.object({
      install_source: z.string(),
      name: z.string(),
    }),
    items: z.array(
      z.union([
        z.object({
          deferred: z.optional(z.boolean()),
          id: z.string(),
          originId: z.optional(z.string()),
          type: z.union([
            z.enum([
              'dashboard',
              'lens',
              'visualization',
              'search',
              'index-pattern',
              'map',
              'ml-module',
              'security-rule',
              'csp-rule-template',
              'osquery-pack-asset',
              'osquery-saved-query',
              'tag',
            ]),
            z.string(),
          ]),
        }),
        z.object({
          deferred: z.optional(z.boolean()),
          id: z.string(),
          type: z.enum([
            'index',
            'index_template',
            'component_template',
            'ingest_pipeline',
            'ilm_policy',
            'data_stream_ilm_policy',
            'transform',
            'ml_model',
            'knowledge_base',
          ]),
          version: z.optional(z.string()),
        }),
      ])
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_packages_bulk_request = z.object({
  body: z.optional(
    z.object({
      force: z.optional(z.boolean()).default(false),
      packages: z
        .array(
          z.union([
            z.string(),
            z.object({
              name: z.string(),
              prerelease: z.optional(z.boolean()),
              version: z.string(),
            }),
          ])
        )
        .min(1),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      prerelease: z.optional(z.boolean()),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_packages_bulk_response = z
  .object({
    items: z.array(
      z.union([
        z.object({
          name: z.string(),
          result: z.object({
            assets: z.optional(
              z.array(
                z.union([
                  z.object({
                    deferred: z.optional(z.boolean()),
                    id: z.string(),
                    originId: z.optional(z.string()),
                    type: z.union([
                      z.enum([
                        'dashboard',
                        'lens',
                        'visualization',
                        'search',
                        'index-pattern',
                        'map',
                        'ml-module',
                        'security-rule',
                        'csp-rule-template',
                        'osquery-pack-asset',
                        'osquery-saved-query',
                        'tag',
                      ]),
                      z.string(),
                    ]),
                  }),
                  z.object({
                    deferred: z.optional(z.boolean()),
                    id: z.string(),
                    type: z.enum([
                      'index',
                      'index_template',
                      'component_template',
                      'ingest_pipeline',
                      'ilm_policy',
                      'data_stream_ilm_policy',
                      'transform',
                      'ml_model',
                      'knowledge_base',
                    ]),
                    version: z.optional(z.string()),
                  }),
                ])
              )
            ),
            error: z.unknown(),
            installSource: z.optional(z.string()),
            installType: z.string(),
            status: z.optional(z.enum(['installed', 'already_installed'])),
          }),
          version: z.string(),
        }),
        z.object({
          error: z.union([z.string(), z.unknown()]),
          name: z.string(),
          statusCode: z.number(),
        }),
      ])
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_packages_bulk_rollback_request = z.object({
  body: z.optional(
    z.object({
      packages: z
        .array(
          z.object({
            name: z.string().register(z.globalRegistry, {
              description: 'Package name to rollback',
            }),
          })
        )
        .min(1),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_packages_bulk_rollback_response = z
  .object({
    taskId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_packages_bulk_rollback_taskid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    taskId: z.string().register(z.globalRegistry, {
      description: 'Task ID of the bulk operation',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_packages_bulk_rollback_taskid_response = z
  .object({
    error: z.optional(
      z.object({
        message: z.string(),
      })
    ),
    results: z.optional(
      z.array(
        z.object({
          error: z.optional(
            z.object({
              message: z.string(),
            })
          ),
          name: z.string(),
          success: z.boolean(),
        })
      )
    ),
    status: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_packages_bulk_uninstall_request = z.object({
  body: z.optional(
    z.object({
      force: z.optional(z.boolean()).default(false),
      packages: z
        .array(
          z.object({
            name: z.string(),
            version: z.string(),
          })
        )
        .min(1),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_packages_bulk_uninstall_response = z
  .object({
    taskId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_packages_bulk_uninstall_taskid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    taskId: z.string().register(z.globalRegistry, {
      description: 'Task ID of the bulk operation',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_packages_bulk_uninstall_taskid_response = z
  .object({
    error: z.optional(
      z.object({
        message: z.string(),
      })
    ),
    results: z.optional(
      z.array(
        z.object({
          error: z.optional(
            z.object({
              message: z.string(),
            })
          ),
          name: z.string(),
          success: z.boolean(),
        })
      )
    ),
    status: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_packages_bulk_upgrade_request = z.object({
  body: z.optional(
    z.object({
      force: z.optional(z.boolean()).default(false),
      packages: z
        .array(
          z.object({
            name: z.string(),
            version: z.optional(z.string()),
          })
        )
        .min(1),
      prerelease: z.optional(z.boolean()),
      upgrade_package_policies: z.optional(z.boolean()).default(false),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_packages_bulk_upgrade_response = z
  .object({
    taskId: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_packages_bulk_upgrade_taskid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    taskId: z.string().register(z.globalRegistry, {
      description: 'Task ID of the bulk operation',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_packages_bulk_upgrade_taskid_response = z
  .object({
    error: z.optional(
      z.object({
        message: z.string(),
      })
    ),
    results: z.optional(
      z.array(
        z.object({
          error: z.optional(
            z.object({
              message: z.string(),
            })
          ),
          name: z.string(),
          success: z.boolean(),
        })
      )
    ),
    status: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_epm_packages_pkgname_pkgversion_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.optional(z.string()),
  }),
  query: z.optional(
    z.object({
      force: z.optional(z.boolean()),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_epm_packages_pkgname_pkgversion_response = z
  .object({
    items: z.array(
      z.union([
        z.object({
          deferred: z.optional(z.boolean()),
          id: z.string(),
          originId: z.optional(z.string()),
          type: z.union([
            z.enum([
              'dashboard',
              'lens',
              'visualization',
              'search',
              'index-pattern',
              'map',
              'ml-module',
              'security-rule',
              'csp-rule-template',
              'osquery-pack-asset',
              'osquery-saved-query',
              'tag',
            ]),
            z.string(),
          ]),
        }),
        z.object({
          deferred: z.optional(z.boolean()),
          id: z.string(),
          type: z.enum([
            'index',
            'index_template',
            'component_template',
            'ingest_pipeline',
            'ilm_policy',
            'data_stream_ilm_policy',
            'transform',
            'ml_model',
            'knowledge_base',
          ]),
          version: z.optional(z.string()),
        }),
      ])
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_packages_pkgname_pkgversion_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.optional(z.string()),
  }),
  query: z.optional(
    z.object({
      ignoreUnverified: z.optional(z.boolean()),
      prerelease: z.optional(z.boolean()),
      full: z.optional(z.boolean()),
      withMetadata: z.optional(z.boolean()).default(false),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_packages_pkgname_pkgversion_response = z
  .object({
    item: z.object({
      agent: z.optional(
        z.object({
          privileges: z.optional(
            z.object({
              root: z.optional(z.boolean()),
            })
          ),
        })
      ),
      asset_tags: z.optional(
        z.array(
          z.object({
            asset_ids: z.optional(z.array(z.string())),
            asset_types: z.optional(z.array(z.string())),
            text: z.string(),
          })
        )
      ),
      assets: z.record(z.string(), z.unknown()),
      categories: z.optional(z.array(z.string())),
      conditions: z.optional(
        z.object({
          elastic: z.optional(
            z.object({
              capabilities: z.optional(z.array(z.string())),
              subscription: z.optional(z.string()),
            })
          ),
          kibana: z.optional(
            z.object({
              version: z.optional(z.string()),
            })
          ),
        })
      ),
      data_streams: z.optional(z.array(z.record(z.string(), z.unknown()))),
      description: z.optional(z.string()),
      discovery: z.optional(
        z.object({
          datasets: z.optional(
            z.array(
              z.object({
                name: z.string(),
              })
            )
          ),
          fields: z.optional(
            z.array(
              z.object({
                name: z.string(),
              })
            )
          ),
        })
      ),
      download: z.optional(z.string()),
      elasticsearch: z.optional(z.record(z.string(), z.unknown())),
      format_version: z.optional(z.string()),
      icons: z.optional(
        z.array(
          z.object({
            dark_mode: z.optional(z.boolean()),
            path: z.optional(z.string()),
            size: z.optional(z.string()),
            src: z.string(),
            title: z.optional(z.string()),
            type: z.optional(z.string()),
          })
        )
      ),
      installationInfo: z.optional(
        z.object({
          additional_spaces_installed_kibana: z.optional(
            z.record(
              z.string(),
              z.array(
                z.object({
                  deferred: z.optional(z.boolean()),
                  id: z.string(),
                  originId: z.optional(z.string()),
                  type: z.union([
                    z.enum([
                      'dashboard',
                      'lens',
                      'visualization',
                      'search',
                      'index-pattern',
                      'map',
                      'ml-module',
                      'security-rule',
                      'csp-rule-template',
                      'osquery-pack-asset',
                      'osquery-saved-query',
                      'tag',
                    ]),
                    z.string(),
                  ]),
                })
              )
            )
          ),
          created_at: z.optional(z.string()),
          experimental_data_stream_features: z.optional(
            z.array(
              z.object({
                data_stream: z.string(),
                features: z.object({
                  doc_value_only_numeric: z.optional(z.boolean()),
                  doc_value_only_other: z.optional(z.boolean()),
                  synthetic_source: z.optional(z.boolean()),
                  tsdb: z.optional(z.boolean()),
                }),
              })
            )
          ),
          install_format_schema_version: z.optional(z.string()),
          install_source: z.enum(['registry', 'upload', 'bundled', 'custom']),
          install_status: z.enum(['installed', 'installing', 'install_failed']),
          installed_es: z.array(
            z.object({
              deferred: z.optional(z.boolean()),
              id: z.string(),
              type: z.enum([
                'index',
                'index_template',
                'component_template',
                'ingest_pipeline',
                'ilm_policy',
                'data_stream_ilm_policy',
                'transform',
                'ml_model',
                'knowledge_base',
              ]),
              version: z.optional(z.string()),
            })
          ),
          installed_kibana: z.array(
            z.object({
              deferred: z.optional(z.boolean()),
              id: z.string(),
              originId: z.optional(z.string()),
              type: z.union([
                z.enum([
                  'dashboard',
                  'lens',
                  'visualization',
                  'search',
                  'index-pattern',
                  'map',
                  'ml-module',
                  'security-rule',
                  'csp-rule-template',
                  'osquery-pack-asset',
                  'osquery-saved-query',
                  'tag',
                ]),
                z.string(),
              ]),
            })
          ),
          installed_kibana_space_id: z.optional(z.string()),
          is_rollback_ttl_expired: z.optional(z.boolean()),
          latest_executed_state: z.optional(
            z.object({
              error: z.optional(z.string()),
              name: z.optional(z.string()),
              started_at: z.optional(z.string()),
            })
          ),
          latest_install_failed_attempts: z.optional(
            z.array(
              z.object({
                created_at: z.string(),
                error: z.object({
                  message: z.string(),
                  name: z.string(),
                  stack: z.optional(z.string()),
                }),
                target_version: z.string(),
              })
            )
          ),
          name: z.string(),
          namespaces: z.optional(z.array(z.string())),
          previous_version: z.optional(z.union([z.string(), z.null()])),
          rolled_back: z.optional(z.boolean()),
          type: z.string(),
          updated_at: z.optional(z.string()),
          verification_key_id: z.optional(z.union([z.string(), z.null()])),
          verification_status: z.enum(['unverified', 'verified', 'unknown']),
          version: z.string(),
        })
      ),
      internal: z.optional(z.boolean()),
      keepPoliciesUpToDate: z.optional(z.boolean()),
      latestVersion: z.optional(z.string()),
      license: z.optional(z.string()),
      licensePath: z.optional(z.string()),
      name: z.string(),
      notice: z.optional(z.string()),
      owner: z.optional(
        z.object({
          github: z.optional(z.string()),
          type: z.optional(z.enum(['elastic', 'partner', 'community'])),
        })
      ),
      path: z.optional(z.string()),
      policy_templates: z.optional(z.array(z.record(z.string(), z.unknown()))),
      readme: z.optional(z.string()),
      release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
      screenshots: z.optional(
        z.array(
          z.object({
            dark_mode: z.optional(z.boolean()),
            path: z.optional(z.string()),
            size: z.optional(z.string()),
            src: z.string(),
            title: z.optional(z.string()),
            type: z.optional(z.string()),
          })
        )
      ),
      signature_path: z.optional(z.string()),
      source: z.optional(
        z.object({
          license: z.string(),
        })
      ),
      status: z.optional(z.string()),
      title: z.string(),
      type: z.optional(
        z.union([z.enum(['integration']), z.enum(['input']), z.enum(['content']), z.string()])
      ),
      vars: z.optional(z.array(z.record(z.string(), z.unknown()))),
      version: z.string(),
    }),
    metadata: z.optional(
      z.object({
        has_policies: z.boolean(),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_packages_pkgname_pkgversion_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        force: z.optional(z.boolean()).default(false),
        ignore_constraints: z.optional(z.boolean()).default(false),
      }),
      z.null(),
    ])
  ),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.optional(z.string()),
  }),
  query: z.optional(
    z.object({
      prerelease: z.optional(z.boolean()),
      ignoreMappingUpdateErrors: z.optional(z.boolean()).default(false),
      skipDataStreamRollover: z.optional(z.boolean()).default(false),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_packages_pkgname_pkgversion_response = z
  .object({
    _meta: z.object({
      install_source: z.string(),
      name: z.string(),
    }),
    items: z.array(
      z.union([
        z.object({
          deferred: z.optional(z.boolean()),
          id: z.string(),
          originId: z.optional(z.string()),
          type: z.union([
            z.enum([
              'dashboard',
              'lens',
              'visualization',
              'search',
              'index-pattern',
              'map',
              'ml-module',
              'security-rule',
              'csp-rule-template',
              'osquery-pack-asset',
              'osquery-saved-query',
              'tag',
            ]),
            z.string(),
          ]),
        }),
        z.object({
          deferred: z.optional(z.boolean()),
          id: z.string(),
          type: z.enum([
            'index',
            'index_template',
            'component_template',
            'ingest_pipeline',
            'ilm_policy',
            'data_stream_ilm_policy',
            'transform',
            'ml_model',
            'knowledge_base',
          ]),
          version: z.optional(z.string()),
        }),
      ])
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_epm_packages_pkgname_pkgversion_request = z.object({
  body: z.optional(
    z.object({
      keepPoliciesUpToDate: z.boolean(),
    })
  ),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.optional(z.string()),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_epm_packages_pkgname_pkgversion_response = z
  .object({
    item: z.object({
      agent: z.optional(
        z.object({
          privileges: z.optional(
            z.object({
              root: z.optional(z.boolean()),
            })
          ),
        })
      ),
      asset_tags: z.optional(
        z.array(
          z.object({
            asset_ids: z.optional(z.array(z.string())),
            asset_types: z.optional(z.array(z.string())),
            text: z.string(),
          })
        )
      ),
      assets: z.record(z.string(), z.unknown()),
      categories: z.optional(z.array(z.string())),
      conditions: z.optional(
        z.object({
          elastic: z.optional(
            z.object({
              capabilities: z.optional(z.array(z.string())),
              subscription: z.optional(z.string()),
            })
          ),
          kibana: z.optional(
            z.object({
              version: z.optional(z.string()),
            })
          ),
        })
      ),
      data_streams: z.optional(z.array(z.record(z.string(), z.unknown()))),
      description: z.optional(z.string()),
      discovery: z.optional(
        z.object({
          datasets: z.optional(
            z.array(
              z.object({
                name: z.string(),
              })
            )
          ),
          fields: z.optional(
            z.array(
              z.object({
                name: z.string(),
              })
            )
          ),
        })
      ),
      download: z.optional(z.string()),
      elasticsearch: z.optional(z.record(z.string(), z.unknown())),
      format_version: z.optional(z.string()),
      icons: z.optional(
        z.array(
          z.object({
            dark_mode: z.optional(z.boolean()),
            path: z.optional(z.string()),
            size: z.optional(z.string()),
            src: z.string(),
            title: z.optional(z.string()),
            type: z.optional(z.string()),
          })
        )
      ),
      installationInfo: z.optional(
        z.object({
          additional_spaces_installed_kibana: z.optional(
            z.record(
              z.string(),
              z.array(
                z.object({
                  deferred: z.optional(z.boolean()),
                  id: z.string(),
                  originId: z.optional(z.string()),
                  type: z.union([
                    z.enum([
                      'dashboard',
                      'lens',
                      'visualization',
                      'search',
                      'index-pattern',
                      'map',
                      'ml-module',
                      'security-rule',
                      'csp-rule-template',
                      'osquery-pack-asset',
                      'osquery-saved-query',
                      'tag',
                    ]),
                    z.string(),
                  ]),
                })
              )
            )
          ),
          created_at: z.optional(z.string()),
          experimental_data_stream_features: z.optional(
            z.array(
              z.object({
                data_stream: z.string(),
                features: z.object({
                  doc_value_only_numeric: z.optional(z.boolean()),
                  doc_value_only_other: z.optional(z.boolean()),
                  synthetic_source: z.optional(z.boolean()),
                  tsdb: z.optional(z.boolean()),
                }),
              })
            )
          ),
          install_format_schema_version: z.optional(z.string()),
          install_source: z.enum(['registry', 'upload', 'bundled', 'custom']),
          install_status: z.enum(['installed', 'installing', 'install_failed']),
          installed_es: z.array(
            z.object({
              deferred: z.optional(z.boolean()),
              id: z.string(),
              type: z.enum([
                'index',
                'index_template',
                'component_template',
                'ingest_pipeline',
                'ilm_policy',
                'data_stream_ilm_policy',
                'transform',
                'ml_model',
                'knowledge_base',
              ]),
              version: z.optional(z.string()),
            })
          ),
          installed_kibana: z.array(
            z.object({
              deferred: z.optional(z.boolean()),
              id: z.string(),
              originId: z.optional(z.string()),
              type: z.union([
                z.enum([
                  'dashboard',
                  'lens',
                  'visualization',
                  'search',
                  'index-pattern',
                  'map',
                  'ml-module',
                  'security-rule',
                  'csp-rule-template',
                  'osquery-pack-asset',
                  'osquery-saved-query',
                  'tag',
                ]),
                z.string(),
              ]),
            })
          ),
          installed_kibana_space_id: z.optional(z.string()),
          is_rollback_ttl_expired: z.optional(z.boolean()),
          latest_executed_state: z.optional(
            z.object({
              error: z.optional(z.string()),
              name: z.optional(z.string()),
              started_at: z.optional(z.string()),
            })
          ),
          latest_install_failed_attempts: z.optional(
            z.array(
              z.object({
                created_at: z.string(),
                error: z.object({
                  message: z.string(),
                  name: z.string(),
                  stack: z.optional(z.string()),
                }),
                target_version: z.string(),
              })
            )
          ),
          name: z.string(),
          namespaces: z.optional(z.array(z.string())),
          previous_version: z.optional(z.union([z.string(), z.null()])),
          rolled_back: z.optional(z.boolean()),
          type: z.string(),
          updated_at: z.optional(z.string()),
          verification_key_id: z.optional(z.union([z.string(), z.null()])),
          verification_status: z.enum(['unverified', 'verified', 'unknown']),
          version: z.string(),
        })
      ),
      internal: z.optional(z.boolean()),
      keepPoliciesUpToDate: z.optional(z.boolean()),
      latestVersion: z.optional(z.string()),
      license: z.optional(z.string()),
      licensePath: z.optional(z.string()),
      name: z.string(),
      notice: z.optional(z.string()),
      owner: z.optional(
        z.object({
          github: z.optional(z.string()),
          type: z.optional(z.enum(['elastic', 'partner', 'community'])),
        })
      ),
      path: z.optional(z.string()),
      policy_templates: z.optional(z.array(z.record(z.string(), z.unknown()))),
      readme: z.optional(z.string()),
      release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
      screenshots: z.optional(
        z.array(
          z.object({
            dark_mode: z.optional(z.boolean()),
            path: z.optional(z.string()),
            size: z.optional(z.string()),
            src: z.string(),
            title: z.optional(z.string()),
            type: z.optional(z.string()),
          })
        )
      ),
      signature_path: z.optional(z.string()),
      source: z.optional(
        z.object({
          license: z.string(),
        })
      ),
      status: z.optional(z.string()),
      title: z.string(),
      type: z.optional(
        z.union([z.enum(['integration']), z.enum(['input']), z.enum(['content']), z.string()])
      ),
      vars: z.optional(z.array(z.record(z.string(), z.unknown()))),
      version: z.string(),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_packages_pkgname_pkgversion_filepath_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.string(),
    filePath: z.string(),
  }),
  query: z.optional(z.never()),
});

export const delete_fleet_epm_packages_pkgname_pkgversion_datastream_assets_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.string(),
  }),
  query: z.object({
    packagePolicyId: z.string(),
  }),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_epm_packages_pkgname_pkgversion_datastream_assets_response = z
  .object({
    success: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_epm_packages_pkgname_pkgversion_kibana_assets_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_epm_packages_pkgname_pkgversion_kibana_assets_response = z
  .object({
    success: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_packages_pkgname_pkgversion_kibana_assets_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        force: z.optional(z.boolean()),
        space_ids: z.optional(
          z.array(z.string()).min(1).register(z.globalRegistry, {
            description:
              'When provided install assets in the specified spaces instead of the current space.',
          })
        ),
      }),
      z.null(),
    ])
  ),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_packages_pkgname_pkgversion_kibana_assets_response = z
  .object({
    success: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_packages_pkgname_pkgversion_rule_assets_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        force: z.optional(z.boolean()),
      }),
      z.null(),
    ])
  ),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_packages_pkgname_pkgversion_rule_assets_response = z
  .object({
    success: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_packages_pkgname_pkgversion_transforms_authorize_request = z.object({
  body: z.optional(
    z.object({
      transforms: z.array(
        z.object({
          transformId: z.string(),
        })
      ),
    })
  ),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.string(),
  }),
  query: z.optional(
    z.object({
      prerelease: z.optional(z.boolean()),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_packages_pkgname_pkgversion_transforms_authorize_response = z
  .array(
    z.object({
      error: z.unknown(),
      success: z.boolean(),
      transformId: z.string(),
    })
  )
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_epm_packages_pkgname_rollback_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    pkgName: z.string().register(z.globalRegistry, {
      description: 'Package name to roll back',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_epm_packages_pkgname_rollback_response = z
  .object({
    success: z.boolean(),
    version: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_packages_pkgname_stats_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    pkgName: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_packages_pkgname_stats_response = z
  .object({
    response: z.object({
      agent_policy_count: z.number(),
      package_policy_count: z.number(),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_packages_installed_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      dataStreamType: z.optional(z.enum(['logs', 'metrics', 'traces', 'synthetics', 'profiling'])),
      showOnlyActiveDataStreams: z.optional(z.boolean()),
      nameQuery: z.optional(z.string()),
      searchAfter: z.optional(z.array(z.union([z.string(), z.number()]))),
      perPage: z.optional(z.number()).default(15),
      sortOrder: z.optional(z.enum(['asc', 'desc'])),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_packages_installed_response = z
  .object({
    items: z.array(
      z.object({
        dataStreams: z.array(
          z.object({
            name: z.string(),
            title: z.string(),
          })
        ),
        description: z.optional(z.string()),
        icons: z.optional(
          z.array(
            z.object({
              dark_mode: z.optional(z.boolean()),
              path: z.optional(z.string()),
              size: z.optional(z.string()),
              src: z.string(),
              title: z.optional(z.string()),
              type: z.optional(z.string()),
            })
          )
        ),
        name: z.string(),
        status: z.string(),
        title: z.optional(z.string()),
        version: z.string(),
      })
    ),
    searchAfter: z.optional(
      z.array(z.union([z.string(), z.number(), z.boolean(), z.unknown(), z.unknown()]))
    ),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_packages_limited_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_packages_limited_response = z
  .object({
    items: z.array(z.string()),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_epm_templates_pkgname_pkgversion_inputs_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    pkgName: z.string(),
    pkgVersion: z.string(),
  }),
  query: z.optional(
    z.object({
      format: z.optional(z.enum(['json', 'yml', 'yaml'])),
      prerelease: z.optional(z.boolean()),
      ignoreUnverified: z.optional(z.boolean()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_templates_pkgname_pkgversion_inputs_response = z.union([
  z.string(),
  z.object({
    inputs: z.array(
      z.object({
        id: z.string(),
        streams: z.optional(
          z.array(
            z.object({
              data_stream: z.object({
                dataset: z.string(),
                type: z.optional(z.string()),
              }),
              id: z.string(),
            })
          )
        ),
        type: z.string(),
      })
    ),
  }),
]);

export const get_fleet_epm_verification_key_id_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_epm_verification_key_id_response = z
  .object({
    id: z.union([z.string(), z.null()]),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_fleet_server_hosts_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_fleet_server_hosts_response = z
  .object({
    items: z.array(
      z.object({
        host_urls: z.array(z.string()).min(1),
        id: z.string(),
        is_default: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()).default(false),
        name: z.string(),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                agent_key: z.optional(
                  z.union([
                    z.object({
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
                es_key: z.optional(
                  z.union([
                    z.object({
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
                key: z.optional(
                  z.union([
                    z.object({
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        ssl: z.optional(
          z.union([
            z.object({
              agent_certificate: z.optional(z.string()),
              agent_certificate_authorities: z.optional(z.array(z.string())),
              agent_key: z.optional(z.string()),
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              client_auth: z.optional(z.enum(['optional', 'required', 'none'])),
              es_certificate: z.optional(z.string()),
              es_certificate_authorities: z.optional(z.array(z.string())),
              es_key: z.optional(z.string()),
              key: z.optional(z.string()),
            }),
            z.null(),
          ])
        ),
      })
    ),
    page: z.number(),
    perPage: z.number(),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_fleet_server_hosts_request = z.object({
  body: z.optional(
    z.object({
      host_urls: z.array(z.string()).min(1),
      id: z.optional(z.string()),
      is_default: z.optional(z.boolean()).default(false),
      is_internal: z.optional(z.boolean()),
      is_preconfigured: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_id: z.optional(z.union([z.string(), z.null()])),
      secrets: z.optional(
        z.object({
          ssl: z.optional(
            z.object({
              agent_key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              es_key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
            })
          ),
        })
      ),
      ssl: z.optional(
        z.union([
          z.object({
            agent_certificate: z.optional(z.string()),
            agent_certificate_authorities: z.optional(z.array(z.string())),
            agent_key: z.optional(z.string()),
            certificate: z.optional(z.string()),
            certificate_authorities: z.optional(z.array(z.string())),
            client_auth: z.optional(z.enum(['optional', 'required', 'none'])),
            es_certificate: z.optional(z.string()),
            es_certificate_authorities: z.optional(z.array(z.string())),
            es_key: z.optional(z.string()),
            key: z.optional(z.string()),
          }),
          z.null(),
        ])
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_fleet_server_hosts_response = z
  .object({
    item: z.object({
      host_urls: z.array(z.string()).min(1),
      id: z.string(),
      is_default: z.optional(z.boolean()).default(false),
      is_internal: z.optional(z.boolean()),
      is_preconfigured: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_id: z.optional(z.union([z.string(), z.null()])),
      secrets: z.optional(
        z.object({
          ssl: z.optional(
            z.object({
              agent_key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              es_key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
            })
          ),
        })
      ),
      ssl: z.optional(
        z.union([
          z.object({
            agent_certificate: z.optional(z.string()),
            agent_certificate_authorities: z.optional(z.array(z.string())),
            agent_key: z.optional(z.string()),
            certificate: z.optional(z.string()),
            certificate_authorities: z.optional(z.array(z.string())),
            client_auth: z.optional(z.enum(['optional', 'required', 'none'])),
            es_certificate: z.optional(z.string()),
            es_certificate_authorities: z.optional(z.array(z.string())),
            es_key: z.optional(z.string()),
            key: z.optional(z.string()),
          }),
          z.null(),
        ])
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_fleet_server_hosts_itemid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    itemId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_fleet_server_hosts_itemid_response = z
  .object({
    id: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_fleet_server_hosts_itemid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    itemId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_fleet_server_hosts_itemid_response = z
  .object({
    item: z.object({
      host_urls: z.array(z.string()).min(1),
      id: z.string(),
      is_default: z.optional(z.boolean()).default(false),
      is_internal: z.optional(z.boolean()),
      is_preconfigured: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_id: z.optional(z.union([z.string(), z.null()])),
      secrets: z.optional(
        z.object({
          ssl: z.optional(
            z.object({
              agent_key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              es_key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
            })
          ),
        })
      ),
      ssl: z.optional(
        z.union([
          z.object({
            agent_certificate: z.optional(z.string()),
            agent_certificate_authorities: z.optional(z.array(z.string())),
            agent_key: z.optional(z.string()),
            certificate: z.optional(z.string()),
            certificate_authorities: z.optional(z.array(z.string())),
            client_auth: z.optional(z.enum(['optional', 'required', 'none'])),
            es_certificate: z.optional(z.string()),
            es_certificate_authorities: z.optional(z.array(z.string())),
            es_key: z.optional(z.string()),
            key: z.optional(z.string()),
          }),
          z.null(),
        ])
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_fleet_server_hosts_itemid_request = z.object({
  body: z.optional(
    z.object({
      host_urls: z.optional(z.array(z.string()).min(1)),
      is_default: z.optional(z.boolean()),
      is_internal: z.optional(z.boolean()),
      name: z.optional(z.string()),
      proxy_id: z.union([z.string(), z.null()]),
      secrets: z.optional(
        z.object({
          ssl: z.optional(
            z.object({
              agent_key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              es_key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
            })
          ),
        })
      ),
      ssl: z.optional(
        z.union([
          z.object({
            agent_certificate: z.optional(z.string()),
            agent_certificate_authorities: z.optional(z.array(z.string())),
            agent_key: z.optional(z.string()),
            certificate: z.optional(z.string()),
            certificate_authorities: z.optional(z.array(z.string())),
            client_auth: z.optional(z.enum(['optional', 'required', 'none'])),
            es_certificate: z.optional(z.string()),
            es_certificate_authorities: z.optional(z.array(z.string())),
            es_key: z.optional(z.string()),
            key: z.optional(z.string()),
          }),
          z.null(),
        ])
      ),
    })
  ),
  path: z.object({
    itemId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_fleet_server_hosts_itemid_response = z
  .object({
    item: z.object({
      host_urls: z.array(z.string()).min(1),
      id: z.string(),
      is_default: z.optional(z.boolean()).default(false),
      is_internal: z.optional(z.boolean()),
      is_preconfigured: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_id: z.optional(z.union([z.string(), z.null()])),
      secrets: z.optional(
        z.object({
          ssl: z.optional(
            z.object({
              agent_key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              es_key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              key: z.optional(
                z.union([
                  z.object({
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
            })
          ),
        })
      ),
      ssl: z.optional(
        z.union([
          z.object({
            agent_certificate: z.optional(z.string()),
            agent_certificate_authorities: z.optional(z.array(z.string())),
            agent_key: z.optional(z.string()),
            certificate: z.optional(z.string()),
            certificate_authorities: z.optional(z.array(z.string())),
            client_auth: z.optional(z.enum(['optional', 'required', 'none'])),
            es_certificate: z.optional(z.string()),
            es_certificate_authorities: z.optional(z.array(z.string())),
            es_key: z.optional(z.string()),
            key: z.optional(z.string()),
          }),
          z.null(),
        ])
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_health_check_request = z.object({
  body: z.optional(
    z.object({
      id: z.string(),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_health_check_response = z
  .object({
    host_id: z.optional(z.string()),
    name: z.optional(z.string()),
    status: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_kubernetes_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      download: z.optional(z.boolean()),
      fleetServer: z.optional(z.string()),
      enrolToken: z.optional(z.string()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_kubernetes_response = z
  .object({
    item: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_kubernetes_download_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      download: z.optional(z.boolean()),
      fleetServer: z.optional(z.string()),
      enrolToken: z.optional(z.string()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_kubernetes_download_response = z.string().register(z.globalRegistry, {
  description: 'OK: A successful request.',
});

export const post_fleet_logstash_api_keys_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_logstash_api_keys_response = z
  .object({
    api_key: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_message_signing_service_rotate_key_pair_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      acknowledge: z.optional(z.boolean()).default(false),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_message_signing_service_rotate_key_pair_response = z
  .object({
    message: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_outputs_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_outputs_response = z
  .object({
    items: z.array(
      z.union([
        z.object({
          allow_edit: z.optional(z.array(z.string())),
          ca_sha256: z.optional(z.union([z.string(), z.null()])),
          ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
          config_yaml: z.optional(z.union([z.string(), z.null()])),
          hosts: z.array(z.url()).min(1),
          id: z.optional(z.string()),
          is_default: z.optional(z.boolean()).default(false),
          is_default_monitoring: z.optional(z.boolean()).default(false),
          is_internal: z.optional(z.boolean()),
          is_preconfigured: z.optional(z.boolean()),
          name: z.string(),
          preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
          proxy_id: z.optional(z.union([z.string(), z.null()])),
          secrets: z.optional(
            z.object({
              ssl: z.optional(
                z.object({
                  key: z.optional(
                    z.union([
                      z.object({
                        hash: z.optional(z.string()),
                        id: z.string(),
                      }),
                      z.string(),
                    ])
                  ),
                })
              ),
            })
          ),
          shipper: z.optional(
            z.union([
              z.object({
                compression_level: z.union([z.number(), z.null()]),
                disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
                disk_queue_enabled: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
                disk_queue_max_size: z.union([z.number(), z.null()]),
                disk_queue_path: z.union([z.string(), z.null()]),
                loadbalance: z.union([z.boolean(), z.null()]),
                max_batch_bytes: z.union([z.number(), z.null()]),
                mem_queue_events: z.union([z.number(), z.null()]),
                queue_flush_timeout: z.union([z.number(), z.null()]),
              }),
              z.null(),
            ])
          ),
          ssl: z.optional(
            z.union([
              z.object({
                certificate: z.optional(z.string()),
                certificate_authorities: z.optional(z.array(z.string())),
                key: z.optional(z.string()),
                verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
              }),
              z.null(),
            ])
          ),
          type: z.enum(['elasticsearch']),
          write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
        }),
        z.object({
          allow_edit: z.optional(z.array(z.string())),
          ca_sha256: z.optional(z.union([z.string(), z.null()])),
          ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
          config_yaml: z.optional(z.union([z.string(), z.null()])),
          hosts: z.array(z.url()).min(1),
          id: z.optional(z.string()),
          is_default: z.optional(z.boolean()).default(false),
          is_default_monitoring: z.optional(z.boolean()).default(false),
          is_internal: z.optional(z.boolean()),
          is_preconfigured: z.optional(z.boolean()),
          kibana_api_key: z.optional(z.union([z.string(), z.null()])),
          kibana_url: z.optional(z.union([z.string(), z.null()])),
          name: z.string(),
          preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
          proxy_id: z.optional(z.union([z.string(), z.null()])),
          secrets: z.optional(
            z.object({
              service_token: z.optional(
                z.union([
                  z.object({
                    hash: z.optional(z.string()),
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              ssl: z.optional(
                z.object({
                  key: z.optional(
                    z.union([
                      z.object({
                        hash: z.optional(z.string()),
                        id: z.string(),
                      }),
                      z.string(),
                    ])
                  ),
                })
              ),
            })
          ),
          service_token: z.optional(z.union([z.string(), z.null()])),
          shipper: z.optional(
            z.union([
              z.object({
                compression_level: z.union([z.number(), z.null()]),
                disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
                disk_queue_enabled: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
                disk_queue_max_size: z.union([z.number(), z.null()]),
                disk_queue_path: z.union([z.string(), z.null()]),
                loadbalance: z.union([z.boolean(), z.null()]),
                max_batch_bytes: z.union([z.number(), z.null()]),
                mem_queue_events: z.union([z.number(), z.null()]),
                queue_flush_timeout: z.union([z.number(), z.null()]),
              }),
              z.null(),
            ])
          ),
          ssl: z.optional(
            z.union([
              z.object({
                certificate: z.optional(z.string()),
                certificate_authorities: z.optional(z.array(z.string())),
                key: z.optional(z.string()),
                verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
              }),
              z.null(),
            ])
          ),
          sync_integrations: z.optional(z.boolean()),
          sync_uninstalled_integrations: z.optional(z.boolean()),
          type: z.enum(['remote_elasticsearch']),
          write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
        }),
        z.object({
          allow_edit: z.optional(z.array(z.string())),
          ca_sha256: z.optional(z.union([z.string(), z.null()])),
          ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
          config_yaml: z.optional(z.union([z.string(), z.null()])),
          hosts: z.array(z.string()).min(1),
          id: z.optional(z.string()),
          is_default: z.optional(z.boolean()).default(false),
          is_default_monitoring: z.optional(z.boolean()).default(false),
          is_internal: z.optional(z.boolean()),
          is_preconfigured: z.optional(z.boolean()),
          name: z.string(),
          proxy_id: z.optional(z.union([z.string(), z.null()])),
          secrets: z.optional(
            z.object({
              ssl: z.optional(
                z.object({
                  key: z.optional(
                    z.union([
                      z.object({
                        hash: z.optional(z.string()),
                        id: z.string(),
                      }),
                      z.string(),
                    ])
                  ),
                })
              ),
            })
          ),
          shipper: z.optional(
            z.union([
              z.object({
                compression_level: z.union([z.number(), z.null()]),
                disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
                disk_queue_enabled: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
                disk_queue_max_size: z.union([z.number(), z.null()]),
                disk_queue_path: z.union([z.string(), z.null()]),
                loadbalance: z.union([z.boolean(), z.null()]),
                max_batch_bytes: z.union([z.number(), z.null()]),
                mem_queue_events: z.union([z.number(), z.null()]),
                queue_flush_timeout: z.union([z.number(), z.null()]),
              }),
              z.null(),
            ])
          ),
          ssl: z.optional(
            z.union([
              z.object({
                certificate: z.optional(z.string()),
                certificate_authorities: z.optional(z.array(z.string())),
                key: z.optional(z.string()),
                verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
              }),
              z.null(),
            ])
          ),
          type: z.enum(['logstash']),
        }),
        z.object({
          allow_edit: z.optional(z.array(z.string())),
          auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']),
          broker_timeout: z.optional(z.number()),
          ca_sha256: z.optional(z.union([z.string(), z.null()])),
          ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
          client_id: z.optional(z.string()),
          compression: z.optional(z.enum(['gzip', 'snappy', 'lz4', 'none'])),
          compression_level: z.union([
            z.array(z.unknown()),
            z.boolean(),
            z.number(),
            z.record(z.string(), z.unknown()),
            z.string(),
            z.null(),
          ]),
          config_yaml: z.optional(z.union([z.string(), z.null()])),
          connection_type: z.union([
            z.array(z.unknown()),
            z.boolean(),
            z.number(),
            z.record(z.string(), z.unknown()),
            z.string(),
            z.null(),
          ]),
          hash: z.optional(
            z.object({
              hash: z.optional(z.string()),
              random: z.optional(z.boolean()),
            })
          ),
          headers: z.optional(
            z.array(
              z.object({
                key: z.string(),
                value: z.string(),
              })
            )
          ),
          hosts: z.array(z.string()).min(1),
          id: z.optional(z.string()),
          is_default: z.optional(z.boolean()).default(false),
          is_default_monitoring: z.optional(z.boolean()).default(false),
          is_internal: z.optional(z.boolean()),
          is_preconfigured: z.optional(z.boolean()),
          key: z.optional(z.string()),
          name: z.string(),
          partition: z.optional(z.enum(['random', 'round_robin', 'hash'])),
          password: z.union([
            z.array(z.unknown()),
            z.boolean(),
            z.number(),
            z.record(z.string(), z.unknown()),
            z.string(),
            z.null(),
          ]),
          proxy_id: z.optional(z.union([z.string(), z.null()])),
          random: z.optional(
            z.object({
              group_events: z.optional(z.number()),
            })
          ),
          required_acks: z.optional(z.union([z.literal(1), z.literal(0), z.literal(-1)])),
          round_robin: z.optional(
            z.object({
              group_events: z.optional(z.number()),
            })
          ),
          sasl: z.optional(
            z.union([
              z.object({
                mechanism: z.optional(z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512'])),
              }),
              z.null(),
            ])
          ),
          secrets: z.optional(
            z.object({
              password: z.optional(
                z.union([
                  z.object({
                    hash: z.optional(z.string()),
                    id: z.string(),
                  }),
                  z.string(),
                ])
              ),
              ssl: z.optional(
                z.object({
                  key: z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ]),
                })
              ),
            })
          ),
          shipper: z.optional(
            z.union([
              z.object({
                compression_level: z.union([z.number(), z.null()]),
                disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
                disk_queue_enabled: z
                  .optional(z.union([z.boolean().default(false), z.null()]))
                  .default(false),
                disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
                disk_queue_max_size: z.union([z.number(), z.null()]),
                disk_queue_path: z.union([z.string(), z.null()]),
                loadbalance: z.union([z.boolean(), z.null()]),
                max_batch_bytes: z.union([z.number(), z.null()]),
                mem_queue_events: z.union([z.number(), z.null()]),
                queue_flush_timeout: z.union([z.number(), z.null()]),
              }),
              z.null(),
            ])
          ),
          ssl: z.optional(
            z.union([
              z.object({
                certificate: z.optional(z.string()),
                certificate_authorities: z.optional(z.array(z.string())),
                key: z.optional(z.string()),
                verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
              }),
              z.null(),
            ])
          ),
          timeout: z.optional(z.number()),
          topic: z.optional(z.string()),
          type: z.enum(['kafka']),
          username: z.union([
            z.array(z.unknown()),
            z.boolean(),
            z.number(),
            z.record(z.string(), z.unknown()),
            z.string(),
            z.null(),
          ]),
          version: z.optional(z.string()),
        }),
      ])
    ),
    page: z.number(),
    perPage: z.number(),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_outputs_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.url()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        name: z.string(),
        preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        type: z.enum(['elasticsearch']),
        write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.url()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        kibana_api_key: z.optional(z.union([z.string(), z.null()])),
        kibana_url: z.optional(z.union([z.string(), z.null()])),
        name: z.string(),
        preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            service_token: z.optional(
              z.union([
                z.object({
                  hash: z.optional(z.string()),
                  id: z.string(),
                }),
                z.string(),
              ])
            ),
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        service_token: z.optional(z.union([z.string(), z.null()])),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        sync_integrations: z.optional(z.boolean()),
        sync_uninstalled_integrations: z.optional(z.boolean()),
        type: z.enum(['remote_elasticsearch']),
        write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.string()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        name: z.string(),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        type: z.enum(['logstash']),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']),
        broker_timeout: z.optional(z.number()),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        client_id: z.optional(z.string()),
        compression: z.optional(z.enum(['gzip', 'snappy', 'lz4', 'none'])),
        compression_level: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        connection_type: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        hash: z.optional(
          z.object({
            hash: z.optional(z.string()),
            random: z.optional(z.boolean()),
          })
        ),
        headers: z.optional(
          z.array(
            z.object({
              key: z.string(),
              value: z.string(),
            })
          )
        ),
        hosts: z.array(z.string()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        key: z.optional(z.string()),
        name: z.string(),
        partition: z.optional(z.enum(['random', 'round_robin', 'hash'])),
        password: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        random: z.optional(
          z.object({
            group_events: z.optional(z.number()),
          })
        ),
        required_acks: z.optional(z.union([z.literal(1), z.literal(0), z.literal(-1)])),
        round_robin: z.optional(
          z.object({
            group_events: z.optional(z.number()),
          })
        ),
        sasl: z.optional(
          z.union([
            z.object({
              mechanism: z.optional(z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512'])),
            }),
            z.null(),
          ])
        ),
        secrets: z.optional(
          z.object({
            password: z.optional(
              z.union([
                z.object({
                  hash: z.optional(z.string()),
                  id: z.string(),
                }),
                z.string(),
              ])
            ),
            ssl: z.optional(
              z.object({
                key: z.union([
                  z.object({
                    hash: z.optional(z.string()),
                    id: z.string(),
                  }),
                  z.string(),
                ]),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        timeout: z.optional(z.number()),
        topic: z.optional(z.string()),
        type: z.enum(['kafka']),
        username: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        version: z.optional(z.string()),
      }),
    ])
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_outputs_response = z
  .object({
    item: z.union([
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.url()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        name: z.string(),
        preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        type: z.enum(['elasticsearch']),
        write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.url()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        kibana_api_key: z.optional(z.union([z.string(), z.null()])),
        kibana_url: z.optional(z.union([z.string(), z.null()])),
        name: z.string(),
        preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            service_token: z.optional(
              z.union([
                z.object({
                  hash: z.optional(z.string()),
                  id: z.string(),
                }),
                z.string(),
              ])
            ),
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        service_token: z.optional(z.union([z.string(), z.null()])),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        sync_integrations: z.optional(z.boolean()),
        sync_uninstalled_integrations: z.optional(z.boolean()),
        type: z.enum(['remote_elasticsearch']),
        write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.string()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        name: z.string(),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        type: z.enum(['logstash']),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']),
        broker_timeout: z.optional(z.number()),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        client_id: z.optional(z.string()),
        compression: z.optional(z.enum(['gzip', 'snappy', 'lz4', 'none'])),
        compression_level: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        connection_type: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        hash: z.optional(
          z.object({
            hash: z.optional(z.string()),
            random: z.optional(z.boolean()),
          })
        ),
        headers: z.optional(
          z.array(
            z.object({
              key: z.string(),
              value: z.string(),
            })
          )
        ),
        hosts: z.array(z.string()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        key: z.optional(z.string()),
        name: z.string(),
        partition: z.optional(z.enum(['random', 'round_robin', 'hash'])),
        password: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        random: z.optional(
          z.object({
            group_events: z.optional(z.number()),
          })
        ),
        required_acks: z.optional(z.union([z.literal(1), z.literal(0), z.literal(-1)])),
        round_robin: z.optional(
          z.object({
            group_events: z.optional(z.number()),
          })
        ),
        sasl: z.optional(
          z.union([
            z.object({
              mechanism: z.optional(z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512'])),
            }),
            z.null(),
          ])
        ),
        secrets: z.optional(
          z.object({
            password: z.optional(
              z.union([
                z.object({
                  hash: z.optional(z.string()),
                  id: z.string(),
                }),
                z.string(),
              ])
            ),
            ssl: z.optional(
              z.object({
                key: z.union([
                  z.object({
                    hash: z.optional(z.string()),
                    id: z.string(),
                  }),
                  z.string(),
                ]),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        timeout: z.optional(z.number()),
        topic: z.optional(z.string()),
        type: z.enum(['kafka']),
        username: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        version: z.optional(z.string()),
      }),
    ]),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_outputs_outputid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    outputId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_outputs_outputid_response = z
  .object({
    id: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_outputs_outputid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    outputId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_outputs_outputid_response = z
  .object({
    item: z.union([
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.url()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        name: z.string(),
        preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        type: z.enum(['elasticsearch']),
        write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.url()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        kibana_api_key: z.optional(z.union([z.string(), z.null()])),
        kibana_url: z.optional(z.union([z.string(), z.null()])),
        name: z.string(),
        preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            service_token: z.optional(
              z.union([
                z.object({
                  hash: z.optional(z.string()),
                  id: z.string(),
                }),
                z.string(),
              ])
            ),
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        service_token: z.optional(z.union([z.string(), z.null()])),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        sync_integrations: z.optional(z.boolean()),
        sync_uninstalled_integrations: z.optional(z.boolean()),
        type: z.enum(['remote_elasticsearch']),
        write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.string()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        name: z.string(),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        type: z.enum(['logstash']),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']),
        broker_timeout: z.optional(z.number()),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        client_id: z.optional(z.string()),
        compression: z.optional(z.enum(['gzip', 'snappy', 'lz4', 'none'])),
        compression_level: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        connection_type: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        hash: z.optional(
          z.object({
            hash: z.optional(z.string()),
            random: z.optional(z.boolean()),
          })
        ),
        headers: z.optional(
          z.array(
            z.object({
              key: z.string(),
              value: z.string(),
            })
          )
        ),
        hosts: z.array(z.string()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        key: z.optional(z.string()),
        name: z.string(),
        partition: z.optional(z.enum(['random', 'round_robin', 'hash'])),
        password: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        random: z.optional(
          z.object({
            group_events: z.optional(z.number()),
          })
        ),
        required_acks: z.optional(z.union([z.literal(1), z.literal(0), z.literal(-1)])),
        round_robin: z.optional(
          z.object({
            group_events: z.optional(z.number()),
          })
        ),
        sasl: z.optional(
          z.union([
            z.object({
              mechanism: z.optional(z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512'])),
            }),
            z.null(),
          ])
        ),
        secrets: z.optional(
          z.object({
            password: z.optional(
              z.union([
                z.object({
                  hash: z.optional(z.string()),
                  id: z.string(),
                }),
                z.string(),
              ])
            ),
            ssl: z.optional(
              z.object({
                key: z.union([
                  z.object({
                    hash: z.optional(z.string()),
                    id: z.string(),
                  }),
                  z.string(),
                ]),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        timeout: z.optional(z.number()),
        topic: z.optional(z.string()),
        type: z.enum(['kafka']),
        username: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        version: z.optional(z.string()),
      }),
    ]),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_outputs_outputid_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.optional(z.array(z.url()).min(1)),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()),
        is_default_monitoring: z.optional(z.boolean()),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        name: z.optional(z.string()),
        preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        type: z.optional(z.enum(['elasticsearch'])),
        write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.optional(z.array(z.url()).min(1)),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()),
        is_default_monitoring: z.optional(z.boolean()),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        kibana_api_key: z.optional(z.union([z.string(), z.null()])),
        kibana_url: z.optional(z.union([z.string(), z.null()])),
        name: z.optional(z.string()),
        preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            service_token: z.optional(
              z.union([
                z.object({
                  hash: z.optional(z.string()),
                  id: z.string(),
                }),
                z.string(),
              ])
            ),
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        service_token: z.optional(z.union([z.string(), z.null()])),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        sync_integrations: z.optional(z.boolean()),
        sync_uninstalled_integrations: z.optional(z.boolean()),
        type: z.optional(z.enum(['remote_elasticsearch'])),
        write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.optional(z.array(z.string()).min(1)),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()),
        is_default_monitoring: z.optional(z.boolean()),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        name: z.optional(z.string()),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        type: z.optional(z.enum(['logstash'])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        auth_type: z.optional(z.enum(['none', 'user_pass', 'ssl', 'kerberos'])),
        broker_timeout: z.optional(z.number()),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        client_id: z.optional(z.string()),
        compression: z.optional(z.enum(['gzip', 'snappy', 'lz4', 'none'])),
        compression_level: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        connection_type: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        hash: z.optional(
          z.object({
            hash: z.optional(z.string()),
            random: z.optional(z.boolean()),
          })
        ),
        headers: z.optional(
          z.array(
            z.object({
              key: z.string(),
              value: z.string(),
            })
          )
        ),
        hosts: z.optional(z.array(z.string()).min(1)),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        key: z.optional(z.string()),
        name: z.string(),
        partition: z.optional(z.enum(['random', 'round_robin', 'hash'])),
        password: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        random: z.optional(
          z.object({
            group_events: z.optional(z.number()),
          })
        ),
        required_acks: z.optional(z.union([z.literal(1), z.literal(0), z.literal(-1)])),
        round_robin: z.optional(
          z.object({
            group_events: z.optional(z.number()),
          })
        ),
        sasl: z.optional(
          z.union([
            z.object({
              mechanism: z.optional(z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512'])),
            }),
            z.null(),
          ])
        ),
        secrets: z.optional(
          z.object({
            password: z.optional(
              z.union([
                z.object({
                  hash: z.optional(z.string()),
                  id: z.string(),
                }),
                z.string(),
              ])
            ),
            ssl: z.optional(
              z.object({
                key: z.union([
                  z.object({
                    hash: z.optional(z.string()),
                    id: z.string(),
                  }),
                  z.string(),
                ]),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        timeout: z.optional(z.number()),
        topic: z.optional(z.string()),
        type: z.optional(z.enum(['kafka'])),
        username: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        version: z.optional(z.string()),
      }),
    ])
  ),
  path: z.object({
    outputId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_outputs_outputid_response = z
  .object({
    item: z.union([
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.url()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        name: z.string(),
        preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        type: z.enum(['elasticsearch']),
        write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.url()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        kibana_api_key: z.optional(z.union([z.string(), z.null()])),
        kibana_url: z.optional(z.union([z.string(), z.null()])),
        name: z.string(),
        preset: z.optional(z.enum(['balanced', 'custom', 'throughput', 'scale', 'latency'])),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            service_token: z.optional(
              z.union([
                z.object({
                  hash: z.optional(z.string()),
                  id: z.string(),
                }),
                z.string(),
              ])
            ),
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        service_token: z.optional(z.union([z.string(), z.null()])),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        sync_integrations: z.optional(z.boolean()),
        sync_uninstalled_integrations: z.optional(z.boolean()),
        type: z.enum(['remote_elasticsearch']),
        write_to_logs_streams: z.optional(z.union([z.boolean(), z.null()])),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        hosts: z.array(z.string()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        name: z.string(),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        secrets: z.optional(
          z.object({
            ssl: z.optional(
              z.object({
                key: z.optional(
                  z.union([
                    z.object({
                      hash: z.optional(z.string()),
                      id: z.string(),
                    }),
                    z.string(),
                  ])
                ),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        type: z.enum(['logstash']),
      }),
      z.object({
        allow_edit: z.optional(z.array(z.string())),
        auth_type: z.enum(['none', 'user_pass', 'ssl', 'kerberos']),
        broker_timeout: z.optional(z.number()),
        ca_sha256: z.optional(z.union([z.string(), z.null()])),
        ca_trusted_fingerprint: z.optional(z.union([z.string(), z.null()])),
        client_id: z.optional(z.string()),
        compression: z.optional(z.enum(['gzip', 'snappy', 'lz4', 'none'])),
        compression_level: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        config_yaml: z.optional(z.union([z.string(), z.null()])),
        connection_type: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        hash: z.optional(
          z.object({
            hash: z.optional(z.string()),
            random: z.optional(z.boolean()),
          })
        ),
        headers: z.optional(
          z.array(
            z.object({
              key: z.string(),
              value: z.string(),
            })
          )
        ),
        hosts: z.array(z.string()).min(1),
        id: z.optional(z.string()),
        is_default: z.optional(z.boolean()).default(false),
        is_default_monitoring: z.optional(z.boolean()).default(false),
        is_internal: z.optional(z.boolean()),
        is_preconfigured: z.optional(z.boolean()),
        key: z.optional(z.string()),
        name: z.string(),
        partition: z.optional(z.enum(['random', 'round_robin', 'hash'])),
        password: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        proxy_id: z.optional(z.union([z.string(), z.null()])),
        random: z.optional(
          z.object({
            group_events: z.optional(z.number()),
          })
        ),
        required_acks: z.optional(z.union([z.literal(1), z.literal(0), z.literal(-1)])),
        round_robin: z.optional(
          z.object({
            group_events: z.optional(z.number()),
          })
        ),
        sasl: z.optional(
          z.union([
            z.object({
              mechanism: z.optional(z.enum(['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512'])),
            }),
            z.null(),
          ])
        ),
        secrets: z.optional(
          z.object({
            password: z.optional(
              z.union([
                z.object({
                  hash: z.optional(z.string()),
                  id: z.string(),
                }),
                z.string(),
              ])
            ),
            ssl: z.optional(
              z.object({
                key: z.union([
                  z.object({
                    hash: z.optional(z.string()),
                    id: z.string(),
                  }),
                  z.string(),
                ]),
              })
            ),
          })
        ),
        shipper: z.optional(
          z.union([
            z.object({
              compression_level: z.union([z.number(), z.null()]),
              disk_queue_compression_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_enabled: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              disk_queue_encryption_enabled: z.union([z.boolean(), z.null()]),
              disk_queue_max_size: z.union([z.number(), z.null()]),
              disk_queue_path: z.union([z.string(), z.null()]),
              loadbalance: z.union([z.boolean(), z.null()]),
              max_batch_bytes: z.union([z.number(), z.null()]),
              mem_queue_events: z.union([z.number(), z.null()]),
              queue_flush_timeout: z.union([z.number(), z.null()]),
            }),
            z.null(),
          ])
        ),
        ssl: z.optional(
          z.union([
            z.object({
              certificate: z.optional(z.string()),
              certificate_authorities: z.optional(z.array(z.string())),
              key: z.optional(z.string()),
              verification_mode: z.optional(z.enum(['full', 'none', 'certificate', 'strict'])),
            }),
            z.null(),
          ])
        ),
        timeout: z.optional(z.number()),
        topic: z.optional(z.string()),
        type: z.enum(['kafka']),
        username: z.union([
          z.array(z.unknown()),
          z.boolean(),
          z.number(),
          z.record(z.string(), z.unknown()),
          z.string(),
          z.null(),
        ]),
        version: z.optional(z.string()),
      }),
    ]),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_outputs_outputid_health_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    outputId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_outputs_outputid_health_response = z
  .object({
    message: z.string().register(z.globalRegistry, {
      description: 'long message if unhealthy',
    }),
    state: z.string().register(z.globalRegistry, {
      description: 'state of output, HEALTHY or DEGRADED',
    }),
    timestamp: z.string().register(z.globalRegistry, {
      description: 'timestamp of reported state',
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_package_policies_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(z.number()),
      perPage: z.optional(z.number()),
      sortField: z.optional(z.string()),
      sortOrder: z.optional(z.enum(['desc', 'asc'])),
      showUpgradeable: z.optional(z.boolean()),
      kuery: z.optional(z.string()),
      format: z.optional(z.enum(['simplified', 'legacy'])),
      withAgentCount: z.optional(z.boolean()),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_package_policies_response = z
  .object({
    items: z.array(
      z.object({
        additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
        agents: z.optional(z.number()),
        cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
        created_at: z.string(),
        created_by: z.string(),
        description: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Package policy description',
          })
        ),
        elasticsearch: z.optional(
          z.object({
            privileges: z.optional(
              z.object({
                cluster: z.optional(z.array(z.string())),
              })
            ),
          })
        ),
        enabled: z.boolean(),
        id: z.string().register(z.globalRegistry, {
          description: 'Package policy unique identifier.',
        }),
        inputs: z.union([
          z.array(
            z.object({
              compiled_input: z.unknown(),
              config: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      frozen: z.optional(z.boolean()),
                      type: z.optional(z.string()),
                      value: z.unknown(),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Package variable (see integration documentation for more information)',
                  })
              ),
              enabled: z.boolean(),
              id: z.optional(z.string()),
              keep_enabled: z.optional(z.boolean()),
              policy_template: z.optional(z.string()),
              streams: z.array(
                z.object({
                  compiled_stream: z.unknown(),
                  config: z.optional(
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      })
                  ),
                  data_stream: z.object({
                    dataset: z.string(),
                    elasticsearch: z.optional(
                      z.object({
                        dynamic_dataset: z.optional(z.boolean()),
                        dynamic_namespace: z.optional(z.boolean()),
                        privileges: z.optional(
                          z.object({
                            indices: z.optional(z.array(z.string())),
                          })
                        ),
                      })
                    ),
                    type: z.string(),
                  }),
                  enabled: z.boolean(),
                  id: z.optional(z.string()),
                  keep_enabled: z.optional(z.boolean()),
                  release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                  vars: z.optional(
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      })
                  ),
                })
              ),
              type: z.string(),
              vars: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      frozen: z.optional(z.boolean()),
                      type: z.optional(z.string()),
                      value: z.unknown(),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Package variable (see integration documentation for more information)',
                  })
              ),
            })
          ),
          z
            .record(
              z.string(),
              z.object({
                enabled: z.optional(
                  z.boolean().register(z.globalRegistry, {
                    description: 'Enable or disable that input. Defaults to `true` (enabled).',
                  })
                ),
                streams: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        enabled: z.optional(
                          z.boolean().register(z.globalRegistry, {
                            description:
                              'Enable or disable that stream. Defaults to `true` (enabled).',
                          })
                        ),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({
                                  id: z.string(),
                                  isSecretRef: z.boolean(),
                                }),
                                z.null(),
                              ])
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input/stream level variable. Refer to the integration documentation for more information.',
                            })
                        ),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input streams. Refer to the integration documentation to know which streams are available.',
                    })
                ),
                vars: z.optional(
                  z
                    .record(
                      z.string(),
                      z.union([
                        z.boolean(),
                        z.string(),
                        z.number(),
                        z.array(z.string()),
                        z.array(z.number()),
                        z.object({
                          id: z.string(),
                          isSecretRef: z.boolean(),
                        }),
                        z.null(),
                      ])
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input/stream level variable. Refer to the integration documentation for more information.',
                    })
                ),
              })
            )
            .register(z.globalRegistry, {
              description:
                'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
            }),
        ]),
        is_managed: z.optional(z.boolean()),
        name: z.string().register(z.globalRegistry, {
          description: 'Unique name for the package policy.',
        }),
        namespace: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
          })
        ),
        output_id: z.optional(z.union([z.string(), z.null()])),
        overrides: z.optional(
          z.union([
            z.object({
              inputs: z.optional(z.record(z.string(), z.unknown())),
            }),
            z.null(),
          ])
        ),
        package: z.optional(
          z.object({
            experimental_data_stream_features: z.optional(
              z.array(
                z.object({
                  data_stream: z.string(),
                  features: z.object({
                    doc_value_only_numeric: z.optional(z.boolean()),
                    doc_value_only_other: z.optional(z.boolean()),
                    synthetic_source: z.optional(z.boolean()),
                    tsdb: z.optional(z.boolean()),
                  }),
                })
              )
            ),
            fips_compatible: z.optional(z.boolean()),
            name: z.string().register(z.globalRegistry, {
              description: 'Package name',
            }),
            requires_root: z.optional(z.boolean()),
            title: z.optional(z.string()),
            version: z.string().register(z.globalRegistry, {
              description: 'Package version',
            }),
          })
        ),
        policy_id: z.optional(z.union([z.string(), z.null()])),
        policy_ids: z.optional(
          z.array(
            z.string().register(z.globalRegistry, {
              description: 'IDs of the agent policies which that package policy will be added to.',
            })
          )
        ),
        revision: z.number().register(z.globalRegistry, {
          description: 'Package policy revision.',
        }),
        secret_references: z.optional(
          z.array(
            z.object({
              id: z.string(),
            })
          )
        ),
        spaceIds: z.optional(z.array(z.string())),
        supports_agentless: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        supports_cloud_connector: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        updated_at: z.string(),
        updated_by: z.string(),
        vars: z.optional(
          z.union([
            z
              .record(
                z.string(),
                z.object({
                  frozen: z.optional(z.boolean()),
                  type: z.optional(z.string()),
                  value: z.unknown(),
                })
              )
              .register(z.globalRegistry, {
                description:
                  'Package variable (see integration documentation for more information)',
              }),
            z
              .record(
                z.string(),
                z.union([
                  z.boolean(),
                  z.string(),
                  z.number(),
                  z.array(z.string()),
                  z.array(z.number()),
                  z.object({
                    id: z.string(),
                    isSecretRef: z.boolean(),
                  }),
                  z.null(),
                ])
              )
              .register(z.globalRegistry, {
                description:
                  'Input/stream level variable. Refer to the integration documentation for more information.',
              }),
          ])
        ),
        version: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Package policy ES version.',
          })
        ),
      })
    ),
    page: z.number(),
    perPage: z.number(),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_package_policies_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
        cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
        description: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Package policy description',
          })
        ),
        enabled: z.optional(z.boolean()),
        force: z.optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Force package policy creation even if the package is not verified, or if the agent policy is managed.',
          })
        ),
        id: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Package policy unique identifier',
          })
        ),
        inputs: z.array(
          z.object({
            config: z.optional(
              z
                .record(
                  z.string(),
                  z.object({
                    frozen: z.optional(z.boolean()),
                    type: z.optional(z.string()),
                    value: z.unknown(),
                  })
                )
                .register(z.globalRegistry, {
                  description:
                    'Package variable (see integration documentation for more information)',
                })
            ),
            enabled: z.boolean(),
            id: z.optional(z.string()),
            keep_enabled: z.optional(z.boolean()),
            policy_template: z.optional(z.string()),
            streams: z.optional(
              z.array(
                z.object({
                  compiled_stream: z.unknown(),
                  config: z.optional(
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      })
                  ),
                  data_stream: z.object({
                    dataset: z.string(),
                    elasticsearch: z.optional(
                      z.object({
                        dynamic_dataset: z.optional(z.boolean()),
                        dynamic_namespace: z.optional(z.boolean()),
                        privileges: z.optional(
                          z.object({
                            indices: z.optional(z.array(z.string())),
                          })
                        ),
                      })
                    ),
                    type: z.string(),
                  }),
                  enabled: z.boolean(),
                  id: z.optional(z.string()),
                  keep_enabled: z.optional(z.boolean()),
                  release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                  vars: z.optional(
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      })
                  ),
                })
              )
            ),
            type: z.string(),
            vars: z.optional(
              z
                .record(
                  z.string(),
                  z.object({
                    frozen: z.optional(z.boolean()),
                    type: z.optional(z.string()),
                    value: z.unknown(),
                  })
                )
                .register(z.globalRegistry, {
                  description:
                    'Package variable (see integration documentation for more information)',
                })
            ),
          })
        ),
        is_managed: z.optional(z.boolean()),
        name: z.string().register(z.globalRegistry, {
          description: 'Unique name for the package policy.',
        }),
        namespace: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
          })
        ),
        output_id: z.optional(z.union([z.string(), z.null()])),
        overrides: z.optional(
          z.union([
            z.object({
              inputs: z.optional(z.record(z.string(), z.unknown())),
            }),
            z.null(),
          ])
        ),
        package: z.optional(
          z.object({
            experimental_data_stream_features: z.optional(
              z.array(
                z.object({
                  data_stream: z.string(),
                  features: z.object({
                    doc_value_only_numeric: z.optional(z.boolean()),
                    doc_value_only_other: z.optional(z.boolean()),
                    synthetic_source: z.optional(z.boolean()),
                    tsdb: z.optional(z.boolean()),
                  }),
                })
              )
            ),
            fips_compatible: z.optional(z.boolean()),
            name: z.string().register(z.globalRegistry, {
              description: 'Package name',
            }),
            requires_root: z.optional(z.boolean()),
            title: z.optional(z.string()),
            version: z.string().register(z.globalRegistry, {
              description: 'Package version',
            }),
          })
        ),
        policy_id: z.optional(z.union([z.string(), z.null()])),
        policy_ids: z.optional(
          z.array(
            z.string().register(z.globalRegistry, {
              description: 'IDs of the agent policies which that package policy will be added to.',
            })
          )
        ),
        spaceIds: z.optional(z.array(z.string())),
        supports_agentless: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        supports_cloud_connector: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        vars: z.optional(
          z
            .record(
              z.string(),
              z.object({
                frozen: z.optional(z.boolean()),
                type: z.optional(z.string()),
                value: z.unknown(),
              })
            )
            .register(z.globalRegistry, {
              description: 'Package variable (see integration documentation for more information)',
            })
        ),
      }),
      z.object({
        additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
        description: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Policy description.',
          })
        ),
        force: z.optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Force package policy creation even if the package is not verified, or if the agent policy is managed.',
          })
        ),
        id: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Policy unique identifier.',
          })
        ),
        inputs: z.optional(
          z
            .record(
              z.string(),
              z.object({
                enabled: z.optional(
                  z.boolean().register(z.globalRegistry, {
                    description: 'Enable or disable that input. Defaults to `true` (enabled).',
                  })
                ),
                streams: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        enabled: z.optional(
                          z.boolean().register(z.globalRegistry, {
                            description:
                              'Enable or disable that stream. Defaults to `true` (enabled).',
                          })
                        ),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({
                                  id: z.string(),
                                  isSecretRef: z.boolean(),
                                }),
                                z.null(),
                              ])
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input/stream level variable. Refer to the integration documentation for more information.',
                            })
                        ),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input streams. Refer to the integration documentation to know which streams are available.',
                    })
                ),
                vars: z.optional(
                  z
                    .record(
                      z.string(),
                      z.union([
                        z.boolean(),
                        z.string(),
                        z.number(),
                        z.array(z.string()),
                        z.array(z.number()),
                        z.object({
                          id: z.string(),
                          isSecretRef: z.boolean(),
                        }),
                        z.null(),
                      ])
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input/stream level variable. Refer to the integration documentation for more information.',
                    })
                ),
              })
            )
            .register(z.globalRegistry, {
              description:
                'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
            })
        ),
        name: z.string().register(z.globalRegistry, {
          description: 'Unique name for the policy.',
        }),
        namespace: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'Policy namespace. When not specified, it inherits the agent policy namespace.',
          })
        ),
        output_id: z.optional(z.union([z.string(), z.null()])),
        package: z.object({
          experimental_data_stream_features: z.optional(
            z.array(
              z.object({
                data_stream: z.string(),
                features: z.object({
                  doc_value_only_numeric: z.optional(z.boolean()),
                  doc_value_only_other: z.optional(z.boolean()),
                  synthetic_source: z.optional(z.boolean()),
                  tsdb: z.optional(z.boolean()),
                }),
              })
            )
          ),
          fips_compatible: z.optional(z.boolean()),
          name: z.string().register(z.globalRegistry, {
            description: 'Package name',
          }),
          requires_root: z.optional(z.boolean()),
          title: z.optional(z.string()),
          version: z.string().register(z.globalRegistry, {
            description: 'Package version',
          }),
        }),
        policy_id: z.optional(z.union([z.string(), z.null()])),
        policy_ids: z.optional(
          z.array(z.string()).register(z.globalRegistry, {
            description: 'IDs of the agent policies which that package policy will be added to.',
          })
        ),
        supports_agentless: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        vars: z.optional(
          z
            .record(
              z.string(),
              z.union([
                z.boolean(),
                z.string(),
                z.number(),
                z.array(z.string()),
                z.array(z.number()),
                z.object({
                  id: z.string(),
                  isSecretRef: z.boolean(),
                }),
                z.null(),
              ])
            )
            .register(z.globalRegistry, {
              description:
                'Input/stream level variable. Refer to the integration documentation for more information.',
            })
        ),
      }),
    ])
  ),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      format: z.optional(z.enum(['simplified', 'legacy'])),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_package_policies_response = z
  .object({
    item: z.object({
      additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
      agents: z.optional(z.number()),
      cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
      created_at: z.string(),
      created_by: z.string(),
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Package policy description',
        })
      ),
      elasticsearch: z.optional(
        z.object({
          privileges: z.optional(
            z.object({
              cluster: z.optional(z.array(z.string())),
            })
          ),
        })
      ),
      enabled: z.boolean(),
      id: z.string().register(z.globalRegistry, {
        description: 'Package policy unique identifier.',
      }),
      inputs: z.union([
        z.array(
          z.object({
            compiled_input: z.unknown(),
            config: z.optional(
              z
                .record(
                  z.string(),
                  z.object({
                    frozen: z.optional(z.boolean()),
                    type: z.optional(z.string()),
                    value: z.unknown(),
                  })
                )
                .register(z.globalRegistry, {
                  description:
                    'Package variable (see integration documentation for more information)',
                })
            ),
            enabled: z.boolean(),
            id: z.optional(z.string()),
            keep_enabled: z.optional(z.boolean()),
            policy_template: z.optional(z.string()),
            streams: z.array(
              z.object({
                compiled_stream: z.unknown(),
                config: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        frozen: z.optional(z.boolean()),
                        type: z.optional(z.string()),
                        value: z.unknown(),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package variable (see integration documentation for more information)',
                    })
                ),
                data_stream: z.object({
                  dataset: z.string(),
                  elasticsearch: z.optional(
                    z.object({
                      dynamic_dataset: z.optional(z.boolean()),
                      dynamic_namespace: z.optional(z.boolean()),
                      privileges: z.optional(
                        z.object({
                          indices: z.optional(z.array(z.string())),
                        })
                      ),
                    })
                  ),
                  type: z.string(),
                }),
                enabled: z.boolean(),
                id: z.optional(z.string()),
                keep_enabled: z.optional(z.boolean()),
                release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                vars: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        frozen: z.optional(z.boolean()),
                        type: z.optional(z.string()),
                        value: z.unknown(),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package variable (see integration documentation for more information)',
                    })
                ),
              })
            ),
            type: z.string(),
            vars: z.optional(
              z
                .record(
                  z.string(),
                  z.object({
                    frozen: z.optional(z.boolean()),
                    type: z.optional(z.string()),
                    value: z.unknown(),
                  })
                )
                .register(z.globalRegistry, {
                  description:
                    'Package variable (see integration documentation for more information)',
                })
            ),
          })
        ),
        z
          .record(
            z.string(),
            z.object({
              enabled: z.optional(
                z.boolean().register(z.globalRegistry, {
                  description: 'Enable or disable that input. Defaults to `true` (enabled).',
                })
              ),
              streams: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      enabled: z.optional(
                        z.boolean().register(z.globalRegistry, {
                          description:
                            'Enable or disable that stream. Defaults to `true` (enabled).',
                        })
                      ),
                      vars: z.optional(
                        z
                          .record(
                            z.string(),
                            z.union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({
                                id: z.string(),
                                isSecretRef: z.boolean(),
                              }),
                              z.null(),
                            ])
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Input/stream level variable. Refer to the integration documentation for more information.',
                          })
                      ),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Input streams. Refer to the integration documentation to know which streams are available.',
                  })
              ),
              vars: z.optional(
                z
                  .record(
                    z.string(),
                    z.union([
                      z.boolean(),
                      z.string(),
                      z.number(),
                      z.array(z.string()),
                      z.array(z.number()),
                      z.object({
                        id: z.string(),
                        isSecretRef: z.boolean(),
                      }),
                      z.null(),
                    ])
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Input/stream level variable. Refer to the integration documentation for more information.',
                  })
              ),
            })
          )
          .register(z.globalRegistry, {
            description:
              'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
          }),
      ]),
      is_managed: z.optional(z.boolean()),
      name: z.string().register(z.globalRegistry, {
        description: 'Unique name for the package policy.',
      }),
      namespace: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
        })
      ),
      output_id: z.optional(z.union([z.string(), z.null()])),
      overrides: z.optional(
        z.union([
          z.object({
            inputs: z.optional(z.record(z.string(), z.unknown())),
          }),
          z.null(),
        ])
      ),
      package: z.optional(
        z.object({
          experimental_data_stream_features: z.optional(
            z.array(
              z.object({
                data_stream: z.string(),
                features: z.object({
                  doc_value_only_numeric: z.optional(z.boolean()),
                  doc_value_only_other: z.optional(z.boolean()),
                  synthetic_source: z.optional(z.boolean()),
                  tsdb: z.optional(z.boolean()),
                }),
              })
            )
          ),
          fips_compatible: z.optional(z.boolean()),
          name: z.string().register(z.globalRegistry, {
            description: 'Package name',
          }),
          requires_root: z.optional(z.boolean()),
          title: z.optional(z.string()),
          version: z.string().register(z.globalRegistry, {
            description: 'Package version',
          }),
        })
      ),
      policy_id: z.optional(z.union([z.string(), z.null()])),
      policy_ids: z.optional(
        z.array(
          z.string().register(z.globalRegistry, {
            description: 'IDs of the agent policies which that package policy will be added to.',
          })
        )
      ),
      revision: z.number().register(z.globalRegistry, {
        description: 'Package policy revision.',
      }),
      secret_references: z.optional(
        z.array(
          z.object({
            id: z.string(),
          })
        )
      ),
      spaceIds: z.optional(z.array(z.string())),
      supports_agentless: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      supports_cloud_connector: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      updated_at: z.string(),
      updated_by: z.string(),
      vars: z.optional(
        z.union([
          z
            .record(
              z.string(),
              z.object({
                frozen: z.optional(z.boolean()),
                type: z.optional(z.string()),
                value: z.unknown(),
              })
            )
            .register(z.globalRegistry, {
              description: 'Package variable (see integration documentation for more information)',
            }),
          z
            .record(
              z.string(),
              z.union([
                z.boolean(),
                z.string(),
                z.number(),
                z.array(z.string()),
                z.array(z.number()),
                z.object({
                  id: z.string(),
                  isSecretRef: z.boolean(),
                }),
                z.null(),
              ])
            )
            .register(z.globalRegistry, {
              description:
                'Input/stream level variable. Refer to the integration documentation for more information.',
            }),
        ])
      ),
      version: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Package policy ES version.',
        })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_package_policies_bulk_get_request = z.object({
  body: z.optional(
    z.object({
      ids: z.array(z.string()).register(z.globalRegistry, {
        description: 'list of package policy ids',
      }),
      ignoreMissing: z.optional(z.boolean()),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      format: z.optional(z.enum(['simplified', 'legacy'])),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_package_policies_bulk_get_response = z
  .object({
    items: z.array(
      z.object({
        additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
        agents: z.optional(z.number()),
        cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
        created_at: z.string(),
        created_by: z.string(),
        description: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Package policy description',
          })
        ),
        elasticsearch: z.optional(
          z.object({
            privileges: z.optional(
              z.object({
                cluster: z.optional(z.array(z.string())),
              })
            ),
          })
        ),
        enabled: z.boolean(),
        id: z.string().register(z.globalRegistry, {
          description: 'Package policy unique identifier.',
        }),
        inputs: z.union([
          z.array(
            z.object({
              compiled_input: z.unknown(),
              config: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      frozen: z.optional(z.boolean()),
                      type: z.optional(z.string()),
                      value: z.unknown(),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Package variable (see integration documentation for more information)',
                  })
              ),
              enabled: z.boolean(),
              id: z.optional(z.string()),
              keep_enabled: z.optional(z.boolean()),
              policy_template: z.optional(z.string()),
              streams: z.array(
                z.object({
                  compiled_stream: z.unknown(),
                  config: z.optional(
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      })
                  ),
                  data_stream: z.object({
                    dataset: z.string(),
                    elasticsearch: z.optional(
                      z.object({
                        dynamic_dataset: z.optional(z.boolean()),
                        dynamic_namespace: z.optional(z.boolean()),
                        privileges: z.optional(
                          z.object({
                            indices: z.optional(z.array(z.string())),
                          })
                        ),
                      })
                    ),
                    type: z.string(),
                  }),
                  enabled: z.boolean(),
                  id: z.optional(z.string()),
                  keep_enabled: z.optional(z.boolean()),
                  release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                  vars: z.optional(
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      })
                  ),
                })
              ),
              type: z.string(),
              vars: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      frozen: z.optional(z.boolean()),
                      type: z.optional(z.string()),
                      value: z.unknown(),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Package variable (see integration documentation for more information)',
                  })
              ),
            })
          ),
          z
            .record(
              z.string(),
              z.object({
                enabled: z.optional(
                  z.boolean().register(z.globalRegistry, {
                    description: 'Enable or disable that input. Defaults to `true` (enabled).',
                  })
                ),
                streams: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        enabled: z.optional(
                          z.boolean().register(z.globalRegistry, {
                            description:
                              'Enable or disable that stream. Defaults to `true` (enabled).',
                          })
                        ),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({
                                  id: z.string(),
                                  isSecretRef: z.boolean(),
                                }),
                                z.null(),
                              ])
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input/stream level variable. Refer to the integration documentation for more information.',
                            })
                        ),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input streams. Refer to the integration documentation to know which streams are available.',
                    })
                ),
                vars: z.optional(
                  z
                    .record(
                      z.string(),
                      z.union([
                        z.boolean(),
                        z.string(),
                        z.number(),
                        z.array(z.string()),
                        z.array(z.number()),
                        z.object({
                          id: z.string(),
                          isSecretRef: z.boolean(),
                        }),
                        z.null(),
                      ])
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input/stream level variable. Refer to the integration documentation for more information.',
                    })
                ),
              })
            )
            .register(z.globalRegistry, {
              description:
                'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
            }),
        ]),
        is_managed: z.optional(z.boolean()),
        name: z.string().register(z.globalRegistry, {
          description: 'Unique name for the package policy.',
        }),
        namespace: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
          })
        ),
        output_id: z.optional(z.union([z.string(), z.null()])),
        overrides: z.optional(
          z.union([
            z.object({
              inputs: z.optional(z.record(z.string(), z.unknown())),
            }),
            z.null(),
          ])
        ),
        package: z.optional(
          z.object({
            experimental_data_stream_features: z.optional(
              z.array(
                z.object({
                  data_stream: z.string(),
                  features: z.object({
                    doc_value_only_numeric: z.optional(z.boolean()),
                    doc_value_only_other: z.optional(z.boolean()),
                    synthetic_source: z.optional(z.boolean()),
                    tsdb: z.optional(z.boolean()),
                  }),
                })
              )
            ),
            fips_compatible: z.optional(z.boolean()),
            name: z.string().register(z.globalRegistry, {
              description: 'Package name',
            }),
            requires_root: z.optional(z.boolean()),
            title: z.optional(z.string()),
            version: z.string().register(z.globalRegistry, {
              description: 'Package version',
            }),
          })
        ),
        policy_id: z.optional(z.union([z.string(), z.null()])),
        policy_ids: z.optional(
          z.array(
            z.string().register(z.globalRegistry, {
              description: 'IDs of the agent policies which that package policy will be added to.',
            })
          )
        ),
        revision: z.number().register(z.globalRegistry, {
          description: 'Package policy revision.',
        }),
        secret_references: z.optional(
          z.array(
            z.object({
              id: z.string(),
            })
          )
        ),
        spaceIds: z.optional(z.array(z.string())),
        supports_agentless: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        supports_cloud_connector: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        updated_at: z.string(),
        updated_by: z.string(),
        vars: z.optional(
          z.union([
            z
              .record(
                z.string(),
                z.object({
                  frozen: z.optional(z.boolean()),
                  type: z.optional(z.string()),
                  value: z.unknown(),
                })
              )
              .register(z.globalRegistry, {
                description:
                  'Package variable (see integration documentation for more information)',
              }),
            z
              .record(
                z.string(),
                z.union([
                  z.boolean(),
                  z.string(),
                  z.number(),
                  z.array(z.string()),
                  z.array(z.number()),
                  z.object({
                    id: z.string(),
                    isSecretRef: z.boolean(),
                  }),
                  z.null(),
                ])
              )
              .register(z.globalRegistry, {
                description:
                  'Input/stream level variable. Refer to the integration documentation for more information.',
              }),
          ])
        ),
        version: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Package policy ES version.',
          })
        ),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_package_policies_packagepolicyid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    packagePolicyId: z.string(),
  }),
  query: z.optional(
    z.object({
      force: z.optional(z.boolean()),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_package_policies_packagepolicyid_response = z
  .object({
    id: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_package_policies_packagepolicyid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    packagePolicyId: z.string(),
  }),
  query: z.optional(
    z.object({
      format: z.optional(z.enum(['simplified', 'legacy'])),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_package_policies_packagepolicyid_response = z
  .object({
    item: z.object({
      additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
      agents: z.optional(z.number()),
      cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
      created_at: z.string(),
      created_by: z.string(),
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Package policy description',
        })
      ),
      elasticsearch: z.optional(
        z.object({
          privileges: z.optional(
            z.object({
              cluster: z.optional(z.array(z.string())),
            })
          ),
        })
      ),
      enabled: z.boolean(),
      id: z.string().register(z.globalRegistry, {
        description: 'Package policy unique identifier.',
      }),
      inputs: z.union([
        z.array(
          z.object({
            compiled_input: z.unknown(),
            config: z.optional(
              z
                .record(
                  z.string(),
                  z.object({
                    frozen: z.optional(z.boolean()),
                    type: z.optional(z.string()),
                    value: z.unknown(),
                  })
                )
                .register(z.globalRegistry, {
                  description:
                    'Package variable (see integration documentation for more information)',
                })
            ),
            enabled: z.boolean(),
            id: z.optional(z.string()),
            keep_enabled: z.optional(z.boolean()),
            policy_template: z.optional(z.string()),
            streams: z.array(
              z.object({
                compiled_stream: z.unknown(),
                config: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        frozen: z.optional(z.boolean()),
                        type: z.optional(z.string()),
                        value: z.unknown(),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package variable (see integration documentation for more information)',
                    })
                ),
                data_stream: z.object({
                  dataset: z.string(),
                  elasticsearch: z.optional(
                    z.object({
                      dynamic_dataset: z.optional(z.boolean()),
                      dynamic_namespace: z.optional(z.boolean()),
                      privileges: z.optional(
                        z.object({
                          indices: z.optional(z.array(z.string())),
                        })
                      ),
                    })
                  ),
                  type: z.string(),
                }),
                enabled: z.boolean(),
                id: z.optional(z.string()),
                keep_enabled: z.optional(z.boolean()),
                release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                vars: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        frozen: z.optional(z.boolean()),
                        type: z.optional(z.string()),
                        value: z.unknown(),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package variable (see integration documentation for more information)',
                    })
                ),
              })
            ),
            type: z.string(),
            vars: z.optional(
              z
                .record(
                  z.string(),
                  z.object({
                    frozen: z.optional(z.boolean()),
                    type: z.optional(z.string()),
                    value: z.unknown(),
                  })
                )
                .register(z.globalRegistry, {
                  description:
                    'Package variable (see integration documentation for more information)',
                })
            ),
          })
        ),
        z
          .record(
            z.string(),
            z.object({
              enabled: z.optional(
                z.boolean().register(z.globalRegistry, {
                  description: 'Enable or disable that input. Defaults to `true` (enabled).',
                })
              ),
              streams: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      enabled: z.optional(
                        z.boolean().register(z.globalRegistry, {
                          description:
                            'Enable or disable that stream. Defaults to `true` (enabled).',
                        })
                      ),
                      vars: z.optional(
                        z
                          .record(
                            z.string(),
                            z.union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({
                                id: z.string(),
                                isSecretRef: z.boolean(),
                              }),
                              z.null(),
                            ])
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Input/stream level variable. Refer to the integration documentation for more information.',
                          })
                      ),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Input streams. Refer to the integration documentation to know which streams are available.',
                  })
              ),
              vars: z.optional(
                z
                  .record(
                    z.string(),
                    z.union([
                      z.boolean(),
                      z.string(),
                      z.number(),
                      z.array(z.string()),
                      z.array(z.number()),
                      z.object({
                        id: z.string(),
                        isSecretRef: z.boolean(),
                      }),
                      z.null(),
                    ])
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Input/stream level variable. Refer to the integration documentation for more information.',
                  })
              ),
            })
          )
          .register(z.globalRegistry, {
            description:
              'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
          }),
      ]),
      is_managed: z.optional(z.boolean()),
      name: z.string().register(z.globalRegistry, {
        description: 'Unique name for the package policy.',
      }),
      namespace: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
        })
      ),
      output_id: z.optional(z.union([z.string(), z.null()])),
      overrides: z.optional(
        z.union([
          z.object({
            inputs: z.optional(z.record(z.string(), z.unknown())),
          }),
          z.null(),
        ])
      ),
      package: z.optional(
        z.object({
          experimental_data_stream_features: z.optional(
            z.array(
              z.object({
                data_stream: z.string(),
                features: z.object({
                  doc_value_only_numeric: z.optional(z.boolean()),
                  doc_value_only_other: z.optional(z.boolean()),
                  synthetic_source: z.optional(z.boolean()),
                  tsdb: z.optional(z.boolean()),
                }),
              })
            )
          ),
          fips_compatible: z.optional(z.boolean()),
          name: z.string().register(z.globalRegistry, {
            description: 'Package name',
          }),
          requires_root: z.optional(z.boolean()),
          title: z.optional(z.string()),
          version: z.string().register(z.globalRegistry, {
            description: 'Package version',
          }),
        })
      ),
      policy_id: z.optional(z.union([z.string(), z.null()])),
      policy_ids: z.optional(
        z.array(
          z.string().register(z.globalRegistry, {
            description: 'IDs of the agent policies which that package policy will be added to.',
          })
        )
      ),
      revision: z.number().register(z.globalRegistry, {
        description: 'Package policy revision.',
      }),
      secret_references: z.optional(
        z.array(
          z.object({
            id: z.string(),
          })
        )
      ),
      spaceIds: z.optional(z.array(z.string())),
      supports_agentless: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      supports_cloud_connector: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      updated_at: z.string(),
      updated_by: z.string(),
      vars: z.optional(
        z.union([
          z
            .record(
              z.string(),
              z.object({
                frozen: z.optional(z.boolean()),
                type: z.optional(z.string()),
                value: z.unknown(),
              })
            )
            .register(z.globalRegistry, {
              description: 'Package variable (see integration documentation for more information)',
            }),
          z
            .record(
              z.string(),
              z.union([
                z.boolean(),
                z.string(),
                z.number(),
                z.array(z.string()),
                z.array(z.number()),
                z.object({
                  id: z.string(),
                  isSecretRef: z.boolean(),
                }),
                z.null(),
              ])
            )
            .register(z.globalRegistry, {
              description:
                'Input/stream level variable. Refer to the integration documentation for more information.',
            }),
        ])
      ),
      version: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Package policy ES version.',
        })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_package_policies_packagepolicyid_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
        cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
        description: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Package policy description',
          })
        ),
        enabled: z.optional(z.boolean()),
        force: z.optional(z.boolean()),
        inputs: z.optional(
          z.array(
            z.object({
              config: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      frozen: z.optional(z.boolean()),
                      type: z.optional(z.string()),
                      value: z.unknown(),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Package variable (see integration documentation for more information)',
                  })
              ),
              enabled: z.boolean(),
              id: z.optional(z.string()),
              keep_enabled: z.optional(z.boolean()),
              policy_template: z.optional(z.string()),
              streams: z.optional(
                z.array(
                  z.object({
                    compiled_stream: z.unknown(),
                    config: z.optional(
                      z
                        .record(
                          z.string(),
                          z.object({
                            frozen: z.optional(z.boolean()),
                            type: z.optional(z.string()),
                            value: z.unknown(),
                          })
                        )
                        .register(z.globalRegistry, {
                          description:
                            'Package variable (see integration documentation for more information)',
                        })
                    ),
                    data_stream: z.object({
                      dataset: z.string(),
                      elasticsearch: z.optional(
                        z.object({
                          dynamic_dataset: z.optional(z.boolean()),
                          dynamic_namespace: z.optional(z.boolean()),
                          privileges: z.optional(
                            z.object({
                              indices: z.optional(z.array(z.string())),
                            })
                          ),
                        })
                      ),
                      type: z.string(),
                    }),
                    enabled: z.boolean(),
                    id: z.optional(z.string()),
                    keep_enabled: z.optional(z.boolean()),
                    release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                    vars: z.optional(
                      z
                        .record(
                          z.string(),
                          z.object({
                            frozen: z.optional(z.boolean()),
                            type: z.optional(z.string()),
                            value: z.unknown(),
                          })
                        )
                        .register(z.globalRegistry, {
                          description:
                            'Package variable (see integration documentation for more information)',
                        })
                    ),
                  })
                )
              ),
              type: z.string(),
              vars: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      frozen: z.optional(z.boolean()),
                      type: z.optional(z.string()),
                      value: z.unknown(),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Package variable (see integration documentation for more information)',
                  })
              ),
            })
          )
        ),
        is_managed: z.optional(z.boolean()),
        name: z.optional(z.string()),
        namespace: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
          })
        ),
        output_id: z.optional(z.union([z.string(), z.null()])),
        overrides: z.optional(
          z.union([
            z.object({
              inputs: z.optional(z.record(z.string(), z.unknown())),
            }),
            z.null(),
          ])
        ),
        package: z.optional(
          z.object({
            experimental_data_stream_features: z.optional(
              z.array(
                z.object({
                  data_stream: z.string(),
                  features: z.object({
                    doc_value_only_numeric: z.optional(z.boolean()),
                    doc_value_only_other: z.optional(z.boolean()),
                    synthetic_source: z.optional(z.boolean()),
                    tsdb: z.optional(z.boolean()),
                  }),
                })
              )
            ),
            fips_compatible: z.optional(z.boolean()),
            name: z.string().register(z.globalRegistry, {
              description: 'Package name',
            }),
            requires_root: z.optional(z.boolean()),
            title: z.optional(z.string()),
            version: z.string().register(z.globalRegistry, {
              description: 'Package version',
            }),
          })
        ),
        policy_id: z.optional(z.union([z.string(), z.null()])),
        policy_ids: z.optional(
          z.array(
            z.string().register(z.globalRegistry, {
              description: 'IDs of the agent policies which that package policy will be added to.',
            })
          )
        ),
        spaceIds: z.optional(z.array(z.string())),
        supports_agentless: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        supports_cloud_connector: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        vars: z.optional(
          z
            .record(
              z.string(),
              z.object({
                frozen: z.optional(z.boolean()),
                type: z.optional(z.string()),
                value: z.unknown(),
              })
            )
            .register(z.globalRegistry, {
              description: 'Package variable (see integration documentation for more information)',
            })
        ),
        version: z.optional(z.string()),
      }),
      z.object({
        additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
        description: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Policy description.',
          })
        ),
        force: z.optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Force package policy creation even if the package is not verified, or if the agent policy is managed.',
          })
        ),
        id: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Policy unique identifier.',
          })
        ),
        inputs: z.optional(
          z
            .record(
              z.string(),
              z.object({
                enabled: z.optional(
                  z.boolean().register(z.globalRegistry, {
                    description: 'Enable or disable that input. Defaults to `true` (enabled).',
                  })
                ),
                streams: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        enabled: z.optional(
                          z.boolean().register(z.globalRegistry, {
                            description:
                              'Enable or disable that stream. Defaults to `true` (enabled).',
                          })
                        ),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.union([
                                z.boolean(),
                                z.string(),
                                z.number(),
                                z.array(z.string()),
                                z.array(z.number()),
                                z.object({
                                  id: z.string(),
                                  isSecretRef: z.boolean(),
                                }),
                                z.null(),
                              ])
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Input/stream level variable. Refer to the integration documentation for more information.',
                            })
                        ),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input streams. Refer to the integration documentation to know which streams are available.',
                    })
                ),
                vars: z.optional(
                  z
                    .record(
                      z.string(),
                      z.union([
                        z.boolean(),
                        z.string(),
                        z.number(),
                        z.array(z.string()),
                        z.array(z.number()),
                        z.object({
                          id: z.string(),
                          isSecretRef: z.boolean(),
                        }),
                        z.null(),
                      ])
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input/stream level variable. Refer to the integration documentation for more information.',
                    })
                ),
              })
            )
            .register(z.globalRegistry, {
              description:
                'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
            })
        ),
        name: z.string().register(z.globalRegistry, {
          description: 'Unique name for the policy.',
        }),
        namespace: z.optional(
          z.string().register(z.globalRegistry, {
            description:
              'Policy namespace. When not specified, it inherits the agent policy namespace.',
          })
        ),
        output_id: z.optional(z.union([z.string(), z.null()])),
        package: z.object({
          experimental_data_stream_features: z.optional(
            z.array(
              z.object({
                data_stream: z.string(),
                features: z.object({
                  doc_value_only_numeric: z.optional(z.boolean()),
                  doc_value_only_other: z.optional(z.boolean()),
                  synthetic_source: z.optional(z.boolean()),
                  tsdb: z.optional(z.boolean()),
                }),
              })
            )
          ),
          fips_compatible: z.optional(z.boolean()),
          name: z.string().register(z.globalRegistry, {
            description: 'Package name',
          }),
          requires_root: z.optional(z.boolean()),
          title: z.optional(z.string()),
          version: z.string().register(z.globalRegistry, {
            description: 'Package version',
          }),
        }),
        policy_id: z.optional(z.union([z.string(), z.null()])),
        policy_ids: z.optional(
          z.array(z.string()).register(z.globalRegistry, {
            description: 'IDs of the agent policies which that package policy will be added to.',
          })
        ),
        supports_agentless: z
          .optional(z.union([z.boolean().default(false), z.null()]))
          .default(false),
        vars: z.optional(
          z
            .record(
              z.string(),
              z.union([
                z.boolean(),
                z.string(),
                z.number(),
                z.array(z.string()),
                z.array(z.number()),
                z.object({
                  id: z.string(),
                  isSecretRef: z.boolean(),
                }),
                z.null(),
              ])
            )
            .register(z.globalRegistry, {
              description:
                'Input/stream level variable. Refer to the integration documentation for more information.',
            })
        ),
      }),
    ])
  ),
  path: z.object({
    packagePolicyId: z.string(),
  }),
  query: z.optional(
    z.object({
      format: z.optional(z.enum(['simplified', 'legacy'])),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_package_policies_packagepolicyid_response = z
  .object({
    item: z.object({
      additional_datastreams_permissions: z.optional(z.union([z.array(z.string()), z.null()])),
      agents: z.optional(z.number()),
      cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
      created_at: z.string(),
      created_by: z.string(),
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Package policy description',
        })
      ),
      elasticsearch: z.optional(
        z.object({
          privileges: z.optional(
            z.object({
              cluster: z.optional(z.array(z.string())),
            })
          ),
        })
      ),
      enabled: z.boolean(),
      id: z.string().register(z.globalRegistry, {
        description: 'Package policy unique identifier.',
      }),
      inputs: z.union([
        z.array(
          z.object({
            compiled_input: z.unknown(),
            config: z.optional(
              z
                .record(
                  z.string(),
                  z.object({
                    frozen: z.optional(z.boolean()),
                    type: z.optional(z.string()),
                    value: z.unknown(),
                  })
                )
                .register(z.globalRegistry, {
                  description:
                    'Package variable (see integration documentation for more information)',
                })
            ),
            enabled: z.boolean(),
            id: z.optional(z.string()),
            keep_enabled: z.optional(z.boolean()),
            policy_template: z.optional(z.string()),
            streams: z.array(
              z.object({
                compiled_stream: z.unknown(),
                config: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        frozen: z.optional(z.boolean()),
                        type: z.optional(z.string()),
                        value: z.unknown(),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package variable (see integration documentation for more information)',
                    })
                ),
                data_stream: z.object({
                  dataset: z.string(),
                  elasticsearch: z.optional(
                    z.object({
                      dynamic_dataset: z.optional(z.boolean()),
                      dynamic_namespace: z.optional(z.boolean()),
                      privileges: z.optional(
                        z.object({
                          indices: z.optional(z.array(z.string())),
                        })
                      ),
                    })
                  ),
                  type: z.string(),
                }),
                enabled: z.boolean(),
                id: z.optional(z.string()),
                keep_enabled: z.optional(z.boolean()),
                release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                vars: z.optional(
                  z
                    .record(
                      z.string(),
                      z.object({
                        frozen: z.optional(z.boolean()),
                        type: z.optional(z.string()),
                        value: z.unknown(),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package variable (see integration documentation for more information)',
                    })
                ),
              })
            ),
            type: z.string(),
            vars: z.optional(
              z
                .record(
                  z.string(),
                  z.object({
                    frozen: z.optional(z.boolean()),
                    type: z.optional(z.string()),
                    value: z.unknown(),
                  })
                )
                .register(z.globalRegistry, {
                  description:
                    'Package variable (see integration documentation for more information)',
                })
            ),
          })
        ),
        z
          .record(
            z.string(),
            z.object({
              enabled: z.optional(
                z.boolean().register(z.globalRegistry, {
                  description: 'Enable or disable that input. Defaults to `true` (enabled).',
                })
              ),
              streams: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      enabled: z.optional(
                        z.boolean().register(z.globalRegistry, {
                          description:
                            'Enable or disable that stream. Defaults to `true` (enabled).',
                        })
                      ),
                      vars: z.optional(
                        z
                          .record(
                            z.string(),
                            z.union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({
                                id: z.string(),
                                isSecretRef: z.boolean(),
                              }),
                              z.null(),
                            ])
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Input/stream level variable. Refer to the integration documentation for more information.',
                          })
                      ),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Input streams. Refer to the integration documentation to know which streams are available.',
                  })
              ),
              vars: z.optional(
                z
                  .record(
                    z.string(),
                    z.union([
                      z.boolean(),
                      z.string(),
                      z.number(),
                      z.array(z.string()),
                      z.array(z.number()),
                      z.object({
                        id: z.string(),
                        isSecretRef: z.boolean(),
                      }),
                      z.null(),
                    ])
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Input/stream level variable. Refer to the integration documentation for more information.',
                  })
              ),
            })
          )
          .register(z.globalRegistry, {
            description:
              'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
          }),
      ]),
      is_managed: z.optional(z.boolean()),
      name: z.string().register(z.globalRegistry, {
        description: 'Unique name for the package policy.',
      }),
      namespace: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
        })
      ),
      output_id: z.optional(z.union([z.string(), z.null()])),
      overrides: z.optional(
        z.union([
          z.object({
            inputs: z.optional(z.record(z.string(), z.unknown())),
          }),
          z.null(),
        ])
      ),
      package: z.optional(
        z.object({
          experimental_data_stream_features: z.optional(
            z.array(
              z.object({
                data_stream: z.string(),
                features: z.object({
                  doc_value_only_numeric: z.optional(z.boolean()),
                  doc_value_only_other: z.optional(z.boolean()),
                  synthetic_source: z.optional(z.boolean()),
                  tsdb: z.optional(z.boolean()),
                }),
              })
            )
          ),
          fips_compatible: z.optional(z.boolean()),
          name: z.string().register(z.globalRegistry, {
            description: 'Package name',
          }),
          requires_root: z.optional(z.boolean()),
          title: z.optional(z.string()),
          version: z.string().register(z.globalRegistry, {
            description: 'Package version',
          }),
        })
      ),
      policy_id: z.optional(z.union([z.string(), z.null()])),
      policy_ids: z.optional(
        z.array(
          z.string().register(z.globalRegistry, {
            description: 'IDs of the agent policies which that package policy will be added to.',
          })
        )
      ),
      revision: z.number().register(z.globalRegistry, {
        description: 'Package policy revision.',
      }),
      secret_references: z.optional(
        z.array(
          z.object({
            id: z.string(),
          })
        )
      ),
      spaceIds: z.optional(z.array(z.string())),
      supports_agentless: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      supports_cloud_connector: z
        .optional(z.union([z.boolean().default(false), z.null()]))
        .default(false),
      updated_at: z.string(),
      updated_by: z.string(),
      vars: z.optional(
        z.union([
          z
            .record(
              z.string(),
              z.object({
                frozen: z.optional(z.boolean()),
                type: z.optional(z.string()),
                value: z.unknown(),
              })
            )
            .register(z.globalRegistry, {
              description: 'Package variable (see integration documentation for more information)',
            }),
          z
            .record(
              z.string(),
              z.union([
                z.boolean(),
                z.string(),
                z.number(),
                z.array(z.string()),
                z.array(z.number()),
                z.object({
                  id: z.string(),
                  isSecretRef: z.boolean(),
                }),
                z.null(),
              ])
            )
            .register(z.globalRegistry, {
              description:
                'Input/stream level variable. Refer to the integration documentation for more information.',
            }),
        ])
      ),
      version: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Package policy ES version.',
        })
      ),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_package_policies_delete_request = z.object({
  body: z.optional(
    z.object({
      force: z.optional(z.boolean()),
      packagePolicyIds: z.array(z.string()),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_package_policies_delete_response = z
  .array(
    z.object({
      body: z.optional(
        z.object({
          message: z.string(),
        })
      ),
      id: z.string(),
      name: z.optional(z.string()),
      output_id: z.optional(z.union([z.string(), z.null()])),
      package: z.object({
        experimental_data_stream_features: z.optional(
          z.array(
            z.object({
              data_stream: z.string(),
              features: z.object({
                doc_value_only_numeric: z.optional(z.boolean()),
                doc_value_only_other: z.optional(z.boolean()),
                synthetic_source: z.optional(z.boolean()),
                tsdb: z.optional(z.boolean()),
              }),
            })
          )
        ),
        fips_compatible: z.optional(z.boolean()),
        name: z.string().register(z.globalRegistry, {
          description: 'Package name',
        }),
        requires_root: z.optional(z.boolean()),
        title: z.optional(z.string()),
        version: z.string().register(z.globalRegistry, {
          description: 'Package version',
        }),
      }),
      policy_id: z.optional(z.union([z.string(), z.null()])),
      policy_ids: z.array(z.string()),
      statusCode: z.optional(z.number()),
      success: z.boolean(),
    })
  )
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_package_policies_upgrade_request = z.object({
  body: z.optional(
    z.object({
      packagePolicyIds: z.array(z.string()),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_package_policies_upgrade_response = z
  .array(
    z.object({
      body: z.optional(
        z.object({
          message: z.string(),
        })
      ),
      id: z.string(),
      name: z.optional(z.string()),
      statusCode: z.optional(z.number()),
      success: z.boolean(),
    })
  )
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_package_policies_upgrade_dryrun_request = z.object({
  body: z.optional(
    z.object({
      packagePolicyIds: z.array(z.string()),
      packageVersion: z.optional(z.string()),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_package_policies_upgrade_dryrun_response = z
  .array(
    z.object({
      agent_diff: z.optional(
        z.array(
          z.array(
            z.object({
              data_stream: z.object({
                namespace: z.string(),
              }),
              id: z.string(),
              meta: z.optional(
                z.object({
                  package: z.object({
                    name: z.string(),
                    version: z.string(),
                  }),
                })
              ),
              name: z.string(),
              package_policy_id: z.string(),
              processors: z.optional(
                z.array(
                  z.object({
                    add_fields: z.object({
                      fields: z.record(z.string(), z.union([z.string(), z.number()])),
                      target: z.string(),
                    }),
                  })
                )
              ),
              revision: z.number(),
              streams: z.optional(
                z.array(
                  z.object({
                    data_stream: z.object({
                      dataset: z.string(),
                      type: z.optional(z.string()),
                    }),
                    id: z.optional(z.string()),
                  })
                )
              ),
              type: z.string(),
              use_output: z.string(),
            })
          )
        )
      ),
      body: z.optional(
        z.object({
          message: z.string(),
        })
      ),
      diff: z.optional(
        z.array(
          z.union([
            z.object({
              additional_datastreams_permissions: z.optional(
                z.union([z.array(z.string()), z.null()])
              ),
              agents: z.optional(z.number()),
              cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
              created_at: z.string(),
              created_by: z.string(),
              description: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'Package policy description',
                })
              ),
              elasticsearch: z.optional(
                z.object({
                  privileges: z.optional(
                    z.object({
                      cluster: z.optional(z.array(z.string())),
                    })
                  ),
                })
              ),
              enabled: z.boolean(),
              id: z.optional(z.string()),
              inputs: z.union([
                z.array(
                  z.object({
                    compiled_input: z.unknown(),
                    config: z.optional(
                      z
                        .record(
                          z.string(),
                          z.object({
                            frozen: z.optional(z.boolean()),
                            type: z.optional(z.string()),
                            value: z.unknown(),
                          })
                        )
                        .register(z.globalRegistry, {
                          description:
                            'Package variable (see integration documentation for more information)',
                        })
                    ),
                    enabled: z.boolean(),
                    id: z.optional(z.string()),
                    keep_enabled: z.optional(z.boolean()),
                    policy_template: z.optional(z.string()),
                    streams: z.array(
                      z.object({
                        compiled_stream: z.unknown(),
                        config: z.optional(
                          z
                            .record(
                              z.string(),
                              z.object({
                                frozen: z.optional(z.boolean()),
                                type: z.optional(z.string()),
                                value: z.unknown(),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Package variable (see integration documentation for more information)',
                            })
                        ),
                        data_stream: z.object({
                          dataset: z.string(),
                          elasticsearch: z.optional(
                            z.object({
                              dynamic_dataset: z.optional(z.boolean()),
                              dynamic_namespace: z.optional(z.boolean()),
                              privileges: z.optional(
                                z.object({
                                  indices: z.optional(z.array(z.string())),
                                })
                              ),
                            })
                          ),
                          type: z.string(),
                        }),
                        enabled: z.boolean(),
                        id: z.optional(z.string()),
                        keep_enabled: z.optional(z.boolean()),
                        release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                        vars: z.optional(
                          z
                            .record(
                              z.string(),
                              z.object({
                                frozen: z.optional(z.boolean()),
                                type: z.optional(z.string()),
                                value: z.unknown(),
                              })
                            )
                            .register(z.globalRegistry, {
                              description:
                                'Package variable (see integration documentation for more information)',
                            })
                        ),
                      })
                    ),
                    type: z.string(),
                    vars: z.optional(
                      z
                        .record(
                          z.string(),
                          z.object({
                            frozen: z.optional(z.boolean()),
                            type: z.optional(z.string()),
                            value: z.unknown(),
                          })
                        )
                        .register(z.globalRegistry, {
                          description:
                            'Package variable (see integration documentation for more information)',
                        })
                    ),
                  })
                ),
                z
                  .record(
                    z.string(),
                    z.object({
                      enabled: z.optional(
                        z.boolean().register(z.globalRegistry, {
                          description:
                            'Enable or disable that input. Defaults to `true` (enabled).',
                        })
                      ),
                      streams: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              enabled: z.optional(
                                z.boolean().register(z.globalRegistry, {
                                  description:
                                    'Enable or disable that stream. Defaults to `true` (enabled).',
                                })
                              ),
                              vars: z.optional(
                                z
                                  .record(
                                    z.string(),
                                    z.union([
                                      z.boolean(),
                                      z.string(),
                                      z.number(),
                                      z.array(z.string()),
                                      z.array(z.number()),
                                      z.object({
                                        id: z.string(),
                                        isSecretRef: z.boolean(),
                                      }),
                                      z.null(),
                                    ])
                                  )
                                  .register(z.globalRegistry, {
                                    description:
                                      'Input/stream level variable. Refer to the integration documentation for more information.',
                                  })
                              ),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Input streams. Refer to the integration documentation to know which streams are available.',
                          })
                      ),
                      vars: z.optional(
                        z
                          .record(
                            z.string(),
                            z.union([
                              z.boolean(),
                              z.string(),
                              z.number(),
                              z.array(z.string()),
                              z.array(z.number()),
                              z.object({
                                id: z.string(),
                                isSecretRef: z.boolean(),
                              }),
                              z.null(),
                            ])
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Input/stream level variable. Refer to the integration documentation for more information.',
                          })
                      ),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Package policy inputs. Refer to the integration documentation to know which inputs are available.',
                  }),
              ]),
              is_managed: z.optional(z.boolean()),
              name: z.string().register(z.globalRegistry, {
                description: 'Unique name for the package policy.',
              }),
              namespace: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
                })
              ),
              output_id: z.optional(z.union([z.string(), z.null()])),
              overrides: z.optional(
                z.union([
                  z.object({
                    inputs: z.optional(z.record(z.string(), z.unknown())),
                  }),
                  z.null(),
                ])
              ),
              package: z.optional(
                z.object({
                  experimental_data_stream_features: z.optional(
                    z.array(
                      z.object({
                        data_stream: z.string(),
                        features: z.object({
                          doc_value_only_numeric: z.optional(z.boolean()),
                          doc_value_only_other: z.optional(z.boolean()),
                          synthetic_source: z.optional(z.boolean()),
                          tsdb: z.optional(z.boolean()),
                        }),
                      })
                    )
                  ),
                  fips_compatible: z.optional(z.boolean()),
                  name: z.string().register(z.globalRegistry, {
                    description: 'Package name',
                  }),
                  requires_root: z.optional(z.boolean()),
                  title: z.optional(z.string()),
                  version: z.string().register(z.globalRegistry, {
                    description: 'Package version',
                  }),
                })
              ),
              policy_id: z.optional(z.union([z.string(), z.null()])),
              policy_ids: z.optional(
                z.array(
                  z.string().register(z.globalRegistry, {
                    description:
                      'IDs of the agent policies which that package policy will be added to.',
                  })
                )
              ),
              revision: z.number().register(z.globalRegistry, {
                description: 'Package policy revision.',
              }),
              secret_references: z.optional(
                z.array(
                  z.object({
                    id: z.string(),
                  })
                )
              ),
              spaceIds: z.optional(z.array(z.string())),
              supports_agentless: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              supports_cloud_connector: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              updated_at: z.string(),
              updated_by: z.string(),
              vars: z.optional(
                z.union([
                  z
                    .record(
                      z.string(),
                      z.object({
                        frozen: z.optional(z.boolean()),
                        type: z.optional(z.string()),
                        value: z.unknown(),
                      })
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Package variable (see integration documentation for more information)',
                    }),
                  z
                    .record(
                      z.string(),
                      z.union([
                        z.boolean(),
                        z.string(),
                        z.number(),
                        z.array(z.string()),
                        z.array(z.number()),
                        z.object({
                          id: z.string(),
                          isSecretRef: z.boolean(),
                        }),
                        z.null(),
                      ])
                    )
                    .register(z.globalRegistry, {
                      description:
                        'Input/stream level variable. Refer to the integration documentation for more information.',
                    }),
                ])
              ),
              version: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'Package policy ES version.',
                })
              ),
            }),
            z.object({
              additional_datastreams_permissions: z.optional(
                z.union([z.array(z.string()), z.null()])
              ),
              cloud_connector_id: z.optional(z.union([z.string(), z.null()])),
              created_at: z.optional(z.string()),
              created_by: z.optional(z.string()),
              description: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'Package policy description',
                })
              ),
              elasticsearch: z.optional(
                z.object({
                  privileges: z.optional(
                    z.object({
                      cluster: z.optional(z.array(z.string())),
                    })
                  ),
                })
              ),
              enabled: z.boolean(),
              errors: z.optional(
                z.array(
                  z.object({
                    key: z.optional(z.string()),
                    message: z.string(),
                  })
                )
              ),
              force: z.optional(z.boolean()),
              id: z.optional(z.string()),
              inputs: z.array(
                z.object({
                  compiled_input: z.unknown(),
                  config: z.optional(
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      })
                  ),
                  enabled: z.boolean(),
                  id: z.optional(z.string()),
                  keep_enabled: z.optional(z.boolean()),
                  policy_template: z.optional(z.string()),
                  streams: z.array(
                    z.object({
                      compiled_stream: z.unknown(),
                      config: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              frozen: z.optional(z.boolean()),
                              type: z.optional(z.string()),
                              value: z.unknown(),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Package variable (see integration documentation for more information)',
                          })
                      ),
                      data_stream: z.object({
                        dataset: z.string(),
                        elasticsearch: z.optional(
                          z.object({
                            dynamic_dataset: z.optional(z.boolean()),
                            dynamic_namespace: z.optional(z.boolean()),
                            privileges: z.optional(
                              z.object({
                                indices: z.optional(z.array(z.string())),
                              })
                            ),
                          })
                        ),
                        type: z.string(),
                      }),
                      enabled: z.boolean(),
                      id: z.optional(z.string()),
                      keep_enabled: z.optional(z.boolean()),
                      release: z.optional(z.enum(['ga', 'beta', 'experimental'])),
                      vars: z.optional(
                        z
                          .record(
                            z.string(),
                            z.object({
                              frozen: z.optional(z.boolean()),
                              type: z.optional(z.string()),
                              value: z.unknown(),
                            })
                          )
                          .register(z.globalRegistry, {
                            description:
                              'Package variable (see integration documentation for more information)',
                          })
                      ),
                    })
                  ),
                  type: z.string(),
                  vars: z.optional(
                    z
                      .record(
                        z.string(),
                        z.object({
                          frozen: z.optional(z.boolean()),
                          type: z.optional(z.string()),
                          value: z.unknown(),
                        })
                      )
                      .register(z.globalRegistry, {
                        description:
                          'Package variable (see integration documentation for more information)',
                      })
                  ),
                })
              ),
              is_managed: z.optional(z.boolean()),
              missingVars: z.optional(z.array(z.string())),
              name: z.string().register(z.globalRegistry, {
                description: 'Unique name for the package policy.',
              }),
              namespace: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    "The package policy namespace. Leave blank to inherit the agent policy's namespace.",
                })
              ),
              output_id: z.optional(z.union([z.string(), z.null()])),
              overrides: z.optional(
                z.union([
                  z.object({
                    inputs: z.optional(z.record(z.string(), z.unknown())),
                  }),
                  z.null(),
                ])
              ),
              package: z.optional(
                z.object({
                  experimental_data_stream_features: z.optional(
                    z.array(
                      z.object({
                        data_stream: z.string(),
                        features: z.object({
                          doc_value_only_numeric: z.optional(z.boolean()),
                          doc_value_only_other: z.optional(z.boolean()),
                          synthetic_source: z.optional(z.boolean()),
                          tsdb: z.optional(z.boolean()),
                        }),
                      })
                    )
                  ),
                  fips_compatible: z.optional(z.boolean()),
                  name: z.string().register(z.globalRegistry, {
                    description: 'Package name',
                  }),
                  requires_root: z.optional(z.boolean()),
                  title: z.optional(z.string()),
                  version: z.string().register(z.globalRegistry, {
                    description: 'Package version',
                  }),
                })
              ),
              policy_id: z.optional(z.union([z.string(), z.null()])),
              policy_ids: z.optional(
                z.array(
                  z.string().register(z.globalRegistry, {
                    description:
                      'IDs of the agent policies which that package policy will be added to.',
                  })
                )
              ),
              revision: z.optional(z.number()),
              secret_references: z.optional(
                z.array(
                  z.object({
                    id: z.string(),
                  })
                )
              ),
              supports_agentless: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              supports_cloud_connector: z
                .optional(z.union([z.boolean().default(false), z.null()]))
                .default(false),
              updated_at: z.optional(z.string()),
              updated_by: z.optional(z.string()),
              vars: z.optional(
                z
                  .record(
                    z.string(),
                    z.object({
                      frozen: z.optional(z.boolean()),
                      type: z.optional(z.string()),
                      value: z.unknown(),
                    })
                  )
                  .register(z.globalRegistry, {
                    description:
                      'Package variable (see integration documentation for more information)',
                  })
              ),
              version: z.optional(
                z.string().register(z.globalRegistry, {
                  description: 'Package policy ES version.',
                })
              ),
            }),
          ])
        )
      ),
      hasErrors: z.boolean(),
      name: z.optional(z.string()),
      statusCode: z.optional(z.number()),
    })
  )
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_proxies_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_proxies_response = z
  .object({
    items: z.array(
      z.object({
        certificate: z.optional(z.union([z.string(), z.null()])),
        certificate_authorities: z.optional(z.union([z.string(), z.null()])),
        certificate_key: z.optional(z.union([z.string(), z.null()])),
        id: z.string(),
        is_preconfigured: z.optional(z.boolean()).default(false),
        name: z.string(),
        proxy_headers: z.optional(
          z.union([z.record(z.string(), z.union([z.string(), z.boolean(), z.number()])), z.null()])
        ),
        url: z.string(),
      })
    ),
    page: z.number(),
    perPage: z.number(),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_proxies_request = z.object({
  body: z.optional(
    z.object({
      certificate: z.optional(z.union([z.string(), z.null()])),
      certificate_authorities: z.optional(z.union([z.string(), z.null()])),
      certificate_key: z.optional(z.union([z.string(), z.null()])),
      id: z.optional(z.string()),
      is_preconfigured: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_headers: z.optional(
        z.union([z.record(z.string(), z.union([z.string(), z.boolean(), z.number()])), z.null()])
      ),
      url: z.string(),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_proxies_response = z
  .object({
    item: z.object({
      certificate: z.optional(z.union([z.string(), z.null()])),
      certificate_authorities: z.optional(z.union([z.string(), z.null()])),
      certificate_key: z.optional(z.union([z.string(), z.null()])),
      id: z.string(),
      is_preconfigured: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_headers: z.optional(
        z.union([z.record(z.string(), z.union([z.string(), z.boolean(), z.number()])), z.null()])
      ),
      url: z.string(),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_fleet_proxies_itemid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    itemId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const delete_fleet_proxies_itemid_response = z
  .object({
    id: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_proxies_itemid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    itemId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_proxies_itemid_response = z
  .object({
    item: z.object({
      certificate: z.optional(z.union([z.string(), z.null()])),
      certificate_authorities: z.optional(z.union([z.string(), z.null()])),
      certificate_key: z.optional(z.union([z.string(), z.null()])),
      id: z.string(),
      is_preconfigured: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_headers: z.optional(
        z.union([z.record(z.string(), z.union([z.string(), z.boolean(), z.number()])), z.null()])
      ),
      url: z.string(),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_proxies_itemid_request = z.object({
  body: z.optional(
    z.object({
      certificate: z.union([z.string(), z.null()]),
      certificate_authorities: z.union([z.string(), z.null()]),
      certificate_key: z.union([z.string(), z.null()]),
      name: z.optional(z.string()),
      proxy_headers: z.optional(
        z.union([z.record(z.string(), z.union([z.string(), z.boolean(), z.number()])), z.null()])
      ),
      url: z.optional(z.string()),
    })
  ),
  path: z.object({
    itemId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_proxies_itemid_response = z
  .object({
    item: z.object({
      certificate: z.optional(z.union([z.string(), z.null()])),
      certificate_authorities: z.optional(z.union([z.string(), z.null()])),
      certificate_key: z.optional(z.union([z.string(), z.null()])),
      id: z.string(),
      is_preconfigured: z.optional(z.boolean()).default(false),
      name: z.string(),
      proxy_headers: z.optional(
        z.union([z.record(z.string(), z.union([z.string(), z.boolean(), z.number()])), z.null()])
      ),
      url: z.string(),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_remote_synced_integrations_outputid_remote_status_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    outputId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_remote_synced_integrations_outputid_remote_status_response = z
  .object({
    custom_assets: z.optional(
      z.record(
        z.string(),
        z.object({
          error: z.optional(z.string()),
          is_deleted: z.optional(z.boolean()),
          name: z.string(),
          package_name: z.string(),
          package_version: z.string(),
          sync_status: z.enum(['completed', 'synchronizing', 'failed', 'warning']),
          type: z.string(),
          warning: z.optional(
            z.object({
              message: z.optional(z.string()),
              title: z.string(),
            })
          ),
        })
      )
    ),
    error: z.optional(z.string()),
    integrations: z.array(
      z.object({
        error: z.optional(z.string()),
        id: z.optional(z.string()),
        install_status: z.object({
          main: z.string(),
          remote: z.optional(z.string()),
        }),
        package_name: z.optional(z.string()),
        package_version: z.optional(z.string()),
        sync_status: z.enum(['completed', 'synchronizing', 'failed', 'warning']),
        updated_at: z.optional(z.string()),
        warning: z.optional(
          z.object({
            message: z.optional(z.string()),
            title: z.string(),
          })
        ),
      })
    ),
    warning: z.optional(
      z.object({
        message: z.optional(z.string()),
        title: z.string(),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_remote_synced_integrations_status_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_remote_synced_integrations_status_response = z
  .object({
    custom_assets: z.optional(
      z.record(
        z.string(),
        z.object({
          error: z.optional(z.string()),
          is_deleted: z.optional(z.boolean()),
          name: z.string(),
          package_name: z.string(),
          package_version: z.string(),
          sync_status: z.enum(['completed', 'synchronizing', 'failed', 'warning']),
          type: z.string(),
          warning: z.optional(
            z.object({
              message: z.optional(z.string()),
              title: z.string(),
            })
          ),
        })
      )
    ),
    error: z.optional(z.string()),
    integrations: z.array(
      z.object({
        error: z.optional(z.string()),
        id: z.optional(z.string()),
        install_status: z.object({
          main: z.string(),
          remote: z.optional(z.string()),
        }),
        package_name: z.optional(z.string()),
        package_version: z.optional(z.string()),
        sync_status: z.enum(['completed', 'synchronizing', 'failed', 'warning']),
        updated_at: z.optional(z.string()),
        warning: z.optional(
          z.object({
            message: z.optional(z.string()),
            title: z.string(),
          })
        ),
      })
    ),
    warning: z.optional(
      z.object({
        message: z.optional(z.string()),
        title: z.string(),
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_service_tokens_request = z.object({
  body: z.optional(
    z.union([
      z.object({
        remote: z.optional(z.boolean()).default(false),
      }),
      z.null(),
    ])
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const post_fleet_service_tokens_response = z
  .object({
    name: z.string(),
    value: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_settings_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_settings_response = z
  .object({
    item: z.object({
      action_secret_storage_requirements_met: z.optional(z.boolean()),
      delete_unenrolled_agents: z.optional(
        z.object({
          enabled: z.boolean(),
          is_preconfigured: z.boolean(),
        })
      ),
      has_seen_add_data_notice: z.optional(z.boolean()),
      id: z.optional(z.string()),
      ilm_migration_status: z.optional(
        z.object({
          logs: z.optional(z.enum(['success'])),
          metrics: z.optional(z.enum(['success'])),
          synthetics: z.optional(z.enum(['success'])),
        })
      ),
      output_secret_storage_requirements_met: z.optional(z.boolean()),
      preconfigured_fields: z.optional(z.array(z.enum(['fleet_server_hosts']))),
      prerelease_integrations_enabled: z.optional(z.boolean()),
      secret_storage_requirements_met: z.optional(z.boolean()),
      use_space_awareness_migration_started_at: z.optional(z.union([z.string(), z.null()])),
      use_space_awareness_migration_status: z.optional(z.enum(['pending', 'success', 'error'])),
      version: z.optional(z.string()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_settings_request = z.object({
  body: z.optional(
    z.object({
      additional_yaml_config: z.optional(z.string()),
      delete_unenrolled_agents: z.optional(
        z.object({
          enabled: z.boolean(),
          is_preconfigured: z.boolean(),
        })
      ),
      has_seen_add_data_notice: z.optional(z.boolean()),
      kibana_ca_sha256: z.optional(z.string()),
      kibana_urls: z.optional(z.array(z.url())),
      prerelease_integrations_enabled: z.optional(z.boolean()),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_settings_response = z
  .object({
    item: z.object({
      action_secret_storage_requirements_met: z.optional(z.boolean()),
      delete_unenrolled_agents: z.optional(
        z.object({
          enabled: z.boolean(),
          is_preconfigured: z.boolean(),
        })
      ),
      has_seen_add_data_notice: z.optional(z.boolean()),
      id: z.optional(z.string()),
      ilm_migration_status: z.optional(
        z.object({
          logs: z.optional(z.enum(['success'])),
          metrics: z.optional(z.enum(['success'])),
          synthetics: z.optional(z.enum(['success'])),
        })
      ),
      output_secret_storage_requirements_met: z.optional(z.boolean()),
      preconfigured_fields: z.optional(z.array(z.enum(['fleet_server_hosts']))),
      prerelease_integrations_enabled: z.optional(z.boolean()),
      secret_storage_requirements_met: z.optional(z.boolean()),
      use_space_awareness_migration_started_at: z.optional(z.union([z.string(), z.null()])),
      use_space_awareness_migration_status: z.optional(z.enum(['pending', 'success', 'error'])),
      version: z.optional(z.string()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const post_fleet_setup_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * A summary of the result of Fleet's `setup` lifecycle. If `isInitialized` is true, Fleet is ready to accept agent enrollment. `nonFatalErrors` may include useful insight into non-blocking issues with Fleet setup.
 */
export const post_fleet_setup_response = z
  .object({
    isInitialized: z.boolean(),
    nonFatalErrors: z.array(
      z.object({
        message: z.string(),
        name: z.string(),
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      "A summary of the result of Fleet's `setup` lifecycle. If `isInitialized` is true, Fleet is ready to accept agent enrollment. `nonFatalErrors` may include useful insight into non-blocking issues with Fleet setup.",
  });

export const get_fleet_space_settings_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_space_settings_response = z
  .object({
    item: z.object({
      allowed_namespace_prefixes: z.array(z.string()),
      managed_by: z.optional(z.string()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const put_fleet_space_settings_request = z.object({
  body: z.optional(
    z.object({
      allowed_namespace_prefixes: z.optional(z.array(z.string())),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * OK: A successful request.
 */
export const put_fleet_space_settings_response = z
  .object({
    item: z.object({
      allowed_namespace_prefixes: z.array(z.string()),
      managed_by: z.optional(z.string()),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_uninstall_tokens_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      policyId: z.optional(
        z.string().max(50).register(z.globalRegistry, {
          description: 'Partial match filtering for policy IDs',
        })
      ),
      search: z.optional(z.string().max(50)),
      perPage: z.optional(
        z.number().gte(5).register(z.globalRegistry, {
          description: 'The number of items to return',
        })
      ),
      page: z.optional(z.number().gte(1)),
    })
  ),
});

/**
 * OK: A successful request.
 */
export const get_fleet_uninstall_tokens_response = z
  .object({
    items: z.array(
      z.object({
        created_at: z.string(),
        id: z.string(),
        namespaces: z.optional(z.array(z.string())),
        policy_id: z.string(),
        policy_name: z.optional(z.union([z.string(), z.null()])),
      })
    ),
    page: z.number(),
    perPage: z.number(),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const get_fleet_uninstall_tokens_uninstalltokenid_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    uninstallTokenId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * OK: A successful request.
 */
export const get_fleet_uninstall_tokens_uninstalltokenid_response = z
  .object({
    item: z.object({
      created_at: z.string(),
      id: z.string(),
      namespaces: z.optional(z.array(z.string())),
      policy_id: z.string(),
      policy_name: z.optional(z.union([z.string(), z.null()])),
      token: z.string(),
    }),
  })
  .register(z.globalRegistry, {
    description: 'OK: A successful request.',
  });

export const delete_list_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    id: security_lists_api_list_id,
    deleteReferences: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Determines whether exception items referencing this value list should be deleted.',
        })
      )
      .default(false),
    ignoreReferences: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Determines whether to delete value list without performing any additional checks of where this list may be utilized.',
        })
      )
      .default(false),
  }),
});

/**
 * Successful response
 */
export const delete_list_response = security_lists_api_list;

export const read_list_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    id: security_lists_api_list_id,
  }),
});

/**
 * Successful response
 */
export const read_list_response = security_lists_api_list;

export const patch_list_request = z.object({
  body: z
    .object({
      _version: z.optional(security_lists_api_list_version_id),
      description: z.optional(security_lists_api_list_description),
      id: security_lists_api_list_id,
      meta: z.optional(security_lists_api_list_metadata),
      name: z.optional(security_lists_api_list_name),
      version: z.optional(security_lists_api_list_version),
    })
    .register(z.globalRegistry, {
      description: "Value list's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const patch_list_response = security_lists_api_list;

export const create_list_request = z.object({
  body: z
    .object({
      description: security_lists_api_list_description,
      deserializer: z.optional(security_lists_api_list_deserializer),
      id: z.optional(security_lists_api_list_id),
      meta: z.optional(security_lists_api_list_metadata),
      name: security_lists_api_list_name,
      serializer: z.optional(security_lists_api_list_serializer),
      type: security_lists_api_list_type,
      version: z.optional(z.int().gte(1)).default(1),
    })
    .register(z.globalRegistry, {
      description: "Value list's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_list_response = security_lists_api_list;

export const update_list_request = z.object({
  body: z
    .object({
      _version: z.optional(security_lists_api_list_version_id),
      description: security_lists_api_list_description,
      id: security_lists_api_list_id,
      meta: z.optional(security_lists_api_list_metadata),
      name: security_lists_api_list_name,
      version: z.optional(security_lists_api_list_version),
    })
    .register(z.globalRegistry, {
      description: "Value list's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const update_list_response = security_lists_api_list;

export const find_lists_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The page number to return.',
        })
      ),
      per_page: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of value lists to return per page.',
        })
      ),
      sort_field: z.optional(
        z.string().min(1).register(z.globalRegistry, {
          description: 'Determines which field is used to sort the results.',
        })
      ),
      sort_order: z.optional(
        z.enum(['desc', 'asc']).register(z.globalRegistry, {
          description: 'Determines the sort order, which can be `desc` or `asc`',
        })
      ),
      cursor: z.optional(security_lists_api_find_lists_cursor),
      filter: z.optional(security_lists_api_find_lists_filter),
    })
  ),
});

/**
 * Successful response
 */
export const find_lists_response = z
  .object({
    cursor: security_lists_api_find_lists_cursor,
    data: z.array(security_lists_api_list),
    page: z.int().gte(0),
    per_page: z.int().gte(0),
    total: z.int().gte(0),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const delete_list_index_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const delete_list_index_response = z
  .object({
    acknowledged: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const read_list_index_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const read_list_index_response = z
  .object({
    list_index: z.boolean(),
    list_item_index: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const create_list_index_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_list_index_response = z
  .object({
    acknowledged: z.boolean(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const delete_list_item_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_lists_api_list_item_id),
      list_id: z.optional(security_lists_api_list_id),
      value: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The value used to evaluate exceptions. Required if `id` is not specified.',
        })
      ),
      refresh: z.optional(
        z.enum(['true', 'false', 'wait_for']).register(z.globalRegistry, {
          description: 'Determines when changes made by the request are made visible to search.',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const delete_list_item_response = z.union([
  security_lists_api_list_item,
  z.array(security_lists_api_list_item),
]);

export const read_list_item_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(security_lists_api_list_id),
      list_id: z.optional(security_lists_api_list_id),
      value: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The value used to evaluate exceptions. Required if `id` is not specified.',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const read_list_item_response = z.union([
  security_lists_api_list_item,
  z.array(security_lists_api_list_item),
]);

export const patch_list_item_request = z.object({
  body: z
    .object({
      _version: z.optional(security_lists_api_list_version_id),
      id: security_lists_api_list_item_id,
      meta: z.optional(security_lists_api_list_item_metadata),
      refresh: z.optional(
        z.enum(['true', 'false', 'wait_for']).register(z.globalRegistry, {
          description: 'Determines when changes made by the request are made visible to search.',
        })
      ),
      value: z.optional(security_lists_api_list_item_value),
    })
    .register(z.globalRegistry, {
      description: "Value list item's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const patch_list_item_response = security_lists_api_list_item;

export const create_list_item_request = z.object({
  body: z
    .object({
      id: z.optional(security_lists_api_list_item_id),
      list_id: security_lists_api_list_id,
      meta: z.optional(security_lists_api_list_item_metadata),
      refresh: z.optional(
        z.enum(['true', 'false', 'wait_for']).register(z.globalRegistry, {
          description: 'Determines when changes made by the request are made visible to search.',
        })
      ),
      value: security_lists_api_list_item_value,
    })
    .register(z.globalRegistry, {
      description: "Value list item's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const create_list_item_response = security_lists_api_list_item;

export const update_list_item_request = z.object({
  body: z
    .object({
      _version: z.optional(security_lists_api_list_version_id),
      id: security_lists_api_list_item_id,
      meta: z.optional(security_lists_api_list_item_metadata),
      value: security_lists_api_list_item_value,
    })
    .register(z.globalRegistry, {
      description: "Value list item's properties",
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const update_list_item_response = security_lists_api_list_item;

export const export_list_items_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    list_id: security_lists_api_list_id,
  }),
});

/**
 * A `.txt` file containing list items from the specified list
 */
export const export_list_items_response = z.string().register(z.globalRegistry, {
  description: 'A `.txt` file containing list items from the specified list',
});

export const find_list_items_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    list_id: security_lists_api_list_id,
    page: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The page number to return.',
      })
    ),
    per_page: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The number of list items to return per page.',
      })
    ),
    sort_field: z.optional(
      z.string().min(1).register(z.globalRegistry, {
        description: 'Determines which field is used to sort the results.',
      })
    ),
    sort_order: z.optional(
      z.enum(['desc', 'asc']).register(z.globalRegistry, {
        description: 'Determines the sort order, which can be `desc` or `asc`',
      })
    ),
    cursor: z.optional(security_lists_api_find_list_items_cursor),
    filter: z.optional(security_lists_api_find_list_items_filter),
  }),
});

/**
 * Successful response
 */
export const find_list_items_response = z
  .object({
    cursor: security_lists_api_find_list_items_cursor,
    data: z.array(security_lists_api_list_item),
    page: z.int().gte(0),
    per_page: z.int().gte(0),
    total: z.int().gte(0),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const import_list_items_request = z.object({
  body: z.object({
    file: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'A `.txt` or `.csv` file containing newline separated list items.',
      })
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      list_id: z.optional(security_lists_api_list_id),
      type: z.optional(security_lists_api_list_type),
      serializer: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Determines how uploaded list item values are parsed. By default, list items are parsed using these named regex groups:\n\n- `(?<value>.+)` - Single value item types, such as ip, long, date, keyword, and text.\n- `(?<gte>.+)-(?<lte>.+)|(?<value>.+)` - Range value item types, such as `date_range`, `ip_range`, `double_range`, `float_range`, `integer_range`, and `long_range`.\n',
        })
      ),
      deserializer: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Determines how retrieved list item values are presented. By default list items are presented using these Handelbar expressions:\n\n- `{{{value}}}` - Single value item types, such as `ip`, `long`, `date`, `keyword`, and `text`.\n- `{{{gte}}}-{{{lte}}}` - Range value item types, such as `ip_range`, `double_range`, `float_range`, `integer_range`, and `long_range`.\n- `{{{gte}}},{{{lte}}}` - Date range values.\n',
        })
      ),
      refresh: z.optional(
        z.enum(['true', 'false', 'wait_for']).register(z.globalRegistry, {
          description: 'Determines when changes made by the request are made visible to search.',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const import_list_items_response = security_lists_api_list;

export const read_list_privileges_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const read_list_privileges_response = z
  .object({
    is_authenticated: z.boolean(),
    listItems: security_lists_api_list_item_privileges,
    lists: security_lists_api_list_privileges,
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const delete_logstash_pipeline_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the pipeline.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const delete_logstash_pipeline_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call',
});

export const get_logstash_pipeline_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the pipeline.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const get_logstash_pipeline_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call',
  });

export const put_logstash_pipeline_request = z.object({
  body: z.optional(
    z.object({
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'A description of the pipeline.',
        })
      ),
      pipeline: z.string().register(z.globalRegistry, {
        description: 'A definition for the pipeline.',
      }),
      settings: z.optional(
        z.record(z.string(), z.unknown()).register(z.globalRegistry, {
          description:
            'Supported settings, represented as object keys, include the following:\n\n- `pipeline.workers`\n- `pipeline.batch.size`\n- `pipeline.batch.delay`\n- `pipeline.ecs_compatibility`\n- `pipeline.ordered`\n- `queue.type`\n- `queue.max_bytes`\n- `queue.checkpoint.writes`\n',
        })
      ),
    })
  ),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the pipeline. Pipeline ID must begin with a letter or underscore and can contain only letters, underscores, dashes, hyphens, and numbers.\n',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const put_logstash_pipeline_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call',
});

export const get_logstash_pipelines_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const get_logstash_pipelines_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call',
  });

export const post_maintenance_window_request = z.object({
  body: z.optional(
    z.object({
      enabled: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether the current maintenance window is enabled. Disabled maintenance windows do not suppress notifications.',
        })
      ),
      schedule: z.object({
        custom: z.object({
          duration: z.string().register(z.globalRegistry, {
            description:
              'The duration of the schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `h`, `m`, or `s` for hours, minutes, seconds. For example: `1d`, `5h`, `30m`, `5000s`.',
          }),
          recurring: z.optional(
            z.object({
              end: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The end date of a recurring schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-04-01T00:00:00.000Z`.',
                })
              ),
              every: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'The interval and frequency of a recurring schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `w`, `M`, or `y` for days, weeks, months, years. For example: `15d`, `2w`, `3m`, `1y`.',
                })
              ),
              occurrences: z.optional(
                z.number().gte(1).register(z.globalRegistry, {
                  description: 'The total number of recurrences of the schedule.',
                })
              ),
              onMonth: z.optional(
                z.array(z.number().gte(1).lte(12)).min(1).register(z.globalRegistry, {
                  description:
                    'The specific months for a recurring schedule. Valid values are 1-12.',
                })
              ),
              onMonthDay: z.optional(
                z.array(z.number().gte(1).lte(31)).min(1).register(z.globalRegistry, {
                  description:
                    'The specific days of the month for a recurring schedule. Valid values are 1-31.',
                })
              ),
              onWeekDay: z.optional(
                z.array(z.string()).min(1).register(z.globalRegistry, {
                  description:
                    'The specific days of the week (`[MO,TU,WE,TH,FR,SA,SU]`) or nth day of month (`[+1MO, -3FR, +2WE, -4SA, -5SU]`) for a recurring schedule.',
                })
              ),
            })
          ),
          start: z.string().register(z.globalRegistry, {
            description:
              'The start date and time of the schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-03-12T12:00:00.000Z`.',
          }),
          timezone: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'The timezone of the schedule. The default timezone is UTC.',
            })
          ),
        }),
      }),
      scope: z.optional(
        z.object({
          alerting: z.object({
            query: z.object({
              kql: z.string().register(z.globalRegistry, {
                description:
                  'A filter written in Kibana Query Language (KQL). Only alerts matching this query will be supressed by the maintenance window.',
              }),
            }),
          }),
        })
      ),
      title: z.string().register(z.globalRegistry, {
        description:
          'The name of the maintenance window. While this name does not have to be unique, a distinctive name can help you identify a specific maintenance window.',
      }),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_maintenance_window_response = z
  .object({
    created_at: z.string().register(z.globalRegistry, {
      description: 'The date and time when the maintenance window was created.',
    }),
    created_by: z.union([z.string(), z.null()]),
    enabled: z.boolean().register(z.globalRegistry, {
      description:
        'Whether the current maintenance window is enabled. Disabled maintenance windows do not suppress notifications.',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the maintenance window.',
    }),
    schedule: z.object({
      custom: z.object({
        duration: z.string().register(z.globalRegistry, {
          description:
            'The duration of the schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `h`, `m`, or `s` for hours, minutes, seconds. For example: `1d`, `5h`, `30m`, `5000s`.',
        }),
        recurring: z.optional(
          z.object({
            end: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The end date of a recurring schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-04-01T00:00:00.000Z`.',
              })
            ),
            every: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The interval and frequency of a recurring schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `w`, `M`, or `y` for days, weeks, months, years. For example: `15d`, `2w`, `3m`, `1y`.',
              })
            ),
            occurrences: z.optional(
              z.number().register(z.globalRegistry, {
                description: 'The total number of recurrences of the schedule.',
              })
            ),
            onMonth: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description: 'The specific months for a recurring schedule. Valid values are 1-12.',
              })
            ),
            onMonthDay: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description:
                  'The specific days of the month for a recurring schedule. Valid values are 1-31.',
              })
            ),
            onWeekDay: z.optional(
              z.array(z.string()).register(z.globalRegistry, {
                description:
                  'The specific days of the week (`[MO,TU,WE,TH,FR,SA,SU]`) or nth day of month (`[+1MO, -3FR, +2WE, -4SA, -5SU]`) for a recurring schedule.',
              })
            ),
          })
        ),
        start: z.string().register(z.globalRegistry, {
          description:
            'The start date and time of the schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-03-12T12:00:00.000Z`.',
        }),
        timezone: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'The timezone of the schedule. The default timezone is UTC.',
          })
        ),
      }),
    }),
    scope: z.optional(
      z.object({
        alerting: z.object({
          query: z.object({
            kql: z.string().register(z.globalRegistry, {
              description: 'A filter written in Kibana Query Language (KQL).',
            }),
          }),
        }),
      })
    ),
    status: z
      .enum(['running', 'upcoming', 'finished', 'archived', 'disabled'])
      .register(z.globalRegistry, {
        description: 'The current status of the maintenance window.',
      }),
    title: z.string().register(z.globalRegistry, {
      description: 'The name of the maintenance window.',
    }),
    updated_at: z.string().register(z.globalRegistry, {
      description: 'The date and time when the maintenance window was last updated.',
    }),
    updated_by: z.union([z.string(), z.null()]),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_maintenance_window_find_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      title: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The title of the maintenance window.',
        })
      ),
      created_by: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The user who created the maintenance window.',
        })
      ),
      status: z.optional(
        z.union([
          z.enum(['running', 'finished', 'upcoming', 'archived', 'disabled']),
          z.array(z.enum(['running', 'finished', 'upcoming', 'archived', 'disabled'])),
        ])
      ),
      page: z
        .optional(
          z.number().gte(1).lte(100).register(z.globalRegistry, {
            description: 'The page number to return.',
          })
        )
        .default(1),
      per_page: z
        .optional(
          z.number().gte(1).lte(100).register(z.globalRegistry, {
            description: 'The number of maintenance windows to return per page.',
          })
        )
        .default(10),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const get_maintenance_window_find_response = z
  .object({
    maintenanceWindows: z.array(
      z.object({
        created_at: z.string().register(z.globalRegistry, {
          description: 'The date and time when the maintenance window was created.',
        }),
        created_by: z.union([z.string(), z.null()]),
        enabled: z.boolean().register(z.globalRegistry, {
          description:
            'Whether the current maintenance window is enabled. Disabled maintenance windows do not suppress notifications.',
        }),
        id: z.string().register(z.globalRegistry, {
          description: 'The identifier for the maintenance window.',
        }),
        schedule: z.object({
          custom: z.object({
            duration: z.string().register(z.globalRegistry, {
              description:
                'The duration of the schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `h`, `m`, or `s` for hours, minutes, seconds. For example: `1d`, `5h`, `30m`, `5000s`.',
            }),
            recurring: z.optional(
              z.object({
                end: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The end date of a recurring schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-04-01T00:00:00.000Z`.',
                  })
                ),
                every: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The interval and frequency of a recurring schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `w`, `M`, or `y` for days, weeks, months, years. For example: `15d`, `2w`, `3m`, `1y`.',
                  })
                ),
                occurrences: z.optional(
                  z.number().register(z.globalRegistry, {
                    description: 'The total number of recurrences of the schedule.',
                  })
                ),
                onMonth: z.optional(
                  z.array(z.number()).register(z.globalRegistry, {
                    description:
                      'The specific months for a recurring schedule. Valid values are 1-12.',
                  })
                ),
                onMonthDay: z.optional(
                  z.array(z.number()).register(z.globalRegistry, {
                    description:
                      'The specific days of the month for a recurring schedule. Valid values are 1-31.',
                  })
                ),
                onWeekDay: z.optional(
                  z.array(z.string()).register(z.globalRegistry, {
                    description:
                      'The specific days of the week (`[MO,TU,WE,TH,FR,SA,SU]`) or nth day of month (`[+1MO, -3FR, +2WE, -4SA, -5SU]`) for a recurring schedule.',
                  })
                ),
              })
            ),
            start: z.string().register(z.globalRegistry, {
              description:
                'The start date and time of the schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-03-12T12:00:00.000Z`.',
            }),
            timezone: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The timezone of the schedule. The default timezone is UTC.',
              })
            ),
          }),
        }),
        scope: z.optional(
          z.object({
            alerting: z.object({
              query: z.object({
                kql: z.string().register(z.globalRegistry, {
                  description: 'A filter written in Kibana Query Language (KQL).',
                }),
              }),
            }),
          })
        ),
        status: z
          .enum(['running', 'upcoming', 'finished', 'archived', 'disabled'])
          .register(z.globalRegistry, {
            description: 'The current status of the maintenance window.',
          }),
        title: z.string().register(z.globalRegistry, {
          description: 'The name of the maintenance window.',
        }),
        updated_at: z.string().register(z.globalRegistry, {
          description: 'The date and time when the maintenance window was last updated.',
        }),
        updated_by: z.union([z.string(), z.null()]),
      })
    ),
    page: z.number(),
    per_page: z.number(),
    total: z.number(),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const delete_maintenance_window_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the maintenance window to be deleted.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const delete_maintenance_window_id_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const get_maintenance_window_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the maintenance window.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_maintenance_window_id_response = z
  .object({
    created_at: z.string().register(z.globalRegistry, {
      description: 'The date and time when the maintenance window was created.',
    }),
    created_by: z.union([z.string(), z.null()]),
    enabled: z.boolean().register(z.globalRegistry, {
      description:
        'Whether the current maintenance window is enabled. Disabled maintenance windows do not suppress notifications.',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the maintenance window.',
    }),
    schedule: z.object({
      custom: z.object({
        duration: z.string().register(z.globalRegistry, {
          description:
            'The duration of the schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `h`, `m`, or `s` for hours, minutes, seconds. For example: `1d`, `5h`, `30m`, `5000s`.',
        }),
        recurring: z.optional(
          z.object({
            end: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The end date of a recurring schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-04-01T00:00:00.000Z`.',
              })
            ),
            every: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The interval and frequency of a recurring schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `w`, `M`, or `y` for days, weeks, months, years. For example: `15d`, `2w`, `3m`, `1y`.',
              })
            ),
            occurrences: z.optional(
              z.number().register(z.globalRegistry, {
                description: 'The total number of recurrences of the schedule.',
              })
            ),
            onMonth: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description: 'The specific months for a recurring schedule. Valid values are 1-12.',
              })
            ),
            onMonthDay: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description:
                  'The specific days of the month for a recurring schedule. Valid values are 1-31.',
              })
            ),
            onWeekDay: z.optional(
              z.array(z.string()).register(z.globalRegistry, {
                description:
                  'The specific days of the week (`[MO,TU,WE,TH,FR,SA,SU]`) or nth day of month (`[+1MO, -3FR, +2WE, -4SA, -5SU]`) for a recurring schedule.',
              })
            ),
          })
        ),
        start: z.string().register(z.globalRegistry, {
          description:
            'The start date and time of the schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-03-12T12:00:00.000Z`.',
        }),
        timezone: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'The timezone of the schedule. The default timezone is UTC.',
          })
        ),
      }),
    }),
    scope: z.optional(
      z.object({
        alerting: z.object({
          query: z.object({
            kql: z.string().register(z.globalRegistry, {
              description: 'A filter written in Kibana Query Language (KQL).',
            }),
          }),
        }),
      })
    ),
    status: z
      .enum(['running', 'upcoming', 'finished', 'archived', 'disabled'])
      .register(z.globalRegistry, {
        description: 'The current status of the maintenance window.',
      }),
    title: z.string().register(z.globalRegistry, {
      description: 'The name of the maintenance window.',
    }),
    updated_at: z.string().register(z.globalRegistry, {
      description: 'The date and time when the maintenance window was last updated.',
    }),
    updated_by: z.union([z.string(), z.null()]),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const patch_maintenance_window_id_request = z.object({
  body: z.optional(
    z.object({
      enabled: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether the current maintenance window is enabled. Disabled maintenance windows do not suppress notifications.',
        })
      ),
      schedule: z.optional(
        z.object({
          custom: z.object({
            duration: z.string().register(z.globalRegistry, {
              description:
                'The duration of the schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `h`, `m`, or `s` for hours, minutes, seconds. For example: `1d`, `5h`, `30m`, `5000s`.',
            }),
            recurring: z.optional(
              z.object({
                end: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The end date of a recurring schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-04-01T00:00:00.000Z`.',
                  })
                ),
                every: z.optional(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The interval and frequency of a recurring schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `w`, `M`, or `y` for days, weeks, months, years. For example: `15d`, `2w`, `3m`, `1y`.',
                  })
                ),
                occurrences: z.optional(
                  z.number().gte(1).register(z.globalRegistry, {
                    description: 'The total number of recurrences of the schedule.',
                  })
                ),
                onMonth: z.optional(
                  z.array(z.number().gte(1).lte(12)).min(1).register(z.globalRegistry, {
                    description:
                      'The specific months for a recurring schedule. Valid values are 1-12.',
                  })
                ),
                onMonthDay: z.optional(
                  z.array(z.number().gte(1).lte(31)).min(1).register(z.globalRegistry, {
                    description:
                      'The specific days of the month for a recurring schedule. Valid values are 1-31.',
                  })
                ),
                onWeekDay: z.optional(
                  z.array(z.string()).min(1).register(z.globalRegistry, {
                    description:
                      'The specific days of the week (`[MO,TU,WE,TH,FR,SA,SU]`) or nth day of month (`[+1MO, -3FR, +2WE, -4SA, -5SU]`) for a recurring schedule.',
                  })
                ),
              })
            ),
            start: z.string().register(z.globalRegistry, {
              description:
                'The start date and time of the schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-03-12T12:00:00.000Z`.',
            }),
            timezone: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The timezone of the schedule. The default timezone is UTC.',
              })
            ),
          }),
        })
      ),
      scope: z.optional(
        z.object({
          alerting: z.object({
            query: z.object({
              kql: z.string().register(z.globalRegistry, {
                description:
                  'A filter written in Kibana Query Language (KQL). Only alerts matching this query will be supressed by the maintenance window.',
              }),
            }),
          }),
        })
      ),
      title: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The name of the maintenance window. While this name does not have to be unique, a distinctive name can help you identify a specific maintenance window.',
        })
      ),
    })
  ),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const patch_maintenance_window_id_response = z
  .object({
    created_at: z.string().register(z.globalRegistry, {
      description: 'The date and time when the maintenance window was created.',
    }),
    created_by: z.union([z.string(), z.null()]),
    enabled: z.boolean().register(z.globalRegistry, {
      description:
        'Whether the current maintenance window is enabled. Disabled maintenance windows do not suppress notifications.',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the maintenance window.',
    }),
    schedule: z.object({
      custom: z.object({
        duration: z.string().register(z.globalRegistry, {
          description:
            'The duration of the schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `h`, `m`, or `s` for hours, minutes, seconds. For example: `1d`, `5h`, `30m`, `5000s`.',
        }),
        recurring: z.optional(
          z.object({
            end: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The end date of a recurring schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-04-01T00:00:00.000Z`.',
              })
            ),
            every: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The interval and frequency of a recurring schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `w`, `M`, or `y` for days, weeks, months, years. For example: `15d`, `2w`, `3m`, `1y`.',
              })
            ),
            occurrences: z.optional(
              z.number().register(z.globalRegistry, {
                description: 'The total number of recurrences of the schedule.',
              })
            ),
            onMonth: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description: 'The specific months for a recurring schedule. Valid values are 1-12.',
              })
            ),
            onMonthDay: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description:
                  'The specific days of the month for a recurring schedule. Valid values are 1-31.',
              })
            ),
            onWeekDay: z.optional(
              z.array(z.string()).register(z.globalRegistry, {
                description:
                  'The specific days of the week (`[MO,TU,WE,TH,FR,SA,SU]`) or nth day of month (`[+1MO, -3FR, +2WE, -4SA, -5SU]`) for a recurring schedule.',
              })
            ),
          })
        ),
        start: z.string().register(z.globalRegistry, {
          description:
            'The start date and time of the schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-03-12T12:00:00.000Z`.',
        }),
        timezone: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'The timezone of the schedule. The default timezone is UTC.',
          })
        ),
      }),
    }),
    scope: z.optional(
      z.object({
        alerting: z.object({
          query: z.object({
            kql: z.string().register(z.globalRegistry, {
              description: 'A filter written in Kibana Query Language (KQL).',
            }),
          }),
        }),
      })
    ),
    status: z
      .enum(['running', 'upcoming', 'finished', 'archived', 'disabled'])
      .register(z.globalRegistry, {
        description: 'The current status of the maintenance window.',
      }),
    title: z.string().register(z.globalRegistry, {
      description: 'The name of the maintenance window.',
    }),
    updated_at: z.string().register(z.globalRegistry, {
      description: 'The date and time when the maintenance window was last updated.',
    }),
    updated_by: z.union([z.string(), z.null()]),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const post_maintenance_window_id_archive_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the maintenance window to be archived.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_maintenance_window_id_archive_response = z
  .object({
    created_at: z.string().register(z.globalRegistry, {
      description: 'The date and time when the maintenance window was created.',
    }),
    created_by: z.union([z.string(), z.null()]),
    enabled: z.boolean().register(z.globalRegistry, {
      description:
        'Whether the current maintenance window is enabled. Disabled maintenance windows do not suppress notifications.',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the maintenance window.',
    }),
    schedule: z.object({
      custom: z.object({
        duration: z.string().register(z.globalRegistry, {
          description:
            'The duration of the schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `h`, `m`, or `s` for hours, minutes, seconds. For example: `1d`, `5h`, `30m`, `5000s`.',
        }),
        recurring: z.optional(
          z.object({
            end: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The end date of a recurring schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-04-01T00:00:00.000Z`.',
              })
            ),
            every: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The interval and frequency of a recurring schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `w`, `M`, or `y` for days, weeks, months, years. For example: `15d`, `2w`, `3m`, `1y`.',
              })
            ),
            occurrences: z.optional(
              z.number().register(z.globalRegistry, {
                description: 'The total number of recurrences of the schedule.',
              })
            ),
            onMonth: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description: 'The specific months for a recurring schedule. Valid values are 1-12.',
              })
            ),
            onMonthDay: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description:
                  'The specific days of the month for a recurring schedule. Valid values are 1-31.',
              })
            ),
            onWeekDay: z.optional(
              z.array(z.string()).register(z.globalRegistry, {
                description:
                  'The specific days of the week (`[MO,TU,WE,TH,FR,SA,SU]`) or nth day of month (`[+1MO, -3FR, +2WE, -4SA, -5SU]`) for a recurring schedule.',
              })
            ),
          })
        ),
        start: z.string().register(z.globalRegistry, {
          description:
            'The start date and time of the schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-03-12T12:00:00.000Z`.',
        }),
        timezone: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'The timezone of the schedule. The default timezone is UTC.',
          })
        ),
      }),
    }),
    scope: z.optional(
      z.object({
        alerting: z.object({
          query: z.object({
            kql: z.string().register(z.globalRegistry, {
              description: 'A filter written in Kibana Query Language (KQL).',
            }),
          }),
        }),
      })
    ),
    status: z
      .enum(['running', 'upcoming', 'finished', 'archived', 'disabled'])
      .register(z.globalRegistry, {
        description: 'The current status of the maintenance window.',
      }),
    title: z.string().register(z.globalRegistry, {
      description: 'The name of the maintenance window.',
    }),
    updated_at: z.string().register(z.globalRegistry, {
      description: 'The date and time when the maintenance window was last updated.',
    }),
    updated_by: z.union([z.string(), z.null()]),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const post_maintenance_window_id_unarchive_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the maintenance window to be unarchived.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_maintenance_window_id_unarchive_response = z
  .object({
    created_at: z.string().register(z.globalRegistry, {
      description: 'The date and time when the maintenance window was created.',
    }),
    created_by: z.union([z.string(), z.null()]),
    enabled: z.boolean().register(z.globalRegistry, {
      description:
        'Whether the current maintenance window is enabled. Disabled maintenance windows do not suppress notifications.',
    }),
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the maintenance window.',
    }),
    schedule: z.object({
      custom: z.object({
        duration: z.string().register(z.globalRegistry, {
          description:
            'The duration of the schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `h`, `m`, or `s` for hours, minutes, seconds. For example: `1d`, `5h`, `30m`, `5000s`.',
        }),
        recurring: z.optional(
          z.object({
            end: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The end date of a recurring schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-04-01T00:00:00.000Z`.',
              })
            ),
            every: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'The interval and frequency of a recurring schedule. It allows values in `<integer><unit>` format. `<unit>` is one of `d`, `w`, `M`, or `y` for days, weeks, months, years. For example: `15d`, `2w`, `3m`, `1y`.',
              })
            ),
            occurrences: z.optional(
              z.number().register(z.globalRegistry, {
                description: 'The total number of recurrences of the schedule.',
              })
            ),
            onMonth: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description: 'The specific months for a recurring schedule. Valid values are 1-12.',
              })
            ),
            onMonthDay: z.optional(
              z.array(z.number()).register(z.globalRegistry, {
                description:
                  'The specific days of the month for a recurring schedule. Valid values are 1-31.',
              })
            ),
            onWeekDay: z.optional(
              z.array(z.string()).register(z.globalRegistry, {
                description:
                  'The specific days of the week (`[MO,TU,WE,TH,FR,SA,SU]`) or nth day of month (`[+1MO, -3FR, +2WE, -4SA, -5SU]`) for a recurring schedule.',
              })
            ),
          })
        ),
        start: z.string().register(z.globalRegistry, {
          description:
            'The start date and time of the schedule, provided in ISO 8601 format and set to the UTC timezone. For example: `2025-03-12T12:00:00.000Z`.',
        }),
        timezone: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'The timezone of the schedule. The default timezone is UTC.',
          })
        ),
      }),
    }),
    scope: z.optional(
      z.object({
        alerting: z.object({
          query: z.object({
            kql: z.string().register(z.globalRegistry, {
              description: 'A filter written in Kibana Query Language (KQL).',
            }),
          }),
        }),
      })
    ),
    status: z
      .enum(['running', 'upcoming', 'finished', 'archived', 'disabled'])
      .register(z.globalRegistry, {
        description: 'The current status of the maintenance window.',
      }),
    title: z.string().register(z.globalRegistry, {
      description: 'The name of the maintenance window.',
    }),
    updated_at: z.string().register(z.globalRegistry, {
      description: 'The date and time when the maintenance window was last updated.',
    }),
    updated_by: z.union([z.string(), z.null()]),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const ml_sync_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      simulate: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'When true, simulates the synchronization by returning only the list of actions that would be performed.',
        })
      ),
    })
  ),
});

/**
 * Indicates a successful call
 */
export const ml_sync_response = machine_learning_ap_is_ml_sync200_response;

export const delete_note_request = z.object({
  body: z.union([
    z.object({
      noteId: z.string(),
    }),
    z.null(),
    z.object({
      noteIds: z.union([z.array(z.string()), z.null()]),
    }),
  ]),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const get_notes_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      documentIds: z.optional(security_timeline_api_document_ids),
      savedObjectIds: z.optional(security_timeline_api_saved_object_ids),
      page: z.optional(z.union([z.string(), z.null()])),
      perPage: z.optional(z.union([z.string(), z.null()])),
      search: z.optional(z.union([z.string(), z.null()])),
      sortField: z.optional(z.union([z.string(), z.null()])),
      sortOrder: z.optional(z.union([z.string(), z.null()])),
      filter: z.optional(z.union([z.string(), z.null()])),
      createdByFilter: z.optional(z.union([z.string(), z.null()])),
      associatedFilter: z.optional(security_timeline_api_associated_filter_type),
    })
  ),
});

/**
 * Indicates the requested notes were returned.
 */
export const get_notes_response = security_timeline_api_get_notes_result;

export const persist_note_route_request = z.object({
  body: z
    .object({
      note: security_timeline_api_bare_note,
      noteId: z.optional(z.union([z.string(), z.null()])),
      version: z.optional(z.union([z.string(), z.null()])),
    })
    .register(z.globalRegistry, {
      description: 'The note to add or update, along with additional metadata.',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates the note was successfully created.
 */
export const persist_note_route_response = security_timeline_api_response_note;

export const observability_ai_assistant_chat_complete_request = z.object({
  body: z.optional(
    z.object({
      actions: z.optional(z.array(observability_ai_assistant_api_function)),
      connectorId: z.string().register(z.globalRegistry, {
        description: 'A unique identifier for the connector.',
      }),
      conversationId: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A unique identifier for the conversation if you are continuing an existing conversation.',
        })
      ),
      disableFunctions: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Flag indicating whether all function calls should be disabled for the conversation. If true, no calls to functions will be made.',
        })
      ),
      instructions: z.optional(
        z.array(observability_ai_assistant_api_instruction).register(z.globalRegistry, {
          description:
            'An array of instruction objects, which can be either simple strings or detailed objects.',
        })
      ),
      messages: z.array(observability_ai_assistant_api_message).register(z.globalRegistry, {
        description: 'An array of message objects containing the conversation history.',
      }),
      persist: z.boolean().register(z.globalRegistry, {
        description:
          'Indicates whether the conversation should be saved to storage. If true, the conversation will be saved and will be available in Kibana.',
      }),
      title: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'A title for the conversation.',
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const observability_ai_assistant_chat_complete_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const osquery_find_live_queries_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      kuery: z.optional(security_osquery_api_kuery_or_undefined),
      page: z.optional(security_osquery_api_page_or_undefined),
      pageSize: z.optional(security_osquery_api_page_size_or_undefined),
      sort: z.optional(security_osquery_api_sort_or_undefined),
      sortOrder: z.optional(security_osquery_api_sort_order_or_undefined),
    })
  ),
});

/**
 * OK
 */
export const osquery_find_live_queries_response = security_osquery_api_find_live_query_response;

export const osquery_create_live_query_request = z.object({
  body: security_osquery_api_create_live_query_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const osquery_create_live_query_response = security_osquery_api_create_live_query_response;

export const osquery_get_live_query_details_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The ID of the live query result you want to retrieve.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const osquery_get_live_query_details_response =
  security_osquery_api_find_live_query_details_response;

export const osquery_get_live_query_results_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The ID of the live query result you want to retrieve.',
    }),
    actionId: z.string().register(z.globalRegistry, {
      description: 'The ID of the query action that generated the live query results.',
    }),
  }),
  query: z.optional(
    z.object({
      kuery: z.optional(security_osquery_api_kuery_or_undefined),
      page: z.optional(security_osquery_api_page_or_undefined),
      pageSize: z.optional(security_osquery_api_page_size_or_undefined),
      sort: z.optional(security_osquery_api_sort_or_undefined),
      sortOrder: z.optional(security_osquery_api_sort_order_or_undefined),
    })
  ),
});

/**
 * OK
 */
export const osquery_get_live_query_results_response =
  security_osquery_api_get_live_query_results_response;

export const osquery_find_packs_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(security_osquery_api_page_or_undefined),
      pageSize: z.optional(security_osquery_api_page_size_or_undefined),
      sort: z.optional(security_osquery_api_sort_or_undefined),
      sortOrder: z.optional(security_osquery_api_sort_order_or_undefined),
    })
  ),
});

/**
 * OK
 */
export const osquery_find_packs_response = security_osquery_api_find_packs_response;

export const osquery_create_packs_request = z.object({
  body: security_osquery_api_create_packs_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const osquery_create_packs_response = security_osquery_api_create_packs_response;

export const osquery_delete_packs_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_osquery_api_pack_id,
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const osquery_delete_packs_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'OK',
  });

export const osquery_get_packs_details_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_osquery_api_pack_id,
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const osquery_get_packs_details_response = security_osquery_api_find_pack_response;

export const osquery_update_packs_request = z.object({
  body: security_osquery_api_update_packs_request_body,
  path: z.object({
    id: security_osquery_api_pack_id,
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const osquery_update_packs_response = security_osquery_api_update_packs_response;

export const osquery_find_saved_queries_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(security_osquery_api_page_or_undefined),
      pageSize: z.optional(security_osquery_api_page_size_or_undefined),
      sort: z.optional(security_osquery_api_sort_or_undefined),
      sortOrder: z.optional(security_osquery_api_sort_order_or_undefined),
    })
  ),
});

/**
 * OK
 */
export const osquery_find_saved_queries_response = security_osquery_api_find_saved_query_response;

export const osquery_create_saved_query_request = z.object({
  body: security_osquery_api_create_saved_query_request_body,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const osquery_create_saved_query_response = security_osquery_api_create_saved_query_response;

export const osquery_delete_saved_query_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_osquery_api_saved_query_id,
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const osquery_delete_saved_query_response = security_osquery_api_default_success_response;

export const osquery_get_saved_query_details_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_osquery_api_saved_query_id,
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const osquery_get_saved_query_details_response =
  security_osquery_api_find_saved_query_detail_response;

export const osquery_update_saved_query_request = z.object({
  body: security_osquery_api_update_saved_query_request_body,
  path: z.object({
    id: security_osquery_api_saved_query_id,
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const osquery_update_saved_query_response = security_osquery_api_update_saved_query_response;

export const persist_pinned_event_route_request = z.object({
  body: z
    .object({
      eventId: z.string().register(z.globalRegistry, {
        description: 'The `_id` of the associated event for this pinned event.',
      }),
      pinnedEventId: z.optional(z.union([z.string(), z.null()])),
      timelineId: z.string().register(z.globalRegistry, {
        description:
          'The `savedObjectId` of the timeline that you want this pinned event unpinned from.',
      }),
    })
    .register(z.globalRegistry, {
      description: 'The pinned event to add or unpin, along with additional metadata.',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates the event was successfully pinned to or unpinned from the Timeline.
 */
export const persist_pinned_event_route_response =
  security_timeline_api_persist_pinned_event_response;

export const clean_up_risk_engine_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const clean_up_risk_engine_response = z
  .object({
    cleanup_successful: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const configure_risk_engine_saved_object_request = z.object({
  body: z.object({
    enable_reset_to_zero: z.optional(z.boolean()),
    exclude_alert_statuses: z.optional(z.array(z.string())),
    exclude_alert_tags: z.optional(z.array(z.string())),
    filters: z.optional(
      z.array(
        z.object({
          entity_types: z.array(z.enum(['host', 'user', 'service'])),
          filter: z.string().register(z.globalRegistry, {
            description: 'KQL filter string',
          }),
        })
      )
    ),
    range: z.optional(
      z.object({
        end: z.optional(z.string()),
        start: z.optional(z.string()),
      })
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const configure_risk_engine_saved_object_response = z
  .object({
    risk_engine_saved_object_configured: z.optional(z.boolean()),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const schedule_risk_engine_now_request = z.object({
  body: z.optional(z.unknown()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const schedule_risk_engine_now_response =
  security_entity_analytics_api_risk_engine_schedule_now_response;

export const bulk_create_saved_objects_request = z.object({
  body: z.array(z.record(z.string(), z.unknown())),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      overwrite: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'When true, overwrites the document with the same identifier.',
        })
      ),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const bulk_create_saved_objects_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const bulk_delete_saved_objects_request = z.object({
  body: z.array(z.record(z.string(), z.unknown())),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      force: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'When true, force delete objects that exist in multiple namespaces. Note that the option applies to the whole request. Use the delete object API to specify per-object deletion behavior. TIP: Use this if you attempted to delete objects and received an HTTP 400 error with the following message: "Unable to delete saved object that exists in multiple namespaces, use the force option to delete it anyway". WARNING: When you bulk delete objects that exist in multiple namespaces, the API also deletes legacy url aliases that reference the object. These requests are batched to minimise the impact but they can place a heavy load on Kibana. Make sure you limit the number of objects that exist in multiple namespaces in a single bulk delete operation.\n',
        })
      ),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call. NOTE: This HTTP response code indicates that the bulk operation succeeded. Errors pertaining to individual objects will be returned in the response body.
 *
 */
export const bulk_delete_saved_objects_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'Indicates a successful call. NOTE: This HTTP response code indicates that the bulk operation succeeded. Errors pertaining to individual objects will be returned in the response body.\n',
  });

export const bulk_get_saved_objects_request = z.object({
  body: z.array(z.record(z.string(), z.unknown())),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const bulk_get_saved_objects_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const bulk_resolve_saved_objects_request = z.object({
  body: z.array(z.record(z.string(), z.unknown())),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call. NOTE: This HTTP response code indicates that the bulk operation succeeded.  Errors pertaining to individual objects will be returned in the response body.
 *
 */
export const bulk_resolve_saved_objects_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'Indicates a successful call. NOTE: This HTTP response code indicates that the bulk operation succeeded.  Errors pertaining to individual objects will be returned in the response body. \n',
  });

export const bulk_update_saved_objects_request = z.object({
  body: z.array(z.record(z.string(), z.unknown())),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call. NOTE: This HTTP response code indicates that the bulk operation succeeded. Errors pertaining to individual objects will be returned in the response body.
 *
 */
export const bulk_update_saved_objects_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'Indicates a successful call. NOTE: This HTTP response code indicates that the bulk operation succeeded. Errors pertaining to individual objects will be returned in the response body. \n',
  });

export const post_saved_objects_export_request = z.object({
  body: z.optional(
    z.object({
      excludeExportDetails: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description: 'Do not add export details entry at the end of the stream.',
          })
        )
        .default(false),
      hasReference: z.optional(
        z.union([
          z.object({
            id: z.string(),
            type: z.string(),
          }),
          z.array(
            z.object({
              id: z.string(),
              type: z.string(),
            })
          ),
        ])
      ),
      includeReferencesDeep: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description: 'Includes all of the referenced objects in the exported objects.',
          })
        )
        .default(false),
      objects: z.optional(
        z
          .array(
            z.object({
              id: z.string(),
              type: z.string(),
            })
          )
          .max(10000)
          .register(z.globalRegistry, {
            description:
              'A list of objects to export. NOTE: this optional parameter cannot be combined with the `types` option',
          })
      ),
      search: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Search for documents to export using the Elasticsearch Simple Query String syntax.',
        })
      ),
      type: z.optional(z.union([z.string(), z.array(z.string())])),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const find_saved_objects_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    aggs: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'An aggregation structure, serialized as a string. The field format is similar to filter, meaning that to use a saved object type attribute in the aggregation, the `savedObjectType.attributes.title: "myTitle"` format must be used. For root fields, the syntax is `savedObjectType.rootField`. NOTE: As objects change in Kibana, the results on each page of the response also change. Use the find API for traditional paginated results, but avoid using it to export large amounts of data.\n',
      })
    ),
    default_search_operator: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The default operator to use for the `simple_query_string`.',
      })
    ),
    fields: z.optional(z.union([z.string(), z.array(z.unknown())])),
    filter: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The filter is a KQL string with the caveat that if you filter with an attribute from your saved object type, it should look like that: `savedObjectType.attributes.title: "myTitle"`. However, if you use a root attribute of a saved object such as `updated_at`, you will have to define your filter like that: `savedObjectType.updated_at > 2018-12-22`.\n',
      })
    ),
    has_no_reference: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description:
          'Filters to objects that do not have a relationship with the type and identifier combination.',
      })
    ),
    has_no_reference_operator: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The operator to use for the `has_no_reference` parameter. Either `OR` or `AND`. Defaults to `OR`.',
      })
    ),
    has_reference: z.optional(
      z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description:
          'Filters to objects that have a relationship with the type and ID combination.',
      })
    ),
    has_reference_operator: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The operator to use for the `has_reference` parameter. Either `OR` or `AND`. Defaults to `OR`.',
      })
    ),
    page: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The page of objects to return.',
      })
    ),
    per_page: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The number of objects to return per page.',
      })
    ),
    search: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'An Elasticsearch `simple_query_string` query that filters the objects in the response.',
      })
    ),
    search_fields: z.optional(z.union([z.string(), z.array(z.unknown())])),
    sort_field: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Sorts the response. Includes "root" and "type" fields. "root" fields exist for all saved objects, such as "updated_at". "type" fields are specific to an object type, such as fields returned in the attributes key of the response. When a single type is defined in the type parameter, the "root" and "type" fields are allowed, and validity checks are made in that order. When multiple types are defined in the type parameter, only "root" fields are allowed.\n',
      })
    ),
    type: z.union([z.string(), z.array(z.unknown())]),
  }),
});

/**
 * Indicates a successful call.
 */
export const find_saved_objects_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const post_saved_objects_import_request = z.object({
  body: z.optional(
    z.object({
      file: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description:
          'A file exported using the export API. Changing the contents of the exported file in any way before importing it can cause errors, crashes or data loss. NOTE: The `savedObjects.maxImportExportSize` configuration setting limits the number of saved objects which may be included in this file. Similarly, the `savedObjects.maxImportPayloadBytes` setting limits the overall size of the file that can be imported.',
      }),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      overwrite: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Overwrites saved objects when they already exist. When used, potential conflict errors are automatically resolved by overwriting the destination object. NOTE: This option cannot be used with the `createNewCopies` option.',
          })
        )
        .default(false),
      createNewCopies: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Creates copies of saved objects, regenerates each object ID, and resets the origin. When used, potential conflict errors are avoided. NOTE: This option cannot be used with the `overwrite` and `compatibilityMode` options.',
          })
        )
        .default(false),
      compatibilityMode: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Applies various adjustments to the saved objects that are being imported to maintain compatibility between different Kibana versions. Use this option only if you encounter issues with imported saved objects. NOTE: This option cannot be used with the `createNewCopies` option.',
          })
        )
        .default(false),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const post_saved_objects_import_response = z
  .object({
    errors: z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
      description:
        'Indicates the import was unsuccessful and specifies the objects that failed to import.\n\nNOTE: One object may result in multiple errors, which requires separate steps to resolve. For instance, a `missing_references` error and conflict error.',
    }),
    success: z.boolean().register(z.globalRegistry, {
      description:
        'Indicates when the import was successfully completed. When set to false, some objects may not have been created. For additional information, refer to the `errors` and `successResults` properties.',
    }),
    successCount: z.number().register(z.globalRegistry, {
      description: 'Indicates the number of successfully imported records.',
    }),
    successResults: z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
      description:
        'Indicates the objects that are successfully imported, with any metadata if applicable.\n\nNOTE: Objects are created only when all resolvable errors are addressed, including conflicts and missing references. If objects are created as new copies, each entry in the `successResults` array includes a `destinationId` attribute.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const resolve_import_errors_request = z.object({
  body: z.object({
    file: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The same file given to the import API.',
      })
    ),
    retries: z
      .array(
        z.object({
          destinationId: z.optional(
            z.string().register(z.globalRegistry, {
              description:
                'Specifies the destination ID that the imported object should have, if different from the current ID.',
            })
          ),
          id: z.string().register(z.globalRegistry, {
            description: 'The saved object ID.',
          }),
          ignoreMissingReferences: z.optional(
            z.boolean().register(z.globalRegistry, {
              description:
                'When set to `true`, ignores missing reference errors. When set to `false`, does nothing.',
            })
          ),
          overwrite: z.optional(
            z.boolean().register(z.globalRegistry, {
              description:
                'When set to `true`, the source object overwrites the conflicting destination object. When set to `false`, does nothing.',
            })
          ),
          replaceReferences: z.optional(
            z
              .array(
                z.object({
                  from: z.optional(z.string()),
                  to: z.optional(z.string()),
                  type: z.optional(z.string()),
                })
              )
              .register(z.globalRegistry, {
                description:
                  'A list of `type`, `from`, and `to` used to change the object references.',
              })
          ),
          type: z.string().register(z.globalRegistry, {
            description: 'The saved object type.',
          }),
        })
      )
      .register(z.globalRegistry, {
        description:
          'The retry operations, which can specify how to resolve different types of errors.',
      }),
  }),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      compatibilityMode: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Applies various adjustments to the saved objects that are being imported to maintain compatibility between different Kibana versions. When enabled during the initial import, also enable when resolving import errors. This option cannot be used with the `createNewCopies` option.\n',
        })
      ),
      createNewCopies: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Creates copies of the saved objects, regenerates each object ID, and resets the origin. When enabled during the initial import, also enable when resolving import errors.\n',
        })
      ),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const resolve_import_errors_response = z
  .object({
    errors: z.optional(
      z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description:
          'Specifies the objects that failed to resolve.\n\nNOTE: One object can result in multiple errors, which requires separate steps to resolve. For instance, a `missing_references` error and a `conflict` error.\n',
      })
    ),
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Indicates a successful import. When set to `false`, some objects may not have been created. For additional information, refer to the `errors` and `successResults` properties.\n',
      })
    ),
    successCount: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'Indicates the number of successfully resolved records.\n',
      })
    ),
    successResults: z.optional(
      z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description:
          'Indicates the objects that are successfully imported, with any metadata if applicable.\n\nNOTE: Objects are only created when all resolvable errors are addressed, including conflict and missing references.\n',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const create_saved_object_request = z.object({
  body: z.object({
    attributes: saved_objects_attributes,
    initialNamespaces: z.optional(saved_objects_initial_namespaces),
    references: z.optional(saved_objects_references),
  }),
  path: z.object({
    type: z.string().register(z.globalRegistry, {
      description:
        'Valid options include `visualization`, `dashboard`, `search`, `index-pattern`, `config`.',
    }),
  }),
  query: z.optional(
    z.object({
      overwrite: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If true, overwrites the document with the same identifier.',
        })
      ),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const create_saved_object_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const get_saved_object_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the saved object.',
    }),
    type: z.string().register(z.globalRegistry, {
      description:
        'Valid options include `visualization`, `dashboard`, `search`, `index-pattern`, `config`.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_saved_object_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const create_saved_object_id_request = z.object({
  body: z.object({
    attributes: saved_objects_attributes,
    initialNamespaces: z.optional(saved_objects_initial_namespaces),
    references: z.optional(saved_objects_initial_namespaces),
  }),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the saved object.',
    }),
    type: z.string().register(z.globalRegistry, {
      description:
        'Valid options include `visualization`, `dashboard`, `search`, `index-pattern`, `config`.',
    }),
  }),
  query: z.optional(
    z.object({
      overwrite: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If true, overwrites the document with the same identifier.',
        })
      ),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const create_saved_object_id_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const update_saved_object_request = z.object({
  body: z.record(z.string(), z.unknown()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the saved object.',
    }),
    type: z.string().register(z.globalRegistry, {
      description:
        'Valid options include `visualization`, `dashboard`, `search`, `index-pattern`, `config`.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const update_saved_object_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const resolve_saved_object_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'An identifier for the saved object.',
    }),
    type: z.string().register(z.globalRegistry, {
      description:
        'Valid options include `visualization`, `dashboard`, `search`, `index-pattern`, `config`.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const resolve_saved_object_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call.',
  });

export const perform_anonymization_fields_bulk_action_request = z.object({
  body: z.optional(
    z.object({
      create: z.optional(
        z
          .array(security_ai_assistant_api_anonymization_field_create_props)
          .register(z.globalRegistry, {
            description: 'Array of anonymization fields to create.',
          })
      ),
      delete: z.optional(
        z
          .object({
            ids: z.optional(
              z.array(z.string()).min(1).register(z.globalRegistry, {
                description: 'Array of IDs to apply the action to.',
              })
            ),
            query: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'Query to filter the bulk action.',
              })
            ),
          })
          .register(z.globalRegistry, {
            description:
              'Object containing the query to filter anonymization fields and/or an array of anonymization field IDs to delete.',
          })
      ),
      update: z.optional(
        z
          .array(security_ai_assistant_api_anonymization_field_update_props)
          .register(z.globalRegistry, {
            description: 'Array of anonymization fields to update.',
          })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const perform_anonymization_fields_bulk_action_response =
  security_ai_assistant_api_anonymization_fields_bulk_crud_action_response;

export const find_anonymization_fields_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      fields: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'Fields to return',
        })
      ),
      filter: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Search query',
        })
      ),
      sort_field: z.optional(security_ai_assistant_api_find_anonymization_fields_sort_field),
      sort_order: z.optional(security_ai_assistant_api_sort_order),
      page: z
        .optional(
          z.int().gte(1).register(z.globalRegistry, {
            description: 'Page number',
          })
        )
        .default(1),
      per_page: z
        .optional(
          z.int().gte(0).register(z.globalRegistry, {
            description: 'AnonymizationFields per page',
          })
        )
        .default(20),
      all_data: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If true, additionally fetch all anonymization fields, otherwise fetch only the provided page',
        })
      ),
    })
  ),
});

/**
 * Successful response
 */
export const find_anonymization_fields_response = z
  .object({
    aggregations: z.optional(
      z.object({
        field_status: z.optional(
          z.object({
            buckets: z.optional(
              z.object({
                allowed: z.optional(
                  z.object({
                    doc_count: z.optional(z.int()).default(0),
                  })
                ),
                anonymized: z.optional(
                  z.object({
                    doc_count: z.optional(z.int()).default(0),
                  })
                ),
                denied: z.optional(
                  z.object({
                    doc_count: z.optional(z.int()).default(0),
                  })
                ),
              })
            ),
          })
        ),
      })
    ),
    all: z.optional(z.array(security_ai_assistant_api_anonymization_field_response)),
    data: z.array(security_ai_assistant_api_anonymization_field_response),
    page: z.int(),
    perPage: z.int(),
    total: z.int(),
  })
  .register(z.globalRegistry, {
    description: 'Successful response',
  });

export const chat_complete_request = z.object({
  body: security_ai_assistant_api_chat_complete_props,
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      content_references_disabled: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description: 'If true, the response will not include content references.',
          })
        )
        .default(false),
    })
  ),
});

/**
 * Indicates a successful model response call.
 */
export const chat_complete_response = z.string().register(z.globalRegistry, {
  description: 'Indicates a successful model response call.',
});

export const delete_all_conversations_request = z.object({
  body: z.optional(
    z.object({
      excludedIds: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'Optional list of conversation IDs to delete.',
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call. The conversations were deleted successfully.
 */
export const delete_all_conversations_response = z
  .object({
    failures: z.optional(z.array(z.string())),
    success: z.optional(z.boolean()),
    totalDeleted: z.optional(z.number()),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call. The conversations were deleted successfully.',
  });

export const create_conversation_request = z.object({
  body: security_ai_assistant_api_conversation_create_props,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call. The conversation was created successfully.
 */
export const create_conversation_response = security_ai_assistant_api_conversation_response;

export const find_conversations_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      fields: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description:
            'A list of fields to include in the response. If omitted, all fields are returned.',
        })
      ),
      filter: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A search query to filter the conversations. Can match against titles, messages, or other conversation attributes.',
        })
      ),
      sort_field: z.optional(security_ai_assistant_api_find_conversations_sort_field),
      sort_order: z.optional(security_ai_assistant_api_sort_order),
      page: z
        .optional(
          z.int().gte(1).register(z.globalRegistry, {
            description: 'The page number of the results to retrieve. Default is 1.',
          })
        )
        .default(1),
      per_page: z
        .optional(
          z.int().gte(0).register(z.globalRegistry, {
            description: 'The number of conversations to return per page. Default is 20.',
          })
        )
        .default(20),
      is_owner: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Whether to return conversations that the current user owns. If true, only conversations owned by the user are returned.',
          })
        )
        .default(false),
    })
  ),
});

/**
 * Successful response, returns a paginated list of conversations matching the specified criteria.
 */
export const find_conversations_response = z
  .object({
    data: z.array(security_ai_assistant_api_conversation_response).register(z.globalRegistry, {
      description: 'A list of conversations.',
    }),
    page: z.int().register(z.globalRegistry, {
      description: 'The current page of the results.',
    }),
    perPage: z.int().register(z.globalRegistry, {
      description: 'The number of results returned per page.',
    }),
    total: z.int().register(z.globalRegistry, {
      description: 'The total number of conversations matching the filter criteria.',
    }),
  })
  .register(z.globalRegistry, {
    description:
      'Successful response, returns a paginated list of conversations matching the specified criteria.',
  });

export const delete_conversation_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_ai_assistant_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call. The conversation was deleted successfully.
 */
export const delete_conversation_response = security_ai_assistant_api_conversation_response;

export const read_conversation_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_ai_assistant_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call. The conversation details are returned.
 */
export const read_conversation_response = security_ai_assistant_api_conversation_response;

export const update_conversation_request = z.object({
  body: security_ai_assistant_api_conversation_update_props,
  path: z.object({
    id: security_ai_assistant_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call. The conversation was updated successfully.
 */
export const update_conversation_response = security_ai_assistant_api_conversation_response;

export const get_knowledge_base_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_knowledge_base_response =
  security_ai_assistant_api_knowledge_base_read_response200;

export const post_knowledge_base_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      modelId: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'ELSER modelId to use when setting up the Knowledge Base. If not provided, a default model will be used.',
        })
      ),
      ignoreSecurityLabs: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Indicates whether we should or should not install Security Labs docs when setting up the Knowledge Base. Defaults to `false`.',
          })
        )
        .default(false),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const post_knowledge_base_response = security_ai_assistant_api_knowledge_base_response;

export const read_knowledge_base_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    resource: z.string().register(z.globalRegistry, {
      description: 'The KnowledgeBase `resource` value.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const read_knowledge_base_response =
  security_ai_assistant_api_knowledge_base_read_response200;

export const create_knowledge_base_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    resource: z.string().register(z.globalRegistry, {
      description: 'The KnowledgeBase `resource` value.',
    }),
  }),
  query: z.optional(
    z.object({
      modelId: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'ELSER modelId to use when setting up the Knowledge Base. If not provided, a default model will be used.',
        })
      ),
      ignoreSecurityLabs: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Indicates whether we should or should not install Security Labs docs when setting up the Knowledge Base. Defaults to `false`.',
          })
        )
        .default(false),
    })
  ),
});

/**
 * Indicates a successful call.
 */
export const create_knowledge_base_response = security_ai_assistant_api_knowledge_base_response;

export const create_knowledge_base_entry_request = z.object({
  body: security_ai_assistant_api_knowledge_base_entry_create_props,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful request returning Knowledge Base Entries
 */
export const create_knowledge_base_entry_response =
  security_ai_assistant_api_knowledge_base_entry_response;

export const perform_knowledge_base_entry_bulk_action_request = z.object({
  body: z.optional(
    z.object({
      create: z.optional(
        z
          .array(security_ai_assistant_api_knowledge_base_entry_create_props)
          .register(z.globalRegistry, {
            description: 'List of Knowledge Base Entries to create.',
          })
      ),
      delete: z.optional(
        z.object({
          ids: z.optional(
            z.array(z.string()).min(1).register(z.globalRegistry, {
              description: 'Array of Knowledge Base Entry IDs.',
            })
          ),
          query: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Query to filter Knowledge Base Entries.',
            })
          ),
        })
      ),
      update: z.optional(
        z
          .array(security_ai_assistant_api_knowledge_base_entry_update_props)
          .register(z.globalRegistry, {
            description: 'List of Knowledge Base Entries to update.',
          })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful bulk operation request
 */
export const perform_knowledge_base_entry_bulk_action_response =
  security_ai_assistant_api_knowledge_base_entry_bulk_crud_action_response;

export const find_knowledge_base_entries_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      fields: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description:
            'A list of fields to include in the response. If not provided, all fields will be included.',
        })
      ),
      filter: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Search query to filter Knowledge Base Entries by specific criteria.',
        })
      ),
      sort_field: z.optional(security_ai_assistant_api_find_knowledge_base_entries_sort_field),
      sort_order: z.optional(security_ai_assistant_api_sort_order),
      page: z
        .optional(
          z.int().gte(1).register(z.globalRegistry, {
            description: 'Page number for paginated results. Defaults to 1.',
          })
        )
        .default(1),
      per_page: z
        .optional(
          z.int().gte(0).register(z.globalRegistry, {
            description: 'Number of Knowledge Base Entries to return per page. Defaults to 20.',
          })
        )
        .default(20),
    })
  ),
});

/**
 * Successful response containing the paginated Knowledge Base Entries.
 */
export const find_knowledge_base_entries_response = z
  .object({
    data: z
      .array(security_ai_assistant_api_knowledge_base_entry_response)
      .register(z.globalRegistry, {
        description: 'The list of Knowledge Base Entries for the current page.',
      }),
    page: z.int().register(z.globalRegistry, {
      description: 'The current page number.',
    }),
    perPage: z.int().register(z.globalRegistry, {
      description: 'The number of Knowledge Base Entries returned per page.',
    }),
    total: z.int().register(z.globalRegistry, {
      description: 'The total number of Knowledge Base Entries available.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Successful response containing the paginated Knowledge Base Entries.',
  });

export const delete_knowledge_base_entry_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_ai_assistant_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Successful request returning the `id` of the deleted Knowledge Base Entry.
 */
export const delete_knowledge_base_entry_response =
  security_ai_assistant_api_delete_response_fields;

export const read_knowledge_base_entry_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: security_ai_assistant_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Successful request returning the requested Knowledge Base Entry.
 */
export const read_knowledge_base_entry_response =
  security_ai_assistant_api_knowledge_base_entry_response;

export const update_knowledge_base_entry_request = z.object({
  body: security_ai_assistant_api_knowledge_base_entry_update_route_props,
  path: z.object({
    id: security_ai_assistant_api_non_empty_string,
  }),
  query: z.optional(z.never()),
});

/**
 * Successful request returning the updated Knowledge Base Entry.
 */
export const update_knowledge_base_entry_response =
  security_ai_assistant_api_knowledge_base_entry_response;

export const perform_prompts_bulk_action_request = z.object({
  body: z.optional(
    z.object({
      create: z.optional(
        z.array(security_ai_assistant_api_prompt_create_props).register(z.globalRegistry, {
          description: 'List of prompts to be created.',
        })
      ),
      delete: z.optional(
        z
          .object({
            ids: z.optional(
              z.array(z.string()).min(1).register(z.globalRegistry, {
                description: 'Array of IDs to apply the action to.',
              })
            ),
            query: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'Query to filter the bulk action.',
              })
            ),
          })
          .register(z.globalRegistry, {
            description: 'Criteria for deleting prompts in bulk.',
          })
      ),
      update: z.optional(
        z.array(security_ai_assistant_api_prompt_update_props).register(z.globalRegistry, {
          description: 'List of prompts to be updated.',
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call with the results of the bulk action.
 */
export const perform_prompts_bulk_action_response =
  security_ai_assistant_api_prompts_bulk_crud_action_response;

export const find_prompts_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      fields: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'List of specific fields to include in each returned prompt.',
        })
      ),
      filter: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Search query string to filter prompts by matching fields.',
        })
      ),
      sort_field: z.optional(security_ai_assistant_api_find_prompts_sort_field),
      sort_order: z.optional(security_ai_assistant_api_sort_order),
      page: z
        .optional(
          z.int().gte(1).register(z.globalRegistry, {
            description: 'Page number for pagination.',
          })
        )
        .default(1),
      per_page: z
        .optional(
          z.int().gte(0).register(z.globalRegistry, {
            description: 'Number of prompts per page.',
          })
        )
        .default(20),
    })
  ),
});

/**
 * Successful response containing a list of prompts.
 */
export const find_prompts_response = z
  .object({
    data: z.array(security_ai_assistant_api_prompt_response).register(z.globalRegistry, {
      description:
        'The list of prompts returned based on the search query, sorting, and pagination.',
    }),
    page: z.int().register(z.globalRegistry, {
      description: 'Current page number.',
    }),
    perPage: z.int().register(z.globalRegistry, {
      description: 'Number of prompts per page.',
    }),
    total: z.int().register(z.globalRegistry, {
      description: 'Total number of prompts matching the query.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Successful response containing a list of prompts.',
  });

export const get_security_role_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      replaceDeprecatedPrivileges: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If `true` and the response contains any privileges that are associated with deprecated features, they are omitted in favor of details about the appropriate replacement feature privileges.',
        })
      ),
    })
  ),
});

export const post_security_role_query_request = z.object({
  body: z.optional(
    z.object({
      filters: z.optional(
        z.object({
          showReservedRoles: z.optional(z.boolean()),
        })
      ),
      from: z.optional(z.number()),
      query: z.optional(z.string()),
      size: z.optional(z.number()),
      sort: z.optional(
        z.object({
          direction: z.enum(['asc', 'desc']),
          field: z.string(),
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const delete_security_role_name_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string().min(1),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const delete_security_role_name_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const get_security_role_name_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string().min(1).register(z.globalRegistry, {
      description: 'The role name.',
    }),
  }),
  query: z.optional(
    z.object({
      replaceDeprecatedPrivileges: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If `true` and the response contains any privileges that are associated with deprecated features, they are omitted in favor of details about the appropriate replacement feature privileges.',
        })
      ),
    })
  ),
});

export const put_security_role_name_request = z.object({
  body: z.optional(
    z.object({
      description: z.optional(
        z.string().max(2048).register(z.globalRegistry, {
          description: 'A description for the role.',
        })
      ),
      elasticsearch: z.object({
        cluster: z.optional(
          z.array(
            z.string().register(z.globalRegistry, {
              description:
                'Cluster privileges that define the cluster level actions that users can perform.',
            })
          )
        ),
        indices: z.optional(
          z.array(
            z.object({
              allow_restricted_indices: z.optional(
                z.boolean().register(z.globalRegistry, {
                  description:
                    'Restricted indices are a special category of indices that are used internally to store configuration data and should not be directly accessed. Only internal system roles should normally grant privileges over the restricted indices. Toggling this flag is very strongly discouraged because it could effectively grant unrestricted operations on critical data, making the entire system unstable or leaking sensitive information. If for administrative purposes you need to create a role with privileges covering restricted indices, however, you can set this property to true. In that case, the names field covers the restricted indices too.',
                })
              ),
              field_security: z.optional(
                z.record(
                  z.string(),
                  z.array(
                    z.string().register(z.globalRegistry, {
                      description: 'The document fields that the role members have read access to.',
                    })
                  )
                )
              ),
              names: z
                .array(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The data streams, indices, and aliases to which the permissions in this entry apply. It supports wildcards (*).',
                  })
                )
                .min(1),
              privileges: z
                .array(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The index level privileges that the role members have for the data streams and indices.',
                  })
                )
                .min(1),
              query: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'A search query that defines the documents the role members have read access to. A document within the specified data streams and indices must match this query in order for it to be accessible by the role members.',
                })
              ),
            })
          )
        ),
        remote_cluster: z.optional(
          z.array(
            z.object({
              clusters: z
                .array(
                  z.string().register(z.globalRegistry, {
                    description:
                      'A list of remote cluster aliases. It supports literal strings as well as wildcards and regular expressions.',
                  })
                )
                .min(1),
              privileges: z
                .array(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The cluster level privileges for the remote cluster. The allowed values are a subset of the cluster privileges.',
                  })
                )
                .min(1),
            })
          )
        ),
        remote_indices: z.optional(
          z.array(
            z.object({
              allow_restricted_indices: z.optional(
                z.boolean().register(z.globalRegistry, {
                  description:
                    'Restricted indices are a special category of indices that are used internally to store configuration data and should not be directly accessed. Only internal system roles should normally grant privileges over the restricted indices. Toggling this flag is very strongly discouraged because it could effectively grant unrestricted operations on critical data, making the entire system unstable or leaking sensitive information. If for administrative purposes you need to create a role with privileges covering restricted indices, however, you can set this property to true. In that case, the names field will cover the restricted indices too.',
                })
              ),
              clusters: z
                .array(
                  z.string().register(z.globalRegistry, {
                    description:
                      'A list of remote cluster aliases. It supports literal strings as well as wildcards and regular expressions.',
                  })
                )
                .min(1),
              field_security: z.optional(
                z.record(
                  z.string(),
                  z.array(
                    z.string().register(z.globalRegistry, {
                      description: 'The document fields that the role members have read access to.',
                    })
                  )
                )
              ),
              names: z
                .array(
                  z.string().register(z.globalRegistry, {
                    description:
                      'A list of remote aliases, data streams, or indices to which the permissions apply. It supports wildcards (*).',
                  })
                )
                .min(1),
              privileges: z
                .array(
                  z.string().register(z.globalRegistry, {
                    description:
                      'The index level privileges that role members have for the specified indices.',
                  })
                )
                .min(1),
              query: z.optional(
                z.string().register(z.globalRegistry, {
                  description:
                    'A search query that defines the documents the role members have read access to. A document within the specified data streams and indices must match this query in order for it to be accessible by the role members. ',
                })
              ),
            })
          )
        ),
        run_as: z.optional(
          z.array(
            z.string().register(z.globalRegistry, {
              description: 'A user name that the role member can impersonate.',
            })
          )
        ),
      }),
      kibana: z.optional(
        z.array(
          z.object({
            base: z.union([
              z.array(z.unknown()),
              z.boolean(),
              z.number(),
              z.record(z.string(), z.unknown()),
              z.string(),
              z.null(),
            ]),
            feature: z.optional(
              z.record(
                z.string(),
                z.array(
                  z.string().register(z.globalRegistry, {
                    description: 'The privileges that the role member has for the feature.',
                  })
                )
              )
            ),
            spaces: z.optional(
              z.union([
                z.tuple([z.enum(['*'])]),
                z.array(
                  z.string().register(z.globalRegistry, {
                    description: 'A space that the privilege applies to.',
                  })
                ),
              ])
            ),
          })
        )
      ),
      metadata: z.optional(z.record(z.string(), z.unknown())),
    })
  ),
  path: z.object({
    name: z.string().min(1).max(1024).register(z.globalRegistry, {
      description: 'The role name.',
    }),
  }),
  query: z.optional(
    z.object({
      createOnly: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description: 'When true, a role is not overwritten if it already exists.',
          })
        )
        .default(false),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const put_security_role_name_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const post_security_roles_request = z.object({
  body: z.optional(
    z.object({
      roles: z.record(
        z.string(),
        z.object({
          description: z.optional(
            z.string().max(2048).register(z.globalRegistry, {
              description: 'A description for the role.',
            })
          ),
          elasticsearch: z.object({
            cluster: z.optional(
              z.array(
                z.string().register(z.globalRegistry, {
                  description:
                    'Cluster privileges that define the cluster level actions that users can perform.',
                })
              )
            ),
            indices: z.optional(
              z.array(
                z.object({
                  allow_restricted_indices: z.optional(
                    z.boolean().register(z.globalRegistry, {
                      description:
                        'Restricted indices are a special category of indices that are used internally to store configuration data and should not be directly accessed. Only internal system roles should normally grant privileges over the restricted indices. Toggling this flag is very strongly discouraged because it could effectively grant unrestricted operations on critical data, making the entire system unstable or leaking sensitive information. If for administrative purposes you need to create a role with privileges covering restricted indices, however, you can set this property to true. In that case, the names field covers the restricted indices too.',
                    })
                  ),
                  field_security: z.optional(
                    z.record(
                      z.string(),
                      z.array(
                        z.string().register(z.globalRegistry, {
                          description:
                            'The document fields that the role members have read access to.',
                        })
                      )
                    )
                  ),
                  names: z
                    .array(
                      z.string().register(z.globalRegistry, {
                        description:
                          'The data streams, indices, and aliases to which the permissions in this entry apply. It supports wildcards (*).',
                      })
                    )
                    .min(1),
                  privileges: z
                    .array(
                      z.string().register(z.globalRegistry, {
                        description:
                          'The index level privileges that the role members have for the data streams and indices.',
                      })
                    )
                    .min(1),
                  query: z.optional(
                    z.string().register(z.globalRegistry, {
                      description:
                        'A search query that defines the documents the role members have read access to. A document within the specified data streams and indices must match this query in order for it to be accessible by the role members.',
                    })
                  ),
                })
              )
            ),
            remote_cluster: z.optional(
              z.array(
                z.object({
                  clusters: z
                    .array(
                      z.string().register(z.globalRegistry, {
                        description:
                          'A list of remote cluster aliases. It supports literal strings as well as wildcards and regular expressions.',
                      })
                    )
                    .min(1),
                  privileges: z
                    .array(
                      z.string().register(z.globalRegistry, {
                        description:
                          'The cluster level privileges for the remote cluster. The allowed values are a subset of the cluster privileges.',
                      })
                    )
                    .min(1),
                })
              )
            ),
            remote_indices: z.optional(
              z.array(
                z.object({
                  allow_restricted_indices: z.optional(
                    z.boolean().register(z.globalRegistry, {
                      description:
                        'Restricted indices are a special category of indices that are used internally to store configuration data and should not be directly accessed. Only internal system roles should normally grant privileges over the restricted indices. Toggling this flag is very strongly discouraged because it could effectively grant unrestricted operations on critical data, making the entire system unstable or leaking sensitive information. If for administrative purposes you need to create a role with privileges covering restricted indices, however, you can set this property to true. In that case, the names field will cover the restricted indices too.',
                    })
                  ),
                  clusters: z
                    .array(
                      z.string().register(z.globalRegistry, {
                        description:
                          'A list of remote cluster aliases. It supports literal strings as well as wildcards and regular expressions.',
                      })
                    )
                    .min(1),
                  field_security: z.optional(
                    z.record(
                      z.string(),
                      z.array(
                        z.string().register(z.globalRegistry, {
                          description:
                            'The document fields that the role members have read access to.',
                        })
                      )
                    )
                  ),
                  names: z
                    .array(
                      z.string().register(z.globalRegistry, {
                        description:
                          'A list of remote aliases, data streams, or indices to which the permissions apply. It supports wildcards (*).',
                      })
                    )
                    .min(1),
                  privileges: z
                    .array(
                      z.string().register(z.globalRegistry, {
                        description:
                          'The index level privileges that role members have for the specified indices.',
                      })
                    )
                    .min(1),
                  query: z.optional(
                    z.string().register(z.globalRegistry, {
                      description:
                        'A search query that defines the documents the role members have read access to. A document within the specified data streams and indices must match this query in order for it to be accessible by the role members. ',
                    })
                  ),
                })
              )
            ),
            run_as: z.optional(
              z.array(
                z.string().register(z.globalRegistry, {
                  description: 'A user name that the role member can impersonate.',
                })
              )
            ),
          }),
          kibana: z.optional(
            z.array(
              z.object({
                base: z.union([
                  z.array(z.unknown()),
                  z.boolean(),
                  z.number(),
                  z.record(z.string(), z.unknown()),
                  z.string(),
                  z.null(),
                ]),
                feature: z.optional(
                  z.record(
                    z.string(),
                    z.array(
                      z.string().register(z.globalRegistry, {
                        description: 'The privileges that the role member has for the feature.',
                      })
                    )
                  )
                ),
                spaces: z.optional(
                  z.union([
                    z.tuple([z.enum(['*'])]),
                    z.array(
                      z.string().register(z.globalRegistry, {
                        description: 'A space that the privilege applies to.',
                      })
                    ),
                  ])
                ),
              })
            )
          ),
          metadata: z.optional(z.record(z.string(), z.unknown())),
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_security_session_invalidate_request = z.object({
  body: z.optional(
    z.object({
      match: z.enum(['all', 'query']).register(z.globalRegistry, {
        description:
          'The method Kibana uses to determine which sessions to invalidate. If it is `all`, all existing sessions will be invalidated. If it is `query`, only the sessions that match the query will be invalidated.\n',
      }),
      query: z.optional(
        z
          .object({
            provider: z
              .object({
                name: z.optional(
                  z.string().register(z.globalRegistry, {
                    description: 'The authentication provider name.',
                  })
                ),
                type: z.string().register(z.globalRegistry, {
                  description:
                    'The authentication provide type. For example: `basic`, `token`, `saml`, `oidc`, `kerberos`, or `pki`.\n',
                }),
              })
              .register(z.globalRegistry, {
                description:
                  'The authentication providers that will have their user sessions invalidated.',
              }),
            username: z.optional(
              z.string().register(z.globalRegistry, {
                description: 'The username that will have its sessions invalidated.',
              })
            ),
          })
          .register(z.globalRegistry, {
            description:
              'The query that Kibana uses to match the sessions to invalidate when the `match` parameter is set to `query`.\n',
          })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call
 */
export const post_security_session_invalidate_response = z
  .object({
    total: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The number of sessions that were successfully invalidated.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Indicates a successful call',
  });

export const post_url_request = z.object({
  body: z.object({
    humanReadableSlug: z.optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'When the `slug` parameter is omitted, the API will generate a random human-readable slug if `humanReadableSlug` is set to true.\n',
      })
    ),
    locatorId: z.string().register(z.globalRegistry, {
      description: 'The identifier for the locator.',
    }),
    params: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'An object which contains all necessary parameters for the given locator to resolve to a Kibana location.\n> warn\n> When you create a short URL, locator params are not validated, which allows you to pass arbitrary and ill-formed data into the API that can break Kibana. Make sure any data that you send to the API is properly formed.\n',
    }),
    slug: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A custom short URL slug. The slug is the part of the short URL that identifies it. You can provide a custom slug which consists of latin alphabet letters, numbers, and `-._` characters. The slug must be at least 3 characters long, but no longer than 255 characters.\n',
      })
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const post_url_response = short_url_ap_is_url_response;

export const resolve_url_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slug: z.string().register(z.globalRegistry, {
      description: 'The slug of the short URL.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const resolve_url_response = short_url_ap_is_url_response;

export const delete_url_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the short URL.',
    }),
  }),
  query: z.optional(z.never()),
});

export const get_url_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the short URL.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call.
 */
export const get_url_response = short_url_ap_is_url_response;

export const post_spaces_copy_saved_objects_request = z.object({
  body: z.optional(
    z.object({
      compatibilityMode: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Apply various adjustments to the saved objects that are being copied to maintain compatibility between different Kibana versions. Use this option only if you encounter issues with copied saved objects. This option cannot be used with the `createNewCopies` option.',
          })
        )
        .default(false),
      createNewCopies: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'Create new copies of saved objects, regenerate each object identifier, and reset the origin. When used, potential conflict errors are avoided.  This option cannot be used with the `overwrite` and `compatibilityMode` options.',
          })
        )
        .default(true),
      includeReferences: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'When set to true, all saved objects related to the specified saved objects will also be copied into the target spaces.',
          })
        )
        .default(false),
      objects: z.array(
        z.object({
          id: z.string().register(z.globalRegistry, {
            description: 'The identifier of the saved object to copy.',
          }),
          type: z.string().register(z.globalRegistry, {
            description: 'The type of the saved object to copy.',
          }),
        })
      ),
      overwrite: z
        .optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'When set to true, all conflicts are automatically overridden. When a saved object with a matching type and identifier exists in the target space, that version is replaced with the version from the source space. This option cannot be used with the `createNewCopies` option.',
          })
        )
        .default(false),
      spaces: z.array(
        z.string().register(z.globalRegistry, {
          description:
            'The identifiers of the spaces where you want to copy the specified objects.',
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_spaces_disable_legacy_url_aliases_request = z.object({
  body: z.optional(
    z.object({
      aliases: z.array(
        z.object({
          sourceId: z.string().register(z.globalRegistry, {
            description:
              'The alias source object identifier. This is the legacy object identifier.',
          }),
          targetSpace: z.string().register(z.globalRegistry, {
            description: 'The space where the alias target object exists.',
          }),
          targetType: z.string().register(z.globalRegistry, {
            description: 'The type of alias target object. ',
          }),
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_spaces_get_shareable_references_request = z.object({
  body: z.optional(
    z.object({
      objects: z.array(
        z.object({
          id: z.string(),
          type: z.string(),
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_spaces_resolve_copy_saved_objects_errors_request = z.object({
  body: z.optional(
    z.object({
      compatibilityMode: z.optional(z.boolean()).default(false),
      createNewCopies: z.optional(z.boolean()).default(true),
      includeReferences: z.optional(z.boolean()).default(false),
      objects: z.array(
        z.object({
          id: z.string(),
          type: z.string(),
        })
      ),
      retries: z.record(
        z.string(),
        z.array(
          z.object({
            createNewCopy: z.optional(
              z.boolean().register(z.globalRegistry, {
                description:
                  'Creates new copies of the saved objects, regenerates each object ID, and resets the origin.',
              })
            ),
            destinationId: z.optional(
              z.string().register(z.globalRegistry, {
                description:
                  'Specifies the destination identifier that the copied object should have, if different from the current identifier.',
              })
            ),
            id: z.string().register(z.globalRegistry, {
              description: 'The saved object identifier.',
            }),
            ignoreMissingReferences: z.optional(
              z.boolean().register(z.globalRegistry, {
                description: 'When set to true, any missing references errors are ignored.',
              })
            ),
            overwrite: z
              .optional(
                z.boolean().register(z.globalRegistry, {
                  description:
                    'When set to true, the saved object from the source space overwrites the conflicting object in the destination space.',
                })
              )
              .default(false),
            type: z.string().register(z.globalRegistry, {
              description: 'The saved object type.',
            }),
          })
        )
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_spaces_update_objects_spaces_request = z.object({
  body: z.optional(
    z.object({
      objects: z.array(
        z.object({
          id: z.string().register(z.globalRegistry, {
            description: 'The identifier of the saved object to update.',
          }),
          type: z.string().register(z.globalRegistry, {
            description: 'The type of the saved object to update.',
          }),
        })
      ),
      spacesToAdd: z.array(
        z.string().register(z.globalRegistry, {
          description:
            'The identifiers of the spaces the saved objects should be added to or removed from.',
        })
      ),
      spacesToRemove: z.array(
        z.string().register(z.globalRegistry, {
          description:
            'The identifiers of the spaces the saved objects should be added to or removed from.',
        })
      ),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_spaces_space_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    purpose: z.optional(
      z
        .enum(['any', 'copySavedObjectsIntoSpace', 'shareSavedObjectsIntoSpace'])
        .register(z.globalRegistry, {
          description:
            'Specifies which authorization checks are applied to the API call. The default value is `any`.',
        })
    ),
    include_authorized_purposes: z.union([
      z.array(z.unknown()),
      z.boolean(),
      z.number(),
      z.record(z.string(), z.unknown()),
      z.string(),
      z.null(),
    ]),
  }),
});

export const post_spaces_space_request = z.object({
  body: z.optional(
    z.object({
      _reserved: z.optional(z.boolean()),
      color: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The hexadecimal color code used in the space avatar. By default, the color is automatically generated from the space name.',
        })
      ),
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'A description for the space.',
        })
      ),
      disabledFeatures: z
        .optional(
          z.array(
            z.string().register(z.globalRegistry, {
              description: 'The list of features that are turned off in the space.',
            })
          )
        )
        .default([]),
      id: z.string().register(z.globalRegistry, {
        description:
          'The space ID that is part of the Kibana URL when inside the space. Space IDs are limited to lowercase alphanumeric, underscore, and hyphen characters (a-z, 0-9, _, and -). You are cannot change the ID with the update operation.',
      }),
      imageUrl: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The data-URL encoded image to display in the space avatar. If specified, initials will not be displayed and the color will be visible as the background color for transparent images. For best results, your image should be 64x64. Images will not be optimized by this API call, so care should be taken when using custom images.',
        })
      ),
      initials: z.optional(
        z.string().max(2).register(z.globalRegistry, {
          description:
            'One or two characters that are shown in the space avatar. By default, the initials are automatically generated from the space name.',
        })
      ),
      name: z.string().min(1).register(z.globalRegistry, {
        description: 'The display name for the space. ',
      }),
      solution: z.optional(z.enum(['security', 'oblt', 'es', 'classic'])),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const delete_spaces_space_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The space identifier.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

/**
 * Indicates a successful call.
 */
export const delete_spaces_space_id_response = z.void().register(z.globalRegistry, {
  description: 'Indicates a successful call.',
});

export const get_spaces_space_id_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The space identifier.',
    }),
  }),
  query: z.optional(z.never()),
});

export const put_spaces_space_id_request = z.object({
  body: z.optional(
    z.object({
      _reserved: z.optional(z.boolean()),
      color: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The hexadecimal color code used in the space avatar. By default, the color is automatically generated from the space name.',
        })
      ),
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'A description for the space.',
        })
      ),
      disabledFeatures: z
        .optional(
          z.array(
            z.string().register(z.globalRegistry, {
              description: 'The list of features that are turned off in the space.',
            })
          )
        )
        .default([]),
      id: z.string().register(z.globalRegistry, {
        description:
          'The space ID that is part of the Kibana URL when inside the space. Space IDs are limited to lowercase alphanumeric, underscore, and hyphen characters (a-z, 0-9, _, and -). You are cannot change the ID with the update operation.',
      }),
      imageUrl: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The data-URL encoded image to display in the space avatar. If specified, initials will not be displayed and the color will be visible as the background color for transparent images. For best results, your image should be 64x64. Images will not be optimized by this API call, so care should be taken when using custom images.',
        })
      ),
      initials: z.optional(
        z.string().max(2).register(z.globalRegistry, {
          description:
            'One or two characters that are shown in the space avatar. By default, the initials are automatically generated from the space name.',
        })
      ),
      name: z.string().min(1).register(z.globalRegistry, {
        description: 'The display name for the space. ',
      }),
      solution: z.optional(z.enum(['security', 'oblt', 'es', 'classic'])),
    })
  ),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description:
        'The space identifier. You are unable to change the ID with the update operation.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_status_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      v7format: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Set to "true" to get the response in v7 format.',
        })
      ),
      v8format: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Set to "true" to get the response in v8 format.',
        })
      ),
    })
  ),
});

/**
 * Kibana's operational status. A minimal response is sent for unauthorized users.
 */
export const get_status_response = z.union([
  kibana_http_ap_is_core_status_response,
  kibana_http_ap_is_core_status_redacted_response,
]);

export const get_streams_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const post_streams_disable_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_streams_enable_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_streams_resync_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const delete_streams_name_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_streams_name_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
});

export const put_streams_name_request = z.object({
  body: z.optional(
    z.union([
      z.union([
        z
          .record(z.string(), z.unknown())
          .and(
            z.object({
              stream: z
                .object({
                  name: z.optional(z.unknown()),
                })
                .and(
                  z.object({
                    description: z.string(),
                    name: z.string(),
                  })
                ),
            })
          )
          .and(
            z.object({
              dashboards: z.array(z.string()),
              queries: z.array(
                z
                  .object({
                    id: z.string().min(1),
                    title: z.string().min(1),
                  })
                  .and(
                    z.object({
                      feature: z.optional(
                        z.object({
                          filter: z.union([
                            z.union([
                              z.object({
                                contains: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                                endsWith: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                                eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                field: z.string().min(1),
                                gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                range: z.optional(
                                  z.object({
                                    gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  })
                                ),
                                startsWith: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                              }),
                              z.object({
                                exists: z.optional(z.boolean()),
                                field: z.string().min(1),
                              }),
                            ]),
                            z.object({
                              and: z.array(z.unknown()),
                            }),
                            z.object({
                              or: z.array(z.unknown()),
                            }),
                            z.object({
                              not: z.unknown(),
                            }),
                            z.object({
                              never: z.object({}),
                            }),
                            z.object({
                              always: z.object({}),
                            }),
                          ]),
                          name: z.string().min(1),
                        })
                      ),
                      kql: z.object({
                        query: z.string(),
                      }),
                    })
                  )
              ),
              rules: z.array(z.string()),
            })
          )
          .and(
            z.object({
              stream: z
                .object({
                  name: z.optional(z.unknown()),
                })
                .and(
                  z
                    .record(z.string(), z.unknown())
                    .and(
                      z.object({
                        description: z.string(),
                        name: z.string(),
                      })
                    )
                    .and(
                      z.object({
                        ingest: z.object({
                          failure_store: z.union([
                            z.object({
                              inherit: z.object({}),
                            }),
                            z.object({
                              disabled: z.object({}),
                            }),
                            z.union([
                              z.object({
                                lifecycle: z.object({
                                  enabled: z.object({
                                    data_retention: z.optional(z.string().min(1)),
                                  }),
                                }),
                              }),
                              z.object({
                                lifecycle: z.object({
                                  disabled: z.object({}),
                                }),
                              }),
                            ]),
                          ]),
                          lifecycle: z.union([
                            z.object({
                              dsl: z.object({
                                data_retention: z.optional(z.string().min(1)),
                              }),
                            }),
                            z.object({
                              ilm: z.object({
                                policy: z.string().min(1),
                              }),
                            }),
                            z.object({
                              inherit: z.object({}),
                            }),
                          ]),
                          processing: z.object({
                            steps: z.array(
                              z.union([
                                z.union([
                                  z.object({
                                    action: z.enum(['grok']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    pattern_definitions: z.optional(
                                      z.record(z.string(), z.string())
                                    ),
                                    patterns: z.array(z.string().min(1)).min(1),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['dissect']),
                                    append_separator: z.optional(z.string().min(1)),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    pattern: z.string().min(1),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['date']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    formats: z.array(z.string().min(1)),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    locale: z.optional(z.string().min(1)),
                                    output_format: z.optional(z.string().min(1)),
                                    timezone: z.optional(z.string().min(1)),
                                    to: z.optional(z.string().min(1)),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['drop_document']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    ignore_failure: z.optional(z.boolean()),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['rename']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    override: z.optional(z.boolean()),
                                    to: z.string().min(1),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['set']),
                                    copy_from: z.optional(z.string().min(1)),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    ignore_failure: z.optional(z.boolean()),
                                    override: z.optional(z.boolean()),
                                    to: z.string().min(1),
                                    value: z.optional(z.unknown()),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['append']),
                                    allow_duplicates: z.optional(z.boolean()),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    ignore_failure: z.optional(z.boolean()),
                                    to: z.string().min(1),
                                    value: z.array(z.unknown()).min(1),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['remove_by_prefix']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                  }),
                                  z.object({
                                    action: z.enum(['remove']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['replace']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    pattern: z.string().min(1),
                                    replacement: z.string(),
                                    to: z.optional(z.string().min(1)),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['convert']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    to: z.optional(z.string().min(1)),
                                    type: z.enum([
                                      'integer',
                                      'long',
                                      'double',
                                      'boolean',
                                      'string',
                                    ]),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['manual_ingest_pipeline']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    ignore_failure: z.optional(z.boolean()),
                                    on_failure: z.optional(
                                      z.array(z.record(z.string(), z.unknown()))
                                    ),
                                    processors: z.array(
                                      z.object({
                                        append: z.unknown(),
                                        attachment: z.unknown(),
                                        bytes: z.unknown(),
                                        circle: z.unknown(),
                                        community_id: z.unknown(),
                                        convert: z.unknown(),
                                        csv: z.unknown(),
                                        date: z.unknown(),
                                        date_index_name: z.unknown(),
                                        dissect: z.unknown(),
                                        dot_expander: z.unknown(),
                                        drop: z.unknown(),
                                        enrich: z.unknown(),
                                        fail: z.unknown(),
                                        fingerprint: z.unknown(),
                                        foreach: z.unknown(),
                                        geo_grid: z.unknown(),
                                        geoip: z.unknown(),
                                        grok: z.unknown(),
                                        gsub: z.unknown(),
                                        html_strip: z.unknown(),
                                        inference: z.unknown(),
                                        ip_location: z.unknown(),
                                        join: z.unknown(),
                                        json: z.unknown(),
                                        kv: z.unknown(),
                                        lowercase: z.unknown(),
                                        network_direction: z.unknown(),
                                        pipeline: z.unknown(),
                                        redact: z.unknown(),
                                        registered_domain: z.unknown(),
                                        remove: z.unknown(),
                                        rename: z.unknown(),
                                        reroute: z.unknown(),
                                        script: z.unknown(),
                                        set: z.unknown(),
                                        set_security_user: z.unknown(),
                                        sort: z.unknown(),
                                        split: z.unknown(),
                                        terminate: z.unknown(),
                                        trim: z.unknown(),
                                        uppercase: z.unknown(),
                                        uri_parts: z.unknown(),
                                        urldecode: z.unknown(),
                                        user_agent: z.unknown(),
                                      })
                                    ),
                                    tag: z.optional(z.string()),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                ]),
                                z.object({
                                  customIdentifier: z.optional(z.string()),
                                  where: z.intersection(
                                    z.union([
                                      z.union([
                                        z.object({
                                          contains: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          endsWith: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          eq: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          field: z.string().min(1),
                                          gt: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          gte: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          lt: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          lte: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          neq: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          range: z.optional(
                                            z.object({
                                              gt: z.optional(
                                                z.union([z.string(), z.number(), z.boolean()])
                                              ),
                                              gte: z.optional(
                                                z.union([z.string(), z.number(), z.boolean()])
                                              ),
                                              lt: z.optional(
                                                z.union([z.string(), z.number(), z.boolean()])
                                              ),
                                              lte: z.optional(
                                                z.union([z.string(), z.number(), z.boolean()])
                                              ),
                                            })
                                          ),
                                          startsWith: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                        }),
                                        z.object({
                                          exists: z.optional(z.boolean()),
                                          field: z.string().min(1),
                                        }),
                                      ]),
                                      z.object({
                                        and: z.array(z.unknown()),
                                      }),
                                      z.object({
                                        or: z.array(z.unknown()),
                                      }),
                                      z.object({
                                        not: z.unknown(),
                                      }),
                                      z.object({
                                        never: z.object({}),
                                      }),
                                      z.object({
                                        always: z.object({}),
                                      }),
                                    ]),
                                    z.object({
                                      steps: z.array(z.unknown()),
                                    })
                                  ),
                                }),
                              ])
                            ),
                          }),
                          settings: z.object({
                            'index.number_of_replicas': z.optional(
                              z.object({
                                value: z.number(),
                              })
                            ),
                            'index.number_of_shards': z.optional(
                              z.object({
                                value: z.number(),
                              })
                            ),
                            'index.refresh_interval': z.optional(
                              z.object({
                                value: z.union([z.string(), z.literal(-1)]),
                              })
                            ),
                          }),
                        }),
                      })
                    )
                    .and(
                      z.object({
                        ingest: z.object({
                          wired: z.object({
                            fields: z.record(
                              z.string(),
                              z
                                .record(
                                  z.string(),
                                  z.union([
                                    z.union([
                                      z.string(),
                                      z.number(),
                                      z.boolean(),
                                      z.enum(['null']),
                                      z.unknown(),
                                    ]),
                                    z.array(
                                      z.union([
                                        z.string(),
                                        z.number(),
                                        z.boolean(),
                                        z.enum(['null']),
                                        z.unknown(),
                                      ])
                                    ),
                                    z.array(z.unknown()),
                                    z.unknown(),
                                  ])
                                )
                                .and(
                                  z.union([
                                    z.object({
                                      format: z.optional(z.string().min(1)),
                                      type: z.enum([
                                        'keyword',
                                        'match_only_text',
                                        'long',
                                        'double',
                                        'date',
                                        'boolean',
                                        'ip',
                                      ]),
                                    }),
                                    z.object({
                                      type: z.enum(['system']),
                                    }),
                                  ])
                                )
                            ),
                            routing: z.array(
                              z.object({
                                destination: z.string().min(1),
                                status: z.optional(z.enum(['enabled', 'disabled'])),
                                where: z.union([
                                  z.union([
                                    z.object({
                                      contains: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      endsWith: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      eq: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      field: z.string().min(1),
                                      gt: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      gte: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      lt: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      lte: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      neq: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      range: z.optional(
                                        z.object({
                                          gt: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          gte: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          lt: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          lte: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                        })
                                      ),
                                      startsWith: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                    }),
                                    z.object({
                                      exists: z.optional(z.boolean()),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({
                                    and: z.array(z.unknown()),
                                  }),
                                  z.object({
                                    or: z.array(z.unknown()),
                                  }),
                                  z.object({
                                    not: z.unknown(),
                                  }),
                                  z.object({
                                    never: z.object({}),
                                  }),
                                  z.object({
                                    always: z.object({}),
                                  }),
                                ]),
                              })
                            ),
                          }),
                        }),
                      })
                    )
                ),
            })
          )
          .and(z.record(z.string(), z.unknown()))
          .and(
            z.object({
              stream: z
                .object({
                  name: z.optional(z.unknown()),
                })
                .and(
                  z.object({
                    description: z.string(),
                    name: z.string(),
                  })
                ),
            })
          )
          .and(
            z.object({
              dashboards: z.array(z.string()),
              queries: z.array(
                z
                  .object({
                    id: z.string().min(1),
                    title: z.string().min(1),
                  })
                  .and(
                    z.object({
                      feature: z.optional(
                        z.object({
                          filter: z.union([
                            z.union([
                              z.object({
                                contains: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                                endsWith: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                                eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                field: z.string().min(1),
                                gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                range: z.optional(
                                  z.object({
                                    gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  })
                                ),
                                startsWith: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                              }),
                              z.object({
                                exists: z.optional(z.boolean()),
                                field: z.string().min(1),
                              }),
                            ]),
                            z.object({
                              and: z.array(z.unknown()),
                            }),
                            z.object({
                              or: z.array(z.unknown()),
                            }),
                            z.object({
                              not: z.unknown(),
                            }),
                            z.object({
                              never: z.object({}),
                            }),
                            z.object({
                              always: z.object({}),
                            }),
                          ]),
                          name: z.string().min(1),
                        })
                      ),
                      kql: z.object({
                        query: z.string(),
                      }),
                    })
                  )
              ),
              rules: z.array(z.string()),
            })
          )
          .and(
            z.object({
              stream: z
                .object({
                  name: z.optional(z.unknown()),
                })
                .and(
                  z.object({
                    ingest: z.object({
                      failure_store: z.union([
                        z.object({
                          inherit: z.object({}),
                        }),
                        z.object({
                          disabled: z.object({}),
                        }),
                        z.union([
                          z.object({
                            lifecycle: z.object({
                              enabled: z.object({
                                data_retention: z.optional(z.string().min(1)),
                              }),
                            }),
                          }),
                          z.object({
                            lifecycle: z.object({
                              disabled: z.object({}),
                            }),
                          }),
                        ]),
                      ]),
                      lifecycle: z.union([
                        z.object({
                          dsl: z.object({
                            data_retention: z.optional(z.string().min(1)),
                          }),
                        }),
                        z.object({
                          ilm: z.object({
                            policy: z.string().min(1),
                          }),
                        }),
                        z.object({
                          inherit: z.object({}),
                        }),
                      ]),
                      processing: z.object({
                        steps: z.array(
                          z.union([
                            z.union([
                              z.object({
                                action: z.enum(['grok']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                pattern_definitions: z.optional(z.record(z.string(), z.string())),
                                patterns: z.array(z.string().min(1)).min(1),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['dissect']),
                                append_separator: z.optional(z.string().min(1)),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                pattern: z.string().min(1),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['date']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                formats: z.array(z.string().min(1)),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                locale: z.optional(z.string().min(1)),
                                output_format: z.optional(z.string().min(1)),
                                timezone: z.optional(z.string().min(1)),
                                to: z.optional(z.string().min(1)),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['drop_document']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                ignore_failure: z.optional(z.boolean()),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['rename']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                override: z.optional(z.boolean()),
                                to: z.string().min(1),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['set']),
                                copy_from: z.optional(z.string().min(1)),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                ignore_failure: z.optional(z.boolean()),
                                override: z.optional(z.boolean()),
                                to: z.string().min(1),
                                value: z.optional(z.unknown()),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['append']),
                                allow_duplicates: z.optional(z.boolean()),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                ignore_failure: z.optional(z.boolean()),
                                to: z.string().min(1),
                                value: z.array(z.unknown()).min(1),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['remove_by_prefix']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                              }),
                              z.object({
                                action: z.enum(['remove']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['replace']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                pattern: z.string().min(1),
                                replacement: z.string(),
                                to: z.optional(z.string().min(1)),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['convert']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                to: z.optional(z.string().min(1)),
                                type: z.enum(['integer', 'long', 'double', 'boolean', 'string']),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['manual_ingest_pipeline']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                ignore_failure: z.optional(z.boolean()),
                                on_failure: z.optional(z.array(z.record(z.string(), z.unknown()))),
                                processors: z.array(
                                  z.object({
                                    append: z.unknown(),
                                    attachment: z.unknown(),
                                    bytes: z.unknown(),
                                    circle: z.unknown(),
                                    community_id: z.unknown(),
                                    convert: z.unknown(),
                                    csv: z.unknown(),
                                    date: z.unknown(),
                                    date_index_name: z.unknown(),
                                    dissect: z.unknown(),
                                    dot_expander: z.unknown(),
                                    drop: z.unknown(),
                                    enrich: z.unknown(),
                                    fail: z.unknown(),
                                    fingerprint: z.unknown(),
                                    foreach: z.unknown(),
                                    geo_grid: z.unknown(),
                                    geoip: z.unknown(),
                                    grok: z.unknown(),
                                    gsub: z.unknown(),
                                    html_strip: z.unknown(),
                                    inference: z.unknown(),
                                    ip_location: z.unknown(),
                                    join: z.unknown(),
                                    json: z.unknown(),
                                    kv: z.unknown(),
                                    lowercase: z.unknown(),
                                    network_direction: z.unknown(),
                                    pipeline: z.unknown(),
                                    redact: z.unknown(),
                                    registered_domain: z.unknown(),
                                    remove: z.unknown(),
                                    rename: z.unknown(),
                                    reroute: z.unknown(),
                                    script: z.unknown(),
                                    set: z.unknown(),
                                    set_security_user: z.unknown(),
                                    sort: z.unknown(),
                                    split: z.unknown(),
                                    terminate: z.unknown(),
                                    trim: z.unknown(),
                                    uppercase: z.unknown(),
                                    uri_parts: z.unknown(),
                                    urldecode: z.unknown(),
                                    user_agent: z.unknown(),
                                  })
                                ),
                                tag: z.optional(z.string()),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                            ]),
                            z.object({
                              customIdentifier: z.optional(z.string()),
                              where: z.intersection(
                                z.union([
                                  z.union([
                                    z.object({
                                      contains: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      endsWith: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      eq: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      field: z.string().min(1),
                                      gt: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      gte: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      lt: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      lte: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      neq: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      range: z.optional(
                                        z.object({
                                          gt: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          gte: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          lt: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          lte: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                        })
                                      ),
                                      startsWith: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                    }),
                                    z.object({
                                      exists: z.optional(z.boolean()),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({
                                    and: z.array(z.unknown()),
                                  }),
                                  z.object({
                                    or: z.array(z.unknown()),
                                  }),
                                  z.object({
                                    not: z.unknown(),
                                  }),
                                  z.object({
                                    never: z.object({}),
                                  }),
                                  z.object({
                                    always: z.object({}),
                                  }),
                                ]),
                                z.object({
                                  steps: z.array(z.unknown()),
                                })
                              ),
                            }),
                          ])
                        ),
                      }),
                      settings: z.object({
                        'index.number_of_replicas': z.optional(
                          z.object({
                            value: z.number(),
                          })
                        ),
                        'index.number_of_shards': z.optional(
                          z.object({
                            value: z.number(),
                          })
                        ),
                        'index.refresh_interval': z.optional(
                          z.object({
                            value: z.union([z.string(), z.literal(-1)]),
                          })
                        ),
                      }),
                    }),
                  })
                ),
            })
          )
          .and(z.record(z.string(), z.unknown()))
          .and(z.record(z.string(), z.unknown())),
        z
          .record(z.string(), z.unknown())
          .and(
            z.object({
              stream: z
                .object({
                  name: z.optional(z.unknown()),
                })
                .and(
                  z.object({
                    description: z.string(),
                    name: z.string(),
                  })
                ),
            })
          )
          .and(
            z.object({
              dashboards: z.array(z.string()),
              queries: z.array(
                z
                  .object({
                    id: z.string().min(1),
                    title: z.string().min(1),
                  })
                  .and(
                    z.object({
                      feature: z.optional(
                        z.object({
                          filter: z.union([
                            z.union([
                              z.object({
                                contains: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                                endsWith: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                                eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                field: z.string().min(1),
                                gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                range: z.optional(
                                  z.object({
                                    gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  })
                                ),
                                startsWith: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                              }),
                              z.object({
                                exists: z.optional(z.boolean()),
                                field: z.string().min(1),
                              }),
                            ]),
                            z.object({
                              and: z.array(z.unknown()),
                            }),
                            z.object({
                              or: z.array(z.unknown()),
                            }),
                            z.object({
                              not: z.unknown(),
                            }),
                            z.object({
                              never: z.object({}),
                            }),
                            z.object({
                              always: z.object({}),
                            }),
                          ]),
                          name: z.string().min(1),
                        })
                      ),
                      kql: z.object({
                        query: z.string(),
                      }),
                    })
                  )
              ),
              rules: z.array(z.string()),
            })
          )
          .and(
            z.object({
              stream: z
                .object({
                  name: z.optional(z.unknown()),
                })
                .and(
                  z
                    .record(z.string(), z.unknown())
                    .and(
                      z.object({
                        description: z.string(),
                        name: z.string(),
                      })
                    )
                    .and(
                      z.object({
                        ingest: z.object({
                          failure_store: z.union([
                            z.object({
                              inherit: z.object({}),
                            }),
                            z.object({
                              disabled: z.object({}),
                            }),
                            z.union([
                              z.object({
                                lifecycle: z.object({
                                  enabled: z.object({
                                    data_retention: z.optional(z.string().min(1)),
                                  }),
                                }),
                              }),
                              z.object({
                                lifecycle: z.object({
                                  disabled: z.object({}),
                                }),
                              }),
                            ]),
                          ]),
                          lifecycle: z.union([
                            z.object({
                              dsl: z.object({
                                data_retention: z.optional(z.string().min(1)),
                              }),
                            }),
                            z.object({
                              ilm: z.object({
                                policy: z.string().min(1),
                              }),
                            }),
                            z.object({
                              inherit: z.object({}),
                            }),
                          ]),
                          processing: z.object({
                            steps: z.array(
                              z.union([
                                z.union([
                                  z.object({
                                    action: z.enum(['grok']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    pattern_definitions: z.optional(
                                      z.record(z.string(), z.string())
                                    ),
                                    patterns: z.array(z.string().min(1)).min(1),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['dissect']),
                                    append_separator: z.optional(z.string().min(1)),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    pattern: z.string().min(1),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['date']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    formats: z.array(z.string().min(1)),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    locale: z.optional(z.string().min(1)),
                                    output_format: z.optional(z.string().min(1)),
                                    timezone: z.optional(z.string().min(1)),
                                    to: z.optional(z.string().min(1)),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['drop_document']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    ignore_failure: z.optional(z.boolean()),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['rename']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    override: z.optional(z.boolean()),
                                    to: z.string().min(1),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['set']),
                                    copy_from: z.optional(z.string().min(1)),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    ignore_failure: z.optional(z.boolean()),
                                    override: z.optional(z.boolean()),
                                    to: z.string().min(1),
                                    value: z.optional(z.unknown()),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['append']),
                                    allow_duplicates: z.optional(z.boolean()),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    ignore_failure: z.optional(z.boolean()),
                                    to: z.string().min(1),
                                    value: z.array(z.unknown()).min(1),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['remove_by_prefix']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                  }),
                                  z.object({
                                    action: z.enum(['remove']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['replace']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    pattern: z.string().min(1),
                                    replacement: z.string(),
                                    to: z.optional(z.string().min(1)),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['convert']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    from: z.string().min(1),
                                    ignore_failure: z.optional(z.boolean()),
                                    ignore_missing: z.optional(z.boolean()),
                                    to: z.optional(z.string().min(1)),
                                    type: z.enum([
                                      'integer',
                                      'long',
                                      'double',
                                      'boolean',
                                      'string',
                                    ]),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                  z.object({
                                    action: z.enum(['manual_ingest_pipeline']),
                                    customIdentifier: z.optional(z.string().min(1)),
                                    description: z.optional(z.string()),
                                    ignore_failure: z.optional(z.boolean()),
                                    on_failure: z.optional(
                                      z.array(z.record(z.string(), z.unknown()))
                                    ),
                                    processors: z.array(
                                      z.object({
                                        append: z.unknown(),
                                        attachment: z.unknown(),
                                        bytes: z.unknown(),
                                        circle: z.unknown(),
                                        community_id: z.unknown(),
                                        convert: z.unknown(),
                                        csv: z.unknown(),
                                        date: z.unknown(),
                                        date_index_name: z.unknown(),
                                        dissect: z.unknown(),
                                        dot_expander: z.unknown(),
                                        drop: z.unknown(),
                                        enrich: z.unknown(),
                                        fail: z.unknown(),
                                        fingerprint: z.unknown(),
                                        foreach: z.unknown(),
                                        geo_grid: z.unknown(),
                                        geoip: z.unknown(),
                                        grok: z.unknown(),
                                        gsub: z.unknown(),
                                        html_strip: z.unknown(),
                                        inference: z.unknown(),
                                        ip_location: z.unknown(),
                                        join: z.unknown(),
                                        json: z.unknown(),
                                        kv: z.unknown(),
                                        lowercase: z.unknown(),
                                        network_direction: z.unknown(),
                                        pipeline: z.unknown(),
                                        redact: z.unknown(),
                                        registered_domain: z.unknown(),
                                        remove: z.unknown(),
                                        rename: z.unknown(),
                                        reroute: z.unknown(),
                                        script: z.unknown(),
                                        set: z.unknown(),
                                        set_security_user: z.unknown(),
                                        sort: z.unknown(),
                                        split: z.unknown(),
                                        terminate: z.unknown(),
                                        trim: z.unknown(),
                                        uppercase: z.unknown(),
                                        uri_parts: z.unknown(),
                                        urldecode: z.unknown(),
                                        user_agent: z.unknown(),
                                      })
                                    ),
                                    tag: z.optional(z.string()),
                                    where: z.optional(
                                      z.union([
                                        z.union([
                                          z.object({
                                            contains: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            endsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            eq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            field: z.string().min(1),
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            neq: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            range: z.optional(
                                              z.object({
                                                gt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                gte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lt: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                                lte: z.optional(
                                                  z.union([z.string(), z.number(), z.boolean()])
                                                ),
                                              })
                                            ),
                                            startsWith: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          }),
                                          z.object({
                                            exists: z.optional(z.boolean()),
                                            field: z.string().min(1),
                                          }),
                                        ]),
                                        z.object({
                                          and: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          or: z.array(z.unknown()),
                                        }),
                                        z.object({
                                          not: z.unknown(),
                                        }),
                                        z.object({
                                          never: z.object({}),
                                        }),
                                        z.object({
                                          always: z.object({}),
                                        }),
                                      ])
                                    ),
                                  }),
                                ]),
                                z.object({
                                  customIdentifier: z.optional(z.string()),
                                  where: z.intersection(
                                    z.union([
                                      z.union([
                                        z.object({
                                          contains: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          endsWith: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          eq: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          field: z.string().min(1),
                                          gt: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          gte: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          lt: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          lte: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          neq: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          range: z.optional(
                                            z.object({
                                              gt: z.optional(
                                                z.union([z.string(), z.number(), z.boolean()])
                                              ),
                                              gte: z.optional(
                                                z.union([z.string(), z.number(), z.boolean()])
                                              ),
                                              lt: z.optional(
                                                z.union([z.string(), z.number(), z.boolean()])
                                              ),
                                              lte: z.optional(
                                                z.union([z.string(), z.number(), z.boolean()])
                                              ),
                                            })
                                          ),
                                          startsWith: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                        }),
                                        z.object({
                                          exists: z.optional(z.boolean()),
                                          field: z.string().min(1),
                                        }),
                                      ]),
                                      z.object({
                                        and: z.array(z.unknown()),
                                      }),
                                      z.object({
                                        or: z.array(z.unknown()),
                                      }),
                                      z.object({
                                        not: z.unknown(),
                                      }),
                                      z.object({
                                        never: z.object({}),
                                      }),
                                      z.object({
                                        always: z.object({}),
                                      }),
                                    ]),
                                    z.object({
                                      steps: z.array(z.unknown()),
                                    })
                                  ),
                                }),
                              ])
                            ),
                          }),
                          settings: z.object({
                            'index.number_of_replicas': z.optional(
                              z.object({
                                value: z.number(),
                              })
                            ),
                            'index.number_of_shards': z.optional(
                              z.object({
                                value: z.number(),
                              })
                            ),
                            'index.refresh_interval': z.optional(
                              z.object({
                                value: z.union([z.string(), z.literal(-1)]),
                              })
                            ),
                          }),
                        }),
                      })
                    )
                    .and(
                      z.object({
                        ingest: z.object({
                          classic: z.object({
                            field_overrides: z.optional(
                              z.record(
                                z.string(),
                                z
                                  .record(
                                    z.string(),
                                    z.union([
                                      z.union([
                                        z.string(),
                                        z.number(),
                                        z.boolean(),
                                        z.enum(['null']),
                                        z.unknown(),
                                      ]),
                                      z.array(
                                        z.union([
                                          z.string(),
                                          z.number(),
                                          z.boolean(),
                                          z.enum(['null']),
                                          z.unknown(),
                                        ])
                                      ),
                                      z.array(z.unknown()),
                                      z.unknown(),
                                    ])
                                  )
                                  .and(
                                    z.union([
                                      z.object({
                                        format: z.optional(z.string().min(1)),
                                        type: z.enum([
                                          'keyword',
                                          'match_only_text',
                                          'long',
                                          'double',
                                          'date',
                                          'boolean',
                                          'ip',
                                        ]),
                                      }),
                                      z.object({
                                        type: z.enum(['system']),
                                      }),
                                    ])
                                  )
                              )
                            ),
                          }),
                        }),
                      })
                    )
                ),
            })
          )
          .and(z.record(z.string(), z.unknown()))
          .and(
            z.object({
              stream: z
                .object({
                  name: z.optional(z.unknown()),
                })
                .and(
                  z.object({
                    description: z.string(),
                    name: z.string(),
                  })
                ),
            })
          )
          .and(
            z.object({
              dashboards: z.array(z.string()),
              queries: z.array(
                z
                  .object({
                    id: z.string().min(1),
                    title: z.string().min(1),
                  })
                  .and(
                    z.object({
                      feature: z.optional(
                        z.object({
                          filter: z.union([
                            z.union([
                              z.object({
                                contains: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                                endsWith: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                                eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                field: z.string().min(1),
                                gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                range: z.optional(
                                  z.object({
                                    gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                    lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  })
                                ),
                                startsWith: z.optional(
                                  z.union([z.string(), z.number(), z.boolean()])
                                ),
                              }),
                              z.object({
                                exists: z.optional(z.boolean()),
                                field: z.string().min(1),
                              }),
                            ]),
                            z.object({
                              and: z.array(z.unknown()),
                            }),
                            z.object({
                              or: z.array(z.unknown()),
                            }),
                            z.object({
                              not: z.unknown(),
                            }),
                            z.object({
                              never: z.object({}),
                            }),
                            z.object({
                              always: z.object({}),
                            }),
                          ]),
                          name: z.string().min(1),
                        })
                      ),
                      kql: z.object({
                        query: z.string(),
                      }),
                    })
                  )
              ),
              rules: z.array(z.string()),
            })
          )
          .and(
            z.object({
              stream: z
                .object({
                  name: z.optional(z.unknown()),
                })
                .and(
                  z.object({
                    ingest: z.object({
                      failure_store: z.union([
                        z.object({
                          inherit: z.object({}),
                        }),
                        z.object({
                          disabled: z.object({}),
                        }),
                        z.union([
                          z.object({
                            lifecycle: z.object({
                              enabled: z.object({
                                data_retention: z.optional(z.string().min(1)),
                              }),
                            }),
                          }),
                          z.object({
                            lifecycle: z.object({
                              disabled: z.object({}),
                            }),
                          }),
                        ]),
                      ]),
                      lifecycle: z.union([
                        z.object({
                          dsl: z.object({
                            data_retention: z.optional(z.string().min(1)),
                          }),
                        }),
                        z.object({
                          ilm: z.object({
                            policy: z.string().min(1),
                          }),
                        }),
                        z.object({
                          inherit: z.object({}),
                        }),
                      ]),
                      processing: z.object({
                        steps: z.array(
                          z.union([
                            z.union([
                              z.object({
                                action: z.enum(['grok']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                pattern_definitions: z.optional(z.record(z.string(), z.string())),
                                patterns: z.array(z.string().min(1)).min(1),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['dissect']),
                                append_separator: z.optional(z.string().min(1)),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                pattern: z.string().min(1),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['date']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                formats: z.array(z.string().min(1)),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                locale: z.optional(z.string().min(1)),
                                output_format: z.optional(z.string().min(1)),
                                timezone: z.optional(z.string().min(1)),
                                to: z.optional(z.string().min(1)),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['drop_document']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                ignore_failure: z.optional(z.boolean()),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['rename']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                override: z.optional(z.boolean()),
                                to: z.string().min(1),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['set']),
                                copy_from: z.optional(z.string().min(1)),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                ignore_failure: z.optional(z.boolean()),
                                override: z.optional(z.boolean()),
                                to: z.string().min(1),
                                value: z.optional(z.unknown()),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['append']),
                                allow_duplicates: z.optional(z.boolean()),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                ignore_failure: z.optional(z.boolean()),
                                to: z.string().min(1),
                                value: z.array(z.unknown()).min(1),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['remove_by_prefix']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                              }),
                              z.object({
                                action: z.enum(['remove']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['replace']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                pattern: z.string().min(1),
                                replacement: z.string(),
                                to: z.optional(z.string().min(1)),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['convert']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                from: z.string().min(1),
                                ignore_failure: z.optional(z.boolean()),
                                ignore_missing: z.optional(z.boolean()),
                                to: z.optional(z.string().min(1)),
                                type: z.enum(['integer', 'long', 'double', 'boolean', 'string']),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                              z.object({
                                action: z.enum(['manual_ingest_pipeline']),
                                customIdentifier: z.optional(z.string().min(1)),
                                description: z.optional(z.string()),
                                ignore_failure: z.optional(z.boolean()),
                                on_failure: z.optional(z.array(z.record(z.string(), z.unknown()))),
                                processors: z.array(
                                  z.object({
                                    append: z.unknown(),
                                    attachment: z.unknown(),
                                    bytes: z.unknown(),
                                    circle: z.unknown(),
                                    community_id: z.unknown(),
                                    convert: z.unknown(),
                                    csv: z.unknown(),
                                    date: z.unknown(),
                                    date_index_name: z.unknown(),
                                    dissect: z.unknown(),
                                    dot_expander: z.unknown(),
                                    drop: z.unknown(),
                                    enrich: z.unknown(),
                                    fail: z.unknown(),
                                    fingerprint: z.unknown(),
                                    foreach: z.unknown(),
                                    geo_grid: z.unknown(),
                                    geoip: z.unknown(),
                                    grok: z.unknown(),
                                    gsub: z.unknown(),
                                    html_strip: z.unknown(),
                                    inference: z.unknown(),
                                    ip_location: z.unknown(),
                                    join: z.unknown(),
                                    json: z.unknown(),
                                    kv: z.unknown(),
                                    lowercase: z.unknown(),
                                    network_direction: z.unknown(),
                                    pipeline: z.unknown(),
                                    redact: z.unknown(),
                                    registered_domain: z.unknown(),
                                    remove: z.unknown(),
                                    rename: z.unknown(),
                                    reroute: z.unknown(),
                                    script: z.unknown(),
                                    set: z.unknown(),
                                    set_security_user: z.unknown(),
                                    sort: z.unknown(),
                                    split: z.unknown(),
                                    terminate: z.unknown(),
                                    trim: z.unknown(),
                                    uppercase: z.unknown(),
                                    uri_parts: z.unknown(),
                                    urldecode: z.unknown(),
                                    user_agent: z.unknown(),
                                  })
                                ),
                                tag: z.optional(z.string()),
                                where: z.optional(
                                  z.union([
                                    z.union([
                                      z.object({
                                        contains: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        endsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        eq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        field: z.string().min(1),
                                        gt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        gte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lt: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        lte: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        neq: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                        range: z.optional(
                                          z.object({
                                            gt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            gte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lt: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                            lte: z.optional(
                                              z.union([z.string(), z.number(), z.boolean()])
                                            ),
                                          })
                                        ),
                                        startsWith: z.optional(
                                          z.union([z.string(), z.number(), z.boolean()])
                                        ),
                                      }),
                                      z.object({
                                        exists: z.optional(z.boolean()),
                                        field: z.string().min(1),
                                      }),
                                    ]),
                                    z.object({
                                      and: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      or: z.array(z.unknown()),
                                    }),
                                    z.object({
                                      not: z.unknown(),
                                    }),
                                    z.object({
                                      never: z.object({}),
                                    }),
                                    z.object({
                                      always: z.object({}),
                                    }),
                                  ])
                                ),
                              }),
                            ]),
                            z.object({
                              customIdentifier: z.optional(z.string()),
                              where: z.intersection(
                                z.union([
                                  z.union([
                                    z.object({
                                      contains: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      endsWith: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      eq: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      field: z.string().min(1),
                                      gt: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      gte: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      lt: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      lte: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      neq: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                      range: z.optional(
                                        z.object({
                                          gt: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          gte: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          lt: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                          lte: z.optional(
                                            z.union([z.string(), z.number(), z.boolean()])
                                          ),
                                        })
                                      ),
                                      startsWith: z.optional(
                                        z.union([z.string(), z.number(), z.boolean()])
                                      ),
                                    }),
                                    z.object({
                                      exists: z.optional(z.boolean()),
                                      field: z.string().min(1),
                                    }),
                                  ]),
                                  z.object({
                                    and: z.array(z.unknown()),
                                  }),
                                  z.object({
                                    or: z.array(z.unknown()),
                                  }),
                                  z.object({
                                    not: z.unknown(),
                                  }),
                                  z.object({
                                    never: z.object({}),
                                  }),
                                  z.object({
                                    always: z.object({}),
                                  }),
                                ]),
                                z.object({
                                  steps: z.array(z.unknown()),
                                })
                              ),
                            }),
                          ])
                        ),
                      }),
                      settings: z.object({
                        'index.number_of_replicas': z.optional(
                          z.object({
                            value: z.number(),
                          })
                        ),
                        'index.number_of_shards': z.optional(
                          z.object({
                            value: z.number(),
                          })
                        ),
                        'index.refresh_interval': z.optional(
                          z.object({
                            value: z.union([z.string(), z.literal(-1)]),
                          })
                        ),
                      }),
                    }),
                  })
                ),
            })
          )
          .and(z.record(z.string(), z.unknown()))
          .and(z.record(z.string(), z.unknown())),
      ]),
      z
        .record(z.string(), z.unknown())
        .and(
          z.object({
            stream: z
              .object({
                name: z.optional(z.unknown()),
              })
              .and(
                z.object({
                  description: z.string(),
                  name: z.string(),
                })
              ),
          })
        )
        .and(
          z.object({
            dashboards: z.array(z.string()),
            queries: z.array(
              z
                .object({
                  id: z.string().min(1),
                  title: z.string().min(1),
                })
                .and(
                  z.object({
                    feature: z.optional(
                      z.object({
                        filter: z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ]),
                        name: z.string().min(1),
                      })
                    ),
                    kql: z.object({
                      query: z.string(),
                    }),
                  })
                )
            ),
            rules: z.array(z.string()),
          })
        )
        .and(
          z.object({
            stream: z
              .object({
                name: z.optional(z.unknown()),
              })
              .and(
                z.object({
                  group: z.object({
                    members: z.array(z.string()),
                    metadata: z.record(z.string(), z.string()),
                    tags: z.array(z.string()),
                  }),
                })
              ),
          })
        )
        .and(z.record(z.string(), z.unknown())),
    ])
  ),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_streams_name_fork_request = z.object({
  body: z.optional(
    z.object({
      status: z.optional(z.enum(['enabled', 'disabled'])),
      stream: z.object({
        name: z.string(),
      }),
      where: z.union([
        z.union([
          z.object({
            contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
            endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
            eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
            field: z.string().min(1),
            gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
            gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
            lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
            lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
            neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
            range: z.optional(
              z.object({
                gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
              })
            ),
            startsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
          }),
          z.object({
            exists: z.optional(z.boolean()),
            field: z.string().min(1),
          }),
        ]),
        z.object({
          and: z.array(z.unknown()),
        }),
        z.object({
          or: z.array(z.unknown()),
        }),
        z.object({
          not: z.unknown(),
        }),
        z.object({
          never: z.record(z.string(), z.never()),
        }),
        z.object({
          always: z.record(z.string(), z.never()),
        }),
      ]),
    })
  ),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_streams_name_group_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
});

export const put_streams_name_group_request = z.object({
  body: z.optional(
    z.object({
      group: z.object({
        members: z.array(z.string()),
        metadata: z.record(z.string(), z.string()),
        tags: z.array(z.string()),
      }),
    })
  ),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_streams_name_ingest_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
});

export const put_streams_name_ingest_request = z.object({
  body: z.optional(
    z.object({
      ingest: z.union([
        z
          .object({
            failure_store: z.union([
              z.object({
                inherit: z.object({}),
              }),
              z.object({
                disabled: z.object({}),
              }),
              z.union([
                z.object({
                  lifecycle: z.object({
                    enabled: z.object({
                      data_retention: z.optional(z.string().min(1)),
                    }),
                  }),
                }),
                z.object({
                  lifecycle: z.object({
                    disabled: z.object({}),
                  }),
                }),
              ]),
            ]),
            lifecycle: z.union([
              z.object({
                dsl: z.object({
                  data_retention: z.optional(z.string().min(1)),
                }),
              }),
              z.object({
                ilm: z.object({
                  policy: z.string().min(1),
                }),
              }),
              z.object({
                inherit: z.object({}),
              }),
            ]),
            processing: z.object({
              steps: z.array(
                z.union([
                  z.union([
                    z.object({
                      action: z.enum(['grok']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      pattern_definitions: z.optional(z.record(z.string(), z.string())),
                      patterns: z.array(z.string().min(1)).min(1),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['dissect']),
                      append_separator: z.optional(z.string().min(1)),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      pattern: z.string().min(1),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['date']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      formats: z.array(z.string().min(1)),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      locale: z.optional(z.string().min(1)),
                      output_format: z.optional(z.string().min(1)),
                      timezone: z.optional(z.string().min(1)),
                      to: z.optional(z.string().min(1)),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['drop_document']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      ignore_failure: z.optional(z.boolean()),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['rename']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      override: z.optional(z.boolean()),
                      to: z.string().min(1),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['set']),
                      copy_from: z.optional(z.string().min(1)),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      ignore_failure: z.optional(z.boolean()),
                      override: z.optional(z.boolean()),
                      to: z.string().min(1),
                      value: z.optional(z.unknown()),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['append']),
                      allow_duplicates: z.optional(z.boolean()),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      ignore_failure: z.optional(z.boolean()),
                      to: z.string().min(1),
                      value: z.array(z.unknown()).min(1),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['remove_by_prefix']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                    }),
                    z.object({
                      action: z.enum(['remove']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['replace']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      pattern: z.string().min(1),
                      replacement: z.string(),
                      to: z.optional(z.string().min(1)),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['convert']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      to: z.optional(z.string().min(1)),
                      type: z.enum(['integer', 'long', 'double', 'boolean', 'string']),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['manual_ingest_pipeline']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      ignore_failure: z.optional(z.boolean()),
                      on_failure: z.optional(z.array(z.record(z.string(), z.unknown()))),
                      processors: z.array(
                        z.object({
                          append: z.unknown(),
                          attachment: z.unknown(),
                          bytes: z.unknown(),
                          circle: z.unknown(),
                          community_id: z.unknown(),
                          convert: z.unknown(),
                          csv: z.unknown(),
                          date: z.unknown(),
                          date_index_name: z.unknown(),
                          dissect: z.unknown(),
                          dot_expander: z.unknown(),
                          drop: z.unknown(),
                          enrich: z.unknown(),
                          fail: z.unknown(),
                          fingerprint: z.unknown(),
                          foreach: z.unknown(),
                          geo_grid: z.unknown(),
                          geoip: z.unknown(),
                          grok: z.unknown(),
                          gsub: z.unknown(),
                          html_strip: z.unknown(),
                          inference: z.unknown(),
                          ip_location: z.unknown(),
                          join: z.unknown(),
                          json: z.unknown(),
                          kv: z.unknown(),
                          lowercase: z.unknown(),
                          network_direction: z.unknown(),
                          pipeline: z.unknown(),
                          redact: z.unknown(),
                          registered_domain: z.unknown(),
                          remove: z.unknown(),
                          rename: z.unknown(),
                          reroute: z.unknown(),
                          script: z.unknown(),
                          set: z.unknown(),
                          set_security_user: z.unknown(),
                          sort: z.unknown(),
                          split: z.unknown(),
                          terminate: z.unknown(),
                          trim: z.unknown(),
                          uppercase: z.unknown(),
                          uri_parts: z.unknown(),
                          urldecode: z.unknown(),
                          user_agent: z.unknown(),
                        })
                      ),
                      tag: z.optional(z.string()),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                  ]),
                  z.object({
                    customIdentifier: z.optional(z.string()),
                    where: z.intersection(
                      z.union([
                        z.union([
                          z.object({
                            contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            field: z.string().min(1),
                            gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            range: z.optional(
                              z.object({
                                gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              })
                            ),
                            startsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          }),
                          z.object({
                            exists: z.optional(z.boolean()),
                            field: z.string().min(1),
                          }),
                        ]),
                        z.object({
                          and: z.array(z.unknown()),
                        }),
                        z.object({
                          or: z.array(z.unknown()),
                        }),
                        z.object({
                          not: z.unknown(),
                        }),
                        z.object({
                          never: z.object({}),
                        }),
                        z.object({
                          always: z.object({}),
                        }),
                      ]),
                      z.object({
                        steps: z.array(z.unknown()),
                      })
                    ),
                  }),
                ])
              ),
            }),
            settings: z.object({
              'index.number_of_replicas': z.optional(
                z.object({
                  value: z.number(),
                })
              ),
              'index.number_of_shards': z.optional(
                z.object({
                  value: z.number(),
                })
              ),
              'index.refresh_interval': z.optional(
                z.object({
                  value: z.union([z.string(), z.literal(-1)]),
                })
              ),
            }),
          })
          .and(
            z.object({
              wired: z.object({
                fields: z.record(
                  z.string(),
                  z
                    .record(
                      z.string(),
                      z.union([
                        z.union([
                          z.string(),
                          z.number(),
                          z.boolean(),
                          z.enum(['null']),
                          z.unknown(),
                        ]),
                        z.array(
                          z.union([
                            z.string(),
                            z.number(),
                            z.boolean(),
                            z.enum(['null']),
                            z.unknown(),
                          ])
                        ),
                        z.array(z.unknown()),
                        z.unknown(),
                      ])
                    )
                    .and(
                      z.union([
                        z.object({
                          format: z.optional(z.string().min(1)),
                          type: z.enum([
                            'keyword',
                            'match_only_text',
                            'long',
                            'double',
                            'date',
                            'boolean',
                            'ip',
                          ]),
                        }),
                        z.object({
                          type: z.enum(['system']),
                        }),
                      ])
                    )
                ),
                routing: z.array(
                  z.object({
                    destination: z.string().min(1),
                    status: z.optional(z.enum(['enabled', 'disabled'])),
                    where: z.union([
                      z.union([
                        z.object({
                          contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          field: z.string().min(1),
                          gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          range: z.optional(
                            z.object({
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            })
                          ),
                          startsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                        }),
                        z.object({
                          exists: z.optional(z.boolean()),
                          field: z.string().min(1),
                        }),
                      ]),
                      z.object({
                        and: z.array(z.unknown()),
                      }),
                      z.object({
                        or: z.array(z.unknown()),
                      }),
                      z.object({
                        not: z.unknown(),
                      }),
                      z.object({
                        never: z.object({}),
                      }),
                      z.object({
                        always: z.object({}),
                      }),
                    ]),
                  })
                ),
              }),
            })
          ),
        z
          .object({
            failure_store: z.union([
              z.object({
                inherit: z.object({}),
              }),
              z.object({
                disabled: z.object({}),
              }),
              z.union([
                z.object({
                  lifecycle: z.object({
                    enabled: z.object({
                      data_retention: z.optional(z.string().min(1)),
                    }),
                  }),
                }),
                z.object({
                  lifecycle: z.object({
                    disabled: z.object({}),
                  }),
                }),
              ]),
            ]),
            lifecycle: z.union([
              z.object({
                dsl: z.object({
                  data_retention: z.optional(z.string().min(1)),
                }),
              }),
              z.object({
                ilm: z.object({
                  policy: z.string().min(1),
                }),
              }),
              z.object({
                inherit: z.object({}),
              }),
            ]),
            processing: z.object({
              steps: z.array(
                z.union([
                  z.union([
                    z.object({
                      action: z.enum(['grok']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      pattern_definitions: z.optional(z.record(z.string(), z.string())),
                      patterns: z.array(z.string().min(1)).min(1),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['dissect']),
                      append_separator: z.optional(z.string().min(1)),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      pattern: z.string().min(1),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['date']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      formats: z.array(z.string().min(1)),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      locale: z.optional(z.string().min(1)),
                      output_format: z.optional(z.string().min(1)),
                      timezone: z.optional(z.string().min(1)),
                      to: z.optional(z.string().min(1)),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['drop_document']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      ignore_failure: z.optional(z.boolean()),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['rename']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      override: z.optional(z.boolean()),
                      to: z.string().min(1),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['set']),
                      copy_from: z.optional(z.string().min(1)),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      ignore_failure: z.optional(z.boolean()),
                      override: z.optional(z.boolean()),
                      to: z.string().min(1),
                      value: z.optional(z.unknown()),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['append']),
                      allow_duplicates: z.optional(z.boolean()),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      ignore_failure: z.optional(z.boolean()),
                      to: z.string().min(1),
                      value: z.array(z.unknown()).min(1),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['remove_by_prefix']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                    }),
                    z.object({
                      action: z.enum(['remove']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['replace']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      pattern: z.string().min(1),
                      replacement: z.string(),
                      to: z.optional(z.string().min(1)),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['convert']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      from: z.string().min(1),
                      ignore_failure: z.optional(z.boolean()),
                      ignore_missing: z.optional(z.boolean()),
                      to: z.optional(z.string().min(1)),
                      type: z.enum(['integer', 'long', 'double', 'boolean', 'string']),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                    z.object({
                      action: z.enum(['manual_ingest_pipeline']),
                      customIdentifier: z.optional(z.string().min(1)),
                      description: z.optional(z.string()),
                      ignore_failure: z.optional(z.boolean()),
                      on_failure: z.optional(z.array(z.record(z.string(), z.unknown()))),
                      processors: z.array(
                        z.object({
                          append: z.unknown(),
                          attachment: z.unknown(),
                          bytes: z.unknown(),
                          circle: z.unknown(),
                          community_id: z.unknown(),
                          convert: z.unknown(),
                          csv: z.unknown(),
                          date: z.unknown(),
                          date_index_name: z.unknown(),
                          dissect: z.unknown(),
                          dot_expander: z.unknown(),
                          drop: z.unknown(),
                          enrich: z.unknown(),
                          fail: z.unknown(),
                          fingerprint: z.unknown(),
                          foreach: z.unknown(),
                          geo_grid: z.unknown(),
                          geoip: z.unknown(),
                          grok: z.unknown(),
                          gsub: z.unknown(),
                          html_strip: z.unknown(),
                          inference: z.unknown(),
                          ip_location: z.unknown(),
                          join: z.unknown(),
                          json: z.unknown(),
                          kv: z.unknown(),
                          lowercase: z.unknown(),
                          network_direction: z.unknown(),
                          pipeline: z.unknown(),
                          redact: z.unknown(),
                          registered_domain: z.unknown(),
                          remove: z.unknown(),
                          rename: z.unknown(),
                          reroute: z.unknown(),
                          script: z.unknown(),
                          set: z.unknown(),
                          set_security_user: z.unknown(),
                          sort: z.unknown(),
                          split: z.unknown(),
                          terminate: z.unknown(),
                          trim: z.unknown(),
                          uppercase: z.unknown(),
                          uri_parts: z.unknown(),
                          urldecode: z.unknown(),
                          user_agent: z.unknown(),
                        })
                      ),
                      tag: z.optional(z.string()),
                      where: z.optional(
                        z.union([
                          z.union([
                            z.object({
                              contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              field: z.string().min(1),
                              gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              range: z.optional(
                                z.object({
                                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                })
                              ),
                              startsWith: z.optional(
                                z.union([z.string(), z.number(), z.boolean()])
                              ),
                            }),
                            z.object({
                              exists: z.optional(z.boolean()),
                              field: z.string().min(1),
                            }),
                          ]),
                          z.object({
                            and: z.array(z.unknown()),
                          }),
                          z.object({
                            or: z.array(z.unknown()),
                          }),
                          z.object({
                            not: z.unknown(),
                          }),
                          z.object({
                            never: z.object({}),
                          }),
                          z.object({
                            always: z.object({}),
                          }),
                        ])
                      ),
                    }),
                  ]),
                  z.object({
                    customIdentifier: z.optional(z.string()),
                    where: z.intersection(
                      z.union([
                        z.union([
                          z.object({
                            contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            field: z.string().min(1),
                            gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            range: z.optional(
                              z.object({
                                gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              })
                            ),
                            startsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          }),
                          z.object({
                            exists: z.optional(z.boolean()),
                            field: z.string().min(1),
                          }),
                        ]),
                        z.object({
                          and: z.array(z.unknown()),
                        }),
                        z.object({
                          or: z.array(z.unknown()),
                        }),
                        z.object({
                          not: z.unknown(),
                        }),
                        z.object({
                          never: z.object({}),
                        }),
                        z.object({
                          always: z.object({}),
                        }),
                      ]),
                      z.object({
                        steps: z.array(z.unknown()),
                      })
                    ),
                  }),
                ])
              ),
            }),
            settings: z.object({
              'index.number_of_replicas': z.optional(
                z.object({
                  value: z.number(),
                })
              ),
              'index.number_of_shards': z.optional(
                z.object({
                  value: z.number(),
                })
              ),
              'index.refresh_interval': z.optional(
                z.object({
                  value: z.union([z.string(), z.literal(-1)]),
                })
              ),
            }),
          })
          .and(
            z.object({
              classic: z.object({
                field_overrides: z.optional(
                  z.record(
                    z.string(),
                    z
                      .record(
                        z.string(),
                        z.union([
                          z.union([
                            z.string(),
                            z.number(),
                            z.boolean(),
                            z.enum(['null']),
                            z.unknown(),
                          ]),
                          z.array(
                            z.union([
                              z.string(),
                              z.number(),
                              z.boolean(),
                              z.enum(['null']),
                              z.unknown(),
                            ])
                          ),
                          z.array(z.unknown()),
                          z.unknown(),
                        ])
                      )
                      .and(
                        z.union([
                          z.object({
                            format: z.optional(z.string().min(1)),
                            type: z.enum([
                              'keyword',
                              'match_only_text',
                              'long',
                              'double',
                              'date',
                              'boolean',
                              'ip',
                            ]),
                          }),
                          z.object({
                            type: z.enum(['system']),
                          }),
                        ])
                      )
                  )
                ),
              }),
            })
          ),
      ]),
    })
  ),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_streams_name_content_export_request = z.object({
  body: z.optional(
    z.object({
      description: z.string(),
      include: z.union([
        z.object({
          objects: z.object({
            all: z.record(z.string(), z.never()),
          }),
        }),
        z.object({
          objects: z.object({
            mappings: z.boolean(),
            queries: z.array(
              z.object({
                id: z.string(),
              })
            ),
            routing: z.array(
              z.intersection(
                z.unknown(),
                z.object({
                  destination: z.string(),
                })
              )
            ),
          }),
        }),
      ]),
      name: z.string(),
      version: z.string(),
    })
  ),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_streams_name_content_import_request = z.object({
  body: z.optional(
    z.object({
      content: z.unknown(),
      include: z.string(),
    })
  ),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_streams_name_dashboards_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
});

export const post_streams_name_dashboards_bulk_request = z.object({
  body: z.optional(
    z.object({
      operations: z.array(
        z.union([
          z.object({
            index: z.object({
              id: z.string(),
            }),
          }),
          z.object({
            delete: z.object({
              id: z.string(),
            }),
          }),
        ])
      ),
    })
  ),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const delete_streams_name_dashboards_dashboardid_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
    dashboardId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const put_streams_name_dashboards_dashboardid_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
    dashboardId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_streams_name_queries_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
});

export const post_streams_name_queries_bulk_request = z.object({
  body: z.optional(
    z.object({
      operations: z.array(
        z.union([
          z.object({
            index: z
              .object({
                id: z.string().min(1),
                title: z.string().min(1),
              })
              .and(
                z.object({
                  feature: z.optional(
                    z.object({
                      filter: z.union([
                        z.union([
                          z.object({
                            contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            field: z.string().min(1),
                            gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                            range: z.optional(
                              z.object({
                                gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                                lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                              })
                            ),
                            startsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                          }),
                          z.object({
                            exists: z.optional(z.boolean()),
                            field: z.string().min(1),
                          }),
                        ]),
                        z.object({
                          and: z.array(z.unknown()),
                        }),
                        z.object({
                          or: z.array(z.unknown()),
                        }),
                        z.object({
                          not: z.unknown(),
                        }),
                        z.object({
                          never: z.object({}),
                        }),
                        z.object({
                          always: z.object({}),
                        }),
                      ]),
                      name: z.string().min(1),
                    })
                  ),
                  kql: z.object({
                    query: z.string(),
                  }),
                })
              ),
          }),
          z.object({
            delete: z.object({
              id: z.string(),
            }),
          }),
        ])
      ),
    })
  ),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const delete_streams_name_queries_queryid_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
    queryId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const put_streams_name_queries_queryid_request = z.object({
  body: z.optional(
    z.object({
      feature: z.optional(
        z.object({
          filter: z.union([
            z.union([
              z.object({
                contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                field: z.string().min(1),
                gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                range: z.optional(
                  z.object({
                    gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                  })
                ),
                startsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
              }),
              z.object({
                exists: z.optional(z.boolean()),
                field: z.string().min(1),
              }),
            ]),
            z.object({
              and: z.array(z.unknown()),
            }),
            z.object({
              or: z.array(z.unknown()),
            }),
            z.object({
              not: z.unknown(),
            }),
            z.object({
              never: z.record(z.string(), z.never()),
            }),
            z.object({
              always: z.record(z.string(), z.never()),
            }),
          ]),
          name: z.string().min(1),
        })
      ),
      kql: z.object({
        query: z.string(),
      }),
      title: z.string().min(1),
    })
  ),
  path: z.object({
    name: z.string(),
    queryId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_streams_name_rules_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
});

export const delete_streams_name_rules_ruleid_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
    ruleId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const put_streams_name_rules_ruleid_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
    ruleId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_streams_name_significant_events_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    name: z.string(),
  }),
  query: z.object({
    from: z.string(),
    to: z.string(),
    bucketSize: z.string(),
  }),
});

export const post_streams_name_significant_events_generate_request = z.object({
  body: z.optional(
    z.object({
      feature: z.optional(
        z
          .object({
            description: z.string(),
            name: z.string().min(1),
            type: z.enum(['system']),
          })
          .and(
            z.object({
              filter: z.union([
                z.union([
                  z.object({
                    contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    field: z.string().min(1),
                    gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    range: z.optional(
                      z.object({
                        gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                        gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                        lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                        lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                      })
                    ),
                    startsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                  }),
                  z.object({
                    exists: z.optional(z.boolean()),
                    field: z.string().min(1),
                  }),
                ]),
                z.object({
                  and: z.array(z.unknown()),
                }),
                z.object({
                  or: z.array(z.unknown()),
                }),
                z.object({
                  not: z.unknown(),
                }),
                z.object({
                  never: z.object({}),
                }),
                z.object({
                  always: z.object({}),
                }),
              ]),
            })
          )
          .and(
            z.object({
              type: z.enum(['system']),
            })
          )
      ),
    })
  ),
  path: z.object({
    name: z.string(),
  }),
  query: z.object({
    connectorId: z.string(),
    currentDate: z.optional(z.string()),
    from: z.string(),
    to: z.string(),
  }),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_streams_name_significant_events_preview_request = z.object({
  body: z.optional(
    z.object({
      query: z.object({
        feature: z.optional(
          z.object({
            filter: z.union([
              z.union([
                z.object({
                  contains: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                  endsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                  eq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                  field: z.string().min(1),
                  gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                  gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                  lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                  lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                  neq: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                  range: z.optional(
                    z.object({
                      gt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                      gte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                      lt: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                      lte: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                    })
                  ),
                  startsWith: z.optional(z.union([z.string(), z.number(), z.boolean()])),
                }),
                z.object({
                  exists: z.optional(z.boolean()),
                  field: z.string().min(1),
                }),
              ]),
              z.object({
                and: z.array(z.unknown()),
              }),
              z.object({
                or: z.array(z.unknown()),
              }),
              z.object({
                not: z.unknown(),
              }),
              z.object({
                never: z.record(z.string(), z.never()),
              }),
              z.object({
                always: z.record(z.string(), z.never()),
              }),
            ]),
            name: z.string(),
          })
        ),
        kql: z.object({
          query: z.string(),
        }),
      }),
    })
  ),
  path: z.object({
    name: z.string(),
  }),
  query: z.object({
    from: z.string(),
    to: z.string(),
    bucketSize: z.string(),
  }),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const get_streams_streamname_attachments_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    streamName: z.string().register(z.globalRegistry, {
      description: 'The name of the stream',
    }),
  }),
  query: z.optional(
    z.object({
      attachmentType: z.optional(
        z.enum(['dashboard', 'rule']).register(z.globalRegistry, {
          description: 'Filter by attachment type',
        })
      ),
    })
  ),
});

export const post_streams_streamname_attachments_bulk_request = z.object({
  body: z.optional(
    z.object({
      operations: z.array(
        z.union([
          z.object({
            index: z.object({
              id: z.string(),
              type: z.enum(['dashboard', 'rule']),
            }),
          }),
          z.object({
            delete: z.object({
              id: z.string(),
              type: z.enum(['dashboard', 'rule']),
            }),
          }),
        ])
      ),
    })
  ),
  path: z.object({
    streamName: z.string().register(z.globalRegistry, {
      description: 'The name of the stream',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const delete_streams_streamname_attachments_attachmenttype_attachmentid_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    streamName: z.string().register(z.globalRegistry, {
      description: 'The name of the stream',
    }),
    attachmentType: z.enum(['dashboard', 'rule']).register(z.globalRegistry, {
      description: 'The type of the attachment',
    }),
    attachmentId: z.string().register(z.globalRegistry, {
      description: 'The ID of the attachment',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const put_streams_streamname_attachments_attachmenttype_attachmentid_request = z.object({
  body: z.optional(z.union([z.record(z.string(), z.never()), z.enum(['null']), z.unknown()])),
  path: z.object({
    streamName: z.string().register(z.globalRegistry, {
      description: 'The name of the stream',
    }),
    attachmentType: z.enum(['dashboard', 'rule']).register(z.globalRegistry, {
      description: 'The type of the attachment',
    }),
    attachmentId: z.string().register(z.globalRegistry, {
      description: 'The ID of the attachment',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'A required header to protect against CSRF attacks',
    }),
  }),
});

export const post_synthetics_monitor_test_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    monitorId: z.string().register(z.globalRegistry, {
      description: 'The ID (config_id) of the monitor to test.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Test run triggered successfully.
 */
export const post_synthetics_monitor_test_response = z
  .object({
    errors: z.optional(
      z
        .array(
          z.object({
            error: z.object({
              failed_monitors: z.union([z.array(z.record(z.string(), z.unknown())), z.null()]),
              reason: z.string().register(z.globalRegistry, {
                description: 'Human-readable explanation of the failure.',
              }),
              status: z.int().register(z.globalRegistry, {
                description: 'HTTP status code returned by the agent.',
              }),
            }),
            locationId: z.string().register(z.globalRegistry, {
              description: 'Identifier of the service location where the error occurred.',
            }),
          })
        )
        .register(z.globalRegistry, {
          description:
            'Array of errors encountered while triggering the test, one per service location.',
        })
    ),
    testRunId: z.string().register(z.globalRegistry, {
      description: 'Unique identifier for the triggered test run.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Test run triggered successfully.',
  });

export const get_synthetic_monitors_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      filter: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Additional filtering criteria.',
        })
      ),
      locations: z.optional(z.union([z.string(), z.array(z.unknown())])),
      monitorTypes: z.optional(
        z.union([
          z.literal('browser'),
          z.literal('http'),
          z.literal('icmp'),
          z.literal('tcp'),
          z.array(z.unknown()),
        ])
      ),
      page: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The page number for paginated results.',
        })
      ),
      per_page: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of items to return per page.',
        })
      ),
      projects: z.optional(z.union([z.string(), z.array(z.unknown())])),
      query: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'A free-text query string.',
        })
      ),
      schedules: z.optional(z.union([z.array(z.unknown()), z.string()])),
      sortField: z.optional(
        z.enum(['name', 'createdAt', 'updatedAt', 'status']).register(z.globalRegistry, {
          description: 'The field to sort the results by.',
        })
      ),
      sortOrder: z.optional(
        z.enum(['asc', 'desc']).register(z.globalRegistry, {
          description: 'The sort order.',
        })
      ),
      status: z.optional(z.union([z.array(z.unknown()), z.string()])),
      tags: z.optional(z.union([z.string(), z.array(z.unknown())])),
      useLogicalAndFor: z.optional(
        z.union([z.literal('tags'), z.literal('locations'), z.array(z.enum(['tags', 'locations']))])
      ),
    })
  ),
});

/**
 * A successful response.
 */
export const get_synthetic_monitors_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'A successful response.',
  });

export const post_synthetic_monitors_request = z.object({
  body: z.union([
    z
      .object({
        type: z.literal('Synthetics_browserMonitorFields'),
      })
      .and(synthetics_browser_monitor_fields),
    z
      .object({
        type: z.literal('Synthetics_httpMonitorFields'),
      })
      .and(synthetics_http_monitor_fields),
    z
      .object({
        type: z.literal('Synthetics_icmpMonitorFields'),
      })
      .and(synthetics_icmp_monitor_fields),
    z
      .object({
        type: z.literal('Synthetics_tcpMonitorFields'),
      })
      .and(synthetics_tcp_monitor_fields),
  ]),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const delete_synthetic_monitors_request = z.object({
  body: z.object({
    ids: z.array(z.string()).register(z.globalRegistry, {
      description: 'An array of monitor IDs to delete.',
    }),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const delete_synthetic_monitors_response = z
  .array(
    z
      .object({
        deleted: z.optional(
          z.boolean().register(z.globalRegistry, {
            description:
              'If it is `true`, the monitor was successfully deleted If it is `false`, the monitor was not deleted.\n',
          })
        ),
        ids: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'The unique identifier of the deleted monitor.',
          })
        ),
      })
      .register(z.globalRegistry, {
        description: 'The API response includes information about the deleted monitors.',
      })
  )
  .register(z.globalRegistry, {
    description: 'A successful response.',
  });

export const delete_synthetic_monitor_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the monitor that you want to delete.',
    }),
  }),
  query: z.optional(z.never()),
});

export const get_synthetic_monitor_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The ID of the monitor.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const get_synthetic_monitor_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'A successful response.',
  });

export const put_synthetic_monitor_request = z.object({
  body: z.union([
    z
      .object({
        type: z.literal('Synthetics_browserMonitorFields'),
      })
      .and(synthetics_browser_monitor_fields),
    z
      .object({
        type: z.literal('Synthetics_httpMonitorFields'),
      })
      .and(synthetics_http_monitor_fields),
    z
      .object({
        type: z.literal('Synthetics_icmpMonitorFields'),
      })
      .and(synthetics_icmp_monitor_fields),
    z
      .object({
        type: z.literal('Synthetics_tcpMonitorFields'),
      })
      .and(synthetics_tcp_monitor_fields),
  ]),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The identifier for the monitor that you want to update.',
    }),
  }),
  query: z.optional(z.never()),
});

export const get_parameters_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const get_parameters_response = z
  .array(synthetics_get_parameter_response)
  .register(z.globalRegistry, {
    description: 'A successful response.',
  });

export const post_parameters_request = z.object({
  body: z.union([z.array(synthetics_parameter_request), synthetics_parameter_request]),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const post_parameters_response = z.union([
  z.array(synthetics_post_parameter_response),
  synthetics_post_parameter_response,
]);

export const delete_parameters_request = z.object({
  body: z.object({
    ids: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description: 'An array of parameter IDs to delete.',
      })
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const delete_parameters_response = z
  .array(
    z.object({
      deleted: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Indicates whether the parameter was successfully deleted. It is `true` if it was deleted. It is `false` if it was not deleted.\n',
        })
      ),
      id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The unique identifier for the deleted parameter.',
        })
      ),
    })
  )
  .register(z.globalRegistry, {
    description: 'A successful response.',
  });

export const delete_parameter_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The ID for the parameter to delete.',
    }),
  }),
  query: z.optional(z.never()),
});

export const get_parameter_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The unique identifier for the parameter.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const get_parameter_response = synthetics_get_parameter_response;

export const put_parameter_request = z.object({
  body: z
    .object({
      description: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The updated description of the parameter.',
        })
      ),
      key: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The key of the parameter.',
        })
      ),
      tags: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'An array of updated tags to categorize the parameter.',
        })
      ),
      value: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The updated value associated with the parameter.',
        })
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request body cannot be empty; at least one attribute is required.',
    }),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The unique identifier for the parameter.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const put_parameter_response = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
  description: 'A successful response.',
});

export const get_private_locations_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const get_private_locations_response = z
  .array(synthetics_get_private_location)
  .register(z.globalRegistry, {
    description: 'A successful response.',
  });

export const post_private_location_request = z.object({
  body: z.object({
    agentPolicyId: z.string().register(z.globalRegistry, {
      description: 'The ID of the agent policy associated with the private location.',
    }),
    geo: z.optional(
      z
        .object({
          lat: z.number().register(z.globalRegistry, {
            description: 'The latitude of the location.',
          }),
          lon: z.number().register(z.globalRegistry, {
            description: 'The longitude of the location.',
          }),
        })
        .register(z.globalRegistry, {
          description: 'Geographic coordinates (WGS84) for the location.',
        })
    ),
    label: z.string().register(z.globalRegistry, {
      description: 'A label for the private location.',
    }),
    spaces: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          'An array of space IDs where the private location is available. If it is not provided, the private location is available in all spaces.\n',
      })
    ),
    tags: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description: 'An array of tags to categorize the private location.',
      })
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const post_private_location_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'A successful response.',
  });

export const delete_private_location_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().min(1).max(1024).register(z.globalRegistry, {
      description: 'The unique identifier of the private location to be deleted.',
    }),
  }),
  query: z.optional(z.never()),
});

export const get_private_location_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'A private location identifier or label.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const get_private_location_response = synthetics_get_private_location;

export const put_private_location_request = z.object({
  body: z.object({
    label: z.string().min(1).register(z.globalRegistry, {
      description: 'A new label for the private location. Must be at least 1 character long.',
    }),
  }),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'The unique identifier of the private location to be updated.',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const put_private_location_response = synthetics_get_private_location;

export const task_manager_health_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const task_manager_health_response = task_manager_health_ap_is_health_response;

export const delete_timelines_request = z.object({
  body: z
    .object({
      savedObjectIds: z.array(z.string()).register(z.globalRegistry, {
        description: 'The list of IDs of the Timelines or Timeline templates to delete',
      }),
      searchIds: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'Saved search IDs that should be deleted alongside the timelines',
        })
      ),
    })
    .register(z.globalRegistry, {
      description: 'The IDs of the Timelines or Timeline templates to delete.',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const get_timeline_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      template_timeline_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The `savedObjectId` of the template timeline to retrieve',
        })
      ),
      id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The `savedObjectId` of the Timeline to retrieve.',
        })
      ),
    })
  ),
});

/**
 * Indicates that the (template) Timeline was found and returned.
 */
export const get_timeline_response = security_timeline_api_timeline_response;

export const patch_timeline_request = z.object({
  body: z
    .object({
      timeline: security_timeline_api_saved_timeline,
      timelineId: z.union([z.string(), z.null()]),
      version: z.union([z.string(), z.null()]),
    })
    .register(z.globalRegistry, {
      description: 'The Timeline updates, along with the Timeline ID and version.',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates that the Timeline was successfully updated.
 */
export const patch_timeline_response = security_timeline_api_timeline_response;

export const create_timelines_request = z.object({
  body: z
    .object({
      status: z.optional(security_timeline_api_timeline_status),
      templateTimelineId: z.optional(z.union([z.string(), z.null()])),
      templateTimelineVersion: z.optional(z.union([z.number(), z.null()])),
      timeline: security_timeline_api_saved_timeline,
      timelineId: z.optional(z.union([z.string(), z.null()])),
      timelineType: z.optional(security_timeline_api_timeline_type),
      version: z.optional(z.union([z.string(), z.null()])),
    })
    .register(z.globalRegistry, {
      description:
        'The required Timeline fields used to create a new Timeline, along with optional fields that will be created if not provided.',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates the Timeline was successfully created.
 */
export const create_timelines_response = security_timeline_api_timeline_response;

export const copy_timeline_request = z.object({
  body: z.object({
    timeline: security_timeline_api_saved_timeline,
    timelineIdToCopy: z.string(),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates that the timeline has been successfully copied.
 */
export const copy_timeline_response = security_timeline_api_timeline_response;

export const get_draft_timelines_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    timelineType: security_timeline_api_timeline_type,
  }),
});

/**
 * Indicates that the draft Timeline was successfully retrieved.
 */
export const get_draft_timelines_response = security_timeline_api_timeline_response;

export const clean_draft_timelines_request = z.object({
  body: z
    .object({
      timelineType: security_timeline_api_timeline_type,
    })
    .register(z.globalRegistry, {
      description: 'The type of Timeline to create. Valid values are `default` and `template`.',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates that the draft Timeline was successfully created. In the event the user already has a draft Timeline, the existing draft Timeline is cleared and returned.
 */
export const clean_draft_timelines_response = security_timeline_api_timeline_response;

export const export_timelines_request = z.object({
  body: z
    .object({
      ids: z.optional(z.union([z.array(z.string()), z.null()])),
    })
    .register(z.globalRegistry, {
      description: 'The IDs of the Timelines to export.',
    }),
  path: z.optional(z.never()),
  query: z.object({
    file_name: z.string().register(z.globalRegistry, {
      description: 'The name of the file to export',
    }),
  }),
});

/**
 * NDJSON of the exported Timelines
 */
export const export_timelines_response = z.string().register(z.globalRegistry, {
  description: 'NDJSON of the exported Timelines',
});

export const persist_favorite_route_request = z.object({
  body: z
    .object({
      templateTimelineId: z.union([z.string(), z.null()]),
      templateTimelineVersion: z.union([z.number(), z.null()]),
      timelineId: z.union([z.string(), z.null()]),
      timelineType: security_timeline_api_timeline_type,
    })
    .register(z.globalRegistry, {
      description: 'The required fields used to favorite a (template) Timeline.',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates the favorite status was successfully updated.
 */
export const persist_favorite_route_response = security_timeline_api_favorite_timeline_response;

export const import_timelines_request = z.object({
  body: z
    .object({
      file: z.unknown(),
      isImmutable: z.optional(
        z.enum(['true', 'false']).register(z.globalRegistry, {
          description: 'Whether the Timeline should be immutable',
        })
      ),
    })
    .register(z.globalRegistry, {
      description: 'The Timelines to import as a readable stream.',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates the import of Timelines was successful.
 */
export const import_timelines_response = security_timeline_api_import_timeline_result;

export const install_prepacked_timelines_request = z.object({
  body: z
    .object({
      prepackagedTimelines: z.array(security_timeline_api_timeline_saved_to_return_object),
      timelinesToInstall: z.array(security_timeline_api_import_timelines),
      timelinesToUpdate: z.array(security_timeline_api_import_timelines),
    })
    .register(z.globalRegistry, {
      description: 'The Timelines to install or update.',
    }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates the installation of prepackaged Timelines was successful.
 */
export const install_prepacked_timelines_response = security_timeline_api_import_timeline_result;

export const resolve_timeline_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      template_timeline_id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The ID of the template timeline to resolve',
        })
      ),
      id: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The ID of the timeline to resolve',
        })
      ),
    })
  ),
});

/**
 * The (template) Timeline has been found
 */
export const resolve_timeline_response = security_timeline_api_resolved_timeline;

export const get_timelines_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      only_user_favorite: z.optional(
        z.enum(['true', 'false']).register(z.globalRegistry, {
          description:
            'If true, only timelines that are marked as favorites by the user are returned.',
        })
      ),
      timeline_type: z.optional(security_timeline_api_timeline_type),
      sort_field: z.optional(security_timeline_api_sort_field_timeline),
      sort_order: z.optional(
        z.enum(['asc', 'desc']).register(z.globalRegistry, {
          description: 'Whether to sort the results `ascending` or `descending`',
        })
      ),
      page_size: z.optional(z.union([z.string(), z.null()])),
      page_index: z.optional(z.union([z.string(), z.null()])),
      search: z.optional(z.union([z.string(), z.null()])),
      status: z.optional(security_timeline_api_timeline_status),
    })
  ),
});

/**
 * Indicates that the (template) Timelines were found and returned.
 */
export const get_timelines_response = z
  .object({
    customTemplateTimelineCount: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'The amount of custom Timeline templates in the results',
      })
    ),
    defaultTimelineCount: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'The amount of `default` type Timelines in the results',
      })
    ),
    elasticTemplateTimelineCount: z.optional(
      z.number().register(z.globalRegistry, {
        description: "The amount of Elastic's Timeline templates in the results",
      })
    ),
    favoriteCount: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'The amount of favorited Timelines',
      })
    ),
    templateTimelineCount: z.optional(
      z.number().register(z.globalRegistry, {
        description: 'The amount of Timeline templates in the results',
      })
    ),
    timeline: z.array(security_timeline_api_timeline_response),
    totalCount: z.number().register(z.globalRegistry, {
      description: 'The total amount of results',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Indicates that the (template) Timelines were found and returned.',
  });

export const get_upgrade_status_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const get_uptime_settings_request = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const get_uptime_settings_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call',
  });

export const put_uptime_settings_request = z.object({
  body: z.optional(
    z.object({
      certAgeThreshold: z
        .optional(
          z.number().register(z.globalRegistry, {
            description: 'The number of days after a certificate is created to trigger an alert.',
          })
        )
        .default(730),
      certExpirationThreshold: z
        .optional(
          z.number().register(z.globalRegistry, {
            description: 'The number of days before a certificate expires to trigger an alert.',
          })
        )
        .default(30),
      defaultConnectors: z
        .optional(
          z.array(z.unknown()).register(z.globalRegistry, {
            description: 'A list of connector IDs to be used as default connectors for new alerts.',
          })
        )
        .default([]),
      defaultEmail: z.optional(
        z
          .object({
            bcc: z.optional(z.array(z.string())).default([]),
            cc: z.optional(z.array(z.string())).default([]),
            to: z.optional(z.array(z.string())).default([]),
          })
          .register(z.globalRegistry, {
            description: 'The default email configuration for new alerts.\n',
          })
      ),
      heartbeatIndices: z
        .optional(
          z.string().register(z.globalRegistry, {
            description:
              'An index pattern string to be used within the Uptime app and alerts to query Heartbeat data. \n',
          })
        )
        .default('heartbeat-*'),
    })
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Indicates a successful call
 */
export const put_uptime_settings_response = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description: 'Indicates a successful call',
  });

export const find_slos_op_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
  }),
  query: z.optional(
    z.object({
      kqlQuery: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'A valid kql query to filter the SLO with',
        })
      ),
      size: z
        .optional(
          z.int().register(z.globalRegistry, {
            description:
              'The page size to use for cursor-based pagination, must be greater or equal than 1',
          })
        )
        .default(1),
      searchAfter: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description:
            'The cursor to use for fetching the results from, when using a cursor-base pagination.',
        })
      ),
      page: z
        .optional(
          z.int().register(z.globalRegistry, {
            description: 'The page to use for pagination, must be greater or equal than 1',
          })
        )
        .default(1),
      perPage: z
        .optional(
          z.int().lte(5000).register(z.globalRegistry, {
            description: 'Number of SLOs returned by page',
          })
        )
        .default(25),
      sortBy: z.optional(
        z
          .enum(['sli_value', 'status', 'error_budget_consumed', 'error_budget_remaining'])
          .register(z.globalRegistry, {
            description: 'Sort by field',
          })
      ),
      sortDirection: z.optional(
        z.enum(['asc', 'desc']).register(z.globalRegistry, {
          description: 'Sort order',
        })
      ),
      hideStale: z.optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Hide stale SLOs from the list as defined by stale SLO threshold in SLO settings',
        })
      ),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const find_slos_op_response = sl_os_find_slo_response;

export const create_slo_op_request = z.object({
  body: sl_os_create_slo_request,
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const create_slo_op_response = sl_os_create_slo_response;

export const bulk_delete_op_request = z.object({
  body: sl_os_bulk_delete_request,
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful response
 */
export const bulk_delete_op_response = sl_os_bulk_delete_response;

export const bulk_delete_status_op_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
    taskId: z.string().register(z.globalRegistry, {
      description: 'The task id of the bulk delete operation',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful response
 */
export const bulk_delete_status_op_response = sl_os_bulk_delete_status_response;

export const delete_rollup_data_op_request = z.object({
  body: sl_os_bulk_purge_rollup_request,
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const delete_rollup_data_op_response = sl_os_bulk_purge_rollup_response;

export const delete_slo_instances_op_request = z.object({
  body: sl_os_delete_slo_instances_request,
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const delete_slo_instances_op_response = z.void().register(z.globalRegistry, {
  description: 'Successful request',
});

export const delete_slo_op_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
    sloId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the slo.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const delete_slo_op_response = z.void().register(z.globalRegistry, {
  description: 'Successful request',
});

export const get_slo_op_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
    sloId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the slo.',
    }),
  }),
  query: z.optional(
    z.object({
      instanceId: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'the specific instanceId used by the summary calculation',
        })
      ),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const get_slo_op_response = sl_os_slo_with_summary_response;

export const update_slo_op_request = z.object({
  body: sl_os_update_slo_request,
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
    sloId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the slo.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const update_slo_op_response = sl_os_slo_definition_response;

export const reset_slo_op_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
    sloId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the slo.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const reset_slo_op_response = sl_os_slo_definition_response;

export const disable_slo_op_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
    sloId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the slo.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const disable_slo_op_response = z.void().register(z.globalRegistry, {
  description: 'Successful request',
});

export const enable_slo_op_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
    sloId: z.string().register(z.globalRegistry, {
      description: 'An identifier for the slo.',
    }),
  }),
  query: z.optional(z.never()),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const enable_slo_op_response = z.void().register(z.globalRegistry, {
  description: 'Successful request',
});

export const get_definitions_op_request = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spaceId: z.string().register(z.globalRegistry, {
      description:
        'An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.',
    }),
  }),
  query: z.optional(
    z.object({
      includeOutdatedOnly: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Indicates if the API returns only outdated SLO or all SLO definitions',
        })
      ),
      includeHealth: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Indicates if the API returns SLO health data with definitions',
        })
      ),
      tags: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Filters the SLOs by tag',
        })
      ),
      search: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Filters the SLOs by name',
        })
      ),
      page: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'The page to use for pagination, must be greater or equal than 1',
        })
      ),
      perPage: z
        .optional(
          z.int().lte(1000).register(z.globalRegistry, {
            description: 'Number of SLOs returned by page',
          })
        )
        .default(100),
    })
  ),
  headers: z.object({
    'kbn-xsrf': z.string().register(z.globalRegistry, {
      description: 'Cross-site request forgery protection',
    }),
  }),
});

/**
 * Successful request
 */
export const get_definitions_op_response = sl_os_find_slo_definitions_response;
