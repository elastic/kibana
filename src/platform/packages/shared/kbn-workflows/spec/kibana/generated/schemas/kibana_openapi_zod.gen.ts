// This file is auto-generated by @hey-api/openapi-ts

import { z } from '@kbn/zod/v4';

export const security_detections_api_siem_error_response = z.object({
    message: z.string(),
    status_code: z.int()
});

/**
 * Use alert tags to organize related alerts into categories that you can filter and group.
 */
export const security_detections_api_alert_tag = z.string().min(1).register(z.globalRegistry, {
    description: 'Use alert tags to organize related alerts into categories that you can filter and group.'
});

/**
 * List of keywords to organize related alerts into categories that you can filter and group.
 */
export const security_detections_api_alert_tags = z.array(security_detections_api_alert_tag).register(z.globalRegistry, {
    description: 'List of keywords to organize related alerts into categories that you can filter and group.'
});

/**
 * Object with list of tags to add and remove.
 */
export const security_detections_api_set_alert_tags = z.object({
    tags_to_add: security_detections_api_alert_tags,
    tags_to_remove: security_detections_api_alert_tags
}).register(z.globalRegistry, {
    description: 'Object with list of tags to add and remove.'
});

/**
 * A list of alerts `id`s.
 */
export const security_detections_api_alert_ids = z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
    description: 'A list of alerts `id`s.'
});

export const security_detections_api_set_alert_tags_body = z.object({
    ids: security_detections_api_alert_ids,
    tags: security_detections_api_set_alert_tags
});

/**
 * The status of an alert, which can be `open`, `acknowledged`, `in-progress`, or `closed`.
 */
export const security_detections_api_alert_status_except_closed = z.enum([
    'open',
    'acknowledged',
    'in-progress'
]).register(z.globalRegistry, {
    description: 'The status of an alert, which can be `open`, `acknowledged`, `in-progress`, or `closed`.'
});

export const security_detections_api_set_alerts_status_by_query_base = z.object({
    conflicts: z.optional(z.enum(['abort', 'proceed'])),
    query: z.record(z.string(), z.unknown()),
    status: security_detections_api_alert_status_except_closed
});

/**
 * The reason for closing the alerts
 */
export const security_detections_api_reason_enum = z.enum([
    'false_positive',
    'duplicate',
    'true_positive',
    'benign_positive',
    'automated_closure',
    'other'
]).register(z.globalRegistry, {
    description: 'The reason for closing the alerts'
});

export const security_detections_api_close_alerts_by_query = z.object({
    conflicts: z.optional(z.enum(['abort', 'proceed'])),
    query: z.record(z.string(), z.unknown()),
    reason: z.optional(security_detections_api_reason_enum),
    status: z.enum(['closed'])
});

export const security_detections_api_set_alerts_status_by_query = z.union([
    security_detections_api_close_alerts_by_query,
    security_detections_api_set_alerts_status_by_query_base
]);

export const security_detections_api_set_alerts_status_by_ids_base = z.object({
    signal_ids: z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'List of alert ids. Use field `_id` on alert document or `kibana.alert.uuid`. Note: signals are a deprecated term for alerts.'
    }),
    status: security_detections_api_alert_status_except_closed
});

export const security_detections_api_close_alerts_by_ids = z.object({
    reason: z.optional(security_detections_api_reason_enum),
    signal_ids: z.array(z.string().min(1)).min(1).register(z.globalRegistry, {
        description: 'List of alert ids. Use field `_id` on alert document or `kibana.alert.uuid`. Note: signals are a deprecated term for alerts.'
    }),
    status: z.enum(['closed'])
});

export const security_detections_api_set_alerts_status_by_ids = z.union([
    security_detections_api_close_alerts_by_ids,
    security_detections_api_set_alerts_status_by_ids_base
]);

export const security_detections_api_platform_error_response = z.object({
    error: z.string(),
    message: z.string(),
    statusCode: z.int()
});

/**
 * Case response properties for updated_by
 */
export const cases_case_response_updated_by_properties = z.union([
    z.object({
        email: z.union([
            z.string(),
            z.null()
        ]),
        full_name: z.union([
            z.string(),
            z.null()
        ]),
        profile_uid: z.optional(z.string()),
        username: z.union([
            z.string(),
            z.null()
        ])
    }),
    z.null()
]);

/**
 * Case response properties for pushed_by
 */
export const cases_case_response_pushed_by_properties = z.union([
    z.object({
        email: z.union([
            z.string(),
            z.null()
        ]),
        full_name: z.union([
            z.string(),
            z.null()
        ]),
        profile_uid: z.optional(z.string()),
        username: z.union([
            z.string(),
            z.null()
        ])
    }),
    z.null()
]);

/**
 * The application that owns the cases: Stack Management, Observability, or Elastic Security.
 *
 */
export const cases_owner = z.enum([
    'cases',
    'observability',
    'securitySolution'
]).register(z.globalRegistry, {
    description: 'The application that owns the cases: Stack Management, Observability, or Elastic Security.\n'
});

/**
 * Case response properties for created_by
 */
export const cases_case_response_created_by_properties = z.object({
    email: z.union([
        z.string(),
        z.null()
    ]),
    full_name: z.union([
        z.string(),
        z.null()
    ]),
    profile_uid: z.optional(z.string()),
    username: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Case response properties for user comments
 */
export const cases_user_comment_response_properties = z.object({
    comment: z.optional(z.string()),
    created_at: z.optional(z.iso.datetime()),
    created_by: z.optional(cases_case_response_created_by_properties),
    id: z.optional(z.string()),
    owner: z.optional(cases_owner),
    pushed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    pushed_by: z.optional(cases_case_response_pushed_by_properties),
    type: z.enum(['user']),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    updated_by: z.optional(cases_case_response_updated_by_properties),
    version: z.optional(z.string())
});

/**
 * The status of the case.
 */
export const cases_case_status = z.enum([
    'closed',
    'in-progress',
    'open'
]).register(z.globalRegistry, {
    description: 'The status of the case.'
});

/**
 * The severity of the case.
 */
export const cases_case_severity = z.enum([
    'critical',
    'high',
    'low',
    'medium'
]).register(z.globalRegistry, {
    description: 'The severity of the case.'
});

/**
 * An object that contains the case settings.
 */
export const cases_settings = z.object({
    syncAlerts: z.boolean().register(z.globalRegistry, {
        description: 'Turns alert syncing on or off.'
    })
}).register(z.globalRegistry, {
    description: 'An object that contains the case settings.'
});

export const cases_external_service = z.union([
    z.object({
        connector_id: z.optional(z.string()),
        connector_name: z.optional(z.string()),
        external_id: z.optional(z.string()),
        external_title: z.optional(z.string()),
        external_url: z.optional(z.string()),
        pushed_at: z.optional(z.iso.datetime()),
        pushed_by: z.optional(z.union([
            z.object({
                email: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                full_name: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                profile_uid: z.optional(z.string()),
                username: z.optional(z.union([
                    z.string(),
                    z.null()
                ]))
            }),
            z.null()
        ]))
    }),
    z.null()
]);

/**
 * An array containing users that are assigned to the case.
 */
export const cases_assignees = z.union([
    z.array(z.object({
        uid: z.string().register(z.globalRegistry, {
            description: 'A unique identifier for the user profile. These identifiers can be found by using the suggest user profile API.'
        })
    })).max(10),
    z.null()
]);

/**
 * A title for the case.
 */
export const cases_case_title = z.string().max(160).register(z.globalRegistry, {
    description: 'A title for the case.'
});

/**
 * The words and phrases that help categorize cases. It can be an empty array.
 *
 */
export const cases_case_tags = z.array(z.string().max(256)).max(200).register(z.globalRegistry, {
    description: 'The words and phrases that help categorize cases. It can be an empty array.\n'
});

/**
 * The description for the case.
 */
export const cases_case_description = z.string().max(30000).register(z.globalRegistry, {
    description: 'The description for the case.'
});

/**
 * Create case request properties for a Swimlane connector
 *
 * Defines properties for connectors when type is `.swimlane`.
 */
export const cases_connector_properties_swimlane = z.object({
    fields: z.object({
        caseId: z.union([
            z.string(),
            z.null()
        ])
    }).register(z.globalRegistry, {
        description: 'An object containing the connector fields. If you want to omit any individual field, specify null as its value.'
    }),
    id: z.string().register(z.globalRegistry, {
        description: 'The identifier for the connector. To retrieve connector IDs, use the find connectors API.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The name of the connector.'
    }),
    type: z.enum(['.swimlane']).register(z.globalRegistry, {
        description: 'The type of connector.'
    })
}).register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.swimlane`.'
});

/**
 * Create case request properties for a ServiceNow SecOps connector
 *
 * Defines properties for connectors when type is `.servicenow-sir`.
 */
export const cases_connector_properties_servicenow_sir = z.object({
    fields: z.object({
        category: z.union([
            z.string(),
            z.null()
        ]),
        destIp: z.union([
            z.boolean(),
            z.null()
        ]),
        malwareHash: z.union([
            z.boolean(),
            z.null()
        ]),
        malwareUrl: z.union([
            z.boolean(),
            z.null()
        ]),
        priority: z.union([
            z.string(),
            z.null()
        ]),
        sourceIp: z.union([
            z.boolean(),
            z.null()
        ]),
        subcategory: z.union([
            z.string(),
            z.null()
        ])
    }).register(z.globalRegistry, {
        description: 'An object containing the connector fields. If you want to omit any individual field, specify null as its value.'
    }),
    id: z.string().register(z.globalRegistry, {
        description: 'The identifier for the connector. To retrieve connector IDs, use the find connectors API.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The name of the connector.'
    }),
    type: z.enum(['.servicenow-sir']).register(z.globalRegistry, {
        description: 'The type of connector.'
    })
}).register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.servicenow-sir`.'
});

/**
 * Create case request properties for a ServiceNow ITSM connector
 *
 * Defines properties for connectors when type is `.servicenow`.
 */
export const cases_connector_properties_servicenow = z.object({
    fields: z.object({
        category: z.union([
            z.string(),
            z.null()
        ]),
        impact: z.union([
            z.string(),
            z.null()
        ]),
        severity: z.union([
            z.string(),
            z.null()
        ]),
        subcategory: z.union([
            z.string(),
            z.null()
        ]),
        urgency: z.union([
            z.string(),
            z.null()
        ])
    }).register(z.globalRegistry, {
        description: 'An object containing the connector fields. If you want to omit any individual field, specify null as its value.'
    }),
    id: z.string().register(z.globalRegistry, {
        description: 'The identifier for the connector. To retrieve connector IDs, use the find connectors API.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The name of the connector.'
    }),
    type: z.enum(['.servicenow']).register(z.globalRegistry, {
        description: 'The type of connector.'
    })
}).register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.servicenow`.'
});

/**
 * Create case request properties for a IBM Resilient connector
 *
 * Defines properties for connectors when type is `.resilient`.
 */
export const cases_connector_properties_resilient = z.object({
    fields: z.union([
        z.object({
            issueTypes: z.array(z.string()).register(z.globalRegistry, {
                description: 'The type of incident.'
            }),
            severityCode: z.string().register(z.globalRegistry, {
                description: 'The severity code of the incident.'
            })
        }),
        z.null()
    ]),
    id: z.string().register(z.globalRegistry, {
        description: 'The identifier for the connector.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The name of the connector.'
    }),
    type: z.enum(['.resilient']).register(z.globalRegistry, {
        description: 'The type of connector.'
    })
}).register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.resilient`.'
});

/**
 * Create or update case request properties for a Jira connector
 *
 * Defines properties for connectors when type is `.jira`.
 */
export const cases_connector_properties_jira = z.object({
    fields: z.object({
        issueType: z.union([
            z.string(),
            z.null()
        ]),
        parent: z.union([
            z.string(),
            z.null()
        ]),
        priority: z.union([
            z.string(),
            z.null()
        ])
    }).register(z.globalRegistry, {
        description: 'An object containing the connector fields. If you want to omit any individual field, specify null as its value.'
    }),
    id: z.string().register(z.globalRegistry, {
        description: 'The identifier for the connector. To retrieve connector IDs, use the find connectors API.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The name of the connector.'
    }),
    type: z.enum(['.jira']).register(z.globalRegistry, {
        description: 'The type of connector.'
    })
}).register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.jira`.'
});

/**
 * Create or upate case request properties for Cases Webhook connector
 *
 * Defines properties for connectors when type is `.cases-webhook`.
 */
export const cases_connector_properties_cases_webhook = z.object({
    fields: z.union([
        z.string(),
        z.null()
    ]),
    id: z.string().register(z.globalRegistry, {
        description: 'The identifier for the connector. To retrieve connector IDs, use the find connectors API.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The name of the connector.'
    }),
    type: z.enum(['.cases-webhook']).register(z.globalRegistry, {
        description: 'The type of connector.'
    })
}).register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.cases-webhook`.'
});

/**
 * Create or update case request properties for no connector
 *
 * Defines properties for connectors when type is `.none`.
 */
export const cases_connector_properties_none = z.object({
    fields: z.union([
        z.string(),
        z.null()
    ]),
    id: z.string().register(z.globalRegistry, {
        description: 'The identifier for the connector. To create a case without a connector, use `none`. To update a case to remove the connector, specify `none`.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The name of the connector. To create a case without a connector, use `none`. To update a case to remove the connector, specify `none`.'
    }),
    type: z.enum(['.none']).register(z.globalRegistry, {
        description: 'The type of connector. To create a case without a connector, use `.none`. To update a case to remove the connector, specify `.none`.'
    })
}).register(z.globalRegistry, {
    description: 'Defines properties for connectors when type is `.none`.'
});

/**
 * A word or phrase that categorizes the case.
 */
export const cases_case_category = z.string().max(50).register(z.globalRegistry, {
    description: 'A word or phrase that categorizes the case.'
});

/**
 * Update case request
 *
 * The update case API request body varies depending on the type of connector.
 */
export const cases_update_case_request = z.object({
    cases: z.array(z.object({
        assignees: z.optional(cases_assignees),
        category: z.optional(cases_case_category),
        connector: z.optional(z.union([
            cases_connector_properties_none,
            cases_connector_properties_cases_webhook,
            cases_connector_properties_jira,
            cases_connector_properties_resilient,
            cases_connector_properties_servicenow,
            cases_connector_properties_servicenow_sir,
            cases_connector_properties_swimlane
        ])),
        customFields: z.optional(z.array(z.object({
            key: z.string().register(z.globalRegistry, {
                description: 'The unique identifier for the custom field. The key value must exist in the case configuration settings.\n'
            }),
            type: z.enum(['text', 'toggle']).register(z.globalRegistry, {
                description: 'The custom field type. It must match the type specified in the case configuration settings.\n'
            }),
            value: z.union([
                z.string().min(1).max(160),
                z.null(),
                z.boolean()
            ])
        })).min(0).max(10).register(z.globalRegistry, {
            description: 'Custom field values for a case. Any optional custom fields that are not specified in the request are set to null.\n'
        })),
        description: z.optional(cases_case_description),
        id: z.string().max(30000).register(z.globalRegistry, {
            description: 'The identifier for the case.'
        }),
        settings: z.optional(cases_settings),
        severity: z.optional(cases_case_severity),
        status: z.optional(cases_case_status),
        tags: z.optional(cases_case_tags),
        title: z.optional(cases_case_title),
        version: z.string().register(z.globalRegistry, {
            description: 'The current version of the case. To determine this value, use the get case or search cases (`_find`) APIs.\n'
        })
    })).min(1).max(100).register(z.globalRegistry, {
        description: 'An array containing one or more case objects.'
    })
}).register(z.globalRegistry, {
    description: 'The update case API request body varies depending on the type of connector.'
});

/**
 * Alerting rule
 *
 * The rule that is associated with the alerts. It is required only when `type` is `alert`. This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.
 *
 */
export const cases_rule = z.object({
    id: z.optional(z.string().register(z.globalRegistry, {
        description: 'The rule identifier.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The rule name.'
    }))
}).register(z.globalRegistry, {
    description: 'The rule that is associated with the alerts. It is required only when `type` is `alert`. This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.\n'
});

/**
 * Alert indices
 *
 * The alert indices. It is required only when `type` is `alert`. If you are adding multiple alerts to a case, use an array of strings; the position of each index name in the array must match the position of the corresponding alert identifier in the `alertId` array.  This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.
 *
 */
export const cases_alert_indices = z.union([
    z.string(),
    z.array(z.string()).max(1000)
]);

/**
 * Alert identifiers
 *
 * The alert identifiers. It is required only when `type` is `alert`. You can use an array of strings to add multiple alerts to a case, provided that they all relate to the same rule; `index` must also be an array with the same length or number of elements. Adding multiple alerts in this manner is recommended rather than calling the API multiple times. This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.
 *
 */
export const cases_alert_identifiers = z.union([
    z.string(),
    z.array(z.string()).max(1000)
]);

/**
 * Create case request
 *
 * The create case API request body varies depending on the type of connector.
 */
export const cases_create_case_request = z.object({
    assignees: z.optional(cases_assignees),
    category: z.optional(cases_case_category),
    connector: z.union([
        cases_connector_properties_none,
        cases_connector_properties_cases_webhook,
        cases_connector_properties_jira,
        cases_connector_properties_resilient,
        cases_connector_properties_servicenow,
        cases_connector_properties_servicenow_sir,
        cases_connector_properties_swimlane
    ]),
    customFields: z.optional(z.array(z.object({
        key: z.string().register(z.globalRegistry, {
            description: 'The unique identifier for the custom field. The key value must exist in the case configuration settings.\n'
        }),
        type: z.enum(['text', 'toggle']).register(z.globalRegistry, {
            description: 'The custom field type. It must match the type specified in the case configuration settings.\n'
        }),
        value: z.union([
            z.string().min(1).max(160),
            z.null(),
            z.boolean()
        ])
    })).min(0).max(10).register(z.globalRegistry, {
        description: 'Custom field values for a case. Any optional custom fields that are not specified in the request are set to null.\n'
    })),
    description: cases_case_description,
    owner: cases_owner,
    settings: cases_settings,
    severity: z.optional(cases_case_severity),
    tags: cases_case_tags,
    title: cases_case_title
}).register(z.globalRegistry, {
    description: 'The create case API request body varies depending on the type of connector.'
});

/**
 * Add case comment response properties for alerts
 */
export const cases_alert_comment_response_properties = z.object({
    alertId: z.optional(z.array(z.string())),
    created_at: z.optional(z.iso.datetime()),
    created_by: z.optional(z.object({
        email: z.union([
            z.string(),
            z.null()
        ]),
        full_name: z.union([
            z.string(),
            z.null()
        ]),
        profile_uid: z.optional(z.string()),
        username: z.union([
            z.string(),
            z.null()
        ])
    })),
    id: z.optional(z.string()),
    index: z.optional(z.array(z.string())),
    owner: z.optional(cases_owner),
    pushed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    pushed_by: z.optional(z.union([
        z.object({
            email: z.union([
                z.string(),
                z.null()
            ]),
            full_name: z.union([
                z.string(),
                z.null()
            ]),
            profile_uid: z.optional(z.string()),
            username: z.union([
                z.string(),
                z.null()
            ])
        }),
        z.null()
    ])),
    rule: z.optional(z.object({
        id: z.optional(z.string().register(z.globalRegistry, {
            description: 'The rule identifier.'
        })),
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'The rule name.'
        }))
    })),
    type: z.enum(['alert']),
    updated_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    updated_by: z.optional(z.union([
        z.object({
            email: z.union([
                z.string(),
                z.null()
            ]),
            full_name: z.union([
                z.string(),
                z.null()
            ]),
            profile_uid: z.optional(z.string()),
            username: z.union([
                z.string(),
                z.null()
            ])
        }),
        z.null()
    ])),
    version: z.optional(z.string())
});

/**
 * Case response properties for closed_by
 */
export const cases_case_response_closed_by_properties = z.union([
    z.object({
        email: z.union([
            z.string(),
            z.null()
        ]),
        full_name: z.union([
            z.string(),
            z.null()
        ]),
        profile_uid: z.optional(z.string()),
        username: z.union([
            z.string(),
            z.null()
        ])
    }),
    z.null()
]);

/**
 * Case response properties
 */
export const cases_case_response_properties = z.object({
    assignees: z.optional(cases_assignees),
    category: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    closed_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    closed_by: cases_case_response_closed_by_properties,
    comments: z.array(z.union([z.object({
            type: z.literal('alert')
        }).and(cases_alert_comment_response_properties), z.object({
            type: z.literal('user')
        }).and(cases_user_comment_response_properties)])).max(10000).register(z.globalRegistry, {
        description: 'An array of comment objects for the case.'
    }),
    connector: z.union([
        z.object({
            type: z.literal('.none')
        }).and(cases_connector_properties_none),
        z.object({
            type: z.literal('.cases-webhook')
        }).and(cases_connector_properties_cases_webhook),
        z.object({
            type: z.literal('.jira')
        }).and(cases_connector_properties_jira),
        z.object({
            type: z.literal('.resilient')
        }).and(cases_connector_properties_resilient),
        z.object({
            type: z.literal('.servicenow')
        }).and(cases_connector_properties_servicenow),
        z.object({
            type: z.literal('.servicenow-sir')
        }).and(cases_connector_properties_servicenow_sir),
        z.object({
            type: z.literal('.swimlane')
        }).and(cases_connector_properties_swimlane)
    ]),
    created_at: z.iso.datetime(),
    created_by: cases_case_response_created_by_properties,
    customFields: z.optional(z.array(z.object({
        key: z.optional(z.string().register(z.globalRegistry, {
            description: 'The unique identifier for the custom field. The key value must exist in the case configuration settings.\n'
        })),
        type: z.optional(z.enum(['text', 'toggle']).register(z.globalRegistry, {
            description: 'The custom field type. It must match the type specified in the case configuration settings.\n'
        })),
        value: z.optional(z.union([
            z.string().min(1).max(160),
            z.null(),
            z.boolean()
        ]))
    })).register(z.globalRegistry, {
        description: 'Custom field values for the case.'
    })),
    description: z.string(),
    duration: z.union([
        z.int(),
        z.null()
    ]),
    external_service: cases_external_service,
    id: z.string(),
    owner: cases_owner,
    settings: cases_settings,
    severity: cases_case_severity,
    status: cases_case_status,
    tags: z.array(z.string()),
    title: z.string(),
    totalAlerts: z.int(),
    totalComment: z.int(),
    updated_at: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    updated_by: cases_case_response_updated_by_properties,
    version: z.string()
});

/**
 * Add case comment request properties for user comments
 *
 * Defines properties for case comment requests when type is user.
 */
export const cases_add_user_comment_request_properties = z.object({
    comment: z.string().max(30000).register(z.globalRegistry, {
        description: 'The new comment. It is required only when `type` is `user`.'
    }),
    owner: cases_owner,
    type: z.enum(['user']).register(z.globalRegistry, {
        description: 'The type of comment.'
    })
}).register(z.globalRegistry, {
    description: 'Defines properties for case comment requests when type is user.'
});

/**
 * Add case comment request properties for alerts
 *
 * Defines properties for case comment requests when type is alert.
 */
export const cases_add_alert_comment_request_properties = z.object({
    alertId: cases_alert_identifiers,
    index: cases_alert_indices,
    owner: cases_owner,
    rule: cases_rule,
    type: z.enum(['alert']).register(z.globalRegistry, {
        description: 'The type of comment.'
    })
}).register(z.globalRegistry, {
    description: 'Defines properties for case comment requests when type is alert.'
});

/**
 * Add case comment request
 *
 * The add comment to case API request body varies depending on whether you are adding an alert or a comment.
 */
export const cases_add_case_comment_request = z.union([
    z.object({
        type: z.literal('alert')
    }).and(cases_add_alert_comment_request_properties),
    z.object({
        type: z.literal('user')
    }).and(cases_add_user_comment_request_properties)
]);

/**
 * Unsuccessful cases API response
 */
export const cases_4xx_response = z.object({
    error: z.optional(z.string()),
    message: z.optional(z.string()),
    statusCode: z.optional(z.int())
});

/**
 * Cross-site request forgery protection
 */
export const cases_kbn_xsrf = z.string().register(z.globalRegistry, {
    description: 'Cross-site request forgery protection'
});

/**
 * Deprecated in 8.1.0. This parameter is deprecated and will be removed in a future release. It determines whether case comments are returned.
 *
 * @deprecated
 */
export const cases_include_comments = z.boolean().register(z.globalRegistry, {
    description: 'Deprecated in 8.1.0. This parameter is deprecated and will be removed in a future release. It determines whether case comments are returned.'
}).default(true);

/**
 * The identifier for the case. To retrieve case IDs, use the search cases (`_find)` API. All non-ASCII characters must be URL encoded.
 */
export const cases_case_id = z.string().register(z.globalRegistry, {
    description: 'The identifier for the case. To retrieve case IDs, use the search cases (`_find)` API. All non-ASCII characters must be URL encoded.'
});

export const update_case_default_space_request = z.object({
    body: z.optional(cases_update_case_request),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'kbn-xsrf': z.string().register(z.globalRegistry, {
            description: 'Cross-site request forgery protection'
        })
    })
});

/**
 * Indicates a successful call.
 */
export const update_case_default_space_response = z.array(cases_case_response_properties).register(z.globalRegistry, {
    description: 'Indicates a successful call.'
});

export const create_case_default_space_request = z.object({
    body: cases_create_case_request,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'kbn-xsrf': z.string().register(z.globalRegistry, {
            description: 'Cross-site request forgery protection'
        })
    })
});

/**
 * Indicates a successful call.
 */
export const create_case_default_space_response = cases_case_response_properties;

export const get_case_default_space_request = z.object({
    body: z.optional(z.never()),
    path: z.object({
        caseId: z.string().register(z.globalRegistry, {
            description: 'The identifier for the case. To retrieve case IDs, use the search cases (`_find)` API. All non-ASCII characters must be URL encoded.'
        })
    }),
    query: z.optional(z.object({
        includeComments: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Deprecated in 8.1.0. This parameter is deprecated and will be removed in a future release. It determines whether case comments are returned.'
        })).default(true)
    }))
});

/**
 * Indicates a successful call.
 */
export const get_case_default_space_response = cases_case_response_properties;

export const add_case_comment_default_space_request = z.object({
    body: cases_add_case_comment_request,
    path: z.object({
        caseId: z.string().register(z.globalRegistry, {
            description: 'The identifier for the case. To retrieve case IDs, use the search cases (`_find)` API. All non-ASCII characters must be URL encoded.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'kbn-xsrf': z.string().register(z.globalRegistry, {
            description: 'Cross-site request forgery protection'
        })
    })
});

/**
 * Indicates a successful call.
 */
export const add_case_comment_default_space_response = cases_case_response_properties;

export const set_alerts_status_request = z.object({
    body: z.union([
        security_detections_api_set_alerts_status_by_ids,
        security_detections_api_set_alerts_status_by_query
    ]),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Elasticsearch update by query response
 */
export const set_alerts_status_response = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Elasticsearch update by query response'
});

export const set_alert_tags_request = z.object({
    body: security_detections_api_set_alert_tags_body,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Elasticsearch update by query response
 */
export const set_alert_tags_response = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Elasticsearch update by query response'
});
