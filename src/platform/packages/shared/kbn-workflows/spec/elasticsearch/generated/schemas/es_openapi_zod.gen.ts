// This file is auto-generated by @hey-api/openapi-ts

import { z } from '@kbn/zod/v4';

export const types_id = z.string();

/**
 * Time unit for milliseconds
 */
export const types_unit_millis = z.number().register(z.globalRegistry, {
    description: 'Time unit for milliseconds'
});

export const types_duration_value_unit_millis = types_unit_millis;

/**
 * A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
 * `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
 */
export const types_duration = z.union([
    z.string(),
    z.enum(['-1']),
    z.enum(['0'])
]);

export const types_ulong = z.number();

export const types_byte_size = z.union([
    z.number(),
    z.string()
]);

/**
 * Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
 */
export const types_field = z.string().register(z.globalRegistry, {
    description: 'Path to field or array of paths. Some API\'s support wildcards in the path to select multiple fields.'
});

export const types_uint = z.number();

export const types_epoch_time_unit_millis = types_unit_millis;

export const types_version_string = z.string();

/**
 * A date and time, either as a string whose format can depend on the context (defaulting to ISO 8601), or a
 * number of milliseconds since the Epoch. Elasticsearch accepts both as input, but will generally output a string
 * representation.
 */
export const types_date_time = z.union([
    z.string(),
    types_epoch_time_unit_millis
]);

export const types_sequence_number = z.number();

export const types_metadata = z.record(z.string(), z.record(z.string(), z.unknown()));

export const types_search_type = z.enum(['query_then_fetch', 'dfs_query_then_fetch']);

export const types_expand_wildcard = z.enum([
    'all',
    'open',
    'closed',
    'hidden',
    'none'
]);

export const types_expand_wildcards = z.union([
    types_expand_wildcard,
    z.array(types_expand_wildcard)
]);

export const types_query_dsl_query_base = z.object({
    boost: z.optional(z.number().register(z.globalRegistry, {
        description: 'Floating point number used to decrease or increase the relevance scores of the query.\nBoost values are relative to the default value of 1.0.\nA boost value between 0 and 1.0 decreases the relevance score.\nA value greater than 1.0 increases the relevance score.'
    })),
    _name: z.optional(z.string())
});

export const types_query_dsl_type_query = types_query_dsl_query_base.and(z.object({
    value: z.string()
}));

export const types_query_dsl_wrapper_query = types_query_dsl_query_base.and(z.object({
    query: z.string().register(z.globalRegistry, {
        description: 'A base64 encoded query.\nThe binary data format can be any of JSON, YAML, CBOR or SMILE encodings'
    })
}));

export const types_multi_term_query_rewrite = z.string();

export const types_query_dsl_wildcard_query = types_query_dsl_query_base.and(z.object({
    case_insensitive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Allows case insensitive matching of the pattern with the indexed field values when set to true. Default is false which means the case sensitivity of matching depends on the underlying field’s mapping.'
    })),
    rewrite: z.optional(types_multi_term_query_rewrite),
    value: z.optional(z.string().register(z.globalRegistry, {
        description: 'Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set.'
    })),
    wildcard: z.optional(z.string().register(z.globalRegistry, {
        description: 'Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set.'
    }))
}));

export const types_token_pruning_config = z.object({
    tokens_freq_ratio_threshold: z.optional(z.number().register(z.globalRegistry, {
        description: 'Tokens whose frequency is more than this threshold times the average frequency of all tokens in the specified field are considered outliers and pruned.'
    })),
    tokens_weight_threshold: z.optional(z.number().register(z.globalRegistry, {
        description: 'Tokens whose weight is less than this threshold are considered nonsignificant and pruned.'
    })),
    only_score_pruned_tokens: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether to only score pruned tokens, vs only scoring kept tokens.'
    }))
});

export const types_query_dsl_weighted_tokens_query = types_query_dsl_query_base.and(z.object({
    tokens: z.union([
        z.record(z.string(), z.number()),
        z.array(z.record(z.string(), z.number()))
    ]),
    pruning_config: z.optional(types_token_pruning_config)
}));

export const types_query_dsl_text_expansion_query = types_query_dsl_query_base.and(z.object({
    model_id: z.string().register(z.globalRegistry, {
        description: 'The text expansion NLP model to use'
    }),
    model_text: z.string().register(z.globalRegistry, {
        description: 'The query text'
    }),
    pruning_config: z.optional(types_token_pruning_config)
}));

export const types_script_language = z.union([
    z.enum([
        'painless',
        'expression',
        'mustache',
        'java'
    ]),
    z.string()
]);

export const types_mapping_runtime_field_fetch_fields = z.object({
    field: types_field,
    format: z.optional(z.string())
});

export const types_mapping_runtime_field_type = z.enum([
    'boolean',
    'composite',
    'date',
    'double',
    'geo_point',
    'geo_shape',
    'ip',
    'keyword',
    'long',
    'lookup'
]);

export const types_mapping_composite_sub_field = z.object({
    type: types_mapping_runtime_field_type
});

export const types_index_name = z.string();

export const global_search_types_point_in_time_reference = z.object({
    id: types_id,
    keep_alive: z.optional(types_duration)
});

export const global_search_types_suggester = z.object({
    text: z.optional(z.string().register(z.globalRegistry, {
        description: 'Global suggest text, to avoid repetition when the same text is used in several suggesters'
    }))
});

export const types_sliced_scroll = z.object({
    field: z.optional(types_field),
    id: types_id,
    max: z.number()
});

export const types_diversify_retriever_types = z.enum(['mmr']);

export const types_text_embedding = z.object({
    model_id: z.optional(z.string().register(z.globalRegistry, {
        description: 'Model ID is required for all dense_vector fields but\nmay be inferred for semantic_text fields'
    })),
    model_text: z.string()
});

export const types_query_vector_builder = z.object({
    text_embedding: z.optional(types_text_embedding)
});

export const types_query_vector = z.array(z.number());

export const types_specified_document = z.object({
    index: z.optional(types_index_name),
    id: types_id
});

export const types_query_dsl_terms_query = types_query_dsl_query_base.and(z.record(z.string(), z.unknown()));

/**
 * A field value.
 */
export const types_field_value = z.union([
    z.number(),
    z.string(),
    z.boolean(),
    z.null()
]);

export const types_query_dsl_term_query = z.union([
    z.string().register(z.globalRegistry, {
        description: 'Short query syntax for match query'
    }),
    types_query_dsl_query_base.and(z.object({
        value: types_field_value,
        case_insensitive: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nWhen `false`, the case sensitivity of matching depends on the underlying field’s mapping.'
        }))
    }))
]);

export const types_query_dsl_sparse_vector_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    query: z.optional(z.string().register(z.globalRegistry, {
        description: 'The query text you want to use for search.\nIf inference_id is specified, query must also be specified.'
    })),
    prune: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether to perform pruning, omitting the non-significant tokens from the query to improve query performance.\nIf prune is true but the pruning_config is not specified, pruning will occur but default values will be used.\nDefault: false'
    })),
    pruning_config: z.optional(types_token_pruning_config)
}).and(z.object({
    query_vector: z.optional(z.record(z.string(), z.number()).register(z.globalRegistry, {
        description: 'Dictionary of precomputed sparse vectors and their associated weights.\nOnly one of inference_id or query_vector may be supplied in a request.'
    })),
    inference_id: z.optional(types_id)
})));

export const types_query_dsl_span_term_query = types_query_dsl_query_base.and(z.object({
    value: types_field_value
}));

/**
 * Can only be used as a clause in a span_near query.
 */
export const types_query_dsl_span_gap_query = z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'Can only be used as a clause in a span_near query.'
});

export const types_query_dsl_simple_query_string_flag = z.enum([
    'NONE',
    'AND',
    'NOT',
    'OR',
    'PREFIX',
    'PHRASE',
    'PRECEDENCE',
    'ESCAPE',
    'WHITESPACE',
    'FUZZY',
    'NEAR',
    'SLOP',
    'ALL'
]);

/**
 * A set of flags that can be represented as a single enum value or a set of values that are encoded
 * as a pipe-separated string
 *
 * Depending on the target language, code generators can use this hint to generate language specific
 * flags enum constructs and the corresponding (de-)serialization code.
 */
export const spec_utils_pipe_separated_flags_simple_query_string_flag = z.union([
    types_query_dsl_simple_query_string_flag,
    z.string()
]);

/**
 * Query flags can be either a single flag or a combination of flags, e.g. `OR|AND|PREFIX`
 */
export const types_query_dsl_simple_query_string_flags = spec_utils_pipe_separated_flags_simple_query_string_flag;

/**
 * The minimum number of terms that should match as integer, percentage or range
 */
export const types_minimum_should_match = z.union([
    z.number(),
    z.string()
]);

export const types_query_dsl_operator = z.enum([
    'and',
    'AND',
    'or',
    'OR'
]);

export const types_query_dsl_simple_query_string_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to convert text in the query string into tokens.'
    })),
    analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the query attempts to analyze wildcard terms in the query string.'
    })),
    auto_generate_synonyms_phrase_query: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the parser creates a match_phrase query for each multi-position token.'
    })),
    default_operator: z.optional(types_query_dsl_operator),
    fields: z.optional(z.array(types_field).register(z.globalRegistry, {
        description: 'Array of fields you wish to search.\nAccepts wildcard expressions.\nYou also can boost relevance scores for matches to particular fields using a caret (`^`) notation.\nDefaults to the `index.query.default_field index` setting, which has a default value of `*`.'
    })),
    flags: z.optional(types_query_dsl_simple_query_string_flags),
    fuzzy_max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of terms to which the query expands for fuzzy matching.'
    })),
    fuzzy_prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of beginning characters left unchanged for fuzzy matching.'
    })),
    fuzzy_transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).'
    })),
    lenient: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.'
    })),
    minimum_should_match: z.optional(types_minimum_should_match),
    query: z.string().register(z.globalRegistry, {
        description: 'Query string in the simple query string syntax you wish to parse and use for search.'
    }),
    quote_field_suffix: z.optional(z.string().register(z.globalRegistry, {
        description: 'Suffix appended to quoted text in the query string.'
    }))
}));

export const types_query_dsl_shape_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'When set to `true` the query ignores an unmapped field and will not match any documents.'
    }))
}));

export const types_query_dsl_semantic_query = types_query_dsl_query_base.and(z.object({
    field: z.string().register(z.globalRegistry, {
        description: 'The field to query, which must be a semantic_text field type'
    }),
    query: z.string().register(z.globalRegistry, {
        description: 'The query text'
    })
}));

export const types_score_normalizer = z.enum([
    'none',
    'minmax',
    'l2_norm'
]);

export const global_search_types_learning_to_rank = z.object({
    model_id: z.string().register(z.globalRegistry, {
        description: 'The unique identifier of the trained model uploaded to Elasticsearch'
    }),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'Named parameters to be passed to the query templates used for feature'
    }))
});

export const global_search_types_score_mode = z.enum([
    'avg',
    'max',
    'min',
    'multiply',
    'total'
]);

export const types_mapping_chunk_rescorer_chunking_settings = z.object({
    strategy: z.optional(z.string().register(z.globalRegistry, {
        description: 'The chunking strategy: `sentence`, `word`, `none` or `recursive`.\n\n * If `strategy` is set to `recursive`, you must also specify:\n\n- `max_chunk_size`\n- either `separators` or`separator_group`\n\nLearn more about different chunking strategies in the linked documentation.'
    })),
    separator_group: z.optional(z.string().register(z.globalRegistry, {
        description: 'Only applicable to the `recursive` strategy and required when using it.\n\nSets a predefined list of separators in the saved chunking settings based on the selected text type.\nValues can be `markdown` or `plaintext`.\n\nUsing this parameter is an alternative to manually specifying a custom `separators` list.'
    })),
    separators: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Only applicable to the `recursive` strategy and required when using it.\n\nA list of strings used as possible split points when chunking text.\n\nEach string can be a plain string or a regular expression (regex) pattern.\nThe system tries each separator in order to split the text, starting from the first item in the list.\n\nAfter splitting, it attempts to recombine smaller pieces into larger chunks that stay within\nthe `max_chunk_size` limit, to reduce the total number of chunks generated.'
    })),
    max_chunk_size: z.number().register(z.globalRegistry, {
        description: 'The maximum size of a chunk in words.\nThis value cannot be lower than `20` (for `sentence` strategy) or `10` (for `word` strategy).\nThis value should not exceed the window size for the associated model.'
    }),
    overlap: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of overlapping words for chunks.\nIt is applicable only to a `word` chunking strategy.\nThis value cannot be higher than half the `max_chunk_size` value.'
    })),
    sentence_overlap: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of overlapping sentences for chunks.\nIt is applicable only for a `sentence` chunking strategy.\nIt can be either `1` or `0`.'
    }))
});

export const types_chunk_rescorer = z.object({
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of chunks per document to evaluate for reranking.'
    })),
    chunking_settings: z.optional(types_mapping_chunk_rescorer_chunking_settings)
});

export const types_rescore_vector = z.object({
    oversample: z.number().register(z.globalRegistry, {
        description: 'Applies the specified oversample factor to k on the approximate kNN search'
    })
});

export const types_sort_results = z.array(types_field_value);

export const types_fields = z.union([
    types_field,
    z.array(types_field)
]);

export const global_search_types_source_filter = z.object({
    exclude_vectors: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, vector fields are excluded from the returned source.\n\nThis option takes precedence over `includes`: any vector field will\nremain excluded even if it matches an `includes` rule.'
    })),
    excludes: z.optional(types_fields),
    includes: z.optional(types_fields)
});

/**
 * Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.
 */
export const global_search_types_source_config = z.union([
    z.boolean(),
    global_search_types_source_filter
]);

export const global_search_types_highlighter_tags_schema = z.enum(['styled']);

export const global_search_types_highlighter_order = z.enum(['score']);

export const global_search_types_highlighter_fragmenter = z.enum(['simple', 'span']);

export const global_search_types_boundary_scanner = z.enum([
    'chars',
    'sentence',
    'word'
]);

export const global_search_types_highlighter_type = z.union([
    z.enum([
        'plain',
        'fvh',
        'unified'
    ]),
    z.string()
]);

export const global_search_types_highlighter_encoder = z.enum(['default', 'html']);

/**
 * A reference to a field with formatting instructions on how to return the value
 */
export const types_query_dsl_field_and_format = z.object({
    field: types_field,
    format: z.optional(z.string().register(z.globalRegistry, {
        description: 'The format in which the values are returned.'
    })),
    include_unmapped: z.optional(z.boolean())
}).register(z.globalRegistry, {
    description: 'A reference to a field with formatting instructions on how to return the value'
});

export const types_name = z.string();

export const types_script_sort_type = z.enum([
    'string',
    'number',
    'version'
]);

export const types_sort_mode = z.enum([
    'min',
    'max',
    'sum',
    'avg',
    'median'
]);

export const types_sort_order = z.enum(['asc', 'desc']);

export const types_distance_unit = z.enum([
    'in',
    'ft',
    'yd',
    'mi',
    'nmi',
    'km',
    'm',
    'cm',
    'mm'
]);

export const types_geo_distance_type = z.enum(['arc', 'plane']);

export const types_score_sort = z.object({
    order: z.optional(types_sort_order)
});

export const types_rank_base = z.record(z.string(), z.unknown());

export const types_rrf_rank = types_rank_base.and(z.object({
    rank_constant: z.optional(z.number().register(z.globalRegistry, {
        description: 'How much influence documents in individual result sets per query have over the final ranked result set'
    })),
    rank_window_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Size of the individual result sets per query'
    }))
}));

export const types_rank_container = z.object({
    rrf: z.optional(types_rrf_rank)
});

/**
 * Number of hits matching the query to count accurately. If true, the exact
 * number of hits is returned at the cost of some performance. If false, the
 * response does not include the total number of hits matching the query.
 * Defaults to 10,000 hits.
 */
export const global_search_types_track_hits = z.union([
    z.boolean(),
    z.number()
]);

export const types_aggregations_value_type = z.enum([
    'string',
    'long',
    'double',
    'number',
    'date',
    'date_nanos',
    'ip',
    'numeric',
    'geo_point',
    'boolean'
]);

export const types_aggregations_aggregation = z.record(z.string(), z.unknown());

export const types_aggregations_missing = z.union([
    z.string(),
    z.number(),
    z.boolean()
]);

export const types_aggregations_top_metrics_value = z.object({
    field: types_field
});

export const types_aggregations_t_test_type = z.enum([
    'paired',
    'homoscedastic',
    'heteroscedastic'
]);

export const types_query_dsl_regexp_query = types_query_dsl_query_base.and(z.object({
    case_insensitive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Allows case insensitive matching of the regular expression value with the indexed field values when set to `true`.\nWhen `false`, case sensitivity of matching depends on the underlying field’s mapping.'
    })),
    flags: z.optional(z.string().register(z.globalRegistry, {
        description: 'Enables optional operators for the regular expression.'
    })),
    max_determinized_states: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of automaton states required for the query.'
    })),
    rewrite: z.optional(types_multi_term_query_rewrite),
    value: z.string().register(z.globalRegistry, {
        description: 'Regular expression for terms you wish to find in the provided field.'
    })
}));

export const types_query_dsl_rank_feature_function = z.record(z.string(), z.unknown());

export const types_query_dsl_rank_feature_function_sigmoid = types_query_dsl_rank_feature_function.and(z.object({
    pivot: z.number().register(z.globalRegistry, {
        description: 'Configurable pivot value so that the result will be less than 0.5.'
    }),
    exponent: z.number().register(z.globalRegistry, {
        description: 'Configurable Exponent.'
    })
}));

export const types_query_dsl_rank_feature_function_linear = types_query_dsl_rank_feature_function.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_rank_feature_function_logarithm = types_query_dsl_rank_feature_function.and(z.object({
    scaling_factor: z.number().register(z.globalRegistry, {
        description: 'Configurable scaling factor.'
    })
}));

export const types_query_dsl_rank_feature_function_saturation = types_query_dsl_rank_feature_function.and(z.object({
    pivot: z.optional(z.number().register(z.globalRegistry, {
        description: 'Configurable pivot value so that the result will be less than 0.5.'
    }))
}));

export const types_query_dsl_rank_feature_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    saturation: z.optional(types_query_dsl_rank_feature_function_saturation),
    log: z.optional(types_query_dsl_rank_feature_function_logarithm),
    linear: z.optional(types_query_dsl_rank_feature_function_linear),
    sigmoid: z.optional(types_query_dsl_rank_feature_function_sigmoid)
}));

export const types_query_dsl_range_relation = z.enum([
    'within',
    'contains',
    'intersects'
]);

export const types_query_dsl_range_query_basestring = types_query_dsl_query_base.and(z.object({
    relation: z.optional(types_query_dsl_range_relation),
    gt: z.optional(z.string().register(z.globalRegistry, {
        description: 'Greater than.'
    })),
    gte: z.optional(z.string().register(z.globalRegistry, {
        description: 'Greater than or equal to.'
    })),
    lt: z.optional(z.string().register(z.globalRegistry, {
        description: 'Less than.'
    })),
    lte: z.optional(z.string().register(z.globalRegistry, {
        description: 'Less than or equal to.'
    }))
}));

export const types_query_dsl_term_range_query = types_query_dsl_range_query_basestring.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_range_query_basedouble = types_query_dsl_query_base.and(z.object({
    relation: z.optional(types_query_dsl_range_relation),
    gt: z.optional(z.number().register(z.globalRegistry, {
        description: 'Greater than.'
    })),
    gte: z.optional(z.number().register(z.globalRegistry, {
        description: 'Greater than or equal to.'
    })),
    lt: z.optional(z.number().register(z.globalRegistry, {
        description: 'Less than.'
    })),
    lte: z.optional(z.number().register(z.globalRegistry, {
        description: 'Less than or equal to.'
    }))
}));

export const types_query_dsl_number_range_query = types_query_dsl_range_query_basedouble.and(z.record(z.string(), z.unknown()));

export const types_date_math = z.string();

export const types_query_dsl_range_query_base_date_math = types_query_dsl_query_base.and(z.object({
    relation: z.optional(types_query_dsl_range_relation),
    gt: z.optional(types_date_math),
    gte: z.optional(types_date_math),
    lt: z.optional(types_date_math),
    lte: z.optional(types_date_math)
}));

export const types_time_zone = z.string();

export const types_date_format = z.string();

export const types_query_dsl_date_range_query = types_query_dsl_range_query_base_date_math.and(z.object({
    format: z.optional(types_date_format),
    time_zone: z.optional(types_time_zone)
}));

export const types_query_dsl_range_query_base = types_query_dsl_query_base.and(z.object({
    relation: z.optional(types_query_dsl_range_relation),
    gt: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Greater than.'
    })),
    gte: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Greater than or equal to.'
    })),
    lt: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Less than.'
    })),
    lte: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Less than or equal to.'
    }))
}));

export const types_query_dsl_untyped_range_query = types_query_dsl_range_query_base.and(z.object({
    format: z.optional(types_date_format),
    time_zone: z.optional(types_time_zone)
}));

export const types_query_dsl_range_query = z.union([
    types_query_dsl_untyped_range_query,
    types_query_dsl_date_range_query,
    types_query_dsl_number_range_query,
    types_query_dsl_term_range_query
]);

export const types_query_dsl_text_query_type = z.enum([
    'best_fields',
    'most_fields',
    'cross_fields',
    'phrase',
    'phrase_prefix',
    'bool_prefix'
]);

export const types_fuzziness = z.union([
    z.string(),
    z.number()
]);

export const types_query_dsl_query_string_query = types_query_dsl_query_base.and(z.object({
    allow_leading_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the wildcard characters `*` and `?` are allowed as the first character of the query string.'
    })),
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to convert text in the query string into tokens.'
    })),
    analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the query attempts to analyze wildcard terms in the query string.'
    })),
    auto_generate_synonyms_phrase_query: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, match phrase queries are automatically created for multi-term synonyms.'
    })),
    default_field: z.optional(types_field),
    default_operator: z.optional(types_query_dsl_operator),
    enable_position_increments: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, enable position increments in queries constructed from a `query_string` search.'
    })),
    escape: z.optional(z.boolean()),
    fields: z.optional(z.array(types_field).register(z.globalRegistry, {
        description: 'Array of fields to search. Supports wildcards (`*`).'
    })),
    fuzziness: z.optional(types_fuzziness),
    fuzzy_max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of terms to which the query expands for fuzzy matching.'
    })),
    fuzzy_prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of beginning characters left unchanged for fuzzy matching.'
    })),
    fuzzy_rewrite: z.optional(types_multi_term_query_rewrite),
    fuzzy_transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).'
    })),
    lenient: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.'
    })),
    max_determinized_states: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of automaton states required for the query.'
    })),
    minimum_should_match: z.optional(types_minimum_should_match),
    phrase_slop: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of positions allowed between matching tokens for phrases.'
    })),
    query: z.string().register(z.globalRegistry, {
        description: 'Query string you wish to parse and use for search.'
    }),
    quote_analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to convert quoted text in the query string into tokens.\nFor quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter.'
    })),
    quote_field_suffix: z.optional(z.string().register(z.globalRegistry, {
        description: 'Suffix appended to quoted text in the query string.\nYou can use this suffix to use a different analysis method for exact matches.'
    })),
    rewrite: z.optional(types_multi_term_query_rewrite),
    tie_breaker: z.optional(z.number().register(z.globalRegistry, {
        description: 'How to combine the queries generated from the individual search terms in the resulting `dis_max` query.'
    })),
    time_zone: z.optional(types_time_zone),
    type: z.optional(types_query_dsl_text_query_type)
}));

export const types_query_dsl_prefix_query = types_query_dsl_query_base.and(z.object({
    rewrite: z.optional(types_multi_term_query_rewrite),
    value: z.string().register(z.globalRegistry, {
        description: 'Beginning characters of terms you wish to find in the provided field.'
    }),
    case_insensitive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nDefault is `false` which means the case sensitivity of matching depends on the underlying field’s mapping.'
    }))
}));

export const types_query_dsl_pinned_doc = z.object({
    _id: types_id,
    _index: z.optional(types_index_name)
});

export const types_version_number = z.number();

export const types_routing = z.union([
    z.string(),
    z.array(z.string())
]);

export const types_query_dsl_percolate_query = types_query_dsl_query_base.and(z.object({
    document: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'The source of the document being percolated.'
    })),
    documents: z.optional(z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'An array of sources of the documents being percolated.'
    })),
    field: types_field,
    id: z.optional(types_id),
    index: z.optional(types_index_name),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The suffix used for the `_percolator_document_slot` field when multiple `percolate` queries are specified.'
    })),
    preference: z.optional(z.string().register(z.globalRegistry, {
        description: 'Preference used to fetch document to percolate.'
    })),
    routing: z.optional(types_routing),
    version: z.optional(types_version_number)
}));

export const types_relation_name = z.string();

export const types_query_dsl_parent_id_query = types_query_dsl_query_base.and(z.object({
    id: z.optional(types_id),
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.'
    })),
    type: z.optional(types_relation_name)
}));

export const types_query_dsl_child_score_mode = z.enum([
    'none',
    'avg',
    'sum',
    'max',
    'min'
]);

export const types_query_dsl_zero_terms_query = z.enum(['all', 'none']);

export const types_query_dsl_multi_match_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to convert the text in the query value into tokens.'
    })),
    auto_generate_synonyms_phrase_query: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, match phrase queries are automatically created for multi-term synonyms.'
    })),
    cutoff_frequency: z.optional(z.number()),
    fields: z.optional(types_fields),
    fuzziness: z.optional(types_fuzziness),
    fuzzy_rewrite: z.optional(types_multi_term_query_rewrite),
    fuzzy_transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.'
    })),
    lenient: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.'
    })),
    max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of terms to which the query will expand.'
    })),
    minimum_should_match: z.optional(types_minimum_should_match),
    operator: z.optional(types_query_dsl_operator),
    prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of beginning characters left unchanged for fuzzy matching.'
    })),
    query: z.string().register(z.globalRegistry, {
        description: 'Text, number, boolean value or date you wish to find in the provided field.'
    }),
    slop: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of positions allowed between matching tokens.'
    })),
    tie_breaker: z.optional(z.number().register(z.globalRegistry, {
        description: 'Determines how scores for each per-term blended query and scores across groups are combined.'
    })),
    type: z.optional(types_query_dsl_text_query_type),
    zero_terms_query: z.optional(types_query_dsl_zero_terms_query)
}));

export const types_analysis_stop_word_language = z.enum([
    '_arabic_',
    '_armenian_',
    '_basque_',
    '_bengali_',
    '_brazilian_',
    '_bulgarian_',
    '_catalan_',
    '_cjk_',
    '_czech_',
    '_danish_',
    '_dutch_',
    '_english_',
    '_estonian_',
    '_finnish_',
    '_french_',
    '_galician_',
    '_german_',
    '_greek_',
    '_hindi_',
    '_hungarian_',
    '_indonesian_',
    '_irish_',
    '_italian_',
    '_latvian_',
    '_lithuanian_',
    '_norwegian_',
    '_persian_',
    '_portuguese_',
    '_romanian_',
    '_russian_',
    '_serbian_',
    '_sorani_',
    '_spanish_',
    '_swedish_',
    '_thai_',
    '_turkish_',
    '_none_'
]);

/**
 * Language value, such as _arabic_ or _thai_. Defaults to _english_.
 * Each language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words.
 * Also accepts an array of stop words.
 */
export const types_analysis_stop_words = z.union([
    types_analysis_stop_word_language,
    z.array(z.string())
]);

export const types_version_type = z.enum([
    'internal',
    'external',
    'external_gte'
]);

export const types_query_dsl_like_document = z.object({
    doc: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'A document not present in the index.'
    })),
    fields: z.optional(z.array(types_field)),
    _id: z.optional(types_id),
    _index: z.optional(types_index_name),
    per_field_analyzer: z.optional(z.record(z.string(), z.string()).register(z.globalRegistry, {
        description: 'Overrides the default analyzer.'
    })),
    routing: z.optional(types_routing),
    version: z.optional(types_version_number),
    version_type: z.optional(types_version_type)
});

/**
 * Text that we want similar documents for or a lookup to a document's field for the text.
 */
export const types_query_dsl_like = z.union([
    z.string(),
    types_query_dsl_like_document
]);

export const types_query_dsl_more_like_this_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'The analyzer that is used to analyze the free form text.\nDefaults to the analyzer associated with the first field in fields.'
    })),
    boost_terms: z.optional(z.number().register(z.globalRegistry, {
        description: 'Each term in the formed query could be further boosted by their tf-idf score.\nThis sets the boost factor to use when using this feature.\nDefaults to deactivated (0).'
    })),
    fail_on_unsupported_field: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Controls whether the query should fail (throw an exception) if any of the specified fields are not of the supported types (`text` or `keyword`).'
    })),
    fields: z.optional(z.array(types_field).register(z.globalRegistry, {
        description: 'A list of fields to fetch and analyze the text from.\nDefaults to the `index.query.default_field` index setting, which has a default value of `*`.'
    })),
    include: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Specifies whether the input documents should also be included in the search results returned.'
    })),
    like: z.union([
        types_query_dsl_like,
        z.array(types_query_dsl_like)
    ]),
    max_doc_freq: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum document frequency above which the terms are ignored from the input document.'
    })),
    max_query_terms: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of query terms that can be selected.'
    })),
    max_word_length: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum word length above which the terms are ignored.\nDefaults to unbounded (`0`).'
    })),
    min_doc_freq: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum document frequency below which the terms are ignored from the input document.'
    })),
    minimum_should_match: z.optional(types_minimum_should_match),
    min_term_freq: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum term frequency below which the terms are ignored from the input document.'
    })),
    min_word_length: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum word length below which the terms are ignored.'
    })),
    routing: z.optional(types_routing),
    stop_words: z.optional(types_analysis_stop_words),
    unlike: z.optional(z.union([
        types_query_dsl_like,
        z.array(types_query_dsl_like)
    ])),
    version: z.optional(types_version_number),
    version_type: z.optional(types_version_type)
}));

export const types_query_dsl_match_phrase_prefix_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to convert text in the query value into tokens.'
    })),
    max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of terms to which the last provided term of the query value will expand.'
    })),
    query: z.string().register(z.globalRegistry, {
        description: 'Text you wish to find in the provided field.'
    }),
    slop: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of positions allowed between matching tokens.'
    })),
    zero_terms_query: z.optional(types_query_dsl_zero_terms_query)
}));

export const types_query_dsl_match_phrase_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to convert the text in the query value into tokens.'
    })),
    query: z.string().register(z.globalRegistry, {
        description: 'Query terms that are analyzed and turned into a phrase query.'
    }),
    slop: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of positions allowed between matching tokens.'
    })),
    zero_terms_query: z.optional(types_query_dsl_zero_terms_query)
}));

export const types_query_dsl_match_none_query = types_query_dsl_query_base.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_match_bool_prefix_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to convert the text in the query value into tokens.'
    })),
    fuzziness: z.optional(types_fuzziness),
    fuzzy_rewrite: z.optional(types_multi_term_query_rewrite),
    fuzzy_transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.'
    })),
    max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of terms to which the query will expand.\nCan be applied to the term subqueries constructed for all terms but the final term.'
    })),
    minimum_should_match: z.optional(types_minimum_should_match),
    operator: z.optional(types_query_dsl_operator),
    prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of beginning characters left unchanged for fuzzy matching.\nCan be applied to the term subqueries constructed for all terms but the final term.'
    })),
    query: z.string().register(z.globalRegistry, {
        description: 'Terms you wish to find in the provided field.\nThe last term is used in a prefix query.'
    })
}));

export const types_query_dsl_match_all_query = types_query_dsl_query_base.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_match_query = z.union([
    z.string().register(z.globalRegistry, {
        description: 'Short query syntax for match query'
    }),
    types_query_dsl_query_base.and(z.object({
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: 'Analyzer used to convert the text in the query value into tokens.'
        })),
        auto_generate_synonyms_phrase_query: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, match phrase queries are automatically created for multi-term synonyms.'
        })),
        cutoff_frequency: z.optional(z.number()),
        fuzziness: z.optional(types_fuzziness),
        fuzzy_rewrite: z.optional(types_multi_term_query_rewrite),
        fuzzy_transpositions: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).'
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.'
        })),
        max_expansions: z.optional(z.number().register(z.globalRegistry, {
            description: 'Maximum number of terms to which the query will expand.'
        })),
        minimum_should_match: z.optional(types_minimum_should_match),
        operator: z.optional(types_query_dsl_operator),
        prefix_length: z.optional(z.number().register(z.globalRegistry, {
            description: 'Number of beginning characters left unchanged for fuzzy matching.'
        })),
        query: z.union([
            z.string(),
            z.number(),
            z.boolean()
        ]),
        zero_terms_query: z.optional(types_query_dsl_zero_terms_query)
    }))
]);

export const types_query_dsl_intervals_wildcard = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to analyze the `pattern`.\nDefaults to the top-level field\'s analyzer.'
    })),
    pattern: z.string().register(z.globalRegistry, {
        description: 'Wildcard pattern used to find matching terms.'
    }),
    use_field: z.optional(types_field)
});

export const types_query_dsl_intervals_regexp = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to analyze the `prefix`.'
    })),
    pattern: z.string().register(z.globalRegistry, {
        description: 'Regex pattern.'
    }),
    use_field: z.optional(types_field)
});

export const types_query_dsl_intervals_range = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to analyze the `prefix`.'
    })),
    gte: z.optional(z.string().register(z.globalRegistry, {
        description: 'Lower term, either gte or gt must be provided.'
    })),
    gt: z.optional(z.string().register(z.globalRegistry, {
        description: 'Lower term, either gte or gt must be provided.'
    })),
    lte: z.optional(z.string().register(z.globalRegistry, {
        description: 'Upper term, either lte or lt must be provided.'
    })),
    lt: z.optional(z.string().register(z.globalRegistry, {
        description: 'Upper term, either lte or lt must be provided.'
    })),
    use_field: z.optional(types_field)
});

export const types_query_dsl_intervals_prefix = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to analyze the `prefix`.'
    })),
    prefix: z.string().register(z.globalRegistry, {
        description: 'Beginning characters of terms you wish to find in the top-level field.'
    }),
    use_field: z.optional(types_field)
});

export const types_query_dsl_intervals_fuzzy = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to normalize the term.'
    })),
    fuzziness: z.optional(types_fuzziness),
    prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of beginning characters left unchanged when creating expansions.'
    })),
    term: z.string().register(z.globalRegistry, {
        description: 'The term to match.'
    }),
    transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`).'
    })),
    use_field: z.optional(types_field)
});

export const types_ids = z.union([
    types_id,
    z.array(types_id)
]);

export const types_query_dsl_ids_query = types_query_dsl_query_base.and(z.object({
    values: z.optional(types_ids)
}));

export const types_query_dsl_geo_shape_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.'
    }))
}));

export const types_query_dsl_geo_validation_method = z.enum([
    'coerce',
    'ignore_malformed',
    'strict'
]);

export const types_query_dsl_geo_polygon_query = types_query_dsl_query_base.and(z.object({
    validation_method: z.optional(types_query_dsl_geo_validation_method),
    ignore_unmapped: z.optional(z.boolean())
}));

/**
 * A map hex cell (H3) reference
 */
export const types_geo_hex_cell = z.string().register(z.globalRegistry, {
    description: 'A map hex cell (H3) reference'
});

/**
 * A map tile reference, represented as `{zoom}/{x}/{y}`
 */
export const types_geo_tile = z.string().register(z.globalRegistry, {
    description: 'A map tile reference, represented as `{zoom}/{x}/{y}`'
});

export const types_geo_hash = z.string();

export const types_query_dsl_geo_grid_query = types_query_dsl_query_base.and(z.object({
    geotile: z.optional(types_geo_tile),
    geohash: z.optional(types_geo_hash),
    geohex: z.optional(types_geo_hex_cell)
}));

export const types_distance = z.string();

export const types_query_dsl_geo_distance_query = types_query_dsl_query_base.and(z.object({
    distance: types_distance,
    distance_type: z.optional(types_geo_distance_type),
    validation_method: z.optional(types_query_dsl_geo_validation_method),
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.'
    }))
}));

export const types_query_dsl_geo_execution = z.enum(['memory', 'indexed']);

export const types_query_dsl_geo_bounding_box_query = types_query_dsl_query_base.and(z.object({
    type: z.optional(types_query_dsl_geo_execution),
    validation_method: z.optional(types_query_dsl_geo_validation_method),
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.'
    }))
}));

export const types_query_dsl_fuzzy_query = types_query_dsl_query_base.and(z.object({
    max_expansions: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of variations created.'
    })),
    prefix_length: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of beginning characters left unchanged when creating expansions.'
    })),
    rewrite: z.optional(types_multi_term_query_rewrite),
    transpositions: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether edits include transpositions of two adjacent characters (for example `ab` to `ba`).'
    })),
    fuzziness: z.optional(types_fuzziness),
    value: z.union([
        z.string(),
        z.number(),
        z.boolean()
    ])
}));

export const types_query_dsl_function_score_mode = z.enum([
    'multiply',
    'sum',
    'avg',
    'first',
    'max',
    'min'
]);

export const types_query_dsl_random_score_function = z.object({
    field: z.optional(types_field),
    seed: z.optional(z.union([
        z.number(),
        z.string()
    ]))
});

export const types_query_dsl_field_value_factor_modifier = z.enum([
    'none',
    'log',
    'log1p',
    'log2p',
    'ln',
    'ln1p',
    'ln2p',
    'square',
    'sqrt',
    'reciprocal'
]);

export const types_query_dsl_field_value_factor_score_function = z.object({
    field: types_field,
    factor: z.optional(z.number().register(z.globalRegistry, {
        description: 'Optional factor to multiply the field value with.'
    })),
    missing: z.optional(z.number().register(z.globalRegistry, {
        description: 'Value used if the document doesn’t have that field.\nThe modifier and factor are still applied to it as though it were read from the document.'
    })),
    modifier: z.optional(types_query_dsl_field_value_factor_modifier)
});

export const types_query_dsl_multi_value_mode = z.enum([
    'min',
    'max',
    'avg',
    'sum'
]);

export const types_query_dsl_decay_function_base_geo_location_distance = z.object({
    multi_value_mode: z.optional(types_query_dsl_multi_value_mode)
});

export const types_query_dsl_geo_decay_function = types_query_dsl_decay_function_base_geo_location_distance.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_decay_function_basedoubledouble = z.object({
    multi_value_mode: z.optional(types_query_dsl_multi_value_mode)
});

export const types_query_dsl_numeric_decay_function = types_query_dsl_decay_function_basedoubledouble.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_decay_function_base_date_math_duration = z.object({
    multi_value_mode: z.optional(types_query_dsl_multi_value_mode)
});

export const types_query_dsl_date_decay_function = types_query_dsl_decay_function_base_date_math_duration.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_decay_function_base = z.object({
    multi_value_mode: z.optional(types_query_dsl_multi_value_mode)
});

export const types_query_dsl_untyped_decay_function = types_query_dsl_decay_function_base.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_decay_function = z.union([
    types_query_dsl_untyped_decay_function,
    types_query_dsl_date_decay_function,
    types_query_dsl_numeric_decay_function,
    types_query_dsl_geo_decay_function
]);

export const types_query_dsl_function_boost_mode = z.enum([
    'multiply',
    'replace',
    'sum',
    'avg',
    'max',
    'min'
]);

export const types_query_dsl_exists_query = types_query_dsl_query_base.and(z.object({
    field: types_field
}));

export const types_query_dsl_distance_feature_query_base_date_math_duration = types_query_dsl_query_base.and(z.object({
    origin: types_date_math,
    pivot: types_duration,
    field: types_field
}));

export const types_query_dsl_date_distance_feature_query = types_query_dsl_distance_feature_query_base_date_math_duration.and(z.record(z.string(), z.unknown()));

export const types_geo_hash_location = z.object({
    geohash: types_geo_hash
});

export const types_lat_lon_geo_location = z.object({
    lat: z.number().register(z.globalRegistry, {
        description: 'Latitude'
    }),
    lon: z.number().register(z.globalRegistry, {
        description: 'Longitude'
    })
});

/**
 * A latitude/longitude as a 2 dimensional point. It can be represented in various ways:
 * - as a `{lat, long}` object
 * - as a geo hash value
 * - as a `[lon, lat]` array
 * - as a string in `"<lat>, <lon>"` or WKT point formats
 */
export const types_geo_location = z.union([
    types_lat_lon_geo_location,
    types_geo_hash_location,
    z.array(z.number()),
    z.string()
]);

export const types_query_dsl_distance_feature_query_base_geo_location_distance = types_query_dsl_query_base.and(z.object({
    origin: types_geo_location,
    pivot: types_distance,
    field: types_field
}));

export const types_query_dsl_geo_distance_feature_query = types_query_dsl_distance_feature_query_base_geo_location_distance.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_distance_feature_query_base = types_query_dsl_query_base.and(z.object({
    origin: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Date or point of origin used to calculate distances.\nIf the `field` value is a `date` or `date_nanos` field, the `origin` value must be a date.\nDate Math, such as `now-1h`, is supported.\nIf the field value is a `geo_point` field, the `origin` value must be a geopoint.'
    }),
    pivot: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Distance from the `origin` at which relevance scores receive half of the `boost` value.\nIf the `field` value is a `date` or `date_nanos` field, the `pivot` value must be a time unit, such as `1h` or `10d`. If the `field` value is a `geo_point` field, the `pivot` value must be a distance unit, such as `1km` or `12m`.'
    }),
    field: types_field
}));

export const types_query_dsl_untyped_distance_feature_query = types_query_dsl_distance_feature_query_base.and(z.record(z.string(), z.unknown()));

export const types_query_dsl_distance_feature_query = z.union([
    types_query_dsl_untyped_distance_feature_query,
    types_query_dsl_geo_distance_feature_query,
    types_query_dsl_date_distance_feature_query
]);

export const types_query_dsl_combined_fields_zero_terms = z.enum(['none', 'all']);

export const types_query_dsl_combined_fields_operator = z.enum(['or', 'and']);

export const types_query_dsl_combined_fields_query = types_query_dsl_query_base.and(z.object({
    fields: z.array(types_field).register(z.globalRegistry, {
        description: 'List of fields to search. Field wildcard patterns are allowed. Only `text` fields are supported, and they must all have the same search `analyzer`.'
    }),
    query: z.string().register(z.globalRegistry, {
        description: 'Text to search for in the provided `fields`.\nThe `combined_fields` query analyzes the provided text before performing a search.'
    }),
    auto_generate_synonyms_phrase_query: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If true, match phrase queries are automatically created for multi-term synonyms.'
    })),
    operator: z.optional(types_query_dsl_combined_fields_operator),
    minimum_should_match: z.optional(types_minimum_should_match),
    zero_terms_query: z.optional(types_query_dsl_combined_fields_zero_terms)
}));

export const types_query_dsl_common_terms_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.optional(z.string()),
    cutoff_frequency: z.optional(z.number()),
    high_freq_operator: z.optional(types_query_dsl_operator),
    low_freq_operator: z.optional(types_query_dsl_operator),
    minimum_should_match: z.optional(types_minimum_should_match),
    query: z.string()
}));

/**
 * Base type for bucket aggregations. These aggregations also accept sub-aggregations.
 */
export const types_aggregations_bucket_aggregation_base = types_aggregations_aggregation.and(z.record(z.string(), z.unknown()));

export const types_aggregations_time_series_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of results to return.'
    })),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array.'
    }))
}));

export const types_aggregations_aggregate_order = z.union([
    z.record(z.string(), types_sort_order),
    z.array(z.record(z.string(), types_sort_order))
]);

export const types_aggregations_missing_order = z.enum([
    'first',
    'last',
    'default'
]);

export const types_aggregations_terms_partition = z.object({
    num_partitions: z.number().register(z.globalRegistry, {
        description: 'The number of partitions.'
    }),
    partition: z.number().register(z.globalRegistry, {
        description: 'The partition number for this request.'
    })
});

export const types_aggregations_terms_include = z.union([
    z.string(),
    z.array(z.string()),
    types_aggregations_terms_partition
]);

export const types_aggregations_terms_aggregation_execution_hint = z.enum([
    'map',
    'global_ordinals',
    'global_ordinals_hash',
    'global_ordinals_low_cardinality'
]);

export const types_aggregations_terms_exclude = z.union([
    z.string(),
    z.array(z.string())
]);

export const types_aggregations_terms_aggregation_collect_mode = z.enum(['depth_first', 'breadth_first']);

export const types_aggregations_gap_policy = z.enum([
    'skip',
    'insert_zeros',
    'keep_values'
]);

/**
 * Buckets path can be expressed in different ways, and an aggregation may accept some or all of these
 * forms depending on its type. Please refer to each aggregation's documentation to know what buckets
 * path forms they accept.
 */
export const types_aggregations_buckets_path = z.union([
    z.string(),
    z.array(z.string()),
    z.record(z.string(), z.string())
]);

export const types_aggregations_bucket_path_aggregation = types_aggregations_aggregation.and(z.object({
    buckets_path: z.optional(types_aggregations_buckets_path)
}));

export const types_aggregations_pipeline_aggregation_base = types_aggregations_bucket_path_aggregation.and(z.object({
    format: z.optional(z.string().register(z.globalRegistry, {
        description: '`DecimalFormat` pattern for the output value.\nIf specified, the formatted value is returned in the aggregation’s `value_as_string` property.'
    })),
    gap_policy: z.optional(types_aggregations_gap_policy)
}));

export const types_aggregations_sum_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_stats_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_percentage_score_heuristic = z.record(z.string(), z.unknown());

export const types_aggregations_mutual_information_heuristic = z.object({
    background_is_superset: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.'
    })),
    include_negatives: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset.'
    }))
});

/**
 * For empty Class assignments
 */
export const types_empty_object = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'For empty Class assignments'
});

export const types_aggregations_google_normalized_distance_heuristic = z.object({
    background_is_superset: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.'
    }))
});

export const types_aggregations_chi_square_heuristic = z.object({
    background_is_superset: z.boolean().register(z.globalRegistry, {
        description: 'Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.'
    }),
    include_negatives: z.boolean().register(z.globalRegistry, {
        description: 'Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset.'
    })
});

export const types_aggregations_p_value_heuristic = z.object({
    background_is_superset: z.optional(z.boolean()),
    normalize_above: z.optional(z.number().register(z.globalRegistry, {
        description: 'Should the results be normalized when above the given value.\nAllows for consistent significance results at various scales.\nNote: `0` is a special value which means no normalization'
    }))
});

export const types_aggregations_serial_differencing_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    lag: z.optional(z.number().register(z.globalRegistry, {
        description: 'The historical bucket to subtract from the current value.\nMust be a positive, non-zero integer.'
    }))
}));

export const types_aggregations_sampler_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Limits how many top-scoring documents are collected in the sample processed on each shard.'
    }))
}));

export const types_aggregations_random_sampler_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    probability: z.number().register(z.globalRegistry, {
        description: 'The probability that a document will be included in the aggregated data.\nMust be greater than 0, less than 0.5, or exactly 1.\nThe lower the probability, the fewer documents are matched.'
    }),
    seed: z.optional(z.number().register(z.globalRegistry, {
        description: 'The seed to generate the random sampling of documents.\nWhen a seed is provided, the random subset of documents is the same between calls.'
    })),
    shard_seed: z.optional(z.number().register(z.globalRegistry, {
        description: 'When combined with seed, setting shard_seed ensures 100% consistent sampling over shards where data is exactly the same.'
    }))
}));

export const types_aggregations_reverse_nested_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    path: z.optional(types_field)
}));

export const types_aggregations_rate_mode = z.enum(['sum', 'value_count']);

export const types_aggregations_calendar_interval = z.enum([
    'second',
    '1s',
    'minute',
    '1m',
    'hour',
    '1h',
    'day',
    '1d',
    'week',
    '1w',
    'month',
    '1M',
    'quarter',
    '1q',
    'year',
    '1y'
]);

export const types_aggregations_rare_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    exclude: z.optional(types_aggregations_terms_exclude),
    field: z.optional(types_field),
    include: z.optional(types_aggregations_terms_include),
    max_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of documents a term should appear in.'
    })),
    missing: z.optional(types_aggregations_missing),
    precision: z.optional(z.number().register(z.globalRegistry, {
        description: 'The precision of the internal CuckooFilters.\nSmaller precision leads to better approximation, but higher memory usage.'
    })),
    value_type: z.optional(z.string())
}));

export const types_aggregations_aggregation_range = z.object({
    from: z.optional(z.union([
        z.number(),
        z.string(),
        z.null()
    ])),
    key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Custom key to return the range with.'
    })),
    to: z.optional(z.union([
        z.number(),
        z.string(),
        z.null()
    ]))
});

export const types_aggregations_percentiles_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    percents: z.optional(z.array(z.number()).register(z.globalRegistry, {
        description: 'The list of percentiles to calculate.'
    }))
}));

export const types_aggregations_t_digest_execution_hint = z.enum(['default', 'high_accuracy']);

export const types_aggregations_t_digest = z.object({
    compression: z.optional(z.number().register(z.globalRegistry, {
        description: 'Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.'
    })),
    execution_hint: z.optional(types_aggregations_t_digest_execution_hint)
});

export const types_aggregations_hdr_method = z.object({
    number_of_significant_value_digits: z.optional(z.number().register(z.globalRegistry, {
        description: 'Specifies the resolution of values for the histogram in number of significant digits.'
    }))
});

export const types_aggregations_parent_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    type: z.optional(types_relation_name)
}));

export const types_aggregations_normalize_method = z.enum([
    'rescale_0_1',
    'rescale_0_100',
    'percent_of_sum',
    'mean',
    'z-score',
    'softmax'
]);

export const types_aggregations_normalize_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    method: z.optional(types_aggregations_normalize_method)
}));

export const types_aggregations_nested_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    path: z.optional(types_field)
}));

export const types_aggregations_multi_term_lookup = z.object({
    field: types_field,
    missing: z.optional(types_aggregations_missing)
});

export const types_aggregations_multi_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    collect_mode: z.optional(types_aggregations_terms_aggregation_collect_mode),
    order: z.optional(types_aggregations_aggregate_order),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum number of documents in a bucket for it to be returned.'
    })),
    shard_min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum number of documents in a bucket on each shard for it to be returned.'
    })),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.'
    })),
    show_term_doc_count_error: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Calculates the doc count error on per term basis.'
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of term buckets should be returned out of the overall terms list.'
    })),
    terms: z.array(types_aggregations_multi_term_lookup).register(z.globalRegistry, {
        description: 'The field from which to generate sets of terms.'
    })
}));

export const types_aggregations_moving_function_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    script: z.optional(z.string().register(z.globalRegistry, {
        description: 'The script that should be executed on each window of data.'
    })),
    shift: z.optional(z.number().register(z.globalRegistry, {
        description: 'By default, the window consists of the last n values excluding the current bucket.\nIncreasing `shift` by 1, moves the starting window position by 1 to the right.'
    })),
    window: z.optional(z.number().register(z.globalRegistry, {
        description: 'The size of window to "slide" across the histogram.'
    }))
}));

export const types_aggregations_moving_percentiles_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    window: z.optional(z.number().register(z.globalRegistry, {
        description: 'The size of window to "slide" across the histogram.'
    })),
    shift: z.optional(z.number().register(z.globalRegistry, {
        description: 'By default, the window consists of the last n values excluding the current bucket.\nIncreasing `shift` by 1, moves the starting window position by 1 to the right.'
    })),
    keyed: z.optional(z.boolean())
}));

export const types_aggregations_holt_winters_type = z.enum(['add', 'mult']);

export const types_aggregations_holt_winters_model_settings = z.object({
    alpha: z.optional(z.number()),
    beta: z.optional(z.number()),
    gamma: z.optional(z.number()),
    pad: z.optional(z.boolean()),
    period: z.optional(z.number()),
    type: z.optional(types_aggregations_holt_winters_type)
});

export const types_aggregations_moving_average_aggregation_base = types_aggregations_pipeline_aggregation_base.and(z.object({
    minimize: z.optional(z.boolean()),
    predict: z.optional(z.number()),
    window: z.optional(z.number())
}));

export const types_aggregations_holt_winters_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum(['holt_winters']),
    settings: types_aggregations_holt_winters_model_settings
}));

export const types_aggregations_holt_linear_model_settings = z.object({
    alpha: z.optional(z.number()),
    beta: z.optional(z.number())
});

export const types_aggregations_holt_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum(['holt']),
    settings: types_aggregations_holt_linear_model_settings
}));

export const types_aggregations_ewma_model_settings = z.object({
    alpha: z.optional(z.number())
});

export const types_aggregations_ewma_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum(['ewma']),
    settings: types_aggregations_ewma_model_settings
}));

export const types_aggregations_simple_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum(['simple']),
    settings: types_empty_object
}));

export const types_aggregations_linear_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum(['linear']),
    settings: types_empty_object
}));

export const types_aggregations_moving_average_aggregation = z.union([
    z.object({
        model: z.literal('linear')
    }).and(types_aggregations_linear_moving_average_aggregation),
    z.object({
        model: z.literal('simple')
    }).and(types_aggregations_simple_moving_average_aggregation),
    z.object({
        model: z.literal('ewma')
    }).and(types_aggregations_ewma_moving_average_aggregation),
    z.object({
        model: z.literal('holt')
    }).and(types_aggregations_holt_moving_average_aggregation),
    z.object({
        model: z.literal('holt_winters')
    }).and(types_aggregations_holt_winters_moving_average_aggregation)
]);

export const types_aggregations_missing_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: z.optional(types_field),
    missing: z.optional(types_aggregations_missing)
}));

export const types_aggregations_min_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_max_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_matrix_aggregation = types_aggregations_aggregation.and(z.object({
    fields: z.optional(types_fields),
    missing: z.optional(z.record(z.string(), z.number()).register(z.globalRegistry, {
        description: 'The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.'
    }))
}));

export const types_aggregations_matrix_stats_aggregation = types_aggregations_matrix_aggregation.and(z.object({
    mode: z.optional(types_sort_mode)
}));

export const ml_types_classification_inference_options = z.object({
    num_top_classes: z.optional(z.number().register(z.globalRegistry, {
        description: 'Specifies the number of top class predictions to return. Defaults to 0.'
    })),
    num_top_feature_importance_values: z.optional(z.number().register(z.globalRegistry, {
        description: 'Specifies the maximum number of feature importance values per document.'
    })),
    prediction_field_type: z.optional(z.string().register(z.globalRegistry, {
        description: 'Specifies the type of the predicted field to write. Acceptable values are: string, number, boolean. When boolean is provided 1.0 is transformed to true and 0.0 to false.'
    })),
    results_field: z.optional(z.string().register(z.globalRegistry, {
        description: 'The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.'
    })),
    top_classes_results_field: z.optional(z.string().register(z.globalRegistry, {
        description: 'Specifies the field to which the top classes are written. Defaults to top_classes.'
    }))
});

export const ml_types_regression_inference_options = z.object({
    results_field: z.optional(types_field),
    num_top_feature_importance_values: z.optional(z.number().register(z.globalRegistry, {
        description: 'Specifies the maximum number of feature importance values per document.'
    }))
});

export const types_aggregations_inference_config_container = z.object({
    regression: z.optional(ml_types_regression_inference_options),
    classification: z.optional(ml_types_classification_inference_options)
});

export const types_aggregations_inference_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    model_id: types_name,
    inference_config: z.optional(types_aggregations_inference_config_container)
}));

export const types_aggregations_ip_prefix_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field,
    prefix_length: z.number().register(z.globalRegistry, {
        description: 'Length of the network prefix. For IPv4 addresses the accepted range is [0, 32].\nFor IPv6 addresses the accepted range is [0, 128].'
    }),
    is_ipv6: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines whether the prefix applies to IPv6 addresses.'
    })),
    append_prefix_length: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines whether the prefix length is appended to IP address keys in the response.'
    })),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines whether buckets are returned as a hash rather than an array in the response.'
    })),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Minimum number of documents in a bucket for it to be included in the response.'
    }))
}));

export const types_aggregations_ip_range_aggregation_range = z.object({
    from: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    mask: z.optional(z.string().register(z.globalRegistry, {
        description: 'IP range defined as a CIDR mask.'
    })),
    to: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

export const types_aggregations_ip_range_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: z.optional(types_field),
    ranges: z.optional(z.array(types_aggregations_ip_range_aggregation_range).register(z.globalRegistry, {
        description: 'Array of IP ranges.'
    }))
}));

export const types_aggregations_extended_boundsdouble = z.object({
    max: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum value for the bound.'
    })),
    min: z.optional(z.number().register(z.globalRegistry, {
        description: 'Minimum value for the bound.'
    }))
});

export const types_aggregations_global_aggregation = types_aggregations_bucket_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_wkt_geo_bounds = z.object({
    wkt: z.string()
});

export const types_top_right_bottom_left_geo_bounds = z.object({
    top_right: types_geo_location,
    bottom_left: types_geo_location
});

export const types_top_left_bottom_right_geo_bounds = z.object({
    top_left: types_geo_location,
    bottom_right: types_geo_location
});

export const types_coords_geo_bounds = z.object({
    top: z.number(),
    bottom: z.number(),
    left: z.number(),
    right: z.number()
});

/**
 * A geo bounding box. It can be represented in various ways:
 * - as 4 top/bottom/left/right coordinates
 * - as 2 top_left / bottom_right points
 * - as 2 top_right / bottom_left points
 * - as a WKT bounding box
 */
export const types_geo_bounds = z.union([
    types_coords_geo_bounds,
    types_top_left_bottom_right_geo_bounds,
    types_top_right_bottom_left_geo_bounds,
    types_wkt_geo_bounds
]);

export const types_aggregations_geohex_grid_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field,
    precision: z.optional(z.number().register(z.globalRegistry, {
        description: 'Integer zoom of the key used to defined cells or buckets\nin the results. Value should be between 0-15.'
    })),
    bounds: z.optional(types_geo_bounds),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of buckets to return.'
    })),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of buckets returned from each shard.'
    }))
}));

export const types_geo_tile_precision = z.number();

export const types_aggregations_geo_tile_grid_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: z.optional(types_field),
    precision: z.optional(types_geo_tile_precision),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Allows for more accurate counting of the top cells returned in the final result the aggregation.\nDefaults to returning `max(10,(size x number-of-shards))` buckets from each shard.'
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of buckets to return.'
    })),
    bounds: z.optional(types_geo_bounds)
}));

export const types_aggregations_geo_line_sort = z.object({
    field: types_field
});

export const types_aggregations_geo_line_point = z.object({
    field: types_field
});

export const types_aggregations_geo_line_aggregation = z.object({
    point: types_aggregations_geo_line_point,
    sort: z.optional(types_aggregations_geo_line_sort),
    include_sort: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'When `true`, returns an additional array of the sort values in the feature properties.'
    })),
    sort_order: z.optional(types_sort_order),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum length of the line represented in the aggregation.\nValid sizes are between 1 and 10000.'
    }))
});

/**
 * A precision that can be expressed as a geohash length between 1 and 12, or a distance measure like "1km", "10m".
 */
export const types_geo_hash_precision = z.union([
    z.number(),
    z.string()
]);

export const types_aggregations_geo_hash_grid_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    bounds: z.optional(types_geo_bounds),
    field: z.optional(types_field),
    precision: z.optional(types_geo_hash_precision),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Allows for more accurate counting of the top cells returned in the final result the aggregation.\nDefaults to returning `max(10,(size x number-of-shards))` buckets from each shard.'
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of geohash buckets to return.'
    }))
}));

export const types_aggregations_geo_distance_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    distance_type: z.optional(types_geo_distance_type),
    field: z.optional(types_field),
    origin: z.optional(types_geo_location),
    ranges: z.optional(z.array(types_aggregations_aggregation_range).register(z.globalRegistry, {
        description: 'An array of ranges used to bucket documents.'
    })),
    unit: z.optional(types_distance_unit)
}));

export const types_aggregations_frequent_item_sets_field = z.object({
    field: types_field,
    exclude: z.optional(types_aggregations_terms_exclude),
    include: z.optional(types_aggregations_terms_include)
});

export const types_aggregations_extended_stats_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    sigma: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of standard deviations above/below the mean to display.'
    }))
}));

export const types_aggregations_sampler_aggregation_execution_hint = z.enum([
    'map',
    'global_ordinals',
    'bytes_hash'
]);

export const types_aggregations_derivative_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

/**
 * A date range limit, represented either as a DateMath expression or a number expressed
 * according to the target field's precision.
 */
export const types_aggregations_field_date_math = z.union([
    types_date_math,
    z.number()
]);

export const types_aggregations_date_range_expression = z.object({
    from: z.optional(types_aggregations_field_date_math),
    key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Custom key to return the range with.'
    })),
    to: z.optional(types_aggregations_field_date_math)
});

export const types_aggregations_date_range_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: z.optional(types_field),
    format: z.optional(z.string().register(z.globalRegistry, {
        description: 'The date format used to format `from` and `to` in the response.'
    })),
    missing: z.optional(types_aggregations_missing),
    ranges: z.optional(z.array(types_aggregations_date_range_expression).register(z.globalRegistry, {
        description: 'Array of date ranges.'
    })),
    time_zone: z.optional(types_time_zone),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array.'
    }))
}));

export const types_aggregations_extended_bounds_field_date_math = z.object({
    max: z.optional(types_aggregations_field_date_math),
    min: z.optional(types_aggregations_field_date_math)
});

export const types_aggregations_cumulative_sum_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_cumulative_cardinality_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

/**
 * A date histogram interval. Similar to `Duration` with additional units: `w` (week), `M` (month), `q` (quarter) and
 * `y` (year)
 */
export const types_duration_large = z.string().register(z.globalRegistry, {
    description: 'A date histogram interval. Similar to `Duration` with additional units: `w` (week), `M` (month), `q` (quarter) and\n`y` (year)'
});

export const types_aggregations_composite_aggregate_key = z.record(z.string(), types_field_value);

export const types_aggregations_children_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    type: z.optional(types_relation_name)
}));

export const types_aggregations_change_point_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_custom_categorize_text_analyzer = z.object({
    char_filter: z.optional(z.array(z.string())),
    tokenizer: z.optional(z.string()),
    filter: z.optional(z.array(z.string()))
});

export const types_aggregations_categorize_text_analyzer = z.union([
    z.string(),
    types_aggregations_custom_categorize_text_analyzer
]);

/**
 * A multi-bucket aggregation that groups semi-structured text into buckets. Each text
 * field is re-analyzed using a custom analyzer. The resulting tokens are then categorized
 * creating buckets of similarly formatted text values. This aggregation works best with machine
 * generated text like system logs. Only the first 100 analyzed tokens are used to categorize the text.
 */
export const types_aggregations_categorize_text_aggregation = types_aggregations_aggregation.and(z.object({
    field: types_field,
    max_unique_tokens: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of unique tokens at any position up to max_matched_tokens. Must be larger than 1.\nSmaller values use less memory and create fewer categories. Larger values will use more memory and\ncreate narrower categories. Max allowed value is 100.'
    })),
    max_matched_tokens: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of token positions to match on before attempting to merge categories. Larger\nvalues will use more memory and create narrower categories. Max allowed value is 100.'
    })),
    similarity_threshold: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum percentage of tokens that must match for text to be added to the category bucket. Must\nbe between 1 and 100. The larger the value the narrower the categories. Larger values will increase memory\nusage and create narrower categories.'
    })),
    categorization_filters: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'This property expects an array of regular expressions. The expressions are used to filter out matching\nsequences from the categorization field values. You can use this functionality to fine tune the categorization\nby excluding sequences from consideration when categories are defined. For example, you can exclude SQL\nstatements that appear in your log files. This property cannot be used at the same time as categorization_analyzer.\nIf you only want to define simple regular expression filters that are applied prior to tokenization, setting\nthis property is the easiest method. If you also want to customize the tokenizer or post-tokenization filtering,\nuse the categorization_analyzer property instead and include the filters as pattern_replace character filters.'
    })),
    categorization_analyzer: z.optional(types_aggregations_categorize_text_analyzer),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of categorization buckets to return from each shard before merging all the results.'
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of buckets to return.'
    })),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum number of documents in a bucket to be returned to the results.'
    })),
    shard_min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum number of documents in a bucket to be returned from the shard before merging.'
    }))
}));

export const types_aggregations_cardinality_execution_mode = z.enum([
    'global_ordinals',
    'segment_ordinals',
    'direct',
    'save_memory_heuristic',
    'save_time_heuristic'
]);

export const types_aggregations_bucket_correlation_function_count_correlation_indicator = z.object({
    doc_count: z.number().register(z.globalRegistry, {
        description: 'The total number of documents that initially created the expectations. It’s required to be greater\nthan or equal to the sum of all values in the buckets_path as this is the originating superset of data\nto which the term values are correlated.'
    }),
    expectations: z.array(z.number()).register(z.globalRegistry, {
        description: 'An array of numbers with which to correlate the configured `bucket_path` values.\nThe length of this value must always equal the number of buckets returned by the `bucket_path`.'
    }),
    fractions: z.optional(z.array(z.number()).register(z.globalRegistry, {
        description: 'An array of fractions to use when averaging and calculating variance. This should be used if\nthe pre-calculated data and the buckets_path have known gaps. The length of fractions, if provided,\nmust equal expectations.'
    }))
});

export const types_aggregations_bucket_correlation_function_count_correlation = z.object({
    indicator: types_aggregations_bucket_correlation_function_count_correlation_indicator
});

export const types_aggregations_bucket_correlation_function = z.object({
    count_correlation: types_aggregations_bucket_correlation_function_count_correlation
});

/**
 * A sibling pipeline aggregation which executes a correlation function on the configured sibling multi-bucket aggregation.
 */
export const types_aggregations_bucket_correlation_aggregation = types_aggregations_bucket_path_aggregation.and(z.object({
    function: types_aggregations_bucket_correlation_function
}));

/**
 * A sibling pipeline aggregation which executes a two sample Kolmogorov–Smirnov test (referred
 * to as a "K-S test" from now on) against a provided distribution, and the distribution implied
 * by the documents counts in the configured sibling aggregation. Specifically, for some metric,
 * assuming that the percentile intervals of the metric are known beforehand or have been computed
 * by an aggregation, then one would use range aggregation for the sibling to compute the p-value
 * of the distribution difference between the metric and the restriction of that metric to a subset
 * of the documents. A natural use case is if the sibling aggregation range aggregation nested in a
 * terms aggregation, in which case one compares the overall distribution of metric to its restriction
 * to each term.
 */
export const types_aggregations_bucket_ks_aggregation = types_aggregations_bucket_path_aggregation.and(z.object({
    alternative: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'A list of string values indicating which K-S test alternative to calculate. The valid values\nare: "greater", "less", "two_sided". This parameter is key for determining the K-S statistic used\nwhen calculating the K-S test. Default value is all possible alternative hypotheses.'
    })),
    fractions: z.optional(z.array(z.number()).register(z.globalRegistry, {
        description: 'A list of doubles indicating the distribution of the samples with which to compare to the `buckets_path` results.\nIn typical usage this is the overall proportion of documents in each bucket, which is compared with the actual\ndocument proportions in each bucket from the sibling aggregation counts. The default is to assume that overall\ndocuments are uniformly distributed on these buckets, which they would be if one used equal percentiles of a\nmetric to define the bucket end points.'
    })),
    sampling_method: z.optional(z.string().register(z.globalRegistry, {
        description: 'Indicates the sampling methodology when calculating the K-S test. Note, this is sampling of the returned values.\nThis determines the cumulative distribution function (CDF) points used comparing the two samples. Default is\n`upper_tail`, which emphasizes the upper end of the CDF points. Valid options are: `upper_tail`, `uniform`,\nand `lower_tail`.'
    }))
}));

export const types_aggregations_average_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_minimum_interval = z.enum([
    'second',
    'minute',
    'hour',
    'day',
    'month',
    'year'
]);

export const types_op_type = z.enum(['index', 'create']);

export const types_refresh = z.enum([
    'true',
    'false',
    'wait_for'
]);

export const types_result = z.enum([
    'created',
    'updated',
    'deleted',
    'not_found',
    'noop'
]);

/**
 * Cause and details about a request failure. This class defines the properties common to all error types.
 * Additional details are also provided, that depend on the error type.
 */
export const types_error_cause = z.object({
    type: z.string().register(z.globalRegistry, {
        description: 'The type of error'
    }),
    reason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    stack_trace: z.optional(z.string().register(z.globalRegistry, {
        description: 'The server stack trace. Present only if the `error_trace=true` parameter was sent with the request.'
    })),
    get caused_by() {
        return z.optional(z.lazy((): any => types_error_cause));
    },
    get root_cause() {
        return z.optional(z.array(z.lazy((): any => types_error_cause)));
    },
    get suppressed() {
        return z.optional(z.array(z.lazy((): any => types_error_cause)));
    }
}).register(z.globalRegistry, {
    description: 'Cause and details about a request failure. This class defines the properties common to all error types.\nAdditional details are also provided, that depend on the error type.'
});

/**
 * Time unit for nanoseconds
 */
export const types_unit_nanos = z.number().register(z.globalRegistry, {
    description: 'Time unit for nanoseconds'
});

export const types_duration_value_unit_nanos = types_unit_nanos;

export const types_node_id = z.string();

export const types_inline_get = z.object({
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    found: z.boolean(),
    _seq_no: z.optional(types_sequence_number),
    _primary_term: z.optional(z.number()),
    _routing: z.optional(types_routing),
    _source: z.optional(z.record(z.string(), z.unknown()))
});

export const global_bulk_failure_store_status = z.enum([
    'not_applicable_or_unknown',
    'used',
    'not_enabled',
    'failed'
]);

export const types_shard_failure = z.object({
    index: z.optional(types_index_name),
    node: z.optional(z.string()),
    reason: types_error_cause,
    shard: z.optional(z.number()),
    status: z.optional(z.string()),
    primary: z.optional(z.boolean())
});

export const types_shard_statistics = z.object({
    failed: types_uint,
    successful: types_uint,
    total: types_uint,
    failures: z.optional(z.array(types_shard_failure)),
    skipped: z.optional(types_uint)
});

export const types_write_response_base = z.object({
    _id: types_id,
    _index: types_index_name,
    _primary_term: z.optional(z.number().register(z.globalRegistry, {
        description: 'The primary term assigned to the document for the indexing operation.'
    })),
    result: types_result,
    _seq_no: z.optional(types_sequence_number),
    _shards: types_shard_statistics,
    _version: types_version_number,
    failure_store: z.optional(global_bulk_failure_store_status),
    forced_refresh: z.optional(z.boolean())
});

export const global_update_update_write_response_base = types_write_response_base.and(z.object({
    get: z.optional(types_inline_get)
}));

export const types_indices = z.union([
    types_index_name,
    z.array(types_index_name)
]);

export const types_uuid = z.string();

export const types_mapping_data_stream_timestamp = z.object({
    enabled: z.boolean()
});

export const types_mapping_source_field_mode = z.enum([
    'disabled',
    'stored',
    'synthetic'
]);

export const types_mapping_source_field = z.object({
    compress: z.optional(z.boolean()),
    compress_threshold: z.optional(z.string()),
    enabled: z.optional(z.boolean()),
    excludes: z.optional(z.array(z.string())),
    includes: z.optional(z.array(z.string())),
    mode: z.optional(types_mapping_source_field_mode)
});

export const types_mapping_size_field = z.object({
    enabled: z.boolean()
});

export const types_mapping_routing_field = z.object({
    required: z.boolean()
});

export const types_mapping_index_field = z.object({
    enabled: z.boolean()
});

export const types_mapping_field_names_field = z.object({
    enabled: z.boolean()
});

export const types_analysis_icu_collation_case_first = z.enum(['lower', 'upper']);

export const types_analysis_icu_collation_alternate = z.enum(['shifted', 'non-ignorable']);

export const types_analysis_icu_collation_decomposition = z.enum(['no', 'identical']);

export const types_analysis_icu_collation_strength = z.enum([
    'primary',
    'secondary',
    'tertiary',
    'quaternary',
    'identical'
]);

export const types_mapping_index_options = z.enum([
    'docs',
    'freqs',
    'positions',
    'offsets'
]);

export const types_mapping_synthetic_source_keep_enum = z.enum([
    'none',
    'arrays',
    'all'
]);

export const types_mapping_dynamic_mapping = z.enum([
    'strict',
    'runtime',
    'true',
    'false'
]);

export const types_mapping_time_series_metric_type = z.enum([
    'gauge',
    'counter',
    'summary',
    'histogram',
    'position'
]);

export const types_mapping_on_script_error = z.enum(['fail', 'continue']);

export const types_short = z.number();

export const types_byte = z.number();

export const types_mapping_geo_orientation = z.enum([
    'right',
    'RIGHT',
    'counterclockwise',
    'ccw',
    'left',
    'LEFT',
    'clockwise',
    'cw'
]);

export const types_mapping_geo_strategy = z.enum(['recursive', 'term']);

export const types_mapping_geo_point_metric_type = z.enum([
    'gauge',
    'counter',
    'position'
]);

export const types_mapping_suggest_context = z.object({
    name: types_name,
    path: z.optional(types_field),
    type: z.string(),
    precision: z.optional(z.union([
        z.number(),
        z.string()
    ]))
});

export const types_mapping_sparse_vector_index_options = z.object({
    prune: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether to perform pruning, omitting the non-significant tokens from the query to improve query performance.\nIf prune is true but the pruning_config is not specified, pruning will occur but default values will be used.\nDefault: false'
    })),
    pruning_config: z.optional(types_token_pruning_config)
});

export const types_mapping_chunking_settings = z.object({
    strategy: z.string().register(z.globalRegistry, {
        description: 'The chunking strategy: `sentence`, `word`, `none` or `recursive`.\n\n * If `strategy` is set to `recursive`, you must also specify:\n\n- `max_chunk_size`\n- either `separators` or`separator_group`\n\nLearn more about different chunking strategies in the linked documentation.'
    }),
    separator_group: z.optional(z.string().register(z.globalRegistry, {
        description: 'Only applicable to the `recursive` strategy and required when using it.\n\nSets a predefined list of separators in the saved chunking settings based on the selected text type.\nValues can be `markdown` or `plaintext`.\n\nUsing this parameter is an alternative to manually specifying a custom `separators` list.'
    })),
    separators: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Only applicable to the `recursive` strategy and required when using it.\n\nA list of strings used as possible split points when chunking text.\n\nEach string can be a plain string or a regular expression (regex) pattern.\nThe system tries each separator in order to split the text, starting from the first item in the list.\n\nAfter splitting, it attempts to recombine smaller pieces into larger chunks that stay within\nthe `max_chunk_size` limit, to reduce the total number of chunks generated.'
    })),
    max_chunk_size: z.number().register(z.globalRegistry, {
        description: 'The maximum size of a chunk in words.\nThis value cannot be lower than `20` (for `sentence` strategy) or `10` (for `word` strategy).\nThis value should not exceed the window size for the associated model.'
    }),
    overlap: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of overlapping words for chunks.\nIt is applicable only to a `word` chunking strategy.\nThis value cannot be higher than half the `max_chunk_size` value.'
    })),
    sentence_overlap: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of overlapping sentences for chunks.\nIt is applicable only for a `sentence` chunking strategy.\nIt can be either `1` or `0`.'
    }))
});

export const types_mapping_dense_vector_index_options_rescore_vector = z.object({
    oversample: z.number().register(z.globalRegistry, {
        description: 'The oversampling factor to use when searching for the nearest neighbor. This is only applicable to the quantized formats: `bbq_*`, `int4_*`, and `int8_*`.\nWhen provided, `oversample * k` vectors will be gathered and then their scores will be re-computed with the original vectors.\n\nvalid values are between `1.0` and `10.0` (inclusive), or `0` exactly to disable oversampling.'
    })
});

export const types_mapping_dense_vector_index_options_type = z.enum([
    'bbq_flat',
    'bbq_hnsw',
    'bbq_disk',
    'flat',
    'hnsw',
    'int4_flat',
    'int4_hnsw',
    'int8_flat',
    'int8_hnsw'
]);

export const types_mapping_dense_vector_index_options = z.object({
    confidence_interval: z.optional(z.number().register(z.globalRegistry, {
        description: 'The confidence interval to use when quantizing the vectors. Can be any value between and including `0.90` and\n`1.0` or exactly `0`. When the value is `0`, this indicates that dynamic quantiles should be calculated for\noptimized quantization. When between `0.90` and `1.0`, this value restricts the values used when calculating\nthe quantization thresholds.\n\nFor example, a value of `0.95` will only use the middle `95%` of the values when calculating the quantization\nthresholds (e.g. the highest and lowest `2.5%` of values will be ignored).\n\nDefaults to `1/(dims + 1)` for `int8` quantized vectors and `0` for `int4` for dynamic quantile calculation.\n\nOnly applicable to `int8_hnsw`, `int4_hnsw`, `int8_flat`, and `int4_flat` index types.'
    })),
    ef_construction: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of candidates to track while assembling the list of nearest neighbors for each new node.\n\nOnly applicable to `hnsw`, `int8_hnsw`, `bbq_hnsw`, and `int4_hnsw` index types.'
    })),
    m: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of neighbors each node will be connected to in the HNSW graph.\n\nOnly applicable to `hnsw`, `int8_hnsw`, `bbq_hnsw`, and `int4_hnsw` index types.'
    })),
    type: types_mapping_dense_vector_index_options_type,
    rescore_vector: z.optional(types_mapping_dense_vector_index_options_rescore_vector),
    on_disk_rescore: z.optional(z.boolean().register(z.globalRegistry, {
        description: '`true` if vector rescoring should be done on-disk\n\nOnly applicable to `bbq_disk`, `bbq_hnsw`, `int4_hnsw`, `int8_hnsw`'
    }))
});

export const types_mapping_semantic_text_index_options = z.object({
    dense_vector: z.optional(types_mapping_dense_vector_index_options),
    sparse_vector: z.optional(types_mapping_sparse_vector_index_options)
});

export const types_mapping_rank_vector_element_type = z.enum([
    'byte',
    'float',
    'bit'
]);

export const types_mapping_subobjects = z.enum(['true', 'false']);

export const types_mapping_dense_vector_similarity = z.enum([
    'cosine',
    'dot_product',
    'l2_norm',
    'max_inner_product'
]);

export const types_mapping_dense_vector_element_type = z.enum([
    'bit',
    'byte',
    'float',
    'bfloat16'
]);

export const indices_types_numeric_fielddata_format = z.enum(['array', 'disabled']);

export const indices_types_numeric_fielddata = z.object({
    format: indices_types_numeric_fielddata_format
});

export const indices_types_fielddata_frequency_filter = z.object({
    max: z.number(),
    min: z.number(),
    min_segment_size: z.number()
});

export const types_mapping_term_vector_option = z.enum([
    'no',
    'yes',
    'with_offsets',
    'with_positions',
    'with_positions_offsets',
    'with_positions_offsets_payloads',
    'with_positions_payloads'
]);

export const types_mapping_text_index_prefixes = z.object({
    max_chars: z.number(),
    min_chars: z.number()
});

export const types_mapping_match_type = z.enum(['simple', 'regex']);

export const types_mapping_all_field = z.object({
    analyzer: z.string(),
    enabled: z.boolean(),
    omit_norms: z.boolean(),
    search_analyzer: z.string(),
    similarity: z.string(),
    store: z.boolean(),
    store_term_vector_offsets: z.boolean(),
    store_term_vector_payloads: z.boolean(),
    store_term_vector_positions: z.boolean(),
    store_term_vectors: z.boolean()
});

/**
 * Base type for multi-bucket aggregation results that can hold sub-aggregations results.
 */
export const types_aggregations_multi_bucket_base = z.object({
    doc_count: z.number()
}).register(z.globalRegistry, {
    description: 'Base type for multi-bucket aggregation results that can hold sub-aggregations results.'
});

export const types_aggregations_composite_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_aggregations_composite_aggregate_key
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_composite_bucket = z.union([
    z.record(z.string(), types_aggregations_composite_bucket),
    z.array(types_aggregations_composite_bucket)
]);

export const types_aggregations_aggregate_base = z.object({
    meta: z.optional(types_metadata)
});

export const types_aggregations_multi_bucket_aggregate_base_composite_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_composite_bucket
}));

export const types_aggregations_composite_aggregate = types_aggregations_multi_bucket_aggregate_base_composite_bucket.and(z.object({
    after_key: z.optional(types_aggregations_composite_aggregate_key)
}));

export const types_aggregations_range_bucket = types_aggregations_multi_bucket_base.and(z.object({
    from: z.optional(z.number()),
    to: z.optional(z.number()),
    from_as_string: z.optional(z.string()),
    to_as_string: z.optional(z.string()),
    key: z.optional(z.string().register(z.globalRegistry, {
        description: 'The bucket key. Present if the aggregation is _not_ keyed'
    }))
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_range_bucket = z.union([
    z.record(z.string(), types_aggregations_range_bucket),
    z.array(types_aggregations_range_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_range_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_range_bucket
}));

export const types_aggregations_range_aggregate = types_aggregations_multi_bucket_aggregate_base_range_bucket.and(z.record(z.string(), z.unknown()));

/**
 * Result of a `date_range` aggregation. Same format as a for a `range` aggregation: `from` and `to`
 * in `buckets` are milliseconds since the Epoch, represented as a floating point number.
 */
export const types_aggregations_date_range_aggregate = types_aggregations_range_aggregate.and(z.record(z.string(), z.unknown()));

export const types_aggregations_filters_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_filters_bucket = z.union([
    z.record(z.string(), types_aggregations_filters_bucket),
    z.array(types_aggregations_filters_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_filters_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_filters_bucket
}));

export const types_aggregations_filters_aggregate = types_aggregations_multi_bucket_aggregate_base_filters_bucket.and(z.record(z.string(), z.unknown()));

/**
 * Base type for single-bucket aggregation results that can hold sub-aggregations results.
 */
export const types_aggregations_single_bucket_aggregate_base = types_aggregations_aggregate_base.and(z.object({
    doc_count: z.number()
}));

export const types_aggregations_filter_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_missing_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_multi_terms_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.array(types_field_value),
    key_as_string: z.optional(z.string()),
    doc_count_error_upper_bound: z.optional(z.number())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_multi_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_multi_terms_bucket),
    z.array(types_aggregations_multi_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_multi_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_multi_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_multi_terms_bucket = types_aggregations_multi_bucket_aggregate_base_multi_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number()),
    sum_other_doc_count: z.optional(z.number())
}));

export const types_aggregations_multi_terms_aggregate = types_aggregations_terms_aggregate_base_multi_terms_bucket.and(z.record(z.string(), z.unknown()));

/**
 * The absence of any type. This is commonly used in APIs that don't return a body.
 *
 * Although "void" is generally used for the unit type that has only one value, this is to be interpreted as
 * the bottom type that has no value at all. Most languages have a unit type, but few have a bottom type.
 *
 * See https://en.m.wikipedia.org/wiki/Unit_type and https://en.m.wikipedia.org/wiki/Bottom_type
 */
export const spec_utils_void = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'The absence of any type. This is commonly used in APIs that don\'t return a body.\n\nAlthough "void" is generally used for the unit type that has only one value, this is to be interpreted as\nthe bottom type that has no value at all. Most languages have a unit type, but few have a bottom type.\n\nSee https://en.m.wikipedia.org/wiki/Unit_type and https://en.m.wikipedia.org/wiki/Bottom_type'
});

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_void = z.union([
    z.record(z.string(), spec_utils_void),
    z.array(spec_utils_void)
]);

export const types_aggregations_multi_bucket_aggregate_base_void = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_void
}));

export const types_aggregations_terms_aggregate_base_void = types_aggregations_multi_bucket_aggregate_base_void.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number()),
    sum_other_doc_count: z.optional(z.number())
}));

/**
 * Result of a `terms` aggregation when the field is unmapped. `buckets` is always empty.
 */
export const types_aggregations_unmapped_terms_aggregate = types_aggregations_terms_aggregate_base_void.and(z.record(z.string(), z.unknown()));

export const types_aggregations_terms_bucket_base = types_aggregations_multi_bucket_base.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number())
}));

export const types_aggregations_double_terms_bucket = types_aggregations_terms_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_double_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_double_terms_bucket),
    z.array(types_aggregations_double_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_double_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_double_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_double_terms_bucket = types_aggregations_multi_bucket_aggregate_base_double_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number()),
    sum_other_doc_count: z.optional(z.number())
}));

/**
 * Result of a `terms` aggregation when the field is some kind of decimal number like a float, double, or distance.
 */
export const types_aggregations_double_terms_aggregate = types_aggregations_terms_aggregate_base_double_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_long_terms_bucket = types_aggregations_terms_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_long_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_long_terms_bucket),
    z.array(types_aggregations_long_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_long_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_long_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_long_terms_bucket = types_aggregations_multi_bucket_aggregate_base_long_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number()),
    sum_other_doc_count: z.optional(z.number())
}));

/**
 * Result of a `terms` aggregation when the field is some kind of whole number like a integer, long, or a date.
 */
export const types_aggregations_long_terms_aggregate = types_aggregations_terms_aggregate_base_long_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_string_terms_bucket = types_aggregations_terms_bucket_base.and(z.object({
    key: types_field_value
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_string_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_string_terms_bucket),
    z.array(types_aggregations_string_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_string_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_string_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_string_terms_bucket = types_aggregations_multi_bucket_aggregate_base_string_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.optional(z.number()),
    sum_other_doc_count: z.optional(z.number())
}));

/**
 * Result of a `terms` aggregation when the field is a string.
 */
export const types_aggregations_string_terms_aggregate = types_aggregations_terms_aggregate_base_string_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_single_metric_aggregate_base = types_aggregations_aggregate_base.and(z.object({
    value: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    value_as_string: z.optional(z.string())
}));

/**
 * Value count aggregation result. `value` is always present.
 */
export const types_aggregations_value_count_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_cardinality_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.number()
}));

export const indices_types_storage_type = z.union([
    z.enum([
        'fs',
        'niofs',
        'mmapfs',
        'hybridfs'
    ]),
    z.string()
]);

export const indices_types_storage = z.object({
    type: indices_types_storage_type,
    allow_mmap: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'You can restrict the use of the mmapfs and the related hybridfs store type via the setting node.store.allow_mmap.\nThis is a boolean setting indicating whether or not memory-mapping is allowed. The default is to allow it. This\nsetting is useful, for example, if you are in an environment where you can not control the ability to create a lot\nof memory maps so you need disable the ability to use memory-mapping.'
    })),
    stats_refresh_interval: z.optional(types_duration)
});

export const indices_types_indexing_pressure_memory = z.object({
    limit: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of outstanding bytes that may be consumed by indexing requests. When this limit is reached or exceeded,\nthe node will reject new coordinating and primary operations. When replica operations consume 1.5x this limit,\nthe node will reject new replica operations. Defaults to 10% of the heap.'
    }))
});

export const indices_types_indexing_pressure = z.object({
    memory: indices_types_indexing_pressure_memory
});

export const indices_types_slowlog_treshold_levels = z.object({
    warn: z.optional(types_duration),
    info: z.optional(types_duration),
    debug: z.optional(types_duration),
    trace: z.optional(types_duration)
});

export const indices_types_indexing_slowlog_tresholds = z.object({
    index: z.optional(indices_types_slowlog_treshold_levels)
});

export const indices_types_indexing_slowlog_settings = z.object({
    level: z.optional(z.string()),
    source: z.optional(z.number()),
    reformat: z.optional(z.boolean()),
    threshold: z.optional(indices_types_indexing_slowlog_tresholds)
});

export const indices_types_source_mode = z.enum([
    'disabled',
    'stored',
    'synthetic'
]);

export const indices_types_mapping_limit_settings_source_fields = z.object({
    mode: indices_types_source_mode
});

export const indices_types_mapping_limit_settings_dimension_fields = z.object({
    limit: z.optional(z.number().register(z.globalRegistry, {
        description: '[preview] This functionality is in technical preview and may be changed or removed in a future release.\nElastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.'
    }))
});

export const indices_types_mapping_limit_settings_field_name_length = z.object({
    limit: z.optional(z.number().register(z.globalRegistry, {
        description: 'Setting for the maximum length of a field name. This setting isn’t really something that addresses mappings explosion but\nmight still be useful if you want to limit the field length. It usually shouldn’t be necessary to set this setting. The\ndefault is okay unless a user starts to add a huge number of fields with really long names. Default is `Long.MAX_VALUE` (no limit).'
    }))
});

export const indices_types_mapping_limit_settings_nested_objects = z.object({
    limit: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps\nto prevent out of memory errors when a document contains too many nested objects.'
    }))
});

export const indices_types_mapping_limit_settings_nested_fields = z.object({
    limit: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of distinct nested mappings in an index. The nested type should only be used in special cases, when\narrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this\nsetting limits the number of unique nested types per index.'
    }))
});

export const indices_types_mapping_limit_settings_depth = z.object({
    limit: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum depth for a field, which is measured as the number of inner objects. For instance, if all fields are defined\nat the root object level, then the depth is 1. If there is one object mapping, then the depth is 2, etc.'
    }))
});

export const indices_types_mapping_limit_settings_total_fields = z.object({
    limit: z.optional(z.union([
        z.number(),
        z.string()
    ])),
    ignore_dynamic_beyond_limit: z.optional(z.union([
        z.boolean(),
        z.string()
    ]))
});

/**
 * Mapping Limit Settings
 */
export const indices_types_mapping_limit_settings = z.object({
    coerce: z.optional(z.boolean()),
    total_fields: z.optional(indices_types_mapping_limit_settings_total_fields),
    depth: z.optional(indices_types_mapping_limit_settings_depth),
    nested_fields: z.optional(indices_types_mapping_limit_settings_nested_fields),
    nested_objects: z.optional(indices_types_mapping_limit_settings_nested_objects),
    field_name_length: z.optional(indices_types_mapping_limit_settings_field_name_length),
    dimension_fields: z.optional(indices_types_mapping_limit_settings_dimension_fields),
    source: z.optional(indices_types_mapping_limit_settings_source_fields),
    ignore_malformed: z.optional(z.union([
        z.boolean(),
        z.string()
    ]))
}).register(z.globalRegistry, {
    description: 'Mapping Limit Settings'
});

export const indices_types_settings_similarity_lmj = z.object({
    type: z.enum(['LMJelinekMercer']),
    lambda: z.optional(z.number())
});

export const indices_types_settings_similarity_lmd = z.object({
    type: z.enum(['LMDirichlet']),
    mu: z.optional(z.number())
});

export const types_ib_lambda = z.enum(['df', 'ttf']);

export const types_ib_distribution = z.enum(['ll', 'spl']);

export const types_normalization = z.enum([
    'no',
    'h1',
    'h2',
    'h3',
    'z'
]);

export const indices_types_settings_similarity_ib = z.object({
    type: z.enum(['IB']),
    distribution: types_ib_distribution,
    lambda: types_ib_lambda,
    normalization: types_normalization
});

export const types_dfr_basic_model = z.enum([
    'be',
    'd',
    'g',
    'if',
    'in',
    'ine',
    'p'
]);

export const types_dfr_after_effect = z.enum([
    'no',
    'b',
    'l'
]);

export const indices_types_settings_similarity_dfr = z.object({
    type: z.enum(['DFR']),
    after_effect: types_dfr_after_effect,
    basic_model: types_dfr_basic_model,
    normalization: types_normalization
});

export const types_dfi_independence_measure = z.enum([
    'standardized',
    'saturated',
    'chisquared'
]);

export const indices_types_settings_similarity_dfi = z.object({
    type: z.enum(['DFI']),
    independence_measure: types_dfi_independence_measure
});

export const indices_types_settings_similarity_boolean = z.object({
    type: z.enum(['boolean'])
});

export const indices_types_settings_similarity_bm25 = z.object({
    type: z.enum(['BM25']),
    b: z.optional(z.number()),
    discount_overlaps: z.optional(z.boolean()),
    k1: z.optional(z.number())
});

export const indices_types_cache_queries = z.object({
    enabled: z.boolean()
});

export const indices_types_queries = z.object({
    cache: z.optional(indices_types_cache_queries)
});

export const indices_types_index_settings_time_series = z.object({
    end_time: z.optional(types_date_time),
    start_time: z.optional(types_date_time)
});

export const types_analysis_nori_decompound_mode = z.enum([
    'discard',
    'none',
    'mixed'
]);

export const types_analysis_tokenizer_base = z.object({
    version: z.optional(types_version_string)
});

export const types_analysis_nori_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['nori_tokenizer']),
    decompound_mode: z.optional(types_analysis_nori_decompound_mode),
    discard_punctuation: z.optional(z.boolean()),
    user_dictionary: z.optional(z.string()),
    user_dictionary_rules: z.optional(z.array(z.string()))
}));

export const types_analysis_kuromoji_tokenization_mode = z.enum([
    'normal',
    'search',
    'extended'
]);

export const types_analysis_kuromoji_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['kuromoji_tokenizer']),
    discard_punctuation: z.optional(z.boolean()),
    mode: types_analysis_kuromoji_tokenization_mode,
    nbest_cost: z.optional(z.number()),
    nbest_examples: z.optional(z.string()),
    user_dictionary: z.optional(z.string()),
    user_dictionary_rules: z.optional(z.array(z.string())),
    discard_compound_token: z.optional(z.boolean())
}));

export const types_analysis_icu_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['icu_tokenizer']),
    rule_files: z.string()
}));

export const types_analysis_whitespace_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['whitespace']),
    max_token_length: z.optional(z.number())
}));

export const types_analysis_uax_email_url_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['uax_url_email']),
    max_token_length: z.optional(z.number())
}));

export const types_analysis_thai_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['thai'])
}));

export const types_analysis_standard_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['standard']),
    max_token_length: z.optional(z.number())
}));

export const types_analysis_simple_pattern_split_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['simple_pattern_split']),
    pattern: z.optional(z.string())
}));

export const types_analysis_simple_pattern_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['simple_pattern']),
    pattern: z.optional(z.string())
}));

export const types_analysis_pattern_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['pattern']),
    flags: z.optional(z.string()),
    group: z.optional(z.number()),
    pattern: z.optional(z.string())
}));

/**
 * Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
 * is used to capture this behavior while keeping the semantics of the field type.
 *
 * Depending on the target language, code generators can keep the union or remove it and leniently parse
 * strings to the target type.
 */
export const spec_utils_stringifiedboolean = z.union([
    z.boolean(),
    z.string()
]);

/**
 * Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
 * is used to capture this behavior while keeping the semantics of the field type.
 *
 * Depending on the target language, code generators can keep the union or remove it and leniently parse
 * strings to the target type.
 */
export const spec_utils_stringifiedinteger = z.union([
    z.number(),
    z.string()
]);

export const types_analysis_path_hierarchy_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['path_hierarchy']),
    buffer_size: z.optional(spec_utils_stringifiedinteger),
    delimiter: z.optional(z.string()),
    replacement: z.optional(z.string()),
    reverse: z.optional(spec_utils_stringifiedboolean),
    skip: z.optional(spec_utils_stringifiedinteger)
}));

export const types_analysis_token_char = z.enum([
    'letter',
    'digit',
    'whitespace',
    'punctuation',
    'symbol',
    'custom'
]);

export const types_analysis_n_gram_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['ngram']),
    custom_token_chars: z.optional(z.string()),
    max_gram: z.optional(z.number()),
    min_gram: z.optional(z.number()),
    token_chars: z.optional(z.array(types_analysis_token_char))
}));

export const types_analysis_lowercase_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['lowercase'])
}));

export const types_analysis_letter_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['letter'])
}));

export const types_analysis_keyword_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['keyword']),
    buffer_size: z.optional(z.number())
}));

export const types_analysis_edge_n_gram_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['edge_ngram']),
    custom_token_chars: z.optional(z.string()),
    max_gram: z.optional(z.number()),
    min_gram: z.optional(z.number()),
    token_chars: z.optional(z.array(types_analysis_token_char))
}));

export const types_analysis_classic_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['classic']),
    max_token_length: z.optional(z.number())
}));

export const types_analysis_char_group_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['char_group']),
    tokenize_on_chars: z.array(z.string()),
    max_token_length: z.optional(z.number())
}));

export const types_analysis_tokenizer_definition = z.union([
    z.object({
        type: z.literal('char_group')
    }).and(types_analysis_char_group_tokenizer),
    z.object({
        type: z.literal('classic')
    }).and(types_analysis_classic_tokenizer),
    z.object({
        type: z.literal('edge_ngram')
    }).and(types_analysis_edge_n_gram_tokenizer),
    z.object({
        type: z.literal('keyword')
    }).and(types_analysis_keyword_tokenizer),
    z.object({
        type: z.literal('letter')
    }).and(types_analysis_letter_tokenizer),
    z.object({
        type: z.literal('lowercase')
    }).and(types_analysis_lowercase_tokenizer),
    z.object({
        type: z.literal('ngram')
    }).and(types_analysis_n_gram_tokenizer),
    z.object({
        type: z.literal('path_hierarchy')
    }).and(types_analysis_path_hierarchy_tokenizer),
    z.object({
        type: z.literal('pattern')
    }).and(types_analysis_pattern_tokenizer),
    z.object({
        type: z.literal('simple_pattern')
    }).and(types_analysis_simple_pattern_tokenizer),
    z.object({
        type: z.literal('simple_pattern_split')
    }).and(types_analysis_simple_pattern_split_tokenizer),
    z.object({
        type: z.literal('standard')
    }).and(types_analysis_standard_tokenizer),
    z.object({
        type: z.literal('thai')
    }).and(types_analysis_thai_tokenizer),
    z.object({
        type: z.literal('uax_url_email')
    }).and(types_analysis_uax_email_url_tokenizer),
    z.object({
        type: z.literal('whitespace')
    }).and(types_analysis_whitespace_tokenizer),
    z.object({
        type: z.literal('icu_tokenizer')
    }).and(types_analysis_icu_tokenizer),
    z.object({
        type: z.literal('kuromoji_tokenizer')
    }).and(types_analysis_kuromoji_tokenizer),
    z.object({
        type: z.literal('nori_tokenizer')
    }).and(types_analysis_nori_tokenizer)
]);

export const types_analysis_tokenizer = z.union([
    z.string(),
    types_analysis_tokenizer_definition
]);

export const types_analysis_custom_normalizer = z.object({
    type: z.enum(['custom']),
    char_filter: z.optional(z.array(z.string())),
    filter: z.optional(z.array(z.string()))
});

export const types_analysis_lowercase_normalizer = z.object({
    type: z.enum(['lowercase'])
});

export const types_analysis_normalizer = z.union([
    z.object({
        type: z.literal('lowercase')
    }).and(types_analysis_lowercase_normalizer),
    z.object({
        type: z.literal('custom')
    }).and(types_analysis_custom_normalizer)
]);

export const types_analysis_token_filter_base = z.object({
    version: z.optional(types_version_string)
});

export const types_analysis_compound_word_token_filter_base = types_analysis_token_filter_base.and(z.object({
    max_subword_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum subword character length. Longer subword tokens are excluded from the output. Defaults to `15`.'
    })),
    min_subword_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Minimum subword character length. Shorter subword tokens are excluded from the output. Defaults to `2`.'
    })),
    min_word_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Minimum word character length. Shorter word tokens are excluded from the output. Defaults to `5`.'
    })),
    only_longest_match: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, only include the longest matching subword. Defaults to `false`.'
    })),
    word_list: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'A list of subwords to look for in the token stream. If found, the subword is included in the token output.\nEither this parameter or `word_list_path` must be specified.'
    })),
    word_list_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path to a file that contains a list of subwords to find in the token stream. If found, the subword is included in the token output.\nThis path must be absolute or relative to the config location, and the file must be UTF-8 encoded. Each token in the file must be separated by a line break.\nEither this parameter or `word_list` must be specified.'
    }))
}));

export const types_analysis_dictionary_decompounder_token_filter = types_analysis_compound_word_token_filter_base.and(z.object({
    type: z.enum(['dictionary_decompounder'])
}));

export const types_analysis_phonetic_rule_type = z.enum(['approx', 'exact']);

export const types_analysis_phonetic_name_type = z.enum([
    'generic',
    'ashkenazi',
    'sephardic'
]);

export const types_analysis_phonetic_language = z.enum([
    'any',
    'common',
    'cyrillic',
    'english',
    'french',
    'german',
    'hebrew',
    'hungarian',
    'polish',
    'romanian',
    'russian',
    'spanish'
]);

export const types_analysis_phonetic_encoder = z.enum([
    'metaphone',
    'double_metaphone',
    'soundex',
    'refined_soundex',
    'caverphone1',
    'caverphone2',
    'cologne',
    'nysiis',
    'koelnerphonetik',
    'haasephonetik',
    'beider_morse',
    'daitch_mokotoff'
]);

export const types_analysis_phonetic_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['phonetic']),
    encoder: types_analysis_phonetic_encoder,
    languageset: z.optional(z.union([
        types_analysis_phonetic_language,
        z.array(types_analysis_phonetic_language)
    ])),
    max_code_len: z.optional(z.number()),
    name_type: z.optional(types_analysis_phonetic_name_type),
    replace: z.optional(z.boolean()),
    rule_type: z.optional(types_analysis_phonetic_rule_type)
}));

export const types_analysis_icu_transform_direction = z.enum(['forward', 'reverse']);

export const types_analysis_icu_transform_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['icu_transform']),
    dir: z.optional(types_analysis_icu_transform_direction),
    id: z.string()
}));

export const types_analysis_icu_normalization_type = z.enum([
    'nfc',
    'nfkc',
    'nfkc_cf'
]);

export const types_analysis_icu_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['icu_normalizer']),
    name: types_analysis_icu_normalization_type
}));

export const types_analysis_icu_folding_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['icu_folding']),
    unicode_set_filter: z.string()
}));

export const types_analysis_icu_collation_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['icu_collation']),
    alternate: z.optional(types_analysis_icu_collation_alternate),
    caseFirst: z.optional(types_analysis_icu_collation_case_first),
    caseLevel: z.optional(z.boolean()),
    country: z.optional(z.string()),
    decomposition: z.optional(types_analysis_icu_collation_decomposition),
    hiraganaQuaternaryMode: z.optional(z.boolean()),
    language: z.optional(z.string()),
    numeric: z.optional(z.boolean()),
    rules: z.optional(z.string()),
    strength: z.optional(types_analysis_icu_collation_strength),
    variableTop: z.optional(z.string()),
    variant: z.optional(z.string())
}));

export const types_analysis_kuromoji_part_of_speech_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['kuromoji_part_of_speech']),
    stoptags: z.array(z.string())
}));

export const types_analysis_kuromoji_reading_form_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['kuromoji_readingform']),
    use_romaji: z.boolean()
}));

export const types_analysis_kuromoji_stemmer_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['kuromoji_stemmer']),
    minimum_length: z.number()
}));

export const types_analysis_ja_stop_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['ja_stop']),
    stopwords: z.optional(types_analysis_stop_words)
}));

export const types_analysis_word_delimiter_token_filter_base = types_analysis_token_filter_base.and(z.object({
    catenate_all: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter produces catenated tokens for chains of alphanumeric characters separated by non-alphabetic delimiters. Defaults to `false`.'
    })),
    catenate_numbers: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter produces catenated tokens for chains of numeric characters separated by non-alphabetic delimiters. Defaults to `false`.'
    })),
    catenate_words: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter produces catenated tokens for chains of alphabetical characters separated by non-alphabetic delimiters. Defaults to `false`.'
    })),
    generate_number_parts: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter includes tokens consisting of only numeric characters in the output. If `false`, the filter excludes these tokens from the output. Defaults to `true`.'
    })),
    generate_word_parts: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter includes tokens consisting of only alphabetical characters in the output. If `false`, the filter excludes these tokens from the output. Defaults to `true`.'
    })),
    preserve_original: z.optional(spec_utils_stringifiedboolean),
    protected_words: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Array of tokens the filter won’t split.'
    })),
    protected_words_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path to a file that contains a list of tokens the filter won’t split.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each token in the file must be separated by a line break.'
    })),
    split_on_case_change: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter splits tokens at letter case transitions. For example: camelCase -> [ camel, Case ]. Defaults to `true`.'
    })),
    split_on_numerics: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter splits tokens at letter-number transitions. For example: j2se -> [ j, 2, se ]. Defaults to `true`.'
    })),
    stem_english_possessive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter removes the English possessive (`\'s`) from the end of each token. For example: O\'Neil\'s -> [ O, Neil ]. Defaults to `true`.'
    })),
    type_table: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Array of custom type mappings for characters. This allows you to map non-alphanumeric characters as numeric or alphanumeric to avoid splitting on those characters.'
    })),
    type_table_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path to a file that contains custom type mappings for characters. This allows you to map non-alphanumeric characters as numeric or alphanumeric to avoid splitting on those characters.'
    }))
}));

export const types_analysis_word_delimiter_token_filter = types_analysis_word_delimiter_token_filter_base.and(z.object({
    type: z.enum(['word_delimiter'])
}));

export const types_analysis_word_delimiter_graph_token_filter = types_analysis_word_delimiter_token_filter_base.and(z.object({
    type: z.enum(['word_delimiter_graph']),
    adjust_offsets: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter adjusts the offsets of split or catenated tokens to better reflect their actual position in the token stream. Defaults to `true`.'
    })),
    ignore_keywords: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter skips tokens with a keyword attribute of true. Defaults to `false`.'
    }))
}));

export const types_analysis_uppercase_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['uppercase'])
}));

export const types_analysis_unique_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['unique']),
    only_on_same_position: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, only remove duplicate tokens in the same position. Defaults to `false`.'
    }))
}));

export const types_analysis_truncate_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['truncate']),
    length: z.optional(z.number().register(z.globalRegistry, {
        description: 'Character limit for each token. Tokens exceeding this limit are truncated. Defaults to `10`.'
    }))
}));

export const types_analysis_trim_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['trim'])
}));

export const types_analysis_synonym_format = z.enum(['solr', 'wordnet']);

export const types_analysis_synonym_token_filter_base = types_analysis_token_filter_base.and(z.object({
    expand: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Expands definitions for equivalent synonym rules. Defaults to `true`.'
    })),
    format: z.optional(types_analysis_synonym_format),
    lenient: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true` ignores errors while parsing the synonym rules. It is important to note that only those synonym rules which cannot get parsed are ignored. Defaults to the value of the `updateable` setting.'
    })),
    synonyms: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Used to define inline synonyms.'
    })),
    synonyms_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Used to provide a synonym file. This path must be absolute or relative to the `config` location.'
    })),
    synonyms_set: z.optional(z.string().register(z.globalRegistry, {
        description: 'Provide a synonym set created via Synonyms Management APIs.'
    })),
    tokenizer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Controls the tokenizers that will be used to tokenize the synonym, this parameter is for backwards compatibility for indices that created before 6.0.'
    })),
    updateable: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true` allows reloading search analyzers to pick up changes to synonym files. Only to be used for search analyzers. Defaults to `false`.'
    }))
}));

export const types_analysis_synonym_token_filter = types_analysis_synonym_token_filter_base.and(z.object({
    type: z.enum(['synonym'])
}));

export const types_analysis_synonym_graph_token_filter = types_analysis_synonym_token_filter_base.and(z.object({
    type: z.enum(['synonym_graph'])
}));

export const types_analysis_stop_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['stop']),
    ignore_case: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, stop word matching is case insensitive. For example, if `true`, a stop word of the matches and removes `The`, `THE`, or `the`. Defaults to `false`.'
    })),
    remove_trailing: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the last token of a stream is removed if it’s a stop word. Defaults to `true`.'
    })),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path to a file that contains a list of stop words to remove.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each stop word in the file must be separated by a line break.'
    }))
}));

export const types_analysis_stemmer_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['stemmer']),
    language: z.optional(z.string())
}));

export const types_analysis_stemmer_override_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['stemmer_override']),
    rules: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'A list of mapping rules to use.'
    })),
    rules_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'A path (either relative to `config` location, or absolute) to a list of mappings.'
    }))
}));

export const types_analysis_sorani_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['sorani_normalization'])
}));

export const types_analysis_snowball_language = z.enum([
    'Arabic',
    'Armenian',
    'Basque',
    'Catalan',
    'Danish',
    'Dutch',
    'English',
    'Estonian',
    'Finnish',
    'French',
    'German',
    'German2',
    'Hungarian',
    'Italian',
    'Irish',
    'Kp',
    'Lithuanian',
    'Lovins',
    'Norwegian',
    'Porter',
    'Portuguese',
    'Romanian',
    'Russian',
    'Serbian',
    'Spanish',
    'Swedish',
    'Turkish'
]);

export const types_analysis_snowball_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['snowball']),
    language: z.optional(types_analysis_snowball_language)
}));

export const types_analysis_shingle_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['shingle']),
    filler_token: z.optional(z.string().register(z.globalRegistry, {
        description: 'String used in shingles as a replacement for empty positions that do not contain a token. This filler token is only used in shingles, not original unigrams. Defaults to an underscore (`_`).'
    })),
    max_shingle_size: z.optional(spec_utils_stringifiedinteger),
    min_shingle_size: z.optional(spec_utils_stringifiedinteger),
    output_unigrams: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the output includes the original input tokens. If `false`, the output only includes shingles; the original input tokens are removed. Defaults to `true`.'
    })),
    output_unigrams_if_no_shingles: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the output includes the original input tokens only if no shingles are produced; if shingles are produced, the output only includes shingles. Defaults to `false`.'
    })),
    token_separator: z.optional(z.string().register(z.globalRegistry, {
        description: 'Separator used to concatenate adjacent tokens to form a shingle. Defaults to a space (`" "`).'
    }))
}));

export const types_analysis_serbian_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['serbian_normalization'])
}));

export const types_analysis_scandinavian_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['scandinavian_normalization'])
}));

export const types_analysis_scandinavian_folding_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['scandinavian_folding'])
}));

export const types_analysis_russian_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['russian_stem'])
}));

export const types_analysis_reverse_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['reverse'])
}));

export const types_analysis_remove_duplicates_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['remove_duplicates'])
}));

export const types_analysis_porter_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['porter_stem'])
}));

export const types_analysis_persian_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['persian_stem'])
}));

export const types_analysis_persian_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['persian_normalization'])
}));

export const types_analysis_pattern_replace_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['pattern_replace']),
    all: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, all substrings matching the pattern parameter’s regular expression are replaced. If `false`, the filter replaces only the first matching substring in each token. Defaults to `true`.'
    })),
    flags: z.optional(z.string()),
    pattern: z.string().register(z.globalRegistry, {
        description: 'Regular expression, written in Java’s regular expression syntax. The filter replaces token substrings matching this pattern with the substring in the `replacement` parameter.'
    }),
    replacement: z.optional(z.string().register(z.globalRegistry, {
        description: 'Replacement substring. Defaults to an empty substring (`""`).'
    }))
}));

export const types_analysis_pattern_capture_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['pattern_capture']),
    patterns: z.array(z.string()).register(z.globalRegistry, {
        description: 'A list of regular expressions to match.'
    }),
    preserve_original: z.optional(spec_utils_stringifiedboolean)
}));

export const types_analysis_nori_part_of_speech_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['nori_part_of_speech']),
    stoptags: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'An array of part-of-speech tags that should be removed.'
    }))
}));

export const types_analysis_n_gram_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['ngram']),
    max_gram: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum length of characters in a gram. Defaults to `2`.'
    })),
    min_gram: z.optional(z.number().register(z.globalRegistry, {
        description: 'Minimum length of characters in a gram. Defaults to `1`.'
    })),
    preserve_original: z.optional(spec_utils_stringifiedboolean)
}));

export const types_analysis_multiplexer_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['multiplexer']),
    filters: z.array(z.string()).register(z.globalRegistry, {
        description: 'A list of token filters to apply to incoming tokens.'
    }),
    preserve_original: z.optional(spec_utils_stringifiedboolean)
}));

export const types_analysis_min_hash_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['min_hash']),
    bucket_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of buckets to which hashes are assigned. Defaults to `512`.'
    })),
    hash_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of ways to hash each token in the stream. Defaults to `1`.'
    })),
    hash_set_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of hashes to keep from each bucket. Defaults to `1`.\nHashes are retained by ascending size, starting with the bucket’s smallest hash first.'
    })),
    with_rotation: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter fills empty buckets with the value of the first non-empty bucket to its circular right if the `hash_set_size` is `1`. If the `bucket_count` argument is greater than 1, this parameter defaults to `true`. Otherwise, this parameter defaults to `false`.'
    }))
}));

export const types_analysis_lowercase_token_filter_languages = z.enum([
    'greek',
    'irish',
    'turkish'
]);

export const types_analysis_lowercase_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['lowercase']),
    language: z.optional(types_analysis_lowercase_token_filter_languages)
}));

export const types_analysis_limit_token_count_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['limit']),
    consume_all_tokens: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the limit filter exhausts the token stream, even if the `max_token_count` has already been reached. Defaults to `false`.'
    })),
    max_token_count: z.optional(spec_utils_stringifiedinteger)
}));

export const types_analysis_length_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['length']),
    max: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum character length of a token. Longer tokens are excluded from the output. Defaults to `Integer.MAX_VALUE`, which is `2^31-1` or `2147483647`.'
    })),
    min: z.optional(z.number().register(z.globalRegistry, {
        description: 'Minimum character length of a token. Shorter tokens are excluded from the output. Defaults to `0`.'
    }))
}));

export const types_analysis_k_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['kstem'])
}));

export const types_analysis_keyword_repeat_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['keyword_repeat'])
}));

export const types_analysis_keyword_marker_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['keyword_marker']),
    ignore_case: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, matching for the `keywords` and `keywords_path` parameters ignores letter case. Defaults to `false`.'
    })),
    keywords: z.optional(z.union([
        z.string(),
        z.array(z.string())
    ])),
    keywords_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path to a file that contains a list of keywords. Tokens that match these keywords are not stemmed.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each word in the file must be separated by a line break.\nThis parameter, `keywords`, or `keywords_pattern` must be specified. You cannot specify this parameter and `keywords_pattern`.'
    })),
    keywords_pattern: z.optional(z.string().register(z.globalRegistry, {
        description: 'Java regular expression used to match tokens. Tokens that match this expression are marked as keywords and not stemmed.\nThis parameter, `keywords`, or `keywords_path` must be specified. You cannot specify this parameter and `keywords` or `keywords_pattern`.'
    }))
}));

export const types_analysis_keep_words_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['keep']),
    keep_words: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'List of words to keep. Only tokens that match words in this list are included in the output.\nEither this parameter or `keep_words_path` must be specified.'
    })),
    keep_words_case: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, lowercase all keep words. Defaults to `false`.'
    })),
    keep_words_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path to a file that contains a list of words to keep. Only tokens that match words in this list are included in the output.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each word in the file must be separated by a line break.\nEither this parameter or `keep_words` must be specified.'
    }))
}));

export const types_analysis_keep_types_mode = z.enum(['include', 'exclude']);

export const types_analysis_keep_types_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['keep_types']),
    mode: z.optional(types_analysis_keep_types_mode),
    types: z.array(z.string()).register(z.globalRegistry, {
        description: 'List of token types to keep or remove.'
    })
}));

export const types_analysis_indic_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['indic_normalization'])
}));

export const types_analysis_hyphenation_decompounder_token_filter = types_analysis_compound_word_token_filter_base.and(z.object({
    type: z.enum(['hyphenation_decompounder']),
    hyphenation_patterns_path: z.string().register(z.globalRegistry, {
        description: 'Path to an Apache FOP (Formatting Objects Processor) XML hyphenation pattern file.\nThis path must be absolute or relative to the `config` location. Only FOP v1.2 compatible files are supported.'
    }),
    no_sub_matches: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, do not match sub tokens in tokens that are in the word list. Defaults to `false`.'
    })),
    no_overlapping_matches: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, do not allow overlapping tokens. Defaults to `false`.'
    }))
}));

export const types_analysis_hunspell_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['hunspell']),
    dedup: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, duplicate tokens are removed from the filter’s output. Defaults to `true`.'
    })),
    dictionary: z.optional(z.string().register(z.globalRegistry, {
        description: 'One or more `.dic` files (e.g, `en_US.dic`, my_custom.dic) to use for the Hunspell dictionary.\nBy default, the `hunspell` filter uses all `.dic` files in the `<$ES_PATH_CONF>/hunspell/<locale>` directory specified using the `lang`, `language`, or `locale` parameter.'
    })),
    locale: z.string().register(z.globalRegistry, {
        description: 'Locale directory used to specify the `.aff` and `.dic` files for a Hunspell dictionary.'
    }),
    longest_only: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, only the longest stemmed version of each token is included in the output. If `false`, all stemmed versions of the token are included. Defaults to `false`.'
    }))
}));

export const types_analysis_hindi_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['hindi_normalization'])
}));

export const types_analysis_german_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['german_stem'])
}));

export const types_analysis_german_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['german_normalization'])
}));

export const types_analysis_french_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['french_stem'])
}));

export const types_analysis_flatten_graph_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['flatten_graph'])
}));

export const types_analysis_fingerprint_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['fingerprint']),
    max_output_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum character length, including whitespace, of the output token. Defaults to `255`. Concatenated tokens longer than this will result in no token output.'
    })),
    separator: z.optional(z.string().register(z.globalRegistry, {
        description: 'Character to use to concatenate the token stream input. Defaults to a space.'
    }))
}));

export const types_analysis_elision_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['elision']),
    articles: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'List of elisions to remove.\nTo be removed, the elision must be at the beginning of a token and be immediately followed by an apostrophe. Both the elision and apostrophe are removed.\nFor custom `elision` filters, either this parameter or `articles_path` must be specified.'
    })),
    articles_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path to a file that contains a list of elisions to remove.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each elision in the file must be separated by a line break.\nTo be removed, the elision must be at the beginning of a token and be immediately followed by an apostrophe. Both the elision and apostrophe are removed.\nFor custom `elision` filters, either this parameter or `articles` must be specified.'
    })),
    articles_case: z.optional(spec_utils_stringifiedboolean)
}));

export const types_analysis_edge_n_gram_side = z.enum(['front', 'back']);

export const types_analysis_edge_n_gram_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['edge_ngram']),
    max_gram: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum character length of a gram. For custom token filters, defaults to `2`. For the built-in edge_ngram filter, defaults to `1`.'
    })),
    min_gram: z.optional(z.number().register(z.globalRegistry, {
        description: 'Minimum character length of a gram. Defaults to `1`.'
    })),
    side: z.optional(types_analysis_edge_n_gram_side),
    preserve_original: z.optional(spec_utils_stringifiedboolean)
}));

export const types_analysis_dutch_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['dutch_stem'])
}));

export const types_analysis_delimited_payload_encoding = z.enum([
    'int',
    'float',
    'identity'
]);

export const types_analysis_delimited_payload_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['delimited_payload']),
    delimiter: z.optional(z.string().register(z.globalRegistry, {
        description: 'Character used to separate tokens from payloads. Defaults to `|`.'
    })),
    encoding: z.optional(types_analysis_delimited_payload_encoding)
}));

export const types_analysis_decimal_digit_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['decimal_digit'])
}));

export const types_analysis_czech_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['czech_stem'])
}));

export const types_analysis_common_grams_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['common_grams']),
    common_words: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'A list of tokens. The filter generates bigrams for these tokens.\nEither this or the `common_words_path` parameter is required.'
    })),
    common_words_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path to a file containing a list of tokens. The filter generates bigrams for these tokens.\nThis path must be absolute or relative to the `config` location. The file must be UTF-8 encoded. Each token in the file must be separated by a line break.\nEither this or the `common_words` parameter is required.'
    })),
    ignore_case: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, matches for common words matching are case-insensitive. Defaults to `false`.'
    })),
    query_mode: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the filter excludes the following tokens from the output:\n- Unigrams for common words\n- Unigrams for terms followed by common words\nDefaults to `false`. We recommend enabling this parameter for search analyzers.'
    }))
}));

export const types_analysis_classic_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['classic'])
}));

export const types_analysis_cjk_width_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['cjk_width'])
}));

export const types_analysis_cjk_bigram_ignored_script = z.enum([
    'han',
    'hangul',
    'hiragana',
    'katakana'
]);

export const types_analysis_cjk_bigram_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['cjk_bigram']),
    ignored_scripts: z.optional(z.array(types_analysis_cjk_bigram_ignored_script).register(z.globalRegistry, {
        description: 'Array of character scripts for which to disable bigrams.'
    })),
    output_unigrams: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, emit tokens in both bigram and unigram form. If `false`, a CJK character is output in unigram form when it has no adjacent characters. Defaults to `false`.'
    }))
}));

export const types_analysis_brazilian_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['brazilian_stem'])
}));

export const types_analysis_bengali_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['bengali_normalization'])
}));

export const types_analysis_ascii_folding_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['asciifolding']),
    preserve_original: z.optional(spec_utils_stringifiedboolean)
}));

export const types_analysis_arabic_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['arabic_normalization'])
}));

export const types_analysis_arabic_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['arabic_stem'])
}));

export const types_analysis_apostrophe_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['apostrophe'])
}));

export const types_analysis_char_filter_base = z.object({
    version: z.optional(types_version_string)
});

export const types_analysis_kuromoji_iteration_mark_char_filter = types_analysis_char_filter_base.and(z.object({
    type: z.enum(['kuromoji_iteration_mark']),
    normalize_kana: z.boolean(),
    normalize_kanji: z.boolean()
}));

export const types_analysis_icu_normalization_mode = z.enum(['decompose', 'compose']);

export const types_analysis_icu_normalization_char_filter = types_analysis_char_filter_base.and(z.object({
    type: z.enum(['icu_normalizer']),
    mode: z.optional(types_analysis_icu_normalization_mode),
    name: z.optional(types_analysis_icu_normalization_type),
    unicode_set_filter: z.optional(z.string())
}));

export const types_analysis_pattern_replace_char_filter = types_analysis_char_filter_base.and(z.object({
    type: z.enum(['pattern_replace']),
    flags: z.optional(z.string()),
    pattern: z.string(),
    replacement: z.optional(z.string())
}));

export const types_analysis_mapping_char_filter = types_analysis_char_filter_base.and(z.object({
    type: z.enum(['mapping']),
    mappings: z.optional(z.array(z.string())),
    mappings_path: z.optional(z.string())
}));

export const types_analysis_html_strip_char_filter = types_analysis_char_filter_base.and(z.object({
    type: z.enum(['html_strip']),
    escaped_tags: z.optional(z.array(z.string()))
}));

export const types_analysis_char_filter_definition = z.union([
    z.object({
        type: z.literal('html_strip')
    }).and(types_analysis_html_strip_char_filter),
    z.object({
        type: z.literal('mapping')
    }).and(types_analysis_mapping_char_filter),
    z.object({
        type: z.literal('pattern_replace')
    }).and(types_analysis_pattern_replace_char_filter),
    z.object({
        type: z.literal('icu_normalizer')
    }).and(types_analysis_icu_normalization_char_filter),
    z.object({
        type: z.literal('kuromoji_iteration_mark')
    }).and(types_analysis_kuromoji_iteration_mark_char_filter)
]);

export const types_analysis_char_filter = z.union([
    z.string(),
    types_analysis_char_filter_definition
]);

export const types_analysis_thai_analyzer = z.object({
    type: z.enum(['thai']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string())
});

export const types_analysis_turkish_analyzer = z.object({
    type: z.enum(['turkish']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_swedish_analyzer = z.object({
    type: z.enum(['swedish']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_spanish_analyzer = z.object({
    type: z.enum(['spanish']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_sorani_analyzer = z.object({
    type: z.enum(['sorani']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_serbian_analyzer = z.object({
    type: z.enum(['serbian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_russian_analyzer = z.object({
    type: z.enum(['russian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_romanian_analyzer = z.object({
    type: z.enum(['romanian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_portuguese_analyzer = z.object({
    type: z.enum(['portuguese']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_persian_analyzer = z.object({
    type: z.enum(['persian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string())
});

export const types_analysis_norwegian_analyzer = z.object({
    type: z.enum(['norwegian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_lithuanian_analyzer = z.object({
    type: z.enum(['lithuanian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_latvian_analyzer = z.object({
    type: z.enum(['latvian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_italian_analyzer = z.object({
    type: z.enum(['italian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_irish_analyzer = z.object({
    type: z.enum(['irish']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_indonesian_analyzer = z.object({
    type: z.enum(['indonesian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_hungarian_analyzer = z.object({
    type: z.enum(['hungarian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_hindi_analyzer = z.object({
    type: z.enum(['hindi']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_greek_analyzer = z.object({
    type: z.enum(['greek']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string())
});

export const types_analysis_german_analyzer = z.object({
    type: z.enum(['german']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_galician_analyzer = z.object({
    type: z.enum(['galician']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_french_analyzer = z.object({
    type: z.enum(['french']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_finnish_analyzer = z.object({
    type: z.enum(['finnish']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_estonian_analyzer = z.object({
    type: z.enum(['estonian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string())
});

export const types_analysis_english_analyzer = z.object({
    type: z.enum(['english']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_dutch_analyzer = z.object({
    type: z.enum(['dutch']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_danish_analyzer = z.object({
    type: z.enum(['danish']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string())
});

export const types_analysis_czech_analyzer = z.object({
    type: z.enum(['czech']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_cjk_analyzer = z.object({
    type: z.enum(['cjk']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string())
});

export const types_analysis_chinese_analyzer = z.object({
    type: z.enum(['chinese']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string())
});

export const types_analysis_catalan_analyzer = z.object({
    type: z.enum(['catalan']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_bulgarian_analyzer = z.object({
    type: z.enum(['bulgarian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_brazilian_analyzer = z.object({
    type: z.enum(['brazilian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string())
});

export const types_analysis_bengali_analyzer = z.object({
    type: z.enum(['bengali']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_basque_analyzer = z.object({
    type: z.enum(['basque']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_armenian_analyzer = z.object({
    type: z.enum(['armenian']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_arabic_analyzer = z.object({
    type: z.enum(['arabic']),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string()),
    stem_exclusion: z.optional(z.array(z.string()))
});

export const types_analysis_snowball_analyzer = z.object({
    type: z.enum(['snowball']),
    version: z.optional(types_version_string),
    language: types_analysis_snowball_language,
    stopwords: z.optional(types_analysis_stop_words)
});

export const types_analysis_kuromoji_analyzer = z.object({
    type: z.enum(['kuromoji']),
    mode: z.optional(types_analysis_kuromoji_tokenization_mode),
    user_dictionary: z.optional(z.string())
});

export const types_analysis_icu_analyzer = z.object({
    type: z.enum(['icu_analyzer']),
    method: types_analysis_icu_normalization_type,
    mode: types_analysis_icu_normalization_mode
});

export const types_analysis_whitespace_analyzer = z.object({
    type: z.enum(['whitespace']),
    version: z.optional(types_version_string)
});

export const types_analysis_stop_analyzer = z.object({
    type: z.enum(['stop']),
    version: z.optional(types_version_string),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'The path to a file containing stop words.'
    }))
});

export const types_analysis_standard_analyzer = z.object({
    type: z.enum(['standard']),
    max_token_length: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum token length. If a token is seen that exceeds this length then it is split at `max_token_length` intervals.\nDefaults to `255`.'
    })),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'The path to a file containing stop words.'
    }))
});

export const types_analysis_simple_analyzer = z.object({
    type: z.enum(['simple']),
    version: z.optional(types_version_string)
});

export const types_analysis_pattern_analyzer = z.object({
    type: z.enum(['pattern']),
    version: z.optional(types_version_string),
    flags: z.optional(z.string().register(z.globalRegistry, {
        description: 'Java regular expression flags. Flags should be pipe-separated, eg "CASE_INSENSITIVE|COMMENTS".'
    })),
    lowercase: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Should terms be lowercased or not.\nDefaults to `true`.'
    })),
    pattern: z.optional(z.string().register(z.globalRegistry, {
        description: 'A Java regular expression.\nDefaults to `\\W+`.'
    })),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'The path to a file containing stop words.'
    }))
});

export const types_analysis_nori_analyzer = z.object({
    type: z.enum(['nori']),
    version: z.optional(types_version_string),
    decompound_mode: z.optional(types_analysis_nori_decompound_mode),
    stoptags: z.optional(z.array(z.string())),
    user_dictionary: z.optional(z.string())
});

export const types_analysis_keyword_analyzer = z.object({
    type: z.enum(['keyword']),
    version: z.optional(types_version_string)
});

export const types_analysis_fingerprint_analyzer = z.object({
    type: z.enum(['fingerprint']),
    version: z.optional(types_version_string),
    max_output_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum token size to emit. Tokens larger than this size will be discarded.\nDefaults to `255`'
    })),
    separator: z.optional(z.string().register(z.globalRegistry, {
        description: 'The character to use to concatenate the terms.\nDefaults to a space.'
    })),
    stopwords: z.optional(types_analysis_stop_words),
    stopwords_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'The path to a file containing stop words.'
    }))
});

export const types_analysis_custom_analyzer = z.object({
    type: z.enum(['custom']),
    char_filter: z.optional(z.union([
        z.string(),
        z.array(z.string())
    ])),
    filter: z.optional(z.union([
        z.string(),
        z.array(z.string())
    ])),
    position_increment_gap: z.optional(z.number()),
    position_offset_gap: z.optional(z.number()),
    tokenizer: z.string()
});

export const types_analysis_analyzer = z.union([
    z.object({
        type: z.literal('custom')
    }).and(types_analysis_custom_analyzer),
    z.object({
        type: z.literal('fingerprint')
    }).and(types_analysis_fingerprint_analyzer),
    z.object({
        type: z.literal('keyword')
    }).and(types_analysis_keyword_analyzer),
    z.object({
        type: z.literal('nori')
    }).and(types_analysis_nori_analyzer),
    z.object({
        type: z.literal('pattern')
    }).and(types_analysis_pattern_analyzer),
    z.object({
        type: z.literal('simple')
    }).and(types_analysis_simple_analyzer),
    z.object({
        type: z.literal('standard')
    }).and(types_analysis_standard_analyzer),
    z.object({
        type: z.literal('stop')
    }).and(types_analysis_stop_analyzer),
    z.object({
        type: z.literal('whitespace')
    }).and(types_analysis_whitespace_analyzer),
    z.object({
        type: z.literal('icu_analyzer')
    }).and(types_analysis_icu_analyzer),
    z.object({
        type: z.literal('kuromoji')
    }).and(types_analysis_kuromoji_analyzer),
    z.object({
        type: z.literal('snowball')
    }).and(types_analysis_snowball_analyzer),
    z.object({
        type: z.literal('arabic')
    }).and(types_analysis_arabic_analyzer),
    z.object({
        type: z.literal('armenian')
    }).and(types_analysis_armenian_analyzer),
    z.object({
        type: z.literal('basque')
    }).and(types_analysis_basque_analyzer),
    z.object({
        type: z.literal('bengali')
    }).and(types_analysis_bengali_analyzer),
    z.object({
        type: z.literal('brazilian')
    }).and(types_analysis_brazilian_analyzer),
    z.object({
        type: z.literal('bulgarian')
    }).and(types_analysis_bulgarian_analyzer),
    z.object({
        type: z.literal('catalan')
    }).and(types_analysis_catalan_analyzer),
    z.object({
        type: z.literal('chinese')
    }).and(types_analysis_chinese_analyzer),
    z.object({
        type: z.literal('cjk')
    }).and(types_analysis_cjk_analyzer),
    z.object({
        type: z.literal('czech')
    }).and(types_analysis_czech_analyzer),
    z.object({
        type: z.literal('danish')
    }).and(types_analysis_danish_analyzer),
    z.object({
        type: z.literal('dutch')
    }).and(types_analysis_dutch_analyzer),
    z.object({
        type: z.literal('english')
    }).and(types_analysis_english_analyzer),
    z.object({
        type: z.literal('estonian')
    }).and(types_analysis_estonian_analyzer),
    z.object({
        type: z.literal('finnish')
    }).and(types_analysis_finnish_analyzer),
    z.object({
        type: z.literal('french')
    }).and(types_analysis_french_analyzer),
    z.object({
        type: z.literal('galician')
    }).and(types_analysis_galician_analyzer),
    z.object({
        type: z.literal('german')
    }).and(types_analysis_german_analyzer),
    z.object({
        type: z.literal('greek')
    }).and(types_analysis_greek_analyzer),
    z.object({
        type: z.literal('hindi')
    }).and(types_analysis_hindi_analyzer),
    z.object({
        type: z.literal('hungarian')
    }).and(types_analysis_hungarian_analyzer),
    z.object({
        type: z.literal('indonesian')
    }).and(types_analysis_indonesian_analyzer),
    z.object({
        type: z.literal('irish')
    }).and(types_analysis_irish_analyzer),
    z.object({
        type: z.literal('italian')
    }).and(types_analysis_italian_analyzer),
    z.object({
        type: z.literal('latvian')
    }).and(types_analysis_latvian_analyzer),
    z.object({
        type: z.literal('lithuanian')
    }).and(types_analysis_lithuanian_analyzer),
    z.object({
        type: z.literal('norwegian')
    }).and(types_analysis_norwegian_analyzer),
    z.object({
        type: z.literal('persian')
    }).and(types_analysis_persian_analyzer),
    z.object({
        type: z.literal('portuguese')
    }).and(types_analysis_portuguese_analyzer),
    z.object({
        type: z.literal('romanian')
    }).and(types_analysis_romanian_analyzer),
    z.object({
        type: z.literal('russian')
    }).and(types_analysis_russian_analyzer),
    z.object({
        type: z.literal('serbian')
    }).and(types_analysis_serbian_analyzer),
    z.object({
        type: z.literal('sorani')
    }).and(types_analysis_sorani_analyzer),
    z.object({
        type: z.literal('spanish')
    }).and(types_analysis_spanish_analyzer),
    z.object({
        type: z.literal('swedish')
    }).and(types_analysis_swedish_analyzer),
    z.object({
        type: z.literal('turkish')
    }).and(types_analysis_turkish_analyzer),
    z.object({
        type: z.literal('thai')
    }).and(types_analysis_thai_analyzer)
]);

export const indices_types_settings_query_string = z.object({
    lenient: spec_utils_stringifiedboolean
});

export const indices_types_translog_retention = z.object({
    size: z.optional(types_byte_size),
    age: z.optional(types_duration)
});

export const indices_types_translog_durability = z.enum([
    'request',
    'REQUEST',
    'async',
    'ASYNC'
]);

export const indices_types_translog = z.object({
    sync_interval: z.optional(types_duration),
    durability: z.optional(indices_types_translog_durability),
    flush_threshold_size: z.optional(types_byte_size),
    retention: z.optional(indices_types_translog_retention)
});

export const indices_types_index_versioning = z.object({
    created: z.optional(types_version_string),
    created_string: z.optional(z.string())
});

/**
 * Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
 * is used to capture this behavior while keeping the semantics of the field type.
 *
 * Depending on the target language, code generators can keep the union or remove it and leniently parse
 * strings to the target type.
 */
export const spec_utils_stringified_epoch_time_unit_millis = z.union([
    types_epoch_time_unit_millis,
    z.string()
]);

export const indices_types_index_settings_lifecycle_step = z.object({
    wait_time_threshold: z.optional(types_duration)
});

export const indices_types_index_settings_lifecycle = z.object({
    name: z.optional(types_name),
    indexing_complete: z.optional(spec_utils_stringifiedboolean),
    origination_date: z.optional(z.number().register(z.globalRegistry, {
        description: 'If specified, this is the timestamp used to calculate the index age for its phase transitions. Use this setting\nif you create a new index that contains old data and want to use the original creation date to calculate the index\nage. Specified as a Unix epoch value in milliseconds.'
    })),
    parse_origination_date: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to true to parse the origination date from the index name. This origination date is used to calculate the index age\nfor its phase transitions. The index name must match the pattern ^.*-{date_format}-\\\\d+, where the date_format is\nyyyy.MM.dd and the trailing digits are optional. An index that was rolled over would normally match the full format,\nfor example logs-2016.10.31-000002). If the index name doesn’t match the pattern, index creation fails.'
    })),
    step: z.optional(indices_types_index_settings_lifecycle_step),
    rollover_alias: z.optional(z.string().register(z.globalRegistry, {
        description: 'The index alias to update when the index rolls over. Specify when using a policy that contains a rollover action.\nWhen the index rolls over, the alias is updated to reflect that the index is no longer the write index. For more\ninformation about rolling indices, see Rollover.'
    })),
    prefer_ilm: z.optional(z.union([
        z.boolean(),
        z.string()
    ]))
});

export const types_pipeline_name = z.string();

export const indices_types_index_routing_rebalance_options = z.enum([
    'all',
    'primaries',
    'replicas',
    'none'
]);

export const indices_types_index_routing_rebalance = z.object({
    enable: indices_types_index_routing_rebalance_options
});

export const indices_types_index_routing_allocation_disk = z.object({
    threshold_enabled: z.optional(z.union([
        z.boolean(),
        z.string()
    ]))
});

export const indices_types_index_routing_allocation_initial_recovery = z.object({
    _id: z.optional(types_id)
});

export const indices_types_index_routing_allocation_include = z.object({
    _tier_preference: z.optional(z.string()),
    _id: z.optional(types_id)
});

export const indices_types_index_routing_allocation_options = z.enum([
    'all',
    'primaries',
    'new_primaries',
    'none'
]);

export const indices_types_index_routing_allocation = z.object({
    enable: z.optional(indices_types_index_routing_allocation_options),
    include: z.optional(indices_types_index_routing_allocation_include),
    initial_recovery: z.optional(indices_types_index_routing_allocation_initial_recovery),
    disk: z.optional(indices_types_index_routing_allocation_disk)
});

export const indices_types_index_routing = z.object({
    allocation: z.optional(indices_types_index_routing_allocation),
    rebalance: z.optional(indices_types_index_routing_rebalance)
});

export const indices_types_settings_highlight = z.object({
    max_analyzed_offset: z.optional(z.number())
});

export const indices_types_settings_analyze = z.object({
    max_token_count: z.optional(spec_utils_stringifiedinteger)
});

export const indices_types_index_setting_blocks = z.object({
    read_only: z.optional(spec_utils_stringifiedboolean),
    read_only_allow_delete: z.optional(spec_utils_stringifiedboolean),
    read: z.optional(spec_utils_stringifiedboolean),
    write: z.optional(spec_utils_stringifiedboolean),
    metadata: z.optional(spec_utils_stringifiedboolean)
});

export const indices_types_slowlog_tresholds = z.object({
    query: z.optional(indices_types_slowlog_treshold_levels),
    fetch: z.optional(indices_types_slowlog_treshold_levels)
});

export const indices_types_slowlog_settings = z.object({
    level: z.optional(z.string()),
    source: z.optional(z.number()),
    reformat: z.optional(z.boolean()),
    threshold: z.optional(indices_types_slowlog_tresholds)
});

export const indices_types_search_idle = z.object({
    after: z.optional(types_duration)
});

export const indices_types_settings_search = z.object({
    idle: z.optional(indices_types_search_idle),
    slowlog: z.optional(indices_types_slowlog_settings)
});

export const indices_types_merge_scheduler = z.object({
    max_thread_count: z.optional(spec_utils_stringifiedinteger),
    max_merge_count: z.optional(spec_utils_stringifiedinteger)
});

export const indices_types_merge = z.object({
    scheduler: z.optional(indices_types_merge_scheduler)
});

/**
 * A `null` value that is to be interpreted as an actual value, unless other uses of `null` that are equivalent
 * to a missing value. It is used for exemple in settings, where using the `NullValue` for a setting will reset
 * it to its default value.
 */
export const spec_utils_null_value = z.union([
    z.string(),
    z.null()
]);

export const indices_types_index_check_on_startup = z.enum([
    'true',
    'false',
    'checksum'
]);

export const indices_types_segment_sort_missing = z.enum(['_last', '_first']);

export const indices_types_segment_sort_mode = z.enum([
    'min',
    'MIN',
    'max',
    'MAX'
]);

export const indices_types_segment_sort_order = z.enum([
    'asc',
    'ASC',
    'desc',
    'DESC'
]);

export const indices_types_index_segment_sort = z.object({
    field: z.optional(types_fields),
    order: z.optional(z.union([
        indices_types_segment_sort_order,
        z.array(indices_types_segment_sort_order)
    ])),
    mode: z.optional(z.union([
        indices_types_segment_sort_mode,
        z.array(indices_types_segment_sort_mode)
    ])),
    missing: z.optional(z.union([
        indices_types_segment_sort_missing,
        z.array(indices_types_segment_sort_missing)
    ]))
});

export const indices_types_retention_lease = z.object({
    period: types_duration
});

export const indices_types_soft_deletes = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether soft deletes are enabled on the index.'
    })),
    retention_lease: z.optional(indices_types_retention_lease)
});

export const types_acknowledged_response_base = z.object({
    acknowledged: z.boolean().register(z.globalRegistry, {
        description: 'For a successful response, this value is always true. On failure, an exception is returned instead.'
    })
});

export const global_search_types_term_suggest_option = z.object({
    text: z.string(),
    score: z.number(),
    freq: z.number(),
    highlighted: z.optional(z.string()),
    collate_match: z.optional(z.boolean())
});

export const global_search_types_suggest_base = z.object({
    length: z.number(),
    offset: z.number(),
    text: z.string()
});

export const global_search_types_term_suggest = global_search_types_suggest_base.and(z.object({
    options: z.union([
        global_search_types_term_suggest_option,
        z.array(global_search_types_term_suggest_option)
    ])
}));

export const global_search_types_phrase_suggest_option = z.object({
    text: z.string(),
    score: z.number(),
    highlighted: z.optional(z.string()),
    collate_match: z.optional(z.boolean())
});

export const global_search_types_phrase_suggest = global_search_types_suggest_base.and(z.object({
    options: z.union([
        global_search_types_phrase_suggest_option,
        z.array(global_search_types_phrase_suggest_option)
    ])
}));

/**
 * Text or location that we want similar documents for or a lookup to a document's field for the text.
 */
export const global_search_types_context = z.union([
    z.string(),
    types_geo_location
]);

export const global_search_types_completion_suggest_option = z.object({
    collate_match: z.optional(z.boolean()),
    contexts: z.optional(z.record(z.string(), z.array(global_search_types_context))),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    _id: z.optional(z.string()),
    _index: z.optional(types_index_name),
    _routing: z.optional(types_routing),
    _score: z.optional(z.number()),
    _source: z.optional(z.record(z.string(), z.unknown())),
    text: z.string(),
    score: z.optional(z.number())
});

export const global_search_types_completion_suggest = global_search_types_suggest_base.and(z.object({
    options: z.union([
        global_search_types_completion_suggest_option,
        z.array(global_search_types_completion_suggest_option)
    ])
}));

export const global_search_types_suggest = z.union([
    global_search_types_completion_suggest,
    global_search_types_phrase_suggest,
    global_search_types_term_suggest
]);

export const types_scroll_id = z.string();

export const global_search_types_query_breakdown = z.object({
    advance: z.number(),
    advance_count: z.number(),
    build_scorer: z.number(),
    build_scorer_count: z.number(),
    create_weight: z.number(),
    create_weight_count: z.number(),
    match: z.number(),
    match_count: z.number(),
    shallow_advance: z.number(),
    shallow_advance_count: z.number(),
    next_doc: z.number(),
    next_doc_count: z.number(),
    score: z.number(),
    score_count: z.number(),
    compute_max_score: z.number(),
    compute_max_score_count: z.number(),
    count_weight: z.number(),
    count_weight_count: z.number(),
    set_min_competitive_score: z.number(),
    set_min_competitive_score_count: z.number()
});

export const global_search_types_query_profile = z.object({
    breakdown: global_search_types_query_breakdown,
    description: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    type: z.string(),
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_query_profile)));
    }
});

export const global_search_types_collector = z.object({
    name: z.string(),
    reason: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_collector)));
    }
});

export const global_search_types_search_profile = z.object({
    collector: z.array(global_search_types_collector),
    query: z.array(global_search_types_query_profile),
    rewrite_time: z.number()
});

export const global_search_types_fetch_profile_debug = z.object({
    stored_fields: z.optional(z.array(z.string())),
    fast_path: z.optional(z.number())
});

export const global_search_types_fetch_profile_breakdown = z.object({
    load_source: z.optional(z.number()),
    load_source_count: z.optional(z.number()),
    load_stored_fields: z.optional(z.number()),
    load_stored_fields_count: z.optional(z.number()),
    next_reader: z.optional(z.number()),
    next_reader_count: z.optional(z.number()),
    process_count: z.optional(z.number()),
    process: z.optional(z.number())
});

export const global_search_types_fetch_profile = z.object({
    type: z.string(),
    description: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    breakdown: global_search_types_fetch_profile_breakdown,
    debug: z.optional(global_search_types_fetch_profile_debug),
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_fetch_profile)));
    }
});

export const global_search_types_knn_collector_result = z.object({
    name: z.string(),
    reason: z.string(),
    time: z.optional(types_duration),
    time_in_nanos: types_duration_value_unit_nanos,
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_knn_collector_result)));
    }
});

export const global_search_types_knn_query_profile_breakdown = z.object({
    advance: z.number(),
    advance_count: z.number(),
    build_scorer: z.number(),
    build_scorer_count: z.number(),
    compute_max_score: z.number(),
    compute_max_score_count: z.number(),
    count_weight: z.number(),
    count_weight_count: z.number(),
    create_weight: z.number(),
    create_weight_count: z.number(),
    match: z.number(),
    match_count: z.number(),
    next_doc: z.number(),
    next_doc_count: z.number(),
    score: z.number(),
    score_count: z.number(),
    set_min_competitive_score: z.number(),
    set_min_competitive_score_count: z.number(),
    shallow_advance: z.number(),
    shallow_advance_count: z.number()
});

export const global_search_types_knn_query_profile_result = z.object({
    type: z.string(),
    description: z.string(),
    time: z.optional(types_duration),
    time_in_nanos: types_duration_value_unit_nanos,
    breakdown: global_search_types_knn_query_profile_breakdown,
    debug: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_knn_query_profile_result)));
    }
});

export const global_search_types_dfs_knn_profile = z.object({
    vector_operations_count: z.optional(z.number()),
    query: z.array(global_search_types_knn_query_profile_result),
    rewrite_time: z.number(),
    collector: z.array(global_search_types_knn_collector_result)
});

export const global_search_types_dfs_statistics_breakdown = z.object({
    collection_statistics: z.number(),
    collection_statistics_count: z.number(),
    create_weight: z.number(),
    create_weight_count: z.number(),
    rewrite: z.number(),
    rewrite_count: z.number(),
    term_statistics: z.number(),
    term_statistics_count: z.number()
});

export const global_search_types_dfs_statistics_profile = z.object({
    type: z.string(),
    description: z.string(),
    time: z.optional(types_duration),
    time_in_nanos: types_duration_value_unit_nanos,
    breakdown: global_search_types_dfs_statistics_breakdown,
    debug: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_dfs_statistics_profile)));
    }
});

export const global_search_types_dfs_profile = z.object({
    statistics: z.optional(global_search_types_dfs_statistics_profile),
    knn: z.optional(z.array(global_search_types_dfs_knn_profile))
});

export const global_search_types_aggregation_profile_delegate_debug_filter = z.object({
    results_from_metadata: z.optional(z.number()),
    query: z.optional(z.string()),
    specialized_for: z.optional(z.string()),
    segments_counted_in_constant_time: z.optional(z.number())
});

export const global_search_types_aggregation_profile_debug = z.object({
    segments_with_multi_valued_ords: z.optional(z.number()),
    collection_strategy: z.optional(z.string()),
    segments_with_single_valued_ords: z.optional(z.number()),
    total_buckets: z.optional(z.number()),
    built_buckets: z.optional(z.number()),
    result_strategy: z.optional(z.string()),
    has_filter: z.optional(z.boolean()),
    delegate: z.optional(z.string()),
    get delegate_debug() {
        return z.optional(z.lazy((): any => global_search_types_aggregation_profile_debug));
    },
    chars_fetched: z.optional(z.number()),
    extract_count: z.optional(z.number()),
    extract_ns: z.optional(z.number()),
    values_fetched: z.optional(z.number()),
    collect_analyzed_ns: z.optional(z.number()),
    collect_analyzed_count: z.optional(z.number()),
    surviving_buckets: z.optional(z.number()),
    ordinals_collectors_used: z.optional(z.number()),
    ordinals_collectors_overhead_too_high: z.optional(z.number()),
    string_hashing_collectors_used: z.optional(z.number()),
    numeric_collectors_used: z.optional(z.number()),
    empty_collectors_used: z.optional(z.number()),
    deferred_aggregators: z.optional(z.array(z.string())),
    segments_with_doc_count_field: z.optional(z.number()),
    segments_with_deleted_docs: z.optional(z.number()),
    filters: z.optional(z.array(global_search_types_aggregation_profile_delegate_debug_filter)),
    segments_counted: z.optional(z.number()),
    segments_collected: z.optional(z.number()),
    map_reducer: z.optional(z.string()),
    brute_force_used: z.optional(z.number()),
    dynamic_pruning_attempted: z.optional(z.number()),
    dynamic_pruning_used: z.optional(z.number()),
    skipped_due_to_no_data: z.optional(z.number())
});

export const global_search_types_aggregation_breakdown = z.object({
    build_aggregation: z.number(),
    build_aggregation_count: z.number(),
    build_leaf_collector: z.number(),
    build_leaf_collector_count: z.number(),
    collect: z.number(),
    collect_count: z.number(),
    initialize: z.number(),
    initialize_count: z.number(),
    post_collection: z.optional(z.number()),
    post_collection_count: z.optional(z.number()),
    reduce: z.number(),
    reduce_count: z.number()
});

export const global_search_types_aggregation_profile = z.object({
    breakdown: global_search_types_aggregation_breakdown,
    description: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    type: z.string(),
    debug: z.optional(global_search_types_aggregation_profile_debug),
    get children() {
        return z.optional(z.array(z.lazy((): any => global_search_types_aggregation_profile)));
    }
});

export const global_search_types_shard_profile = z.object({
    aggregations: z.array(global_search_types_aggregation_profile),
    cluster: z.string(),
    dfs: z.optional(global_search_types_dfs_profile),
    fetch: z.optional(global_search_types_fetch_profile),
    id: z.string(),
    index: types_index_name,
    node_id: types_node_id,
    searches: z.array(global_search_types_search_profile),
    shard_id: z.number()
});

export const global_search_types_profile = z.object({
    shards: z.array(global_search_types_shard_profile)
});

export const types_cluster_search_status = z.enum([
    'running',
    'successful',
    'partial',
    'skipped',
    'failed'
]);

export const types_cluster_details = z.object({
    status: types_cluster_search_status,
    indices: z.string(),
    took: z.optional(types_duration_value_unit_millis),
    timed_out: z.boolean(),
    _shards: z.optional(types_shard_statistics),
    failures: z.optional(z.array(types_shard_failure))
});

export const types_cluster_statistics = z.object({
    skipped: z.number(),
    successful: z.number(),
    total: z.number(),
    running: z.number(),
    partial: z.number(),
    failed: z.number(),
    details: z.optional(z.record(z.string(), types_cluster_details))
});

/**
 * A GeoJson GeoLine.
 */
export const types_geo_line = z.object({
    type: z.string().register(z.globalRegistry, {
        description: 'Always `"LineString"`'
    }),
    coordinates: z.array(z.array(z.number())).register(z.globalRegistry, {
        description: 'Array of `[lon, lat]` coordinates'
    })
}).register(z.globalRegistry, {
    description: 'A GeoJson GeoLine.'
});

export const types_aggregations_geo_line_aggregate = types_aggregations_aggregate_base.and(z.object({
    type: z.string(),
    geometry: types_geo_line,
    properties: z.record(z.string(), z.unknown())
}));

export const types_aggregations_matrix_stats_fields = z.object({
    name: types_field,
    count: z.number(),
    mean: z.number(),
    variance: z.number(),
    skewness: z.number(),
    kurtosis: z.number(),
    covariance: z.record(z.string(), z.number()),
    correlation: z.record(z.string(), z.number())
});

export const types_aggregations_matrix_stats_aggregate = types_aggregations_aggregate_base.and(z.object({
    doc_count: z.number(),
    fields: z.optional(z.array(types_aggregations_matrix_stats_fields))
}));

/**
 * Result of the `cumulative_cardinality` aggregation
 */
export const types_aggregations_cumulative_cardinality_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.number(),
    value_as_string: z.optional(z.string())
}));

export const types_aggregations_rate_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.number(),
    value_as_string: z.optional(z.string())
}));

export const types_aggregations_t_test_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    value_as_string: z.optional(z.string())
}));

export const types_aggregations_top_metrics = z.object({
    sort: z.array(z.union([
        types_field_value,
        z.string(),
        z.null()
    ])),
    metrics: z.record(z.string(), z.union([
        types_field_value,
        z.string(),
        z.null()
    ]))
});

export const types_aggregations_top_metrics_aggregate = types_aggregations_aggregate_base.and(z.object({
    top: z.array(types_aggregations_top_metrics)
}));

export const types_aggregations_box_plot_aggregate = types_aggregations_aggregate_base.and(z.object({
    min: z.number(),
    max: z.number(),
    q1: z.number(),
    q2: z.number(),
    q3: z.number(),
    lower: z.number(),
    upper: z.number(),
    min_as_string: z.optional(z.string()),
    max_as_string: z.optional(z.string()),
    q1_as_string: z.optional(z.string()),
    q2_as_string: z.optional(z.string()),
    q3_as_string: z.optional(z.string()),
    lower_as_string: z.optional(z.string()),
    upper_as_string: z.optional(z.string())
}));

export const types_aggregations_string_stats_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    min_length: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    max_length: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    avg_length: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    entropy: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    distribution: z.optional(z.union([
        z.record(z.string(), z.number()),
        z.string(),
        z.null()
    ])),
    min_length_as_string: z.optional(z.string()),
    max_length_as_string: z.optional(z.string()),
    avg_length_as_string: z.optional(z.string())
}));

export const types_aggregations_inference_top_class_entry = z.object({
    class_name: types_field_value,
    class_probability: z.number(),
    class_score: z.number()
});

export const types_aggregations_inference_class_importance = z.object({
    class_name: z.string(),
    importance: z.number()
});

export const types_aggregations_inference_feature_importance = z.object({
    feature_name: z.string(),
    importance: z.optional(z.number()),
    classes: z.optional(z.array(types_aggregations_inference_class_importance))
});

export const types_aggregations_inference_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.optional(types_field_value),
    feature_importance: z.optional(z.array(types_aggregations_inference_feature_importance)),
    top_classes: z.optional(z.array(types_aggregations_inference_top_class_entry)),
    warning: z.optional(z.string())
}));

export const global_search_types_nested_identity = z.object({
    field: types_field,
    offset: z.number(),
    get _nested() {
        return z.optional(z.lazy((): any => global_search_types_nested_identity));
    }
});

export const global_explain_explanation_detail = z.object({
    description: z.string(),
    get details() {
        return z.optional(z.array(z.lazy((): any => global_explain_explanation_detail)));
    },
    value: z.number()
});

export const global_explain_explanation = z.object({
    description: z.string(),
    details: z.array(global_explain_explanation_detail),
    value: z.number()
});

export const global_search_types_total_hits_relation = z.enum(['eq', 'gte']);

export const global_search_types_total_hits = z.object({
    relation: global_search_types_total_hits_relation,
    value: z.number()
});

export const types_aggregations_scripted_metric_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.record(z.string(), z.unknown())
}));

export const types_aggregations_time_series_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.record(z.string(), types_field_value)
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_time_series_bucket = z.union([
    z.record(z.string(), types_aggregations_time_series_bucket),
    z.array(types_aggregations_time_series_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_time_series_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_time_series_bucket
}));

export const types_aggregations_time_series_aggregate = types_aggregations_multi_bucket_aggregate_base_time_series_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_frequent_item_sets_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.record(z.string(), z.array(z.string())),
    support: z.number()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_frequent_item_sets_bucket = z.union([
    z.record(z.string(), types_aggregations_frequent_item_sets_bucket),
    z.array(types_aggregations_frequent_item_sets_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_frequent_item_sets_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_frequent_item_sets_bucket
}));

export const types_aggregations_frequent_item_sets_aggregate = types_aggregations_multi_bucket_aggregate_base_frequent_item_sets_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_significant_terms_aggregate_base_void = types_aggregations_multi_bucket_aggregate_base_void.and(z.object({
    bg_count: z.optional(z.number()),
    doc_count: z.optional(z.number())
}));

/**
 * Result of the `significant_terms` aggregation on an unmapped field. `buckets` is always empty.
 */
export const types_aggregations_unmapped_significant_terms_aggregate = types_aggregations_significant_terms_aggregate_base_void.and(z.record(z.string(), z.unknown()));

export const types_aggregations_significant_terms_bucket_base = types_aggregations_multi_bucket_base.and(z.object({
    score: z.number(),
    bg_count: z.number()
}));

export const types_aggregations_significant_string_terms_bucket = types_aggregations_significant_terms_bucket_base.and(z.object({
    key: z.string()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_significant_string_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_significant_string_terms_bucket),
    z.array(types_aggregations_significant_string_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_significant_string_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_significant_string_terms_bucket
}));

export const types_aggregations_significant_terms_aggregate_base_significant_string_terms_bucket = types_aggregations_multi_bucket_aggregate_base_significant_string_terms_bucket.and(z.object({
    bg_count: z.optional(z.number()),
    doc_count: z.optional(z.number())
}));

export const types_aggregations_significant_string_terms_aggregate = types_aggregations_significant_terms_aggregate_base_significant_string_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_significant_long_terms_bucket = types_aggregations_significant_terms_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_significant_long_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_significant_long_terms_bucket),
    z.array(types_aggregations_significant_long_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_significant_long_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_significant_long_terms_bucket
}));

export const types_aggregations_significant_terms_aggregate_base_significant_long_terms_bucket = types_aggregations_multi_bucket_aggregate_base_significant_long_terms_bucket.and(z.object({
    bg_count: z.optional(z.number()),
    doc_count: z.optional(z.number())
}));

export const types_aggregations_significant_long_terms_aggregate = types_aggregations_significant_terms_aggregate_base_significant_long_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_adjacency_matrix_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.string()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_adjacency_matrix_bucket = z.union([
    z.record(z.string(), types_aggregations_adjacency_matrix_bucket),
    z.array(types_aggregations_adjacency_matrix_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_adjacency_matrix_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_adjacency_matrix_bucket
}));

export const types_aggregations_adjacency_matrix_aggregate = types_aggregations_multi_bucket_aggregate_base_adjacency_matrix_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_ip_prefix_bucket = types_aggregations_multi_bucket_base.and(z.object({
    is_ipv6: z.boolean(),
    key: z.string(),
    prefix_length: z.number(),
    netmask: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_ip_prefix_bucket = z.union([
    z.record(z.string(), types_aggregations_ip_prefix_bucket),
    z.array(types_aggregations_ip_prefix_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_ip_prefix_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_ip_prefix_bucket
}));

export const types_aggregations_ip_prefix_aggregate = types_aggregations_multi_bucket_aggregate_base_ip_prefix_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_ip_range_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.optional(z.string()),
    from: z.optional(z.string()),
    to: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_ip_range_bucket = z.union([
    z.record(z.string(), types_aggregations_ip_range_bucket),
    z.array(types_aggregations_ip_range_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_ip_range_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_ip_range_bucket
}));

export const types_aggregations_ip_range_aggregate = types_aggregations_multi_bucket_aggregate_base_ip_range_bucket.and(z.record(z.string(), z.unknown()));

/**
 * Result of a `geo_distance` aggregation. The unit for `from` and `to` is meters by default.
 */
export const types_aggregations_geo_distance_aggregate = types_aggregations_range_aggregate.and(z.record(z.string(), z.unknown()));

export const types_aggregations_geo_hex_grid_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_geo_hex_cell
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_geo_hex_grid_bucket = z.union([
    z.record(z.string(), types_aggregations_geo_hex_grid_bucket),
    z.array(types_aggregations_geo_hex_grid_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_geo_hex_grid_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_geo_hex_grid_bucket
}));

export const types_aggregations_geo_hex_grid_aggregate = types_aggregations_multi_bucket_aggregate_base_geo_hex_grid_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_geo_tile_grid_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_geo_tile
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_geo_tile_grid_bucket = z.union([
    z.record(z.string(), types_aggregations_geo_tile_grid_bucket),
    z.array(types_aggregations_geo_tile_grid_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_geo_tile_grid_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_geo_tile_grid_bucket
}));

export const types_aggregations_geo_tile_grid_aggregate = types_aggregations_multi_bucket_aggregate_base_geo_tile_grid_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_geo_hash_grid_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_geo_hash
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_geo_hash_grid_bucket = z.union([
    z.record(z.string(), types_aggregations_geo_hash_grid_bucket),
    z.array(types_aggregations_geo_hash_grid_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_geo_hash_grid_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_geo_hash_grid_bucket
}));

export const types_aggregations_geo_hash_grid_aggregate = types_aggregations_multi_bucket_aggregate_base_geo_hash_grid_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_unmapped_sampler_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_sampler_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_parent_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_children_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_global_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_reverse_nested_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_nested_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.string(), z.unknown()));

/**
 * Result of a `rare_terms` aggregation when the field is unmapped. `buckets` is always empty.
 */
export const types_aggregations_unmapped_rare_terms_aggregate = types_aggregations_multi_bucket_aggregate_base_void.and(z.record(z.string(), z.unknown()));

export const types_aggregations_string_rare_terms_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.string()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_string_rare_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_string_rare_terms_bucket),
    z.array(types_aggregations_string_rare_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_string_rare_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_string_rare_terms_bucket
}));

/**
 * Result of the `rare_terms` aggregation when the field is a string.
 */
export const types_aggregations_string_rare_terms_aggregate = types_aggregations_multi_bucket_aggregate_base_string_rare_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_long_rare_terms_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_long_rare_terms_bucket = z.union([
    z.record(z.string(), types_aggregations_long_rare_terms_bucket),
    z.array(types_aggregations_long_rare_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_long_rare_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_long_rare_terms_bucket
}));

/**
 * Result of the `rare_terms` aggregation when the field is some kind of whole number like a integer, long, or a date.
 */
export const types_aggregations_long_rare_terms_aggregate = types_aggregations_multi_bucket_aggregate_base_long_rare_terms_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_variable_width_histogram_bucket = types_aggregations_multi_bucket_base.and(z.object({
    min: z.number(),
    key: z.number(),
    max: z.number(),
    min_as_string: z.optional(z.string()),
    key_as_string: z.optional(z.string()),
    max_as_string: z.optional(z.string())
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_variable_width_histogram_bucket = z.union([
    z.record(z.string(), types_aggregations_variable_width_histogram_bucket),
    z.array(types_aggregations_variable_width_histogram_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_variable_width_histogram_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_variable_width_histogram_bucket
}));

export const types_aggregations_variable_width_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_variable_width_histogram_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_date_histogram_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key_as_string: z.optional(z.string()),
    key: types_epoch_time_unit_millis
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_date_histogram_bucket = z.union([
    z.record(z.string(), types_aggregations_date_histogram_bucket),
    z.array(types_aggregations_date_histogram_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_date_histogram_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_date_histogram_bucket
}));

export const types_aggregations_auto_date_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_date_histogram_bucket.and(z.object({
    interval: types_duration_large
}));

export const types_aggregations_date_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_date_histogram_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_histogram_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key_as_string: z.optional(z.string()),
    key: z.number()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_histogram_bucket = z.union([
    z.record(z.string(), types_aggregations_histogram_bucket),
    z.array(types_aggregations_histogram_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_histogram_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_histogram_bucket
}));

export const types_aggregations_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_histogram_bucket.and(z.record(z.string(), z.unknown()));

export const types_aggregations_geo_centroid_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    location: z.optional(types_geo_location)
}));

export const types_aggregations_geo_bounds_aggregate = types_aggregations_aggregate_base.and(z.object({
    bounds: z.optional(types_geo_bounds)
}));

export const types_cartesian_point = z.object({
    x: z.number(),
    y: z.number()
});

export const types_aggregations_cartesian_centroid_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    location: z.optional(types_cartesian_point)
}));

export const types_aggregations_cartesian_bounds_aggregate = types_aggregations_aggregate_base.and(z.object({
    bounds: z.optional(types_top_left_bottom_right_geo_bounds)
}));

export const types_aggregations_standard_deviation_bounds_as_string = z.object({
    upper: z.string(),
    lower: z.string(),
    upper_population: z.string(),
    lower_population: z.string(),
    upper_sampling: z.string(),
    lower_sampling: z.string()
});

export const types_aggregations_standard_deviation_bounds = z.object({
    upper: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    lower: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    upper_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    lower_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    upper_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    lower_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ])
});

/**
 * Statistics aggregation result. `min`, `max` and `avg` are missing if there were no values to process
 * (`count` is zero).
 */
export const types_aggregations_stats_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    min: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    max: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    avg: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    sum: z.number(),
    min_as_string: z.optional(z.string()),
    max_as_string: z.optional(z.string()),
    avg_as_string: z.optional(z.string()),
    sum_as_string: z.optional(z.string())
}));

export const types_aggregations_extended_stats_aggregate = types_aggregations_stats_aggregate.and(z.object({
    sum_of_squares: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    variance: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    variance_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    variance_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation_bounds: z.optional(types_aggregations_standard_deviation_bounds),
    sum_of_squares_as_string: z.optional(z.string()),
    variance_as_string: z.optional(z.string()),
    variance_population_as_string: z.optional(z.string()),
    variance_sampling_as_string: z.optional(z.string()),
    std_deviation_as_string: z.optional(z.string()),
    std_deviation_bounds_as_string: z.optional(types_aggregations_standard_deviation_bounds_as_string)
}));

export const types_aggregations_extended_stats_bucket_aggregate = types_aggregations_extended_stats_aggregate.and(z.record(z.string(), z.unknown()));

export const types_aggregations_stats_bucket_aggregate = types_aggregations_stats_aggregate.and(z.record(z.string(), z.unknown()));

export const types_aggregations_change_point_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_field_value
}));

export const types_aggregations_trend_change = z.object({
    p_value: z.number(),
    r_value: z.number(),
    change_point: z.number()
});

export const types_aggregations_abstract_change_point = z.object({
    p_value: z.number(),
    change_point: z.number()
});

export const types_aggregations_step_change = types_aggregations_abstract_change_point.and(z.record(z.string(), z.unknown()));

export const types_aggregations_stationary = z.record(z.string(), z.unknown());

export const types_aggregations_spike = types_aggregations_abstract_change_point.and(z.record(z.string(), z.unknown()));

export const types_aggregations_non_stationary = z.object({
    p_value: z.number(),
    r_value: z.number(),
    trend: z.string()
});

export const types_aggregations_indeterminable = z.object({
    reason: z.string()
});

export const types_aggregations_distribution_change = types_aggregations_abstract_change_point.and(z.record(z.string(), z.unknown()));

export const types_aggregations_dip = types_aggregations_abstract_change_point.and(z.record(z.string(), z.unknown()));

export const types_aggregations_change_type = z.object({
    dip: z.optional(types_aggregations_dip),
    distribution_change: z.optional(types_aggregations_distribution_change),
    indeterminable: z.optional(types_aggregations_indeterminable),
    non_stationary: z.optional(types_aggregations_non_stationary),
    spike: z.optional(types_aggregations_spike),
    stationary: z.optional(types_aggregations_stationary),
    step_change: z.optional(types_aggregations_step_change),
    trend_change: z.optional(types_aggregations_trend_change)
});

export const types_aggregations_change_point_aggregate = types_aggregations_aggregate_base.and(z.object({
    type: types_aggregations_change_type,
    bucket: z.optional(types_aggregations_change_point_bucket)
}));

export const types_aggregations_bucket_metric_value_aggregate = types_aggregations_single_metric_aggregate_base.and(z.object({
    keys: z.array(z.string())
}));

export const types_aggregations_derivative_aggregate = types_aggregations_single_metric_aggregate_base.and(z.object({
    normalized_value: z.optional(z.number()),
    normalized_value_as_string: z.optional(z.string())
}));

export const types_aggregations_simple_value_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

/**
 * Weighted average aggregation result. `value` is missing if the weight was set to zero.
 */
export const types_aggregations_weighted_avg_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_avg_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

/**
 * Sum aggregation result. `value` is always present and is zero if there were no values to process.
 */
export const types_aggregations_sum_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_max_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_min_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_median_absolute_deviation_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_array_percentiles_item = z.object({
    key: z.number(),
    value: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    value_as_string: z.optional(z.string())
});

export const types_aggregations_keyed_percentiles = z.record(z.string(), z.union([
    z.string(),
    z.number(),
    z.null()
]));

export const types_aggregations_percentiles = z.union([
    types_aggregations_keyed_percentiles,
    z.array(types_aggregations_array_percentiles_item)
]);

export const types_aggregations_percentiles_aggregate_base = types_aggregations_aggregate_base.and(z.object({
    values: types_aggregations_percentiles
}));

export const types_aggregations_percentiles_bucket_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_t_digest_percentile_ranks_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_t_digest_percentiles_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_hdr_percentile_ranks_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_hdr_percentiles_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.string(), z.unknown()));

export const types_indices_response_base = types_acknowledged_response_base.and(z.object({
    _shards: z.optional(types_shard_statistics)
}));

export const esql_types_esql_param = z.union([
    types_field_value,
    z.array(types_field_value)
]);

export const esql_types_esql_shard_failure = z.object({
    shard: z.number(),
    index: z.union([
        types_index_name,
        z.string(),
        z.null()
    ]),
    node: z.optional(types_node_id),
    reason: types_error_cause
});

export const esql_types_esql_shard_info = z.object({
    total: z.number(),
    successful: z.optional(z.number()),
    skipped: z.optional(z.number()),
    failed: z.optional(z.number())
});

export const esql_types_esql_cluster_status = z.enum([
    'running',
    'successful',
    'partial',
    'skipped',
    'failed'
]);

export const esql_types_esql_cluster_details = z.object({
    status: esql_types_esql_cluster_status,
    indices: z.string(),
    took: z.optional(types_duration_value_unit_millis),
    _shards: z.optional(esql_types_esql_shard_info),
    failures: z.optional(z.array(esql_types_esql_shard_failure))
});

export const esql_types_esql_cluster_info = z.object({
    total: z.number(),
    successful: z.number(),
    running: z.number(),
    skipped: z.number(),
    partial: z.number(),
    failed: z.number(),
    details: z.record(z.string(), esql_types_esql_cluster_details)
});

export const esql_types_esql_column_info = z.object({
    name: z.string(),
    type: z.string()
});

export const esql_types_esql_result = z.object({
    took: z.optional(types_duration_value_unit_millis),
    is_partial: z.optional(z.boolean()),
    all_columns: z.optional(z.array(esql_types_esql_column_info)),
    columns: z.array(esql_types_esql_column_info),
    values: z.array(z.array(types_field_value)),
    _clusters: z.optional(esql_types_esql_cluster_info),
    profile: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Profiling information. Present if `profile` was `true` in the request.\nThe contents of this field are currently unstable.'
    }))
});

export const esql_types_table_values_long_double = z.union([
    z.number(),
    z.array(z.number())
]);

export const esql_types_table_values_long_value = z.union([
    z.number(),
    z.array(z.number())
]);

export const esql_types_table_values_keyword_value = z.union([
    z.string(),
    z.array(z.string())
]);

export const esql_types_table_values_integer_value = z.union([
    z.number(),
    z.array(z.number())
]);

export const esql_types_table_values_container = z.object({
    integer: z.optional(z.array(esql_types_table_values_integer_value)),
    keyword: z.optional(z.array(esql_types_table_values_keyword_value)),
    long: z.optional(z.array(esql_types_table_values_long_value)),
    double: z.optional(z.array(esql_types_table_values_long_double))
});

export const esql_types_esql_format = z.enum([
    'csv',
    'json',
    'tsv',
    'txt',
    'yaml',
    'cbor',
    'smile',
    'arrow'
]);

export const types_inline_get_dict_user_defined = z.object({
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    found: z.boolean(),
    _seq_no: z.optional(types_sequence_number),
    _primary_term: z.optional(z.number()),
    _routing: z.optional(types_routing),
    _source: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())))
});

export const global_bulk_response_item = z.object({
    _id: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    _index: z.string().register(z.globalRegistry, {
        description: 'The name of the index associated with the operation.\nIf the operation targeted a data stream, this is the backing index into which the document was written.'
    }),
    status: z.number().register(z.globalRegistry, {
        description: 'The HTTP status code returned for the operation.'
    }),
    failure_store: z.optional(global_bulk_failure_store_status),
    error: z.optional(types_error_cause),
    _primary_term: z.optional(z.number().register(z.globalRegistry, {
        description: 'The primary term assigned to the document for the operation.\nThis property is returned only for successful operations.'
    })),
    result: z.optional(z.string().register(z.globalRegistry, {
        description: 'The result of the operation.\nSuccessful values are `created`, `deleted`, and `updated`.'
    })),
    _seq_no: z.optional(types_sequence_number),
    _shards: z.optional(types_shard_statistics),
    _version: z.optional(types_version_number),
    forced_refresh: z.optional(z.boolean()),
    get: z.optional(types_inline_get_dict_user_defined)
});

export const global_bulk_operation_base = z.object({
    _id: z.optional(types_id),
    _index: z.optional(types_index_name),
    routing: z.optional(types_routing),
    if_primary_term: z.optional(z.number()),
    if_seq_no: z.optional(types_sequence_number),
    version: z.optional(types_version_number),
    version_type: z.optional(types_version_type)
});

export const global_bulk_delete_operation = global_bulk_operation_base.and(z.record(z.string(), z.unknown()));

export const global_bulk_update_operation = global_bulk_operation_base.and(z.object({
    require_alias: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the request\'s actions must target an index alias.'
    })),
    retry_on_conflict: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of times an update should be retried in the case of a version conflict.'
    }))
}));

export const global_bulk_write_operation = global_bulk_operation_base.and(z.object({
    dynamic_templates: z.optional(z.record(z.string(), z.string()).register(z.globalRegistry, {
        description: 'A map from the full name of fields to the name of dynamic templates.\nIt defaults to an empty map.\nIf a name matches a dynamic template, that template will be applied regardless of other match predicates defined in the template.\nIf a field is already defined in the mapping, then this parameter won\'t be used.'
    })),
    pipeline: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.'
    })),
    require_alias: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the request\'s actions must target an index alias.'
    }))
}));

export const global_bulk_create_operation = global_bulk_write_operation.and(z.record(z.string(), z.unknown()));

export const global_bulk_index_operation = global_bulk_write_operation.and(z.record(z.string(), z.unknown()));

export const global_bulk_operation_container = z.object({
    index: z.optional(global_bulk_index_operation),
    create: z.optional(global_bulk_create_operation),
    update: z.optional(global_bulk_update_operation),
    delete: z.optional(global_bulk_delete_operation)
});

export const types_wait_for_active_shard_options = z.enum(['all', 'index-setting']);

export const types_wait_for_active_shards = z.union([
    z.number(),
    types_wait_for_active_shard_options
]);

/**
 * Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.
 * Used as a query parameter along with the `_source_includes` and `_source_excludes` parameters.
 */
export const global_search_types_source_config_param = z.union([
    z.boolean(),
    types_fields
]);

export const types_suggest_mode = z.enum([
    'missing',
    'popular',
    'always'
]);

export const types_query_dsl_terms_set_query = types_query_dsl_query_base.and(z.lazy(() => z.object({
    minimum_should_match: z.optional(types_minimum_should_match),
    minimum_should_match_field: z.optional(types_field),
    get minimum_should_match_script() {
        return z.optional(z.lazy((): any => types_script));
    },
    terms: z.array(types_field_value).register(z.globalRegistry, {
        description: 'Array of terms you wish to find in the provided field.'
    })
})));

export const types_mapping_runtime_field = z.object({
    fields: z.optional(z.record(z.string(), types_mapping_composite_sub_field).register(z.globalRegistry, {
        description: 'For type `composite`'
    })),
    fetch_fields: z.optional(z.array(types_mapping_runtime_field_fetch_fields).register(z.globalRegistry, {
        description: 'For type `lookup`'
    })),
    format: z.optional(z.string().register(z.globalRegistry, {
        description: 'A custom format for `date` type runtime fields.'
    })),
    input_field: z.optional(types_field),
    target_field: z.optional(types_field),
    target_index: z.optional(types_index_name),
    get script() {
        return z.optional(z.lazy((): any => types_script));
    },
    type: types_mapping_runtime_field_type
});

export const types_script = z.object({
    get source() {
        return z.optional(z.lazy((): any => types_script_source));
    },
    id: z.optional(types_id),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'Specifies any named parameters that are passed into the script as variables.\nUse parameters instead of hard-coded values to decrease compile time.'
    })),
    lang: z.optional(types_script_language),
    options: z.optional(z.record(z.string(), z.string()))
});

export const types_mapping_runtime_fields = z.record(z.string(), types_mapping_runtime_field);

export const types_diversify_retriever = z.lazy((): any => types_retriever_base).and(z.lazy(() => z.object({
    type: types_diversify_retriever_types,
    field: z.string().register(z.globalRegistry, {
        description: 'The document field on which to diversify results on.'
    }),
    get retriever() {
        return z.lazy((): any => types_retriever_container);
    },
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of top documents to return after diversification.'
    })),
    rank_window_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of top documents from the nested retriever to consider for diversification.'
    })),
    query_vector: z.optional(types_query_vector),
    query_vector_builder: z.optional(types_query_vector_builder),
    lambda: z.optional(z.number().register(z.globalRegistry, {
        description: 'Controls the trade-off between relevance and diversity for MMR. A value of 0.0 focuses solely on diversity, while a value of 1.0 focuses solely on relevance. Required for MMR'
    }))
})));

export const types_retriever_container = z.object({
    get standard() {
        return z.optional(z.lazy((): any => types_standard_retriever));
    },
    get knn() {
        return z.optional(z.lazy((): any => types_knn_retriever));
    },
    get rrf() {
        return z.optional(z.lazy((): any => types_rrf_retriever));
    },
    get text_similarity_reranker() {
        return z.optional(z.lazy((): any => types_text_similarity_reranker));
    },
    get rule() {
        return z.optional(z.lazy((): any => types_rule_retriever));
    },
    get rescorer() {
        return z.optional(z.lazy((): any => types_rescorer_retriever));
    },
    get linear() {
        return z.optional(z.lazy((): any => types_linear_retriever));
    },
    get pinned() {
        return z.optional(z.lazy((): any => types_pinned_retriever));
    },
    diversify: z.optional(types_diversify_retriever)
});

export const types_pinned_retriever = z.lazy((): any => types_retriever_base).and(z.object({
    retriever: types_retriever_container,
    ids: z.optional(z.array(z.string())),
    docs: z.optional(z.array(types_specified_document)),
    rank_window_size: z.optional(z.number())
}));

/**
 * An Elasticsearch Query DSL (Domain Specific Language) object that defines a query.
 */
export const types_query_dsl_query_container = z.object({
    get bool() {
        return z.optional(z.lazy((): any => types_query_dsl_bool_query));
    },
    get boosting() {
        return z.optional(z.lazy((): any => types_query_dsl_boosting_query));
    },
    common: z.optional(z.record(z.string(), types_query_dsl_common_terms_query)),
    combined_fields: z.optional(types_query_dsl_combined_fields_query),
    get constant_score() {
        return z.optional(z.lazy((): any => types_query_dsl_constant_score_query));
    },
    get dis_max() {
        return z.optional(z.lazy((): any => types_query_dsl_dis_max_query));
    },
    distance_feature: z.optional(types_query_dsl_distance_feature_query),
    exists: z.optional(types_query_dsl_exists_query),
    get function_score() {
        return z.optional(z.lazy((): any => types_query_dsl_function_score_query));
    },
    fuzzy: z.optional(z.record(z.string(), types_query_dsl_fuzzy_query).register(z.globalRegistry, {
        description: 'Returns documents that contain terms similar to the search term, as measured by a Levenshtein edit distance.'
    })),
    geo_bounding_box: z.optional(types_query_dsl_geo_bounding_box_query),
    geo_distance: z.optional(types_query_dsl_geo_distance_query),
    geo_grid: z.optional(z.record(z.string(), types_query_dsl_geo_grid_query).register(z.globalRegistry, {
        description: 'Matches `geo_point` and `geo_shape` values that intersect a grid cell from a GeoGrid aggregation.'
    })),
    geo_polygon: z.optional(types_query_dsl_geo_polygon_query),
    geo_shape: z.optional(types_query_dsl_geo_shape_query),
    get has_child() {
        return z.optional(z.lazy((): any => types_query_dsl_has_child_query));
    },
    get has_parent() {
        return z.optional(z.lazy((): any => types_query_dsl_has_parent_query));
    },
    ids: z.optional(types_query_dsl_ids_query),
    get intervals() {
        return z.optional(z.record(z.string(), z.lazy((): any => types_query_dsl_intervals_query)).register(z.globalRegistry, {
            description: 'Returns documents based on the order and proximity of matching terms.'
        }));
    },
    get knn() {
        return z.optional(z.lazy((): any => types_knn_query));
    },
    match: z.optional(z.record(z.string(), types_query_dsl_match_query).register(z.globalRegistry, {
        description: 'Returns documents that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.'
    })),
    match_all: z.optional(types_query_dsl_match_all_query),
    match_bool_prefix: z.optional(z.record(z.string(), types_query_dsl_match_bool_prefix_query).register(z.globalRegistry, {
        description: 'Analyzes its input and constructs a `bool` query from the terms.\nEach term except the last is used in a `term` query.\nThe last term is used in a prefix query.'
    })),
    match_none: z.optional(types_query_dsl_match_none_query),
    match_phrase: z.optional(z.record(z.string(), types_query_dsl_match_phrase_query).register(z.globalRegistry, {
        description: 'Analyzes the text and creates a phrase query out of the analyzed text.'
    })),
    match_phrase_prefix: z.optional(z.record(z.string(), types_query_dsl_match_phrase_prefix_query).register(z.globalRegistry, {
        description: 'Returns documents that contain the words of a provided text, in the same order as provided.\nThe last term of the provided text is treated as a prefix, matching any words that begin with that term.'
    })),
    more_like_this: z.optional(types_query_dsl_more_like_this_query),
    multi_match: z.optional(types_query_dsl_multi_match_query),
    get nested() {
        return z.optional(z.lazy((): any => types_query_dsl_nested_query));
    },
    parent_id: z.optional(types_query_dsl_parent_id_query),
    percolate: z.optional(types_query_dsl_percolate_query),
    get pinned() {
        return z.optional(z.lazy((): any => types_query_dsl_pinned_query));
    },
    prefix: z.optional(z.record(z.string(), types_query_dsl_prefix_query).register(z.globalRegistry, {
        description: 'Returns documents that contain a specific prefix in a provided field.'
    })),
    query_string: z.optional(types_query_dsl_query_string_query),
    range: z.optional(z.record(z.string(), types_query_dsl_range_query).register(z.globalRegistry, {
        description: 'Returns documents that contain terms within a provided range.'
    })),
    rank_feature: z.optional(types_query_dsl_rank_feature_query),
    regexp: z.optional(z.record(z.string(), types_query_dsl_regexp_query).register(z.globalRegistry, {
        description: 'Returns documents that contain terms matching a regular expression.'
    })),
    get rule() {
        return z.optional(z.lazy((): any => types_query_dsl_rule_query));
    },
    get script() {
        return z.optional(z.lazy((): any => types_query_dsl_script_query));
    },
    get script_score() {
        return z.optional(z.lazy((): any => types_query_dsl_script_score_query));
    },
    semantic: z.optional(types_query_dsl_semantic_query),
    shape: z.optional(types_query_dsl_shape_query),
    simple_query_string: z.optional(types_query_dsl_simple_query_string_query),
    get span_containing() {
        return z.optional(z.lazy((): any => types_query_dsl_span_containing_query));
    },
    get span_field_masking() {
        return z.optional(z.lazy((): any => types_query_dsl_span_field_masking_query));
    },
    get span_first() {
        return z.optional(z.lazy((): any => types_query_dsl_span_first_query));
    },
    get span_multi() {
        return z.optional(z.lazy((): any => types_query_dsl_span_multi_term_query));
    },
    get span_near() {
        return z.optional(z.lazy((): any => types_query_dsl_span_near_query));
    },
    get span_not() {
        return z.optional(z.lazy((): any => types_query_dsl_span_not_query));
    },
    get span_or() {
        return z.optional(z.lazy((): any => types_query_dsl_span_or_query));
    },
    span_term: z.optional(z.record(z.string(), types_query_dsl_span_term_query).register(z.globalRegistry, {
        description: 'Matches spans containing a term.'
    })),
    get span_within() {
        return z.optional(z.lazy((): any => types_query_dsl_span_within_query));
    },
    sparse_vector: z.optional(types_query_dsl_sparse_vector_query),
    term: z.optional(z.record(z.string(), types_query_dsl_term_query).register(z.globalRegistry, {
        description: 'Returns documents that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field\'s value, including whitespace and capitalization.'
    })),
    terms: z.optional(types_query_dsl_terms_query),
    terms_set: z.optional(z.record(z.string(), types_query_dsl_terms_set_query).register(z.globalRegistry, {
        description: 'Returns documents that contain a minimum number of exact terms in a provided field.\nTo return a document, a required number of terms must exactly match the field values, including whitespace and capitalization.'
    })),
    text_expansion: z.optional(z.record(z.string(), types_query_dsl_text_expansion_query).register(z.globalRegistry, {
        description: 'Uses a natural language processing model to convert the query text into a list of token-weight pairs which are then used in a query against a sparse vector or rank features field.'
    })),
    weighted_tokens: z.optional(z.record(z.string(), types_query_dsl_weighted_tokens_query).register(z.globalRegistry, {
        description: 'Supports returning text_expansion query results by sending in precomputed tokens with the query.'
    })),
    wildcard: z.optional(z.record(z.string(), types_query_dsl_wildcard_query).register(z.globalRegistry, {
        description: 'Returns documents that contain terms matching a wildcard pattern.'
    })),
    wrapper: z.optional(types_query_dsl_wrapper_query),
    type: z.optional(types_query_dsl_type_query)
}).register(z.globalRegistry, {
    description: 'An Elasticsearch Query DSL (Domain Specific Language) object that defines a query.'
});

export const types_query_dsl_span_within_query = types_query_dsl_query_base.and(z.lazy(() => z.object({
    get big() {
        return z.lazy((): any => types_query_dsl_span_query);
    },
    get little() {
        return z.lazy((): any => types_query_dsl_span_query);
    }
})));

export const types_query_dsl_span_query = z.object({
    get span_containing() {
        return z.optional(z.lazy((): any => types_query_dsl_span_containing_query));
    },
    get span_field_masking() {
        return z.optional(z.lazy((): any => types_query_dsl_span_field_masking_query));
    },
    get span_first() {
        return z.optional(z.lazy((): any => types_query_dsl_span_first_query));
    },
    span_gap: z.optional(types_query_dsl_span_gap_query),
    get span_multi() {
        return z.optional(z.lazy((): any => types_query_dsl_span_multi_term_query));
    },
    get span_near() {
        return z.optional(z.lazy((): any => types_query_dsl_span_near_query));
    },
    get span_not() {
        return z.optional(z.lazy((): any => types_query_dsl_span_not_query));
    },
    get span_or() {
        return z.optional(z.lazy((): any => types_query_dsl_span_or_query));
    },
    span_term: z.optional(z.record(z.string(), types_query_dsl_span_term_query).register(z.globalRegistry, {
        description: 'The equivalent of the `term` query but for use with other span queries.'
    })),
    span_within: z.optional(types_query_dsl_span_within_query)
});

export const types_query_dsl_span_or_query = types_query_dsl_query_base.and(z.object({
    clauses: z.array(types_query_dsl_span_query).register(z.globalRegistry, {
        description: 'Array of one or more other span type queries.'
    })
}));

export const types_query_dsl_span_not_query = types_query_dsl_query_base.and(z.object({
    dist: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of tokens from within the include span that can’t have overlap with the exclude span.\nEquivalent to setting both `pre` and `post`.'
    })),
    exclude: types_query_dsl_span_query,
    include: types_query_dsl_span_query,
    post: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of tokens after the include span that can’t have overlap with the exclude span.'
    })),
    pre: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of tokens before the include span that can’t have overlap with the exclude span.'
    }))
}));

export const types_query_dsl_span_near_query = types_query_dsl_query_base.and(z.object({
    clauses: z.array(types_query_dsl_span_query).register(z.globalRegistry, {
        description: 'Array of one or more other span type queries.'
    }),
    in_order: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Controls whether matches are required to be in-order.'
    })),
    slop: z.optional(z.number().register(z.globalRegistry, {
        description: 'Controls the maximum number of intervening unmatched positions permitted.'
    }))
}));

export const types_query_dsl_span_multi_term_query = types_query_dsl_query_base.and(z.object({
    match: types_query_dsl_query_container
}));

export const types_query_dsl_span_first_query = types_query_dsl_query_base.and(z.object({
    end: z.number().register(z.globalRegistry, {
        description: 'Controls the maximum end position permitted in a match.'
    }),
    match: types_query_dsl_span_query
}));

export const types_query_dsl_span_field_masking_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    query: types_query_dsl_span_query
}));

export const types_query_dsl_span_containing_query = types_query_dsl_query_base.and(z.object({
    big: types_query_dsl_span_query,
    little: types_query_dsl_span_query
}));

export const types_query_dsl_script_score_query = types_query_dsl_query_base.and(z.object({
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: 'Documents with a score lower than this floating point number are excluded from the search results.'
    })),
    query: types_query_dsl_query_container,
    script: types_script
}));

export const types_inner_retriever = z.object({
    retriever: types_retriever_container,
    weight: z.number(),
    normalizer: types_score_normalizer
});

export const types_linear_retriever = z.lazy((): any => types_retriever_base).and(z.object({
    retrievers: z.optional(z.array(types_inner_retriever).register(z.globalRegistry, {
        description: 'Inner retrievers.'
    })),
    rank_window_size: z.optional(z.number()),
    query: z.optional(z.string()),
    fields: z.optional(z.array(z.string())),
    normalizer: z.optional(types_score_normalizer)
}));

export const types_retriever_base = z.object({
    filter: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: 'Minimum _score for matching documents. Documents with a lower _score are not included in the top documents.'
    })),
    _name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Retriever name.'
    }))
});

export const types_rescorer_retriever = types_retriever_base.and(z.object({
    retriever: types_retriever_container,
    rescore: z.union([
        z.lazy((): any => global_search_types_rescore),
        z.array(z.lazy((): any => global_search_types_rescore))
    ])
}));

export const global_search_types_script_rescore = z.object({
    script: types_script
});

export const global_search_types_rescore_query = z.object({
    rescore_query: types_query_dsl_query_container,
    query_weight: z.optional(z.number().register(z.globalRegistry, {
        description: 'Relative importance of the original query versus the rescore query.'
    })),
    rescore_query_weight: z.optional(z.number().register(z.globalRegistry, {
        description: 'Relative importance of the rescore query versus the original query.'
    })),
    score_mode: z.optional(global_search_types_score_mode)
});

export const global_search_types_rescore = z.object({
    window_size: z.optional(z.number())
}).and(z.object({
    query: z.optional(global_search_types_rescore_query),
    learning_to_rank: z.optional(global_search_types_learning_to_rank),
    script: z.optional(global_search_types_script_rescore)
}));

export const types_rule_retriever = types_retriever_base.and(z.object({
    ruleset_ids: z.union([
        types_id,
        z.array(types_id)
    ]),
    match_criteria: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'The match criteria that will determine if a rule in the provided rulesets should be applied.'
    }),
    retriever: types_retriever_container,
    rank_window_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'This value determines the size of the individual result set.'
    }))
}));

export const types_text_similarity_reranker = types_retriever_base.and(z.object({
    retriever: types_retriever_container,
    rank_window_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'This value determines how many documents we will consider from the nested retriever.'
    })),
    inference_id: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier of the inference endpoint created using the inference API.'
    })),
    inference_text: z.string().register(z.globalRegistry, {
        description: 'The text snippet used as the basis for similarity comparison.'
    }),
    field: z.string().register(z.globalRegistry, {
        description: 'The document field to be used for text similarity comparisons. This field should contain the text that will be evaluated against the inference_text.'
    }),
    chunk_rescorer: z.optional(types_chunk_rescorer)
}));

/**
 * Wraps a retriever with an optional weight for RRF scoring.
 */
export const types_rrf_retriever_component = z.object({
    retriever: types_retriever_container,
    weight: z.optional(z.number().register(z.globalRegistry, {
        description: 'Weight multiplier for this retriever\'s contribution to the RRF score. Higher values increase influence. Defaults to 1.0 if not specified. Must be non-negative.'
    }))
}).register(z.globalRegistry, {
    description: 'Wraps a retriever with an optional weight for RRF scoring.'
});

/**
 * Either a direct RetrieverContainer (backward compatible) or an RRFRetrieverComponent with weight.
 */
export const types_rrf_retriever_entry = z.union([
    types_retriever_container,
    types_rrf_retriever_component
]);

export const types_rrf_retriever = types_retriever_base.and(z.object({
    retrievers: z.array(types_rrf_retriever_entry).register(z.globalRegistry, {
        description: 'A list of child retrievers to specify which sets of returned top documents will have the RRF formula applied to them. Each retriever can optionally include a weight parameter.'
    }),
    rank_constant: z.optional(z.number().register(z.globalRegistry, {
        description: 'This value determines how much influence documents in individual result sets per query have over the final ranked result set.'
    })),
    rank_window_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'This value determines the size of the individual result sets per query.'
    })),
    query: z.optional(z.string()),
    fields: z.optional(z.array(z.string()))
}));

export const types_knn_retriever = types_retriever_base.and(z.object({
    field: z.string().register(z.globalRegistry, {
        description: 'The name of the vector field to search against.'
    }),
    query_vector: z.optional(types_query_vector),
    query_vector_builder: z.optional(types_query_vector_builder),
    k: z.number().register(z.globalRegistry, {
        description: 'Number of nearest neighbors to return as top hits.'
    }),
    num_candidates: z.number().register(z.globalRegistry, {
        description: 'Number of nearest neighbor candidates to consider per shard.'
    }),
    visit_percentage: z.optional(z.number().register(z.globalRegistry, {
        description: 'The percentage of vectors to explore per shard while doing knn search with bbq_disk'
    })),
    similarity: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum similarity required for a document to be considered a match.'
    })),
    rescore_vector: z.optional(types_rescore_vector)
}));

export const types_standard_retriever = types_retriever_base.and(z.lazy(() => z.object({
    query: z.optional(types_query_dsl_query_container),
    search_after: z.optional(types_sort_results),
    terminate_after: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of documents to collect for each shard.'
    })),
    get sort() {
        return z.optional(z.lazy((): any => types_sort));
    },
    get collapse() {
        return z.optional(z.lazy((): any => global_search_types_field_collapse));
    }
})));

export const types_script_field = z.object({
    script: types_script,
    ignore_failure: z.optional(z.boolean())
});

export const global_search_types_highlight_field = z.lazy((): any => global_search_types_highlight_base).and(z.object({
    fragment_offset: z.optional(z.number()),
    matched_fields: z.optional(types_fields)
}));

export const global_search_types_highlight_base = z.object({
    type: z.optional(global_search_types_highlighter_type),
    boundary_chars: z.optional(z.string().register(z.globalRegistry, {
        description: 'A string that contains each boundary character.'
    })),
    boundary_max_scan: z.optional(z.number().register(z.globalRegistry, {
        description: 'How far to scan for boundary characters.'
    })),
    boundary_scanner: z.optional(global_search_types_boundary_scanner),
    boundary_scanner_locale: z.optional(z.string().register(z.globalRegistry, {
        description: 'Controls which locale is used to search for sentence and word boundaries.\nThis parameter takes a form of a language tag, for example: `"en-US"`, `"fr-FR"`, `"ja-JP"`.'
    })),
    force_source: z.optional(z.boolean()),
    fragmenter: z.optional(global_search_types_highlighter_fragmenter),
    fragment_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The size of the highlighted fragment in characters.'
    })),
    highlight_filter: z.optional(z.boolean()),
    highlight_query: z.optional(types_query_dsl_query_container),
    max_fragment_length: z.optional(z.number()),
    max_analyzed_offset: z.optional(z.number().register(z.globalRegistry, {
        description: 'If set to a non-negative value, highlighting stops at this defined maximum limit.\nThe rest of the text is not processed, thus not highlighted and no error is returned\nThe `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it’s set to lower value than the query setting.'
    })),
    no_match_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.'
    })),
    number_of_fragments: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of fragments to return.\nIf the number of fragments is set to `0`, no fragments are returned.\nInstead, the entire field contents are highlighted and returned.\nThis can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.\nIf `number_of_fragments` is `0`, `fragment_size` is ignored.'
    })),
    options: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    order: z.optional(global_search_types_highlighter_order),
    phrase_limit: z.optional(z.number().register(z.globalRegistry, {
        description: 'Controls the number of matching phrases in a document that are considered.\nPrevents the `fvh` highlighter from analyzing too many phrases and consuming too much memory.\nWhen using `matched_fields`, `phrase_limit` phrases per matched field are considered. Raising the limit increases query time and consumes more memory.\nOnly supported by the `fvh` highlighter.'
    })),
    post_tags: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Use in conjunction with `pre_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags.'
    })),
    pre_tags: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Use in conjunction with `post_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags.'
    })),
    require_field_match: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'By default, only fields that contains a query match are highlighted.\nSet to `false` to highlight all fields.'
    })),
    tags_schema: z.optional(global_search_types_highlighter_tags_schema)
});

export const global_search_types_highlight = global_search_types_highlight_base.and(z.object({
    encoder: z.optional(global_search_types_highlighter_encoder),
    fields: z.union([
        z.record(z.string(), global_search_types_highlight_field),
        z.array(z.record(z.string(), global_search_types_highlight_field))
    ])
}));

export const global_search_types_inner_hits = z.object({
    name: z.optional(types_name),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of hits to return per `inner_hits`.'
    })),
    from: z.optional(z.number().register(z.globalRegistry, {
        description: 'Inner hit starting document offset.'
    })),
    get collapse() {
        return z.optional(z.lazy((): any => global_search_types_field_collapse));
    },
    docvalue_fields: z.optional(z.array(types_query_dsl_field_and_format)),
    explain: z.optional(z.boolean()),
    highlight: z.optional(global_search_types_highlight),
    ignore_unmapped: z.optional(z.boolean()),
    script_fields: z.optional(z.record(z.string(), types_script_field)),
    seq_no_primary_term: z.optional(z.boolean()),
    fields: z.optional(z.array(types_field)),
    get sort() {
        return z.optional(z.lazy((): any => types_sort));
    },
    _source: z.optional(global_search_types_source_config),
    stored_fields: z.optional(types_fields),
    track_scores: z.optional(z.boolean()),
    version: z.optional(z.boolean())
});

export const types_script_sort = z.object({
    order: z.optional(types_sort_order),
    script: types_script,
    type: z.optional(types_script_sort_type),
    mode: z.optional(types_sort_mode),
    get nested() {
        return z.optional(z.lazy((): any => types_nested_sort_value));
    }
});

export const types_nested_sort_value = z.object({
    filter: z.optional(types_query_dsl_query_container),
    max_children: z.optional(z.number()),
    get nested() {
        return z.optional(z.lazy((): any => types_nested_sort_value));
    },
    path: types_field
});

export const types_geo_distance_sort = z.object({
    mode: z.optional(types_sort_mode),
    distance_type: z.optional(types_geo_distance_type),
    ignore_unmapped: z.optional(z.boolean()),
    order: z.optional(types_sort_order),
    unit: z.optional(types_distance_unit),
    nested: z.optional(types_nested_sort_value)
});

export const types_sort_options = z.object({
    _score: z.optional(types_score_sort),
    _doc: z.optional(types_score_sort),
    _geo_distance: z.optional(types_geo_distance_sort),
    _script: z.optional(types_script_sort)
});

export const types_sort_combinations = z.union([
    types_field,
    types_sort_options
]);

export const types_sort = z.union([
    types_sort_combinations,
    z.array(types_sort_combinations)
]);

export const global_search_types_field_collapse = z.object({
    field: types_field,
    inner_hits: z.optional(z.union([
        global_search_types_inner_hits,
        z.array(global_search_types_inner_hits)
    ])),
    max_concurrent_group_searches: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of concurrent requests allowed to retrieve the inner_hits per group'
    })),
    get collapse() {
        return z.optional(z.lazy((): any => global_search_types_field_collapse));
    }
});

export const types_knn_search = z.object({
    field: types_field,
    query_vector: z.optional(types_query_vector),
    query_vector_builder: z.optional(types_query_vector_builder),
    k: z.optional(z.number().register(z.globalRegistry, {
        description: 'The final number of nearest neighbors to return as top hits'
    })),
    num_candidates: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of nearest neighbor candidates to consider per shard'
    })),
    visit_percentage: z.optional(z.number().register(z.globalRegistry, {
        description: 'The percentage of vectors to explore per shard while doing knn search with bbq_disk'
    })),
    boost: z.optional(z.number().register(z.globalRegistry, {
        description: 'Boost value to apply to kNN scores'
    })),
    filter: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    similarity: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum similarity for a vector to be considered a match'
    })),
    inner_hits: z.optional(global_search_types_inner_hits),
    rescore_vector: z.optional(types_rescore_vector)
});

export const types_aggregations_aggregation_container = z.object({
    get aggregations() {
        return z.optional(z.record(z.string(), z.lazy((): any => types_aggregations_aggregation_container)).register(z.globalRegistry, {
            description: 'Sub-aggregations for this aggregation.\nOnly applies to bucket aggregations.'
        }));
    },
    meta: z.optional(types_metadata)
}).and(z.lazy(() => z.object({
    get adjacency_matrix() {
        return z.optional(z.lazy((): any => types_aggregations_adjacency_matrix_aggregation));
    },
    get auto_date_histogram() {
        return z.optional(z.lazy((): any => types_aggregations_auto_date_histogram_aggregation));
    },
    get avg() {
        return z.optional(z.lazy((): any => types_aggregations_average_aggregation));
    },
    avg_bucket: z.optional(types_aggregations_average_bucket_aggregation),
    get boxplot() {
        return z.optional(z.lazy((): any => types_aggregations_boxplot_aggregation));
    },
    get bucket_script() {
        return z.optional(z.lazy((): any => types_aggregations_bucket_script_aggregation));
    },
    get bucket_selector() {
        return z.optional(z.lazy((): any => types_aggregations_bucket_selector_aggregation));
    },
    get bucket_sort() {
        return z.optional(z.lazy((): any => types_aggregations_bucket_sort_aggregation));
    },
    bucket_count_ks_test: z.optional(types_aggregations_bucket_ks_aggregation),
    bucket_correlation: z.optional(types_aggregations_bucket_correlation_aggregation),
    get cardinality() {
        return z.optional(z.lazy((): any => types_aggregations_cardinality_aggregation));
    },
    get cartesian_bounds() {
        return z.optional(z.lazy((): any => types_aggregations_cartesian_bounds_aggregation));
    },
    get cartesian_centroid() {
        return z.optional(z.lazy((): any => types_aggregations_cartesian_centroid_aggregation));
    },
    categorize_text: z.optional(types_aggregations_categorize_text_aggregation),
    change_point: z.optional(types_aggregations_change_point_aggregation),
    children: z.optional(types_aggregations_children_aggregation),
    get composite() {
        return z.optional(z.lazy((): any => types_aggregations_composite_aggregation));
    },
    cumulative_cardinality: z.optional(types_aggregations_cumulative_cardinality_aggregation),
    cumulative_sum: z.optional(types_aggregations_cumulative_sum_aggregation),
    get date_histogram() {
        return z.optional(z.lazy((): any => types_aggregations_date_histogram_aggregation));
    },
    date_range: z.optional(types_aggregations_date_range_aggregation),
    derivative: z.optional(types_aggregations_derivative_aggregation),
    get diversified_sampler() {
        return z.optional(z.lazy((): any => types_aggregations_diversified_sampler_aggregation));
    },
    get extended_stats() {
        return z.optional(z.lazy((): any => types_aggregations_extended_stats_aggregation));
    },
    extended_stats_bucket: z.optional(types_aggregations_extended_stats_bucket_aggregation),
    get frequent_item_sets() {
        return z.optional(z.lazy((): any => types_aggregations_frequent_item_sets_aggregation));
    },
    filter: z.optional(types_query_dsl_query_container),
    get filters() {
        return z.optional(z.lazy((): any => types_aggregations_filters_aggregation));
    },
    get geo_bounds() {
        return z.optional(z.lazy((): any => types_aggregations_geo_bounds_aggregation));
    },
    get geo_centroid() {
        return z.optional(z.lazy((): any => types_aggregations_geo_centroid_aggregation));
    },
    geo_distance: z.optional(types_aggregations_geo_distance_aggregation),
    geohash_grid: z.optional(types_aggregations_geo_hash_grid_aggregation),
    geo_line: z.optional(types_aggregations_geo_line_aggregation),
    geotile_grid: z.optional(types_aggregations_geo_tile_grid_aggregation),
    geohex_grid: z.optional(types_aggregations_geohex_grid_aggregation),
    global: z.optional(types_aggregations_global_aggregation),
    get histogram() {
        return z.optional(z.lazy((): any => types_aggregations_histogram_aggregation));
    },
    ip_range: z.optional(types_aggregations_ip_range_aggregation),
    ip_prefix: z.optional(types_aggregations_ip_prefix_aggregation),
    inference: z.optional(types_aggregations_inference_aggregation),
    line: z.optional(types_aggregations_geo_line_aggregation),
    matrix_stats: z.optional(types_aggregations_matrix_stats_aggregation),
    get max() {
        return z.optional(z.lazy((): any => types_aggregations_max_aggregation));
    },
    max_bucket: z.optional(types_aggregations_max_bucket_aggregation),
    get median_absolute_deviation() {
        return z.optional(z.lazy((): any => types_aggregations_median_absolute_deviation_aggregation));
    },
    get min() {
        return z.optional(z.lazy((): any => types_aggregations_min_aggregation));
    },
    min_bucket: z.optional(types_aggregations_min_bucket_aggregation),
    missing: z.optional(types_aggregations_missing_aggregation),
    moving_avg: z.optional(types_aggregations_moving_average_aggregation),
    moving_percentiles: z.optional(types_aggregations_moving_percentiles_aggregation),
    moving_fn: z.optional(types_aggregations_moving_function_aggregation),
    multi_terms: z.optional(types_aggregations_multi_terms_aggregation),
    nested: z.optional(types_aggregations_nested_aggregation),
    normalize: z.optional(types_aggregations_normalize_aggregation),
    parent: z.optional(types_aggregations_parent_aggregation),
    get percentile_ranks() {
        return z.optional(z.lazy((): any => types_aggregations_percentile_ranks_aggregation));
    },
    get percentiles() {
        return z.optional(z.lazy((): any => types_aggregations_percentiles_aggregation));
    },
    percentiles_bucket: z.optional(types_aggregations_percentiles_bucket_aggregation),
    get range() {
        return z.optional(z.lazy((): any => types_aggregations_range_aggregation));
    },
    rare_terms: z.optional(types_aggregations_rare_terms_aggregation),
    get rate() {
        return z.optional(z.lazy((): any => types_aggregations_rate_aggregation));
    },
    reverse_nested: z.optional(types_aggregations_reverse_nested_aggregation),
    random_sampler: z.optional(types_aggregations_random_sampler_aggregation),
    sampler: z.optional(types_aggregations_sampler_aggregation),
    get scripted_metric() {
        return z.optional(z.lazy((): any => types_aggregations_scripted_metric_aggregation));
    },
    serial_diff: z.optional(types_aggregations_serial_differencing_aggregation),
    get significant_terms() {
        return z.optional(z.lazy((): any => types_aggregations_significant_terms_aggregation));
    },
    get significant_text() {
        return z.optional(z.lazy((): any => types_aggregations_significant_text_aggregation));
    },
    get stats() {
        return z.optional(z.lazy((): any => types_aggregations_stats_aggregation));
    },
    stats_bucket: z.optional(types_aggregations_stats_bucket_aggregation),
    get string_stats() {
        return z.optional(z.lazy((): any => types_aggregations_string_stats_aggregation));
    },
    get sum() {
        return z.optional(z.lazy((): any => types_aggregations_sum_aggregation));
    },
    sum_bucket: z.optional(types_aggregations_sum_bucket_aggregation),
    get terms() {
        return z.optional(z.lazy((): any => types_aggregations_terms_aggregation));
    },
    time_series: z.optional(types_aggregations_time_series_aggregation),
    get top_hits() {
        return z.optional(z.lazy((): any => types_aggregations_top_hits_aggregation));
    },
    get t_test() {
        return z.optional(z.lazy((): any => types_aggregations_t_test_aggregation));
    },
    get top_metrics() {
        return z.optional(z.lazy((): any => types_aggregations_top_metrics_aggregation));
    },
    get value_count() {
        return z.optional(z.lazy((): any => types_aggregations_value_count_aggregation));
    },
    get weighted_avg() {
        return z.optional(z.lazy((): any => types_aggregations_weighted_average_aggregation));
    },
    get variable_width_histogram() {
        return z.optional(z.lazy((): any => types_aggregations_variable_width_histogram_aggregation));
    }
})));

export const types_aggregations_variable_width_histogram_aggregation = z.object({
    field: z.optional(types_field),
    buckets: z.optional(z.number().register(z.globalRegistry, {
        description: 'The target number of buckets.'
    })),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of buckets that the coordinating node will request from each shard.\nDefaults to `buckets * 50`.'
    })),
    initial_buffer: z.optional(z.number().register(z.globalRegistry, {
        description: 'Specifies the number of individual documents that will be stored in memory on a shard before the initial bucketing algorithm is run.\nDefaults to `min(10 * shard_size, 50000)`.'
    })),
    script: z.optional(types_script)
});

export const global_search_types_search_request_body = z.object({
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregation_container).register(z.globalRegistry, {
        description: 'Defines the aggregations that are run as part of the search request.'
    })),
    collapse: z.optional(global_search_types_field_collapse),
    explain: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the request returns detailed information about score computation as part of a hit.'
    })),
    ext: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'Configuration of search extensions defined by Elasticsearch plugins.'
    })),
    from: z.optional(z.number().register(z.globalRegistry, {
        description: 'The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
    })),
    highlight: z.optional(global_search_types_highlight),
    track_total_hits: z.optional(global_search_types_track_hits),
    indices_boost: z.optional(z.array(z.record(z.string(), z.number())).register(z.globalRegistry, {
        description: 'Boost the `_score` of documents from specified indices.\nThe boost value is the factor by which scores are multiplied.\nA boost value greater than `1.0` increases the score.\nA boost value between `0` and `1.0` decreases the score.'
    })),
    docvalue_fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: 'An array of wildcard (`*`) field patterns.\nThe request returns doc values for field names matching these patterns in the `hits.fields` property of the response.'
    })),
    knn: z.optional(z.union([
        types_knn_search,
        z.array(types_knn_search)
    ])),
    rank: z.optional(types_rank_container),
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum `_score` for matching documents.\nDocuments with a lower `_score` are not included in search results or results collected by aggregations.'
    })),
    post_filter: z.optional(types_query_dsl_query_container),
    profile: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to return detailed timing information about the execution of individual components in a search request.\nNOTE: This is a debugging tool and adds significant overhead to search execution.'
    })),
    query: z.optional(types_query_dsl_query_container),
    rescore: z.optional(z.union([
        global_search_types_rescore,
        z.array(global_search_types_rescore)
    ])),
    retriever: z.optional(types_retriever_container),
    script_fields: z.optional(z.record(z.string(), types_script_field).register(z.globalRegistry, {
        description: 'Retrieve a script evaluation (based on different fields) for each hit.'
    })),
    search_after: z.optional(types_sort_results),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of hits to return, which must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` property.'
    })),
    slice: z.optional(types_sliced_scroll),
    sort: z.optional(types_sort),
    _source: z.optional(global_search_types_source_config),
    fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: 'An array of wildcard (`*`) field patterns.\nThe request returns values for field names matching these patterns in the `hits.fields` property of the response.'
    })),
    suggest: z.optional(global_search_types_suggester),
    terminate_after: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this property to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this property for requests that target data streams with backing indices across multiple data tiers.\n\nIf set to `0` (default), the query does not terminate early.'
    })),
    timeout: z.optional(z.string().register(z.globalRegistry, {
        description: 'The period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.'
    })),
    track_scores: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, calculate and return document scores, even if the scores are not used for sorting.'
    })),
    version: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the request returns the document version as part of a hit.'
    })),
    seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the request returns sequence number and primary term of the last modification of each hit.'
    })),
    stored_fields: z.optional(types_fields),
    pit: z.optional(global_search_types_point_in_time_reference),
    runtime_mappings: z.optional(types_mapping_runtime_fields),
    stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'The stats groups to associate with the search.\nEach group maintains a statistics aggregation for its associated searches.\nYou can retrieve these stats using the indices stats API.'
    }))
});

export const types_script_source = z.union([
    z.string(),
    global_search_types_search_request_body
]);

export const types_aggregations_weighted_average_value = z.object({
    field: z.optional(types_field),
    missing: z.optional(z.number().register(z.globalRegistry, {
        description: 'A value or weight to use if the field is missing.'
    })),
    script: z.optional(types_script)
});

export const types_aggregations_weighted_average_aggregation = types_aggregations_aggregation.and(z.object({
    format: z.optional(z.string().register(z.globalRegistry, {
        description: 'A numeric response formatter.'
    })),
    value: z.optional(types_aggregations_weighted_average_value),
    value_type: z.optional(types_aggregations_value_type),
    weight: z.optional(types_aggregations_weighted_average_value)
}));

export const types_aggregations_formattable_metric_aggregation = z.lazy((): any => types_aggregations_metric_aggregation_base).and(z.object({
    format: z.optional(z.string())
}));

export const types_aggregations_metric_aggregation_base = z.object({
    field: z.optional(types_field),
    missing: z.optional(types_aggregations_missing),
    script: z.optional(types_script)
});

export const types_aggregations_value_count_aggregation = types_aggregations_formattable_metric_aggregation.and(z.record(z.string(), z.unknown()));

export const types_aggregations_top_metrics_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    metrics: z.optional(z.union([
        types_aggregations_top_metrics_value,
        z.array(types_aggregations_top_metrics_value)
    ])),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of top documents from which to return metrics.'
    })),
    sort: z.optional(types_sort)
}));

export const types_aggregations_test_population = z.object({
    field: types_field,
    script: z.optional(types_script),
    filter: z.optional(types_query_dsl_query_container)
});

export const types_query_dsl_script_query = types_query_dsl_query_base.and(z.object({
    script: types_script
}));

export const types_query_dsl_rule_query = types_query_dsl_query_base.and(z.object({
    organic: types_query_dsl_query_container,
    ruleset_ids: z.optional(z.union([
        types_id,
        z.array(types_id)
    ])),
    ruleset_id: z.optional(z.string()),
    match_criteria: z.record(z.string(), z.unknown())
}));

export const types_query_dsl_pinned_query = types_query_dsl_query_base.and(z.object({
    organic: types_query_dsl_query_container
}).and(z.object({
    ids: z.optional(z.array(types_id).register(z.globalRegistry, {
        description: 'Document IDs listed in the order they are to appear in results.\nRequired if `docs` is not specified.'
    })),
    docs: z.optional(z.array(types_query_dsl_pinned_doc).register(z.globalRegistry, {
        description: 'Documents listed in the order they are to appear in results.\nRequired if `ids` is not specified.'
    }))
})));

export const types_query_dsl_nested_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether to ignore an unmapped path and not return any documents instead of an error.'
    })),
    inner_hits: z.optional(global_search_types_inner_hits),
    path: types_field,
    query: types_query_dsl_query_container,
    score_mode: z.optional(types_query_dsl_child_score_mode)
}));

export const types_knn_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    query_vector: z.optional(types_query_vector),
    query_vector_builder: z.optional(types_query_vector_builder),
    num_candidates: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of nearest neighbor candidates to consider per shard'
    })),
    visit_percentage: z.optional(z.number().register(z.globalRegistry, {
        description: 'The percentage of vectors to explore per shard while doing knn search with bbq_disk'
    })),
    k: z.optional(z.number().register(z.globalRegistry, {
        description: 'The final number of nearest neighbors to return as top hits'
    })),
    filter: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    similarity: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum similarity for a vector to be considered a match'
    })),
    rescore_vector: z.optional(types_rescore_vector)
}));

export const types_query_dsl_intervals_match = z.object({
    analyzer: z.optional(z.string().register(z.globalRegistry, {
        description: 'Analyzer used to analyze terms in the query.'
    })),
    max_gaps: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of positions between the matching terms.\nTerms further apart than this are not considered matches.'
    })),
    ordered: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, matching terms must appear in their specified order.'
    })),
    query: z.string().register(z.globalRegistry, {
        description: 'Text you wish to find in the provided field.'
    }),
    use_field: z.optional(types_field),
    get filter() {
        return z.optional(z.lazy((): any => types_query_dsl_intervals_filter));
    }
});

export const types_query_dsl_intervals_container = z.object({
    get all_of() {
        return z.optional(z.lazy((): any => types_query_dsl_intervals_all_of));
    },
    get any_of() {
        return z.optional(z.lazy((): any => types_query_dsl_intervals_any_of));
    },
    fuzzy: z.optional(types_query_dsl_intervals_fuzzy),
    match: z.optional(types_query_dsl_intervals_match),
    prefix: z.optional(types_query_dsl_intervals_prefix),
    range: z.optional(types_query_dsl_intervals_range),
    regexp: z.optional(types_query_dsl_intervals_regexp),
    wildcard: z.optional(types_query_dsl_intervals_wildcard)
});

export const types_query_dsl_intervals_filter = z.object({
    after: z.optional(types_query_dsl_intervals_container),
    before: z.optional(types_query_dsl_intervals_container),
    contained_by: z.optional(types_query_dsl_intervals_container),
    containing: z.optional(types_query_dsl_intervals_container),
    not_contained_by: z.optional(types_query_dsl_intervals_container),
    not_containing: z.optional(types_query_dsl_intervals_container),
    not_overlapping: z.optional(types_query_dsl_intervals_container),
    overlapping: z.optional(types_query_dsl_intervals_container),
    script: z.optional(types_script)
});

export const types_query_dsl_intervals_any_of = z.object({
    intervals: z.array(types_query_dsl_intervals_container).register(z.globalRegistry, {
        description: 'An array of rules to match.'
    }),
    filter: z.optional(types_query_dsl_intervals_filter)
});

export const types_query_dsl_intervals_all_of = z.object({
    intervals: z.array(types_query_dsl_intervals_container).register(z.globalRegistry, {
        description: 'An array of rules to combine. All rules must produce a match in a document for the overall source to match.'
    }),
    max_gaps: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of positions between the matching terms.\nIntervals produced by the rules further apart than this are not considered matches.'
    })),
    ordered: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, intervals produced by the rules should appear in the order in which they are specified.'
    })),
    filter: z.optional(types_query_dsl_intervals_filter)
});

export const types_query_dsl_intervals_query = types_query_dsl_query_base.and(z.object({
    all_of: z.optional(types_query_dsl_intervals_all_of),
    any_of: z.optional(types_query_dsl_intervals_any_of),
    fuzzy: z.optional(types_query_dsl_intervals_fuzzy),
    match: z.optional(types_query_dsl_intervals_match),
    prefix: z.optional(types_query_dsl_intervals_prefix),
    range: z.optional(types_query_dsl_intervals_range),
    regexp: z.optional(types_query_dsl_intervals_regexp),
    wildcard: z.optional(types_query_dsl_intervals_wildcard)
}));

export const types_query_dsl_has_parent_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether to ignore an unmapped `parent_type` and not return any documents instead of an error.\nYou can use this parameter to query multiple indices that may not contain the `parent_type`.'
    })),
    inner_hits: z.optional(global_search_types_inner_hits),
    parent_type: types_relation_name,
    query: types_query_dsl_query_container,
    score: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the relevance score of a matching parent document is aggregated into its child documents.'
    }))
}));

export const types_query_dsl_has_child_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.'
    })),
    inner_hits: z.optional(global_search_types_inner_hits),
    max_children: z.optional(z.number().register(z.globalRegistry, {
        description: 'Maximum number of child documents that match the query allowed for a returned parent document.\nIf the parent document exceeds this limit, it is excluded from the search results.'
    })),
    min_children: z.optional(z.number().register(z.globalRegistry, {
        description: 'Minimum number of child documents that match the query required to match the query for a returned parent document.\nIf the parent document does not meet this limit, it is excluded from the search results.'
    })),
    query: types_query_dsl_query_container,
    score_mode: z.optional(types_query_dsl_child_score_mode),
    type: types_relation_name
}));

export const types_query_dsl_script_score_function = z.object({
    script: types_script
});

export const types_query_dsl_function_score_container = z.object({
    filter: z.optional(types_query_dsl_query_container),
    weight: z.optional(z.number())
}).and(z.object({
    exp: z.optional(types_query_dsl_decay_function),
    gauss: z.optional(types_query_dsl_decay_function),
    linear: z.optional(types_query_dsl_decay_function),
    field_value_factor: z.optional(types_query_dsl_field_value_factor_score_function),
    random_score: z.optional(types_query_dsl_random_score_function),
    script_score: z.optional(types_query_dsl_script_score_function)
}));

export const types_query_dsl_function_score_query = types_query_dsl_query_base.and(z.object({
    boost_mode: z.optional(types_query_dsl_function_boost_mode),
    functions: z.optional(z.array(types_query_dsl_function_score_container).register(z.globalRegistry, {
        description: 'One or more functions that compute a new score for each document returned by the query.'
    })),
    max_boost: z.optional(z.number().register(z.globalRegistry, {
        description: 'Restricts the new score to not exceed the provided limit.'
    })),
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: 'Excludes documents that do not meet the provided score threshold.'
    })),
    query: z.optional(types_query_dsl_query_container),
    score_mode: z.optional(types_query_dsl_function_score_mode)
}));

export const types_query_dsl_dis_max_query = types_query_dsl_query_base.and(z.object({
    queries: z.array(types_query_dsl_query_container).register(z.globalRegistry, {
        description: 'One or more query clauses.\nReturned documents must match one or more of these queries.\nIf a document matches multiple queries, Elasticsearch uses the highest relevance score.'
    }),
    tie_breaker: z.optional(z.number().register(z.globalRegistry, {
        description: 'Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses.'
    }))
}));

export const types_query_dsl_constant_score_query = types_query_dsl_query_base.and(z.object({
    filter: types_query_dsl_query_container
}));

export const types_query_dsl_boosting_query = types_query_dsl_query_base.and(z.object({
    negative_boost: z.number().register(z.globalRegistry, {
        description: 'Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query.'
    }),
    negative: types_query_dsl_query_container,
    positive: types_query_dsl_query_container
}));

export const types_query_dsl_bool_query = types_query_dsl_query_base.and(z.object({
    filter: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    minimum_should_match: z.optional(types_minimum_should_match),
    must: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    must_not: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ])),
    should: z.optional(z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ]))
}));

export const types_aggregations_t_test_aggregation = types_aggregations_aggregation.and(z.object({
    a: z.optional(types_aggregations_test_population),
    b: z.optional(types_aggregations_test_population),
    type: z.optional(types_aggregations_t_test_type)
}));

export const types_aggregations_top_hits_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    docvalue_fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: 'Fields for which to return doc values.'
    })),
    explain: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, returns detailed information about score computation as part of a hit.'
    })),
    fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: 'Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.'
    })),
    from: z.optional(z.number().register(z.globalRegistry, {
        description: 'Starting document offset.'
    })),
    highlight: z.optional(global_search_types_highlight),
    script_fields: z.optional(z.record(z.string(), types_script_field).register(z.globalRegistry, {
        description: 'Returns the result of one or more script evaluations for each hit.'
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of top matching hits to return per bucket.'
    })),
    sort: z.optional(types_sort),
    _source: z.optional(global_search_types_source_config),
    stored_fields: z.optional(types_fields),
    track_scores: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, calculates and returns document scores, even if the scores are not used for sorting.'
    })),
    version: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, returns document version as part of a hit.'
    })),
    seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, returns sequence number and primary term of the last modification of each hit.'
    }))
}));

export const types_aggregations_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    collect_mode: z.optional(types_aggregations_terms_aggregation_collect_mode),
    exclude: z.optional(types_aggregations_terms_exclude),
    execution_hint: z.optional(types_aggregations_terms_aggregation_execution_hint),
    field: z.optional(types_field),
    include: z.optional(types_aggregations_terms_include),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Only return values that are found in more than `min_doc_count` hits.'
    })),
    missing: z.optional(types_aggregations_missing),
    missing_order: z.optional(types_aggregations_missing_order),
    missing_bucket: z.optional(z.boolean()),
    value_type: z.optional(z.string().register(z.globalRegistry, {
        description: 'Coerced unmapped fields into the specified type.'
    })),
    order: z.optional(types_aggregations_aggregate_order),
    script: z.optional(types_script),
    shard_min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`.\nTerms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.'
    })),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.'
    })),
    show_term_doc_count_error: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to return the `doc_count_error_upper_bound`, which is an upper bound to the error on the `doc_count` returned by each shard.'
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of buckets returned out of the overall terms list.'
    })),
    format: z.optional(z.string())
}));

export const types_aggregations_sum_aggregation = z.lazy((): any => types_aggregations_format_metric_aggregation_base).and(z.record(z.string(), z.unknown()));

export const types_aggregations_format_metric_aggregation_base = types_aggregations_metric_aggregation_base.and(z.object({
    format: z.optional(z.string())
}));

export const types_aggregations_string_stats_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    show_distribution: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Shows the probability distribution for all characters.'
    }))
}));

export const types_aggregations_stats_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_significant_text_aggregation = types_aggregations_bucket_aggregation_base.and(z.lazy(() => z.object({
    background_filter: z.optional(types_query_dsl_query_container),
    chi_square: z.optional(types_aggregations_chi_square_heuristic),
    exclude: z.optional(types_aggregations_terms_exclude),
    execution_hint: z.optional(types_aggregations_terms_aggregation_execution_hint),
    field: z.optional(types_field),
    filter_duplicate_text: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether to out duplicate text to deal with noisy data.'
    })),
    gnd: z.optional(types_aggregations_google_normalized_distance_heuristic),
    include: z.optional(types_aggregations_terms_include),
    jlh: z.optional(types_empty_object),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Only return values that are found in more than `min_doc_count` hits.'
    })),
    mutual_information: z.optional(types_aggregations_mutual_information_heuristic),
    percentage: z.optional(types_aggregations_percentage_score_heuristic),
    get script_heuristic() {
        return z.optional(z.lazy((): any => types_aggregations_scripted_heuristic));
    },
    shard_min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Regulates the certainty a shard has if the values should actually be added to the candidate list or not with respect to the min_doc_count.\nValues will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.'
    })),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.'
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of buckets returned out of the overall terms list.'
    })),
    source_fields: z.optional(types_fields)
})));

export const types_aggregations_scripted_heuristic = z.object({
    script: types_script
});

export const types_aggregations_significant_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    background_filter: z.optional(types_query_dsl_query_container),
    chi_square: z.optional(types_aggregations_chi_square_heuristic),
    exclude: z.optional(types_aggregations_terms_exclude),
    execution_hint: z.optional(types_aggregations_terms_aggregation_execution_hint),
    field: z.optional(types_field),
    gnd: z.optional(types_aggregations_google_normalized_distance_heuristic),
    include: z.optional(types_aggregations_terms_include),
    jlh: z.optional(types_empty_object),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Only return terms that are found in more than `min_doc_count` hits.'
    })),
    mutual_information: z.optional(types_aggregations_mutual_information_heuristic),
    percentage: z.optional(types_aggregations_percentage_score_heuristic),
    script_heuristic: z.optional(types_aggregations_scripted_heuristic),
    p_value: z.optional(types_aggregations_p_value_heuristic),
    shard_min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`.\nTerms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.'
    })),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Can be used to control the volumes of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.'
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of buckets returned out of the overall terms list.'
    }))
}));

export const types_aggregations_scripted_metric_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    combine_script: z.optional(types_script),
    init_script: z.optional(types_script),
    map_script: z.optional(types_script),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'A global object with script parameters for `init`, `map` and `combine` scripts.\nIt is shared between the scripts.'
    })),
    reduce_script: z.optional(types_script)
}));

export const types_aggregations_rate_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    unit: z.optional(types_aggregations_calendar_interval),
    mode: z.optional(types_aggregations_rate_mode)
}));

export const types_aggregations_range_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: z.optional(types_field),
    missing: z.optional(z.number().register(z.globalRegistry, {
        description: 'The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.'
    })),
    ranges: z.optional(z.array(types_aggregations_aggregation_range).register(z.globalRegistry, {
        description: 'An array of ranges used to bucket documents.'
    })),
    script: z.optional(types_script),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array.'
    })),
    format: z.optional(z.string())
}));

export const types_aggregations_percentiles_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array.\nSet to `false` to disable this behavior.'
    })),
    percents: z.optional(z.union([
        z.number(),
        z.array(z.number())
    ])),
    hdr: z.optional(types_aggregations_hdr_method),
    tdigest: z.optional(types_aggregations_t_digest)
}));

export const types_aggregations_percentile_ranks_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array.\nSet to `false` to disable this behavior.'
    })),
    values: z.optional(z.union([
        z.array(z.number()),
        z.string(),
        z.null()
    ])),
    hdr: z.optional(types_aggregations_hdr_method),
    tdigest: z.optional(types_aggregations_t_digest)
}));

export const types_aggregations_min_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_median_absolute_deviation_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    compression: z.optional(z.number().register(z.globalRegistry, {
        description: 'Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.'
    })),
    execution_hint: z.optional(types_aggregations_t_digest_execution_hint)
}));

export const types_aggregations_max_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_histogram_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    extended_bounds: z.optional(types_aggregations_extended_boundsdouble),
    hard_bounds: z.optional(types_aggregations_extended_boundsdouble),
    field: z.optional(types_field),
    interval: z.optional(z.number().register(z.globalRegistry, {
        description: 'The interval for the buckets.\nMust be a positive decimal.'
    })),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Only returns buckets that have `min_doc_count` number of documents.\nBy default, the response will fill gaps in the histogram with empty buckets.'
    })),
    missing: z.optional(z.number().register(z.globalRegistry, {
        description: 'The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.'
    })),
    offset: z.optional(z.number().register(z.globalRegistry, {
        description: 'By default, the bucket keys start with 0 and then continue in even spaced steps of `interval`.\nThe bucket boundaries can be shifted by using the `offset` option.'
    })),
    order: z.optional(types_aggregations_aggregate_order),
    script: z.optional(types_script),
    format: z.optional(z.string()),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, returns buckets as a hash instead of an array, keyed by the bucket keys.'
    }))
}));

export const types_aggregations_geo_centroid_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    count: z.optional(z.number()),
    location: z.optional(types_geo_location)
}));

export const types_aggregations_geo_bounds_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    wrap_longitude: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Specifies whether the bounding box should be allowed to overlap the international date line.'
    }))
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_query_container = z.union([
    z.record(z.string(), types_query_dsl_query_container),
    z.array(types_query_dsl_query_container)
]);

export const types_aggregations_filters_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    filters: z.optional(types_aggregations_buckets_query_container),
    other_bucket: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to add a bucket to the response which will contain all documents that do not match any of the given filters.'
    })),
    other_bucket_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'The key with which the other bucket is returned.'
    })),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'By default, the named filters aggregation returns the buckets as an object.\nSet to `false` to return the buckets as an array of objects.'
    }))
}));

export const types_aggregations_frequent_item_sets_aggregation = z.object({
    fields: z.array(types_aggregations_frequent_item_sets_field).register(z.globalRegistry, {
        description: 'Fields to analyze.'
    }),
    minimum_set_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum size of one item set.'
    })),
    minimum_support: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum support of one item set.'
    })),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of top item sets to return.'
    })),
    filter: z.optional(types_query_dsl_query_container)
});

export const types_aggregations_extended_stats_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    sigma: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of standard deviations above/below the mean to display.'
    }))
}));

export const types_aggregations_diversified_sampler_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    execution_hint: z.optional(types_aggregations_sampler_aggregation_execution_hint),
    max_docs_per_value: z.optional(z.number().register(z.globalRegistry, {
        description: 'Limits how many documents are permitted per choice of de-duplicating value.'
    })),
    script: z.optional(types_script),
    shard_size: z.optional(z.number().register(z.globalRegistry, {
        description: 'Limits how many top-scoring documents are collected in the sample processed on each shard.'
    })),
    field: z.optional(types_field)
}));

export const types_aggregations_date_histogram_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    calendar_interval: z.optional(types_aggregations_calendar_interval),
    extended_bounds: z.optional(types_aggregations_extended_bounds_field_date_math),
    hard_bounds: z.optional(types_aggregations_extended_bounds_field_date_math),
    field: z.optional(types_field),
    fixed_interval: z.optional(types_duration),
    format: z.optional(z.string().register(z.globalRegistry, {
        description: 'The date format used to format `key_as_string` in the response.\nIf no `format` is specified, the first date format specified in the field mapping is used.'
    })),
    interval: z.optional(types_duration),
    min_doc_count: z.optional(z.number().register(z.globalRegistry, {
        description: 'Only returns buckets that have `min_doc_count` number of documents.\nBy default, all buckets between the first bucket that matches documents and the last one are returned.'
    })),
    missing: z.optional(types_date_time),
    offset: z.optional(types_duration),
    order: z.optional(types_aggregations_aggregate_order),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    script: z.optional(types_script),
    time_zone: z.optional(types_time_zone),
    keyed: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array.'
    }))
}));

export const types_aggregations_composite_geo_tile_grid_aggregation = z.lazy((): any => types_aggregations_composite_aggregation_base).and(z.object({
    precision: z.optional(z.number()),
    bounds: z.optional(types_geo_bounds)
}));

export const types_aggregations_composite_aggregation_base = z.object({
    field: z.optional(types_field),
    missing_bucket: z.optional(z.boolean()),
    missing_order: z.optional(types_aggregations_missing_order),
    script: z.optional(types_script),
    value_type: z.optional(types_aggregations_value_type),
    order: z.optional(types_sort_order)
});

export const types_aggregations_composite_date_histogram_aggregation = types_aggregations_composite_aggregation_base.and(z.object({
    format: z.optional(z.string()),
    calendar_interval: z.optional(types_duration_large),
    fixed_interval: z.optional(types_duration_large),
    offset: z.optional(types_duration),
    time_zone: z.optional(types_time_zone)
}));

export const types_aggregations_composite_histogram_aggregation = types_aggregations_composite_aggregation_base.and(z.object({
    interval: z.number()
}));

export const types_aggregations_composite_terms_aggregation = types_aggregations_composite_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_composite_aggregation_source = z.object({
    terms: z.optional(types_aggregations_composite_terms_aggregation),
    histogram: z.optional(types_aggregations_composite_histogram_aggregation),
    date_histogram: z.optional(types_aggregations_composite_date_histogram_aggregation),
    geotile_grid: z.optional(types_aggregations_composite_geo_tile_grid_aggregation)
});

export const types_aggregations_composite_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    after: z.optional(types_aggregations_composite_aggregate_key),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of composite buckets that should be returned.'
    })),
    sources: z.optional(z.array(z.record(z.string(), types_aggregations_composite_aggregation_source)).register(z.globalRegistry, {
        description: 'The value sources used to build composite buckets.\nKeys are returned in the order of the `sources` definition.'
    }))
}));

export const types_aggregations_cartesian_centroid_aggregation = types_aggregations_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_cartesian_bounds_aggregation = types_aggregations_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_cardinality_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    precision_threshold: z.optional(z.number().register(z.globalRegistry, {
        description: 'A unique count below which counts are expected to be close to accurate.\nThis allows to trade memory for accuracy.'
    })),
    rehash: z.optional(z.boolean()),
    execution_hint: z.optional(types_aggregations_cardinality_execution_mode)
}));

export const types_aggregations_bucket_sort_aggregation = types_aggregations_aggregation.and(z.object({
    from: z.optional(z.number().register(z.globalRegistry, {
        description: 'Buckets in positions prior to `from` will be truncated.'
    })),
    gap_policy: z.optional(types_aggregations_gap_policy),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of buckets to return.\nDefaults to all buckets of the parent aggregation.'
    })),
    sort: z.optional(types_sort)
}));

export const types_aggregations_bucket_selector_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    script: z.optional(types_script)
}));

export const types_aggregations_bucket_script_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    script: z.optional(types_script)
}));

export const types_aggregations_boxplot_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    compression: z.optional(z.number().register(z.globalRegistry, {
        description: 'Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.'
    })),
    execution_hint: z.optional(types_aggregations_t_digest_execution_hint)
}));

export const types_aggregations_average_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.string(), z.unknown()));

export const types_aggregations_auto_date_histogram_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    buckets: z.optional(z.number().register(z.globalRegistry, {
        description: 'The target number of buckets.'
    })),
    field: z.optional(types_field),
    format: z.optional(z.string().register(z.globalRegistry, {
        description: 'The date format used to format `key_as_string` in the response.\nIf no `format` is specified, the first date format specified in the field mapping is used.'
    })),
    minimum_interval: z.optional(types_aggregations_minimum_interval),
    missing: z.optional(types_date_time),
    offset: z.optional(z.string().register(z.globalRegistry, {
        description: 'Time zone specified as a ISO 8601 UTC offset.'
    })),
    params: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    script: z.optional(types_script),
    time_zone: z.optional(types_time_zone)
}));

export const types_aggregations_adjacency_matrix_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    filters: z.optional(z.record(z.string(), types_query_dsl_query_container).register(z.globalRegistry, {
        description: 'Filters used to create buckets.\nAt least one filter is required.'
    })),
    separator: z.optional(z.string().register(z.globalRegistry, {
        description: 'Separator used to concatenate filter names. Defaults to &.'
    }))
}));

export const types_mapping_icu_collation_property = z.lazy((): any => types_mapping_doc_values_property_base).and(z.object({
    type: z.enum(['icu_collation_keyword']),
    norms: z.optional(z.boolean()),
    index_options: z.optional(types_mapping_index_options),
    index: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Should the field be searchable?'
    })),
    null_value: z.optional(z.string().register(z.globalRegistry, {
        description: 'Accepts a string value which is substituted for any explicit null values. Defaults to null, which means the field is treated as missing.'
    })),
    rules: z.optional(z.string()),
    language: z.optional(z.string()),
    country: z.optional(z.string()),
    variant: z.optional(z.string()),
    strength: z.optional(types_analysis_icu_collation_strength),
    decomposition: z.optional(types_analysis_icu_collation_decomposition),
    alternate: z.optional(types_analysis_icu_collation_alternate),
    case_level: z.optional(z.boolean()),
    case_first: z.optional(types_analysis_icu_collation_case_first),
    numeric: z.optional(z.boolean()),
    variable_top: z.optional(z.string()),
    hiragana_quaternary_mode: z.optional(z.boolean())
}));

export const types_mapping_property = z.union([
    z.object({
        type: z.literal('binary')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_binary_property))),
    z.object({
        type: z.literal('boolean')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_boolean_property))),
    z.object({
        type: z.literal('{dynamic_type}')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_dynamic_property))),
    z.object({
        type: z.literal('join')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_join_property))),
    z.object({
        type: z.literal('keyword')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_keyword_property))),
    z.object({
        type: z.literal('match_only_text')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_match_only_text_property))),
    z.object({
        type: z.literal('percolator')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_percolator_property))),
    z.object({
        type: z.literal('rank_feature')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_rank_feature_property))),
    z.object({
        type: z.literal('rank_features')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_rank_features_property))),
    z.object({
        type: z.literal('search_as_you_type')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_search_as_you_type_property))),
    z.object({
        type: z.literal('text')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_text_property))),
    z.object({
        type: z.literal('version')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_version_property))),
    z.object({
        type: z.literal('wildcard')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_wildcard_property))),
    z.object({
        type: z.literal('date_nanos')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_date_nanos_property))),
    z.object({
        type: z.literal('date')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_date_property))),
    z.object({
        type: z.literal('aggregate_metric_double')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_aggregate_metric_double_property))),
    z.object({
        type: z.literal('dense_vector')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_dense_vector_property))),
    z.object({
        type: z.literal('flattened')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_flattened_property))),
    z.object({
        type: z.literal('nested')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_nested_property))),
    z.object({
        type: z.literal('object')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_object_property))),
    z.object({
        type: z.literal('passthrough')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_passthrough_object_property))),
    z.object({
        type: z.literal('rank_vectors')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_rank_vector_property))),
    z.object({
        type: z.literal('semantic_text')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_semantic_text_property))),
    z.object({
        type: z.literal('sparse_vector')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_sparse_vector_property))),
    z.object({
        type: z.literal('completion')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_completion_property))),
    z.object({
        type: z.literal('constant_keyword')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_constant_keyword_property))),
    z.object({
        type: z.literal('counted_keyword')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_counted_keyword_property))),
    z.object({
        type: z.literal('alias')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_field_alias_property))),
    z.object({
        type: z.literal('histogram')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_histogram_property))),
    z.object({
        type: z.literal('exponential_histogram')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_exponential_histogram_property))),
    z.object({
        type: z.literal('ip')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_ip_property))),
    z.object({
        type: z.literal('murmur3')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_murmur3_hash_property))),
    z.object({
        type: z.literal('token_count')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_token_count_property))),
    z.object({
        type: z.literal('geo_point')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_geo_point_property))),
    z.object({
        type: z.literal('geo_shape')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_geo_shape_property))),
    z.object({
        type: z.literal('point')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_point_property))),
    z.object({
        type: z.literal('shape')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_shape_property))),
    z.object({
        type: z.literal('byte')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_byte_number_property))),
    z.object({
        type: z.literal('double')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_double_number_property))),
    z.object({
        type: z.literal('float')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_float_number_property))),
    z.object({
        type: z.literal('half_float')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_half_float_number_property))),
    z.object({
        type: z.literal('integer')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_integer_number_property))),
    z.object({
        type: z.literal('long')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_long_number_property))),
    z.object({
        type: z.literal('scaled_float')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_scaled_float_number_property))),
    z.object({
        type: z.literal('short')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_short_number_property))),
    z.object({
        type: z.literal('unsigned_long')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_unsigned_long_number_property))),
    z.object({
        type: z.literal('date_range')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_date_range_property))),
    z.object({
        type: z.literal('double_range')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_double_range_property))),
    z.object({
        type: z.literal('float_range')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_float_range_property))),
    z.object({
        type: z.literal('integer_range')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_integer_range_property))),
    z.object({
        type: z.literal('ip_range')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_ip_range_property))),
    z.object({
        type: z.literal('long_range')
    }).and(z.lazy(() => z.lazy((): any => types_mapping_long_range_property))),
    z.object({
        type: z.literal('icu_collation_keyword')
    }).and(types_mapping_icu_collation_property)
]);

export const types_mapping_long_range_property = z.lazy((): any => types_mapping_range_property_base).and(z.object({
    type: z.enum(['long_range'])
}));

export const types_mapping_property_base = z.object({
    meta: z.optional(z.record(z.string(), z.string()).register(z.globalRegistry, {
        description: 'Metadata about the field.'
    })),
    properties: z.optional(z.record(z.string(), types_mapping_property)),
    ignore_above: z.optional(z.number()),
    dynamic: z.optional(types_mapping_dynamic_mapping),
    fields: z.optional(z.record(z.string(), types_mapping_property)),
    synthetic_source_keep: z.optional(types_mapping_synthetic_source_keep_enum)
});

export const types_mapping_core_property_base = types_mapping_property_base.and(z.object({
    copy_to: z.optional(types_fields),
    store: z.optional(z.boolean())
}));

export const types_mapping_doc_values_property_base = types_mapping_core_property_base.and(z.object({
    doc_values: z.optional(z.boolean())
}));

export const types_mapping_range_property_base = types_mapping_doc_values_property_base.and(z.object({
    boost: z.optional(z.number()),
    coerce: z.optional(z.boolean()),
    index: z.optional(z.boolean())
}));

export const types_mapping_ip_range_property = types_mapping_range_property_base.and(z.object({
    type: z.enum(['ip_range'])
}));

export const types_mapping_integer_range_property = types_mapping_range_property_base.and(z.object({
    type: z.enum(['integer_range'])
}));

export const types_mapping_float_range_property = types_mapping_range_property_base.and(z.object({
    type: z.enum(['float_range'])
}));

export const types_mapping_double_range_property = types_mapping_range_property_base.and(z.object({
    type: z.enum(['double_range'])
}));

export const types_mapping_date_range_property = types_mapping_range_property_base.and(z.object({
    format: z.optional(z.string()),
    type: z.enum(['date_range'])
}));

export const types_mapping_unsigned_long_number_property = z.lazy((): any => types_mapping_number_property_base).and(z.object({
    type: z.enum(['unsigned_long']),
    null_value: z.optional(types_ulong)
}));

export const types_mapping_number_property_base = types_mapping_doc_values_property_base.and(z.object({
    boost: z.optional(z.number()),
    coerce: z.optional(z.boolean()),
    ignore_malformed: z.optional(z.boolean()),
    index: z.optional(z.boolean()),
    on_script_error: z.optional(types_mapping_on_script_error),
    script: z.optional(types_script),
    time_series_metric: z.optional(types_mapping_time_series_metric_type),
    time_series_dimension: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.'
    }))
}));

export const types_mapping_short_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['short']),
    null_value: z.optional(types_short)
}));

export const types_mapping_scaled_float_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['scaled_float']),
    null_value: z.optional(z.number()),
    scaling_factor: z.optional(z.number())
}));

export const types_mapping_long_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['long']),
    null_value: z.optional(z.number())
}));

export const types_mapping_integer_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['integer']),
    null_value: z.optional(z.number())
}));

export const types_mapping_half_float_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['half_float']),
    null_value: z.optional(z.number())
}));

export const types_mapping_float_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['float']),
    null_value: z.optional(z.number())
}));

export const types_mapping_double_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['double']),
    null_value: z.optional(z.number())
}));

export const types_mapping_byte_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['byte']),
    null_value: z.optional(types_byte)
}));

/**
 * The `shape` data type facilitates the indexing of and searching with arbitrary `x, y` cartesian shapes such as
 * rectangles and polygons.
 */
export const types_mapping_shape_property = types_mapping_doc_values_property_base.and(z.object({
    coerce: z.optional(z.boolean()),
    ignore_malformed: z.optional(z.boolean()),
    ignore_z_value: z.optional(z.boolean()),
    orientation: z.optional(types_mapping_geo_orientation),
    type: z.enum(['shape'])
}));

export const types_mapping_point_property = types_mapping_doc_values_property_base.and(z.object({
    ignore_malformed: z.optional(z.boolean()),
    ignore_z_value: z.optional(z.boolean()),
    null_value: z.optional(z.string()),
    type: z.enum(['point'])
}));

/**
 * The `geo_shape` data type facilitates the indexing of and searching with arbitrary geo shapes such as rectangles
 * and polygons.
 */
export const types_mapping_geo_shape_property = types_mapping_doc_values_property_base.and(z.object({
    coerce: z.optional(z.boolean()),
    ignore_malformed: z.optional(z.boolean()),
    ignore_z_value: z.optional(z.boolean()),
    index: z.optional(z.boolean()),
    orientation: z.optional(types_mapping_geo_orientation),
    strategy: z.optional(types_mapping_geo_strategy),
    type: z.enum(['geo_shape'])
}));

export const types_mapping_geo_point_property = types_mapping_doc_values_property_base.and(z.object({
    ignore_malformed: z.optional(z.boolean()),
    ignore_z_value: z.optional(z.boolean()),
    null_value: z.optional(types_geo_location),
    index: z.optional(z.boolean()),
    on_script_error: z.optional(types_mapping_on_script_error),
    script: z.optional(types_script),
    type: z.enum(['geo_point']),
    time_series_metric: z.optional(types_mapping_geo_point_metric_type)
}));

export const types_mapping_token_count_property = types_mapping_doc_values_property_base.and(z.object({
    analyzer: z.optional(z.string()),
    boost: z.optional(z.number()),
    index: z.optional(z.boolean()),
    null_value: z.optional(z.number()),
    enable_position_increments: z.optional(z.boolean()),
    type: z.enum(['token_count'])
}));

export const types_mapping_murmur3_hash_property = types_mapping_doc_values_property_base.and(z.object({
    type: z.enum(['murmur3'])
}));

export const types_mapping_ip_property = types_mapping_doc_values_property_base.and(z.object({
    boost: z.optional(z.number()),
    index: z.optional(z.boolean()),
    ignore_malformed: z.optional(z.boolean()),
    null_value: z.optional(z.string()),
    on_script_error: z.optional(types_mapping_on_script_error),
    script: z.optional(types_script),
    time_series_dimension: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.'
    })),
    type: z.enum(['ip'])
}));

export const types_mapping_exponential_histogram_property = types_mapping_property_base.and(z.object({
    time_series_metric: z.optional(types_mapping_time_series_metric_type),
    type: z.enum(['exponential_histogram'])
}));

export const types_mapping_histogram_property = types_mapping_property_base.and(z.object({
    ignore_malformed: z.optional(z.boolean()),
    time_series_metric: z.optional(types_mapping_time_series_metric_type),
    type: z.enum(['histogram'])
}));

export const types_mapping_field_alias_property = types_mapping_property_base.and(z.object({
    path: z.optional(types_field),
    type: z.enum(['alias'])
}));

export const types_mapping_counted_keyword_property = types_mapping_property_base.and(z.object({
    type: z.enum(['counted_keyword']),
    index: z.optional(z.boolean())
}));

export const types_mapping_constant_keyword_property = types_mapping_property_base.and(z.object({
    value: z.optional(z.record(z.string(), z.unknown())),
    type: z.enum(['constant_keyword'])
}));

export const types_mapping_completion_property = types_mapping_doc_values_property_base.and(z.object({
    analyzer: z.optional(z.string()),
    contexts: z.optional(z.array(types_mapping_suggest_context)),
    max_input_length: z.optional(z.number()),
    preserve_position_increments: z.optional(z.boolean()),
    preserve_separators: z.optional(z.boolean()),
    search_analyzer: z.optional(z.string()),
    type: z.enum(['completion'])
}));

export const types_mapping_sparse_vector_property = types_mapping_property_base.and(z.object({
    store: z.optional(z.boolean()),
    type: z.enum(['sparse_vector']),
    index_options: z.optional(types_mapping_sparse_vector_index_options)
}));

export const types_mapping_semantic_text_property = z.object({
    type: z.enum(['semantic_text']),
    meta: z.optional(z.record(z.string(), z.string())),
    inference_id: z.optional(types_id),
    search_inference_id: z.optional(types_id),
    index_options: z.optional(types_mapping_semantic_text_index_options),
    chunking_settings: z.optional(z.union([
        types_mapping_chunking_settings,
        z.string(),
        z.null()
    ])),
    fields: z.optional(z.record(z.string(), types_mapping_property).register(z.globalRegistry, {
        description: 'Multi-fields allow the same string value to be indexed in multiple ways for different purposes, such as one\nfield for search and a multi-field for sorting and aggregations, or the same string value analyzed by different analyzers.'
    }))
});

/**
 * Technical preview
 */
export const types_mapping_rank_vector_property = types_mapping_property_base.and(z.object({
    type: z.enum(['rank_vectors']),
    element_type: z.optional(types_mapping_rank_vector_element_type),
    dims: z.optional(z.number())
}));

export const types_mapping_passthrough_object_property = types_mapping_core_property_base.and(z.object({
    type: z.optional(z.enum(['passthrough'])),
    enabled: z.optional(z.boolean()),
    priority: z.optional(z.number()),
    time_series_dimension: z.optional(z.boolean())
}));

export const types_mapping_object_property = types_mapping_core_property_base.and(z.object({
    enabled: z.optional(z.boolean()),
    subobjects: z.optional(types_mapping_subobjects),
    type: z.optional(z.enum(['object']))
}));

export const types_mapping_nested_property = types_mapping_core_property_base.and(z.object({
    enabled: z.optional(z.boolean()),
    include_in_parent: z.optional(z.boolean()),
    include_in_root: z.optional(z.boolean()),
    type: z.enum(['nested'])
}));

export const types_mapping_flattened_property = types_mapping_property_base.and(z.object({
    boost: z.optional(z.number()),
    depth_limit: z.optional(z.number()),
    doc_values: z.optional(z.boolean()),
    eager_global_ordinals: z.optional(z.boolean()),
    index: z.optional(z.boolean()),
    index_options: z.optional(types_mapping_index_options),
    null_value: z.optional(z.string()),
    similarity: z.optional(z.string()),
    split_queries_on_whitespace: z.optional(z.boolean()),
    time_series_dimensions: z.optional(z.array(z.string())),
    type: z.enum(['flattened'])
}));

export const types_mapping_dense_vector_property = types_mapping_property_base.and(z.object({
    type: z.enum(['dense_vector']),
    dims: z.optional(z.number().register(z.globalRegistry, {
        description: 'Number of vector dimensions. Can\'t exceed `4096`. If `dims` is not specified, it will be set to the length of\nthe first vector added to the field.'
    })),
    element_type: z.optional(types_mapping_dense_vector_element_type),
    index: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, you can search this field using the kNN search API.'
    })),
    index_options: z.optional(types_mapping_dense_vector_index_options),
    similarity: z.optional(types_mapping_dense_vector_similarity)
}));

export const types_mapping_aggregate_metric_double_property = types_mapping_property_base.and(z.object({
    type: z.enum(['aggregate_metric_double']),
    default_metric: z.string(),
    ignore_malformed: z.optional(z.boolean()),
    metrics: z.array(z.string()),
    time_series_metric: z.optional(types_mapping_time_series_metric_type)
}));

export const types_mapping_date_property = types_mapping_doc_values_property_base.and(z.object({
    boost: z.optional(z.number()),
    fielddata: z.optional(indices_types_numeric_fielddata),
    format: z.optional(z.string()),
    ignore_malformed: z.optional(z.boolean()),
    index: z.optional(z.boolean()),
    script: z.optional(types_script),
    on_script_error: z.optional(types_mapping_on_script_error),
    null_value: z.optional(types_date_time),
    precision_step: z.optional(z.number()),
    locale: z.optional(z.string()),
    type: z.enum(['date'])
}));

export const types_mapping_date_nanos_property = types_mapping_doc_values_property_base.and(z.object({
    boost: z.optional(z.number()),
    format: z.optional(z.string()),
    ignore_malformed: z.optional(z.boolean()),
    index: z.optional(z.boolean()),
    script: z.optional(types_script),
    on_script_error: z.optional(types_mapping_on_script_error),
    null_value: z.optional(types_date_time),
    precision_step: z.optional(z.number()),
    type: z.enum(['date_nanos'])
}));

export const types_mapping_wildcard_property = types_mapping_doc_values_property_base.and(z.object({
    type: z.enum(['wildcard']),
    null_value: z.optional(z.string())
}));

export const types_mapping_version_property = types_mapping_doc_values_property_base.and(z.object({
    type: z.enum(['version'])
}));

export const types_mapping_text_property = types_mapping_core_property_base.and(z.object({
    analyzer: z.optional(z.string()),
    boost: z.optional(z.number()),
    eager_global_ordinals: z.optional(z.boolean()),
    fielddata: z.optional(z.boolean()),
    fielddata_frequency_filter: z.optional(indices_types_fielddata_frequency_filter),
    index: z.optional(z.boolean()),
    index_options: z.optional(types_mapping_index_options),
    index_phrases: z.optional(z.boolean()),
    index_prefixes: z.optional(z.union([
        types_mapping_text_index_prefixes,
        z.string(),
        z.null()
    ])),
    norms: z.optional(z.boolean()),
    position_increment_gap: z.optional(z.number()),
    search_analyzer: z.optional(z.string()),
    search_quote_analyzer: z.optional(z.string()),
    similarity: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    term_vector: z.optional(types_mapping_term_vector_option),
    type: z.enum(['text'])
}));

export const types_mapping_search_as_you_type_property = types_mapping_core_property_base.and(z.object({
    analyzer: z.optional(z.string()),
    index: z.optional(z.boolean()),
    index_options: z.optional(types_mapping_index_options),
    max_shingle_size: z.optional(z.number()),
    norms: z.optional(z.boolean()),
    search_analyzer: z.optional(z.string()),
    search_quote_analyzer: z.optional(z.string()),
    similarity: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    term_vector: z.optional(types_mapping_term_vector_option),
    type: z.enum(['search_as_you_type'])
}));

export const types_mapping_rank_features_property = types_mapping_property_base.and(z.object({
    positive_score_impact: z.optional(z.boolean()),
    type: z.enum(['rank_features'])
}));

export const types_mapping_rank_feature_property = types_mapping_property_base.and(z.object({
    positive_score_impact: z.optional(z.boolean()),
    type: z.enum(['rank_feature'])
}));

export const types_mapping_percolator_property = types_mapping_property_base.and(z.object({
    type: z.enum(['percolator'])
}));

/**
 * A variant of text that trades scoring and efficiency of positional queries for space efficiency. This field
 * effectively stores data the same way as a text field that only indexes documents (index_options: docs) and
 * disables norms (norms: false). Term queries perform as fast if not faster as on text fields, however queries
 * that need positions such as the match_phrase query perform slower as they need to look at the _source document
 * to verify whether a phrase matches. All queries return constant scores that are equal to 1.0.
 */
export const types_mapping_match_only_text_property = z.object({
    type: z.enum(['match_only_text']),
    fields: z.optional(z.record(z.string(), types_mapping_property).register(z.globalRegistry, {
        description: 'Multi-fields allow the same string value to be indexed in multiple ways for different purposes, such as one\nfield for search and a multi-field for sorting and aggregations, or the same string value analyzed by different analyzers.'
    })),
    meta: z.optional(z.record(z.string(), z.string()).register(z.globalRegistry, {
        description: 'Metadata about the field.'
    })),
    copy_to: z.optional(types_fields)
}).register(z.globalRegistry, {
    description: 'A variant of text that trades scoring and efficiency of positional queries for space efficiency. This field\neffectively stores data the same way as a text field that only indexes documents (index_options: docs) and\ndisables norms (norms: false). Term queries perform as fast if not faster as on text fields, however queries\nthat need positions such as the match_phrase query perform slower as they need to look at the _source document\nto verify whether a phrase matches. All queries return constant scores that are equal to 1.0.'
});

export const types_mapping_keyword_property = types_mapping_doc_values_property_base.and(z.object({
    boost: z.optional(z.number()),
    eager_global_ordinals: z.optional(z.boolean()),
    index: z.optional(z.boolean()),
    index_options: z.optional(types_mapping_index_options),
    script: z.optional(types_script),
    on_script_error: z.optional(types_mapping_on_script_error),
    normalizer: z.optional(z.string()),
    norms: z.optional(z.boolean()),
    null_value: z.optional(z.string()),
    similarity: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    split_queries_on_whitespace: z.optional(z.boolean()),
    time_series_dimension: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.'
    })),
    type: z.enum(['keyword'])
}));

export const types_mapping_join_property = types_mapping_property_base.and(z.object({
    relations: z.optional(z.record(z.string(), z.union([
        types_relation_name,
        z.array(types_relation_name)
    ]))),
    eager_global_ordinals: z.optional(z.boolean()),
    type: z.enum(['join'])
}));

export const types_mapping_dynamic_property = types_mapping_doc_values_property_base.and(z.object({
    type: z.enum(['{dynamic_type}']),
    enabled: z.optional(z.boolean()),
    null_value: z.optional(types_field_value),
    boost: z.optional(z.number()),
    coerce: z.optional(z.boolean()),
    script: z.optional(types_script),
    on_script_error: z.optional(types_mapping_on_script_error),
    ignore_malformed: z.optional(z.boolean()),
    time_series_metric: z.optional(types_mapping_time_series_metric_type),
    analyzer: z.optional(z.string()),
    eager_global_ordinals: z.optional(z.boolean()),
    index: z.optional(z.boolean()),
    index_options: z.optional(types_mapping_index_options),
    index_phrases: z.optional(z.boolean()),
    index_prefixes: z.optional(z.union([
        types_mapping_text_index_prefixes,
        z.string(),
        z.null()
    ])),
    norms: z.optional(z.boolean()),
    position_increment_gap: z.optional(z.number()),
    search_analyzer: z.optional(z.string()),
    search_quote_analyzer: z.optional(z.string()),
    term_vector: z.optional(types_mapping_term_vector_option),
    format: z.optional(z.string()),
    precision_step: z.optional(z.number()),
    locale: z.optional(z.string())
}));

export const types_mapping_boolean_property = types_mapping_doc_values_property_base.and(z.object({
    boost: z.optional(z.number()),
    fielddata: z.optional(indices_types_numeric_fielddata),
    index: z.optional(z.boolean()),
    null_value: z.optional(z.boolean()),
    ignore_malformed: z.optional(z.boolean()),
    script: z.optional(types_script),
    on_script_error: z.optional(types_mapping_on_script_error),
    time_series_dimension: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.'
    })),
    type: z.enum(['boolean'])
}));

export const types_mapping_binary_property = types_mapping_doc_values_property_base.and(z.object({
    type: z.enum(['binary'])
}));

export const types_mapping_dynamic_template = z.object({
    match: z.optional(z.union([
        z.string(),
        z.array(z.string())
    ])),
    path_match: z.optional(z.union([
        z.string(),
        z.array(z.string())
    ])),
    unmatch: z.optional(z.union([
        z.string(),
        z.array(z.string())
    ])),
    path_unmatch: z.optional(z.union([
        z.string(),
        z.array(z.string())
    ])),
    match_mapping_type: z.optional(z.union([
        z.string(),
        z.array(z.string())
    ])),
    unmatch_mapping_type: z.optional(z.union([
        z.string(),
        z.array(z.string())
    ])),
    match_pattern: z.optional(types_mapping_match_type)
}).and(z.object({
    mapping: z.optional(types_mapping_property),
    runtime: z.optional(types_mapping_runtime_field)
}));

export const types_mapping_type_mapping = z.object({
    all_field: z.optional(types_mapping_all_field),
    date_detection: z.optional(z.boolean()),
    dynamic: z.optional(types_mapping_dynamic_mapping),
    dynamic_date_formats: z.optional(z.array(z.string())),
    dynamic_templates: z.optional(z.array(z.record(z.string(), types_mapping_dynamic_template))),
    _field_names: z.optional(types_mapping_field_names_field),
    index_field: z.optional(types_mapping_index_field),
    _meta: z.optional(types_metadata),
    numeric_detection: z.optional(z.boolean()),
    properties: z.optional(z.record(z.string(), types_mapping_property)),
    _routing: z.optional(types_mapping_routing_field),
    _size: z.optional(types_mapping_size_field),
    _source: z.optional(types_mapping_source_field),
    runtime: z.optional(z.record(z.string(), types_mapping_runtime_field)),
    enabled: z.optional(z.boolean()),
    subobjects: z.optional(types_mapping_subobjects),
    _data_stream_timestamp: z.optional(types_mapping_data_stream_timestamp)
});

export const indices_types_settings_similarity_scripted = z.object({
    type: z.enum(['scripted']),
    script: types_script,
    weight_script: z.optional(types_script)
});

export const indices_types_settings_similarity = z.union([
    z.object({
        type: z.literal('BM25')
    }).and(indices_types_settings_similarity_bm25),
    z.object({
        type: z.literal('boolean')
    }).and(indices_types_settings_similarity_boolean),
    z.object({
        type: z.literal('DFI')
    }).and(indices_types_settings_similarity_dfi),
    z.object({
        type: z.literal('DFR')
    }).and(indices_types_settings_similarity_dfr),
    z.object({
        type: z.literal('IB')
    }).and(indices_types_settings_similarity_ib),
    z.object({
        type: z.literal('LMDirichlet')
    }).and(indices_types_settings_similarity_lmd),
    z.object({
        type: z.literal('LMJelinekMercer')
    }).and(indices_types_settings_similarity_lmj),
    z.object({
        type: z.literal('scripted')
    }).and(indices_types_settings_similarity_scripted)
]);

export const types_analysis_predicate_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['predicate_token_filter']),
    script: types_script
}));

export const types_analysis_condition_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['condition']),
    filter: z.array(z.string()).register(z.globalRegistry, {
        description: 'Array of token filters. If a token matches the predicate script in the `script` parameter, these filters are applied to the token in the order provided.'
    }),
    script: types_script
}));

export const types_analysis_token_filter_definition = z.union([
    z.object({
        type: z.literal('apostrophe')
    }).and(types_analysis_apostrophe_token_filter),
    z.object({
        type: z.literal('arabic_stem')
    }).and(types_analysis_arabic_stem_token_filter),
    z.object({
        type: z.literal('arabic_normalization')
    }).and(types_analysis_arabic_normalization_token_filter),
    z.object({
        type: z.literal('asciifolding')
    }).and(types_analysis_ascii_folding_token_filter),
    z.object({
        type: z.literal('bengali_normalization')
    }).and(types_analysis_bengali_normalization_token_filter),
    z.object({
        type: z.literal('brazilian_stem')
    }).and(types_analysis_brazilian_stem_token_filter),
    z.object({
        type: z.literal('cjk_bigram')
    }).and(types_analysis_cjk_bigram_token_filter),
    z.object({
        type: z.literal('cjk_width')
    }).and(types_analysis_cjk_width_token_filter),
    z.object({
        type: z.literal('classic')
    }).and(types_analysis_classic_token_filter),
    z.object({
        type: z.literal('common_grams')
    }).and(types_analysis_common_grams_token_filter),
    z.object({
        type: z.literal('condition')
    }).and(types_analysis_condition_token_filter),
    z.object({
        type: z.literal('czech_stem')
    }).and(types_analysis_czech_stem_token_filter),
    z.object({
        type: z.literal('decimal_digit')
    }).and(types_analysis_decimal_digit_token_filter),
    z.object({
        type: z.literal('delimited_payload')
    }).and(types_analysis_delimited_payload_token_filter),
    z.object({
        type: z.literal('dutch_stem')
    }).and(types_analysis_dutch_stem_token_filter),
    z.object({
        type: z.literal('edge_ngram')
    }).and(types_analysis_edge_n_gram_token_filter),
    z.object({
        type: z.literal('elision')
    }).and(types_analysis_elision_token_filter),
    z.object({
        type: z.literal('fingerprint')
    }).and(types_analysis_fingerprint_token_filter),
    z.object({
        type: z.literal('flatten_graph')
    }).and(types_analysis_flatten_graph_token_filter),
    z.object({
        type: z.literal('french_stem')
    }).and(types_analysis_french_stem_token_filter),
    z.object({
        type: z.literal('german_normalization')
    }).and(types_analysis_german_normalization_token_filter),
    z.object({
        type: z.literal('german_stem')
    }).and(types_analysis_german_stem_token_filter),
    z.object({
        type: z.literal('hindi_normalization')
    }).and(types_analysis_hindi_normalization_token_filter),
    z.object({
        type: z.literal('hunspell')
    }).and(types_analysis_hunspell_token_filter),
    z.object({
        type: z.literal('hyphenation_decompounder')
    }).and(types_analysis_hyphenation_decompounder_token_filter),
    z.object({
        type: z.literal('indic_normalization')
    }).and(types_analysis_indic_normalization_token_filter),
    z.object({
        type: z.literal('keep_types')
    }).and(types_analysis_keep_types_token_filter),
    z.object({
        type: z.literal('keep')
    }).and(types_analysis_keep_words_token_filter),
    z.object({
        type: z.literal('keyword_marker')
    }).and(types_analysis_keyword_marker_token_filter),
    z.object({
        type: z.literal('keyword_repeat')
    }).and(types_analysis_keyword_repeat_token_filter),
    z.object({
        type: z.literal('kstem')
    }).and(types_analysis_k_stem_token_filter),
    z.object({
        type: z.literal('length')
    }).and(types_analysis_length_token_filter),
    z.object({
        type: z.literal('limit')
    }).and(types_analysis_limit_token_count_token_filter),
    z.object({
        type: z.literal('lowercase')
    }).and(types_analysis_lowercase_token_filter),
    z.object({
        type: z.literal('min_hash')
    }).and(types_analysis_min_hash_token_filter),
    z.object({
        type: z.literal('multiplexer')
    }).and(types_analysis_multiplexer_token_filter),
    z.object({
        type: z.literal('ngram')
    }).and(types_analysis_n_gram_token_filter),
    z.object({
        type: z.literal('nori_part_of_speech')
    }).and(types_analysis_nori_part_of_speech_token_filter),
    z.object({
        type: z.literal('pattern_capture')
    }).and(types_analysis_pattern_capture_token_filter),
    z.object({
        type: z.literal('pattern_replace')
    }).and(types_analysis_pattern_replace_token_filter),
    z.object({
        type: z.literal('persian_normalization')
    }).and(types_analysis_persian_normalization_token_filter),
    z.object({
        type: z.literal('persian_stem')
    }).and(types_analysis_persian_stem_token_filter),
    z.object({
        type: z.literal('porter_stem')
    }).and(types_analysis_porter_stem_token_filter),
    z.object({
        type: z.literal('predicate_token_filter')
    }).and(types_analysis_predicate_token_filter),
    z.object({
        type: z.literal('remove_duplicates')
    }).and(types_analysis_remove_duplicates_token_filter),
    z.object({
        type: z.literal('reverse')
    }).and(types_analysis_reverse_token_filter),
    z.object({
        type: z.literal('russian_stem')
    }).and(types_analysis_russian_stem_token_filter),
    z.object({
        type: z.literal('scandinavian_folding')
    }).and(types_analysis_scandinavian_folding_token_filter),
    z.object({
        type: z.literal('scandinavian_normalization')
    }).and(types_analysis_scandinavian_normalization_token_filter),
    z.object({
        type: z.literal('serbian_normalization')
    }).and(types_analysis_serbian_normalization_token_filter),
    z.object({
        type: z.literal('shingle')
    }).and(types_analysis_shingle_token_filter),
    z.object({
        type: z.literal('snowball')
    }).and(types_analysis_snowball_token_filter),
    z.object({
        type: z.literal('sorani_normalization')
    }).and(types_analysis_sorani_normalization_token_filter),
    z.object({
        type: z.literal('stemmer_override')
    }).and(types_analysis_stemmer_override_token_filter),
    z.object({
        type: z.literal('stemmer')
    }).and(types_analysis_stemmer_token_filter),
    z.object({
        type: z.literal('stop')
    }).and(types_analysis_stop_token_filter),
    z.object({
        type: z.literal('synonym_graph')
    }).and(types_analysis_synonym_graph_token_filter),
    z.object({
        type: z.literal('synonym')
    }).and(types_analysis_synonym_token_filter),
    z.object({
        type: z.literal('trim')
    }).and(types_analysis_trim_token_filter),
    z.object({
        type: z.literal('truncate')
    }).and(types_analysis_truncate_token_filter),
    z.object({
        type: z.literal('unique')
    }).and(types_analysis_unique_token_filter),
    z.object({
        type: z.literal('uppercase')
    }).and(types_analysis_uppercase_token_filter),
    z.object({
        type: z.literal('word_delimiter_graph')
    }).and(types_analysis_word_delimiter_graph_token_filter),
    z.object({
        type: z.literal('word_delimiter')
    }).and(types_analysis_word_delimiter_token_filter),
    z.object({
        type: z.literal('ja_stop')
    }).and(types_analysis_ja_stop_token_filter),
    z.object({
        type: z.literal('kuromoji_stemmer')
    }).and(types_analysis_kuromoji_stemmer_token_filter),
    z.object({
        type: z.literal('kuromoji_readingform')
    }).and(types_analysis_kuromoji_reading_form_token_filter),
    z.object({
        type: z.literal('kuromoji_part_of_speech')
    }).and(types_analysis_kuromoji_part_of_speech_token_filter),
    z.object({
        type: z.literal('icu_collation')
    }).and(types_analysis_icu_collation_token_filter),
    z.object({
        type: z.literal('icu_folding')
    }).and(types_analysis_icu_folding_token_filter),
    z.object({
        type: z.literal('icu_normalizer')
    }).and(types_analysis_icu_normalization_token_filter),
    z.object({
        type: z.literal('icu_transform')
    }).and(types_analysis_icu_transform_token_filter),
    z.object({
        type: z.literal('phonetic')
    }).and(types_analysis_phonetic_token_filter),
    z.object({
        type: z.literal('dictionary_decompounder')
    }).and(types_analysis_dictionary_decompounder_token_filter)
]);

export const types_analysis_token_filter = z.union([
    z.string(),
    types_analysis_token_filter_definition
]);

export const indices_types_index_settings_analysis = z.object({
    analyzer: z.optional(z.record(z.string(), types_analysis_analyzer)),
    char_filter: z.optional(z.record(z.string(), types_analysis_char_filter)),
    filter: z.optional(z.record(z.string(), types_analysis_token_filter)),
    normalizer: z.optional(z.record(z.string(), types_analysis_normalizer)),
    tokenizer: z.optional(z.record(z.string(), types_analysis_tokenizer))
});

export const indices_types_index_settings = z.object({
    get index() {
        return z.optional(z.lazy((): any => indices_types_index_settings));
    },
    mode: z.optional(z.string()),
    routing_path: z.optional(z.union([
        z.string(),
        z.array(z.string())
    ])),
    soft_deletes: z.optional(indices_types_soft_deletes),
    sort: z.optional(indices_types_index_segment_sort),
    number_of_shards: z.optional(z.union([
        z.number(),
        z.string()
    ])),
    number_of_replicas: z.optional(z.union([
        z.number(),
        z.string()
    ])),
    number_of_routing_shards: z.optional(z.number()),
    check_on_startup: z.optional(indices_types_index_check_on_startup),
    codec: z.optional(z.string()),
    routing_partition_size: z.optional(spec_utils_stringifiedinteger),
    load_fixed_bitset_filters_eagerly: z.optional(z.boolean()),
    hidden: z.optional(z.union([
        z.boolean(),
        z.string()
    ])),
    auto_expand_replicas: z.optional(z.union([
        z.string(),
        spec_utils_null_value
    ])),
    merge: z.optional(indices_types_merge),
    search: z.optional(indices_types_settings_search),
    refresh_interval: z.optional(types_duration),
    max_result_window: z.optional(z.number()),
    max_inner_result_window: z.optional(z.number()),
    max_rescore_window: z.optional(z.number()),
    max_docvalue_fields_search: z.optional(z.number()),
    max_script_fields: z.optional(z.number()),
    max_ngram_diff: z.optional(z.number()),
    max_shingle_diff: z.optional(z.number()),
    blocks: z.optional(indices_types_index_setting_blocks),
    max_refresh_listeners: z.optional(z.number()),
    analyze: z.optional(indices_types_settings_analyze),
    highlight: z.optional(indices_types_settings_highlight),
    max_terms_count: z.optional(z.number()),
    max_regex_length: z.optional(z.number()),
    routing: z.optional(indices_types_index_routing),
    gc_deletes: z.optional(types_duration),
    default_pipeline: z.optional(types_pipeline_name),
    final_pipeline: z.optional(types_pipeline_name),
    lifecycle: z.optional(indices_types_index_settings_lifecycle),
    provided_name: z.optional(types_name),
    creation_date: z.optional(spec_utils_stringified_epoch_time_unit_millis),
    creation_date_string: z.optional(types_date_time),
    uuid: z.optional(types_uuid),
    version: z.optional(indices_types_index_versioning),
    verified_before_close: z.optional(z.union([
        z.boolean(),
        z.string()
    ])),
    format: z.optional(z.union([
        z.string(),
        z.number()
    ])),
    max_slices_per_scroll: z.optional(z.number()),
    translog: z.optional(indices_types_translog),
    query_string: z.optional(indices_types_settings_query_string),
    priority: z.optional(z.union([
        z.number(),
        z.string()
    ])),
    top_metrics_max_size: z.optional(z.number()),
    analysis: z.optional(indices_types_index_settings_analysis),
    get settings() {
        return z.optional(z.lazy((): any => indices_types_index_settings));
    },
    time_series: z.optional(indices_types_index_settings_time_series),
    queries: z.optional(indices_types_queries),
    similarity: z.optional(z.record(z.string(), indices_types_settings_similarity).register(z.globalRegistry, {
        description: 'Configure custom similarity settings to customize how search results are scored.'
    })),
    mapping: z.optional(indices_types_mapping_limit_settings),
    'indexing.slowlog': z.optional(indices_types_indexing_slowlog_settings),
    indexing_pressure: z.optional(indices_types_indexing_pressure),
    store: z.optional(indices_types_storage)
});

export const types_aggregations_top_hits_aggregate = types_aggregations_aggregate_base.and(z.lazy(() => z.object({
    get hits() {
        return z.lazy((): any => global_search_types_hits_metadata);
    }
})));

export const global_search_types_inner_hits_result = z.object({
    get hits() {
        return z.lazy((): any => global_search_types_hits_metadata);
    }
});

export const global_search_types_hits_metadata = z.object({
    total: z.optional(z.union([
        global_search_types_total_hits,
        z.number()
    ])),
    get hits() {
        return z.array(z.lazy((): any => global_search_types_hit));
    },
    max_score: z.optional(z.union([
        z.number(),
        z.string(),
        z.null()
    ]))
});

export const global_search_types_hit = z.object({
    _index: types_index_name,
    _id: z.optional(types_id),
    _score: z.optional(z.union([
        z.number(),
        z.string(),
        z.null()
    ])),
    _explanation: z.optional(global_explain_explanation),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    highlight: z.optional(z.record(z.string(), z.array(z.string()))),
    inner_hits: z.optional(z.record(z.string(), global_search_types_inner_hits_result)),
    matched_queries: z.optional(z.union([
        z.array(z.string()),
        z.record(z.string(), z.number())
    ])),
    _nested: z.optional(global_search_types_nested_identity),
    _ignored: z.optional(z.array(z.string())),
    ignored_field_values: z.optional(z.record(z.string(), z.array(z.record(z.string(), z.unknown())))),
    _shard: z.optional(z.string()),
    _node: z.optional(z.string()),
    _routing: z.optional(z.string()),
    _source: z.optional(z.record(z.string(), z.unknown())),
    _rank: z.optional(z.number()),
    _seq_no: z.optional(types_sequence_number),
    _primary_term: z.optional(z.number()),
    _version: z.optional(types_version_number),
    sort: z.optional(types_sort_results)
});

export const types_aggregations_aggregate = z.union([
    types_aggregations_cardinality_aggregate,
    types_aggregations_hdr_percentiles_aggregate,
    types_aggregations_hdr_percentile_ranks_aggregate,
    types_aggregations_t_digest_percentiles_aggregate,
    types_aggregations_t_digest_percentile_ranks_aggregate,
    types_aggregations_percentiles_bucket_aggregate,
    types_aggregations_median_absolute_deviation_aggregate,
    types_aggregations_min_aggregate,
    types_aggregations_max_aggregate,
    types_aggregations_sum_aggregate,
    types_aggregations_avg_aggregate,
    types_aggregations_weighted_avg_aggregate,
    types_aggregations_value_count_aggregate,
    types_aggregations_simple_value_aggregate,
    types_aggregations_derivative_aggregate,
    types_aggregations_bucket_metric_value_aggregate,
    types_aggregations_change_point_aggregate,
    types_aggregations_stats_aggregate,
    types_aggregations_stats_bucket_aggregate,
    types_aggregations_extended_stats_aggregate,
    types_aggregations_extended_stats_bucket_aggregate,
    types_aggregations_cartesian_bounds_aggregate,
    types_aggregations_cartesian_centroid_aggregate,
    types_aggregations_geo_bounds_aggregate,
    types_aggregations_geo_centroid_aggregate,
    types_aggregations_histogram_aggregate,
    types_aggregations_date_histogram_aggregate,
    types_aggregations_auto_date_histogram_aggregate,
    types_aggregations_variable_width_histogram_aggregate,
    types_aggregations_string_terms_aggregate,
    types_aggregations_long_terms_aggregate,
    types_aggregations_double_terms_aggregate,
    types_aggregations_unmapped_terms_aggregate,
    types_aggregations_long_rare_terms_aggregate,
    types_aggregations_string_rare_terms_aggregate,
    types_aggregations_unmapped_rare_terms_aggregate,
    types_aggregations_multi_terms_aggregate,
    types_aggregations_missing_aggregate,
    types_aggregations_nested_aggregate,
    types_aggregations_reverse_nested_aggregate,
    types_aggregations_global_aggregate,
    types_aggregations_filter_aggregate,
    types_aggregations_children_aggregate,
    types_aggregations_parent_aggregate,
    types_aggregations_sampler_aggregate,
    types_aggregations_unmapped_sampler_aggregate,
    types_aggregations_geo_hash_grid_aggregate,
    types_aggregations_geo_tile_grid_aggregate,
    types_aggregations_geo_hex_grid_aggregate,
    types_aggregations_range_aggregate,
    types_aggregations_date_range_aggregate,
    types_aggregations_geo_distance_aggregate,
    types_aggregations_ip_range_aggregate,
    types_aggregations_ip_prefix_aggregate,
    types_aggregations_filters_aggregate,
    types_aggregations_adjacency_matrix_aggregate,
    types_aggregations_significant_long_terms_aggregate,
    types_aggregations_significant_string_terms_aggregate,
    types_aggregations_unmapped_significant_terms_aggregate,
    types_aggregations_composite_aggregate,
    types_aggregations_frequent_item_sets_aggregate,
    types_aggregations_time_series_aggregate,
    types_aggregations_scripted_metric_aggregate,
    types_aggregations_top_hits_aggregate,
    types_aggregations_inference_aggregate,
    types_aggregations_string_stats_aggregate,
    types_aggregations_box_plot_aggregate,
    types_aggregations_top_metrics_aggregate,
    types_aggregations_t_test_aggregate,
    types_aggregations_rate_aggregate,
    types_aggregations_cumulative_cardinality_aggregate,
    types_aggregations_matrix_stats_aggregate,
    types_aggregations_geo_line_aggregate
]);

export const global_search_response_body = z.object({
    took: z.number().register(z.globalRegistry, {
        description: 'The number of milliseconds it took Elasticsearch to run the request.\nThis value is calculated by measuring the time elapsed between receipt of a request on the coordinating node and the time at which the coordinating node is ready to send the response.\nIt includes:\n\n* Communication time between the coordinating node and data nodes\n* Time the request spends in the search thread pool, queued for execution\n* Actual run time\n\nIt does not include:\n\n* Time needed to send the request to Elasticsearch\n* Time needed to serialize the JSON response\n* Time needed to send the response to a client'
    }),
    timed_out: z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the request timed out before completion; returned results may be partial or empty.'
    }),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregate)),
    _clusters: z.optional(types_cluster_statistics),
    fields: z.optional(z.record(z.string(), z.record(z.string(), z.unknown()))),
    max_score: z.optional(z.number()),
    num_reduce_phases: z.optional(z.number()),
    profile: z.optional(global_search_types_profile),
    pit_id: z.optional(types_id),
    _scroll_id: z.optional(types_scroll_id),
    suggest: z.optional(z.record(z.string(), z.array(global_search_types_suggest))),
    terminated_early: z.optional(z.boolean())
});

export const indices_types_alias = z.object({
    filter: z.optional(types_query_dsl_query_container),
    index_routing: z.optional(types_routing),
    is_hidden: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the alias is hidden.\nAll indices for the alias must have the same `is_hidden` value.'
    })),
    is_write_index: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the index is the write index for the alias.'
    })),
    routing: z.optional(types_routing),
    search_routing: z.optional(types_routing)
});

export const global_bulk_update_action = z.object({
    detect_noop: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If true, the `result` in the response is set to \'noop\' when no changes to the document occur.'
    })),
    doc: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'A partial update to an existing document.'
    })),
    doc_as_upsert: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to use the contents of `doc` as the value of `upsert`.'
    })),
    script: z.optional(types_script),
    scripted_upsert: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to run the script whether or not the document exists.'
    })),
    _source: z.optional(global_search_types_source_config),
    upsert: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'If the document does not already exist, the contents of `upsert` are inserted as a new document.\nIf the document exists, the `script` is run.'
    }))
});

/**
 * A comma-separated list of `<field>:<direction>` pairs.
 */
export const search_sort = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * The starting document offset, which must be non-negative.
 * By default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.
 * To page through more hits, use the `search_after` parameter.
 */
export const search_from = z.number().register(z.globalRegistry, {
    description: 'The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
});

/**
 * The number of hits to return.
 * By default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.
 * To page through more hits, use the `search_after` parameter.
 */
export const search_size = z.number().register(z.globalRegistry, {
    description: 'The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
});

/**
 * A query in the Lucene query string syntax.
 * Query parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.
 *
 * IMPORTANT: This parameter overrides the query parameter in the request body.
 * If both parameters are specified, documents matching the query request body parameter are not returned.
 */
export const search_q = z.string().register(z.globalRegistry, {
    description: 'A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.'
});

/**
 * If `true`, the request returns the sequence number and primary term of the last modification of each hit.
 */
export const search_seq_no_primary_term = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the request returns the sequence number and primary term of the last modification of each hit.'
});

/**
 * A comma-separated list of source fields to include in the response.
 * If this parameter is specified, only these source fields are returned.
 * You can exclude fields from this subset using the `_source_excludes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const search_source_includes = types_fields;

/**
 * Whether vectors should be excluded from _source
 */
export const search_source_exclude_vectors = z.boolean().register(z.globalRegistry, {
    description: 'Whether vectors should be excluded from _source'
});

/**
 * A comma-separated list of source fields to exclude from the response.
 * You can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const search_source_excludes = types_fields;

/**
 * The source fields that are returned for matching documents.
 * These fields are returned in the `hits._source` property of the search response.
 * Valid values are:
 *
 * * `true` to return the entire document source.
 * * `false` to not return the document source.
 * * `<string>` to return the source fields that are specified as a comma-separated list that supports wildcard (`*`) patterns.
 */
export const search_source = global_search_types_source_config_param;

/**
 * If `true`, the request returns the document version as part of a hit.
 */
export const search_version = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the request returns the document version as part of a hit.'
});

/**
 * Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.
 */
export const search_rest_total_hits_as_int = z.boolean().register(z.globalRegistry, {
    description: 'Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.'
});

/**
 * If `true`, aggregation and suggester names are be prefixed by their respective types in the response.
 */
export const search_typed_keys = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, aggregation and suggester names are be prefixed by their respective types in the response.'
});

/**
 * If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.
 */
export const search_track_scores = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.'
});

/**
 * The number of hits matching the query to count accurately.
 * If `true`, the exact number of hits is returned at the cost of some performance.
 * If `false`, the response does not include the total number of hits matching the query.
 */
export const search_track_total_hits = global_search_types_track_hits;

/**
 * The period of time to wait for a response from each shard.
 * If no response is received before the timeout expires, the request fails and returns an error.
 * It defaults to no timeout.
 */
export const search_timeout = types_duration;

/**
 * The maximum number of documents to collect for each shard.
 * If a query reaches this limit, Elasticsearch terminates the query early.
 * Elasticsearch collects documents before sorting.
 *
 * IMPORTANT: Use with caution.
 * Elasticsearch applies this parameter to each shard handling the request.
 * When possible, let Elasticsearch perform early termination automatically.
 * Avoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.
 * If set to `0` (default), the query does not terminate early.
 */
export const search_terminate_after = z.number().register(z.globalRegistry, {
    description: 'The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.'
});

/**
 * The source text for which the suggestions should be returned.
 * This parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.
 */
export const search_suggest_text = z.string().register(z.globalRegistry, {
    description: 'The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.'
});

/**
 * The number of suggestions to return.
 * This parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.
 */
export const search_suggest_size = z.number().register(z.globalRegistry, {
    description: 'The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.'
});

/**
 * The suggest mode.
 * This parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.
 */
export const search_suggest_mode = types_suggest_mode;

/**
 * The field to use for suggestions.
 */
export const search_suggest_field = types_field;

/**
 * A comma-separated list of stored fields to return as part of a hit.
 * If no fields are specified, no stored fields are included in the response.
 * If this field is specified, the `_source` parameter defaults to `false`.
 * You can pass `_source: true` to return both source fields and stored fields in the search response.
 */
export const search_stored_fields = types_fields;

/**
 * Specific `tag` of the request for logging and statistical purposes.
 */
export const search_stats = z.array(z.string()).register(z.globalRegistry, {
    description: 'Specific `tag` of the request for logging and statistical purposes.'
});

/**
 * Indicates how distributed term frequencies are calculated for relevance scoring.
 */
export const search_search_type = types_search_type;

/**
 * The period to retain the search context for scrolling.
 * By default, this value cannot exceed `1d` (24 hours).
 * You can change this limit by using the `search.max_keep_alive` cluster-level setting.
 */
export const search_scroll = types_duration;

/**
 * A custom value that is used to route operations to a specific shard.
 */
export const search_routing = types_routing;

/**
 * If `true`, the caching of search results is enabled for requests where `size` is `0`.
 * It defaults to index level settings.
 */
export const search_request_cache = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.'
});

/**
 * A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.
 * This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).
 * When unspecified, the pre-filter phase is executed if any of these conditions is met:
 *
 * * The request targets more than 128 shards.
 * * The request targets one or more read-only index.
 * * The primary sort of the query targets an indexed field.
 */
export const search_pre_filter_shard_size = z.number().register(z.globalRegistry, {
    description: 'A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.'
});

/**
 * The nodes and shards used for the search.
 * By default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.
 * Valid values are:
 *
 * * `_only_local` to run the search only on shards on the local node.
 * * `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.
 * * `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.
 * * `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.
 * * `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.
 * * `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.
 */
export const search_preference = z.string().register(z.globalRegistry, {
    description: 'The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.'
});

/**
 * The number of concurrent shard requests per node that the search runs concurrently.
 * This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
 */
export const search_max_concurrent_shard_requests = z.number().register(z.globalRegistry, {
    description: 'The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.'
});

/**
 * If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_lenient = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.'
});

/**
 * If `true`, the response includes the score contribution from any named queries.
 *
 * This functionality reruns each named query on every hit in a search response.
 * Typically, this adds a small overhead to a request.
 * However, using computationally expensive named queries on a large number of hits may add significant overhead.
 */
export const search_include_named_queries_score = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.'
});

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const search_ignore_unavailable = z.boolean().register(z.globalRegistry, {
    description: 'If `false`, the request returns an error if it targets a missing or closed index.'
});

/**
 * If `true`, concrete, expanded or aliased indices will be ignored when frozen.
 *
 * @deprecated
 */
export const search_ignore_throttled = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, concrete, expanded or aliased indices will be ignored when frozen.'
});

/**
 * If `true`, the request returns detailed information about score computation as part of a hit.
 */
export const search_explain = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the request returns detailed information about score computation as part of a hit.'
});

/**
 * The type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * It supports comma-separated values such as `open,hidden`.
 */
export const search_expand_wildcards = types_expand_wildcards;

/**
 * A comma-separated list of fields to return as the docvalue representation of a field for each hit.
 */
export const search_docvalue_fields = types_fields;

/**
 * The field to use as a default when no field prefix is given in the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_df = z.string().register(z.globalRegistry, {
    description: 'The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.'
});

/**
 * The default operator for the query string query: `and` or `or`.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_default_operator = types_query_dsl_operator;

/**
 * If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.
 */
export const search_ccs_minimize_roundtrips = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.'
});

/**
 * The number of shard results that should be reduced at once on the coordinating node.
 * If the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.
 */
export const search_batched_reduce_size = z.number().register(z.globalRegistry, {
    description: 'The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.'
});

/**
 * If `true`, wildcard and prefix queries are analyzed.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_analyze_wildcard = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.'
});

/**
 * The analyzer to use for the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_analyzer = z.string().register(z.globalRegistry, {
    description: 'The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.'
});

/**
 * If `true` and there are shard request timeouts or shard failures, the request returns partial results.
 * If `false`, it returns an error with no partial results.
 *
 * To override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.
 */
export const search_allow_partial_search_results = z.boolean().register(z.globalRegistry, {
    description: 'If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.'
});

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 * For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const search_allow_no_indices = z.boolean().register(z.globalRegistry, {
    description: 'If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.'
});

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 * To search all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const search_index = types_indices;

/**
 * If `true`, the request's actions must target a data stream (existing or to be created).
 */
export const index_require_data_stream = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the request\'s actions must target a data stream (existing or to be created).'
});

/**
 * If `true`, the destination must be an index alias.
 */
export const index_require_alias = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the destination must be an index alias.'
});

/**
 * The number of shard copies that must be active before proceeding with the operation.
 * You can set it to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).
 * The default value of `1` means it waits for each primary shard to be active.
 */
export const index_wait_for_active_shards = types_wait_for_active_shards;

/**
 * The version type.
 */
export const index_version_type = types_version_type;

/**
 * An explicit version number for concurrency control.
 * It must be a non-negative long number.
 */
export const index_version = types_version_number;

/**
 * The period the request waits for the following operations: automatic index creation, dynamic mapping updates, waiting for active shards.
 *
 * This parameter is useful for situations where the primary shard assigned to perform the operation might not be available when the operation runs.
 * Some reasons for this might be that the primary shard is currently recovering from a gateway or undergoing relocation.
 * By default, the operation will wait on the primary shard to become available for at least 1 minute before failing and responding with an error.
 * The actual wait time could be longer, particularly when multiple waits occur.
 */
export const index_timeout = types_duration;

/**
 * A custom value that is used to route operations to a specific shard.
 */
export const index_routing = types_routing;

/**
 * If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search.
 * If `wait_for`, it waits for a refresh to make this operation visible to search.
 * If `false`, it does nothing with refreshes.
 */
export const index_refresh = types_refresh;

/**
 * The ID of the pipeline to use to preprocess incoming documents.
 * If the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.
 * If a final pipeline is configured it will always run, regardless of the value of this parameter.
 */
export const index_pipeline = z.string().register(z.globalRegistry, {
    description: 'The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.'
});

/**
 * Set to `create` to only index the document if it does not already exist (put if absent).
 * If a document with the specified `_id` already exists, the indexing operation will fail.
 * The behavior is the same as using the `<index>/_create` endpoint.
 * If a document ID is specified, this paramater defaults to `index`.
 * Otherwise, it defaults to `create`.
 * If the request targets a data stream, an `op_type` of `create` is required.
 */
export const index_op_type = types_op_type;

/**
 * True or false if to include the document source in the error message in case of parsing errors.
 */
export const index_include_source_on_error = z.boolean().register(z.globalRegistry, {
    description: 'True or false if to include the document source in the error message in case of parsing errors.'
});

/**
 * Only perform the operation if the document has this sequence number.
 */
export const index_if_seq_no = types_sequence_number;

/**
 * Only perform the operation if the document has this primary term.
 */
export const index_if_primary_term = z.number().register(z.globalRegistry, {
    description: 'Only perform the operation if the document has this primary term.'
});

/**
 * The name of the data stream or index to target.
 * If the target doesn't exist and matches the name or wildcard (`*`) pattern of an index template with a `data_stream` definition, this request creates the data stream.
 * If the target doesn't exist and doesn't match a data stream template, this request creates the index.
 * You can check for existing targets with the resolve index API.
 */
export const index_index = types_index_name;

/**
 * A unique identifier for the document.
 * To automatically generate a document ID, use the `POST /<target>/_doc/` request format and omit this parameter.
 */
export const index_id = types_id;

/**
 * If `true`, the request's actions must target a data stream (existing or to be created).
 */
export const bulk_require_data_stream = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the request\'s actions must target a data stream (existing or to be created).'
});

/**
 * If `true`, the request's actions must target an index alias.
 */
export const bulk_require_alias = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the request\'s actions must target an index alias.'
});

/**
 * The number of shard copies that must be active before proceeding with the operation.
 * Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).
 * The default is `1`, which waits for each primary shard to be active.
 */
export const bulk_wait_for_active_shards = types_wait_for_active_shards;

/**
 * The period each action waits for the following operations: automatic index creation, dynamic mapping updates, and waiting for active shards.
 * The default is `1m` (one minute), which guarantees Elasticsearch waits for at least the timeout before failing.
 * The actual wait time could be longer, particularly when multiple waits occur.
 */
export const bulk_timeout = types_duration;

/**
 * A comma-separated list of source fields to include in the response.
 * If this parameter is specified, only these source fields are returned.
 * You can exclude fields from this subset using the `_source_excludes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const bulk_source_includes = types_fields;

/**
 * A comma-separated list of source fields to exclude from the response.
 * You can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const bulk_source_excludes = types_fields;

/**
 * Indicates whether to return the `_source` field (`true` or `false`) or contains a list of fields to return.
 */
export const bulk_source = global_search_types_source_config_param;

/**
 * A custom value that is used to route operations to a specific shard.
 */
export const bulk_routing = types_routing;

/**
 * If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search.
 * If `wait_for`, wait for a refresh to make this operation visible to search.
 * If `false`, do nothing with refreshes.
 * Valid values: `true`, `false`, `wait_for`.
 */
export const bulk_refresh = types_refresh;

/**
 * The pipeline identifier to use to preprocess incoming documents.
 * If the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.
 * If a final pipeline is configured, it will always run regardless of the value of this parameter.
 */
export const bulk_pipeline = z.string().register(z.globalRegistry, {
    description: 'The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.'
});

/**
 * If `true`, the response will include the ingest pipelines that were run for each index or create.
 */
export const bulk_list_executed_pipelines = z.boolean().register(z.globalRegistry, {
    description: 'If `true`, the response will include the ingest pipelines that were run for each index or create.'
});

/**
 * True or false if to include the document source in the error message in case of parsing errors.
 */
export const bulk_include_source_on_error = z.boolean().register(z.globalRegistry, {
    description: 'True or false if to include the document source in the error message in case of parsing errors.'
});

/**
 * The name of the data stream, index, or index alias to perform bulk actions on.
 */
export const bulk_index = types_index_name;

export const index = z.record(z.string(), z.unknown());

export const search = z.object({
    aggregations: z.optional(z.record(z.string(), types_aggregations_aggregation_container).register(z.globalRegistry, {
        description: 'Defines the aggregations that are run as part of the search request.'
    })),
    collapse: z.optional(global_search_types_field_collapse),
    explain: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the request returns detailed information about score computation as part of a hit.'
    })),
    ext: z.optional(z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'Configuration of search extensions defined by Elasticsearch plugins.'
    })),
    from: z.optional(z.number().register(z.globalRegistry, {
        description: 'The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
    })),
    highlight: z.optional(global_search_types_highlight),
    track_total_hits: z.optional(global_search_types_track_hits),
    indices_boost: z.optional(z.array(z.record(z.string(), z.number())).register(z.globalRegistry, {
        description: 'Boost the `_score` of documents from specified indices.\nThe boost value is the factor by which scores are multiplied.\nA boost value greater than `1.0` increases the score.\nA boost value between `0` and `1.0` decreases the score.'
    })),
    docvalue_fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: 'An array of wildcard (`*`) field patterns.\nThe request returns doc values for field names matching these patterns in the `hits.fields` property of the response.'
    })),
    knn: z.optional(z.union([
        types_knn_search,
        z.array(types_knn_search)
    ])),
    rank: z.optional(types_rank_container),
    min_score: z.optional(z.number().register(z.globalRegistry, {
        description: 'The minimum `_score` for matching documents.\nDocuments with a lower `_score` are not included in search results and results collected by aggregations.'
    })),
    post_filter: z.optional(types_query_dsl_query_container),
    profile: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Set to `true` to return detailed timing information about the execution of individual components in a search request.\nNOTE: This is a debugging tool and adds significant overhead to search execution.'
    })),
    query: z.optional(types_query_dsl_query_container),
    rescore: z.optional(z.union([
        global_search_types_rescore,
        z.array(global_search_types_rescore)
    ])),
    retriever: z.optional(types_retriever_container),
    script_fields: z.optional(z.record(z.string(), types_script_field).register(z.globalRegistry, {
        description: 'Retrieve a script evaluation (based on different fields) for each hit.'
    })),
    search_after: z.optional(types_sort_results),
    size: z.optional(z.number().register(z.globalRegistry, {
        description: 'The number of hits to return, which must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` property.'
    })),
    slice: z.optional(types_sliced_scroll),
    sort: z.optional(types_sort),
    _source: z.optional(global_search_types_source_config),
    fields: z.optional(z.array(types_query_dsl_field_and_format).register(z.globalRegistry, {
        description: 'An array of wildcard (`*`) field patterns.\nThe request returns values for field names matching these patterns in the `hits.fields` property of the response.'
    })),
    suggest: z.optional(global_search_types_suggester),
    terminate_after: z.optional(z.number().register(z.globalRegistry, {
        description: 'The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this property to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this property for requests that target data streams with backing indices across multiple data tiers.\n\nIf set to `0` (default), the query does not terminate early.'
    })),
    timeout: z.optional(z.string().register(z.globalRegistry, {
        description: 'The period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.'
    })),
    track_scores: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, calculate and return document scores, even if the scores are not used for sorting.'
    })),
    version: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the request returns the document version as part of a hit.'
    })),
    seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'If `true`, the request returns sequence number and primary term of the last modification of each hit.'
    })),
    stored_fields: z.optional(types_fields),
    pit: z.optional(global_search_types_point_in_time_reference),
    runtime_mappings: z.optional(types_mapping_runtime_fields),
    stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'The stats groups to associate with the search.\nEach group maintains a statistics aggregation for its associated searches.\nYou can retrieve these stats using the indices stats API.'
    }))
});

export const bulk = z.array(z.union([
    global_bulk_operation_container,
    global_bulk_update_action,
    z.record(z.string(), z.unknown())
]));

export const index1_request = z.object({
    body: index,
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.optional(z.object({
        if_primary_term: z.optional(z.number().register(z.globalRegistry, {
            description: 'Only perform the operation if the document has this primary term.'
        })),
        if_seq_no: z.optional(types_sequence_number),
        include_source_on_error: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'True or false if to include the document source in the error message in case of parsing errors.'
        })),
        op_type: z.optional(types_op_type),
        pipeline: z.optional(z.string().register(z.globalRegistry, {
            description: 'The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.'
        })),
        refresh: z.optional(types_refresh),
        routing: z.optional(types_routing),
        timeout: z.optional(types_duration),
        version: z.optional(types_version_number),
        version_type: z.optional(types_version_type),
        wait_for_active_shards: z.optional(types_wait_for_active_shards),
        require_alias: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the destination must be an index alias.'
        })),
        require_data_stream: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target a data stream (existing or to be created).'
        }))
    }))
});

export const index1_response = types_write_response_base;

export const index_request = z.object({
    body: index,
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.optional(z.object({
        if_primary_term: z.optional(z.number().register(z.globalRegistry, {
            description: 'Only perform the operation if the document has this primary term.'
        })),
        if_seq_no: z.optional(types_sequence_number),
        include_source_on_error: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'True or false if to include the document source in the error message in case of parsing errors.'
        })),
        op_type: z.optional(types_op_type),
        pipeline: z.optional(z.string().register(z.globalRegistry, {
            description: 'The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.'
        })),
        refresh: z.optional(types_refresh),
        routing: z.optional(types_routing),
        timeout: z.optional(types_duration),
        version: z.optional(types_version_number),
        version_type: z.optional(types_version_type),
        wait_for_active_shards: z.optional(types_wait_for_active_shards),
        require_alias: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the destination must be an index alias.'
        })),
        require_data_stream: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target a data stream (existing or to be created).'
        }))
    }))
});

export const index_response = types_write_response_base;

export const index2_request = z.object({
    body: index,
    path: z.object({
        index: types_index_name
    }),
    query: z.optional(z.object({
        if_primary_term: z.optional(z.number().register(z.globalRegistry, {
            description: 'Only perform the operation if the document has this primary term.'
        })),
        if_seq_no: z.optional(types_sequence_number),
        include_source_on_error: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'True or false if to include the document source in the error message in case of parsing errors.'
        })),
        op_type: z.optional(types_op_type),
        pipeline: z.optional(z.string().register(z.globalRegistry, {
            description: 'The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.'
        })),
        refresh: z.optional(types_refresh),
        routing: z.optional(types_routing),
        timeout: z.optional(types_duration),
        version: z.optional(types_version_number),
        version_type: z.optional(types_version_type),
        wait_for_active_shards: z.optional(types_wait_for_active_shards),
        require_alias: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the destination must be an index alias.'
        })),
        require_data_stream: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target a data stream (existing or to be created).'
        }))
    }))
});

export const index2_response = types_write_response_base;

export const indices_delete_request = z.object({
    body: z.optional(z.never()),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.'
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if it targets a missing or closed index.'
        })),
        master_timeout: z.optional(types_duration),
        timeout: z.optional(types_duration)
    }))
});

export const indices_delete_response = types_indices_response_base;

export const indices_exists_request = z.object({
    body: z.optional(z.never()),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.'
        })),
        expand_wildcards: z.optional(types_expand_wildcards),
        flat_settings: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, returns settings in flat format.'
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if it targets a missing or closed index.'
        })),
        include_defaults: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, return all default settings in the response.'
        })),
        local: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request retrieves information from the local node only.'
        }))
    }))
});

export const bulk_request = z.object({
    body: bulk,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        include_source_on_error: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'True or false if to include the document source in the error message in case of parsing errors.'
        })),
        list_executed_pipelines: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the response will include the ingest pipelines that were run for each index or create.'
        })),
        pipeline: z.optional(z.string().register(z.globalRegistry, {
            description: 'The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.'
        })),
        refresh: z.optional(types_refresh),
        routing: z.optional(types_routing),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_includes: z.optional(types_fields),
        timeout: z.optional(types_duration),
        wait_for_active_shards: z.optional(types_wait_for_active_shards),
        require_alias: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target an index alias.'
        })),
        require_data_stream: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target a data stream (existing or to be created).'
        }))
    }))
});

export const bulk_response = z.object({
    errors: z.boolean().register(z.globalRegistry, {
        description: 'If `true`, one or more of the operations in the bulk request did not complete successfully.'
    }),
    items: z.array(z.record(z.string(), global_bulk_response_item)).register(z.globalRegistry, {
        description: 'The result of each operation in the bulk request, in the order they were submitted.'
    }),
    took: z.number().register(z.globalRegistry, {
        description: 'The length of time, in milliseconds, it took to process the bulk request.'
    }),
    ingest_took: z.optional(z.number())
});

export const bulk1_request = z.object({
    body: bulk,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        include_source_on_error: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'True or false if to include the document source in the error message in case of parsing errors.'
        })),
        list_executed_pipelines: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the response will include the ingest pipelines that were run for each index or create.'
        })),
        pipeline: z.optional(z.string().register(z.globalRegistry, {
            description: 'The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.'
        })),
        refresh: z.optional(types_refresh),
        routing: z.optional(types_routing),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_includes: z.optional(types_fields),
        timeout: z.optional(types_duration),
        wait_for_active_shards: z.optional(types_wait_for_active_shards),
        require_alias: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target an index alias.'
        })),
        require_data_stream: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target a data stream (existing or to be created).'
        }))
    }))
});

export const bulk1_response = z.object({
    errors: z.boolean().register(z.globalRegistry, {
        description: 'If `true`, one or more of the operations in the bulk request did not complete successfully.'
    }),
    items: z.array(z.record(z.string(), global_bulk_response_item)).register(z.globalRegistry, {
        description: 'The result of each operation in the bulk request, in the order they were submitted.'
    }),
    took: z.number().register(z.globalRegistry, {
        description: 'The length of time, in milliseconds, it took to process the bulk request.'
    }),
    ingest_took: z.optional(z.number())
});

export const bulk2_request = z.object({
    body: bulk,
    path: z.object({
        index: types_index_name
    }),
    query: z.optional(z.object({
        include_source_on_error: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'True or false if to include the document source in the error message in case of parsing errors.'
        })),
        list_executed_pipelines: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the response will include the ingest pipelines that were run for each index or create.'
        })),
        pipeline: z.optional(z.string().register(z.globalRegistry, {
            description: 'The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.'
        })),
        refresh: z.optional(types_refresh),
        routing: z.optional(types_routing),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_includes: z.optional(types_fields),
        timeout: z.optional(types_duration),
        wait_for_active_shards: z.optional(types_wait_for_active_shards),
        require_alias: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target an index alias.'
        })),
        require_data_stream: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target a data stream (existing or to be created).'
        }))
    }))
});

export const bulk2_response = z.object({
    errors: z.boolean().register(z.globalRegistry, {
        description: 'If `true`, one or more of the operations in the bulk request did not complete successfully.'
    }),
    items: z.array(z.record(z.string(), global_bulk_response_item)).register(z.globalRegistry, {
        description: 'The result of each operation in the bulk request, in the order they were submitted.'
    }),
    took: z.number().register(z.globalRegistry, {
        description: 'The length of time, in milliseconds, it took to process the bulk request.'
    }),
    ingest_took: z.optional(z.number())
});

export const bulk3_request = z.object({
    body: bulk,
    path: z.object({
        index: types_index_name
    }),
    query: z.optional(z.object({
        include_source_on_error: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'True or false if to include the document source in the error message in case of parsing errors.'
        })),
        list_executed_pipelines: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the response will include the ingest pipelines that were run for each index or create.'
        })),
        pipeline: z.optional(z.string().register(z.globalRegistry, {
            description: 'The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.'
        })),
        refresh: z.optional(types_refresh),
        routing: z.optional(types_routing),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_includes: z.optional(types_fields),
        timeout: z.optional(types_duration),
        wait_for_active_shards: z.optional(types_wait_for_active_shards),
        require_alias: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target an index alias.'
        })),
        require_data_stream: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request\'s actions must target a data stream (existing or to be created).'
        }))
    }))
});

export const bulk3_response = z.object({
    errors: z.boolean().register(z.globalRegistry, {
        description: 'If `true`, one or more of the operations in the bulk request did not complete successfully.'
    }),
    items: z.array(z.record(z.string(), global_bulk_response_item)).register(z.globalRegistry, {
        description: 'The result of each operation in the bulk request, in the order they were submitted.'
    }),
    took: z.number().register(z.globalRegistry, {
        description: 'The length of time, in milliseconds, it took to process the bulk request.'
    }),
    ingest_took: z.optional(z.number())
});

export const esql_query_request = z.object({
    body: z.object({
        columnar: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'By default, ES|QL returns results as rows. For example, FROM returns each individual document as one row. For the JSON, YAML, CBOR and smile formats, ES|QL can return the results in a columnar fashion where one row represents all the values of a certain column in the results.'
        })),
        filter: z.optional(types_query_dsl_query_container),
        locale: z.optional(z.string()),
        params: z.optional(z.array(esql_types_esql_param).register(z.globalRegistry, {
            description: 'To avoid any attempts of hacking or code injection, extract the values in a separate list of parameters. Use question mark placeholders (?) in the query string for each of the parameters.'
        })),
        profile: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If provided and `true` the response will include an extra `profile` object\nwith information on how the query was executed. This information is for human debugging\nand its format can change at any time but it can give some insight into the performance\nof each part of the query.'
        })),
        query: z.string().register(z.globalRegistry, {
            description: 'The ES|QL query API accepts an ES|QL query string in the query parameter, runs it, and returns the results.'
        }),
        tables: z.optional(z.record(z.string(), z.record(z.string(), esql_types_table_values_container)).register(z.globalRegistry, {
            description: 'Tables to use with the LOOKUP operation. The top level key is the table\nname and the next level key is the column name.'
        })),
        include_ccs_metadata: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'When set to `true` and performing a cross-cluster/cross-project query, the response will include an extra `_clusters`\nobject with information about the clusters that participated in the search along with info such as shards\ncount.'
        })),
        include_execution_metadata: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'When set to `true`, the response will include an extra `_clusters`\nobject with information about the clusters that participated in the search along with info such as shards\ncount.\nThis is similar to `include_ccs_metadata`, but it also returns metadata when the query is not CCS/CPS'
        }))
    }),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        format: z.optional(esql_types_esql_format),
        delimiter: z.optional(z.string().register(z.globalRegistry, {
            description: 'The character to use between values within a CSV row. Only valid for the CSV format.'
        })),
        drop_null_columns: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Should columns that are entirely `null` be removed from the `columns` and `values` portion of the results?\nDefaults to `false`. If `true` then the response will include an extra section under the name `all_columns` which has the name of all columns.'
        })),
        allow_partial_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, partial results will be returned if there are shard failures, but the query can continue to execute on other clusters and shards.\nIf `false`, the query will fail if there are any failures.\n\nTo override the default behavior, you can set the `esql.query.allow_partial_results` cluster setting to `false`.'
        }))
    }))
});

export const esql_query_response = esql_types_esql_result;

export const indices_create_request = z.object({
    body: z.optional(z.object({
        aliases: z.optional(z.record(z.string(), indices_types_alias).register(z.globalRegistry, {
            description: 'Aliases for the index.'
        })),
        mappings: z.optional(types_mapping_type_mapping),
        settings: z.optional(indices_types_index_settings)
    })),
    path: z.object({
        index: types_index_name
    }),
    query: z.optional(z.object({
        master_timeout: z.optional(types_duration),
        timeout: z.optional(types_duration),
        wait_for_active_shards: z.optional(types_wait_for_active_shards)
    }))
});

export const indices_create_response = z.object({
    index: types_index_name,
    shards_acknowledged: z.boolean(),
    acknowledged: z.boolean()
});

export const search_request = z.object({
    body: z.optional(search),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.'
        })),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.'
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: 'The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        batched_reduce_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.'
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.'
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: 'The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        docvalue_fields: z.optional(types_fields),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns detailed information about score computation as part of a hit.'
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, concrete, expanded or aliased indices will be ignored when frozen.'
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if it targets a missing or closed index.'
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.'
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.'
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: 'The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.'
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.'
        })),
        request_cache: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.'
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: 'Specific `tag` of the request for logging and statistical purposes.'
        })),
        stored_fields: z.optional(types_fields),
        suggest_field: z.optional(types_field),
        suggest_mode: z.optional(types_suggest_mode),
        suggest_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.'
        })),
        suggest_text: z.optional(z.string().register(z.globalRegistry, {
            description: 'The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.'
        })),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: 'The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.'
        })),
        timeout: z.optional(types_duration),
        track_total_hits: z.optional(global_search_types_track_hits),
        track_scores: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.'
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, aggregation and suggester names are be prefixed by their respective types in the response.'
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.'
        })),
        version: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns the document version as part of a hit.'
        })),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_exclude_vectors: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Whether vectors should be excluded from _source'
        })),
        _source_includes: z.optional(types_fields),
        seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns the sequence number and primary term of the last modification of each hit.'
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: 'A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.'
        })),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
        })),
        from: z.optional(z.number().register(z.globalRegistry, {
            description: 'The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
        })),
        sort: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ]))
    }))
});

export const search_response = global_search_response_body;

export const search1_request = z.object({
    body: z.optional(search),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.'
        })),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.'
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: 'The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        batched_reduce_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.'
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.'
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: 'The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        docvalue_fields: z.optional(types_fields),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns detailed information about score computation as part of a hit.'
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, concrete, expanded or aliased indices will be ignored when frozen.'
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if it targets a missing or closed index.'
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.'
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.'
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: 'The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.'
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.'
        })),
        request_cache: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.'
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: 'Specific `tag` of the request for logging and statistical purposes.'
        })),
        stored_fields: z.optional(types_fields),
        suggest_field: z.optional(types_field),
        suggest_mode: z.optional(types_suggest_mode),
        suggest_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.'
        })),
        suggest_text: z.optional(z.string().register(z.globalRegistry, {
            description: 'The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.'
        })),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: 'The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.'
        })),
        timeout: z.optional(types_duration),
        track_total_hits: z.optional(global_search_types_track_hits),
        track_scores: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.'
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, aggregation and suggester names are be prefixed by their respective types in the response.'
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.'
        })),
        version: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns the document version as part of a hit.'
        })),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_exclude_vectors: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Whether vectors should be excluded from _source'
        })),
        _source_includes: z.optional(types_fields),
        seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns the sequence number and primary term of the last modification of each hit.'
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: 'A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.'
        })),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
        })),
        from: z.optional(z.number().register(z.globalRegistry, {
            description: 'The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
        })),
        sort: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ]))
    }))
});

export const search1_response = global_search_response_body;

export const search2_request = z.object({
    body: z.optional(search),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.'
        })),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.'
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: 'The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        batched_reduce_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.'
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.'
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: 'The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        docvalue_fields: z.optional(types_fields),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns detailed information about score computation as part of a hit.'
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, concrete, expanded or aliased indices will be ignored when frozen.'
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if it targets a missing or closed index.'
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.'
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.'
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: 'The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.'
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.'
        })),
        request_cache: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.'
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: 'Specific `tag` of the request for logging and statistical purposes.'
        })),
        stored_fields: z.optional(types_fields),
        suggest_field: z.optional(types_field),
        suggest_mode: z.optional(types_suggest_mode),
        suggest_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.'
        })),
        suggest_text: z.optional(z.string().register(z.globalRegistry, {
            description: 'The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.'
        })),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: 'The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.'
        })),
        timeout: z.optional(types_duration),
        track_total_hits: z.optional(global_search_types_track_hits),
        track_scores: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.'
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, aggregation and suggester names are be prefixed by their respective types in the response.'
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.'
        })),
        version: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns the document version as part of a hit.'
        })),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_exclude_vectors: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Whether vectors should be excluded from _source'
        })),
        _source_includes: z.optional(types_fields),
        seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns the sequence number and primary term of the last modification of each hit.'
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: 'A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.'
        })),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
        })),
        from: z.optional(z.number().register(z.globalRegistry, {
            description: 'The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
        })),
        sort: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ]))
    }))
});

export const search2_response = global_search_response_body;

export const search3_request = z.object({
    body: z.optional(search),
    path: z.object({
        index: types_indices
    }),
    query: z.optional(z.object({
        allow_no_indices: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.'
        })),
        allow_partial_search_results: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.'
        })),
        analyzer: z.optional(z.string().register(z.globalRegistry, {
            description: 'The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        analyze_wildcard: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        batched_reduce_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.'
        })),
        ccs_minimize_roundtrips: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.'
        })),
        default_operator: z.optional(types_query_dsl_operator),
        df: z.optional(z.string().register(z.globalRegistry, {
            description: 'The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        docvalue_fields: z.optional(types_fields),
        expand_wildcards: z.optional(types_expand_wildcards),
        explain: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns detailed information about score computation as part of a hit.'
        })),
        ignore_throttled: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, concrete, expanded or aliased indices will be ignored when frozen.'
        })),
        ignore_unavailable: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `false`, the request returns an error if it targets a missing or closed index.'
        })),
        include_named_queries_score: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.'
        })),
        lenient: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.'
        })),
        max_concurrent_shard_requests: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.'
        })),
        preference: z.optional(z.string().register(z.globalRegistry, {
            description: 'The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.'
        })),
        pre_filter_shard_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.'
        })),
        request_cache: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.'
        })),
        routing: z.optional(types_routing),
        scroll: z.optional(types_duration),
        search_type: z.optional(types_search_type),
        stats: z.optional(z.array(z.string()).register(z.globalRegistry, {
            description: 'Specific `tag` of the request for logging and statistical purposes.'
        })),
        stored_fields: z.optional(types_fields),
        suggest_field: z.optional(types_field),
        suggest_mode: z.optional(types_suggest_mode),
        suggest_size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.'
        })),
        suggest_text: z.optional(z.string().register(z.globalRegistry, {
            description: 'The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.'
        })),
        terminate_after: z.optional(z.number().register(z.globalRegistry, {
            description: 'The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.'
        })),
        timeout: z.optional(types_duration),
        track_total_hits: z.optional(global_search_types_track_hits),
        track_scores: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.'
        })),
        typed_keys: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, aggregation and suggester names are be prefixed by their respective types in the response.'
        })),
        rest_total_hits_as_int: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.'
        })),
        version: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns the document version as part of a hit.'
        })),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_exclude_vectors: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Whether vectors should be excluded from _source'
        })),
        _source_includes: z.optional(types_fields),
        seq_no_primary_term: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the request returns the sequence number and primary term of the last modification of each hit.'
        })),
        q: z.optional(z.string().register(z.globalRegistry, {
            description: 'A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.'
        })),
        size: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
        })),
        from: z.optional(z.number().register(z.globalRegistry, {
            description: 'The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.'
        })),
        sort: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ]))
    }))
});

export const search3_response = global_search_response_body;

export const update_request = z.object({
    body: z.object({
        detect_noop: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the `result` in the response is set to `noop` (no operation) when there are no changes to the document.'
        })),
        doc: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
            description: 'A partial update to an existing document.\nIf both `doc` and `script` are specified, `doc` is ignored.'
        })),
        doc_as_upsert: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, use the contents of \'doc\' as the value of \'upsert\'.\nNOTE: Using ingest pipelines with `doc_as_upsert` is not supported.'
        })),
        script: z.optional(types_script),
        scripted_upsert: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, run the script whether or not the document exists.'
        })),
        _source: z.optional(global_search_types_source_config),
        upsert: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
            description: 'If the document does not already exist, the contents of \'upsert\' are inserted as a new document.\nIf the document exists, the \'script\' is run.'
        }))
    }),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.optional(z.object({
        if_primary_term: z.optional(z.number().register(z.globalRegistry, {
            description: 'Only perform the operation if the document has this primary term.'
        })),
        if_seq_no: z.optional(types_sequence_number),
        include_source_on_error: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'True or false if to include the document source in the error message in case of parsing errors.'
        })),
        lang: z.optional(z.string().register(z.globalRegistry, {
            description: 'The script language.'
        })),
        refresh: z.optional(types_refresh),
        require_alias: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'If `true`, the destination must be an index alias.'
        })),
        retry_on_conflict: z.optional(z.number().register(z.globalRegistry, {
            description: 'The number of times the operation should be retried when a conflict occurs.'
        })),
        routing: z.optional(types_routing),
        timeout: z.optional(types_duration),
        wait_for_active_shards: z.optional(types_wait_for_active_shards),
        _source: z.optional(global_search_types_source_config_param),
        _source_excludes: z.optional(types_fields),
        _source_includes: z.optional(types_fields)
    }))
});

export const update_response = global_update_update_write_response_base;
