// This file is auto-generated by @hey-api/openapi-ts

import { z } from '@kbn/zod/v4';

export const types_id = z.string();

export const types_acknowledged_response_base = z.object({
    acknowledged: z.boolean().describe('For a successful response, this value is always true. On failure, an exception is returned instead.')
});

/**
 * A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
 * `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
 */
export const types_duration = z.union([
    z.string(),
    z.enum(['-1']),
    z.enum(['0'])
]);

export const types_metadata = z.record(z.record(z.unknown()));

export const types_aggregations_aggregate_base = z.object({
    meta: types_metadata.optional()
});

export const types_aggregations_cardinality_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.number()
}));

export const types_aggregations_keyed_percentiles = z.record(z.union([
    z.string(),
    z.number(),
    z.null()
]));

export const types_aggregations_array_percentiles_item = z.object({
    key: z.number(),
    value: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    value_as_string: z.string().optional()
});

export const types_aggregations_percentiles = z.union([
    types_aggregations_keyed_percentiles,
    z.array(types_aggregations_array_percentiles_item)
]);

export const types_aggregations_percentiles_aggregate_base = types_aggregations_aggregate_base.and(z.object({
    values: types_aggregations_percentiles
}));

export const types_aggregations_hdr_percentiles_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_hdr_percentile_ranks_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_t_digest_percentiles_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_t_digest_percentile_ranks_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_percentiles_bucket_aggregate = types_aggregations_percentiles_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_single_metric_aggregate_base = types_aggregations_aggregate_base.and(z.object({
    value: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    value_as_string: z.string().optional()
}));

export const types_aggregations_median_absolute_deviation_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_min_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_max_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.unknown()));

/**
 * Sum aggregation result. `value` is always present and is zero if there were no values to process.
 */
export const types_aggregations_sum_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_avg_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.unknown()));

/**
 * Weighted average aggregation result. `value` is missing if the weight was set to zero.
 */
export const types_aggregations_weighted_avg_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.unknown()));

/**
 * Value count aggregation result. `value` is always present.
 */
export const types_aggregations_value_count_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_simple_value_aggregate = types_aggregations_single_metric_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_derivative_aggregate = types_aggregations_single_metric_aggregate_base.and(z.object({
    normalized_value: z.number().optional(),
    normalized_value_as_string: z.string().optional()
}));

export const types_aggregations_bucket_metric_value_aggregate = types_aggregations_single_metric_aggregate_base.and(z.object({
    keys: z.array(z.string())
}));

export const types_aggregations_abstract_change_point = z.object({
    p_value: z.number(),
    change_point: z.number()
});

export const types_aggregations_dip = types_aggregations_abstract_change_point.and(z.record(z.unknown()));

export const types_aggregations_distribution_change = types_aggregations_abstract_change_point.and(z.record(z.unknown()));

export const types_aggregations_indeterminable = z.object({
    reason: z.string()
});

export const types_aggregations_non_stationary = z.object({
    p_value: z.number(),
    r_value: z.number(),
    trend: z.string()
});

export const types_aggregations_spike = types_aggregations_abstract_change_point.and(z.record(z.unknown()));

export const types_aggregations_stationary = z.record(z.unknown());

export const types_aggregations_step_change = types_aggregations_abstract_change_point.and(z.record(z.unknown()));

export const types_aggregations_trend_change = z.object({
    p_value: z.number(),
    r_value: z.number(),
    change_point: z.number()
});

export const types_aggregations_change_type = z.object({
    dip: types_aggregations_dip.optional(),
    distribution_change: types_aggregations_distribution_change.optional(),
    indeterminable: types_aggregations_indeterminable.optional(),
    non_stationary: types_aggregations_non_stationary.optional(),
    spike: types_aggregations_spike.optional(),
    stationary: types_aggregations_stationary.optional(),
    step_change: types_aggregations_step_change.optional(),
    trend_change: types_aggregations_trend_change.optional()
});

/**
 * A field value.
 */
export const types_field_value = z.union([
    z.number(),
    z.string(),
    z.boolean(),
    z.null()
]);

/**
 * Base type for multi-bucket aggregation results that can hold sub-aggregations results.
 */
export const types_aggregations_multi_bucket_base = z.object({
    doc_count: z.number()
}).describe('Base type for multi-bucket aggregation results that can hold sub-aggregations results.');

export const types_aggregations_change_point_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_field_value
}));

export const types_aggregations_change_point_aggregate = types_aggregations_aggregate_base.and(z.object({
    type: types_aggregations_change_type,
    bucket: types_aggregations_change_point_bucket.optional()
}));

/**
 * Statistics aggregation result. `min`, `max` and `avg` are missing if there were no values to process
 * (`count` is zero).
 */
export const types_aggregations_stats_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    min: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    max: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    avg: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    sum: z.number(),
    min_as_string: z.string().optional(),
    max_as_string: z.string().optional(),
    avg_as_string: z.string().optional(),
    sum_as_string: z.string().optional()
}));

export const types_aggregations_stats_bucket_aggregate = types_aggregations_stats_aggregate.and(z.record(z.unknown()));

export const types_aggregations_standard_deviation_bounds = z.object({
    upper: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    lower: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    upper_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    lower_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    upper_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    lower_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ])
});

export const types_aggregations_standard_deviation_bounds_as_string = z.object({
    upper: z.string(),
    lower: z.string(),
    upper_population: z.string(),
    lower_population: z.string(),
    upper_sampling: z.string(),
    lower_sampling: z.string()
});

export const types_aggregations_extended_stats_aggregate = types_aggregations_stats_aggregate.and(z.object({
    sum_of_squares: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    variance: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    variance_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    variance_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation_population: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation_sampling: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    std_deviation_bounds: types_aggregations_standard_deviation_bounds.optional(),
    sum_of_squares_as_string: z.string().optional(),
    variance_as_string: z.string().optional(),
    variance_population_as_string: z.string().optional(),
    variance_sampling_as_string: z.string().optional(),
    std_deviation_as_string: z.string().optional(),
    std_deviation_bounds_as_string: types_aggregations_standard_deviation_bounds_as_string.optional()
}));

export const types_aggregations_extended_stats_bucket_aggregate = types_aggregations_extended_stats_aggregate.and(z.record(z.unknown()));

export const types_lat_lon_geo_location = z.object({
    lat: z.number().describe('Latitude'),
    lon: z.number().describe('Longitude')
});

export const types_geo_hash = z.string();

export const types_geo_hash_location = z.object({
    geohash: types_geo_hash
});

/**
 * A latitude/longitude as a 2 dimensional point. It can be represented in various ways:
 * - as a `{lat, long}` object
 * - as a geo hash value
 * - as a `[lon, lat]` array
 * - as a string in `"<lat>, <lon>"` or WKT point formats
 */
export const types_geo_location = z.union([
    types_lat_lon_geo_location,
    types_geo_hash_location,
    z.array(z.number()),
    z.string()
]);

export const types_top_left_bottom_right_geo_bounds = z.object({
    top_left: types_geo_location,
    bottom_right: types_geo_location
});

export const types_aggregations_cartesian_bounds_aggregate = types_aggregations_aggregate_base.and(z.object({
    bounds: types_top_left_bottom_right_geo_bounds.optional()
}));

export const types_cartesian_point = z.object({
    x: z.number(),
    y: z.number()
});

export const types_aggregations_cartesian_centroid_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    location: types_cartesian_point.optional()
}));

export const types_coords_geo_bounds = z.object({
    top: z.number(),
    bottom: z.number(),
    left: z.number(),
    right: z.number()
});

export const types_top_right_bottom_left_geo_bounds = z.object({
    top_right: types_geo_location,
    bottom_left: types_geo_location
});

export const types_wkt_geo_bounds = z.object({
    wkt: z.string()
});

/**
 * A geo bounding box. It can be represented in various ways:
 * - as 4 top/bottom/left/right coordinates
 * - as 2 top_left / bottom_right points
 * - as 2 top_right / bottom_left points
 * - as a WKT bounding box
 */
export const types_geo_bounds = z.union([
    types_coords_geo_bounds,
    types_top_left_bottom_right_geo_bounds,
    types_top_right_bottom_left_geo_bounds,
    types_wkt_geo_bounds
]);

export const types_aggregations_geo_bounds_aggregate = types_aggregations_aggregate_base.and(z.object({
    bounds: types_geo_bounds.optional()
}));

export const types_aggregations_geo_centroid_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    location: types_geo_location.optional()
}));

export const types_aggregations_histogram_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key_as_string: z.string().optional(),
    key: z.number()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_histogram_bucket = z.union([
    z.record(types_aggregations_histogram_bucket),
    z.array(types_aggregations_histogram_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_histogram_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_histogram_bucket
}));

export const types_aggregations_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_histogram_bucket.and(z.record(z.unknown()));

/**
 * Time unit for milliseconds
 */
export const types_unit_millis = z.number().describe('Time unit for milliseconds');

export const types_epoch_time_unit_millis = types_unit_millis;

export const types_aggregations_date_histogram_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key_as_string: z.string().optional(),
    key: types_epoch_time_unit_millis
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_date_histogram_bucket = z.union([
    z.record(types_aggregations_date_histogram_bucket),
    z.array(types_aggregations_date_histogram_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_date_histogram_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_date_histogram_bucket
}));

export const types_aggregations_date_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_date_histogram_bucket.and(z.record(z.unknown()));

/**
 * A date histogram interval. Similar to `Duration` with additional units: `w` (week), `M` (month), `q` (quarter) and
 * `y` (year)
 */
export const types_duration_large = z.string().describe('A date histogram interval. Similar to `Duration` with additional units: `w` (week), `M` (month), `q` (quarter) and\n`y` (year)');

export const types_aggregations_auto_date_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_date_histogram_bucket.and(z.object({
    interval: types_duration_large
}));

export const types_aggregations_variable_width_histogram_bucket = types_aggregations_multi_bucket_base.and(z.object({
    min: z.number(),
    key: z.number(),
    max: z.number(),
    min_as_string: z.string().optional(),
    key_as_string: z.string().optional(),
    max_as_string: z.string().optional()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_variable_width_histogram_bucket = z.union([
    z.record(types_aggregations_variable_width_histogram_bucket),
    z.array(types_aggregations_variable_width_histogram_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_variable_width_histogram_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_variable_width_histogram_bucket
}));

export const types_aggregations_variable_width_histogram_aggregate = types_aggregations_multi_bucket_aggregate_base_variable_width_histogram_bucket.and(z.record(z.unknown()));

export const types_aggregations_terms_bucket_base = types_aggregations_multi_bucket_base.and(z.object({
    doc_count_error_upper_bound: z.number().optional()
}));

export const types_aggregations_string_terms_bucket = types_aggregations_terms_bucket_base.and(z.object({
    key: types_field_value
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_string_terms_bucket = z.union([
    z.record(types_aggregations_string_terms_bucket),
    z.array(types_aggregations_string_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_string_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_string_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_string_terms_bucket = types_aggregations_multi_bucket_aggregate_base_string_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.number().optional(),
    sum_other_doc_count: z.number().optional()
}));

/**
 * Result of a `terms` aggregation when the field is a string.
 */
export const types_aggregations_string_terms_aggregate = types_aggregations_terms_aggregate_base_string_terms_bucket.and(z.record(z.unknown()));

export const types_aggregations_long_terms_bucket = types_aggregations_terms_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.string().optional()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_long_terms_bucket = z.union([
    z.record(types_aggregations_long_terms_bucket),
    z.array(types_aggregations_long_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_long_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_long_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_long_terms_bucket = types_aggregations_multi_bucket_aggregate_base_long_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.number().optional(),
    sum_other_doc_count: z.number().optional()
}));

/**
 * Result of a `terms` aggregation when the field is some kind of whole number like a integer, long, or a date.
 */
export const types_aggregations_long_terms_aggregate = types_aggregations_terms_aggregate_base_long_terms_bucket.and(z.record(z.unknown()));

export const types_aggregations_double_terms_bucket = types_aggregations_terms_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.string().optional()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_double_terms_bucket = z.union([
    z.record(types_aggregations_double_terms_bucket),
    z.array(types_aggregations_double_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_double_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_double_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_double_terms_bucket = types_aggregations_multi_bucket_aggregate_base_double_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.number().optional(),
    sum_other_doc_count: z.number().optional()
}));

/**
 * Result of a `terms` aggregation when the field is some kind of decimal number like a float, double, or distance.
 */
export const types_aggregations_double_terms_aggregate = types_aggregations_terms_aggregate_base_double_terms_bucket.and(z.record(z.unknown()));

/**
 * The absence of any type. This is commonly used in APIs that don't return a body.
 *
 * Although "void" is generally used for the unit type that has only one value, this is to be interpreted as
 * the bottom type that has no value at all. Most languages have a unit type, but few have a bottom type.
 *
 * See https://en.m.wikipedia.org/wiki/Unit_type and https://en.m.wikipedia.org/wiki/Bottom_type
 */
export const spec_utils_void = z.record(z.unknown()).describe('The absence of any type. This is commonly used in APIs that don\'t return a body.\n\nAlthough "void" is generally used for the unit type that has only one value, this is to be interpreted as\nthe bottom type that has no value at all. Most languages have a unit type, but few have a bottom type.\n\nSee https://en.m.wikipedia.org/wiki/Unit_type and https://en.m.wikipedia.org/wiki/Bottom_type');

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_void = z.union([
    z.record(spec_utils_void),
    z.array(spec_utils_void)
]);

export const types_aggregations_multi_bucket_aggregate_base_void = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_void
}));

export const types_aggregations_terms_aggregate_base_void = types_aggregations_multi_bucket_aggregate_base_void.and(z.object({
    doc_count_error_upper_bound: z.number().optional(),
    sum_other_doc_count: z.number().optional()
}));

/**
 * Result of a `terms` aggregation when the field is unmapped. `buckets` is always empty.
 */
export const types_aggregations_unmapped_terms_aggregate = types_aggregations_terms_aggregate_base_void.and(z.record(z.unknown()));

export const types_aggregations_long_rare_terms_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.string().optional()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_long_rare_terms_bucket = z.union([
    z.record(types_aggregations_long_rare_terms_bucket),
    z.array(types_aggregations_long_rare_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_long_rare_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_long_rare_terms_bucket
}));

/**
 * Result of the `rare_terms` aggregation when the field is some kind of whole number like a integer, long, or a date.
 */
export const types_aggregations_long_rare_terms_aggregate = types_aggregations_multi_bucket_aggregate_base_long_rare_terms_bucket.and(z.record(z.unknown()));

export const types_aggregations_string_rare_terms_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.string()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_string_rare_terms_bucket = z.union([
    z.record(types_aggregations_string_rare_terms_bucket),
    z.array(types_aggregations_string_rare_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_string_rare_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_string_rare_terms_bucket
}));

/**
 * Result of the `rare_terms` aggregation when the field is a string.
 */
export const types_aggregations_string_rare_terms_aggregate = types_aggregations_multi_bucket_aggregate_base_string_rare_terms_bucket.and(z.record(z.unknown()));

/**
 * Result of a `rare_terms` aggregation when the field is unmapped. `buckets` is always empty.
 */
export const types_aggregations_unmapped_rare_terms_aggregate = types_aggregations_multi_bucket_aggregate_base_void.and(z.record(z.unknown()));

export const types_aggregations_multi_terms_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.array(types_field_value),
    key_as_string: z.string().optional(),
    doc_count_error_upper_bound: z.number().optional()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_multi_terms_bucket = z.union([
    z.record(types_aggregations_multi_terms_bucket),
    z.array(types_aggregations_multi_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_multi_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_multi_terms_bucket
}));

export const types_aggregations_terms_aggregate_base_multi_terms_bucket = types_aggregations_multi_bucket_aggregate_base_multi_terms_bucket.and(z.object({
    doc_count_error_upper_bound: z.number().optional(),
    sum_other_doc_count: z.number().optional()
}));

export const types_aggregations_multi_terms_aggregate = types_aggregations_terms_aggregate_base_multi_terms_bucket.and(z.record(z.unknown()));

/**
 * Base type for single-bucket aggregation results that can hold sub-aggregations results.
 */
export const types_aggregations_single_bucket_aggregate_base = types_aggregations_aggregate_base.and(z.object({
    doc_count: z.number()
}));

export const types_aggregations_missing_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_nested_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_reverse_nested_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_global_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_filter_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_children_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_parent_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_sampler_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_unmapped_sampler_aggregate = types_aggregations_single_bucket_aggregate_base.and(z.record(z.unknown()));

export const types_aggregations_geo_hash_grid_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_geo_hash
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_geo_hash_grid_bucket = z.union([
    z.record(types_aggregations_geo_hash_grid_bucket),
    z.array(types_aggregations_geo_hash_grid_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_geo_hash_grid_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_geo_hash_grid_bucket
}));

export const types_aggregations_geo_hash_grid_aggregate = types_aggregations_multi_bucket_aggregate_base_geo_hash_grid_bucket.and(z.record(z.unknown()));

/**
 * A map tile reference, represented as `{zoom}/{x}/{y}`
 */
export const types_geo_tile = z.string().describe('A map tile reference, represented as `{zoom}/{x}/{y}`');

export const types_aggregations_geo_tile_grid_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_geo_tile
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_geo_tile_grid_bucket = z.union([
    z.record(types_aggregations_geo_tile_grid_bucket),
    z.array(types_aggregations_geo_tile_grid_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_geo_tile_grid_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_geo_tile_grid_bucket
}));

export const types_aggregations_geo_tile_grid_aggregate = types_aggregations_multi_bucket_aggregate_base_geo_tile_grid_bucket.and(z.record(z.unknown()));

/**
 * A map hex cell (H3) reference
 */
export const types_geo_hex_cell = z.string().describe('A map hex cell (H3) reference');

export const types_aggregations_geo_hex_grid_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_geo_hex_cell
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_geo_hex_grid_bucket = z.union([
    z.record(types_aggregations_geo_hex_grid_bucket),
    z.array(types_aggregations_geo_hex_grid_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_geo_hex_grid_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_geo_hex_grid_bucket
}));

export const types_aggregations_geo_hex_grid_aggregate = types_aggregations_multi_bucket_aggregate_base_geo_hex_grid_bucket.and(z.record(z.unknown()));

export const types_aggregations_range_bucket = types_aggregations_multi_bucket_base.and(z.object({
    from: z.number().optional(),
    to: z.number().optional(),
    from_as_string: z.string().optional(),
    to_as_string: z.string().optional(),
    key: z.string().describe('The bucket key. Present if the aggregation is _not_ keyed').optional()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_range_bucket = z.union([
    z.record(types_aggregations_range_bucket),
    z.array(types_aggregations_range_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_range_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_range_bucket
}));

export const types_aggregations_range_aggregate = types_aggregations_multi_bucket_aggregate_base_range_bucket.and(z.record(z.unknown()));

/**
 * Result of a `date_range` aggregation. Same format as a for a `range` aggregation: `from` and `to`
 * in `buckets` are milliseconds since the Epoch, represented as a floating point number.
 */
export const types_aggregations_date_range_aggregate = types_aggregations_range_aggregate.and(z.record(z.unknown()));

/**
 * Result of a `geo_distance` aggregation. The unit for `from` and `to` is meters by default.
 */
export const types_aggregations_geo_distance_aggregate = types_aggregations_range_aggregate.and(z.record(z.unknown()));

export const types_aggregations_ip_range_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.string().optional(),
    from: z.string().optional(),
    to: z.string().optional()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_ip_range_bucket = z.union([
    z.record(types_aggregations_ip_range_bucket),
    z.array(types_aggregations_ip_range_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_ip_range_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_ip_range_bucket
}));

export const types_aggregations_ip_range_aggregate = types_aggregations_multi_bucket_aggregate_base_ip_range_bucket.and(z.record(z.unknown()));

export const types_aggregations_ip_prefix_bucket = types_aggregations_multi_bucket_base.and(z.object({
    is_ipv6: z.boolean(),
    key: z.string(),
    prefix_length: z.number(),
    netmask: z.string().optional()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_ip_prefix_bucket = z.union([
    z.record(types_aggregations_ip_prefix_bucket),
    z.array(types_aggregations_ip_prefix_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_ip_prefix_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_ip_prefix_bucket
}));

export const types_aggregations_ip_prefix_aggregate = types_aggregations_multi_bucket_aggregate_base_ip_prefix_bucket.and(z.record(z.unknown()));

export const types_aggregations_filters_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.string().optional()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_filters_bucket = z.union([
    z.record(types_aggregations_filters_bucket),
    z.array(types_aggregations_filters_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_filters_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_filters_bucket
}));

export const types_aggregations_filters_aggregate = types_aggregations_multi_bucket_aggregate_base_filters_bucket.and(z.record(z.unknown()));

export const types_aggregations_adjacency_matrix_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.string()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_adjacency_matrix_bucket = z.union([
    z.record(types_aggregations_adjacency_matrix_bucket),
    z.array(types_aggregations_adjacency_matrix_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_adjacency_matrix_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_adjacency_matrix_bucket
}));

export const types_aggregations_adjacency_matrix_aggregate = types_aggregations_multi_bucket_aggregate_base_adjacency_matrix_bucket.and(z.record(z.unknown()));

export const types_aggregations_significant_terms_bucket_base = types_aggregations_multi_bucket_base.and(z.object({
    score: z.number(),
    bg_count: z.number()
}));

export const types_aggregations_significant_long_terms_bucket = types_aggregations_significant_terms_bucket_base.and(z.object({
    key: z.number(),
    key_as_string: z.string().optional()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_significant_long_terms_bucket = z.union([
    z.record(types_aggregations_significant_long_terms_bucket),
    z.array(types_aggregations_significant_long_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_significant_long_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_significant_long_terms_bucket
}));

export const types_aggregations_significant_terms_aggregate_base_significant_long_terms_bucket = types_aggregations_multi_bucket_aggregate_base_significant_long_terms_bucket.and(z.object({
    bg_count: z.number().optional(),
    doc_count: z.number().optional()
}));

export const types_aggregations_significant_long_terms_aggregate = types_aggregations_significant_terms_aggregate_base_significant_long_terms_bucket.and(z.record(z.unknown()));

export const types_aggregations_significant_string_terms_bucket = types_aggregations_significant_terms_bucket_base.and(z.object({
    key: z.string()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_significant_string_terms_bucket = z.union([
    z.record(types_aggregations_significant_string_terms_bucket),
    z.array(types_aggregations_significant_string_terms_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_significant_string_terms_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_significant_string_terms_bucket
}));

export const types_aggregations_significant_terms_aggregate_base_significant_string_terms_bucket = types_aggregations_multi_bucket_aggregate_base_significant_string_terms_bucket.and(z.object({
    bg_count: z.number().optional(),
    doc_count: z.number().optional()
}));

export const types_aggregations_significant_string_terms_aggregate = types_aggregations_significant_terms_aggregate_base_significant_string_terms_bucket.and(z.record(z.unknown()));

export const types_aggregations_significant_terms_aggregate_base_void = types_aggregations_multi_bucket_aggregate_base_void.and(z.object({
    bg_count: z.number().optional(),
    doc_count: z.number().optional()
}));

/**
 * Result of the `significant_terms` aggregation on an unmapped field. `buckets` is always empty.
 */
export const types_aggregations_unmapped_significant_terms_aggregate = types_aggregations_significant_terms_aggregate_base_void.and(z.record(z.unknown()));

export const types_aggregations_composite_aggregate_key = z.record(types_field_value);

export const types_aggregations_composite_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: types_aggregations_composite_aggregate_key
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_composite_bucket = z.union([
    z.record(types_aggregations_composite_bucket),
    z.array(types_aggregations_composite_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_composite_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_composite_bucket
}));

export const types_aggregations_composite_aggregate = types_aggregations_multi_bucket_aggregate_base_composite_bucket.and(z.object({
    after_key: types_aggregations_composite_aggregate_key.optional()
}));

export const types_aggregations_frequent_item_sets_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.record(z.array(z.string())),
    support: z.number()
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_frequent_item_sets_bucket = z.union([
    z.record(types_aggregations_frequent_item_sets_bucket),
    z.array(types_aggregations_frequent_item_sets_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_frequent_item_sets_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_frequent_item_sets_bucket
}));

export const types_aggregations_frequent_item_sets_aggregate = types_aggregations_multi_bucket_aggregate_base_frequent_item_sets_bucket.and(z.record(z.unknown()));

export const types_aggregations_time_series_bucket = types_aggregations_multi_bucket_base.and(z.object({
    key: z.record(types_field_value)
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_time_series_bucket = z.union([
    z.record(types_aggregations_time_series_bucket),
    z.array(types_aggregations_time_series_bucket)
]);

export const types_aggregations_multi_bucket_aggregate_base_time_series_bucket = types_aggregations_aggregate_base.and(z.object({
    buckets: types_aggregations_buckets_time_series_bucket
}));

export const types_aggregations_time_series_aggregate = types_aggregations_multi_bucket_aggregate_base_time_series_bucket.and(z.record(z.unknown()));

export const types_aggregations_scripted_metric_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.record(z.unknown())
}));

export const global_search_types_total_hits_relation = z.enum(['eq', 'gte']);

export const global_search_types_total_hits = z.object({
    relation: global_search_types_total_hits_relation,
    value: z.number()
});

export const types_index_name = z.string();

export const global_explain_explanation_detail: z.AnyZodObject = z.object({
    description: z.string(),
    details: z.array(z.lazy(() => global_explain_explanation_detail)).optional(),
    value: z.number()
});

export const global_explain_explanation = z.object({
    description: z.string(),
    details: z.array(global_explain_explanation_detail),
    value: z.number()
});

/**
 * Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
 */
export const types_field = z.string().describe('Path to field or array of paths. Some API\'s support wildcards in the path to select multiple fields.');

export const global_search_types_nested_identity: z.AnyZodObject = z.object({
    field: types_field,
    offset: z.number(),
    _nested: z.lazy(() => global_search_types_nested_identity).optional()
});

export const types_sequence_number = z.number();

export const types_version_number = z.number();

export const types_sort_results = z.array(types_field_value);

export const types_aggregations_inference_class_importance = z.object({
    class_name: z.string(),
    importance: z.number()
});

export const types_aggregations_inference_feature_importance = z.object({
    feature_name: z.string(),
    importance: z.number().optional(),
    classes: z.array(types_aggregations_inference_class_importance).optional()
});

export const types_aggregations_inference_top_class_entry = z.object({
    class_name: types_field_value,
    class_probability: z.number(),
    class_score: z.number()
});

export const types_aggregations_inference_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: types_field_value.optional(),
    feature_importance: z.array(types_aggregations_inference_feature_importance).optional(),
    top_classes: z.array(types_aggregations_inference_top_class_entry).optional(),
    warning: z.string().optional()
}));

export const types_aggregations_string_stats_aggregate = types_aggregations_aggregate_base.and(z.object({
    count: z.number(),
    min_length: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    max_length: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    avg_length: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    entropy: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    distribution: z.union([
        z.record(z.number()),
        z.string(),
        z.null()
    ]).optional(),
    min_length_as_string: z.string().optional(),
    max_length_as_string: z.string().optional(),
    avg_length_as_string: z.string().optional()
}));

export const types_aggregations_box_plot_aggregate = types_aggregations_aggregate_base.and(z.object({
    min: z.number(),
    max: z.number(),
    q1: z.number(),
    q2: z.number(),
    q3: z.number(),
    lower: z.number(),
    upper: z.number(),
    min_as_string: z.string().optional(),
    max_as_string: z.string().optional(),
    q1_as_string: z.string().optional(),
    q2_as_string: z.string().optional(),
    q3_as_string: z.string().optional(),
    lower_as_string: z.string().optional(),
    upper_as_string: z.string().optional()
}));

export const types_aggregations_top_metrics = z.object({
    sort: z.array(z.union([
        types_field_value,
        z.string(),
        z.null()
    ])),
    metrics: z.record(z.union([
        types_field_value,
        z.string(),
        z.null()
    ]))
});

export const types_aggregations_top_metrics_aggregate = types_aggregations_aggregate_base.and(z.object({
    top: z.array(types_aggregations_top_metrics)
}));

export const types_aggregations_t_test_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    value_as_string: z.string().optional()
}));

export const types_aggregations_rate_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.number(),
    value_as_string: z.string().optional()
}));

/**
 * Result of the `cumulative_cardinality` aggregation
 */
export const types_aggregations_cumulative_cardinality_aggregate = types_aggregations_aggregate_base.and(z.object({
    value: z.number(),
    value_as_string: z.string().optional()
}));

export const types_aggregations_matrix_stats_fields = z.object({
    name: types_field,
    count: z.number(),
    mean: z.number(),
    variance: z.number(),
    skewness: z.number(),
    kurtosis: z.number(),
    covariance: z.record(z.number()),
    correlation: z.record(z.number())
});

export const types_aggregations_matrix_stats_aggregate = types_aggregations_aggregate_base.and(z.object({
    doc_count: z.number(),
    fields: z.array(types_aggregations_matrix_stats_fields).optional()
}));

/**
 * A GeoJson GeoLine.
 */
export const types_geo_line = z.object({
    type: z.string().describe('Always `"LineString"`'),
    coordinates: z.array(z.array(z.number())).describe('Array of `[lon, lat]` coordinates')
}).describe('A GeoJson GeoLine.');

export const types_aggregations_geo_line_aggregate = types_aggregations_aggregate_base.and(z.object({
    type: z.string(),
    geometry: types_geo_line,
    properties: z.record(z.unknown())
}));

export const types_cluster_search_status = z.enum([
    'running',
    'successful',
    'partial',
    'skipped',
    'failed'
]);

export const types_duration_value_unit_millis = types_unit_millis;

export const types_uint = z.number();

/**
 * Cause and details about a request failure. This class defines the properties common to all error types.
 * Additional details are also provided, that depend on the error type.
 */
export const types_error_cause: z.AnyZodObject = z.object({
    type: z.string().describe('The type of error'),
    reason: z.union([
        z.string(),
        z.null()
    ]).optional(),
    stack_trace: z.string().describe('The server stack trace. Present only if the `error_trace=true` parameter was sent with the request.').optional(),
    caused_by: z.lazy(() => types_error_cause).optional(),
    root_cause: z.array(z.lazy(() => types_error_cause)).optional(),
    suppressed: z.array(z.lazy(() => types_error_cause)).optional()
}).describe('Cause and details about a request failure. This class defines the properties common to all error types.\nAdditional details are also provided, that depend on the error type.');

export const types_shard_failure = z.object({
    index: types_index_name.optional(),
    node: z.string().optional(),
    reason: types_error_cause,
    shard: z.number().optional(),
    status: z.string().optional(),
    primary: z.boolean().optional()
});

export const types_shard_statistics = z.object({
    failed: types_uint,
    successful: types_uint,
    total: types_uint,
    failures: z.array(types_shard_failure).optional(),
    skipped: types_uint.optional()
});

export const types_cluster_details = z.object({
    status: types_cluster_search_status,
    indices: z.string(),
    took: types_duration_value_unit_millis.optional(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics.optional(),
    failures: z.array(types_shard_failure).optional()
});

export const types_cluster_statistics = z.object({
    skipped: z.number(),
    successful: z.number(),
    total: z.number(),
    running: z.number(),
    partial: z.number(),
    failed: z.number(),
    details: z.record(types_cluster_details).optional()
});

export const global_search_types_aggregation_breakdown = z.object({
    build_aggregation: z.number(),
    build_aggregation_count: z.number(),
    build_leaf_collector: z.number(),
    build_leaf_collector_count: z.number(),
    collect: z.number(),
    collect_count: z.number(),
    initialize: z.number(),
    initialize_count: z.number(),
    post_collection: z.number().optional(),
    post_collection_count: z.number().optional(),
    reduce: z.number(),
    reduce_count: z.number()
});

/**
 * Time unit for nanoseconds
 */
export const types_unit_nanos = z.number().describe('Time unit for nanoseconds');

export const types_duration_value_unit_nanos = types_unit_nanos;

export const global_search_types_aggregation_profile_delegate_debug_filter = z.object({
    results_from_metadata: z.number().optional(),
    query: z.string().optional(),
    specialized_for: z.string().optional(),
    segments_counted_in_constant_time: z.number().optional()
});

export const global_search_types_aggregation_profile_debug: z.AnyZodObject = z.object({
    segments_with_multi_valued_ords: z.number().optional(),
    collection_strategy: z.string().optional(),
    segments_with_single_valued_ords: z.number().optional(),
    total_buckets: z.number().optional(),
    built_buckets: z.number().optional(),
    result_strategy: z.string().optional(),
    has_filter: z.boolean().optional(),
    delegate: z.string().optional(),
    delegate_debug: z.lazy(() => global_search_types_aggregation_profile_debug).optional(),
    chars_fetched: z.number().optional(),
    extract_count: z.number().optional(),
    extract_ns: z.number().optional(),
    values_fetched: z.number().optional(),
    collect_analyzed_ns: z.number().optional(),
    collect_analyzed_count: z.number().optional(),
    surviving_buckets: z.number().optional(),
    ordinals_collectors_used: z.number().optional(),
    ordinals_collectors_overhead_too_high: z.number().optional(),
    string_hashing_collectors_used: z.number().optional(),
    numeric_collectors_used: z.number().optional(),
    empty_collectors_used: z.number().optional(),
    deferred_aggregators: z.array(z.string()).optional(),
    segments_with_doc_count_field: z.number().optional(),
    segments_with_deleted_docs: z.number().optional(),
    filters: z.array(global_search_types_aggregation_profile_delegate_debug_filter).optional(),
    segments_counted: z.number().optional(),
    segments_collected: z.number().optional(),
    map_reducer: z.string().optional(),
    brute_force_used: z.number().optional(),
    dynamic_pruning_attempted: z.number().optional(),
    dynamic_pruning_used: z.number().optional(),
    skipped_due_to_no_data: z.number().optional()
});

export const global_search_types_aggregation_profile: z.AnyZodObject = z.object({
    breakdown: global_search_types_aggregation_breakdown,
    description: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    type: z.string(),
    debug: global_search_types_aggregation_profile_debug.optional(),
    children: z.array(z.lazy(() => global_search_types_aggregation_profile)).optional()
});

export const global_search_types_dfs_statistics_breakdown = z.object({
    collection_statistics: z.number(),
    collection_statistics_count: z.number(),
    create_weight: z.number(),
    create_weight_count: z.number(),
    rewrite: z.number(),
    rewrite_count: z.number(),
    term_statistics: z.number(),
    term_statistics_count: z.number()
});

export const global_search_types_dfs_statistics_profile: z.AnyZodObject = z.object({
    type: z.string(),
    description: z.string(),
    time: types_duration.optional(),
    time_in_nanos: types_duration_value_unit_nanos,
    breakdown: global_search_types_dfs_statistics_breakdown,
    debug: z.record(z.record(z.unknown())).optional(),
    children: z.array(z.lazy(() => global_search_types_dfs_statistics_profile)).optional()
});

export const global_search_types_knn_query_profile_breakdown = z.object({
    advance: z.number(),
    advance_count: z.number(),
    build_scorer: z.number(),
    build_scorer_count: z.number(),
    compute_max_score: z.number(),
    compute_max_score_count: z.number(),
    count_weight: z.number(),
    count_weight_count: z.number(),
    create_weight: z.number(),
    create_weight_count: z.number(),
    match: z.number(),
    match_count: z.number(),
    next_doc: z.number(),
    next_doc_count: z.number(),
    score: z.number(),
    score_count: z.number(),
    set_min_competitive_score: z.number(),
    set_min_competitive_score_count: z.number(),
    shallow_advance: z.number(),
    shallow_advance_count: z.number()
});

export const global_search_types_knn_query_profile_result: z.AnyZodObject = z.object({
    type: z.string(),
    description: z.string(),
    time: types_duration.optional(),
    time_in_nanos: types_duration_value_unit_nanos,
    breakdown: global_search_types_knn_query_profile_breakdown,
    debug: z.record(z.record(z.unknown())).optional(),
    children: z.array(z.lazy(() => global_search_types_knn_query_profile_result)).optional()
});

export const global_search_types_knn_collector_result: z.AnyZodObject = z.object({
    name: z.string(),
    reason: z.string(),
    time: types_duration.optional(),
    time_in_nanos: types_duration_value_unit_nanos,
    children: z.array(z.lazy(() => global_search_types_knn_collector_result)).optional()
});

export const global_search_types_dfs_knn_profile = z.object({
    vector_operations_count: z.number().optional(),
    query: z.array(global_search_types_knn_query_profile_result),
    rewrite_time: z.number(),
    collector: z.array(global_search_types_knn_collector_result)
});

export const global_search_types_dfs_profile = z.object({
    statistics: global_search_types_dfs_statistics_profile.optional(),
    knn: z.array(global_search_types_dfs_knn_profile).optional()
});

export const global_search_types_fetch_profile_breakdown = z.object({
    load_source: z.number().optional(),
    load_source_count: z.number().optional(),
    load_stored_fields: z.number().optional(),
    load_stored_fields_count: z.number().optional(),
    next_reader: z.number().optional(),
    next_reader_count: z.number().optional(),
    process_count: z.number().optional(),
    process: z.number().optional()
});

export const global_search_types_fetch_profile_debug = z.object({
    stored_fields: z.array(z.string()).optional(),
    fast_path: z.number().optional()
});

export const global_search_types_fetch_profile: z.AnyZodObject = z.object({
    type: z.string(),
    description: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    breakdown: global_search_types_fetch_profile_breakdown,
    debug: global_search_types_fetch_profile_debug.optional(),
    children: z.array(z.lazy(() => global_search_types_fetch_profile)).optional()
});

export const types_node_id = z.string();

export const global_search_types_collector: z.AnyZodObject = z.object({
    name: z.string(),
    reason: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    children: z.array(z.lazy(() => global_search_types_collector)).optional()
});

export const global_search_types_query_breakdown = z.object({
    advance: z.number(),
    advance_count: z.number(),
    build_scorer: z.number(),
    build_scorer_count: z.number(),
    create_weight: z.number(),
    create_weight_count: z.number(),
    match: z.number(),
    match_count: z.number(),
    shallow_advance: z.number(),
    shallow_advance_count: z.number(),
    next_doc: z.number(),
    next_doc_count: z.number(),
    score: z.number(),
    score_count: z.number(),
    compute_max_score: z.number(),
    compute_max_score_count: z.number(),
    count_weight: z.number(),
    count_weight_count: z.number(),
    set_min_competitive_score: z.number(),
    set_min_competitive_score_count: z.number()
});

export const global_search_types_query_profile: z.AnyZodObject = z.object({
    breakdown: global_search_types_query_breakdown,
    description: z.string(),
    time_in_nanos: types_duration_value_unit_nanos,
    type: z.string(),
    children: z.array(z.lazy(() => global_search_types_query_profile)).optional()
});

export const global_search_types_search_profile = z.object({
    collector: z.array(global_search_types_collector),
    query: z.array(global_search_types_query_profile),
    rewrite_time: z.number()
});

export const global_search_types_shard_profile = z.object({
    aggregations: z.array(global_search_types_aggregation_profile),
    cluster: z.string(),
    dfs: global_search_types_dfs_profile.optional(),
    fetch: global_search_types_fetch_profile.optional(),
    id: z.string(),
    index: types_index_name,
    node_id: types_node_id,
    searches: z.array(global_search_types_search_profile),
    shard_id: z.number()
});

export const global_search_types_profile = z.object({
    shards: z.array(global_search_types_shard_profile)
});

export const types_scroll_id = z.string();

/**
 * Text or location that we want similar documents for or a lookup to a document's field for the text.
 */
export const global_search_types_context = z.union([
    z.string(),
    types_geo_location
]);

export const types_routing = z.string();

export const global_search_types_completion_suggest_option = z.object({
    collate_match: z.boolean().optional(),
    contexts: z.record(z.array(global_search_types_context)).optional(),
    fields: z.record(z.record(z.unknown())).optional(),
    _id: z.string().optional(),
    _index: types_index_name.optional(),
    _routing: types_routing.optional(),
    _score: z.number().optional(),
    _source: z.record(z.unknown()).optional(),
    text: z.string(),
    score: z.number().optional()
});

export const global_search_types_suggest_base = z.object({
    length: z.number(),
    offset: z.number(),
    text: z.string()
});

export const global_search_types_completion_suggest = global_search_types_suggest_base.and(z.object({
    options: z.union([
        global_search_types_completion_suggest_option,
        z.array(global_search_types_completion_suggest_option)
    ])
}));

export const global_search_types_phrase_suggest_option = z.object({
    text: z.string(),
    score: z.number(),
    highlighted: z.string().optional(),
    collate_match: z.boolean().optional()
});

export const global_search_types_phrase_suggest = global_search_types_suggest_base.and(z.object({
    options: z.union([
        global_search_types_phrase_suggest_option,
        z.array(global_search_types_phrase_suggest_option)
    ])
}));

export const global_search_types_term_suggest_option = z.object({
    text: z.string(),
    score: z.number(),
    freq: z.number(),
    highlighted: z.string().optional(),
    collate_match: z.boolean().optional()
});

export const global_search_types_term_suggest = global_search_types_suggest_base.and(z.object({
    options: z.union([
        global_search_types_term_suggest_option,
        z.array(global_search_types_term_suggest_option)
    ])
}));

export const global_search_types_suggest = z.union([
    global_search_types_completion_suggest,
    global_search_types_phrase_suggest,
    global_search_types_term_suggest
]);

/**
 * A date and time, either as a string whose format can depend on the context (defaulting to ISO 8601), or a
 * number of milliseconds since the Epoch. Elasticsearch accepts both as input, but will generally output a string
 * representation.
 */
export const types_date_time = z.union([
    z.string(),
    types_epoch_time_unit_millis
]);

export const async_search_types_async_search_response_base = z.object({
    id: types_id.optional(),
    is_partial: z.boolean().describe('When the query is no longer running, this property indicates whether the search failed or was successfully completed on all shards.\nWhile the query is running, `is_partial` is always set to `true`.'),
    is_running: z.boolean().describe('Indicates whether the search is still running or has completed.\n\n> info\n> If the search failed after some shards returned their results or the node that is coordinating the async search dies, results may be partial even though `is_running` is `false`.'),
    expiration_time: types_date_time.optional(),
    expiration_time_in_millis: types_epoch_time_unit_millis,
    start_time: types_date_time.optional(),
    start_time_in_millis: types_epoch_time_unit_millis,
    completion_time: types_date_time.optional(),
    completion_time_in_millis: types_epoch_time_unit_millis.optional(),
    error: types_error_cause.optional()
});

export const async_search_status_status_response_base = async_search_types_async_search_response_base.and(z.object({
    _shards: types_shard_statistics,
    _clusters: types_cluster_statistics.optional(),
    completion_status: z.number().describe('If the async search completed, this field shows the status code of the search.\nFor example, `200` indicates that the async search was successfully completed.\n`503` indicates that the async search was completed with an error.').optional()
}));

export const types_indices = z.union([
    types_index_name,
    z.array(types_index_name)
]);

export const types_query_dsl_operator = z.enum([
    'and',
    'AND',
    'or',
    'OR'
]);

export const types_fields = z.union([
    types_field,
    z.array(types_field)
]);

export const types_expand_wildcard = z.enum([
    'all',
    'open',
    'closed',
    'hidden',
    'none'
]);

export const types_expand_wildcards = z.union([
    types_expand_wildcard,
    z.array(types_expand_wildcard)
]);

export const types_search_type = z.enum(['query_then_fetch', 'dfs_query_then_fetch']);

export const types_suggest_mode = z.enum([
    'missing',
    'popular',
    'always'
]);

/**
 * Number of hits matching the query to count accurately. If true, the exact
 * number of hits is returned at the cost of some performance. If false, the
 * response does not include the total number of hits matching the query.
 * Defaults to 10,000 hits.
 */
export const global_search_types_track_hits = z.union([
    z.boolean(),
    z.number()
]);

/**
 * Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.
 * Used as a query parameter along with the `_source_includes` and `_source_excludes` parameters.
 */
export const global_search_types_source_config_param = z.union([
    z.boolean(),
    types_fields
]);

/**
 * The minimum number of terms that should match as integer, percentage or range
 */
export const types_minimum_should_match = z.union([
    z.number(),
    z.string()
]);

export const types_query_dsl_query_base = z.object({
    boost: z.number().describe('Floating point number used to decrease or increase the relevance scores of the query.\nBoost values are relative to the default value of 1.0.\nA boost value between 0 and 1.0 decreases the relevance score.\nA value greater than 1.0 increases the relevance score.').optional().default(1),
    _name: z.string().optional()
});

export const types_query_dsl_common_terms_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.string().optional(),
    cutoff_frequency: z.number().optional(),
    high_freq_operator: types_query_dsl_operator.optional(),
    low_freq_operator: types_query_dsl_operator.optional(),
    minimum_should_match: types_minimum_should_match.optional(),
    query: z.string()
}));

export const types_query_dsl_combined_fields_operator = z.enum(['or', 'and']);

export const types_query_dsl_combined_fields_zero_terms = z.enum(['none', 'all']);

export const types_query_dsl_combined_fields_query = types_query_dsl_query_base.and(z.object({
    fields: z.array(types_field).describe('List of fields to search. Field wildcard patterns are allowed. Only `text` fields are supported, and they must all have the same search `analyzer`.'),
    query: z.string().describe('Text to search for in the provided `fields`.\nThe `combined_fields` query analyzes the provided text before performing a search.'),
    auto_generate_synonyms_phrase_query: z.boolean().describe('If true, match phrase queries are automatically created for multi-term synonyms.').optional().default(true),
    operator: types_query_dsl_combined_fields_operator.optional(),
    minimum_should_match: types_minimum_should_match.optional(),
    zero_terms_query: types_query_dsl_combined_fields_zero_terms.optional()
}));

export const types_query_dsl_distance_feature_query_base = types_query_dsl_query_base.and(z.object({
    origin: z.record(z.unknown()).describe('Date or point of origin used to calculate distances.\nIf the `field` value is a `date` or `date_nanos` field, the `origin` value must be a date.\nDate Math, such as `now-1h`, is supported.\nIf the field value is a `geo_point` field, the `origin` value must be a geopoint.'),
    pivot: z.record(z.unknown()).describe('Distance from the `origin` at which relevance scores receive half of the `boost` value.\nIf the `field` value is a `date` or `date_nanos` field, the `pivot` value must be a time unit, such as `1h` or `10d`. If the `field` value is a `geo_point` field, the `pivot` value must be a distance unit, such as `1km` or `12m`.'),
    field: types_field
}));

export const types_query_dsl_untyped_distance_feature_query = types_query_dsl_distance_feature_query_base.and(z.record(z.unknown()));

export const types_distance = z.string();

export const types_query_dsl_distance_feature_query_base_geo_location_distance = types_query_dsl_query_base.and(z.object({
    origin: types_geo_location,
    pivot: types_distance,
    field: types_field
}));

export const types_query_dsl_geo_distance_feature_query = types_query_dsl_distance_feature_query_base_geo_location_distance.and(z.record(z.unknown()));

export const types_date_math = z.string();

export const types_query_dsl_distance_feature_query_base_date_math_duration = types_query_dsl_query_base.and(z.object({
    origin: types_date_math,
    pivot: types_duration,
    field: types_field
}));

export const types_query_dsl_date_distance_feature_query = types_query_dsl_distance_feature_query_base_date_math_duration.and(z.record(z.unknown()));

export const types_query_dsl_distance_feature_query = z.union([
    types_query_dsl_untyped_distance_feature_query,
    types_query_dsl_geo_distance_feature_query,
    types_query_dsl_date_distance_feature_query
]);

export const types_query_dsl_exists_query = types_query_dsl_query_base.and(z.object({
    field: types_field
}));

export const types_query_dsl_function_boost_mode = z.enum([
    'multiply',
    'replace',
    'sum',
    'avg',
    'max',
    'min'
]);

export const types_query_dsl_multi_value_mode = z.enum([
    'min',
    'max',
    'avg',
    'sum'
]);

export const types_query_dsl_decay_function_base = z.object({
    multi_value_mode: types_query_dsl_multi_value_mode.optional()
});

export const types_query_dsl_untyped_decay_function = types_query_dsl_decay_function_base.and(z.record(z.unknown()));

export const types_query_dsl_decay_function_base_date_math_duration = z.object({
    multi_value_mode: types_query_dsl_multi_value_mode.optional()
});

export const types_query_dsl_date_decay_function = types_query_dsl_decay_function_base_date_math_duration.and(z.record(z.unknown()));

export const types_query_dsl_decay_function_basedoubledouble = z.object({
    multi_value_mode: types_query_dsl_multi_value_mode.optional()
});

export const types_query_dsl_numeric_decay_function = types_query_dsl_decay_function_basedoubledouble.and(z.record(z.unknown()));

export const types_query_dsl_decay_function_base_geo_location_distance = z.object({
    multi_value_mode: types_query_dsl_multi_value_mode.optional()
});

export const types_query_dsl_geo_decay_function = types_query_dsl_decay_function_base_geo_location_distance.and(z.record(z.unknown()));

export const types_query_dsl_decay_function = z.union([
    types_query_dsl_untyped_decay_function,
    types_query_dsl_date_decay_function,
    types_query_dsl_numeric_decay_function,
    types_query_dsl_geo_decay_function
]);

export const types_query_dsl_field_value_factor_modifier = z.enum([
    'none',
    'log',
    'log1p',
    'log2p',
    'ln',
    'ln1p',
    'ln2p',
    'square',
    'sqrt',
    'reciprocal'
]);

export const types_query_dsl_field_value_factor_score_function = z.object({
    field: types_field,
    factor: z.number().describe('Optional factor to multiply the field value with.').optional().default(1),
    missing: z.number().describe('Value used if the document doesnt have that field.\nThe modifier and factor are still applied to it as though it were read from the document.').optional(),
    modifier: types_query_dsl_field_value_factor_modifier.optional()
});

export const types_query_dsl_random_score_function = z.object({
    field: types_field.optional(),
    seed: z.union([
        z.number(),
        z.string()
    ]).optional()
});

export const types_name = z.string();

/**
 * A reference to a field with formatting instructions on how to return the value
 */
export const types_query_dsl_field_and_format = z.object({
    field: types_field,
    format: z.string().describe('The format in which the values are returned.').optional(),
    include_unmapped: z.boolean().optional()
}).describe('A reference to a field with formatting instructions on how to return the value');

export const global_search_types_highlighter_encoder = z.enum(['default', 'html']);

export const global_search_types_highlighter_type = z.union([
    z.enum([
        'plain',
        'fvh',
        'unified'
    ]),
    z.string()
]);

export const global_search_types_boundary_scanner = z.enum([
    'chars',
    'sentence',
    'word'
]);

export const global_search_types_highlighter_fragmenter = z.enum(['simple', 'span']);

export const global_search_types_highlighter_order = z.enum(['score']);

export const global_search_types_highlighter_tags_schema = z.enum(['styled']);

export const types_sort_order = z.enum(['asc', 'desc']);

export const types_score_sort = z.object({
    order: types_sort_order.optional()
});

export const types_sort_mode = z.enum([
    'min',
    'max',
    'sum',
    'avg',
    'median'
]);

export const types_geo_distance_type = z.enum(['arc', 'plane']);

export const types_distance_unit = z.enum([
    'in',
    'ft',
    'yd',
    'mi',
    'nmi',
    'km',
    'm',
    'cm',
    'mm'
]);

export const types_script_sort_type = z.enum([
    'string',
    'number',
    'version'
]);

export const global_search_types_source_filter = z.object({
    exclude_vectors: z.boolean().describe('If `true`, vector fields are excluded from the returned source.\n\nThis option takes precedence over `includes`: any vector field will\nremain excluded even if it matches an `includes` rule.').optional(),
    excludes: types_fields.optional(),
    includes: types_fields.optional()
});

/**
 * Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.
 */
export const global_search_types_source_config = z.union([
    z.boolean(),
    global_search_types_source_filter
]);

export const types_query_vector = z.array(z.number());

export const types_text_embedding = z.object({
    model_id: z.string().describe('Model ID is required for all dense_vector fields but\nmay be inferred for semantic_text fields').optional(),
    model_text: z.string()
});

export const types_query_vector_builder = z.object({
    text_embedding: types_text_embedding.optional()
});

export const types_rescore_vector = z.object({
    oversample: z.number().describe('Applies the specified oversample factor to k on the approximate kNN search')
});

export const types_rank_base = z.record(z.unknown());

export const types_rrf_rank = types_rank_base.and(z.object({
    rank_constant: z.number().describe('How much influence documents in individual result sets per query have over the final ranked result set').optional(),
    rank_window_size: z.number().describe('Size of the individual result sets per query').optional()
}));

export const types_rank_container = z.object({
    rrf: types_rrf_rank.optional()
});

export const global_search_types_score_mode = z.enum([
    'avg',
    'max',
    'min',
    'multiply',
    'total'
]);

export const global_search_types_learning_to_rank = z.object({
    model_id: z.string().describe('The unique identifier of the trained model uploaded to Elasticsearch'),
    params: z.record(z.record(z.unknown())).describe('Named parameters to be passed to the query templates used for feature').optional()
});

export const types_mapping_chunk_rescorer_chunking_settings = z.object({
    strategy: z.string().describe('The chunking strategy: `sentence`, `word`, `none` or `recursive`.\n\n * If `strategy` is set to `recursive`, you must also specify:\n\n- `max_chunk_size`\n- either `separators` or`separator_group`\n\nLearn more about different chunking strategies in the linked documentation.').optional().default('sentence'),
    separator_group: z.string().describe('Only applicable to the `recursive` strategy and required when using it.\n\nSets a predefined list of separators in the saved chunking settings based on the selected text type.\nValues can be `markdown` or `plaintext`.\n\nUsing this parameter is an alternative to manually specifying a custom `separators` list.').optional(),
    separators: z.array(z.string()).describe('Only applicable to the `recursive` strategy and required when using it.\n\nA list of strings used as possible split points when chunking text.\n\nEach string can be a plain string or a regular expression (regex) pattern.\nThe system tries each separator in order to split the text, starting from the first item in the list.\n\nAfter splitting, it attempts to recombine smaller pieces into larger chunks that stay within\nthe `max_chunk_size` limit, to reduce the total number of chunks generated.').optional(),
    max_chunk_size: z.number().describe('The maximum size of a chunk in words.\nThis value cannot be lower than `20` (for `sentence` strategy) or `10` (for `word` strategy).\nThis value should not exceed the window size for the associated model.').default(250),
    overlap: z.number().describe('The number of overlapping words for chunks.\nIt is applicable only to a `word` chunking strategy.\nThis value cannot be higher than half the `max_chunk_size` value.').optional().default(100),
    sentence_overlap: z.number().describe('The number of overlapping sentences for chunks.\nIt is applicable only for a `sentence` chunking strategy.\nIt can be either `1` or `0`.').optional().default(1)
});

export const types_chunk_rescorer = z.object({
    size: z.number().describe('The number of chunks per document to evaluate for reranking.').optional(),
    chunking_settings: types_mapping_chunk_rescorer_chunking_settings.optional()
});

export const types_score_normalizer = z.enum([
    'none',
    'minmax',
    'l2_norm'
]);

export const types_specified_document = z.object({
    index: types_index_name.optional(),
    id: types_id
});

export const types_sliced_scroll = z.object({
    field: types_field.optional(),
    id: types_id,
    max: z.number()
});

export const global_search_types_suggester = z.object({
    text: z.string().describe('Global suggest text, to avoid repetition when the same text is used in several suggesters').optional()
});

export const global_search_types_point_in_time_reference = z.object({
    id: types_id,
    keep_alive: types_duration.optional()
});

export const types_mapping_runtime_field_type = z.enum([
    'boolean',
    'composite',
    'date',
    'double',
    'geo_point',
    'geo_shape',
    'ip',
    'keyword',
    'long',
    'lookup'
]);

export const types_mapping_composite_sub_field = z.object({
    type: types_mapping_runtime_field_type
});

export const types_mapping_runtime_field_fetch_fields = z.object({
    field: types_field,
    format: z.string().optional()
});

export const types_script_language = z.union([
    z.enum([
        'painless',
        'expression',
        'mustache',
        'java'
    ]),
    z.string()
]);

export const types_query_dsl_function_score_mode = z.enum([
    'multiply',
    'sum',
    'avg',
    'first',
    'max',
    'min'
]);

export const types_multi_term_query_rewrite = z.string();

export const types_fuzziness = z.union([
    z.string(),
    z.number()
]);

export const types_query_dsl_fuzzy_query = types_query_dsl_query_base.and(z.object({
    max_expansions: z.number().describe('Maximum number of variations created.').optional().default(50),
    prefix_length: z.number().describe('Number of beginning characters left unchanged when creating expansions.').optional().default(0),
    rewrite: types_multi_term_query_rewrite.optional(),
    transpositions: z.boolean().describe('Indicates whether edits include transpositions of two adjacent characters (for example `ab` to `ba`).').optional().default(true),
    fuzziness: types_fuzziness.optional(),
    value: z.union([
        z.string(),
        z.number(),
        z.boolean()
    ])
}));

export const types_query_dsl_geo_execution = z.enum(['memory', 'indexed']);

export const types_query_dsl_geo_validation_method = z.enum([
    'coerce',
    'ignore_malformed',
    'strict'
]);

export const types_query_dsl_geo_bounding_box_query = types_query_dsl_query_base.and(z.object({
    type: types_query_dsl_geo_execution.optional(),
    validation_method: types_query_dsl_geo_validation_method.optional(),
    ignore_unmapped: z.boolean().describe('Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.').optional().default(false)
}));

export const types_query_dsl_geo_distance_query = types_query_dsl_query_base.and(z.object({
    distance: types_distance,
    distance_type: types_geo_distance_type.optional(),
    validation_method: types_query_dsl_geo_validation_method.optional(),
    ignore_unmapped: z.boolean().describe('Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.').optional().default(false)
}));

export const types_query_dsl_geo_grid_query = types_query_dsl_query_base.and(z.object({
    geotile: types_geo_tile.optional(),
    geohash: types_geo_hash.optional(),
    geohex: types_geo_hex_cell.optional()
}));

export const types_query_dsl_geo_polygon_query = types_query_dsl_query_base.and(z.object({
    validation_method: types_query_dsl_geo_validation_method.optional(),
    ignore_unmapped: z.boolean().optional()
}));

export const types_query_dsl_geo_shape_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.boolean().describe('Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.').optional().default(false)
}));

export const types_query_dsl_child_score_mode = z.enum([
    'none',
    'avg',
    'sum',
    'max',
    'min'
]);

export const types_relation_name = z.string();

export const types_ids = z.union([
    types_id,
    z.array(types_id)
]);

export const types_query_dsl_ids_query = types_query_dsl_query_base.and(z.object({
    values: types_ids.optional()
}));

export const types_query_dsl_intervals_fuzzy = z.object({
    analyzer: z.string().describe('Analyzer used to normalize the term.').optional(),
    fuzziness: types_fuzziness.optional(),
    prefix_length: z.number().describe('Number of beginning characters left unchanged when creating expansions.').optional().default(0),
    term: z.string().describe('The term to match.'),
    transpositions: z.boolean().describe('Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`).').optional().default(true),
    use_field: types_field.optional()
});

export const types_query_dsl_intervals_prefix = z.object({
    analyzer: z.string().describe('Analyzer used to analyze the `prefix`.').optional(),
    prefix: z.string().describe('Beginning characters of terms you wish to find in the top-level field.'),
    use_field: types_field.optional()
});

export const types_query_dsl_intervals_range = z.object({
    analyzer: z.string().describe('Analyzer used to analyze the `prefix`.').optional(),
    gte: z.string().describe('Lower term, either gte or gt must be provided.').optional(),
    gt: z.string().describe('Lower term, either gte or gt must be provided.').optional(),
    lte: z.string().describe('Upper term, either lte or lt must be provided.').optional(),
    lt: z.string().describe('Upper term, either lte or lt must be provided.').optional(),
    use_field: types_field.optional()
});

export const types_query_dsl_intervals_regexp = z.object({
    analyzer: z.string().describe('Analyzer used to analyze the `prefix`.').optional(),
    pattern: z.string().describe('Regex pattern.'),
    use_field: types_field.optional()
});

export const types_query_dsl_intervals_wildcard = z.object({
    analyzer: z.string().describe('Analyzer used to analyze the `pattern`.\nDefaults to the top-level field\'s analyzer.').optional(),
    pattern: z.string().describe('Wildcard pattern used to find matching terms.'),
    use_field: types_field.optional()
});

export const types_query_dsl_zero_terms_query = z.enum(['all', 'none']);

export const types_query_dsl_match_query = z.union([
    z.string().describe('Short query syntax for match query'),
    types_query_dsl_query_base.and(z.object({
        analyzer: z.string().describe('Analyzer used to convert the text in the query value into tokens.').optional(),
        auto_generate_synonyms_phrase_query: z.boolean().describe('If `true`, match phrase queries are automatically created for multi-term synonyms.').optional().default(true),
        cutoff_frequency: z.number().optional(),
        fuzziness: types_fuzziness.optional(),
        fuzzy_rewrite: types_multi_term_query_rewrite.optional(),
        fuzzy_transpositions: z.boolean().describe('If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).').optional().default(true),
        lenient: z.boolean().describe('If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.').optional().default(false),
        max_expansions: z.number().describe('Maximum number of terms to which the query will expand.').optional().default(50),
        minimum_should_match: types_minimum_should_match.optional(),
        operator: types_query_dsl_operator.optional(),
        prefix_length: z.number().describe('Number of beginning characters left unchanged for fuzzy matching.').optional().default(0),
        query: z.union([
            z.string(),
            z.number(),
            z.boolean()
        ]),
        zero_terms_query: types_query_dsl_zero_terms_query.optional()
    }))
]);

export const types_query_dsl_match_all_query = types_query_dsl_query_base.and(z.record(z.unknown()));

export const types_query_dsl_match_bool_prefix_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.string().describe('Analyzer used to convert the text in the query value into tokens.').optional(),
    fuzziness: types_fuzziness.optional(),
    fuzzy_rewrite: types_multi_term_query_rewrite.optional(),
    fuzzy_transpositions: z.boolean().describe('If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.').optional().default(true),
    max_expansions: z.number().describe('Maximum number of terms to which the query will expand.\nCan be applied to the term subqueries constructed for all terms but the final term.').optional().default(50),
    minimum_should_match: types_minimum_should_match.optional(),
    operator: types_query_dsl_operator.optional(),
    prefix_length: z.number().describe('Number of beginning characters left unchanged for fuzzy matching.\nCan be applied to the term subqueries constructed for all terms but the final term.').optional().default(0),
    query: z.string().describe('Terms you wish to find in the provided field.\nThe last term is used in a prefix query.')
}));

export const types_query_dsl_match_none_query = types_query_dsl_query_base.and(z.record(z.unknown()));

export const types_query_dsl_match_phrase_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.string().describe('Analyzer used to convert the text in the query value into tokens.').optional(),
    query: z.string().describe('Query terms that are analyzed and turned into a phrase query.'),
    slop: z.number().describe('Maximum number of positions allowed between matching tokens.').optional().default(0),
    zero_terms_query: types_query_dsl_zero_terms_query.optional()
}));

export const types_query_dsl_match_phrase_prefix_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.string().describe('Analyzer used to convert text in the query value into tokens.').optional(),
    max_expansions: z.number().describe('Maximum number of terms to which the last provided term of the query value will expand.').optional().default(50),
    query: z.string().describe('Text you wish to find in the provided field.'),
    slop: z.number().describe('Maximum number of positions allowed between matching tokens.').optional().default(0),
    zero_terms_query: types_query_dsl_zero_terms_query.optional()
}));

export const types_version_type = z.enum([
    'internal',
    'external',
    'external_gte'
]);

export const types_query_dsl_like_document = z.object({
    doc: z.record(z.unknown()).describe('A document not present in the index.').optional(),
    fields: z.array(types_field).optional(),
    _id: types_id.optional(),
    _index: types_index_name.optional(),
    per_field_analyzer: z.record(z.string()).describe('Overrides the default analyzer.').optional(),
    routing: types_routing.optional(),
    version: types_version_number.optional(),
    version_type: types_version_type.optional()
});

/**
 * Text that we want similar documents for or a lookup to a document's field for the text.
 */
export const types_query_dsl_like = z.union([
    z.string(),
    types_query_dsl_like_document
]);

export const types_analysis_stop_word_language = z.enum([
    '_arabic_',
    '_armenian_',
    '_basque_',
    '_bengali_',
    '_brazilian_',
    '_bulgarian_',
    '_catalan_',
    '_cjk_',
    '_czech_',
    '_danish_',
    '_dutch_',
    '_english_',
    '_estonian_',
    '_finnish_',
    '_french_',
    '_galician_',
    '_german_',
    '_greek_',
    '_hindi_',
    '_hungarian_',
    '_indonesian_',
    '_irish_',
    '_italian_',
    '_latvian_',
    '_lithuanian_',
    '_norwegian_',
    '_persian_',
    '_portuguese_',
    '_romanian_',
    '_russian_',
    '_serbian_',
    '_sorani_',
    '_spanish_',
    '_swedish_',
    '_thai_',
    '_turkish_',
    '_none_'
]);

/**
 * Language value, such as _arabic_ or _thai_. Defaults to _english_.
 * Each language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words.
 * Also accepts an array of stop words.
 */
export const types_analysis_stop_words = z.union([
    types_analysis_stop_word_language,
    z.array(z.string())
]);

export const types_query_dsl_more_like_this_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.string().describe('The analyzer that is used to analyze the free form text.\nDefaults to the analyzer associated with the first field in fields.').optional(),
    boost_terms: z.number().describe('Each term in the formed query could be further boosted by their tf-idf score.\nThis sets the boost factor to use when using this feature.\nDefaults to deactivated (0).').optional().default(0),
    fail_on_unsupported_field: z.boolean().describe('Controls whether the query should fail (throw an exception) if any of the specified fields are not of the supported types (`text` or `keyword`).').optional().default(true),
    fields: z.array(types_field).describe('A list of fields to fetch and analyze the text from.\nDefaults to the `index.query.default_field` index setting, which has a default value of `*`.').optional(),
    include: z.boolean().describe('Specifies whether the input documents should also be included in the search results returned.').optional().default(false),
    like: z.union([
        types_query_dsl_like,
        z.array(types_query_dsl_like)
    ]),
    max_doc_freq: z.number().describe('The maximum document frequency above which the terms are ignored from the input document.').optional(),
    max_query_terms: z.number().describe('The maximum number of query terms that can be selected.').optional().default(25),
    max_word_length: z.number().describe('The maximum word length above which the terms are ignored.\nDefaults to unbounded (`0`).').optional().default(0),
    min_doc_freq: z.number().describe('The minimum document frequency below which the terms are ignored from the input document.').optional().default(5),
    minimum_should_match: types_minimum_should_match.optional(),
    min_term_freq: z.number().describe('The minimum term frequency below which the terms are ignored from the input document.').optional().default(2),
    min_word_length: z.number().describe('The minimum word length below which the terms are ignored.').optional().default(0),
    routing: types_routing.optional(),
    stop_words: types_analysis_stop_words.optional(),
    unlike: z.union([
        types_query_dsl_like,
        z.array(types_query_dsl_like)
    ]).optional(),
    version: types_version_number.optional(),
    version_type: types_version_type.optional()
}));

export const types_query_dsl_text_query_type = z.enum([
    'best_fields',
    'most_fields',
    'cross_fields',
    'phrase',
    'phrase_prefix',
    'bool_prefix'
]);

export const types_query_dsl_multi_match_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.string().describe('Analyzer used to convert the text in the query value into tokens.').optional(),
    auto_generate_synonyms_phrase_query: z.boolean().describe('If `true`, match phrase queries are automatically created for multi-term synonyms.').optional().default(true),
    cutoff_frequency: z.number().optional(),
    fields: types_fields.optional(),
    fuzziness: types_fuzziness.optional(),
    fuzzy_rewrite: types_multi_term_query_rewrite.optional(),
    fuzzy_transpositions: z.boolean().describe('If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.').optional().default(true),
    lenient: z.boolean().describe('If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.').optional().default(false),
    max_expansions: z.number().describe('Maximum number of terms to which the query will expand.').optional().default(50),
    minimum_should_match: types_minimum_should_match.optional(),
    operator: types_query_dsl_operator.optional(),
    prefix_length: z.number().describe('Number of beginning characters left unchanged for fuzzy matching.').optional().default(0),
    query: z.string().describe('Text, number, boolean value or date you wish to find in the provided field.'),
    slop: z.number().describe('Maximum number of positions allowed between matching tokens.').optional().default(0),
    tie_breaker: z.number().describe('Determines how scores for each per-term blended query and scores across groups are combined.').optional().default(0),
    type: types_query_dsl_text_query_type.optional(),
    zero_terms_query: types_query_dsl_zero_terms_query.optional()
}));

export const types_query_dsl_parent_id_query = types_query_dsl_query_base.and(z.object({
    id: types_id.optional(),
    ignore_unmapped: z.boolean().describe('Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.').optional().default(false),
    type: types_relation_name.optional()
}));

export const types_query_dsl_percolate_query = types_query_dsl_query_base.and(z.object({
    document: z.record(z.unknown()).describe('The source of the document being percolated.').optional(),
    documents: z.array(z.record(z.unknown())).describe('An array of sources of the documents being percolated.').optional(),
    field: types_field,
    id: types_id.optional(),
    index: types_index_name.optional(),
    name: z.string().describe('The suffix used for the `_percolator_document_slot` field when multiple `percolate` queries are specified.').optional(),
    preference: z.string().describe('Preference used to fetch document to percolate.').optional(),
    routing: types_routing.optional(),
    version: types_version_number.optional()
}));

export const types_query_dsl_pinned_doc = z.object({
    _id: types_id,
    _index: types_index_name.optional()
});

export const types_query_dsl_prefix_query = types_query_dsl_query_base.and(z.object({
    rewrite: types_multi_term_query_rewrite.optional(),
    value: z.string().describe('Beginning characters of terms you wish to find in the provided field.'),
    case_insensitive: z.boolean().describe('Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nDefault is `false` which means the case sensitivity of matching depends on the underlying fields mapping.').optional().default(false)
}));

export const types_time_zone = z.string();

export const types_query_dsl_query_string_query = types_query_dsl_query_base.and(z.object({
    allow_leading_wildcard: z.boolean().describe('If `true`, the wildcard characters `*` and `?` are allowed as the first character of the query string.').optional().default(true),
    analyzer: z.string().describe('Analyzer used to convert text in the query string into tokens.').optional(),
    analyze_wildcard: z.boolean().describe('If `true`, the query attempts to analyze wildcard terms in the query string.').optional().default(false),
    auto_generate_synonyms_phrase_query: z.boolean().describe('If `true`, match phrase queries are automatically created for multi-term synonyms.').optional().default(true),
    default_field: types_field.optional(),
    default_operator: types_query_dsl_operator.optional(),
    enable_position_increments: z.boolean().describe('If `true`, enable position increments in queries constructed from a `query_string` search.').optional().default(true),
    escape: z.boolean().optional().default(false),
    fields: z.array(types_field).describe('Array of fields to search. Supports wildcards (`*`).').optional(),
    fuzziness: types_fuzziness.optional(),
    fuzzy_max_expansions: z.number().describe('Maximum number of terms to which the query expands for fuzzy matching.').optional().default(50),
    fuzzy_prefix_length: z.number().describe('Number of beginning characters left unchanged for fuzzy matching.').optional().default(0),
    fuzzy_rewrite: types_multi_term_query_rewrite.optional(),
    fuzzy_transpositions: z.boolean().describe('If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).').optional().default(true),
    lenient: z.boolean().describe('If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.').optional().default(false),
    max_determinized_states: z.number().describe('Maximum number of automaton states required for the query.').optional().default(10000),
    minimum_should_match: types_minimum_should_match.optional(),
    phrase_slop: z.number().describe('Maximum number of positions allowed between matching tokens for phrases.').optional().default(0),
    query: z.string().describe('Query string you wish to parse and use for search.'),
    quote_analyzer: z.string().describe('Analyzer used to convert quoted text in the query string into tokens.\nFor quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter.').optional(),
    quote_field_suffix: z.string().describe('Suffix appended to quoted text in the query string.\nYou can use this suffix to use a different analysis method for exact matches.').optional(),
    rewrite: types_multi_term_query_rewrite.optional(),
    tie_breaker: z.number().describe('How to combine the queries generated from the individual search terms in the resulting `dis_max` query.').optional(),
    time_zone: types_time_zone.optional(),
    type: types_query_dsl_text_query_type.optional()
}));

export const types_date_format = z.string();

export const types_query_dsl_range_relation = z.enum([
    'within',
    'contains',
    'intersects'
]);

export const types_query_dsl_range_query_base = types_query_dsl_query_base.and(z.object({
    relation: types_query_dsl_range_relation.optional(),
    gt: z.record(z.unknown()).describe('Greater than.').optional(),
    gte: z.record(z.unknown()).describe('Greater than or equal to.').optional(),
    lt: z.record(z.unknown()).describe('Less than.').optional(),
    lte: z.record(z.unknown()).describe('Less than or equal to.').optional()
}));

export const types_query_dsl_untyped_range_query = types_query_dsl_range_query_base.and(z.object({
    format: types_date_format.optional(),
    time_zone: types_time_zone.optional()
}));

export const types_query_dsl_range_query_base_date_math = types_query_dsl_query_base.and(z.object({
    relation: types_query_dsl_range_relation.optional(),
    gt: types_date_math.optional(),
    gte: types_date_math.optional(),
    lt: types_date_math.optional(),
    lte: types_date_math.optional()
}));

export const types_query_dsl_date_range_query = types_query_dsl_range_query_base_date_math.and(z.object({
    format: types_date_format.optional(),
    time_zone: types_time_zone.optional()
}));

export const types_query_dsl_range_query_basedouble = types_query_dsl_query_base.and(z.object({
    relation: types_query_dsl_range_relation.optional(),
    gt: z.number().describe('Greater than.').optional(),
    gte: z.number().describe('Greater than or equal to.').optional(),
    lt: z.number().describe('Less than.').optional(),
    lte: z.number().describe('Less than or equal to.').optional()
}));

export const types_query_dsl_number_range_query = types_query_dsl_range_query_basedouble.and(z.record(z.unknown()));

export const types_query_dsl_range_query_basestring = types_query_dsl_query_base.and(z.object({
    relation: types_query_dsl_range_relation.optional(),
    gt: z.string().describe('Greater than.').optional(),
    gte: z.string().describe('Greater than or equal to.').optional(),
    lt: z.string().describe('Less than.').optional(),
    lte: z.string().describe('Less than or equal to.').optional()
}));

export const types_query_dsl_term_range_query = types_query_dsl_range_query_basestring.and(z.record(z.unknown()));

export const types_query_dsl_range_query = z.union([
    types_query_dsl_untyped_range_query,
    types_query_dsl_date_range_query,
    types_query_dsl_number_range_query,
    types_query_dsl_term_range_query
]);

export const types_query_dsl_rank_feature_function = z.record(z.unknown());

export const types_query_dsl_rank_feature_function_saturation = types_query_dsl_rank_feature_function.and(z.object({
    pivot: z.number().describe('Configurable pivot value so that the result will be less than 0.5.').optional()
}));

export const types_query_dsl_rank_feature_function_logarithm = types_query_dsl_rank_feature_function.and(z.object({
    scaling_factor: z.number().describe('Configurable scaling factor.')
}));

export const types_query_dsl_rank_feature_function_linear = types_query_dsl_rank_feature_function.and(z.record(z.unknown()));

export const types_query_dsl_rank_feature_function_sigmoid = types_query_dsl_rank_feature_function.and(z.object({
    pivot: z.number().describe('Configurable pivot value so that the result will be less than 0.5.'),
    exponent: z.number().describe('Configurable Exponent.')
}));

export const types_query_dsl_rank_feature_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    saturation: types_query_dsl_rank_feature_function_saturation.optional(),
    log: types_query_dsl_rank_feature_function_logarithm.optional(),
    linear: types_query_dsl_rank_feature_function_linear.optional(),
    sigmoid: types_query_dsl_rank_feature_function_sigmoid.optional()
}));

export const types_query_dsl_regexp_query = types_query_dsl_query_base.and(z.object({
    case_insensitive: z.boolean().describe('Allows case insensitive matching of the regular expression value with the indexed field values when set to `true`.\nWhen `false`, case sensitivity of matching depends on the underlying fields mapping.').optional().default(false),
    flags: z.string().describe('Enables optional operators for the regular expression.').optional(),
    max_determinized_states: z.number().describe('Maximum number of automaton states required for the query.').optional().default(10000),
    rewrite: types_multi_term_query_rewrite.optional(),
    value: z.string().describe('Regular expression for terms you wish to find in the provided field.')
}));

export const types_query_dsl_semantic_query = types_query_dsl_query_base.and(z.object({
    field: z.string().describe('The field to query, which must be a semantic_text field type'),
    query: z.string().describe('The query text')
}));

export const types_query_dsl_shape_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.boolean().describe('When set to `true` the query ignores an unmapped field and will not match any documents.').optional()
}));

export const types_query_dsl_simple_query_string_flag = z.enum([
    'NONE',
    'AND',
    'NOT',
    'OR',
    'PREFIX',
    'PHRASE',
    'PRECEDENCE',
    'ESCAPE',
    'WHITESPACE',
    'FUZZY',
    'NEAR',
    'SLOP',
    'ALL'
]);

/**
 * A set of flags that can be represented as a single enum value or a set of values that are encoded
 * as a pipe-separated string
 *
 * Depending on the target language, code generators can use this hint to generate language specific
 * flags enum constructs and the corresponding (de-)serialization code.
 */
export const spec_utils_pipe_separated_flags_simple_query_string_flag = z.union([
    types_query_dsl_simple_query_string_flag,
    z.string()
]);

/**
 * Query flags can be either a single flag or a combination of flags, e.g. `OR|AND|PREFIX`
 */
export const types_query_dsl_simple_query_string_flags = spec_utils_pipe_separated_flags_simple_query_string_flag;

export const types_query_dsl_simple_query_string_query = types_query_dsl_query_base.and(z.object({
    analyzer: z.string().describe('Analyzer used to convert text in the query string into tokens.').optional(),
    analyze_wildcard: z.boolean().describe('If `true`, the query attempts to analyze wildcard terms in the query string.').optional().default(false),
    auto_generate_synonyms_phrase_query: z.boolean().describe('If `true`, the parser creates a match_phrase query for each multi-position token.').optional().default(true),
    default_operator: types_query_dsl_operator.optional(),
    fields: z.array(types_field).describe('Array of fields you wish to search.\nAccepts wildcard expressions.\nYou also can boost relevance scores for matches to particular fields using a caret (`^`) notation.\nDefaults to the `index.query.default_field index` setting, which has a default value of `*`.').optional(),
    flags: types_query_dsl_simple_query_string_flags.optional(),
    fuzzy_max_expansions: z.number().describe('Maximum number of terms to which the query expands for fuzzy matching.').optional().default(50),
    fuzzy_prefix_length: z.number().describe('Number of beginning characters left unchanged for fuzzy matching.').optional().default(0),
    fuzzy_transpositions: z.boolean().describe('If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).').optional(),
    lenient: z.boolean().describe('If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.').optional().default(false),
    minimum_should_match: types_minimum_should_match.optional(),
    query: z.string().describe('Query string in the simple query string syntax you wish to parse and use for search.'),
    quote_field_suffix: z.string().describe('Suffix appended to quoted text in the query string.').optional()
}));

/**
 * Can only be used as a clause in a span_near query.
 */
export const types_query_dsl_span_gap_query = z.record(z.number()).describe('Can only be used as a clause in a span_near query.');

export const types_query_dsl_span_term_query = types_query_dsl_query_base.and(z.object({
    value: types_field_value
}));

export const types_token_pruning_config = z.object({
    tokens_freq_ratio_threshold: z.number().describe('Tokens whose frequency is more than this threshold times the average frequency of all tokens in the specified field are considered outliers and pruned.').optional().default(5),
    tokens_weight_threshold: z.number().describe('Tokens whose weight is less than this threshold are considered nonsignificant and pruned.').optional().default(0.4),
    only_score_pruned_tokens: z.boolean().describe('Whether to only score pruned tokens, vs only scoring kept tokens.').optional().default(false)
});

export const types_query_dsl_sparse_vector_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    query: z.string().describe('The query text you want to use for search.\nIf inference_id is specified, query must also be specified.').optional(),
    prune: z.boolean().describe('Whether to perform pruning, omitting the non-significant tokens from the query to improve query performance.\nIf prune is true but the pruning_config is not specified, pruning will occur but default values will be used.\nDefault: false').optional(),
    pruning_config: types_token_pruning_config.optional()
}).and(z.object({
    query_vector: z.record(z.number()).describe('Dictionary of precomputed sparse vectors and their associated weights.\nOnly one of inference_id or query_vector may be supplied in a request.').optional(),
    inference_id: types_id.optional()
})));

export const types_query_dsl_term_query = z.union([
    z.string().describe('Short query syntax for match query'),
    types_query_dsl_query_base.and(z.object({
        value: types_field_value,
        case_insensitive: z.boolean().describe('Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nWhen `false`, the case sensitivity of matching depends on the underlying fields mapping.').optional().default(false)
    }))
]);

export const types_query_dsl_terms_query = types_query_dsl_query_base.and(z.record(z.unknown()));

export const types_query_dsl_text_expansion_query = types_query_dsl_query_base.and(z.object({
    model_id: z.string().describe('The text expansion NLP model to use'),
    model_text: z.string().describe('The query text'),
    pruning_config: types_token_pruning_config.optional()
}));

export const types_query_dsl_weighted_tokens_query = types_query_dsl_query_base.and(z.object({
    tokens: z.union([
        z.record(z.number()),
        z.array(z.record(z.number()))
    ]),
    pruning_config: types_token_pruning_config.optional()
}));

export const types_query_dsl_wildcard_query = types_query_dsl_query_base.and(z.object({
    case_insensitive: z.boolean().describe('Allows case insensitive matching of the pattern with the indexed field values when set to true. Default is false which means the case sensitivity of matching depends on the underlying fields mapping.').optional(),
    rewrite: types_multi_term_query_rewrite.optional(),
    value: z.string().describe('Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set.').optional(),
    wildcard: z.string().describe('Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set.').optional()
}));

export const types_query_dsl_wrapper_query = types_query_dsl_query_base.and(z.object({
    query: z.string().describe('A base64 encoded query.\nThe binary data format can be any of JSON, YAML, CBOR or SMILE encodings')
}));

export const types_query_dsl_type_query = types_query_dsl_query_base.and(z.object({
    value: z.string()
}));

export const types_aggregations_aggregation = z.record(z.unknown());

/**
 * Base type for bucket aggregations. These aggregations also accept sub-aggregations.
 */
export const types_aggregations_bucket_aggregation_base = types_aggregations_aggregation.and(z.record(z.unknown()));

export const types_aggregations_minimum_interval = z.enum([
    'second',
    'minute',
    'hour',
    'day',
    'month',
    'year'
]);

export const types_aggregations_missing = z.union([
    z.string(),
    z.number(),
    z.boolean()
]);

export const types_aggregations_gap_policy = z.enum([
    'skip',
    'insert_zeros',
    'keep_values'
]);

/**
 * Buckets path can be expressed in different ways, and an aggregation may accept some or all of these
 * forms depending on its type. Please refer to each aggregation's documentation to know what buckets
 * path forms they accept.
 */
export const types_aggregations_buckets_path = z.union([
    z.string(),
    z.array(z.string()),
    z.record(z.string())
]);

export const types_aggregations_bucket_path_aggregation = types_aggregations_aggregation.and(z.object({
    buckets_path: types_aggregations_buckets_path.optional()
}));

export const types_aggregations_pipeline_aggregation_base = types_aggregations_bucket_path_aggregation.and(z.object({
    format: z.string().describe('`DecimalFormat` pattern for the output value.\nIf specified, the formatted value is returned in the aggregations `value_as_string` property.').optional(),
    gap_policy: types_aggregations_gap_policy.optional()
}));

export const types_aggregations_average_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_t_digest_execution_hint = z.enum(['default', 'high_accuracy']);

/**
 * A sibling pipeline aggregation which executes a two sample KolmogorovSmirnov test (referred
 * to as a "K-S test" from now on) against a provided distribution, and the distribution implied
 * by the documents counts in the configured sibling aggregation. Specifically, for some metric,
 * assuming that the percentile intervals of the metric are known beforehand or have been computed
 * by an aggregation, then one would use range aggregation for the sibling to compute the p-value
 * of the distribution difference between the metric and the restriction of that metric to a subset
 * of the documents. A natural use case is if the sibling aggregation range aggregation nested in a
 * terms aggregation, in which case one compares the overall distribution of metric to its restriction
 * to each term.
 */
export const types_aggregations_bucket_ks_aggregation = types_aggregations_bucket_path_aggregation.and(z.object({
    alternative: z.array(z.string()).describe('A list of string values indicating which K-S test alternative to calculate. The valid values\nare: "greater", "less", "two_sided". This parameter is key for determining the K-S statistic used\nwhen calculating the K-S test. Default value is all possible alternative hypotheses.').optional(),
    fractions: z.array(z.number()).describe('A list of doubles indicating the distribution of the samples with which to compare to the `buckets_path` results.\nIn typical usage this is the overall proportion of documents in each bucket, which is compared with the actual\ndocument proportions in each bucket from the sibling aggregation counts. The default is to assume that overall\ndocuments are uniformly distributed on these buckets, which they would be if one used equal percentiles of a\nmetric to define the bucket end points.').optional(),
    sampling_method: z.string().describe('Indicates the sampling methodology when calculating the K-S test. Note, this is sampling of the returned values.\nThis determines the cumulative distribution function (CDF) points used comparing the two samples. Default is\n`upper_tail`, which emphasizes the upper end of the CDF points. Valid options are: `upper_tail`, `uniform`,\nand `lower_tail`.').optional()
}));

export const types_aggregations_bucket_correlation_function_count_correlation_indicator = z.object({
    doc_count: z.number().describe('The total number of documents that initially created the expectations. Its required to be greater\nthan or equal to the sum of all values in the buckets_path as this is the originating superset of data\nto which the term values are correlated.'),
    expectations: z.array(z.number()).describe('An array of numbers with which to correlate the configured `bucket_path` values.\nThe length of this value must always equal the number of buckets returned by the `bucket_path`.'),
    fractions: z.array(z.number()).describe('An array of fractions to use when averaging and calculating variance. This should be used if\nthe pre-calculated data and the buckets_path have known gaps. The length of fractions, if provided,\nmust equal expectations.').optional()
});

export const types_aggregations_bucket_correlation_function_count_correlation = z.object({
    indicator: types_aggregations_bucket_correlation_function_count_correlation_indicator
});

export const types_aggregations_bucket_correlation_function = z.object({
    count_correlation: types_aggregations_bucket_correlation_function_count_correlation
});

/**
 * A sibling pipeline aggregation which executes a correlation function on the configured sibling multi-bucket aggregation.
 */
export const types_aggregations_bucket_correlation_aggregation = types_aggregations_bucket_path_aggregation.and(z.object({
    function: types_aggregations_bucket_correlation_function
}));

export const types_aggregations_cardinality_execution_mode = z.enum([
    'global_ordinals',
    'segment_ordinals',
    'direct',
    'save_memory_heuristic',
    'save_time_heuristic'
]);

export const types_aggregations_custom_categorize_text_analyzer = z.object({
    char_filter: z.array(z.string()).optional(),
    tokenizer: z.string().optional(),
    filter: z.array(z.string()).optional()
});

export const types_aggregations_categorize_text_analyzer = z.union([
    z.string(),
    types_aggregations_custom_categorize_text_analyzer
]);

/**
 * A multi-bucket aggregation that groups semi-structured text into buckets. Each text
 * field is re-analyzed using a custom analyzer. The resulting tokens are then categorized
 * creating buckets of similarly formatted text values. This aggregation works best with machine
 * generated text like system logs. Only the first 100 analyzed tokens are used to categorize the text.
 */
export const types_aggregations_categorize_text_aggregation = types_aggregations_aggregation.and(z.object({
    field: types_field,
    max_unique_tokens: z.number().describe('The maximum number of unique tokens at any position up to max_matched_tokens. Must be larger than 1.\nSmaller values use less memory and create fewer categories. Larger values will use more memory and\ncreate narrower categories. Max allowed value is 100.').optional().default(50),
    max_matched_tokens: z.number().describe('The maximum number of token positions to match on before attempting to merge categories. Larger\nvalues will use more memory and create narrower categories. Max allowed value is 100.').optional().default(5),
    similarity_threshold: z.number().describe('The minimum percentage of tokens that must match for text to be added to the category bucket. Must\nbe between 1 and 100. The larger the value the narrower the categories. Larger values will increase memory\nusage and create narrower categories.').optional().default(50),
    categorization_filters: z.array(z.string()).describe('This property expects an array of regular expressions. The expressions are used to filter out matching\nsequences from the categorization field values. You can use this functionality to fine tune the categorization\nby excluding sequences from consideration when categories are defined. For example, you can exclude SQL\nstatements that appear in your log files. This property cannot be used at the same time as categorization_analyzer.\nIf you only want to define simple regular expression filters that are applied prior to tokenization, setting\nthis property is the easiest method. If you also want to customize the tokenizer or post-tokenization filtering,\nuse the categorization_analyzer property instead and include the filters as pattern_replace character filters.').optional(),
    categorization_analyzer: types_aggregations_categorize_text_analyzer.optional(),
    shard_size: z.number().describe('The number of categorization buckets to return from each shard before merging all the results.').optional(),
    size: z.number().describe('The number of buckets to return.').optional().default(10),
    min_doc_count: z.number().describe('The minimum number of documents in a bucket to be returned to the results.').optional(),
    shard_min_doc_count: z.number().describe('The minimum number of documents in a bucket to be returned from the shard before merging.').optional()
}));

export const types_aggregations_change_point_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_children_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    type: types_relation_name.optional()
}));

export const types_aggregations_missing_order = z.enum([
    'first',
    'last',
    'default'
]);

export const types_aggregations_value_type = z.enum([
    'string',
    'long',
    'double',
    'number',
    'date',
    'date_nanos',
    'ip',
    'numeric',
    'geo_point',
    'boolean'
]);

export const types_aggregations_cumulative_cardinality_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_cumulative_sum_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_calendar_interval = z.enum([
    'second',
    '1s',
    'minute',
    '1m',
    'hour',
    '1h',
    'day',
    '1d',
    'week',
    '1w',
    'month',
    '1M',
    'quarter',
    '1q',
    'year',
    '1y'
]);

/**
 * A date range limit, represented either as a DateMath expression or a number expressed
 * according to the target field's precision.
 */
export const types_aggregations_field_date_math = z.union([
    types_date_math,
    z.number()
]);

export const types_aggregations_extended_bounds_field_date_math = z.object({
    max: types_aggregations_field_date_math.optional(),
    min: types_aggregations_field_date_math.optional()
});

export const types_aggregations_aggregate_order = z.union([
    z.record(types_sort_order),
    z.array(z.record(types_sort_order))
]);

export const types_aggregations_date_range_expression = z.object({
    from: types_aggregations_field_date_math.optional(),
    key: z.string().describe('Custom key to return the range with.').optional(),
    to: types_aggregations_field_date_math.optional()
});

export const types_aggregations_date_range_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field.optional(),
    format: z.string().describe('The date format used to format `from` and `to` in the response.').optional(),
    missing: types_aggregations_missing.optional(),
    ranges: z.array(types_aggregations_date_range_expression).describe('Array of date ranges.').optional(),
    time_zone: types_time_zone.optional(),
    keyed: z.boolean().describe('Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array.').optional()
}));

export const types_aggregations_derivative_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_sampler_aggregation_execution_hint = z.enum([
    'map',
    'global_ordinals',
    'bytes_hash'
]);

export const types_aggregations_extended_stats_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    sigma: z.number().describe('The number of standard deviations above/below the mean to display.').optional()
}));

export const types_aggregations_terms_exclude = z.union([
    z.string(),
    z.array(z.string())
]);

export const types_aggregations_terms_partition = z.object({
    num_partitions: z.number().describe('The number of partitions.'),
    partition: z.number().describe('The partition number for this request.')
});

export const types_aggregations_terms_include = z.union([
    z.string(),
    z.array(z.string()),
    types_aggregations_terms_partition
]);

export const types_aggregations_frequent_item_sets_field = z.object({
    field: types_field,
    exclude: types_aggregations_terms_exclude.optional(),
    include: types_aggregations_terms_include.optional()
});

export const types_aggregations_aggregation_range = z.object({
    from: z.union([
        z.number(),
        z.string(),
        z.null()
    ]).optional(),
    key: z.string().describe('Custom key to return the range with.').optional(),
    to: z.union([
        z.number(),
        z.string(),
        z.null()
    ]).optional()
});

export const types_aggregations_geo_distance_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    distance_type: types_geo_distance_type.optional(),
    field: types_field.optional(),
    origin: types_geo_location.optional(),
    ranges: z.array(types_aggregations_aggregation_range).describe('An array of ranges used to bucket documents.').optional(),
    unit: types_distance_unit.optional()
}));

/**
 * A precision that can be expressed as a geohash length between 1 and 12, or a distance measure like "1km", "10m".
 */
export const types_geo_hash_precision = z.union([
    z.number(),
    z.string()
]);

export const types_aggregations_geo_hash_grid_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    bounds: types_geo_bounds.optional(),
    field: types_field.optional(),
    precision: types_geo_hash_precision.optional(),
    shard_size: z.number().describe('Allows for more accurate counting of the top cells returned in the final result the aggregation.\nDefaults to returning `max(10,(size x number-of-shards))` buckets from each shard.').optional(),
    size: z.number().describe('The maximum number of geohash buckets to return.').optional().default(10000)
}));

export const types_aggregations_geo_line_point = z.object({
    field: types_field
});

export const types_aggregations_geo_line_sort = z.object({
    field: types_field
});

export const types_aggregations_geo_line_aggregation = z.object({
    point: types_aggregations_geo_line_point,
    sort: types_aggregations_geo_line_sort.optional(),
    include_sort: z.boolean().describe('When `true`, returns an additional array of the sort values in the feature properties.').optional(),
    sort_order: types_sort_order.optional(),
    size: z.number().describe('The maximum length of the line represented in the aggregation.\nValid sizes are between 1 and 10000.').optional().default(10000)
});

export const types_geo_tile_precision = z.number();

export const types_aggregations_geo_tile_grid_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field.optional(),
    precision: types_geo_tile_precision.optional(),
    shard_size: z.number().describe('Allows for more accurate counting of the top cells returned in the final result the aggregation.\nDefaults to returning `max(10,(size x number-of-shards))` buckets from each shard.').optional(),
    size: z.number().describe('The maximum number of buckets to return.').optional().default(10000),
    bounds: types_geo_bounds.optional()
}));

export const types_aggregations_geohex_grid_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field,
    precision: z.number().describe('Integer zoom of the key used to defined cells or buckets\nin the results. Value should be between 0-15.').optional().default(6),
    bounds: types_geo_bounds.optional(),
    size: z.number().describe('Maximum number of buckets to return.').optional().default(10000),
    shard_size: z.number().describe('Number of buckets returned from each shard.').optional()
}));

export const types_aggregations_global_aggregation = types_aggregations_bucket_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_extended_boundsdouble = z.object({
    max: z.number().describe('Maximum value for the bound.').optional(),
    min: z.number().describe('Minimum value for the bound.').optional()
});

export const types_aggregations_ip_range_aggregation_range = z.object({
    from: z.union([
        z.string(),
        z.null()
    ]).optional(),
    mask: z.string().describe('IP range defined as a CIDR mask.').optional(),
    to: z.union([
        z.string(),
        z.null()
    ]).optional()
});

export const types_aggregations_ip_range_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field.optional(),
    ranges: z.array(types_aggregations_ip_range_aggregation_range).describe('Array of IP ranges.').optional()
}));

export const types_aggregations_ip_prefix_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field,
    prefix_length: z.number().describe('Length of the network prefix. For IPv4 addresses the accepted range is [0, 32].\nFor IPv6 addresses the accepted range is [0, 128].'),
    is_ipv6: z.boolean().describe('Defines whether the prefix applies to IPv6 addresses.').optional().default(false),
    append_prefix_length: z.boolean().describe('Defines whether the prefix length is appended to IP address keys in the response.').optional().default(false),
    keyed: z.boolean().describe('Defines whether buckets are returned as a hash rather than an array in the response.').optional(),
    min_doc_count: z.number().describe('Minimum number of documents in a bucket for it to be included in the response.').optional().default(1)
}));

export const ml_types_regression_inference_options = z.object({
    results_field: types_field.optional(),
    num_top_feature_importance_values: z.number().describe('Specifies the maximum number of feature importance values per document.').optional().default(0)
});

export const ml_types_classification_inference_options = z.object({
    num_top_classes: z.number().describe('Specifies the number of top class predictions to return. Defaults to 0.').optional(),
    num_top_feature_importance_values: z.number().describe('Specifies the maximum number of feature importance values per document.').optional().default(0),
    prediction_field_type: z.string().describe('Specifies the type of the predicted field to write. Acceptable values are: string, number, boolean. When boolean is provided 1.0 is transformed to true and 0.0 to false.').optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    top_classes_results_field: z.string().describe('Specifies the field to which the top classes are written. Defaults to top_classes.').optional()
});

export const types_aggregations_inference_config_container = z.object({
    regression: ml_types_regression_inference_options.optional(),
    classification: ml_types_classification_inference_options.optional()
});

export const types_aggregations_inference_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    model_id: types_name,
    inference_config: types_aggregations_inference_config_container.optional()
}));

export const types_aggregations_matrix_aggregation = types_aggregations_aggregation.and(z.object({
    fields: types_fields.optional(),
    missing: z.record(z.number()).describe('The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.').optional()
}));

export const types_aggregations_matrix_stats_aggregation = types_aggregations_matrix_aggregation.and(z.object({
    mode: types_sort_mode.optional()
}));

export const types_aggregations_max_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_min_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_missing_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field.optional(),
    missing: types_aggregations_missing.optional()
}));

/**
 * For empty Class assignments
 */
export const types_empty_object = z.record(z.unknown()).describe('For empty Class assignments');

export const types_aggregations_moving_average_aggregation_base = types_aggregations_pipeline_aggregation_base.and(z.object({
    minimize: z.boolean().optional(),
    predict: z.number().optional(),
    window: z.number().optional()
}));

export const types_aggregations_linear_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum(['linear']),
    settings: types_empty_object
}));

export const types_aggregations_simple_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum(['simple']),
    settings: types_empty_object
}));

export const types_aggregations_ewma_model_settings = z.object({
    alpha: z.number().optional()
});

export const types_aggregations_ewma_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum(['ewma']),
    settings: types_aggregations_ewma_model_settings
}));

export const types_aggregations_holt_linear_model_settings = z.object({
    alpha: z.number().optional(),
    beta: z.number().optional()
});

export const types_aggregations_holt_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum(['holt']),
    settings: types_aggregations_holt_linear_model_settings
}));

export const types_aggregations_holt_winters_type = z.enum(['add', 'mult']);

export const types_aggregations_holt_winters_model_settings = z.object({
    alpha: z.number().optional(),
    beta: z.number().optional(),
    gamma: z.number().optional(),
    pad: z.boolean().optional(),
    period: z.number().optional(),
    type: types_aggregations_holt_winters_type.optional()
});

export const types_aggregations_holt_winters_moving_average_aggregation = types_aggregations_moving_average_aggregation_base.and(z.object({
    model: z.enum(['holt_winters']),
    settings: types_aggregations_holt_winters_model_settings
}));

export const types_aggregations_moving_average_aggregation = z.union([
    types_aggregations_linear_moving_average_aggregation,
    types_aggregations_simple_moving_average_aggregation,
    types_aggregations_ewma_moving_average_aggregation,
    types_aggregations_holt_moving_average_aggregation,
    types_aggregations_holt_winters_moving_average_aggregation
]);

export const types_aggregations_moving_percentiles_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    window: z.number().describe('The size of window to "slide" across the histogram.').optional(),
    shift: z.number().describe('By default, the window consists of the last n values excluding the current bucket.\nIncreasing `shift` by 1, moves the starting window position by 1 to the right.').optional().default(0),
    keyed: z.boolean().optional()
}));

export const types_aggregations_moving_function_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    script: z.string().describe('The script that should be executed on each window of data.').optional(),
    shift: z.number().describe('By default, the window consists of the last n values excluding the current bucket.\nIncreasing `shift` by 1, moves the starting window position by 1 to the right.').optional().default(0),
    window: z.number().describe('The size of window to "slide" across the histogram.').optional()
}));

export const types_aggregations_terms_aggregation_collect_mode = z.enum(['depth_first', 'breadth_first']);

export const types_aggregations_multi_term_lookup = z.object({
    field: types_field,
    missing: types_aggregations_missing.optional()
});

export const types_aggregations_multi_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    collect_mode: types_aggregations_terms_aggregation_collect_mode.optional(),
    order: types_aggregations_aggregate_order.optional(),
    min_doc_count: z.number().describe('The minimum number of documents in a bucket for it to be returned.').optional().default(1),
    shard_min_doc_count: z.number().describe('The minimum number of documents in a bucket on each shard for it to be returned.').optional().default(1),
    shard_size: z.number().describe('The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.').optional(),
    show_term_doc_count_error: z.boolean().describe('Calculates the doc count error on per term basis.').optional().default(false),
    size: z.number().describe('The number of term buckets should be returned out of the overall terms list.').optional().default(10),
    terms: z.array(types_aggregations_multi_term_lookup).describe('The field from which to generate sets of terms.')
}));

export const types_aggregations_nested_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    path: types_field.optional()
}));

export const types_aggregations_normalize_method = z.enum([
    'rescale_0_1',
    'rescale_0_100',
    'percent_of_sum',
    'mean',
    'z-score',
    'softmax'
]);

export const types_aggregations_normalize_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    method: types_aggregations_normalize_method.optional()
}));

export const types_aggregations_parent_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    type: types_relation_name.optional()
}));

export const types_aggregations_hdr_method = z.object({
    number_of_significant_value_digits: z.number().describe('Specifies the resolution of values for the histogram in number of significant digits.').optional()
});

export const types_aggregations_t_digest = z.object({
    compression: z.number().describe('Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.').optional(),
    execution_hint: types_aggregations_t_digest_execution_hint.optional()
});

export const types_aggregations_percentiles_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    percents: z.array(z.number()).describe('The list of percentiles to calculate.').optional()
}));

export const types_aggregations_rare_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    exclude: types_aggregations_terms_exclude.optional(),
    field: types_field.optional(),
    include: types_aggregations_terms_include.optional(),
    max_doc_count: z.number().describe('The maximum number of documents a term should appear in.').optional().default(1),
    missing: types_aggregations_missing.optional(),
    precision: z.number().describe('The precision of the internal CuckooFilters.\nSmaller precision leads to better approximation, but higher memory usage.').optional().default(0.001),
    value_type: z.string().optional()
}));

export const types_aggregations_rate_mode = z.enum(['sum', 'value_count']);

export const types_aggregations_reverse_nested_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    path: types_field.optional()
}));

export const types_aggregations_random_sampler_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    probability: z.number().describe('The probability that a document will be included in the aggregated data.\nMust be greater than 0, less than 0.5, or exactly 1.\nThe lower the probability, the fewer documents are matched.'),
    seed: z.number().describe('The seed to generate the random sampling of documents.\nWhen a seed is provided, the random subset of documents is the same between calls.').optional(),
    shard_seed: z.number().describe('When combined with seed, setting shard_seed ensures 100% consistent sampling over shards where data is exactly the same.').optional()
}));

export const types_aggregations_sampler_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    shard_size: z.number().describe('Limits how many top-scoring documents are collected in the sample processed on each shard.').optional().default(100)
}));

export const types_aggregations_serial_differencing_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    lag: z.number().describe('The historical bucket to subtract from the current value.\nMust be a positive, non-zero integer.').optional()
}));

export const types_aggregations_chi_square_heuristic = z.object({
    background_is_superset: z.boolean().describe('Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.'),
    include_negatives: z.boolean().describe('Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset.')
});

export const types_aggregations_terms_aggregation_execution_hint = z.enum([
    'map',
    'global_ordinals',
    'global_ordinals_hash',
    'global_ordinals_low_cardinality'
]);

export const types_aggregations_google_normalized_distance_heuristic = z.object({
    background_is_superset: z.boolean().describe('Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.').optional()
});

export const types_aggregations_mutual_information_heuristic = z.object({
    background_is_superset: z.boolean().describe('Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.').optional(),
    include_negatives: z.boolean().describe('Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset.').optional()
});

export const types_aggregations_percentage_score_heuristic = z.record(z.unknown());

export const types_aggregations_p_value_heuristic = z.object({
    background_is_superset: z.boolean().optional(),
    normalize_above: z.number().describe('Should the results be normalized when above the given value.\nAllows for consistent significance results at various scales.\nNote: `0` is a special value which means no normalization').optional().default(0)
});

export const types_aggregations_stats_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_sum_bucket_aggregation = types_aggregations_pipeline_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_time_series_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    size: z.number().describe('The maximum number of results to return.').optional().default(10000),
    keyed: z.boolean().describe('Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array.').optional()
}));

export const types_aggregations_t_test_type = z.enum([
    'paired',
    'homoscedastic',
    'heteroscedastic'
]);

export const types_aggregations_top_metrics_value = z.object({
    field: types_field
});

export const types_refresh = z.enum([
    'true',
    'false',
    'wait_for'
]);

export const types_wait_for_active_shard_options = z.enum(['all', 'index-setting']);

export const types_wait_for_active_shards = z.union([
    z.number(),
    types_wait_for_active_shard_options
]);

export const global_bulk_operation_base = z.object({
    _id: types_id.optional(),
    _index: types_index_name.optional(),
    routing: types_routing.optional(),
    if_primary_term: z.number().optional(),
    if_seq_no: types_sequence_number.optional(),
    version: types_version_number.optional(),
    version_type: types_version_type.optional()
});

export const global_bulk_write_operation = global_bulk_operation_base.and(z.object({
    dynamic_templates: z.record(z.string()).describe('A map from the full name of fields to the name of dynamic templates.\nIt defaults to an empty map.\nIf a name matches a dynamic template, that template will be applied regardless of other match predicates defined in the template.\nIf a field is already defined in the mapping, then this parameter won\'t be used.').optional(),
    pipeline: z.string().describe('The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.').optional(),
    require_alias: z.boolean().describe('If `true`, the request\'s actions must target an index alias.').optional().default(false)
}));

export const global_bulk_index_operation = global_bulk_write_operation.and(z.record(z.unknown()));

export const global_bulk_create_operation = global_bulk_write_operation.and(z.record(z.unknown()));

export const global_bulk_update_operation = global_bulk_operation_base.and(z.object({
    require_alias: z.boolean().describe('If `true`, the request\'s actions must target an index alias.').optional().default(false),
    retry_on_conflict: z.number().describe('The number of times an update should be retried in the case of a version conflict.').optional()
}));

export const global_bulk_delete_operation = global_bulk_operation_base.and(z.record(z.unknown()));

export const global_bulk_operation_container = z.object({
    index: global_bulk_index_operation.optional(),
    create: global_bulk_create_operation.optional(),
    update: global_bulk_update_operation.optional(),
    delete: global_bulk_delete_operation.optional()
});

export const global_bulk_failure_store_status = z.enum([
    'not_applicable_or_unknown',
    'used',
    'not_enabled',
    'failed'
]);

export const types_inline_get_dict_user_defined = z.object({
    fields: z.record(z.record(z.unknown())).optional(),
    found: z.boolean(),
    _seq_no: types_sequence_number.optional(),
    _primary_term: z.number().optional(),
    _routing: types_routing.optional(),
    _source: z.record(z.record(z.unknown())).optional()
});

export const global_bulk_response_item = z.object({
    _id: z.union([
        z.string(),
        z.null()
    ]).optional(),
    _index: z.string().describe('The name of the index associated with the operation.\nIf the operation targeted a data stream, this is the backing index into which the document was written.'),
    status: z.number().describe('The HTTP status code returned for the operation.'),
    failure_store: global_bulk_failure_store_status.optional(),
    error: types_error_cause.optional(),
    _primary_term: z.number().describe('The primary term assigned to the document for the operation.\nThis property is returned only for successful operations.').optional(),
    result: z.string().describe('The result of the operation.\nSuccessful values are `created`, `deleted`, and `updated`.').optional(),
    _seq_no: types_sequence_number.optional(),
    _shards: types_shard_statistics.optional(),
    _version: types_version_number.optional(),
    forced_refresh: z.boolean().optional(),
    get: types_inline_get_dict_user_defined.optional()
});

export const types_names = z.union([
    types_name,
    z.array(types_name)
]);

export const cat_types_cat_aliases_column = z.union([
    z.enum([
        'alias',
        'a',
        'index',
        'i',
        'idx',
        'filter',
        'f',
        'fi',
        'routing.index',
        'ri',
        'routingIndex',
        'routing.search',
        'rs',
        'routingSearch',
        'is_write_index',
        'w',
        'isWriteIndex'
    ]),
    z.string()
]);

export const cat_types_cat_aliases_columns = z.union([
    cat_types_cat_aliases_column,
    z.array(cat_types_cat_aliases_column)
]);

export const cat_aliases_aliases_record = z.object({
    alias: z.string().describe('alias name').optional(),
    index: types_index_name.optional(),
    filter: z.string().describe('filter').optional(),
    'routing.index': z.string().describe('index routing').optional(),
    'routing.search': z.string().describe('search routing').optional(),
    is_write_index: z.string().describe('write index').optional()
});

export const types_node_ids = z.union([
    types_node_id,
    z.array(types_node_id)
]);

export const cat_types_cat_allocation_column = z.union([
    z.enum([
        'shards',
        's',
        'shards.undesired',
        'write_load.forecast',
        'wlf',
        'writeLoadForecast',
        'disk.indices.forecast',
        'dif',
        'diskIndicesForecast',
        'disk.indices',
        'di',
        'diskIndices',
        'disk.used',
        'du',
        'diskUsed',
        'disk.avail',
        'da',
        'diskAvail',
        'disk.total',
        'dt',
        'diskTotal',
        'disk.percent',
        'dp',
        'diskPercent',
        'host',
        'h',
        'ip',
        'node',
        'n',
        'node.role',
        'r',
        'role',
        'nodeRole'
    ]),
    z.string()
]);

export const cat_types_cat_allocation_columns = z.union([
    cat_types_cat_allocation_column,
    z.array(cat_types_cat_allocation_column)
]);

/**
 * Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
 * is used to capture this behavior while keeping the semantics of the field type.
 *
 * Depending on the target language, code generators can keep the union or remove it and leniently parse
 * strings to the target type.
 */
export const spec_utils_stringifieddouble = z.union([
    z.number(),
    z.string()
]);

export const types_byte_size = z.union([
    z.number(),
    z.string()
]);

export const types_percentage = z.union([
    z.string(),
    z.number()
]);

export const types_host = z.string();

export const types_ip = z.string();

export const cat_allocation_allocation_record = z.object({
    shards: z.string().describe('Number of primary and replica shards assigned to the node.').optional(),
    'shards.undesired': z.union([
        z.string(),
        z.null()
    ]).optional(),
    'write_load.forecast': z.union([
        spec_utils_stringifieddouble,
        z.string(),
        z.null()
    ]).optional(),
    'disk.indices.forecast': z.union([
        types_byte_size,
        z.string(),
        z.null()
    ]).optional(),
    'disk.indices': z.union([
        types_byte_size,
        z.string(),
        z.null()
    ]).optional(),
    'disk.used': z.union([
        types_byte_size,
        z.string(),
        z.null()
    ]).optional(),
    'disk.avail': z.union([
        types_byte_size,
        z.string(),
        z.null()
    ]).optional(),
    'disk.total': z.union([
        types_byte_size,
        z.string(),
        z.null()
    ]).optional(),
    'disk.percent': z.union([
        types_percentage,
        z.string(),
        z.null()
    ]).optional(),
    host: z.union([
        types_host,
        z.string(),
        z.null()
    ]).optional(),
    ip: z.union([
        types_ip,
        z.string(),
        z.null()
    ]).optional(),
    node: z.string().describe('Name for the node. Set using the `node.name` setting.').optional(),
    'node.role': z.union([
        z.string(),
        z.null()
    ]).optional()
});

export const cat_types_cat_component_column = z.union([
    z.enum([
        'name',
        'n',
        'version',
        'v',
        'alias_count',
        'a',
        'mapping_count',
        'm',
        'settings_count',
        's',
        'metadata_count',
        'me',
        'included_in',
        'i'
    ]),
    z.string()
]);

export const cat_types_cat_component_columns = z.union([
    cat_types_cat_component_column,
    z.array(cat_types_cat_component_column)
]);

export const cat_component_templates_component_template = z.object({
    name: z.string(),
    version: z.union([
        z.string(),
        z.null()
    ]),
    alias_count: z.string(),
    mapping_count: z.string(),
    settings_count: z.string(),
    metadata_count: z.string(),
    included_in: z.string()
});

export const cat_types_cat_count_column = z.union([
    z.enum([
        'epoch',
        't',
        'time',
        'timestamp',
        'ts',
        'hms',
        'hhmmss',
        'count',
        'dc',
        'docs.count',
        'docsCount'
    ]),
    z.string()
]);

export const cat_types_cat_count_columns = z.union([
    cat_types_cat_count_column,
    z.array(cat_types_cat_count_column)
]);

/**
 * Time unit for seconds
 */
export const types_unit_seconds = z.number().describe('Time unit for seconds');

export const types_epoch_time_unit_seconds = types_unit_seconds;

/**
 * Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
 * is used to capture this behavior while keeping the semantics of the field type.
 *
 * Depending on the target language, code generators can keep the union or remove it and leniently parse
 * strings to the target type.
 */
export const spec_utils_stringified_epoch_time_unit_seconds = z.union([
    types_epoch_time_unit_seconds,
    z.string()
]);

/**
 * Time of day, expressed as HH:MM:SS
 */
export const types_time_of_day = z.string().describe('Time of day, expressed as HH:MM:SS');

export const cat_count_count_record = z.object({
    epoch: spec_utils_stringified_epoch_time_unit_seconds.optional(),
    timestamp: types_time_of_day.optional(),
    count: z.string().describe('the document count').optional()
});

export const cat_types_cat_field_data_column = z.union([
    z.enum([
        'id',
        'host',
        'h',
        'ip',
        'node',
        'n',
        'field',
        'f',
        'size',
        's'
    ]),
    z.string()
]);

export const cat_types_cat_field_data_columns = z.union([
    cat_types_cat_field_data_column,
    z.array(cat_types_cat_field_data_column)
]);

export const cat_fielddata_fielddata_record = z.object({
    id: z.string().describe('node id').optional(),
    host: z.string().describe('host name').optional(),
    ip: z.string().describe('ip address').optional(),
    node: z.string().describe('node name').optional(),
    field: z.string().describe('field name').optional(),
    size: z.string().describe('field data usage').optional()
});

export const cat_types_cat_health_column = z.union([
    z.enum([
        'epoch',
        't',
        'time',
        'timestamp',
        'ts',
        'hms',
        'hhmmss',
        'cluster',
        'cl',
        'status',
        'st',
        'node.total',
        'nt',
        'nodeTotal',
        'node.data',
        'nd',
        'nodeData',
        'shards',
        't',
        'sh',
        'shards.total',
        'shardsTotal',
        'pri',
        'p',
        'shards.primary',
        'shardsPrimary',
        'relo',
        'r',
        'shards.relocating',
        'shardsRelocating',
        'init',
        'i',
        'shards.initializing',
        'shardsInitializing',
        'unassign',
        'u',
        'shards.unassigned',
        'shardsUnassigned',
        'unassign.pri',
        'up',
        'shards.unassigned.primary',
        'shardsUnassignedPrimary',
        'pending_tasks',
        'pt',
        'pendingTasks',
        'max_task_wait_time',
        'mtwt',
        'maxTaskWaitTime',
        'active_shards_percent',
        'asp',
        'activeShardsPercent'
    ]),
    z.string()
]);

export const cat_types_cat_health_columns = z.union([
    cat_types_cat_health_column,
    z.array(cat_types_cat_health_column)
]);

export const cat_health_health_record = z.object({
    epoch: spec_utils_stringified_epoch_time_unit_seconds.optional(),
    timestamp: types_time_of_day.optional(),
    cluster: z.string().describe('cluster name').optional(),
    status: z.string().describe('health status').optional(),
    'node.total': z.string().describe('total number of nodes').optional(),
    'node.data': z.string().describe('number of nodes that can store data').optional(),
    shards: z.string().describe('total number of shards').optional(),
    pri: z.string().describe('number of primary shards').optional(),
    relo: z.string().describe('number of relocating nodes').optional(),
    init: z.string().describe('number of initializing nodes').optional(),
    'unassign.pri': z.string().describe('number of unassigned primary shards').optional(),
    unassign: z.string().describe('number of unassigned shards').optional(),
    pending_tasks: z.string().describe('number of pending tasks').optional(),
    max_task_wait_time: z.string().describe('wait time of longest task pending').optional(),
    active_shards_percent: z.string().describe('active number of shards in percent').optional()
});

export const types_health_status = z.enum([
    'green',
    'GREEN',
    'yellow',
    'YELLOW',
    'red',
    'RED',
    'unknown',
    'unavailable'
]);

export const cat_types_cat_indices_column = z.union([
    z.enum([
        'health',
        'h',
        'status',
        's',
        'index',
        'i',
        'idx',
        'uuid',
        'id',
        'uuid',
        'pri',
        'p',
        'shards.primary',
        'shardsPrimary',
        'rep',
        'r',
        'shards.replica',
        'shardsReplica',
        'docs.count',
        'dc',
        'docsCount',
        'docs.deleted',
        'dd',
        'docsDeleted',
        'creation.date',
        'cd',
        'creation.date.string',
        'cds',
        'store.size',
        'ss',
        'storeSize',
        'pri.store.size',
        'dataset.size',
        'completion.size',
        'cs',
        'completionSize',
        'pri.completion.size',
        'fielddata.memory_size',
        'fm',
        'fielddataMemory',
        'pri.fielddata.memory_size',
        'fielddata.evictions',
        'fe',
        'fielddataEvictions',
        'pri.fielddata.evictions',
        'query_cache.memory_size',
        'qcm',
        'queryCacheMemory',
        'pri.query_cache.memory_size',
        'query_cache.evictions',
        'qce',
        'queryCacheEvictions',
        'pri.query_cache.evictions',
        'request_cache.memory_size',
        'rcm',
        'requestCacheMemory',
        'pri.request_cache.memory_size',
        'request_cache.evictions',
        'rce',
        'requestCacheEvictions',
        'pri.request_cache.evictions',
        'request_cache.hit_count',
        'rchc',
        'requestCacheHitCount',
        'pri.request_cache.hit_count',
        'request_cache.miss_count',
        'rcmc',
        'requestCacheMissCount',
        'pri.request_cache.miss_count',
        'flush.total',
        'ft',
        'flushTotal',
        'pri.flush.total',
        'flush.total_time',
        'ftt',
        'flushTotalTime',
        'pri.flush.total_time',
        'get.current',
        'gc',
        'getCurrent',
        'pri.get.current',
        'get.time',
        'gti',
        'getTime',
        'pri.get.time',
        'get.total',
        'gto',
        'getTotal',
        'pri.get.total',
        'get.exists_time',
        'geti',
        'getExistsTime',
        'pri.get.exists_time',
        'get.exists_total',
        'geto',
        'getExistsTotal',
        'pri.get.exists_total',
        'get.missing_time',
        'gmti',
        'getMissingTime',
        'pri.get.missing_time',
        'get.missing_total',
        'gmto',
        'getMissingTotal',
        'pri.get.missing_total',
        'indexing.delete_current',
        'idc',
        'indexingDeleteCurrent',
        'pri.indexing.delete_current',
        'indexing.delete_time',
        'idti',
        'indexingDeleteTime',
        'pri.indexing.delete_time',
        'indexing.delete_total',
        'idto',
        'indexingDeleteTotal',
        'pri.indexing.delete_total',
        'indexing.index_current',
        'iic',
        'indexingIndexCurrent',
        'pri.indexing.index_current',
        'indexing.index_time',
        'iiti',
        'indexingIndexTime',
        'pri.indexing.index_time',
        'indexing.index_total',
        'iito',
        'indexingIndexTotal',
        'pri.indexing.index_total',
        'indexing.index_failed',
        'iif',
        'indexingIndexFailed',
        'pri.indexing.index_failed',
        'indexing.index_failed_due_to_version_conflict',
        'iifvc',
        'indexingIndexFailedDueToVersionConflict',
        'pri.indexing.index_failed_due_to_version_conflict',
        'merges.current',
        'mc',
        'mergesCurrent',
        'pri.merges.current',
        'merges.current_docs',
        'mcd',
        'mergesCurrentDocs',
        'pri.merges.current_docs',
        'merges.current_size',
        'mcs',
        'mergesCurrentSize',
        'pri.merges.current_size',
        'merges.total',
        'mt',
        'mergesTotal',
        'pri.merges.total',
        'merges.total_docs',
        'mtd',
        'mergesTotalDocs',
        'pri.merges.total_docs',
        'merges.total_size',
        'mts',
        'mergesTotalSize',
        'pri.merges.total_size',
        'merges.total_time',
        'mtt',
        'mergesTotalTime',
        'pri.merges.total_time',
        'refresh.total',
        'rto',
        'refreshTotal',
        'pri.refresh.total',
        'refresh.time',
        'rti',
        'refreshTime',
        'pri.refresh.time',
        'refresh.external_total',
        'rto',
        'refreshTotal',
        'pri.refresh.external_total',
        'refresh.external_time',
        'rti',
        'refreshTime',
        'pri.refresh.external_time',
        'refresh.listeners',
        'rli',
        'refreshListeners',
        'pri.refresh.listeners',
        'search.fetch_current',
        'sfc',
        'searchFetchCurrent',
        'pri.search.fetch_current',
        'search.fetch_time',
        'sfti',
        'searchFetchTime',
        'pri.search.fetch_time',
        'search.fetch_total',
        'sfto',
        'searchFetchTotal',
        'pri.search.fetch_total',
        'search.open_contexts',
        'so',
        'searchOpenContexts',
        'pri.search.open_contexts',
        'search.query_current',
        'sqc',
        'searchQueryCurrent',
        'pri.search.query_current',
        'search.query_time',
        'sqti',
        'searchQueryTime',
        'pri.search.query_time',
        'search.query_total',
        'sqto',
        'searchQueryTotal',
        'pri.search.query_total',
        'search.scroll_current',
        'scc',
        'searchScrollCurrent',
        'pri.search.scroll_current',
        'search.scroll_time',
        'scti',
        'searchScrollTime',
        'pri.search.scroll_time',
        'search.scroll_total',
        'scto',
        'searchScrollTotal',
        'pri.search.scroll_total',
        'segments.count',
        'sc',
        'segmentsCount',
        'pri.segments.count',
        'segments.memory',
        'sm',
        'segmentsMemory',
        'pri.segments.memory',
        'segments.index_writer_memory',
        'siwm',
        'segmentsIndexWriterMemory',
        'pri.segments.index_writer_memory',
        'segments.version_map_memory',
        'svmm',
        'segmentsVersionMapMemory',
        'pri.segments.version_map_memory',
        'segments.fixed_bitset_memory',
        'sfbm',
        'fixedBitsetMemory',
        'pri.segments.fixed_bitset_memory',
        'warmer.current',
        'wc',
        'warmerCurrent',
        'pri.warmer.current',
        'warmer.total',
        'wto',
        'warmerTotal',
        'pri.warmer.total',
        'warmer.total_time',
        'wtt',
        'warmerTotalTime',
        'pri.warmer.total_time',
        'suggest.current',
        'suc',
        'suggestCurrent',
        'pri.suggest.current',
        'suggest.time',
        'suti',
        'suggestTime',
        'pri.suggest.time',
        'suggest.total',
        'suto',
        'suggestTotal',
        'pri.suggest.total',
        'memory.total',
        'tm',
        'memoryTotal',
        'pri.memory.total',
        'bulk.total_operations',
        'bto',
        'bulkTotalOperation',
        'pri.bulk.total_operations',
        'bulk.total_time',
        'btti',
        'bulkTotalTime',
        'pri.bulk.total_time',
        'bulk.total_size_in_bytes',
        'btsi',
        'bulkTotalSizeInBytes',
        'pri.bulk.total_size_in_bytes',
        'bulk.avg_time',
        'bati',
        'bulkAvgTime',
        'pri.bulk.avg_time',
        'bulk.avg_size_in_bytes',
        'basi',
        'bulkAvgSizeInBytes',
        'pri.bulk.avg_size_in_bytes',
        'dense_vector.value_count',
        'dvc',
        'denseVectorCount',
        'pri.dense_vector.value_count',
        'sparse_vector.value_count',
        'svc',
        'sparseVectorCount',
        'pri.sparse_vector.value_count'
    ]),
    z.string()
]);

export const cat_types_cat_indices_columns = z.union([
    cat_types_cat_indices_column,
    z.array(cat_types_cat_indices_column)
]);

export const cat_indices_indices_record = z.object({
    health: z.string().describe('current health status').optional(),
    status: z.string().describe('open/close status').optional(),
    index: z.string().describe('index name').optional(),
    uuid: z.string().describe('index uuid').optional(),
    pri: z.string().describe('number of primary shards').optional(),
    rep: z.string().describe('number of replica shards').optional(),
    'docs.count': z.union([
        z.string(),
        z.null()
    ]).optional(),
    'docs.deleted': z.union([
        z.string(),
        z.null()
    ]).optional(),
    'creation.date': z.string().describe('index creation date (millisecond value)').optional(),
    'creation.date.string': z.string().describe('index creation date (as string)').optional(),
    'store.size': z.union([
        z.string(),
        z.null()
    ]).optional(),
    'pri.store.size': z.union([
        z.string(),
        z.null()
    ]).optional(),
    'dataset.size': z.union([
        z.string(),
        z.null()
    ]).optional(),
    'completion.size': z.string().describe('size of completion').optional(),
    'pri.completion.size': z.string().describe('size of completion').optional(),
    'fielddata.memory_size': z.string().describe('used fielddata cache').optional(),
    'pri.fielddata.memory_size': z.string().describe('used fielddata cache').optional(),
    'fielddata.evictions': z.string().describe('fielddata evictions').optional(),
    'pri.fielddata.evictions': z.string().describe('fielddata evictions').optional(),
    'query_cache.memory_size': z.string().describe('used query cache').optional(),
    'pri.query_cache.memory_size': z.string().describe('used query cache').optional(),
    'query_cache.evictions': z.string().describe('query cache evictions').optional(),
    'pri.query_cache.evictions': z.string().describe('query cache evictions').optional(),
    'request_cache.memory_size': z.string().describe('used request cache').optional(),
    'pri.request_cache.memory_size': z.string().describe('used request cache').optional(),
    'request_cache.evictions': z.string().describe('request cache evictions').optional(),
    'pri.request_cache.evictions': z.string().describe('request cache evictions').optional(),
    'request_cache.hit_count': z.string().describe('request cache hit count').optional(),
    'pri.request_cache.hit_count': z.string().describe('request cache hit count').optional(),
    'request_cache.miss_count': z.string().describe('request cache miss count').optional(),
    'pri.request_cache.miss_count': z.string().describe('request cache miss count').optional(),
    'flush.total': z.string().describe('number of flushes').optional(),
    'pri.flush.total': z.string().describe('number of flushes').optional(),
    'flush.total_time': z.string().describe('time spent in flush').optional(),
    'pri.flush.total_time': z.string().describe('time spent in flush').optional(),
    'get.current': z.string().describe('number of current get ops').optional(),
    'pri.get.current': z.string().describe('number of current get ops').optional(),
    'get.time': z.string().describe('time spent in get').optional(),
    'pri.get.time': z.string().describe('time spent in get').optional(),
    'get.total': z.string().describe('number of get ops').optional(),
    'pri.get.total': z.string().describe('number of get ops').optional(),
    'get.exists_time': z.string().describe('time spent in successful gets').optional(),
    'pri.get.exists_time': z.string().describe('time spent in successful gets').optional(),
    'get.exists_total': z.string().describe('number of successful gets').optional(),
    'pri.get.exists_total': z.string().describe('number of successful gets').optional(),
    'get.missing_time': z.string().describe('time spent in failed gets').optional(),
    'pri.get.missing_time': z.string().describe('time spent in failed gets').optional(),
    'get.missing_total': z.string().describe('number of failed gets').optional(),
    'pri.get.missing_total': z.string().describe('number of failed gets').optional(),
    'indexing.delete_current': z.string().describe('number of current deletions').optional(),
    'pri.indexing.delete_current': z.string().describe('number of current deletions').optional(),
    'indexing.delete_time': z.string().describe('time spent in deletions').optional(),
    'pri.indexing.delete_time': z.string().describe('time spent in deletions').optional(),
    'indexing.delete_total': z.string().describe('number of delete ops').optional(),
    'pri.indexing.delete_total': z.string().describe('number of delete ops').optional(),
    'indexing.index_current': z.string().describe('number of current indexing ops').optional(),
    'pri.indexing.index_current': z.string().describe('number of current indexing ops').optional(),
    'indexing.index_time': z.string().describe('time spent in indexing').optional(),
    'pri.indexing.index_time': z.string().describe('time spent in indexing').optional(),
    'indexing.index_total': z.string().describe('number of indexing ops').optional(),
    'pri.indexing.index_total': z.string().describe('number of indexing ops').optional(),
    'indexing.index_failed': z.string().describe('number of failed indexing ops').optional(),
    'pri.indexing.index_failed': z.string().describe('number of failed indexing ops').optional(),
    'merges.current': z.string().describe('number of current merges').optional(),
    'pri.merges.current': z.string().describe('number of current merges').optional(),
    'merges.current_docs': z.string().describe('number of current merging docs').optional(),
    'pri.merges.current_docs': z.string().describe('number of current merging docs').optional(),
    'merges.current_size': z.string().describe('size of current merges').optional(),
    'pri.merges.current_size': z.string().describe('size of current merges').optional(),
    'merges.total': z.string().describe('number of completed merge ops').optional(),
    'pri.merges.total': z.string().describe('number of completed merge ops').optional(),
    'merges.total_docs': z.string().describe('docs merged').optional(),
    'pri.merges.total_docs': z.string().describe('docs merged').optional(),
    'merges.total_size': z.string().describe('size merged').optional(),
    'pri.merges.total_size': z.string().describe('size merged').optional(),
    'merges.total_time': z.string().describe('time spent in merges').optional(),
    'pri.merges.total_time': z.string().describe('time spent in merges').optional(),
    'refresh.total': z.string().describe('total refreshes').optional(),
    'pri.refresh.total': z.string().describe('total refreshes').optional(),
    'refresh.time': z.string().describe('time spent in refreshes').optional(),
    'pri.refresh.time': z.string().describe('time spent in refreshes').optional(),
    'refresh.external_total': z.string().describe('total external refreshes').optional(),
    'pri.refresh.external_total': z.string().describe('total external refreshes').optional(),
    'refresh.external_time': z.string().describe('time spent in external refreshes').optional(),
    'pri.refresh.external_time': z.string().describe('time spent in external refreshes').optional(),
    'refresh.listeners': z.string().describe('number of pending refresh listeners').optional(),
    'pri.refresh.listeners': z.string().describe('number of pending refresh listeners').optional(),
    'search.fetch_current': z.string().describe('current fetch phase ops').optional(),
    'pri.search.fetch_current': z.string().describe('current fetch phase ops').optional(),
    'search.fetch_time': z.string().describe('time spent in fetch phase').optional(),
    'pri.search.fetch_time': z.string().describe('time spent in fetch phase').optional(),
    'search.fetch_total': z.string().describe('total fetch ops').optional(),
    'pri.search.fetch_total': z.string().describe('total fetch ops').optional(),
    'search.open_contexts': z.string().describe('open search contexts').optional(),
    'pri.search.open_contexts': z.string().describe('open search contexts').optional(),
    'search.query_current': z.string().describe('current query phase ops').optional(),
    'pri.search.query_current': z.string().describe('current query phase ops').optional(),
    'search.query_time': z.string().describe('time spent in query phase').optional(),
    'pri.search.query_time': z.string().describe('time spent in query phase').optional(),
    'search.query_total': z.string().describe('total query phase ops').optional(),
    'pri.search.query_total': z.string().describe('total query phase ops').optional(),
    'search.scroll_current': z.string().describe('open scroll contexts').optional(),
    'pri.search.scroll_current': z.string().describe('open scroll contexts').optional(),
    'search.scroll_time': z.string().describe('time scroll contexts held open').optional(),
    'pri.search.scroll_time': z.string().describe('time scroll contexts held open').optional(),
    'search.scroll_total': z.string().describe('completed scroll contexts').optional(),
    'pri.search.scroll_total': z.string().describe('completed scroll contexts').optional(),
    'segments.count': z.string().describe('number of segments').optional(),
    'pri.segments.count': z.string().describe('number of segments').optional(),
    'segments.memory': z.string().describe('memory used by segments').optional(),
    'pri.segments.memory': z.string().describe('memory used by segments').optional(),
    'segments.index_writer_memory': z.string().describe('memory used by index writer').optional(),
    'pri.segments.index_writer_memory': z.string().describe('memory used by index writer').optional(),
    'segments.version_map_memory': z.string().describe('memory used by version map').optional(),
    'pri.segments.version_map_memory': z.string().describe('memory used by version map').optional(),
    'segments.fixed_bitset_memory': z.string().describe('memory used by fixed bit sets for nested object field types and export type filters for types referred in _parent fields').optional(),
    'pri.segments.fixed_bitset_memory': z.string().describe('memory used by fixed bit sets for nested object field types and export type filters for types referred in _parent fields').optional(),
    'warmer.current': z.string().describe('current warmer ops').optional(),
    'pri.warmer.current': z.string().describe('current warmer ops').optional(),
    'warmer.total': z.string().describe('total warmer ops').optional(),
    'pri.warmer.total': z.string().describe('total warmer ops').optional(),
    'warmer.total_time': z.string().describe('time spent in warmers').optional(),
    'pri.warmer.total_time': z.string().describe('time spent in warmers').optional(),
    'suggest.current': z.string().describe('number of current suggest ops').optional(),
    'pri.suggest.current': z.string().describe('number of current suggest ops').optional(),
    'suggest.time': z.string().describe('time spend in suggest').optional(),
    'pri.suggest.time': z.string().describe('time spend in suggest').optional(),
    'suggest.total': z.string().describe('number of suggest ops').optional(),
    'pri.suggest.total': z.string().describe('number of suggest ops').optional(),
    'memory.total': z.string().describe('total used memory').optional(),
    'pri.memory.total': z.string().describe('total user memory').optional(),
    'search.throttled': z.string().describe('indicates if the index is search throttled').optional(),
    'bulk.total_operations': z.string().describe('number of bulk shard ops').optional(),
    'pri.bulk.total_operations': z.string().describe('number of bulk shard ops').optional(),
    'bulk.total_time': z.string().describe('time spend in shard bulk').optional(),
    'pri.bulk.total_time': z.string().describe('time spend in shard bulk').optional(),
    'bulk.total_size_in_bytes': z.string().describe('total size in bytes of shard bulk').optional(),
    'pri.bulk.total_size_in_bytes': z.string().describe('total size in bytes of shard bulk').optional(),
    'bulk.avg_time': z.string().describe('average time spend in shard bulk').optional(),
    'pri.bulk.avg_time': z.string().describe('average time spend in shard bulk').optional(),
    'bulk.avg_size_in_bytes': z.string().describe('average size in bytes of shard bulk').optional(),
    'pri.bulk.avg_size_in_bytes': z.string().describe('average size in bytes of shard bulk').optional()
});

export const cat_types_cat_master_column = z.union([
    z.enum([
        'id',
        'host',
        'h',
        'ip',
        'node',
        'n'
    ]),
    z.string()
]);

export const cat_types_cat_master_columns = z.union([
    cat_types_cat_master_column,
    z.array(cat_types_cat_master_column)
]);

export const cat_master_master_record = z.object({
    id: z.string().describe('node id').optional(),
    host: z.string().describe('host name').optional(),
    ip: z.string().describe('ip address').optional(),
    node: z.string().describe('node name').optional()
});

export const cat_types_cat_dfa_column = z.enum([
    'assignment_explanation',
    'ae',
    'create_time',
    'ct',
    'createTime',
    'description',
    'd',
    'dest_index',
    'di',
    'destIndex',
    'failure_reason',
    'fr',
    'failureReason',
    'id',
    'model_memory_limit',
    'mml',
    'modelMemoryLimit',
    'node.address',
    'na',
    'nodeAddress',
    'node.ephemeral_id',
    'ne',
    'nodeEphemeralId',
    'node.id',
    'ni',
    'nodeId',
    'node.name',
    'nn',
    'nodeName',
    'progress',
    'p',
    'source_index',
    'si',
    'sourceIndex',
    'state',
    's',
    'type',
    't',
    'version',
    'v'
]);

export const cat_types_cat_dfa_columns = z.union([
    cat_types_cat_dfa_column,
    z.array(cat_types_cat_dfa_column)
]);

export const types_version_string = z.string();

export const cat_ml_data_frame_analytics_data_frame_analytics_record = z.object({
    id: types_id.optional(),
    type: z.string().describe('The type of analysis that the job performs.').optional(),
    create_time: z.string().describe('The time when the job was created.').optional(),
    version: types_version_string.optional(),
    source_index: types_index_name.optional(),
    dest_index: types_index_name.optional(),
    description: z.string().describe('A description of the job.').optional(),
    model_memory_limit: z.string().describe('The approximate maximum amount of memory resources that are permitted for the job.').optional(),
    state: z.string().describe('The current status of the job.').optional(),
    failure_reason: z.string().describe('Messages about the reason why the job failed.').optional(),
    progress: z.string().describe('The progress report for the job by phase.').optional(),
    assignment_explanation: z.string().describe('Messages related to the selection of a node.').optional(),
    'node.id': types_id.optional(),
    'node.name': types_name.optional(),
    'node.ephemeral_id': types_id.optional(),
    'node.address': z.string().describe('The network address of the assigned node.').optional()
});

export const cat_types_cat_datafeed_column = z.enum([
    'ae',
    'assignment_explanation',
    'bc',
    'buckets.count',
    'bucketsCount',
    'id',
    'na',
    'node.address',
    'nodeAddress',
    'ne',
    'node.ephemeral_id',
    'nodeEphemeralId',
    'ni',
    'node.id',
    'nodeId',
    'nn',
    'node.name',
    'nodeName',
    'sba',
    'search.bucket_avg',
    'searchBucketAvg',
    'sc',
    'search.count',
    'searchCount',
    'seah',
    'search.exp_avg_hour',
    'searchExpAvgHour',
    'st',
    'search.time',
    'searchTime',
    's',
    'state'
]);

export const cat_types_cat_datafeed_columns = z.union([
    cat_types_cat_datafeed_column,
    z.array(cat_types_cat_datafeed_column)
]);

export const ml_types_datafeed_state = z.enum([
    'started',
    'stopped',
    'starting',
    'stopping'
]);

export const cat_ml_datafeeds_datafeeds_record = z.object({
    id: z.string().describe('The datafeed identifier.').optional(),
    state: ml_types_datafeed_state.optional(),
    assignment_explanation: z.string().describe('For started datafeeds only, contains messages relating to the selection of a node.').optional(),
    'buckets.count': z.string().describe('The number of buckets processed.').optional(),
    'search.count': z.string().describe('The number of searches run by the datafeed.').optional(),
    'search.time': z.string().describe('The total time the datafeed spent searching, in milliseconds.').optional(),
    'search.bucket_avg': z.string().describe('The average search time per bucket, in milliseconds.').optional(),
    'search.exp_avg_hour': z.string().describe('The exponential average search time per hour, in milliseconds.').optional(),
    'node.id': z.string().describe('The unique identifier of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.').optional(),
    'node.name': z.string().describe('The name of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.').optional(),
    'node.ephemeral_id': z.string().describe('The ephemeral identifier of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.').optional(),
    'node.address': z.string().describe('The network address of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.').optional()
});

export const cat_types_cat_anomaly_detector_column = z.enum([
    'assignment_explanation',
    'ae',
    'buckets.count',
    'bc',
    'bucketsCount',
    'buckets.time.exp_avg',
    'btea',
    'bucketsTimeExpAvg',
    'buckets.time.exp_avg_hour',
    'bteah',
    'bucketsTimeExpAvgHour',
    'buckets.time.max',
    'btmax',
    'bucketsTimeMax',
    'buckets.time.min',
    'btmin',
    'bucketsTimeMin',
    'buckets.time.total',
    'btt',
    'bucketsTimeTotal',
    'data.buckets',
    'db',
    'dataBuckets',
    'data.earliest_record',
    'der',
    'dataEarliestRecord',
    'data.empty_buckets',
    'deb',
    'dataEmptyBuckets',
    'data.input_bytes',
    'dib',
    'dataInputBytes',
    'data.input_fields',
    'dif',
    'dataInputFields',
    'data.input_records',
    'dir',
    'dataInputRecords',
    'data.invalid_dates',
    'did',
    'dataInvalidDates',
    'data.last',
    'dl',
    'dataLast',
    'data.last_empty_bucket',
    'dleb',
    'dataLastEmptyBucket',
    'data.last_sparse_bucket',
    'dlsb',
    'dataLastSparseBucket',
    'data.latest_record',
    'dlr',
    'dataLatestRecord',
    'data.missing_fields',
    'dmf',
    'dataMissingFields',
    'data.out_of_order_timestamps',
    'doot',
    'dataOutOfOrderTimestamps',
    'data.processed_fields',
    'dpf',
    'dataProcessedFields',
    'data.processed_records',
    'dpr',
    'dataProcessedRecords',
    'data.sparse_buckets',
    'dsb',
    'dataSparseBuckets',
    'forecasts.memory.avg',
    'fmavg',
    'forecastsMemoryAvg',
    'forecasts.memory.max',
    'fmmax',
    'forecastsMemoryMax',
    'forecasts.memory.min',
    'fmmin',
    'forecastsMemoryMin',
    'forecasts.memory.total',
    'fmt',
    'forecastsMemoryTotal',
    'forecasts.records.avg',
    'fravg',
    'forecastsRecordsAvg',
    'forecasts.records.max',
    'frmax',
    'forecastsRecordsMax',
    'forecasts.records.min',
    'frmin',
    'forecastsRecordsMin',
    'forecasts.records.total',
    'frt',
    'forecastsRecordsTotal',
    'forecasts.time.avg',
    'ftavg',
    'forecastsTimeAvg',
    'forecasts.time.max',
    'ftmax',
    'forecastsTimeMax',
    'forecasts.time.min',
    'ftmin',
    'forecastsTimeMin',
    'forecasts.time.total',
    'ftt',
    'forecastsTimeTotal',
    'forecasts.total',
    'ft',
    'forecastsTotal',
    'id',
    'model.bucket_allocation_failures',
    'mbaf',
    'modelBucketAllocationFailures',
    'model.by_fields',
    'mbf',
    'modelByFields',
    'model.bytes',
    'mb',
    'modelBytes',
    'model.bytes_exceeded',
    'mbe',
    'modelBytesExceeded',
    'model.categorization_status',
    'mcs',
    'modelCategorizationStatus',
    'model.categorized_doc_count',
    'mcdc',
    'modelCategorizedDocCount',
    'model.dead_category_count',
    'mdcc',
    'modelDeadCategoryCount',
    'model.failed_category_count',
    'mdcc',
    'modelFailedCategoryCount',
    'model.frequent_category_count',
    'mfcc',
    'modelFrequentCategoryCount',
    'model.log_time',
    'mlt',
    'modelLogTime',
    'model.memory_limit',
    'mml',
    'modelMemoryLimit',
    'model.memory_status',
    'mms',
    'modelMemoryStatus',
    'model.over_fields',
    'mof',
    'modelOverFields',
    'model.partition_fields',
    'mpf',
    'modelPartitionFields',
    'model.rare_category_count',
    'mrcc',
    'modelRareCategoryCount',
    'model.timestamp',
    'mt',
    'modelTimestamp',
    'model.total_category_count',
    'mtcc',
    'modelTotalCategoryCount',
    'node.address',
    'na',
    'nodeAddress',
    'node.ephemeral_id',
    'ne',
    'nodeEphemeralId',
    'node.id',
    'ni',
    'nodeId',
    'node.name',
    'nn',
    'nodeName',
    'opened_time',
    'ot',
    'state',
    's'
]);

export const cat_types_cat_anomaly_detector_columns = z.union([
    cat_types_cat_anomaly_detector_column,
    z.array(cat_types_cat_anomaly_detector_column)
]);

export const ml_types_job_state = z.enum([
    'closing',
    'closed',
    'opened',
    'failed',
    'opening'
]);

export const ml_types_memory_status = z.enum([
    'ok',
    'soft_limit',
    'hard_limit'
]);

export const ml_types_categorization_status = z.enum(['ok', 'warn']);

export const cat_ml_jobs_jobs_record = z.object({
    id: types_id.optional(),
    state: ml_types_job_state.optional(),
    opened_time: z.string().describe('For open jobs only, the amount of time the job has been opened.').optional(),
    assignment_explanation: z.string().describe('For open anomaly detection jobs only, contains messages relating to the selection of a node to run the job.').optional(),
    'data.processed_records': z.string().describe('The number of input documents that have been processed by the anomaly detection job.\nThis value includes documents with missing fields, since they are nonetheless analyzed.\nIf you use datafeeds and have aggregations in your search query, the `processed_record_count` is the number of aggregation results processed, not the number of Elasticsearch documents.').optional(),
    'data.processed_fields': z.string().describe('The total number of fields in all the documents that have been processed by the anomaly detection job.\nOnly fields that are specified in the detector configuration object contribute to this count.\nThe timestamp is not included in this count.').optional(),
    'data.input_bytes': types_byte_size.optional(),
    'data.input_records': z.string().describe('The number of input documents posted to the anomaly detection job.').optional(),
    'data.input_fields': z.string().describe('The total number of fields in input documents posted to the anomaly detection job.\nThis count includes fields that are not used in the analysis.\nHowever, be aware that if you are using a datafeed, it extracts only the required fields from the documents it retrieves before posting them to the job.').optional(),
    'data.invalid_dates': z.string().describe('The number of input documents with either a missing date field or a date that could not be parsed.').optional(),
    'data.missing_fields': z.string().describe('The number of input documents that are missing a field that the anomaly detection job is configured to analyze.\nInput documents with missing fields are still processed because it is possible that not all fields are missing.\nIf you are using datafeeds or posting data to the job in JSON format, a high `missing_field_count` is often not an indication of data issues.\nIt is not necessarily a cause for concern.').optional(),
    'data.out_of_order_timestamps': z.string().describe('The number of input documents that have a timestamp chronologically preceding the start of the current anomaly detection bucket offset by the latency window.\nThis information is applicable only when you provide data to the anomaly detection job by using the post data API.\nThese out of order documents are discarded, since jobs require time series data to be in ascending chronological order.').optional(),
    'data.empty_buckets': z.string().describe('The number of buckets which did not contain any data.\nIf your data contains many empty buckets, consider increasing your `bucket_span` or using functions that are tolerant to gaps in data such as mean, `non_null_sum` or `non_zero_count`.').optional(),
    'data.sparse_buckets': z.string().describe('The number of buckets that contained few data points compared to the expected number of data points.\nIf your data contains many sparse buckets, consider using a longer `bucket_span`.').optional(),
    'data.buckets': z.string().describe('The total number of buckets processed.').optional(),
    'data.earliest_record': z.string().describe('The timestamp of the earliest chronologically input document.').optional(),
    'data.latest_record': z.string().describe('The timestamp of the latest chronologically input document.').optional(),
    'data.last': z.string().describe('The timestamp at which data was last analyzed, according to server time.').optional(),
    'data.last_empty_bucket': z.string().describe('The timestamp of the last bucket that did not contain any data.').optional(),
    'data.last_sparse_bucket': z.string().describe('The timestamp of the last bucket that was considered sparse.').optional(),
    'model.bytes': types_byte_size.optional(),
    'model.memory_status': ml_types_memory_status.optional(),
    'model.bytes_exceeded': types_byte_size.optional(),
    'model.memory_limit': z.string().describe('The upper limit for model memory usage, checked on increasing values.').optional(),
    'model.by_fields': z.string().describe('The number of `by` field values that were analyzed by the models.\nThis value is cumulative for all detectors in the job.').optional(),
    'model.over_fields': z.string().describe('The number of `over` field values that were analyzed by the models.\nThis value is cumulative for all detectors in the job.').optional(),
    'model.partition_fields': z.string().describe('The number of `partition` field values that were analyzed by the models.\nThis value is cumulative for all detectors in the job.').optional(),
    'model.bucket_allocation_failures': z.string().describe('The number of buckets for which new entities in incoming data were not processed due to insufficient model memory.\nThis situation is also signified by a `hard_limit: memory_status` property value.').optional(),
    'model.categorization_status': ml_types_categorization_status.optional(),
    'model.categorized_doc_count': z.string().describe('The number of documents that have had a field categorized.').optional(),
    'model.total_category_count': z.string().describe('The number of categories created by categorization.').optional(),
    'model.frequent_category_count': z.string().describe('The number of categories that match more than 1% of categorized documents.').optional(),
    'model.rare_category_count': z.string().describe('The number of categories that match just one categorized document.').optional(),
    'model.dead_category_count': z.string().describe('The number of categories created by categorization that will never be assigned again because another categorys definition makes it a superset of the dead category.\nDead categories are a side effect of the way categorization has no prior training.').optional(),
    'model.failed_category_count': z.string().describe('The number of times that categorization wanted to create a new category but couldnt because the job had hit its `model_memory_limit`.\nThis count does not track which specific categories failed to be created.\nTherefore you cannot use this value to determine the number of unique categories that were missed.').optional(),
    'model.log_time': z.string().describe('The timestamp when the model stats were gathered, according to server time.').optional(),
    'model.timestamp': z.string().describe('The timestamp of the last record when the model stats were gathered.').optional(),
    'forecasts.total': z.string().describe('The number of individual forecasts currently available for the job.\nA value of one or more indicates that forecasts exist.').optional(),
    'forecasts.memory.min': z.string().describe('The minimum memory usage in bytes for forecasts related to the anomaly detection job.').optional(),
    'forecasts.memory.max': z.string().describe('The maximum memory usage in bytes for forecasts related to the anomaly detection job.').optional(),
    'forecasts.memory.avg': z.string().describe('The average memory usage in bytes for forecasts related to the anomaly detection job.').optional(),
    'forecasts.memory.total': z.string().describe('The total memory usage in bytes for forecasts related to the anomaly detection job.').optional(),
    'forecasts.records.min': z.string().describe('The minimum number of `model_forecast` documents written for forecasts related to the anomaly detection job.').optional(),
    'forecasts.records.max': z.string().describe('The maximum number of `model_forecast` documents written for forecasts related to the anomaly detection job.').optional(),
    'forecasts.records.avg': z.string().describe('The average number of `model_forecast` documents written for forecasts related to the anomaly detection job.').optional(),
    'forecasts.records.total': z.string().describe('The total number of `model_forecast` documents written for forecasts related to the anomaly detection job.').optional(),
    'forecasts.time.min': z.string().describe('The minimum runtime in milliseconds for forecasts related to the anomaly detection job.').optional(),
    'forecasts.time.max': z.string().describe('The maximum runtime in milliseconds for forecasts related to the anomaly detection job.').optional(),
    'forecasts.time.avg': z.string().describe('The average runtime in milliseconds for forecasts related to the anomaly detection job.').optional(),
    'forecasts.time.total': z.string().describe('The total runtime in milliseconds for forecasts related to the anomaly detection job.').optional(),
    'node.id': types_node_id.optional(),
    'node.name': z.string().describe('The name of the assigned node.').optional(),
    'node.ephemeral_id': types_node_id.optional(),
    'node.address': z.string().describe('The network address of the assigned node.').optional(),
    'buckets.count': z.string().describe('The number of bucket results produced by the job.').optional(),
    'buckets.time.total': z.string().describe('The sum of all bucket processing times, in milliseconds.').optional(),
    'buckets.time.min': z.string().describe('The minimum of all bucket processing times, in milliseconds.').optional(),
    'buckets.time.max': z.string().describe('The maximum of all bucket processing times, in milliseconds.').optional(),
    'buckets.time.exp_avg': z.string().describe('The exponential moving average of all bucket processing times, in milliseconds.').optional(),
    'buckets.time.exp_avg_hour': z.string().describe('The exponential moving average of bucket processing times calculated in a one hour time window, in milliseconds.').optional()
});

export const cat_types_cat_trained_models_column = z.enum([
    'create_time',
    'ct',
    'created_by',
    'c',
    'createdBy',
    'data_frame_analytics_id',
    'df',
    'dataFrameAnalytics',
    'dfid',
    'description',
    'd',
    'heap_size',
    'hs',
    'modelHeapSize',
    'id',
    'ingest.count',
    'ic',
    'ingestCount',
    'ingest.current',
    'icurr',
    'ingestCurrent',
    'ingest.failed',
    'if',
    'ingestFailed',
    'ingest.pipelines',
    'ip',
    'ingestPipelines',
    'ingest.time',
    'it',
    'ingestTime',
    'license',
    'l',
    'operations',
    'o',
    'modelOperations',
    'version',
    'v'
]);

export const cat_types_cat_trained_models_columns = z.union([
    cat_types_cat_trained_models_column,
    z.array(cat_types_cat_trained_models_column)
]);

export const cat_ml_trained_models_trained_models_record = z.object({
    id: types_id.optional(),
    created_by: z.string().describe('Information about the creator of the model.').optional(),
    heap_size: types_byte_size.optional(),
    operations: z.string().describe('The estimated number of operations to use the model.\nThis number helps to measure the computational complexity of the model.').optional(),
    license: z.string().describe('The license level of the model.').optional(),
    create_time: types_date_time.optional(),
    version: types_version_string.optional(),
    description: z.string().describe('A description of the model.').optional(),
    'ingest.pipelines': z.string().describe('The number of pipelines that are referencing the model.').optional(),
    'ingest.count': z.string().describe('The total number of documents that are processed by the model.').optional(),
    'ingest.time': z.string().describe('The total time spent processing documents with thie model.').optional(),
    'ingest.current': z.string().describe('The total number of documents that are currently being handled by the model.').optional(),
    'ingest.failed': z.string().describe('The total number of failed ingest attempts with the model.').optional(),
    'data_frame.id': z.string().describe('The identifier for the data frame analytics job that created the model.\nOnly displayed if the job is still available.').optional(),
    'data_frame.create_time': z.string().describe('The time the data frame analytics job was created.').optional(),
    'data_frame.source_index': z.string().describe('The source index used to train in the data frame analysis.').optional(),
    'data_frame.analysis': z.string().describe('The analysis used by the data frame to build the model.').optional(),
    type: z.string().optional()
});

export const cat_types_cat_nodeattrs_column = z.union([
    z.enum([
        'node',
        'id',
        'id',
        'nodeId',
        'pid',
        'p',
        'host',
        'h',
        'ip',
        'i',
        'port',
        'po',
        'attr',
        'attr.name',
        'value',
        'attr.value'
    ]),
    z.string()
]);

export const cat_types_cat_nodeattrs_columns = z.union([
    cat_types_cat_nodeattrs_column,
    z.array(cat_types_cat_nodeattrs_column)
]);

export const cat_nodeattrs_node_attributes_record = z.object({
    node: z.string().describe('The node name.').optional(),
    id: z.string().describe('The unique node identifier.').optional(),
    pid: z.string().describe('The process identifier.').optional(),
    host: z.string().describe('The host name.').optional(),
    ip: z.string().describe('The IP address.').optional(),
    port: z.string().describe('The bound transport port.').optional(),
    attr: z.string().describe('The attribute name.').optional(),
    value: z.string().describe('The attribute value.').optional()
});

export const cat_types_cat_node_column = z.union([
    z.enum([
        'build',
        'b',
        'completion.size',
        'cs',
        'completionSize',
        'cpu',
        'disk.avail',
        'd',
        'disk',
        'diskAvail',
        'disk.total',
        'dt',
        'diskTotal',
        'disk.used',
        'du',
        'diskUsed',
        'disk.used_percent',
        'dup',
        'diskUsedPercent',
        'fielddata.evictions',
        'fe',
        'fielddataEvictions',
        'fielddata.memory_size',
        'fm',
        'fielddataMemory',
        'file_desc.current',
        'fdc',
        'fileDescriptorCurrent',
        'file_desc.max',
        'fdm',
        'fileDescriptorMax',
        'file_desc.percent',
        'fdp',
        'fileDescriptorPercent',
        'flush.total',
        'ft',
        'flushTotal',
        'flush.total_time',
        'ftt',
        'flushTotalTime',
        'get.current',
        'gc',
        'getCurrent',
        'get.exists_time',
        'geti',
        'getExistsTime',
        'get.exists_total',
        'geto',
        'getExistsTotal',
        'get.missing_time',
        'gmti',
        'getMissingTime',
        'get.missing_total',
        'gmto',
        'getMissingTotal',
        'get.time',
        'gti',
        'getTime',
        'get.total',
        'gto',
        'getTotal',
        'heap.current',
        'hc',
        'heapCurrent',
        'heap.max',
        'hm',
        'heapMax',
        'heap.percent',
        'hp',
        'heapPercent',
        'http_address',
        'http',
        'id',
        'nodeId',
        'indexing.delete_current',
        'idc',
        'indexingDeleteCurrent',
        'indexing.delete_time',
        'idti',
        'indexingDeleteTime',
        'indexing.delete_total',
        'idto',
        'indexingDeleteTotal',
        'indexing.index_current',
        'iic',
        'indexingIndexCurrent',
        'indexing.index_failed',
        'iif',
        'indexingIndexFailed',
        'indexing.index_failed_due_to_version_conflict',
        'iifvc',
        'indexingIndexFailedDueToVersionConflict',
        'indexing.index_time',
        'iiti',
        'indexingIndexTime',
        'indexing.index_total',
        'iito',
        'indexingIndexTotal',
        'ip',
        'i',
        'jdk',
        'j',
        'load_1m',
        'l',
        'load_5m',
        'l',
        'load_15m',
        'l',
        'available_processors',
        'ap',
        'mappings.total_count',
        'mtc',
        'mappingsTotalCount',
        'mappings.total_estimated_overhead_in_bytes',
        'mteo',
        'mappingsTotalEstimatedOverheadInBytes',
        'master',
        'm',
        'merges.current',
        'mc',
        'mergesCurrent',
        'merges.current_docs',
        'mcd',
        'mergesCurrentDocs',
        'merges.current_size',
        'mcs',
        'mergesCurrentSize',
        'merges.total',
        'mt',
        'mergesTotal',
        'merges.total_docs',
        'mtd',
        'mergesTotalDocs',
        'merges.total_size',
        'mts',
        'mergesTotalSize',
        'merges.total_time',
        'mtt',
        'mergesTotalTime',
        'name',
        'n',
        'node.role',
        'r',
        'role',
        'nodeRole',
        'pid',
        'p',
        'port',
        'po',
        'query_cache.memory_size',
        'qcm',
        'queryCacheMemory',
        'query_cache.evictions',
        'qce',
        'queryCacheEvictions',
        'query_cache.hit_count',
        'qchc',
        'queryCacheHitCount',
        'query_cache.miss_count',
        'qcmc',
        'queryCacheMissCount',
        'ram.current',
        'rc',
        'ramCurrent',
        'ram.max',
        'rm',
        'ramMax',
        'ram.percent',
        'rp',
        'ramPercent',
        'refresh.total',
        'rto',
        'refreshTotal',
        'refresh.time',
        'rti',
        'refreshTime',
        'request_cache.memory_size',
        'rcm',
        'requestCacheMemory',
        'request_cache.evictions',
        'rce',
        'requestCacheEvictions',
        'request_cache.hit_count',
        'rchc',
        'requestCacheHitCount',
        'request_cache.miss_count',
        'rcmc',
        'requestCacheMissCount',
        'script.compilations',
        'scrcc',
        'scriptCompilations',
        'script.cache_evictions',
        'scrce',
        'scriptCacheEvictions',
        'search.fetch_current',
        'sfc',
        'searchFetchCurrent',
        'search.fetch_time',
        'sfti',
        'searchFetchTime',
        'search.fetch_total',
        'sfto',
        'searchFetchTotal',
        'search.open_contexts',
        'so',
        'searchOpenContexts',
        'search.query_current',
        'sqc',
        'searchQueryCurrent',
        'search.query_time',
        'sqti',
        'searchQueryTime',
        'search.query_total',
        'sqto',
        'searchQueryTotal',
        'search.scroll_current',
        'scc',
        'searchScrollCurrent',
        'search.scroll_time',
        'scti',
        'searchScrollTime',
        'search.scroll_total',
        'scto',
        'searchScrollTotal',
        'segments.count',
        'sc',
        'segmentsCount',
        'segments.fixed_bitset_memory',
        'sfbm',
        'fixedBitsetMemory',
        'segments.index_writer_memory',
        'siwm',
        'segmentsIndexWriterMemory',
        'segments.memory',
        'sm',
        'segmentsMemory',
        'segments.version_map_memory',
        'svmm',
        'segmentsVersionMapMemory',
        'shard_stats.total_count',
        'sstc',
        'shards',
        'shardStatsTotalCount',
        'suggest.current',
        'suc',
        'suggestCurrent',
        'suggest.time',
        'suti',
        'suggestTime',
        'suggest.total',
        'suto',
        'suggestTotal',
        'uptime',
        'u',
        'version',
        'v'
    ]),
    z.string()
]);

export const cat_types_cat_node_columns = z.union([
    cat_types_cat_node_column,
    z.array(cat_types_cat_node_column)
]);

export const cat_nodes_nodes_record = z.object({
    id: types_id.optional(),
    pid: z.string().describe('The process identifier.').optional(),
    ip: z.string().describe('The IP address.').optional(),
    port: z.string().describe('The bound transport port.').optional(),
    http_address: z.string().describe('The bound HTTP address.').optional(),
    version: types_version_string.optional(),
    flavor: z.string().describe('The Elasticsearch distribution flavor.').optional(),
    type: z.string().describe('The Elasticsearch distribution type.').optional(),
    build: z.string().describe('The Elasticsearch build hash.').optional(),
    jdk: z.string().describe('The Java version.').optional(),
    'disk.total': types_byte_size.optional(),
    'disk.used': types_byte_size.optional(),
    'disk.avail': types_byte_size.optional(),
    'disk.used_percent': types_percentage.optional(),
    'heap.current': z.string().describe('The used heap.').optional(),
    'heap.percent': types_percentage.optional(),
    'heap.max': z.string().describe('The maximum configured heap.').optional(),
    'ram.current': z.string().describe('The used machine memory.').optional(),
    'ram.percent': types_percentage.optional(),
    'ram.max': z.string().describe('The total machine memory.').optional(),
    'file_desc.current': z.string().describe('The used file descriptors.').optional(),
    'file_desc.percent': types_percentage.optional(),
    'file_desc.max': z.string().describe('The maximum number of file descriptors.').optional(),
    cpu: z.string().describe('The recent system CPU usage as a percentage.').optional(),
    load_1m: z.string().describe('The load average for the most recent minute.').optional(),
    load_5m: z.string().describe('The load average for the last five minutes.').optional(),
    load_15m: z.string().describe('The load average for the last fifteen minutes.').optional(),
    available_processors: z.string().describe('The number of available processors (logical CPU cores available to the JVM).').optional(),
    uptime: z.string().describe('The node uptime.').optional(),
    'node.role': z.string().describe('The roles of the node.\nReturned values include `c`(cold node), `d`(data node), `f`(frozen node), `h`(hot node), `i`(ingest node), `l`(machine learning node), `m` (master eligible node), `r`(remote cluster client node), `s`(content node), `t`(transform node), `v`(voting-only node), `w`(warm node),and `-`(coordinating node only).').optional(),
    master: z.string().describe('Indicates whether the node is the elected master node.\nReturned values include `*`(elected master) and `-`(not elected master).').optional(),
    name: types_name.optional(),
    'completion.size': z.string().describe('The size of completion.').optional(),
    'fielddata.memory_size': z.string().describe('The used fielddata cache.').optional(),
    'fielddata.evictions': z.string().describe('The fielddata evictions.').optional(),
    'query_cache.memory_size': z.string().describe('The used query cache.').optional(),
    'query_cache.evictions': z.string().describe('The query cache evictions.').optional(),
    'query_cache.hit_count': z.string().describe('The query cache hit counts.').optional(),
    'query_cache.miss_count': z.string().describe('The query cache miss counts.').optional(),
    'request_cache.memory_size': z.string().describe('The used request cache.').optional(),
    'request_cache.evictions': z.string().describe('The request cache evictions.').optional(),
    'request_cache.hit_count': z.string().describe('The request cache hit counts.').optional(),
    'request_cache.miss_count': z.string().describe('The request cache miss counts.').optional(),
    'flush.total': z.string().describe('The number of flushes.').optional(),
    'flush.total_time': z.string().describe('The time spent in flush.').optional(),
    'get.current': z.string().describe('The number of current get ops.').optional(),
    'get.time': z.string().describe('The time spent in get.').optional(),
    'get.total': z.string().describe('The number of get ops.').optional(),
    'get.exists_time': z.string().describe('The time spent in successful gets.').optional(),
    'get.exists_total': z.string().describe('The number of successful get operations.').optional(),
    'get.missing_time': z.string().describe('The time spent in failed gets.').optional(),
    'get.missing_total': z.string().describe('The number of failed gets.').optional(),
    'indexing.delete_current': z.string().describe('The number of current deletions.').optional(),
    'indexing.delete_time': z.string().describe('The time spent in deletions.').optional(),
    'indexing.delete_total': z.string().describe('The number of delete operations.').optional(),
    'indexing.index_current': z.string().describe('The number of current indexing operations.').optional(),
    'indexing.index_time': z.string().describe('The time spent in indexing.').optional(),
    'indexing.index_total': z.string().describe('The number of indexing operations.').optional(),
    'indexing.index_failed': z.string().describe('The number of failed indexing operations.').optional(),
    'merges.current': z.string().describe('The number of current merges.').optional(),
    'merges.current_docs': z.string().describe('The number of current merging docs.').optional(),
    'merges.current_size': z.string().describe('The size of current merges.').optional(),
    'merges.total': z.string().describe('The number of completed merge operations.').optional(),
    'merges.total_docs': z.string().describe('The docs merged.').optional(),
    'merges.total_size': z.string().describe('The size merged.').optional(),
    'merges.total_time': z.string().describe('The time spent in merges.').optional(),
    'refresh.total': z.string().describe('The total refreshes.').optional(),
    'refresh.time': z.string().describe('The time spent in refreshes.').optional(),
    'refresh.external_total': z.string().describe('The total external refreshes.').optional(),
    'refresh.external_time': z.string().describe('The time spent in external refreshes.').optional(),
    'refresh.listeners': z.string().describe('The number of pending refresh listeners.').optional(),
    'script.compilations': z.string().describe('The total script compilations.').optional(),
    'script.cache_evictions': z.string().describe('The total compiled scripts evicted from the cache.').optional(),
    'script.compilation_limit_triggered': z.string().describe('The script cache compilation limit triggered.').optional(),
    'search.fetch_current': z.string().describe('The current fetch phase operations.').optional(),
    'search.fetch_time': z.string().describe('The time spent in fetch phase.').optional(),
    'search.fetch_total': z.string().describe('The total fetch operations.').optional(),
    'search.open_contexts': z.string().describe('The open search contexts.').optional(),
    'search.query_current': z.string().describe('The current query phase operations.').optional(),
    'search.query_time': z.string().describe('The time spent in query phase.').optional(),
    'search.query_total': z.string().describe('The total query phase operations.').optional(),
    'search.scroll_current': z.string().describe('The open scroll contexts.').optional(),
    'search.scroll_time': z.string().describe('The time scroll contexts held open.').optional(),
    'search.scroll_total': z.string().describe('The completed scroll contexts.').optional(),
    'segments.count': z.string().describe('The number of segments.').optional(),
    'segments.memory': z.string().describe('The memory used by segments.').optional(),
    'segments.index_writer_memory': z.string().describe('The memory used by the index writer.').optional(),
    'segments.version_map_memory': z.string().describe('The memory used by the version map.').optional(),
    'segments.fixed_bitset_memory': z.string().describe('The memory used by fixed bit sets for nested object field types and export type filters for types referred in _parent fields.').optional(),
    'suggest.current': z.string().describe('The number of current suggest operations.').optional(),
    'suggest.time': z.string().describe('The time spend in suggest.').optional(),
    'suggest.total': z.string().describe('The number of suggest operations.').optional(),
    'bulk.total_operations': z.string().describe('The number of bulk shard operations.').optional(),
    'bulk.total_time': z.string().describe('The time spend in shard bulk.').optional(),
    'bulk.total_size_in_bytes': z.string().describe('The total size in bytes of shard bulk.').optional(),
    'bulk.avg_time': z.string().describe('The average time spend in shard bulk.').optional(),
    'bulk.avg_size_in_bytes': z.string().describe('The average size in bytes of shard bulk.').optional()
});

export const cat_types_cat_pending_tasks_column = z.union([
    z.enum([
        'insertOrder',
        'o',
        'timeInQueue',
        't',
        'priority',
        'p',
        'source',
        's'
    ]),
    z.string()
]);

export const cat_types_cat_pending_tasks_columns = z.union([
    cat_types_cat_pending_tasks_column,
    z.array(cat_types_cat_pending_tasks_column)
]);

export const cat_pending_tasks_pending_tasks_record = z.object({
    insertOrder: z.string().describe('The task insertion order.').optional(),
    timeInQueue: z.string().describe('Indicates how long the task has been in queue.').optional(),
    priority: z.string().describe('The task priority.').optional(),
    source: z.string().describe('The task source.').optional()
});

export const cat_types_cat_plugins_column = z.union([
    z.enum([
        'id',
        'name',
        'n',
        'component',
        'c',
        'version',
        'v',
        'description',
        'd'
    ]),
    z.string()
]);

export const cat_types_cat_plugins_columns = z.union([
    cat_types_cat_plugins_column,
    z.array(cat_types_cat_plugins_column)
]);

export const cat_plugins_plugins_record = z.object({
    id: types_node_id.optional(),
    name: types_name.optional(),
    component: z.string().describe('The component name.').optional(),
    version: types_version_string.optional(),
    description: z.string().describe('The plugin details.').optional(),
    type: z.string().describe('The plugin type.').optional()
});

export const cat_types_cat_recovery_column = z.union([
    z.enum([
        'index',
        'i',
        'idx',
        'shard',
        's',
        'sh',
        'start_time',
        'start',
        'start_time_millis',
        'start_millis',
        'stop_time',
        'stop',
        'stop_time_millis',
        'stop_millis',
        'time',
        't',
        'ti',
        'type',
        'ty',
        'stage',
        'st',
        'source_host',
        'shost',
        'source_node',
        'snode',
        'target_host',
        'thost',
        'target_node',
        'tnode',
        'repository',
        'rep',
        'snapshot',
        'snap',
        'files',
        'f',
        'files_recovered',
        'fr',
        'files_percent',
        'fp',
        'files_total',
        'tf',
        'bytes',
        'b',
        'bytes_recovered',
        'br',
        'bytes_percent',
        'bp',
        'bytes_total',
        'tb',
        'translog_ops',
        'to',
        'translog_ops_recovered',
        'tor',
        'translog_ops_percent',
        'top'
    ]),
    z.string()
]);

export const cat_types_cat_recovery_columns = z.union([
    cat_types_cat_recovery_column,
    z.array(cat_types_cat_recovery_column)
]);

export const cat_recovery_recovery_record = z.object({
    index: types_index_name.optional(),
    shard: z.string().describe('The shard name.').optional(),
    start_time: types_date_time.optional(),
    start_time_millis: types_epoch_time_unit_millis.optional(),
    stop_time: types_date_time.optional(),
    stop_time_millis: types_epoch_time_unit_millis.optional(),
    time: types_duration.optional(),
    type: z.string().describe('The recovery type.').optional(),
    stage: z.string().describe('The recovery stage.').optional(),
    source_host: z.string().describe('The source host.').optional(),
    source_node: z.string().describe('The source node name.').optional(),
    target_host: z.string().describe('The target host.').optional(),
    target_node: z.string().describe('The target node name.').optional(),
    repository: z.string().describe('The repository name.').optional(),
    snapshot: z.string().describe('The snapshot name.').optional(),
    files: z.string().describe('The number of files to recover.').optional(),
    files_recovered: z.string().describe('The files recovered.').optional(),
    files_percent: types_percentage.optional(),
    files_total: z.string().describe('The total number of files.').optional(),
    bytes: z.string().describe('The number of bytes to recover.').optional(),
    bytes_recovered: z.string().describe('The bytes recovered.').optional(),
    bytes_percent: types_percentage.optional(),
    bytes_total: z.string().describe('The total number of bytes.').optional(),
    translog_ops: z.string().describe('The number of translog operations to recover.').optional(),
    translog_ops_recovered: z.string().describe('The translog operations recovered.').optional(),
    translog_ops_percent: types_percentage.optional()
});

export const cat_repositories_repositories_record = z.object({
    id: z.string().describe('The unique repository identifier.').optional(),
    type: z.string().describe('The repository type.').optional()
});

export const cat_types_cat_segments_column = z.union([
    z.enum([
        'index',
        'i',
        'idx',
        'shard',
        's',
        'sh',
        'prirep',
        'p',
        'pr',
        'primaryOrReplica',
        'ip',
        'segment',
        'generation',
        'docs.count',
        'docs.deleted',
        'size',
        'size.memory',
        'committed',
        'searchable',
        'version',
        'compound',
        'id'
    ]),
    z.string()
]);

export const cat_types_cat_segments_columns = z.union([
    cat_types_cat_segments_column,
    z.array(cat_types_cat_segments_column)
]);

export const cat_segments_segments_record = z.object({
    index: types_index_name.optional(),
    shard: z.string().describe('The shard name.').optional(),
    prirep: z.string().describe('The shard type: `primary` or `replica`.').optional(),
    ip: z.string().describe('The IP address of the node where it lives.').optional(),
    id: types_node_id.optional(),
    segment: z.string().describe('The segment name, which is derived from the segment generation and used internally to create file names in the directory of the shard.').optional(),
    generation: z.string().describe('The segment generation number.\nElasticsearch increments this generation number for each segment written then uses this number to derive the segment name.').optional(),
    'docs.count': z.string().describe('The number of documents in the segment.\nThis excludes deleted documents and counts any nested documents separately from their parents.\nIt also excludes documents which were indexed recently and do not yet belong to a segment.').optional(),
    'docs.deleted': z.string().describe('The number of deleted documents in the segment, which might be higher or lower than the number of delete operations you have performed.\nThis number excludes deletes that were performed recently and do not yet belong to a segment.\nDeleted documents are cleaned up by the automatic merge process if it makes sense to do so.\nAlso, Elasticsearch creates extra deleted documents to internally track the recent history of operations on a shard.').optional(),
    size: types_byte_size.optional(),
    'size.memory': types_byte_size.optional(),
    committed: z.string().describe('If `true`, the segment is synced to disk.\nSegments that are synced can survive a hard reboot.\nIf `false`, the data from uncommitted segments is also stored in the transaction log so that Elasticsearch is able to replay changes on the next start.').optional(),
    searchable: z.string().describe('If `true`, the segment is searchable.\nIf `false`, the segment has most likely been written to disk but needs a refresh to be searchable.').optional(),
    version: types_version_string.optional(),
    compound: z.string().describe('If `true`, the segment is stored in a compound file.\nThis means Lucene merged all files from the segment in a single file to save file descriptors.').optional()
});

export const cat_types_cat_shard_column = z.union([
    z.enum([
        'completion.size',
        'cs',
        'completionSize',
        'dataset.size',
        'dense_vector.value_count',
        'dvc',
        'denseVectorCount',
        'docs',
        'd',
        'dc',
        'fielddata.evictions',
        'fe',
        'fielddataEvictions',
        'fielddata.memory_size',
        'fm',
        'fielddataMemory',
        'flush.total',
        'ft',
        'flushTotal',
        'flush.total_time',
        'ftt',
        'flushTotalTime',
        'get.current',
        'gc',
        'getCurrent',
        'get.exists_time',
        'geti',
        'getExistsTime',
        'get.exists_total',
        'geto',
        'getExistsTotal',
        'get.missing_time',
        'gmti',
        'getMissingTime',
        'get.missing_total',
        'gmto',
        'getMissingTotal',
        'get.time',
        'gti',
        'getTime',
        'get.total',
        'gto',
        'getTotal',
        'id',
        'index',
        'i',
        'idx',
        'indexing.delete_current',
        'idc',
        'indexingDeleteCurrent',
        'indexing.delete_time',
        'idti',
        'indexingDeleteTime',
        'indexing.delete_total',
        'idto',
        'indexingDeleteTotal',
        'indexing.index_current',
        'iic',
        'indexingIndexCurrent',
        'indexing.index_failed_due_to_version_conflict',
        'iifvc',
        'indexingIndexFailedDueToVersionConflict',
        'indexing.index_failed',
        'iif',
        'indexingIndexFailed',
        'indexing.index_time',
        'iiti',
        'indexingIndexTime',
        'indexing.index_total',
        'iito',
        'indexingIndexTotal',
        'ip',
        'merges.current',
        'mc',
        'mergesCurrent',
        'merges.current_docs',
        'mcd',
        'mergesCurrentDocs',
        'merges.current_size',
        'mcs',
        'mergesCurrentSize',
        'merges.total',
        'mt',
        'mergesTotal',
        'merges.total_docs',
        'mtd',
        'mergesTotalDocs',
        'merges.total_size',
        'mts',
        'mergesTotalSize',
        'merges.total_time',
        'mtt',
        'mergesTotalTime',
        'node',
        'n',
        'prirep',
        'p',
        'pr',
        'primaryOrReplica',
        'query_cache.evictions',
        'qce',
        'queryCacheEvictions',
        'query_cache.memory_size',
        'qcm',
        'queryCacheMemory',
        'recoverysource.type',
        'rs',
        'refresh.time',
        'rti',
        'refreshTime',
        'refresh.total',
        'rto',
        'refreshTotal',
        'search.fetch_current',
        'sfc',
        'searchFetchCurrent',
        'search.fetch_time',
        'sfti',
        'searchFetchTime',
        'search.fetch_total',
        'sfto',
        'searchFetchTotal',
        'search.open_contexts',
        'so',
        'searchOpenContexts',
        'search.query_current',
        'sqc',
        'searchQueryCurrent',
        'search.query_time',
        'sqti',
        'searchQueryTime',
        'search.query_total',
        'sqto',
        'searchQueryTotal',
        'search.scroll_current',
        'scc',
        'searchScrollCurrent',
        'search.scroll_time',
        'scti',
        'searchScrollTime',
        'search.scroll_total',
        'scto',
        'searchScrollTotal',
        'segments.count',
        'sc',
        'segmentsCount',
        'segments.fixed_bitset_memory',
        'sfbm',
        'fixedBitsetMemory',
        'segments.index_writer_memory',
        'siwm',
        'segmentsIndexWriterMemory',
        'segments.memory',
        'sm',
        'segmentsMemory',
        'segments.version_map_memory',
        'svmm',
        'segmentsVersionMapMemory',
        'seq_no.global_checkpoint',
        'sqg',
        'globalCheckpoint',
        'seq_no.local_checkpoint',
        'sql',
        'localCheckpoint',
        'seq_no.max',
        'sqm',
        'maxSeqNo',
        'shard',
        's',
        'sh',
        'dsparse_vector.value_count',
        'svc',
        'sparseVectorCount',
        'state',
        'st',
        'store',
        'sto',
        'suggest.current',
        'suc',
        'suggestCurrent',
        'suggest.time',
        'suti',
        'suggestTime',
        'suggest.total',
        'suto',
        'suggestTotal',
        'sync_id',
        'unassigned.at',
        'ua',
        'unassigned.details',
        'ud',
        'unassigned.for',
        'uf',
        'unassigned.reason',
        'ur'
    ]),
    z.string()
]);

export const cat_types_cat_shard_columns = z.union([
    cat_types_cat_shard_column,
    z.array(cat_types_cat_shard_column)
]);

export const cat_shards_shards_record = z.object({
    index: z.string().describe('The index name.').optional(),
    shard: z.string().describe('The shard name.').optional(),
    prirep: z.string().describe('The shard type: `primary` or `replica`.').optional(),
    state: z.string().describe('The shard state.\nReturned values include:\n`INITIALIZING`: The shard is recovering from a peer shard or gateway.\n`RELOCATING`: The shard is relocating.\n`STARTED`: The shard has started.\n`UNASSIGNED`: The shard is not assigned to any node.').optional(),
    docs: z.union([
        z.string(),
        z.null()
    ]).optional(),
    store: z.union([
        z.string(),
        z.null()
    ]).optional(),
    dataset: z.union([
        z.string(),
        z.null()
    ]).optional(),
    ip: z.union([
        z.string(),
        z.null()
    ]).optional(),
    id: z.string().describe('The unique identifier for the node.').optional(),
    node: z.union([
        z.string(),
        z.null()
    ]).optional(),
    sync_id: z.string().describe('The sync identifier.').optional(),
    'unassigned.reason': z.string().describe('The reason for the last change to the state of an unassigned shard.\nIt does not explain why the shard is currently unassigned; use the cluster allocation explain API for that information.\nReturned values include:\n`ALLOCATION_FAILED`: Unassigned as a result of a failed allocation of the shard.\n`CLUSTER_RECOVERED`: Unassigned as a result of a full cluster recovery.\n`DANGLING_INDEX_IMPORTED`: Unassigned as a result of importing a dangling index.\n`EXISTING_INDEX_RESTORED`: Unassigned as a result of restoring into a closed index.\n`FORCED_EMPTY_PRIMARY`: The shards allocation was last modified by forcing an empty primary using the cluster reroute API.\n`INDEX_CLOSED`: Unassigned because the index was closed.\n`INDEX_CREATED`: Unassigned as a result of an API creation of an index.\n`INDEX_REOPENED`: Unassigned as a result of opening a closed index.\n`MANUAL_ALLOCATION`: The shards allocation was last modified by the cluster reroute API.\n`NEW_INDEX_RESTORED`: Unassigned as a result of restoring into a new index.\n`NODE_LEFT`: Unassigned as a result of the node hosting it leaving the cluster.\n`NODE_RESTARTING`: Similar to `NODE_LEFT`, except that the node was registered as restarting using the node shutdown API.\n`PRIMARY_FAILED`: The shard was initializing as a replica, but the primary shard failed before the initialization completed.\n`REALLOCATED_REPLICA`: A better replica location is identified and causes the existing replica allocation to be cancelled.\n`REINITIALIZED`: When a shard moves from started back to initializing.\n`REPLICA_ADDED`: Unassigned as a result of explicit addition of a replica.\n`REROUTE_CANCELLED`: Unassigned as a result of explicit cancel reroute command.').optional(),
    'unassigned.at': z.string().describe('The time at which the shard became unassigned in Coordinated Universal Time (UTC).').optional(),
    'unassigned.for': z.string().describe('The time at which the shard was requested to be unassigned in Coordinated Universal Time (UTC).').optional(),
    'unassigned.details': z.string().describe('Additional details as to why the shard became unassigned.\nIt does not explain why the shard is not assigned; use the cluster allocation explain API for that information.').optional(),
    'recoverysource.type': z.string().describe('The type of recovery source.').optional(),
    'completion.size': z.string().describe('The size of completion.').optional(),
    'fielddata.memory_size': z.string().describe('The used fielddata cache memory.').optional(),
    'fielddata.evictions': z.string().describe('The fielddata cache evictions.').optional(),
    'query_cache.memory_size': z.string().describe('The used query cache memory.').optional(),
    'query_cache.evictions': z.string().describe('The query cache evictions.').optional(),
    'flush.total': z.string().describe('The number of flushes.').optional(),
    'flush.total_time': z.string().describe('The time spent in flush.').optional(),
    'get.current': z.string().describe('The number of current get operations.').optional(),
    'get.time': z.string().describe('The time spent in get operations.').optional(),
    'get.total': z.string().describe('The number of get operations.').optional(),
    'get.exists_time': z.string().describe('The time spent in successful get operations.').optional(),
    'get.exists_total': z.string().describe('The number of successful get operations.').optional(),
    'get.missing_time': z.string().describe('The time spent in failed get operations.').optional(),
    'get.missing_total': z.string().describe('The number of failed get operations.').optional(),
    'indexing.delete_current': z.string().describe('The number of current deletion operations.').optional(),
    'indexing.delete_time': z.string().describe('The time spent in deletion operations.').optional(),
    'indexing.delete_total': z.string().describe('The number of delete operations.').optional(),
    'indexing.index_current': z.string().describe('The number of current indexing operations.').optional(),
    'indexing.index_time': z.string().describe('The time spent in indexing operations.').optional(),
    'indexing.index_total': z.string().describe('The number of indexing operations.').optional(),
    'indexing.index_failed': z.string().describe('The number of failed indexing operations.').optional(),
    'merges.current': z.string().describe('The number of current merge operations.').optional(),
    'merges.current_docs': z.string().describe('The number of current merging documents.').optional(),
    'merges.current_size': z.string().describe('The size of current merge operations.').optional(),
    'merges.total': z.string().describe('The number of completed merge operations.').optional(),
    'merges.total_docs': z.string().describe('The nuber of merged documents.').optional(),
    'merges.total_size': z.string().describe('The size of current merges.').optional(),
    'merges.total_time': z.string().describe('The time spent merging documents.').optional(),
    'refresh.total': z.string().describe('The total number of refreshes.').optional(),
    'refresh.time': z.string().describe('The time spent in refreshes.').optional(),
    'refresh.external_total': z.string().describe('The total nunber of external refreshes.').optional(),
    'refresh.external_time': z.string().describe('The time spent in external refreshes.').optional(),
    'refresh.listeners': z.string().describe('The number of pending refresh listeners.').optional(),
    'search.fetch_current': z.string().describe('The current fetch phase operations.').optional(),
    'search.fetch_time': z.string().describe('The time spent in fetch phase.').optional(),
    'search.fetch_total': z.string().describe('The total number of fetch operations.').optional(),
    'search.open_contexts': z.string().describe('The number of open search contexts.').optional(),
    'search.query_current': z.string().describe('The current query phase operations.').optional(),
    'search.query_time': z.string().describe('The time spent in query phase.').optional(),
    'search.query_total': z.string().describe('The total number of query phase operations.').optional(),
    'search.scroll_current': z.string().describe('The open scroll contexts.').optional(),
    'search.scroll_time': z.string().describe('The time scroll contexts were held open.').optional(),
    'search.scroll_total': z.string().describe('The number of completed scroll contexts.').optional(),
    'segments.count': z.string().describe('The number of segments.').optional(),
    'segments.memory': z.string().describe('The memory used by segments.').optional(),
    'segments.index_writer_memory': z.string().describe('The memory used by the index writer.').optional(),
    'segments.version_map_memory': z.string().describe('The memory used by the version map.').optional(),
    'segments.fixed_bitset_memory': z.string().describe('The memory used by fixed bit sets for nested object field types and export type filters for types referred in `_parent` fields.').optional(),
    'seq_no.max': z.string().describe('The maximum sequence number.').optional(),
    'seq_no.local_checkpoint': z.string().describe('The local checkpoint.').optional(),
    'seq_no.global_checkpoint': z.string().describe('The global checkpoint.').optional(),
    'warmer.current': z.string().describe('The number of current warmer operations.').optional(),
    'warmer.total': z.string().describe('The total number of warmer operations.').optional(),
    'warmer.total_time': z.string().describe('The time spent in warmer operations.').optional(),
    'path.data': z.string().describe('The shard data path.').optional(),
    'path.state': z.string().describe('The shard state path.').optional(),
    'bulk.total_operations': z.string().describe('The number of bulk shard operations.').optional(),
    'bulk.total_time': z.string().describe('The time spent in shard bulk operations.').optional(),
    'bulk.total_size_in_bytes': z.string().describe('The total size in bytes of shard bulk operations.').optional(),
    'bulk.avg_time': z.string().describe('The average time spent in shard bulk operations.').optional(),
    'bulk.avg_size_in_bytes': z.string().describe('The average size in bytes of shard bulk operations.').optional()
});

export const cat_types_cat_snapshots_column = z.union([
    z.enum([
        'id',
        'snapshot',
        'repository',
        're',
        'repo',
        'status',
        's',
        'start_epoch',
        'ste',
        'startEpoch',
        'start_time',
        'sti',
        'startTime',
        'end_epoch',
        'ete',
        'endEpoch',
        'end_time',
        'eti',
        'endTime',
        'duration',
        'dur',
        'indices',
        'i',
        'successful_shards',
        'ss',
        'failed_shards',
        'fs',
        'total_shards',
        'ts',
        'reason',
        'r'
    ]),
    z.string()
]);

export const cat_types_cat_snapshots_columns = z.union([
    cat_types_cat_snapshots_column,
    z.array(cat_types_cat_snapshots_column)
]);

export const watcher_types_hour_and_minute = z.object({
    hour: z.array(z.number()),
    minute: z.array(z.number())
});

/**
 * A time of day, expressed either as `hh:mm`, `noon`, `midnight`, or an hour/minutes structure.
 */
export const watcher_types_schedule_time_of_day = z.union([
    z.string(),
    watcher_types_hour_and_minute
]);

export const cat_snapshots_snapshots_record = z.object({
    id: z.string().describe('The unique identifier for the snapshot.').optional(),
    repository: z.string().describe('The repository name.').optional(),
    status: z.string().describe('The state of the snapshot process.\nReturned values include:\n`FAILED`: The snapshot process failed.\n`INCOMPATIBLE`: The snapshot process is incompatible with the current cluster version.\n`IN_PROGRESS`: The snapshot process started but has not completed.\n`PARTIAL`: The snapshot process completed with a partial success.\n`SUCCESS`: The snapshot process completed with a full success.').optional(),
    start_epoch: spec_utils_stringified_epoch_time_unit_seconds.optional(),
    start_time: watcher_types_schedule_time_of_day.optional(),
    end_epoch: spec_utils_stringified_epoch_time_unit_seconds.optional(),
    end_time: types_time_of_day.optional(),
    duration: types_duration.optional(),
    indices: z.string().describe('The number of indices in the snapshot.').optional(),
    successful_shards: z.string().describe('The number of successful shards in the snapshot.').optional(),
    failed_shards: z.string().describe('The number of failed shards in the snapshot.').optional(),
    total_shards: z.string().describe('The total number of shards in the snapshot.').optional(),
    reason: z.string().describe('The reason for any snapshot failures.').optional()
});

export const cat_types_cat_tasks_column = z.union([
    z.enum([
        'id',
        'action',
        'ac',
        'task_id',
        'ti',
        'parent_task_id',
        'pti',
        'type',
        'ty',
        'start_time',
        'start',
        'timestamp',
        'ts',
        'hms',
        'hhmmss',
        'running_time_ns',
        'time',
        'running_time',
        'time',
        'node_id',
        'ni',
        'ip',
        'i',
        'port',
        'po',
        'node',
        'n',
        'version',
        'v',
        'x_opaque_id',
        'x'
    ]),
    z.string()
]);

export const cat_types_cat_tasks_columns = z.union([
    cat_types_cat_tasks_column,
    z.array(cat_types_cat_tasks_column)
]);

export const cat_tasks_tasks_record = z.object({
    id: types_id.optional(),
    action: z.string().describe('The task action.').optional(),
    task_id: types_id.optional(),
    parent_task_id: z.string().describe('The parent task identifier.').optional(),
    type: z.string().describe('The task type.').optional(),
    start_time: z.string().describe('The start time in milliseconds.').optional(),
    timestamp: z.string().describe('The start time in `HH:MM:SS` format.').optional(),
    running_time_ns: z.string().describe('The running time in nanoseconds.').optional(),
    running_time: z.string().describe('The running time.').optional(),
    node_id: types_node_id.optional(),
    ip: z.string().describe('The IP address for the node.').optional(),
    port: z.string().describe('The bound transport port for the node.').optional(),
    node: z.string().describe('The node name.').optional(),
    version: types_version_string.optional(),
    x_opaque_id: z.string().describe('The X-Opaque-ID header.').optional(),
    description: z.string().describe('The task action description.').optional()
});

export const cat_types_cat_templates_column = z.union([
    z.enum([
        'name',
        'n',
        'index_patterns',
        't',
        'order',
        'o',
        'p',
        'version',
        'v',
        'composed_of',
        'c'
    ]),
    z.string()
]);

export const cat_types_cat_templates_columns = z.union([
    cat_types_cat_templates_column,
    z.array(cat_types_cat_templates_column)
]);

export const cat_templates_templates_record = z.object({
    name: types_name.optional(),
    index_patterns: z.string().describe('The template index patterns.').optional(),
    order: z.string().describe('The template application order or priority number.').optional(),
    version: z.union([
        types_version_string,
        z.string(),
        z.null()
    ]).optional(),
    composed_of: z.string().describe('The component templates that comprise the index template.').optional()
});

export const cat_types_cat_thread_pool_column = z.union([
    z.enum([
        'active',
        'a',
        'completed',
        'c',
        'core',
        'cr',
        'ephemeral_id',
        'eid',
        'host',
        'h',
        'ip',
        'i',
        'keep_alive',
        'k',
        'largest',
        'l',
        'max',
        'mx',
        'name',
        'node_id',
        'id',
        'node_name',
        'pid',
        'p',
        'pool_size',
        'psz',
        'port',
        'po',
        'queue',
        'q',
        'queue_size',
        'qs',
        'rejected',
        'r',
        'size',
        'sz',
        'type',
        't'
    ]),
    z.string()
]);

export const cat_types_cat_thread_pool_columns = z.union([
    cat_types_cat_thread_pool_column,
    z.array(cat_types_cat_thread_pool_column)
]);

export const cat_thread_pool_thread_pool_record = z.object({
    node_name: z.string().describe('The node name.').optional(),
    node_id: types_node_id.optional(),
    ephemeral_node_id: z.string().describe('The ephemeral node identifier.').optional(),
    pid: z.string().describe('The process identifier.').optional(),
    host: z.string().describe('The host name for the current node.').optional(),
    ip: z.string().describe('The IP address for the current node.').optional(),
    port: z.string().describe('The bound transport port for the current node.').optional(),
    name: z.string().describe('The thread pool name.').optional(),
    type: z.string().describe('The thread pool type.\nReturned values include `fixed`, `fixed_auto_queue_size`, `direct`, and `scaling`.').optional(),
    active: z.string().describe('The number of active threads in the current thread pool.').optional(),
    pool_size: z.string().describe('The number of threads in the current thread pool.').optional(),
    queue: z.string().describe('The number of tasks currently in queue.').optional(),
    queue_size: z.string().describe('The maximum number of tasks permitted in the queue.').optional(),
    rejected: z.string().describe('The number of rejected tasks.').optional(),
    largest: z.string().describe('The highest number of active threads in the current thread pool.').optional(),
    completed: z.string().describe('The number of completed tasks.').optional(),
    core: z.union([
        z.string(),
        z.null()
    ]).optional(),
    max: z.union([
        z.string(),
        z.null()
    ]).optional(),
    size: z.union([
        z.string(),
        z.null()
    ]).optional(),
    keep_alive: z.union([
        z.string(),
        z.null()
    ]).optional()
});

export const cat_types_cat_transform_column = z.enum([
    'changes_last_detection_time',
    'cldt',
    'checkpoint',
    'cp',
    'checkpoint_duration_time_exp_avg',
    'cdtea',
    'checkpointTimeExpAvg',
    'checkpoint_progress',
    'c',
    'checkpointProgress',
    'create_time',
    'ct',
    'createTime',
    'delete_time',
    'dtime',
    'description',
    'd',
    'dest_index',
    'di',
    'destIndex',
    'documents_deleted',
    'docd',
    'documents_indexed',
    'doci',
    'docs_per_second',
    'dps',
    'documents_processed',
    'docp',
    'frequency',
    'f',
    'id',
    'index_failure',
    'if',
    'index_time',
    'itime',
    'index_total',
    'it',
    'indexed_documents_exp_avg',
    'idea',
    'last_search_time',
    'lst',
    'lastSearchTime',
    'max_page_search_size',
    'mpsz',
    'pages_processed',
    'pp',
    'pipeline',
    'p',
    'processed_documents_exp_avg',
    'pdea',
    'processing_time',
    'pt',
    'reason',
    'r',
    'search_failure',
    'sf',
    'search_time',
    'stime',
    'search_total',
    'st',
    'source_index',
    'si',
    'sourceIndex',
    'state',
    's',
    'transform_type',
    'tt',
    'trigger_count',
    'tc',
    'version',
    'v'
]);

export const cat_types_cat_transform_columns = z.union([
    cat_types_cat_transform_column,
    z.array(cat_types_cat_transform_column)
]);

export const cat_transforms_transforms_record = z.object({
    id: types_id.optional(),
    state: z.string().describe('The status of the transform.\nReturned values include:\n`aborting`: The transform is aborting.\n`failed: The transform failed. For more information about the failure, check the `reason` field.\n`indexing`: The transform is actively processing data and creating new documents.\n`started`: The transform is running but not actively indexing data.\n`stopped`: The transform is stopped.\n`stopping`: The transform is stopping.').optional(),
    checkpoint: z.string().describe('The sequence number for the checkpoint.').optional(),
    documents_processed: z.string().describe('The number of documents that have been processed from the source index of the transform.').optional(),
    checkpoint_progress: z.union([
        z.string(),
        z.null()
    ]).optional(),
    last_search_time: z.union([
        z.string(),
        z.null()
    ]).optional(),
    changes_last_detection_time: z.union([
        z.string(),
        z.null()
    ]).optional(),
    create_time: z.string().describe('The time the transform was created.').optional(),
    version: types_version_string.optional(),
    source_index: z.string().describe('The source indices for the transform.').optional(),
    dest_index: z.string().describe('The destination index for the transform.').optional(),
    pipeline: z.string().describe('The unique identifier for the ingest pipeline.').optional(),
    description: z.string().describe('The description of the transform.').optional(),
    transform_type: z.string().describe('The type of transform: `batch` or `continuous`.').optional(),
    frequency: z.string().describe('The interval between checks for changes in the source indices when the transform is running continuously.').optional(),
    max_page_search_size: z.string().describe('The initial page size that is used for the composite aggregation for each checkpoint.').optional(),
    docs_per_second: z.string().describe('The number of input documents per second.').optional(),
    reason: z.string().describe('If a transform has a `failed` state, these details describe the reason for failure.').optional(),
    search_total: z.string().describe('The total number of search operations on the source index for the transform.').optional(),
    search_failure: z.string().describe('The total number of search failures.').optional(),
    search_time: z.string().describe('The total amount of search time, in milliseconds.').optional(),
    index_total: z.string().describe('The total number of index operations done by the transform.').optional(),
    index_failure: z.string().describe('The total number of indexing failures.').optional(),
    index_time: z.string().describe('The total time spent indexing documents, in milliseconds.').optional(),
    documents_indexed: z.string().describe('The number of documents that have been indexed into the destination index for the transform.').optional(),
    delete_time: z.string().describe('The total time spent deleting documents, in milliseconds.').optional(),
    documents_deleted: z.string().describe('The number of documents deleted from the destination index due to the retention policy for the transform.').optional(),
    trigger_count: z.string().describe('The number of times the transform has been triggered by the scheduler.\nFor example, the scheduler triggers the transform indexer to check for updates or ingest new data at an interval specified in the `frequency` property.').optional(),
    pages_processed: z.string().describe('The number of search or bulk index operations processed.\nDocuments are processed in batches instead of individually.').optional(),
    processing_time: z.string().describe('The total time spent processing results, in milliseconds.').optional(),
    checkpoint_duration_time_exp_avg: z.string().describe('The exponential moving average of the duration of the checkpoint, in milliseconds.').optional(),
    indexed_documents_exp_avg: z.string().describe('The exponential moving average of the number of new documents that have been indexed.').optional(),
    processed_documents_exp_avg: z.string().describe('The exponential moving average of the number of documents that have been processed.').optional()
});

export const indices_types_retention_lease = z.object({
    period: types_duration
});

export const indices_types_soft_deletes = z.object({
    enabled: z.boolean().describe('Indicates whether soft deletes are enabled on the index.').optional().default(true),
    retention_lease: indices_types_retention_lease.optional()
});

export const indices_types_segment_sort_order = z.enum([
    'asc',
    'ASC',
    'desc',
    'DESC'
]);

export const indices_types_segment_sort_mode = z.enum([
    'min',
    'MIN',
    'max',
    'MAX'
]);

export const indices_types_segment_sort_missing = z.enum(['_last', '_first']);

export const indices_types_index_segment_sort = z.object({
    field: types_fields.optional(),
    order: z.union([
        indices_types_segment_sort_order,
        z.array(indices_types_segment_sort_order)
    ]).optional(),
    mode: z.union([
        indices_types_segment_sort_mode,
        z.array(indices_types_segment_sort_mode)
    ]).optional(),
    missing: z.union([
        indices_types_segment_sort_missing,
        z.array(indices_types_segment_sort_missing)
    ]).optional()
});

export const indices_types_index_check_on_startup = z.enum([
    'true',
    'false',
    'checksum'
]);

/**
 * Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
 * is used to capture this behavior while keeping the semantics of the field type.
 *
 * Depending on the target language, code generators can keep the union or remove it and leniently parse
 * strings to the target type.
 */
export const spec_utils_stringifiedinteger = z.union([
    z.number(),
    z.string()
]);

/**
 * A `null` value that is to be interpreted as an actual value, unless other uses of `null` that are equivalent
 * to a missing value. It is used for exemple in settings, where using the `NullValue` for a setting will reset
 * it to its default value.
 */
export const spec_utils_null_value = z.union([
    z.string(),
    z.null()
]);

export const indices_types_merge_scheduler = z.object({
    max_thread_count: spec_utils_stringifiedinteger.optional(),
    max_merge_count: spec_utils_stringifiedinteger.optional()
});

export const indices_types_merge = z.object({
    scheduler: indices_types_merge_scheduler.optional()
});

export const indices_types_search_idle = z.object({
    after: types_duration.optional()
});

export const indices_types_slowlog_treshold_levels = z.object({
    warn: types_duration.optional(),
    info: types_duration.optional(),
    debug: types_duration.optional(),
    trace: types_duration.optional()
});

export const indices_types_slowlog_tresholds = z.object({
    query: indices_types_slowlog_treshold_levels.optional(),
    fetch: indices_types_slowlog_treshold_levels.optional()
});

export const indices_types_slowlog_settings = z.object({
    level: z.string().optional(),
    source: z.number().optional(),
    reformat: z.boolean().optional(),
    threshold: indices_types_slowlog_tresholds.optional()
});

export const indices_types_settings_search = z.object({
    idle: indices_types_search_idle.optional(),
    slowlog: indices_types_slowlog_settings.optional()
});

/**
 * Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
 * is used to capture this behavior while keeping the semantics of the field type.
 *
 * Depending on the target language, code generators can keep the union or remove it and leniently parse
 * strings to the target type.
 */
export const spec_utils_stringifiedboolean = z.union([
    z.boolean(),
    z.string()
]);

export const indices_types_index_setting_blocks = z.object({
    read_only: spec_utils_stringifiedboolean.optional(),
    read_only_allow_delete: spec_utils_stringifiedboolean.optional(),
    read: spec_utils_stringifiedboolean.optional(),
    write: spec_utils_stringifiedboolean.optional(),
    metadata: spec_utils_stringifiedboolean.optional()
});

export const indices_types_settings_analyze = z.object({
    max_token_count: spec_utils_stringifiedinteger.optional()
});

export const indices_types_settings_highlight = z.object({
    max_analyzed_offset: z.number().optional().default(1000000)
});

export const indices_types_index_routing_allocation_options = z.enum([
    'all',
    'primaries',
    'new_primaries',
    'none'
]);

export const indices_types_index_routing_allocation_include = z.object({
    _tier_preference: z.string().optional(),
    _id: types_id.optional()
});

export const indices_types_index_routing_allocation_initial_recovery = z.object({
    _id: types_id.optional()
});

export const indices_types_index_routing_allocation_disk = z.object({
    threshold_enabled: z.union([
        z.boolean(),
        z.string()
    ]).optional()
});

export const indices_types_index_routing_allocation = z.object({
    enable: indices_types_index_routing_allocation_options.optional(),
    include: indices_types_index_routing_allocation_include.optional(),
    initial_recovery: indices_types_index_routing_allocation_initial_recovery.optional(),
    disk: indices_types_index_routing_allocation_disk.optional()
});

export const indices_types_index_routing_rebalance_options = z.enum([
    'all',
    'primaries',
    'replicas',
    'none'
]);

export const indices_types_index_routing_rebalance = z.object({
    enable: indices_types_index_routing_rebalance_options
});

export const indices_types_index_routing = z.object({
    allocation: indices_types_index_routing_allocation.optional(),
    rebalance: indices_types_index_routing_rebalance.optional()
});

export const types_pipeline_name = z.string();

export const indices_types_index_settings_lifecycle_step = z.object({
    wait_time_threshold: types_duration.optional()
});

export const indices_types_index_settings_lifecycle = z.object({
    name: types_name.optional(),
    indexing_complete: spec_utils_stringifiedboolean.optional(),
    origination_date: z.number().describe('If specified, this is the timestamp used to calculate the index age for its phase transitions. Use this setting\nif you create a new index that contains old data and want to use the original creation date to calculate the index\nage. Specified as a Unix epoch value in milliseconds.').optional().default(0),
    parse_origination_date: z.boolean().describe('Set to true to parse the origination date from the index name. This origination date is used to calculate the index age\nfor its phase transitions. The index name must match the pattern ^.*-{date_format}-\\\\d+, where the date_format is\nyyyy.MM.dd and the trailing digits are optional. An index that was rolled over would normally match the full format,\nfor example logs-2016.10.31-000002). If the index name doesnt match the pattern, index creation fails.').optional(),
    step: indices_types_index_settings_lifecycle_step.optional(),
    rollover_alias: z.string().describe('The index alias to update when the index rolls over. Specify when using a policy that contains a rollover action.\nWhen the index rolls over, the alias is updated to reflect that the index is no longer the write index. For more\ninformation about rolling indices, see Rollover.').optional().default(''),
    prefer_ilm: z.union([
        z.boolean(),
        z.string()
    ]).optional()
});

/**
 * Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
 * is used to capture this behavior while keeping the semantics of the field type.
 *
 * Depending on the target language, code generators can keep the union or remove it and leniently parse
 * strings to the target type.
 */
export const spec_utils_stringified_epoch_time_unit_millis = z.union([
    types_epoch_time_unit_millis,
    z.string()
]);

export const types_uuid = z.string();

export const indices_types_index_versioning = z.object({
    created: types_version_string.optional(),
    created_string: z.string().optional()
});

export const indices_types_translog_durability = z.enum([
    'request',
    'REQUEST',
    'async',
    'ASYNC'
]);

export const indices_types_translog_retention = z.object({
    size: types_byte_size.optional(),
    age: types_duration.optional()
});

export const indices_types_translog = z.object({
    sync_interval: types_duration.optional(),
    durability: indices_types_translog_durability.optional(),
    flush_threshold_size: types_byte_size.optional(),
    retention: indices_types_translog_retention.optional()
});

export const indices_types_settings_query_string = z.object({
    lenient: spec_utils_stringifiedboolean
});

export const types_analysis_custom_analyzer = z.object({
    type: z.enum(['custom']),
    char_filter: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    filter: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    position_increment_gap: z.number().optional(),
    position_offset_gap: z.number().optional(),
    tokenizer: z.string()
});

export const types_analysis_fingerprint_analyzer = z.object({
    type: z.enum(['fingerprint']),
    version: types_version_string.optional(),
    max_output_size: z.number().describe('The maximum token size to emit. Tokens larger than this size will be discarded.\nDefaults to `255`').optional().default(255),
    separator: z.string().describe('The character to use to concatenate the terms.\nDefaults to a space.').optional(),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().describe('The path to a file containing stop words.').optional()
});

export const types_analysis_keyword_analyzer = z.object({
    type: z.enum(['keyword']),
    version: types_version_string.optional()
});

export const types_analysis_nori_decompound_mode = z.enum([
    'discard',
    'none',
    'mixed'
]);

export const types_analysis_nori_analyzer = z.object({
    type: z.enum(['nori']),
    version: types_version_string.optional(),
    decompound_mode: types_analysis_nori_decompound_mode.optional(),
    stoptags: z.array(z.string()).optional(),
    user_dictionary: z.string().optional()
});

export const types_analysis_pattern_analyzer = z.object({
    type: z.enum(['pattern']),
    version: types_version_string.optional(),
    flags: z.string().describe('Java regular expression flags. Flags should be pipe-separated, eg "CASE_INSENSITIVE|COMMENTS".').optional(),
    lowercase: z.boolean().describe('Should terms be lowercased or not.\nDefaults to `true`.').optional().default(true),
    pattern: z.string().describe('A Java regular expression.\nDefaults to `\\W+`.').optional().default('\\W+'),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().describe('The path to a file containing stop words.').optional()
});

export const types_analysis_simple_analyzer = z.object({
    type: z.enum(['simple']),
    version: types_version_string.optional()
});

export const types_analysis_standard_analyzer = z.object({
    type: z.enum(['standard']),
    max_token_length: z.number().describe('The maximum token length. If a token is seen that exceeds this length then it is split at `max_token_length` intervals.\nDefaults to `255`.').optional().default(255),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().describe('The path to a file containing stop words.').optional()
});

export const types_analysis_stop_analyzer = z.object({
    type: z.enum(['stop']),
    version: types_version_string.optional(),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().describe('The path to a file containing stop words.').optional()
});

export const types_analysis_whitespace_analyzer = z.object({
    type: z.enum(['whitespace']),
    version: types_version_string.optional()
});

export const types_analysis_icu_normalization_type = z.enum([
    'nfc',
    'nfkc',
    'nfkc_cf'
]);

export const types_analysis_icu_normalization_mode = z.enum(['decompose', 'compose']);

export const types_analysis_icu_analyzer = z.object({
    type: z.enum(['icu_analyzer']),
    method: types_analysis_icu_normalization_type,
    mode: types_analysis_icu_normalization_mode
});

export const types_analysis_kuromoji_tokenization_mode = z.enum([
    'normal',
    'search',
    'extended'
]);

export const types_analysis_kuromoji_analyzer = z.object({
    type: z.enum(['kuromoji']),
    mode: types_analysis_kuromoji_tokenization_mode.optional(),
    user_dictionary: z.string().optional()
});

export const types_analysis_snowball_language = z.enum([
    'Arabic',
    'Armenian',
    'Basque',
    'Catalan',
    'Danish',
    'Dutch',
    'English',
    'Estonian',
    'Finnish',
    'French',
    'German',
    'German2',
    'Hungarian',
    'Italian',
    'Irish',
    'Kp',
    'Lithuanian',
    'Lovins',
    'Norwegian',
    'Porter',
    'Portuguese',
    'Romanian',
    'Russian',
    'Serbian',
    'Spanish',
    'Swedish',
    'Turkish'
]);

export const types_analysis_snowball_analyzer = z.object({
    type: z.enum(['snowball']),
    version: types_version_string.optional(),
    language: types_analysis_snowball_language,
    stopwords: types_analysis_stop_words.optional()
});

export const types_analysis_arabic_analyzer = z.object({
    type: z.enum(['arabic']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_armenian_analyzer = z.object({
    type: z.enum(['armenian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_basque_analyzer = z.object({
    type: z.enum(['basque']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_bengali_analyzer = z.object({
    type: z.enum(['bengali']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_brazilian_analyzer = z.object({
    type: z.enum(['brazilian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional()
});

export const types_analysis_bulgarian_analyzer = z.object({
    type: z.enum(['bulgarian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_catalan_analyzer = z.object({
    type: z.enum(['catalan']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_chinese_analyzer = z.object({
    type: z.enum(['chinese']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional()
});

export const types_analysis_cjk_analyzer = z.object({
    type: z.enum(['cjk']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional()
});

export const types_analysis_czech_analyzer = z.object({
    type: z.enum(['czech']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_danish_analyzer = z.object({
    type: z.enum(['danish']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional()
});

export const types_analysis_dutch_analyzer = z.object({
    type: z.enum(['dutch']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_english_analyzer = z.object({
    type: z.enum(['english']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_estonian_analyzer = z.object({
    type: z.enum(['estonian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional()
});

export const types_analysis_finnish_analyzer = z.object({
    type: z.enum(['finnish']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_french_analyzer = z.object({
    type: z.enum(['french']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_galician_analyzer = z.object({
    type: z.enum(['galician']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_german_analyzer = z.object({
    type: z.enum(['german']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_greek_analyzer = z.object({
    type: z.enum(['greek']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional()
});

export const types_analysis_hindi_analyzer = z.object({
    type: z.enum(['hindi']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_hungarian_analyzer = z.object({
    type: z.enum(['hungarian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_indonesian_analyzer = z.object({
    type: z.enum(['indonesian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_irish_analyzer = z.object({
    type: z.enum(['irish']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_italian_analyzer = z.object({
    type: z.enum(['italian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_latvian_analyzer = z.object({
    type: z.enum(['latvian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_lithuanian_analyzer = z.object({
    type: z.enum(['lithuanian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_norwegian_analyzer = z.object({
    type: z.enum(['norwegian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_persian_analyzer = z.object({
    type: z.enum(['persian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional()
});

export const types_analysis_portuguese_analyzer = z.object({
    type: z.enum(['portuguese']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_romanian_analyzer = z.object({
    type: z.enum(['romanian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_russian_analyzer = z.object({
    type: z.enum(['russian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_serbian_analyzer = z.object({
    type: z.enum(['serbian']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_sorani_analyzer = z.object({
    type: z.enum(['sorani']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_spanish_analyzer = z.object({
    type: z.enum(['spanish']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_swedish_analyzer = z.object({
    type: z.enum(['swedish']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_turkish_analyzer = z.object({
    type: z.enum(['turkish']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional(),
    stem_exclusion: z.array(z.string()).optional()
});

export const types_analysis_thai_analyzer = z.object({
    type: z.enum(['thai']),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().optional()
});

export const types_analysis_analyzer = z.union([
    types_analysis_custom_analyzer,
    types_analysis_fingerprint_analyzer,
    types_analysis_keyword_analyzer,
    types_analysis_nori_analyzer,
    types_analysis_pattern_analyzer,
    types_analysis_simple_analyzer,
    types_analysis_standard_analyzer,
    types_analysis_stop_analyzer,
    types_analysis_whitespace_analyzer,
    types_analysis_icu_analyzer,
    types_analysis_kuromoji_analyzer,
    types_analysis_snowball_analyzer,
    types_analysis_arabic_analyzer,
    types_analysis_armenian_analyzer,
    types_analysis_basque_analyzer,
    types_analysis_bengali_analyzer,
    types_analysis_brazilian_analyzer,
    types_analysis_bulgarian_analyzer,
    types_analysis_catalan_analyzer,
    types_analysis_chinese_analyzer,
    types_analysis_cjk_analyzer,
    types_analysis_czech_analyzer,
    types_analysis_danish_analyzer,
    types_analysis_dutch_analyzer,
    types_analysis_english_analyzer,
    types_analysis_estonian_analyzer,
    types_analysis_finnish_analyzer,
    types_analysis_french_analyzer,
    types_analysis_galician_analyzer,
    types_analysis_german_analyzer,
    types_analysis_greek_analyzer,
    types_analysis_hindi_analyzer,
    types_analysis_hungarian_analyzer,
    types_analysis_indonesian_analyzer,
    types_analysis_irish_analyzer,
    types_analysis_italian_analyzer,
    types_analysis_latvian_analyzer,
    types_analysis_lithuanian_analyzer,
    types_analysis_norwegian_analyzer,
    types_analysis_persian_analyzer,
    types_analysis_portuguese_analyzer,
    types_analysis_romanian_analyzer,
    types_analysis_russian_analyzer,
    types_analysis_serbian_analyzer,
    types_analysis_sorani_analyzer,
    types_analysis_spanish_analyzer,
    types_analysis_swedish_analyzer,
    types_analysis_turkish_analyzer,
    types_analysis_thai_analyzer
]);

export const types_analysis_char_filter_base = z.object({
    version: types_version_string.optional()
});

export const types_analysis_html_strip_char_filter = types_analysis_char_filter_base.and(z.object({
    type: z.enum(['html_strip']),
    escaped_tags: z.array(z.string()).optional()
}));

export const types_analysis_mapping_char_filter = types_analysis_char_filter_base.and(z.object({
    type: z.enum(['mapping']),
    mappings: z.array(z.string()).optional(),
    mappings_path: z.string().optional()
}));

export const types_analysis_pattern_replace_char_filter = types_analysis_char_filter_base.and(z.object({
    type: z.enum(['pattern_replace']),
    flags: z.string().optional(),
    pattern: z.string(),
    replacement: z.string().optional()
}));

export const types_analysis_icu_normalization_char_filter = types_analysis_char_filter_base.and(z.object({
    type: z.enum(['icu_normalizer']),
    mode: types_analysis_icu_normalization_mode.optional(),
    name: types_analysis_icu_normalization_type.optional(),
    unicode_set_filter: z.string().optional()
}));

export const types_analysis_kuromoji_iteration_mark_char_filter = types_analysis_char_filter_base.and(z.object({
    type: z.enum(['kuromoji_iteration_mark']),
    normalize_kana: z.boolean(),
    normalize_kanji: z.boolean()
}));

export const types_analysis_char_filter_definition = z.union([
    types_analysis_html_strip_char_filter,
    types_analysis_mapping_char_filter,
    types_analysis_pattern_replace_char_filter,
    types_analysis_icu_normalization_char_filter,
    types_analysis_kuromoji_iteration_mark_char_filter
]);

export const types_analysis_char_filter = z.union([
    z.string(),
    types_analysis_char_filter_definition
]);

export const types_analysis_token_filter_base = z.object({
    version: types_version_string.optional()
});

export const types_analysis_apostrophe_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['apostrophe'])
}));

export const types_analysis_arabic_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['arabic_stem'])
}));

export const types_analysis_arabic_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['arabic_normalization'])
}));

export const types_analysis_ascii_folding_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['asciifolding']),
    preserve_original: spec_utils_stringifiedboolean.optional()
}));

export const types_analysis_bengali_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['bengali_normalization'])
}));

export const types_analysis_brazilian_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['brazilian_stem'])
}));

export const types_analysis_cjk_bigram_ignored_script = z.enum([
    'han',
    'hangul',
    'hiragana',
    'katakana'
]);

export const types_analysis_cjk_bigram_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['cjk_bigram']),
    ignored_scripts: z.array(types_analysis_cjk_bigram_ignored_script).describe('Array of character scripts for which to disable bigrams.').optional(),
    output_unigrams: z.boolean().describe('If `true`, emit tokens in both bigram and unigram form. If `false`, a CJK character is output in unigram form when it has no adjacent characters. Defaults to `false`.').optional()
}));

export const types_analysis_cjk_width_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['cjk_width'])
}));

export const types_analysis_classic_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['classic'])
}));

export const types_analysis_common_grams_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['common_grams']),
    common_words: z.array(z.string()).describe('A list of tokens. The filter generates bigrams for these tokens.\nEither this or the `common_words_path` parameter is required.').optional(),
    common_words_path: z.string().describe('Path to a file containing a list of tokens. The filter generates bigrams for these tokens.\nThis path must be absolute or relative to the `config` location. The file must be UTF-8 encoded. Each token in the file must be separated by a line break.\nEither this or the `common_words` parameter is required.').optional(),
    ignore_case: z.boolean().describe('If `true`, matches for common words matching are case-insensitive. Defaults to `false`.').optional(),
    query_mode: z.boolean().describe('If `true`, the filter excludes the following tokens from the output:\n- Unigrams for common words\n- Unigrams for terms followed by common words\nDefaults to `false`. We recommend enabling this parameter for search analyzers.').optional()
}));

export const types_analysis_czech_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['czech_stem'])
}));

export const types_analysis_decimal_digit_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['decimal_digit'])
}));

export const types_analysis_delimited_payload_encoding = z.enum([
    'int',
    'float',
    'identity'
]);

export const types_analysis_delimited_payload_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['delimited_payload']),
    delimiter: z.string().describe('Character used to separate tokens from payloads. Defaults to `|`.').optional(),
    encoding: types_analysis_delimited_payload_encoding.optional()
}));

export const types_analysis_dutch_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['dutch_stem'])
}));

export const types_analysis_edge_n_gram_side = z.enum(['front', 'back']);

export const types_analysis_edge_n_gram_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['edge_ngram']),
    max_gram: z.number().describe('Maximum character length of a gram. For custom token filters, defaults to `2`. For the built-in edge_ngram filter, defaults to `1`.').optional(),
    min_gram: z.number().describe('Minimum character length of a gram. Defaults to `1`.').optional(),
    side: types_analysis_edge_n_gram_side.optional(),
    preserve_original: spec_utils_stringifiedboolean.optional()
}));

export const types_analysis_elision_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['elision']),
    articles: z.array(z.string()).describe('List of elisions to remove.\nTo be removed, the elision must be at the beginning of a token and be immediately followed by an apostrophe. Both the elision and apostrophe are removed.\nFor custom `elision` filters, either this parameter or `articles_path` must be specified.').optional(),
    articles_path: z.string().describe('Path to a file that contains a list of elisions to remove.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each elision in the file must be separated by a line break.\nTo be removed, the elision must be at the beginning of a token and be immediately followed by an apostrophe. Both the elision and apostrophe are removed.\nFor custom `elision` filters, either this parameter or `articles` must be specified.').optional(),
    articles_case: spec_utils_stringifiedboolean.optional()
}));

export const types_analysis_fingerprint_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['fingerprint']),
    max_output_size: z.number().describe('Maximum character length, including whitespace, of the output token. Defaults to `255`. Concatenated tokens longer than this will result in no token output.').optional(),
    separator: z.string().describe('Character to use to concatenate the token stream input. Defaults to a space.').optional()
}));

export const types_analysis_flatten_graph_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['flatten_graph'])
}));

export const types_analysis_french_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['french_stem'])
}));

export const types_analysis_german_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['german_normalization'])
}));

export const types_analysis_german_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['german_stem'])
}));

export const types_analysis_hindi_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['hindi_normalization'])
}));

export const types_analysis_hunspell_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['hunspell']),
    dedup: z.boolean().describe('If `true`, duplicate tokens are removed from the filters output. Defaults to `true`.').optional(),
    dictionary: z.string().describe('One or more `.dic` files (e.g, `en_US.dic`, my_custom.dic) to use for the Hunspell dictionary.\nBy default, the `hunspell` filter uses all `.dic` files in the `<$ES_PATH_CONF>/hunspell/<locale>` directory specified using the `lang`, `language`, or `locale` parameter.').optional(),
    locale: z.string().describe('Locale directory used to specify the `.aff` and `.dic` files for a Hunspell dictionary.'),
    longest_only: z.boolean().describe('If `true`, only the longest stemmed version of each token is included in the output. If `false`, all stemmed versions of the token are included. Defaults to `false`.').optional()
}));

export const types_analysis_compound_word_token_filter_base = types_analysis_token_filter_base.and(z.object({
    max_subword_size: z.number().describe('Maximum subword character length. Longer subword tokens are excluded from the output. Defaults to `15`.').optional(),
    min_subword_size: z.number().describe('Minimum subword character length. Shorter subword tokens are excluded from the output. Defaults to `2`.').optional(),
    min_word_size: z.number().describe('Minimum word character length. Shorter word tokens are excluded from the output. Defaults to `5`.').optional(),
    only_longest_match: z.boolean().describe('If `true`, only include the longest matching subword. Defaults to `false`.').optional(),
    word_list: z.array(z.string()).describe('A list of subwords to look for in the token stream. If found, the subword is included in the token output.\nEither this parameter or `word_list_path` must be specified.').optional(),
    word_list_path: z.string().describe('Path to a file that contains a list of subwords to find in the token stream. If found, the subword is included in the token output.\nThis path must be absolute or relative to the config location, and the file must be UTF-8 encoded. Each token in the file must be separated by a line break.\nEither this parameter or `word_list` must be specified.').optional()
}));

export const types_analysis_hyphenation_decompounder_token_filter = types_analysis_compound_word_token_filter_base.and(z.object({
    type: z.enum(['hyphenation_decompounder']),
    hyphenation_patterns_path: z.string().describe('Path to an Apache FOP (Formatting Objects Processor) XML hyphenation pattern file.\nThis path must be absolute or relative to the `config` location. Only FOP v1.2 compatible files are supported.'),
    no_sub_matches: z.boolean().describe('If `true`, do not match sub tokens in tokens that are in the word list. Defaults to `false`.').optional(),
    no_overlapping_matches: z.boolean().describe('If `true`, do not allow overlapping tokens. Defaults to `false`.').optional()
}));

export const types_analysis_indic_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['indic_normalization'])
}));

export const types_analysis_keep_types_mode = z.enum(['include', 'exclude']);

export const types_analysis_keep_types_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['keep_types']),
    mode: types_analysis_keep_types_mode.optional(),
    types: z.array(z.string()).describe('List of token types to keep or remove.')
}));

export const types_analysis_keep_words_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['keep']),
    keep_words: z.array(z.string()).describe('List of words to keep. Only tokens that match words in this list are included in the output.\nEither this parameter or `keep_words_path` must be specified.').optional(),
    keep_words_case: z.boolean().describe('If `true`, lowercase all keep words. Defaults to `false`.').optional(),
    keep_words_path: z.string().describe('Path to a file that contains a list of words to keep. Only tokens that match words in this list are included in the output.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each word in the file must be separated by a line break.\nEither this parameter or `keep_words` must be specified.').optional()
}));

export const types_analysis_keyword_marker_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['keyword_marker']),
    ignore_case: z.boolean().describe('If `true`, matching for the `keywords` and `keywords_path` parameters ignores letter case. Defaults to `false`.').optional(),
    keywords: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    keywords_path: z.string().describe('Path to a file that contains a list of keywords. Tokens that match these keywords are not stemmed.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each word in the file must be separated by a line break.\nThis parameter, `keywords`, or `keywords_pattern` must be specified. You cannot specify this parameter and `keywords_pattern`.').optional(),
    keywords_pattern: z.string().describe('Java regular expression used to match tokens. Tokens that match this expression are marked as keywords and not stemmed.\nThis parameter, `keywords`, or `keywords_path` must be specified. You cannot specify this parameter and `keywords` or `keywords_pattern`.').optional()
}));

export const types_analysis_keyword_repeat_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['keyword_repeat'])
}));

export const types_analysis_k_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['kstem'])
}));

export const types_analysis_length_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['length']),
    max: z.number().describe('Maximum character length of a token. Longer tokens are excluded from the output. Defaults to `Integer.MAX_VALUE`, which is `2^31-1` or `2147483647`.').optional(),
    min: z.number().describe('Minimum character length of a token. Shorter tokens are excluded from the output. Defaults to `0`.').optional()
}));

export const types_analysis_limit_token_count_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['limit']),
    consume_all_tokens: z.boolean().describe('If `true`, the limit filter exhausts the token stream, even if the `max_token_count` has already been reached. Defaults to `false`.').optional(),
    max_token_count: spec_utils_stringifiedinteger.optional()
}));

export const types_analysis_lowercase_token_filter_languages = z.enum([
    'greek',
    'irish',
    'turkish'
]);

export const types_analysis_lowercase_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['lowercase']),
    language: types_analysis_lowercase_token_filter_languages.optional()
}));

export const types_analysis_min_hash_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['min_hash']),
    bucket_count: z.number().describe('Number of buckets to which hashes are assigned. Defaults to `512`.').optional(),
    hash_count: z.number().describe('Number of ways to hash each token in the stream. Defaults to `1`.').optional(),
    hash_set_size: z.number().describe('Number of hashes to keep from each bucket. Defaults to `1`.\nHashes are retained by ascending size, starting with the buckets smallest hash first.').optional(),
    with_rotation: z.boolean().describe('If `true`, the filter fills empty buckets with the value of the first non-empty bucket to its circular right if the `hash_set_size` is `1`. If the `bucket_count` argument is greater than 1, this parameter defaults to `true`. Otherwise, this parameter defaults to `false`.').optional()
}));

export const types_analysis_multiplexer_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['multiplexer']),
    filters: z.array(z.string()).describe('A list of token filters to apply to incoming tokens.'),
    preserve_original: spec_utils_stringifiedboolean.optional()
}));

export const types_analysis_n_gram_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['ngram']),
    max_gram: z.number().describe('Maximum length of characters in a gram. Defaults to `2`.').optional(),
    min_gram: z.number().describe('Minimum length of characters in a gram. Defaults to `1`.').optional(),
    preserve_original: spec_utils_stringifiedboolean.optional()
}));

export const types_analysis_nori_part_of_speech_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['nori_part_of_speech']),
    stoptags: z.array(z.string()).describe('An array of part-of-speech tags that should be removed.').optional()
}));

export const types_analysis_pattern_capture_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['pattern_capture']),
    patterns: z.array(z.string()).describe('A list of regular expressions to match.'),
    preserve_original: spec_utils_stringifiedboolean.optional()
}));

export const types_analysis_pattern_replace_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['pattern_replace']),
    all: z.boolean().describe('If `true`, all substrings matching the pattern parameters regular expression are replaced. If `false`, the filter replaces only the first matching substring in each token. Defaults to `true`.').optional(),
    flags: z.string().optional(),
    pattern: z.string().describe('Regular expression, written in Javas regular expression syntax. The filter replaces token substrings matching this pattern with the substring in the `replacement` parameter.'),
    replacement: z.string().describe('Replacement substring. Defaults to an empty substring (`""`).').optional()
}));

export const types_analysis_persian_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['persian_normalization'])
}));

export const types_analysis_persian_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['persian_stem'])
}));

export const types_analysis_porter_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['porter_stem'])
}));

export const types_analysis_remove_duplicates_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['remove_duplicates'])
}));

export const types_analysis_reverse_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['reverse'])
}));

export const types_analysis_russian_stem_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['russian_stem'])
}));

export const types_analysis_scandinavian_folding_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['scandinavian_folding'])
}));

export const types_analysis_scandinavian_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['scandinavian_normalization'])
}));

export const types_analysis_serbian_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['serbian_normalization'])
}));

export const types_analysis_shingle_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['shingle']),
    filler_token: z.string().describe('String used in shingles as a replacement for empty positions that do not contain a token. This filler token is only used in shingles, not original unigrams. Defaults to an underscore (`_`).').optional(),
    max_shingle_size: spec_utils_stringifiedinteger.optional(),
    min_shingle_size: spec_utils_stringifiedinteger.optional(),
    output_unigrams: z.boolean().describe('If `true`, the output includes the original input tokens. If `false`, the output only includes shingles; the original input tokens are removed. Defaults to `true`.').optional(),
    output_unigrams_if_no_shingles: z.boolean().describe('If `true`, the output includes the original input tokens only if no shingles are produced; if shingles are produced, the output only includes shingles. Defaults to `false`.').optional(),
    token_separator: z.string().describe('Separator used to concatenate adjacent tokens to form a shingle. Defaults to a space (`" "`).').optional()
}));

export const types_analysis_snowball_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['snowball']),
    language: types_analysis_snowball_language.optional()
}));

export const types_analysis_sorani_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['sorani_normalization'])
}));

export const types_analysis_stemmer_override_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['stemmer_override']),
    rules: z.array(z.string()).describe('A list of mapping rules to use.').optional(),
    rules_path: z.string().describe('A path (either relative to `config` location, or absolute) to a list of mappings.').optional()
}));

export const types_analysis_stemmer_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['stemmer']),
    language: z.string().optional()
}));

export const types_analysis_stop_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['stop']),
    ignore_case: z.boolean().describe('If `true`, stop word matching is case insensitive. For example, if `true`, a stop word of the matches and removes `The`, `THE`, or `the`. Defaults to `false`.').optional(),
    remove_trailing: z.boolean().describe('If `true`, the last token of a stream is removed if its a stop word. Defaults to `true`.').optional(),
    stopwords: types_analysis_stop_words.optional(),
    stopwords_path: z.string().describe('Path to a file that contains a list of stop words to remove.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each stop word in the file must be separated by a line break.').optional()
}));

export const types_analysis_synonym_format = z.enum(['solr', 'wordnet']);

export const types_analysis_synonym_token_filter_base = types_analysis_token_filter_base.and(z.object({
    expand: z.boolean().describe('Expands definitions for equivalent synonym rules. Defaults to `true`.').optional(),
    format: types_analysis_synonym_format.optional(),
    lenient: z.boolean().describe('If `true` ignores errors while parsing the synonym rules. It is important to note that only those synonym rules which cannot get parsed are ignored. Defaults to the value of the `updateable` setting.').optional(),
    synonyms: z.array(z.string()).describe('Used to define inline synonyms.').optional(),
    synonyms_path: z.string().describe('Used to provide a synonym file. This path must be absolute or relative to the `config` location.').optional(),
    synonyms_set: z.string().describe('Provide a synonym set created via Synonyms Management APIs.').optional(),
    tokenizer: z.string().describe('Controls the tokenizers that will be used to tokenize the synonym, this parameter is for backwards compatibility for indices that created before 6.0.').optional(),
    updateable: z.boolean().describe('If `true` allows reloading search analyzers to pick up changes to synonym files. Only to be used for search analyzers. Defaults to `false`.').optional()
}));

export const types_analysis_synonym_graph_token_filter = types_analysis_synonym_token_filter_base.and(z.object({
    type: z.enum(['synonym_graph'])
}));

export const types_analysis_synonym_token_filter = types_analysis_synonym_token_filter_base.and(z.object({
    type: z.enum(['synonym'])
}));

export const types_analysis_trim_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['trim'])
}));

export const types_analysis_truncate_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['truncate']),
    length: z.number().describe('Character limit for each token. Tokens exceeding this limit are truncated. Defaults to `10`.').optional()
}));

export const types_analysis_unique_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['unique']),
    only_on_same_position: z.boolean().describe('If `true`, only remove duplicate tokens in the same position. Defaults to `false`.').optional()
}));

export const types_analysis_uppercase_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['uppercase'])
}));

export const types_analysis_word_delimiter_token_filter_base = types_analysis_token_filter_base.and(z.object({
    catenate_all: z.boolean().describe('If `true`, the filter produces catenated tokens for chains of alphanumeric characters separated by non-alphabetic delimiters. Defaults to `false`.').optional(),
    catenate_numbers: z.boolean().describe('If `true`, the filter produces catenated tokens for chains of numeric characters separated by non-alphabetic delimiters. Defaults to `false`.').optional(),
    catenate_words: z.boolean().describe('If `true`, the filter produces catenated tokens for chains of alphabetical characters separated by non-alphabetic delimiters. Defaults to `false`.').optional(),
    generate_number_parts: z.boolean().describe('If `true`, the filter includes tokens consisting of only numeric characters in the output. If `false`, the filter excludes these tokens from the output. Defaults to `true`.').optional(),
    generate_word_parts: z.boolean().describe('If `true`, the filter includes tokens consisting of only alphabetical characters in the output. If `false`, the filter excludes these tokens from the output. Defaults to `true`.').optional(),
    preserve_original: spec_utils_stringifiedboolean.optional(),
    protected_words: z.array(z.string()).describe('Array of tokens the filter wont split.').optional(),
    protected_words_path: z.string().describe('Path to a file that contains a list of tokens the filter wont split.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each token in the file must be separated by a line break.').optional(),
    split_on_case_change: z.boolean().describe('If `true`, the filter splits tokens at letter case transitions. For example: camelCase -> [ camel, Case ]. Defaults to `true`.').optional(),
    split_on_numerics: z.boolean().describe('If `true`, the filter splits tokens at letter-number transitions. For example: j2se -> [ j, 2, se ]. Defaults to `true`.').optional(),
    stem_english_possessive: z.boolean().describe('If `true`, the filter removes the English possessive (`\'s`) from the end of each token. For example: O\'Neil\'s -> [ O, Neil ]. Defaults to `true`.').optional(),
    type_table: z.array(z.string()).describe('Array of custom type mappings for characters. This allows you to map non-alphanumeric characters as numeric or alphanumeric to avoid splitting on those characters.').optional(),
    type_table_path: z.string().describe('Path to a file that contains custom type mappings for characters. This allows you to map non-alphanumeric characters as numeric or alphanumeric to avoid splitting on those characters.').optional()
}));

export const types_analysis_word_delimiter_graph_token_filter = types_analysis_word_delimiter_token_filter_base.and(z.object({
    type: z.enum(['word_delimiter_graph']),
    adjust_offsets: z.boolean().describe('If `true`, the filter adjusts the offsets of split or catenated tokens to better reflect their actual position in the token stream. Defaults to `true`.').optional(),
    ignore_keywords: z.boolean().describe('If `true`, the filter skips tokens with a keyword attribute of true. Defaults to `false`.').optional()
}));

export const types_analysis_word_delimiter_token_filter = types_analysis_word_delimiter_token_filter_base.and(z.object({
    type: z.enum(['word_delimiter'])
}));

export const types_analysis_ja_stop_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['ja_stop']),
    stopwords: types_analysis_stop_words.optional()
}));

export const types_analysis_kuromoji_stemmer_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['kuromoji_stemmer']),
    minimum_length: z.number()
}));

export const types_analysis_kuromoji_reading_form_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['kuromoji_readingform']),
    use_romaji: z.boolean()
}));

export const types_analysis_kuromoji_part_of_speech_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['kuromoji_part_of_speech']),
    stoptags: z.array(z.string())
}));

export const types_analysis_icu_collation_alternate = z.enum(['shifted', 'non-ignorable']);

export const types_analysis_icu_collation_case_first = z.enum(['lower', 'upper']);

export const types_analysis_icu_collation_decomposition = z.enum(['no', 'identical']);

export const types_analysis_icu_collation_strength = z.enum([
    'primary',
    'secondary',
    'tertiary',
    'quaternary',
    'identical'
]);

export const types_analysis_icu_collation_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['icu_collation']),
    alternate: types_analysis_icu_collation_alternate.optional(),
    caseFirst: types_analysis_icu_collation_case_first.optional(),
    caseLevel: z.boolean().optional(),
    country: z.string().optional(),
    decomposition: types_analysis_icu_collation_decomposition.optional(),
    hiraganaQuaternaryMode: z.boolean().optional(),
    language: z.string().optional(),
    numeric: z.boolean().optional(),
    rules: z.string().optional(),
    strength: types_analysis_icu_collation_strength.optional(),
    variableTop: z.string().optional(),
    variant: z.string().optional()
}));

export const types_analysis_icu_folding_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['icu_folding']),
    unicode_set_filter: z.string()
}));

export const types_analysis_icu_normalization_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['icu_normalizer']),
    name: types_analysis_icu_normalization_type
}));

export const types_analysis_icu_transform_direction = z.enum(['forward', 'reverse']);

export const types_analysis_icu_transform_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['icu_transform']),
    dir: types_analysis_icu_transform_direction.optional(),
    id: z.string()
}));

export const types_analysis_phonetic_encoder = z.enum([
    'metaphone',
    'double_metaphone',
    'soundex',
    'refined_soundex',
    'caverphone1',
    'caverphone2',
    'cologne',
    'nysiis',
    'koelnerphonetik',
    'haasephonetik',
    'beider_morse',
    'daitch_mokotoff'
]);

export const types_analysis_phonetic_language = z.enum([
    'any',
    'common',
    'cyrillic',
    'english',
    'french',
    'german',
    'hebrew',
    'hungarian',
    'polish',
    'romanian',
    'russian',
    'spanish'
]);

export const types_analysis_phonetic_name_type = z.enum([
    'generic',
    'ashkenazi',
    'sephardic'
]);

export const types_analysis_phonetic_rule_type = z.enum(['approx', 'exact']);

export const types_analysis_phonetic_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['phonetic']),
    encoder: types_analysis_phonetic_encoder,
    languageset: z.union([
        types_analysis_phonetic_language,
        z.array(types_analysis_phonetic_language)
    ]).optional(),
    max_code_len: z.number().optional(),
    name_type: types_analysis_phonetic_name_type.optional(),
    replace: z.boolean().optional(),
    rule_type: types_analysis_phonetic_rule_type.optional()
}));

export const types_analysis_dictionary_decompounder_token_filter = types_analysis_compound_word_token_filter_base.and(z.object({
    type: z.enum(['dictionary_decompounder'])
}));

export const types_analysis_lowercase_normalizer = z.object({
    type: z.enum(['lowercase'])
});

export const types_analysis_custom_normalizer = z.object({
    type: z.enum(['custom']),
    char_filter: z.array(z.string()).optional(),
    filter: z.array(z.string()).optional()
});

export const types_analysis_normalizer = z.union([
    types_analysis_lowercase_normalizer,
    types_analysis_custom_normalizer
]);

export const types_analysis_tokenizer_base = z.object({
    version: types_version_string.optional()
});

export const types_analysis_char_group_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['char_group']),
    tokenize_on_chars: z.array(z.string()),
    max_token_length: z.number().optional()
}));

export const types_analysis_classic_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['classic']),
    max_token_length: z.number().optional()
}));

export const types_analysis_token_char = z.enum([
    'letter',
    'digit',
    'whitespace',
    'punctuation',
    'symbol',
    'custom'
]);

export const types_analysis_edge_n_gram_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['edge_ngram']),
    custom_token_chars: z.string().optional(),
    max_gram: z.number().optional(),
    min_gram: z.number().optional(),
    token_chars: z.array(types_analysis_token_char).optional().default([])
}));

export const types_analysis_keyword_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['keyword']),
    buffer_size: z.number().optional().default(256)
}));

export const types_analysis_letter_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['letter'])
}));

export const types_analysis_lowercase_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['lowercase'])
}));

export const types_analysis_n_gram_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['ngram']),
    custom_token_chars: z.string().optional(),
    max_gram: z.number().optional(),
    min_gram: z.number().optional(),
    token_chars: z.array(types_analysis_token_char).optional().default([])
}));

export const types_analysis_path_hierarchy_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['path_hierarchy']),
    buffer_size: spec_utils_stringifiedinteger.optional(),
    delimiter: z.string().optional(),
    replacement: z.string().optional(),
    reverse: spec_utils_stringifiedboolean.optional(),
    skip: spec_utils_stringifiedinteger.optional()
}));

export const types_analysis_pattern_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['pattern']),
    flags: z.string().optional(),
    group: z.number().optional(),
    pattern: z.string().optional()
}));

export const types_analysis_simple_pattern_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['simple_pattern']),
    pattern: z.string().optional()
}));

export const types_analysis_simple_pattern_split_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['simple_pattern_split']),
    pattern: z.string().optional()
}));

export const types_analysis_standard_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['standard']),
    max_token_length: z.number().optional()
}));

export const types_analysis_thai_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['thai'])
}));

export const types_analysis_uax_email_url_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['uax_url_email']),
    max_token_length: z.number().optional()
}));

export const types_analysis_whitespace_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['whitespace']),
    max_token_length: z.number().optional()
}));

export const types_analysis_icu_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['icu_tokenizer']),
    rule_files: z.string()
}));

export const types_analysis_kuromoji_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['kuromoji_tokenizer']),
    discard_punctuation: z.boolean().optional(),
    mode: types_analysis_kuromoji_tokenization_mode,
    nbest_cost: z.number().optional(),
    nbest_examples: z.string().optional(),
    user_dictionary: z.string().optional(),
    user_dictionary_rules: z.array(z.string()).optional(),
    discard_compound_token: z.boolean().optional()
}));

export const types_analysis_nori_tokenizer = types_analysis_tokenizer_base.and(z.object({
    type: z.enum(['nori_tokenizer']),
    decompound_mode: types_analysis_nori_decompound_mode.optional(),
    discard_punctuation: z.boolean().optional(),
    user_dictionary: z.string().optional(),
    user_dictionary_rules: z.array(z.string()).optional()
}));

export const types_analysis_tokenizer_definition = z.union([
    types_analysis_char_group_tokenizer,
    types_analysis_classic_tokenizer,
    types_analysis_edge_n_gram_tokenizer,
    types_analysis_keyword_tokenizer,
    types_analysis_letter_tokenizer,
    types_analysis_lowercase_tokenizer,
    types_analysis_n_gram_tokenizer,
    types_analysis_path_hierarchy_tokenizer,
    types_analysis_pattern_tokenizer,
    types_analysis_simple_pattern_tokenizer,
    types_analysis_simple_pattern_split_tokenizer,
    types_analysis_standard_tokenizer,
    types_analysis_thai_tokenizer,
    types_analysis_uax_email_url_tokenizer,
    types_analysis_whitespace_tokenizer,
    types_analysis_icu_tokenizer,
    types_analysis_kuromoji_tokenizer,
    types_analysis_nori_tokenizer
]);

export const types_analysis_tokenizer = z.union([
    z.string(),
    types_analysis_tokenizer_definition
]);

export const indices_types_index_settings_time_series = z.object({
    end_time: types_date_time.optional(),
    start_time: types_date_time.optional()
});

export const indices_types_cache_queries = z.object({
    enabled: z.boolean()
});

export const indices_types_queries = z.object({
    cache: indices_types_cache_queries.optional()
});

export const indices_types_settings_similarity_bm25 = z.object({
    type: z.enum(['BM25']),
    b: z.number().optional(),
    discount_overlaps: z.boolean().optional(),
    k1: z.number().optional()
});

export const indices_types_settings_similarity_boolean = z.object({
    type: z.enum(['boolean'])
});

export const types_dfi_independence_measure = z.enum([
    'standardized',
    'saturated',
    'chisquared'
]);

export const indices_types_settings_similarity_dfi = z.object({
    type: z.enum(['DFI']),
    independence_measure: types_dfi_independence_measure
});

export const types_dfr_after_effect = z.enum([
    'no',
    'b',
    'l'
]);

export const types_dfr_basic_model = z.enum([
    'be',
    'd',
    'g',
    'if',
    'in',
    'ine',
    'p'
]);

export const types_normalization = z.enum([
    'no',
    'h1',
    'h2',
    'h3',
    'z'
]);

export const indices_types_settings_similarity_dfr = z.object({
    type: z.enum(['DFR']),
    after_effect: types_dfr_after_effect,
    basic_model: types_dfr_basic_model,
    normalization: types_normalization
});

export const types_ib_distribution = z.enum(['ll', 'spl']);

export const types_ib_lambda = z.enum(['df', 'ttf']);

export const indices_types_settings_similarity_ib = z.object({
    type: z.enum(['IB']),
    distribution: types_ib_distribution,
    lambda: types_ib_lambda,
    normalization: types_normalization
});

export const indices_types_settings_similarity_lmd = z.object({
    type: z.enum(['LMDirichlet']),
    mu: z.number().optional()
});

export const indices_types_settings_similarity_lmj = z.object({
    type: z.enum(['LMJelinekMercer']),
    lambda: z.number().optional()
});

export const indices_types_mapping_limit_settings_total_fields = z.object({
    limit: z.union([
        z.number(),
        z.string()
    ]).optional(),
    ignore_dynamic_beyond_limit: z.union([
        z.boolean(),
        z.string()
    ]).optional()
});

export const indices_types_mapping_limit_settings_depth = z.object({
    limit: z.number().describe('The maximum depth for a field, which is measured as the number of inner objects. For instance, if all fields are defined\nat the root object level, then the depth is 1. If there is one object mapping, then the depth is 2, etc.').optional().default(20)
});

export const indices_types_mapping_limit_settings_nested_fields = z.object({
    limit: z.number().describe('The maximum number of distinct nested mappings in an index. The nested type should only be used in special cases, when\narrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this\nsetting limits the number of unique nested types per index.').optional().default(50)
});

export const indices_types_mapping_limit_settings_nested_objects = z.object({
    limit: z.number().describe('The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps\nto prevent out of memory errors when a document contains too many nested objects.').optional().default(10000)
});

export const indices_types_mapping_limit_settings_field_name_length = z.object({
    limit: z.number().describe('Setting for the maximum length of a field name. This setting isnt really something that addresses mappings explosion but\nmight still be useful if you want to limit the field length. It usually shouldnt be necessary to set this setting. The\ndefault is okay unless a user starts to add a huge number of fields with really long names. Default is `Long.MAX_VALUE` (no limit).').optional()
});

export const indices_types_mapping_limit_settings_dimension_fields = z.object({
    limit: z.number().describe('[preview] This functionality is in technical preview and may be changed or removed in a future release.\nElastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.').optional()
});

export const indices_types_source_mode = z.enum([
    'disabled',
    'stored',
    'synthetic'
]);

export const indices_types_mapping_limit_settings_source_fields = z.object({
    mode: indices_types_source_mode
});

/**
 * Mapping Limit Settings
 */
export const indices_types_mapping_limit_settings = z.object({
    coerce: z.boolean().optional(),
    total_fields: indices_types_mapping_limit_settings_total_fields.optional(),
    depth: indices_types_mapping_limit_settings_depth.optional(),
    nested_fields: indices_types_mapping_limit_settings_nested_fields.optional(),
    nested_objects: indices_types_mapping_limit_settings_nested_objects.optional(),
    field_name_length: indices_types_mapping_limit_settings_field_name_length.optional(),
    dimension_fields: indices_types_mapping_limit_settings_dimension_fields.optional(),
    source: indices_types_mapping_limit_settings_source_fields.optional(),
    ignore_malformed: z.union([
        z.boolean(),
        z.string()
    ]).optional()
}).describe('Mapping Limit Settings');

export const indices_types_indexing_slowlog_tresholds = z.object({
    index: indices_types_slowlog_treshold_levels.optional()
});

export const indices_types_indexing_slowlog_settings = z.object({
    level: z.string().optional(),
    source: z.number().optional(),
    reformat: z.boolean().optional(),
    threshold: indices_types_indexing_slowlog_tresholds.optional()
});

export const indices_types_indexing_pressure_memory = z.object({
    limit: z.number().describe('Number of outstanding bytes that may be consumed by indexing requests. When this limit is reached or exceeded,\nthe node will reject new coordinating and primary operations. When replica operations consume 1.5x this limit,\nthe node will reject new replica operations. Defaults to 10% of the heap.').optional()
});

export const indices_types_indexing_pressure = z.object({
    memory: indices_types_indexing_pressure_memory
});

export const indices_types_storage_type = z.union([
    z.enum([
        'fs',
        'niofs',
        'mmapfs',
        'hybridfs'
    ]),
    z.string()
]);

export const indices_types_storage = z.object({
    type: indices_types_storage_type,
    allow_mmap: z.boolean().describe('You can restrict the use of the mmapfs and the related hybridfs store type via the setting node.store.allow_mmap.\nThis is a boolean setting indicating whether or not memory-mapping is allowed. The default is to allow it. This\nsetting is useful, for example, if you are in an environment where you can not control the ability to create a lot\nof memory maps so you need disable the ability to use memory-mapping.').optional(),
    stats_refresh_interval: types_duration.optional()
});

export const ccr_follow_info_follower_index_parameters = z.object({
    max_outstanding_read_requests: z.number().describe('The maximum number of outstanding reads requests from the remote cluster.').optional(),
    max_outstanding_write_requests: z.number().describe('The maximum number of outstanding write requests on the follower.').optional(),
    max_read_request_operation_count: z.number().describe('The maximum number of operations to pull per read from the remote cluster.').optional(),
    max_read_request_size: types_byte_size.optional(),
    max_retry_delay: types_duration.optional(),
    max_write_buffer_count: z.number().describe('The maximum number of operations that can be queued for writing. When this limit is reached, reads from the remote cluster will be\ndeferred until the number of queued operations goes below the limit.').optional(),
    max_write_buffer_size: types_byte_size.optional(),
    max_write_request_operation_count: z.number().describe('The maximum number of operations per bulk write request executed on the follower.').optional(),
    max_write_request_size: types_byte_size.optional(),
    read_poll_timeout: types_duration.optional()
});

export const ccr_follow_info_follower_index_status = z.enum(['active', 'paused']);

export const ccr_follow_info_follower_index = z.object({
    follower_index: types_index_name,
    leader_index: types_index_name,
    parameters: ccr_follow_info_follower_index_parameters.optional(),
    remote_cluster: types_name,
    status: ccr_follow_info_follower_index_status
});

export const ccr_types_read_exception = z.object({
    exception: types_error_cause,
    from_seq_no: types_sequence_number,
    retries: z.number().describe('The number of times the batch has been retried.')
});

export const ccr_types_shard_stats = z.object({
    bytes_read: z.number().describe('The total of transferred bytes read from the leader.\nThis is only an estimate and does not account for compression if enabled.'),
    failed_read_requests: z.number().describe('The number of failed reads.'),
    failed_write_requests: z.number().describe('The number of failed bulk write requests on the follower.'),
    fatal_exception: types_error_cause.optional(),
    follower_aliases_version: types_version_number,
    follower_global_checkpoint: z.number().describe('The current global checkpoint on the follower.\nThe difference between the `leader_global_checkpoint` and the `follower_global_checkpoint` is an indication of how much the follower is lagging the leader.'),
    follower_index: z.string().describe('The name of the follower index.'),
    follower_mapping_version: types_version_number,
    follower_max_seq_no: types_sequence_number,
    follower_settings_version: types_version_number,
    last_requested_seq_no: types_sequence_number,
    leader_global_checkpoint: z.number().describe('The current global checkpoint on the leader known to the follower task.'),
    leader_index: z.string().describe('The name of the index in the leader cluster being followed.'),
    leader_max_seq_no: types_sequence_number,
    operations_read: z.number().describe('The total number of operations read from the leader.'),
    operations_written: z.number().describe('The number of operations written on the follower.'),
    outstanding_read_requests: z.number().describe('The number of active read requests from the follower.'),
    outstanding_write_requests: z.number().describe('The number of active bulk write requests on the follower.'),
    read_exceptions: z.array(ccr_types_read_exception).describe('An array of objects representing failed reads.'),
    remote_cluster: z.string().describe('The remote cluster containing the leader index.'),
    shard_id: z.number().describe('The numerical shard ID, with values from 0 to one less than the number of replicas.'),
    successful_read_requests: z.number().describe('The number of successful fetches.'),
    successful_write_requests: z.number().describe('The number of bulk write requests run on the follower.'),
    time_since_last_read: types_duration.optional(),
    time_since_last_read_millis: types_duration_value_unit_millis,
    total_read_remote_exec_time: types_duration.optional(),
    total_read_remote_exec_time_millis: types_duration_value_unit_millis,
    total_read_time: types_duration.optional(),
    total_read_time_millis: types_duration_value_unit_millis,
    total_write_time: types_duration.optional(),
    total_write_time_millis: types_duration_value_unit_millis,
    write_buffer_operation_count: z.number().describe('The number of write operations queued on the follower.'),
    write_buffer_size_in_bytes: types_byte_size
});

export const ccr_types_follow_index_stats = z.object({
    index: types_index_name,
    shards: z.array(ccr_types_shard_stats).describe('An array of shard-level following task statistics.')
});

export const types_index_pattern = z.string();

export const types_index_patterns = z.array(types_index_pattern);

export const ccr_get_auto_follow_pattern_auto_follow_pattern_summary = z.object({
    active: z.boolean(),
    remote_cluster: z.string().describe('The remote cluster containing the leader indices to match against.'),
    follow_index_pattern: types_index_pattern.optional(),
    leader_index_patterns: types_index_patterns,
    leader_index_exclusion_patterns: types_index_patterns,
    max_outstanding_read_requests: z.number().describe('The maximum number of outstanding reads requests from the remote cluster.')
});

export const ccr_get_auto_follow_pattern_auto_follow_pattern = z.object({
    name: types_name,
    pattern: ccr_get_auto_follow_pattern_auto_follow_pattern_summary
});

export const ccr_stats_auto_followed_cluster = z.object({
    cluster_name: types_name,
    last_seen_metadata_version: types_version_number,
    time_since_last_check_millis: types_duration_value_unit_millis
});

export const ccr_stats_auto_follow_stats = z.object({
    auto_followed_clusters: z.array(ccr_stats_auto_followed_cluster),
    number_of_failed_follow_indices: z.number().describe('The number of indices that the auto-follow coordinator failed to automatically follow.\nThe causes of recent failures are captured in the logs of the elected master node and in the `auto_follow_stats.recent_auto_follow_errors` field.'),
    number_of_failed_remote_cluster_state_requests: z.number().describe('The number of times that the auto-follow coordinator failed to retrieve the cluster state from a remote cluster registered in a collection of auto-follow patterns.'),
    number_of_successful_follow_indices: z.number().describe('The number of indices that the auto-follow coordinator successfully followed.'),
    recent_auto_follow_errors: z.array(types_error_cause).describe('An array of objects representing failures by the auto-follow coordinator.')
});

export const ccr_stats_follow_stats = z.object({
    indices: z.array(ccr_types_follow_index_stats)
});

export const types_scroll_ids = z.union([
    types_scroll_id,
    z.array(types_scroll_id)
]);

export const cluster_allocation_explain_decision = z.enum([
    'yes',
    'no',
    'worse_balance',
    'throttled',
    'awaiting_info',
    'allocation_delayed',
    'no_valid_shard_copy',
    'no_attempt'
]);

export const cluster_allocation_explain_allocation_explain_decision = z.enum([
    'NO',
    'YES',
    'THROTTLE',
    'ALWAYS'
]);

export const cluster_allocation_explain_allocation_decision = z.object({
    decider: z.string(),
    decision: cluster_allocation_explain_allocation_explain_decision,
    explanation: z.string()
});

export const cluster_allocation_explain_disk_usage = z.object({
    path: z.string(),
    total_bytes: z.number(),
    used_bytes: z.number(),
    free_bytes: z.number(),
    free_disk_percent: z.number(),
    used_disk_percent: z.number()
});

export const cluster_allocation_explain_node_disk_usage = z.object({
    node_name: types_name,
    least_available: cluster_allocation_explain_disk_usage,
    most_available: cluster_allocation_explain_disk_usage
});

export const cluster_allocation_explain_reserved_size = z.object({
    node_id: types_id,
    path: z.string(),
    total: z.number(),
    shards: z.array(z.string())
});

export const cluster_allocation_explain_cluster_info = z.object({
    nodes: z.record(cluster_allocation_explain_node_disk_usage),
    shard_sizes: z.record(z.number()),
    shard_data_set_sizes: z.record(z.string()).optional(),
    shard_paths: z.record(z.string()),
    reserved_sizes: z.array(cluster_allocation_explain_reserved_size)
});

export const types_node_role = z.enum([
    'master',
    'data',
    'data_cold',
    'data_content',
    'data_frozen',
    'data_hot',
    'data_warm',
    'client',
    'ingest',
    'ml',
    'voting_only',
    'transform',
    'remote_cluster_client',
    'coordinating_only'
]);

export const types_node_roles = z.array(types_node_role);

export const types_transport_address = z.string();

export const cluster_allocation_explain_current_node = z.object({
    id: types_id,
    name: types_name,
    roles: types_node_roles,
    attributes: z.record(z.string()),
    transport_address: types_transport_address,
    weight_ranking: z.number()
});

export const cluster_allocation_explain_allocation_store = z.object({
    allocation_id: z.string(),
    found: z.boolean(),
    in_sync: z.boolean(),
    matching_size_in_bytes: z.number(),
    matching_sync_id: z.boolean(),
    store_exception: z.string()
});

export const cluster_allocation_explain_node_allocation_explanation = z.object({
    deciders: z.array(cluster_allocation_explain_allocation_decision).optional(),
    node_attributes: z.record(z.string()),
    node_decision: cluster_allocation_explain_decision,
    node_id: types_id,
    node_name: types_name,
    roles: types_node_roles,
    store: cluster_allocation_explain_allocation_store.optional(),
    transport_address: types_transport_address,
    weight_ranking: z.number().optional()
});

export const cluster_allocation_explain_unassigned_information_reason = z.enum([
    'INDEX_CREATED',
    'CLUSTER_RECOVERED',
    'INDEX_REOPENED',
    'DANGLING_INDEX_IMPORTED',
    'NEW_INDEX_RESTORED',
    'EXISTING_INDEX_RESTORED',
    'REPLICA_ADDED',
    'ALLOCATION_FAILED',
    'NODE_LEFT',
    'REROUTE_CANCELLED',
    'REINITIALIZED',
    'REALLOCATED_REPLICA',
    'PRIMARY_FAILED',
    'FORCED_EMPTY_PRIMARY',
    'MANUAL_ALLOCATION'
]);

export const cluster_allocation_explain_unassigned_information = z.object({
    at: types_date_time,
    last_allocation_status: z.string().optional(),
    reason: cluster_allocation_explain_unassigned_information_reason,
    details: z.string().optional(),
    failed_allocation_attempts: z.number().optional(),
    delayed: z.boolean().optional(),
    allocation_status: z.string().optional()
});

export const types_mapping_all_field = z.object({
    analyzer: z.string(),
    enabled: z.boolean(),
    omit_norms: z.boolean(),
    search_analyzer: z.string(),
    similarity: z.string(),
    store: z.boolean(),
    store_term_vector_offsets: z.boolean(),
    store_term_vector_payloads: z.boolean(),
    store_term_vector_positions: z.boolean(),
    store_term_vectors: z.boolean()
});

export const types_mapping_dynamic_mapping = z.enum([
    'strict',
    'runtime',
    'true',
    'false'
]);

export const types_mapping_synthetic_source_keep_enum = z.enum([
    'none',
    'arrays',
    'all'
]);

export const indices_types_numeric_fielddata_format = z.enum(['array', 'disabled']);

export const indices_types_numeric_fielddata = z.object({
    format: indices_types_numeric_fielddata_format
});

export const types_mapping_on_script_error = z.enum(['fail', 'continue']);

export const types_mapping_time_series_metric_type = z.enum([
    'gauge',
    'counter',
    'summary',
    'histogram',
    'position'
]);

export const types_mapping_index_options = z.enum([
    'docs',
    'freqs',
    'positions',
    'offsets'
]);

export const types_mapping_text_index_prefixes = z.object({
    max_chars: z.number(),
    min_chars: z.number()
});

export const types_mapping_term_vector_option = z.enum([
    'no',
    'yes',
    'with_offsets',
    'with_positions',
    'with_positions_offsets',
    'with_positions_offsets_payloads',
    'with_positions_payloads'
]);

export const indices_types_fielddata_frequency_filter = z.object({
    max: z.number(),
    min: z.number(),
    min_segment_size: z.number()
});

export const types_mapping_dense_vector_element_type = z.enum([
    'bit',
    'byte',
    'float'
]);

export const types_mapping_dense_vector_index_options_type = z.enum([
    'bbq_flat',
    'bbq_hnsw',
    'bbq_disk',
    'flat',
    'hnsw',
    'int4_flat',
    'int4_hnsw',
    'int8_flat',
    'int8_hnsw'
]);

export const types_mapping_dense_vector_index_options_rescore_vector = z.object({
    oversample: z.number().describe('The oversampling factor to use when searching for the nearest neighbor. This is only applicable to the quantized formats: `bbq_*`, `int4_*`, and `int8_*`.\nWhen provided, `oversample * k` vectors will be gathered and then their scores will be re-computed with the original vectors.\n\nvalid values are between `1.0` and `10.0` (inclusive), or `0` exactly to disable oversampling.')
});

export const types_mapping_dense_vector_index_options = z.object({
    confidence_interval: z.number().describe('The confidence interval to use when quantizing the vectors. Can be any value between and including `0.90` and\n`1.0` or exactly `0`. When the value is `0`, this indicates that dynamic quantiles should be calculated for\noptimized quantization. When between `0.90` and `1.0`, this value restricts the values used when calculating\nthe quantization thresholds.\n\nFor example, a value of `0.95` will only use the middle `95%` of the values when calculating the quantization\nthresholds (e.g. the highest and lowest `2.5%` of values will be ignored).\n\nDefaults to `1/(dims + 1)` for `int8` quantized vectors and `0` for `int4` for dynamic quantile calculation.\n\nOnly applicable to `int8_hnsw`, `int4_hnsw`, `int8_flat`, and `int4_flat` index types.').optional(),
    ef_construction: z.number().describe('The number of candidates to track while assembling the list of nearest neighbors for each new node.\n\nOnly applicable to `hnsw`, `int8_hnsw`, `bbq_hnsw`, and `int4_hnsw` index types.').optional().default(100),
    m: z.number().describe('The number of neighbors each node will be connected to in the HNSW graph.\n\nOnly applicable to `hnsw`, `int8_hnsw`, `bbq_hnsw`, and `int4_hnsw` index types.').optional().default(16),
    type: types_mapping_dense_vector_index_options_type,
    rescore_vector: types_mapping_dense_vector_index_options_rescore_vector.optional(),
    on_disk_rescore: z.boolean().describe('`true` if vector rescoring should be done on-disk\n\nOnly applicable to `bbq_hnsw`').optional().default(false)
});

export const types_mapping_dense_vector_similarity = z.enum([
    'cosine',
    'dot_product',
    'l2_norm',
    'max_inner_product'
]);

export const types_mapping_subobjects = z.enum(['true', 'false']);

export const types_mapping_rank_vector_element_type = z.enum([
    'byte',
    'float',
    'bit'
]);

export const types_mapping_sparse_vector_index_options = z.object({
    prune: z.boolean().describe('Whether to perform pruning, omitting the non-significant tokens from the query to improve query performance.\nIf prune is true but the pruning_config is not specified, pruning will occur but default values will be used.\nDefault: false').optional(),
    pruning_config: types_token_pruning_config.optional()
});

export const types_mapping_semantic_text_index_options = z.object({
    dense_vector: types_mapping_dense_vector_index_options.optional(),
    sparse_vector: types_mapping_sparse_vector_index_options.optional()
});

export const types_mapping_chunking_settings = z.object({
    strategy: z.string().describe('The chunking strategy: `sentence`, `word`, `none` or `recursive`.\n\n * If `strategy` is set to `recursive`, you must also specify:\n\n- `max_chunk_size`\n- either `separators` or`separator_group`\n\nLearn more about different chunking strategies in the linked documentation.').default('sentence'),
    separator_group: z.string().describe('Only applicable to the `recursive` strategy and required when using it.\n\nSets a predefined list of separators in the saved chunking settings based on the selected text type.\nValues can be `markdown` or `plaintext`.\n\nUsing this parameter is an alternative to manually specifying a custom `separators` list.').optional(),
    separators: z.array(z.string()).describe('Only applicable to the `recursive` strategy and required when using it.\n\nA list of strings used as possible split points when chunking text.\n\nEach string can be a plain string or a regular expression (regex) pattern.\nThe system tries each separator in order to split the text, starting from the first item in the list.\n\nAfter splitting, it attempts to recombine smaller pieces into larger chunks that stay within\nthe `max_chunk_size` limit, to reduce the total number of chunks generated.').optional(),
    max_chunk_size: z.number().describe('The maximum size of a chunk in words.\nThis value cannot be lower than `20` (for `sentence` strategy) or `10` (for `word` strategy).\nThis value should not exceed the window size for the associated model.').default(250),
    overlap: z.number().describe('The number of overlapping words for chunks.\nIt is applicable only to a `word` chunking strategy.\nThis value cannot be higher than half the `max_chunk_size` value.').optional().default(100),
    sentence_overlap: z.number().describe('The number of overlapping sentences for chunks.\nIt is applicable only for a `sentence` chunking strategy.\nIt can be either `1` or `0`.').optional().default(1)
});

export const types_mapping_suggest_context = z.object({
    name: types_name,
    path: types_field.optional(),
    type: z.string(),
    precision: z.union([
        z.number(),
        z.string()
    ]).optional()
});

export const types_mapping_geo_point_metric_type = z.enum([
    'gauge',
    'counter',
    'position'
]);

export const types_mapping_geo_orientation = z.enum([
    'right',
    'RIGHT',
    'counterclockwise',
    'ccw',
    'left',
    'LEFT',
    'clockwise',
    'cw'
]);

export const types_mapping_geo_strategy = z.enum(['recursive', 'term']);

export const types_byte = z.number();

export const types_short = z.number();

export const types_ulong = z.number();

export const types_mapping_match_type = z.enum(['simple', 'regex']);

export const types_mapping_field_names_field = z.object({
    enabled: z.boolean()
});

export const types_mapping_index_field = z.object({
    enabled: z.boolean()
});

export const types_mapping_routing_field = z.object({
    required: z.boolean()
});

export const types_mapping_size_field = z.object({
    enabled: z.boolean()
});

export const types_mapping_source_field_mode = z.enum([
    'disabled',
    'stored',
    'synthetic'
]);

export const types_mapping_source_field = z.object({
    compress: z.boolean().optional(),
    compress_threshold: z.string().optional(),
    enabled: z.boolean().optional(),
    excludes: z.array(z.string()).optional(),
    includes: z.array(z.string()).optional(),
    mode: types_mapping_source_field_mode.optional()
});

export const types_mapping_data_stream_timestamp = z.object({
    enabled: z.boolean()
});

export const indices_types_data_stream_lifecycle_rollover_conditions = z.object({
    min_age: types_duration.optional(),
    max_age: z.string().optional(),
    min_docs: z.number().optional(),
    max_docs: z.number().optional(),
    min_size: types_byte_size.optional(),
    max_size: types_byte_size.optional(),
    min_primary_shard_size: types_byte_size.optional(),
    max_primary_shard_size: types_byte_size.optional(),
    min_primary_shard_docs: z.number().optional(),
    max_primary_shard_docs: z.number().optional()
});

export const indices_types_downsampling_round = z.object({
    after: types_duration,
    fixed_interval: types_duration_large
});

export const indices_types_data_stream_lifecycle_downsampling = z.object({
    rounds: z.array(indices_types_downsampling_round).describe('The list of downsampling rounds to execute as part of this downsampling configuration')
});

/**
 * Data stream lifecycle denotes that a data stream is managed by the data stream lifecycle and contains the configuration.
 */
export const indices_types_data_stream_lifecycle = z.object({
    data_retention: types_duration.optional(),
    downsampling: indices_types_data_stream_lifecycle_downsampling.optional(),
    enabled: z.boolean().describe('If defined, it turns data stream lifecycle on/off (`true`/`false`) for this data stream. A data stream lifecycle\nthat\'s disabled (enabled: `false`) will have no effect on the data stream.').optional().default(true)
}).describe('Data stream lifecycle denotes that a data stream is managed by the data stream lifecycle and contains the configuration.');

/**
 * Data stream lifecycle with rollover can be used to display the configuration including the default rollover conditions,
 * if asked.
 */
export const indices_types_data_stream_lifecycle_with_rollover = indices_types_data_stream_lifecycle.and(z.object({
    rollover: indices_types_data_stream_lifecycle_rollover_conditions.optional()
}));

/**
 * Template equivalent of FailureStoreLifecycle that allows nullable values.
 */
export const indices_types_failure_store_lifecycle_template = z.object({
    data_retention: z.union([
        types_duration,
        z.string(),
        z.null()
    ]).optional(),
    enabled: z.boolean().describe('If defined, it turns data stream lifecycle on/off (`true`/`false`) for this data stream. A data stream lifecycle\nthat\'s disabled (enabled: `false`) will have no effect on the data stream.').optional().default(true)
}).describe('Template equivalent of FailureStoreLifecycle that allows nullable values.');

/**
 * Template equivalent of DataStreamFailureStore that allows nullable values.
 */
export const indices_types_data_stream_failure_store_template = z.object({
    enabled: z.union([
        z.boolean(),
        z.string(),
        z.null()
    ]).optional(),
    lifecycle: z.union([
        indices_types_failure_store_lifecycle_template,
        z.string(),
        z.null()
    ]).optional()
}).describe('Template equivalent of DataStreamFailureStore that allows nullable values.');

/**
 * Data stream options template contains the same information as DataStreamOptions but allows them to be set explicitly to null.
 */
export const indices_types_data_stream_options_template = z.object({
    failure_store: z.union([
        indices_types_data_stream_failure_store_template,
        z.string(),
        z.null()
    ]).optional()
}).describe('Data stream options template contains the same information as DataStreamOptions but allows them to be set explicitly to null.');

export const types_level = z.enum([
    'cluster',
    'indices',
    'shards'
]);

export const types_wait_for_events = z.enum([
    'immediate',
    'urgent',
    'high',
    'normal',
    'low',
    'languid'
]);

export const cluster_health_wait_for_nodes = z.union([
    z.string(),
    z.number()
]);

export const cluster_health_shard_health_stats = z.object({
    active_shards: z.number(),
    initializing_shards: z.number(),
    primary_active: z.boolean(),
    relocating_shards: z.number(),
    status: types_health_status,
    unassigned_shards: z.number(),
    unassigned_primary_shards: z.number()
});

export const cluster_health_index_health_stats = z.object({
    active_primary_shards: z.number(),
    active_shards: z.number(),
    initializing_shards: z.number(),
    number_of_replicas: z.number(),
    number_of_shards: z.number(),
    relocating_shards: z.number(),
    shards: z.record(cluster_health_shard_health_stats).optional(),
    status: types_health_status,
    unassigned_shards: z.number(),
    unassigned_primary_shards: z.number()
});

export const cluster_health_health_response_body = z.object({
    active_primary_shards: z.number().describe('The number of active primary shards.'),
    active_shards: z.number().describe('The total number of active primary and replica shards.'),
    active_shards_percent: z.string().describe('The ratio of active shards in the cluster expressed as a string formatted percentage.').optional(),
    active_shards_percent_as_number: z.number().describe('The ratio of active shards in the cluster expressed as a percentage.'),
    cluster_name: types_name,
    delayed_unassigned_shards: z.number().describe('The number of shards whose allocation has been delayed by the timeout settings.'),
    indices: z.record(cluster_health_index_health_stats).optional(),
    initializing_shards: z.number().describe('The number of shards that are under initialization.'),
    number_of_data_nodes: z.number().describe('The number of nodes that are dedicated data nodes.'),
    number_of_in_flight_fetch: z.number().describe('The number of unfinished fetches.'),
    number_of_nodes: z.number().describe('The number of nodes within the cluster.'),
    number_of_pending_tasks: z.number().describe('The number of cluster-level changes that have not yet been executed.'),
    relocating_shards: z.number().describe('The number of shards that are under relocation.'),
    status: types_health_status,
    task_max_waiting_in_queue: types_duration.optional(),
    task_max_waiting_in_queue_millis: types_duration_value_unit_millis,
    timed_out: z.boolean().describe('If false the response returned within the period of time that is specified by the timeout parameter (30s by default)'),
    unassigned_primary_shards: z.number().describe('The number of primary shards that are not allocated.'),
    unassigned_shards: z.number().describe('The number of shards that are not allocated.')
});

export const types_cluster_info_target = z.enum([
    '_all',
    'http',
    'ingest',
    'thread_pool',
    'script'
]);

export const types_cluster_info_targets = z.union([
    types_cluster_info_target,
    z.array(types_cluster_info_target)
]);

export const nodes_types_client = z.object({
    id: z.number().describe('Unique ID for the HTTP client.').optional(),
    agent: z.string().describe('Reported agent for the HTTP client.\nIf unavailable, this property is not included in the response.').optional(),
    local_address: z.string().describe('Local address for the HTTP connection.').optional(),
    remote_address: z.string().describe('Remote address for the HTTP connection.').optional(),
    last_uri: z.string().describe('The URI of the clients most recent request.').optional(),
    opened_time_millis: z.number().describe('Time at which the client opened the connection.').optional(),
    closed_time_millis: z.number().describe('Time at which the client closed the connection if the connection is closed.').optional(),
    last_request_time_millis: z.number().describe('Time of the most recent request from this client.').optional(),
    request_count: z.number().describe('Number of requests from this client.').optional(),
    request_size_bytes: z.number().describe('Cumulative size in bytes of all requests from this client.').optional(),
    x_opaque_id: z.string().describe('Value from the clients `x-opaque-id` HTTP header.\nIf unavailable, this property is not included in the response.').optional()
});

export const nodes_types_size_http_histogram = z.object({
    count: z.number(),
    ge_bytes: z.number().optional(),
    lt_bytes: z.number().optional()
});

export const nodes_types_http_route_requests = z.object({
    count: z.number(),
    total_size_in_bytes: z.number(),
    size_histogram: z.array(nodes_types_size_http_histogram)
});

export const nodes_types_time_http_histogram = z.object({
    count: z.number(),
    ge_millis: z.number().optional(),
    lt_millis: z.number().optional()
});

export const nodes_types_http_route_responses = z.object({
    count: z.number(),
    total_size_in_bytes: z.number(),
    handling_time_histogram: z.array(nodes_types_time_http_histogram),
    size_histogram: z.array(nodes_types_size_http_histogram)
});

export const nodes_types_http_route = z.object({
    requests: nodes_types_http_route_requests,
    responses: nodes_types_http_route_responses
});

export const nodes_types_http = z.object({
    current_open: z.number().describe('Current number of open HTTP connections for the node.').optional(),
    total_opened: z.number().describe('Total number of HTTP connections opened for the node.').optional(),
    clients: z.array(nodes_types_client).describe('Information on current and recently-closed HTTP client connections.\nClients that have been closed longer than the `http.client_stats.closed_channels.max_age` setting will not be represented here.').optional(),
    routes: z.record(nodes_types_http_route).describe('Detailed HTTP stats broken down by route')
});

export const nodes_types_processor = z.object({
    count: z.number().describe('Number of documents transformed by the processor.').optional(),
    current: z.number().describe('Number of documents currently being transformed by the processor.').optional(),
    failed: z.number().describe('Number of failed operations for the processor.').optional(),
    time_in_millis: types_duration_value_unit_millis.optional()
});

export const nodes_types_keyed_processor = z.object({
    stats: nodes_types_processor.optional(),
    type: z.string().optional()
});

export const nodes_types_ingest_stats = z.object({
    count: z.number().describe('Total number of documents ingested during the lifetime of this node.'),
    current: z.number().describe('Total number of documents currently being ingested.'),
    failed: z.number().describe('Total number of failed ingest operations during the lifetime of this node.'),
    processors: z.array(z.record(nodes_types_keyed_processor)).describe('Total number of ingest processors.'),
    time_in_millis: types_duration_value_unit_millis,
    ingested_as_first_pipeline_in_bytes: z.number().describe('Total number of bytes of all documents ingested by the pipeline.\nThis field is only present on pipelines which are the first to process a document.\nThus, it is not present on pipelines which only serve as a final pipeline after a default pipeline, a pipeline run after a reroute processor, or pipelines in pipeline processors.'),
    produced_as_first_pipeline_in_bytes: z.number().describe('Total number of bytes of all documents produced by the pipeline.\nThis field is only present on pipelines which are the first to process a document.\nThus, it is not present on pipelines which only serve as a final pipeline after a default pipeline, a pipeline run after a reroute processor, or pipelines in pipeline processors.\nIn situations where there are subsequent pipelines, the value represents the size of the document after all pipelines have run.')
});

export const nodes_types_ingest_total = z.object({
    count: z.number().describe('Total number of documents ingested during the lifetime of this node.'),
    current: z.number().describe('Total number of documents currently being ingested.'),
    failed: z.number().describe('Total number of failed ingest operations during the lifetime of this node.'),
    time_in_millis: types_duration_value_unit_millis
});

export const nodes_types_ingest = z.object({
    pipelines: z.record(nodes_types_ingest_stats).describe('Contains statistics about ingest pipelines for the node.').optional(),
    total: nodes_types_ingest_total.optional()
});

export const nodes_types_thread_count = z.object({
    active: z.number().describe('Number of active threads in the thread pool.').optional(),
    completed: z.number().describe('Number of tasks completed by the thread pool executor.').optional(),
    largest: z.number().describe('Highest number of active threads in the thread pool.').optional(),
    queue: z.number().describe('Number of tasks in queue for the thread pool.').optional(),
    rejected: z.number().describe('Number of tasks rejected by the thread pool executor.').optional(),
    threads: z.number().describe('Number of threads in the thread pool.').optional()
});

export const nodes_types_context = z.object({
    context: z.string().optional(),
    compilations: z.number().optional(),
    cache_evictions: z.number().optional(),
    compilation_limit_triggered: z.number().optional()
});

export const nodes_types_scripting = z.object({
    cache_evictions: z.number().describe('Total number of times the script cache has evicted old data.').optional(),
    compilations: z.number().describe('Total number of inline script compilations performed by the node.').optional(),
    compilations_history: z.record(z.number()).describe('Contains this recent history of script compilations.').optional(),
    compilation_limit_triggered: z.number().describe('Total number of times the script compilation circuit breaker has limited inline script compilations.').optional(),
    contexts: z.array(nodes_types_context).optional()
});

export const cluster_pending_tasks_pending_task = z.object({
    executing: z.boolean().describe('Indicates whether the pending tasks are currently executing or not.'),
    insert_order: z.number().describe('The number that represents when the task has been inserted into the task queue.'),
    priority: z.string().describe('The priority of the pending task.\nThe valid priorities in descending priority order are: `IMMEDIATE` > `URGENT` > `HIGH` > `NORMAL` > `LOW` > `LANGUID`.'),
    source: z.string().describe('A general description of the cluster task that may include a reason and origin.'),
    time_in_queue: types_duration.optional(),
    time_in_queue_millis: types_duration_value_unit_millis
});

export const types_data_stream_name = z.string();

export const cluster_remote_info_cluster_remote_sniff_info = z.object({
    mode: z.enum(['sniff']).describe('The connection mode for the remote cluster.'),
    connected: z.boolean().describe('If it is `true`, there is at least one open connection to the remote cluster.\nIf it is `false`, it means that the cluster no longer has an open connection to the remote cluster.\nIt does not necessarily mean that the remote cluster is down or unavailable, just that at some point a connection was lost.'),
    max_connections_per_cluster: z.number().describe('The maximum number of connections maintained for the remote cluster when sniff mode is configured.'),
    num_nodes_connected: z.number().describe('The number of connected nodes in the remote cluster when sniff mode is configured.'),
    initial_connect_timeout: types_duration,
    skip_unavailable: z.boolean().describe('If `true`, cross-cluster search skips the remote cluster when its nodes are unavailable during the search and ignores errors returned by the remote cluster.'),
    seeds: z.array(z.string()).describe('The initial seed transport addresses of the remote cluster when sniff mode is configured.')
});

export const cluster_remote_info_cluster_remote_proxy_info = z.object({
    mode: z.enum(['proxy']).describe('The connection mode for the remote cluster.'),
    connected: z.boolean().describe('If it is `true`, there is at least one open connection to the remote cluster.\nIf it is `false`, it means that the cluster no longer has an open connection to the remote cluster.\nIt does not necessarily mean that the remote cluster is down or unavailable, just that at some point a connection was lost.'),
    initial_connect_timeout: types_duration,
    skip_unavailable: z.boolean().describe('If `true`, cross-cluster search skips the remote cluster when its nodes are unavailable during the search and ignores errors returned by the remote cluster.'),
    proxy_address: z.string().describe('The address for remote connections when proxy mode is configured.'),
    server_name: z.string(),
    num_proxy_sockets_connected: z.number().describe('The number of open socket connections to the remote cluster when proxy mode is configured.'),
    max_proxy_socket_connections: z.number().describe('The maximum number of socket connections to the remote cluster when proxy mode is configured.'),
    cluster_credentials: z.string().describe('This field is present and has a value of `::es_redacted::` only when the remote cluster is configured with the API key based model. Otherwise, the field is not present.').optional()
});

export const cluster_remote_info_cluster_remote_info = z.union([
    cluster_remote_info_cluster_remote_sniff_info,
    cluster_remote_info_cluster_remote_proxy_info
]);

export const cluster_reroute_command_cancel_action = z.object({
    index: types_index_name,
    shard: z.number(),
    node: z.string(),
    allow_primary: z.boolean().optional()
});

export const cluster_reroute_command_move_action = z.object({
    index: types_index_name,
    shard: z.number(),
    from_node: z.string().describe('The node to move the shard from'),
    to_node: z.string().describe('The node to move the shard to')
});

export const cluster_reroute_command_allocate_replica_action = z.object({
    index: types_index_name,
    shard: z.number(),
    node: z.string()
});

export const cluster_reroute_command_allocate_primary_action = z.object({
    index: types_index_name,
    shard: z.number(),
    node: z.string(),
    accept_data_loss: z.boolean().describe('If a node which has a copy of the data rejoins the cluster later on, that data will be deleted. To ensure that these implications are well-understood, this command requires the flag accept_data_loss to be explicitly set to true')
});

export const cluster_reroute_command = z.object({
    cancel: cluster_reroute_command_cancel_action.optional(),
    move: cluster_reroute_command_move_action.optional(),
    allocate_replica: cluster_reroute_command_allocate_replica_action.optional(),
    allocate_stale_primary: cluster_reroute_command_allocate_primary_action.optional(),
    allocate_empty_primary: cluster_reroute_command_allocate_primary_action.optional()
});

export const cluster_reroute_reroute_decision = z.object({
    decider: z.string(),
    decision: z.string(),
    explanation: z.string()
});

export const types_node_name = z.string();

export const cluster_reroute_reroute_parameters = z.object({
    allow_primary: z.boolean(),
    index: types_index_name,
    node: types_node_name,
    shard: z.number(),
    from_node: types_node_name.optional(),
    to_node: types_node_name.optional()
});

export const cluster_reroute_reroute_explanation = z.object({
    command: z.string(),
    decisions: z.array(cluster_reroute_reroute_decision),
    parameters: cluster_reroute_reroute_parameters
});

export const cluster_state_cluster_state_metric = z.enum([
    '_all',
    'version',
    'master_node',
    'blocks',
    'nodes',
    'metadata',
    'routing_table',
    'routing_nodes',
    'customs'
]);

export const cluster_state_cluster_state_metrics = z.union([
    cluster_state_cluster_state_metric,
    z.array(cluster_state_cluster_state_metric)
]);

export const cluster_stats_field_types = z.object({
    name: types_name,
    count: z.number().describe('The number of occurrences of the field type in selected nodes.'),
    index_count: z.number().describe('The number of indices containing the field type in selected nodes.'),
    indexed_vector_count: z.number().describe('For dense_vector field types, number of indexed vector types in selected nodes.').optional(),
    indexed_vector_dim_max: z.number().describe('For dense_vector field types, the maximum dimension of all indexed vector types in selected nodes.').optional(),
    indexed_vector_dim_min: z.number().describe('For dense_vector field types, the minimum dimension of all indexed vector types in selected nodes.').optional(),
    script_count: z.number().describe('The number of fields that declare a script.').optional(),
    vector_index_type_count: z.record(z.number()).describe('For dense_vector field types, count of mappings by index type').optional(),
    vector_similarity_type_count: z.record(z.number()).describe('For dense_vector field types, count of mappings by similarity').optional(),
    vector_element_type_count: z.record(z.number()).describe('For dense_vector field types, count of mappings by element type').optional()
});

export const cluster_stats_synonyms_stats = z.object({
    count: z.number(),
    index_count: z.number()
});

export const cluster_stats_char_filter_types = z.object({
    analyzer_types: z.array(cluster_stats_field_types).describe('Contains statistics about analyzer types used in selected nodes.'),
    built_in_analyzers: z.array(cluster_stats_field_types).describe('Contains statistics about built-in analyzers used in selected nodes.'),
    built_in_char_filters: z.array(cluster_stats_field_types).describe('Contains statistics about built-in character filters used in selected nodes.'),
    built_in_filters: z.array(cluster_stats_field_types).describe('Contains statistics about built-in token filters used in selected nodes.'),
    built_in_tokenizers: z.array(cluster_stats_field_types).describe('Contains statistics about built-in tokenizers used in selected nodes.'),
    char_filter_types: z.array(cluster_stats_field_types).describe('Contains statistics about character filter types used in selected nodes.'),
    filter_types: z.array(cluster_stats_field_types).describe('Contains statistics about token filter types used in selected nodes.'),
    tokenizer_types: z.array(cluster_stats_field_types).describe('Contains statistics about tokenizer types used in selected nodes.'),
    synonyms: z.record(cluster_stats_synonyms_stats).describe('Contains statistics about synonyms types used in selected nodes.')
});

export const types_field_size_usage = z.object({
    size: types_byte_size.optional(),
    size_in_bytes: z.number()
});

export const types_completion_stats = z.object({
    size_in_bytes: z.number().describe('Total amount, in bytes, of memory used for completion across all shards assigned to selected nodes.'),
    size: types_byte_size.optional(),
    fields: z.record(types_field_size_usage).optional()
});

export const types_doc_stats = z.object({
    count: z.number().describe('Total number of non-deleted documents across all primary shards assigned to selected nodes.\nThis number is based on documents in Lucene segments and may include documents from nested fields.'),
    deleted: z.number().describe('Total number of deleted documents across all primary shards assigned to selected nodes.\nThis number is based on documents in Lucene segments.\nElasticsearch reclaims the disk space of deleted Lucene documents when a segment is merged.').optional(),
    total_size_in_bytes: z.number().describe('Returns the total size in bytes of all documents in this stats.\nThis value may be more reliable than store_stats.size_in_bytes in estimating the index size.'),
    total_size: types_byte_size.optional()
});

export const types_field_memory_usage = z.object({
    memory_size: types_byte_size.optional(),
    memory_size_in_bytes: z.number()
});

export const types_global_ordinal_field_stats = z.object({
    build_time_in_millis: types_unit_millis,
    build_time: z.string().optional(),
    shard_max_value_count: z.number()
});

export const types_global_ordinals_stats = z.object({
    build_time_in_millis: types_unit_millis,
    build_time: z.string().optional(),
    fields: z.record(types_global_ordinal_field_stats).optional()
});

export const types_fielddata_stats = z.object({
    evictions: z.number().optional(),
    memory_size: types_byte_size.optional(),
    memory_size_in_bytes: z.number(),
    fields: z.record(types_field_memory_usage).optional(),
    global_ordinals: types_global_ordinals_stats
});

export const types_query_cache_stats = z.object({
    cache_count: z.number().describe('Total number of entries added to the query cache across all shards assigned to selected nodes.\nThis number includes current and evicted entries.'),
    cache_size: z.number().describe('Total number of entries currently in the query cache across all shards assigned to selected nodes.'),
    evictions: z.number().describe('Total number of query cache evictions across all shards assigned to selected nodes.'),
    hit_count: z.number().describe('Total count of query cache hits across all shards assigned to selected nodes.'),
    memory_size: types_byte_size.optional(),
    memory_size_in_bytes: z.number().describe('Total amount, in bytes, of memory used for the query cache across all shards assigned to selected nodes.'),
    miss_count: z.number().describe('Total count of query cache misses across all shards assigned to selected nodes.'),
    total_count: z.number().describe('Total count of hits and misses in the query cache across all shards assigned to selected nodes.')
});

export const cluster_stats_extended_text_similarity_retriever_usage = z.object({
    chunk_rescorer: z.number().optional()
});

export const cluster_stats_extended_retrievers_search_usage = z.object({
    text_similarity_reranker: cluster_stats_extended_text_similarity_retriever_usage.optional()
});

export const cluster_stats_extended_search_usage = z.object({
    retrievers: cluster_stats_extended_retrievers_search_usage.optional()
});

export const cluster_stats_search_usage_stats = z.object({
    total: z.number(),
    queries: z.record(z.number()),
    rescorers: z.record(z.number()),
    sections: z.record(z.number()),
    retrievers: z.record(z.number()),
    extended: cluster_stats_extended_search_usage
});

export const indices_stats_shard_file_size_info = z.object({
    description: z.string(),
    size_in_bytes: z.number(),
    min_size_in_bytes: z.number().optional(),
    max_size_in_bytes: z.number().optional(),
    average_size_in_bytes: z.number().optional(),
    count: z.number().optional()
});

export const types_segments_stats = z.object({
    count: z.number().describe('Total number of segments across all shards assigned to selected nodes.'),
    doc_values_memory: types_byte_size.optional(),
    doc_values_memory_in_bytes: z.number().describe('Total amount, in bytes, of memory used for doc values across all shards assigned to selected nodes.'),
    file_sizes: z.record(indices_stats_shard_file_size_info).describe('This object is not populated by the cluster stats API.\nTo get information on segment files, use the node stats API.'),
    fixed_bit_set: types_byte_size.optional(),
    fixed_bit_set_memory_in_bytes: z.number().describe('Total amount of memory, in bytes, used by fixed bit sets across all shards assigned to selected nodes.'),
    index_writer_memory: types_byte_size.optional(),
    index_writer_memory_in_bytes: z.number().describe('Total amount, in bytes, of memory used by all index writers across all shards assigned to selected nodes.'),
    max_unsafe_auto_id_timestamp: z.number().describe('Unix timestamp, in milliseconds, of the most recently retried indexing request.'),
    memory: types_byte_size.optional(),
    memory_in_bytes: z.number().describe('Total amount, in bytes, of memory used for segments across all shards assigned to selected nodes.'),
    norms_memory: types_byte_size.optional(),
    norms_memory_in_bytes: z.number().describe('Total amount, in bytes, of memory used for normalization factors across all shards assigned to selected nodes.'),
    points_memory: types_byte_size.optional(),
    points_memory_in_bytes: z.number().describe('Total amount, in bytes, of memory used for points across all shards assigned to selected nodes.'),
    stored_fields_memory_in_bytes: z.number().describe('Total amount, in bytes, of memory used for stored fields across all shards assigned to selected nodes.'),
    stored_fields_memory: types_byte_size.optional(),
    terms_memory_in_bytes: z.number().describe('Total amount, in bytes, of memory used for terms across all shards assigned to selected nodes.'),
    terms_memory: types_byte_size.optional(),
    term_vectors_memory: types_byte_size.optional(),
    term_vectors_memory_in_bytes: z.number().describe('Total amount, in bytes, of memory used for term vectors across all shards assigned to selected nodes.'),
    version_map_memory: types_byte_size.optional(),
    version_map_memory_in_bytes: z.number().describe('Total amount, in bytes, of memory used by all version maps across all shards assigned to selected nodes.')
});

export const cluster_stats_cluster_shard_metrics = z.object({
    avg: z.number().describe('Mean number of shards in an index, counting only shards assigned to selected nodes.'),
    max: z.number().describe('Maximum number of shards in an index, counting only shards assigned to selected nodes.'),
    min: z.number().describe('Minimum number of shards in an index, counting only shards assigned to selected nodes.')
});

export const cluster_stats_cluster_indices_shards_index = z.object({
    primaries: cluster_stats_cluster_shard_metrics,
    replication: cluster_stats_cluster_shard_metrics,
    shards: cluster_stats_cluster_shard_metrics
});

/**
 * Contains statistics about shards assigned to selected nodes.
 */
export const cluster_stats_cluster_indices_shards = z.object({
    index: cluster_stats_cluster_indices_shards_index.optional(),
    primaries: z.number().describe('Number of primary shards assigned to selected nodes.').optional(),
    replication: z.number().describe('Ratio of replica shards to primary shards across all selected nodes.').optional(),
    total: z.number().describe('Total number of shards assigned to selected nodes.').optional()
}).describe('Contains statistics about shards assigned to selected nodes.');

export const types_store_stats = z.object({
    size: types_byte_size.optional(),
    size_in_bytes: z.number().describe('Total size, in bytes, of all shards assigned to selected nodes.'),
    reserved: types_byte_size.optional(),
    reserved_in_bytes: z.number().describe('A prediction, in bytes, of how much larger the shard stores will eventually grow due to ongoing peer recoveries, restoring snapshots, and similar activities.'),
    total_data_set_size: types_byte_size.optional(),
    total_data_set_size_in_bytes: z.number().describe('Total data set size, in bytes, of all shards assigned to selected nodes.\nThis includes the size of shards not stored fully on the nodes, such as the cache for partially mounted indices.').optional()
});

export const cluster_stats_runtime_field_types = z.object({
    chars_max: z.number().describe('Maximum number of characters for a single runtime field script.'),
    chars_total: z.number().describe('Total number of characters for the scripts that define the current runtime field data type.'),
    count: z.number().describe('Number of runtime fields mapped to the field data type in selected nodes.'),
    doc_max: z.number().describe('Maximum number of accesses to doc_values for a single runtime field script'),
    doc_total: z.number().describe('Total number of accesses to doc_values for the scripts that define the current runtime field data type.'),
    index_count: z.number().describe('Number of indices containing a mapping of the runtime field data type in selected nodes.'),
    lang: z.array(z.string()).describe('Script languages used for the runtime fields scripts.'),
    lines_max: z.number().describe('Maximum number of lines for a single runtime field script.'),
    lines_total: z.number().describe('Total number of lines for the scripts that define the current runtime field data type.'),
    name: types_name,
    scriptless_count: z.number().describe('Number of runtime fields that dont declare a script.'),
    shadowed_count: z.number().describe('Number of runtime fields that shadow an indexed field.'),
    source_max: z.number().describe('Maximum number of accesses to _source for a single runtime field script.'),
    source_total: z.number().describe('Total number of accesses to _source for the scripts that define the current runtime field data type.')
});

export const cluster_stats_field_types_mappings = z.object({
    field_types: z.array(cluster_stats_field_types).describe('Contains statistics about field data types used in selected nodes.'),
    runtime_field_types: z.array(cluster_stats_runtime_field_types).describe('Contains statistics about runtime field data types used in selected nodes.'),
    total_field_count: z.number().describe('Total number of fields in all non-system indices.').optional(),
    total_deduplicated_field_count: z.number().describe('Total number of fields in all non-system indices, accounting for mapping deduplication.').optional(),
    total_deduplicated_mapping_size: types_byte_size.optional(),
    total_deduplicated_mapping_size_in_bytes: z.number().describe('Total size of all mappings, in bytes, after deduplication and compression.').optional(),
    source_modes: z.record(z.number()).describe('Source mode usage count.')
});

export const cluster_stats_indices_versions = z.object({
    index_count: z.number(),
    primary_shard_count: z.number(),
    total_primary_bytes: z.number(),
    total_primary_size: types_byte_size.optional(),
    version: types_version_string
});

export const cluster_stats_dense_vector_off_heap_stats = z.object({
    total_size_bytes: z.number(),
    total_size: types_byte_size.optional(),
    total_veb_size_bytes: z.number(),
    total_veb_size: types_byte_size.optional(),
    total_vec_size_bytes: z.number(),
    total_vec_size: types_byte_size.optional(),
    total_veq_size_bytes: z.number(),
    total_veq_size: types_byte_size.optional(),
    total_vex_size_bytes: z.number(),
    total_vex_size: types_byte_size.optional(),
    fielddata: z.record(z.record(z.number())).optional()
});

export const cluster_stats_dense_vector_stats = z.object({
    value_count: z.number(),
    off_heap: cluster_stats_dense_vector_off_heap_stats.optional()
});

export const cluster_stats_sparse_vector_stats = z.object({
    value_count: z.number()
});

export const cluster_stats_cluster_indices = z.object({
    analysis: cluster_stats_char_filter_types.optional(),
    completion: types_completion_stats,
    count: z.number().describe('Total number of indices with shards assigned to selected nodes.'),
    docs: types_doc_stats,
    fielddata: types_fielddata_stats,
    query_cache: types_query_cache_stats,
    search: cluster_stats_search_usage_stats,
    segments: types_segments_stats,
    shards: cluster_stats_cluster_indices_shards,
    store: types_store_stats,
    mappings: cluster_stats_field_types_mappings.optional(),
    versions: z.array(cluster_stats_indices_versions).describe('Contains statistics about analyzers and analyzer components used in selected nodes.').optional(),
    dense_vector: cluster_stats_dense_vector_stats,
    sparse_vector: cluster_stats_sparse_vector_stats
});

export const cluster_stats_cluster_node_count = z.object({
    total: z.number(),
    coordinating_only: z.number().optional(),
    data: z.number().optional(),
    data_cold: z.number().optional(),
    data_content: z.number().optional(),
    data_frozen: z.number().optional(),
    data_hot: z.number().optional(),
    data_warm: z.number().optional(),
    index: z.number().optional(),
    ingest: z.number().optional(),
    master: z.number().optional(),
    ml: z.number().optional(),
    remote_cluster_client: z.number().optional(),
    search: z.number().optional(),
    transform: z.number().optional(),
    voting_only: z.number().optional()
});

export const cluster_stats_cluster_file_system = z.object({
    path: z.string().optional(),
    mount: z.string().optional(),
    type: z.string().optional(),
    available_in_bytes: z.number().describe('Total number of bytes available to JVM in file stores across all selected nodes.\nDepending on operating system or process-level restrictions, this number may be less than `nodes.fs.free_in_byes`.\nThis is the actual amount of free disk space the selected Elasticsearch nodes can use.').optional(),
    available: types_byte_size.optional(),
    free_in_bytes: z.number().describe('Total number, in bytes, of unallocated bytes in file stores across all selected nodes.').optional(),
    free: types_byte_size.optional(),
    total_in_bytes: z.number().describe('Total size, in bytes, of all file stores across all selected nodes.').optional(),
    total: types_byte_size.optional(),
    low_watermark_free_space: types_byte_size.optional(),
    low_watermark_free_space_in_bytes: z.number().optional(),
    high_watermark_free_space: types_byte_size.optional(),
    high_watermark_free_space_in_bytes: z.number().optional(),
    flood_stage_free_space: types_byte_size.optional(),
    flood_stage_free_space_in_bytes: z.number().optional(),
    frozen_flood_stage_free_space: types_byte_size.optional(),
    frozen_flood_stage_free_space_in_bytes: z.number().optional()
});

export const nodes_types_pressure_memory = z.object({
    all: types_byte_size.optional(),
    all_in_bytes: z.number().describe('Memory consumed, in bytes, by indexing requests in the coordinating, primary, or replica stage.').optional(),
    combined_coordinating_and_primary: types_byte_size.optional(),
    combined_coordinating_and_primary_in_bytes: z.number().describe('Memory consumed, in bytes, by indexing requests in the coordinating or primary stage.\nThis value is not the sum of coordinating and primary as a node can reuse the coordinating memory if the primary stage is executed locally.').optional(),
    coordinating: types_byte_size.optional(),
    coordinating_in_bytes: z.number().describe('Memory consumed, in bytes, by indexing requests in the coordinating stage.').optional(),
    primary: types_byte_size.optional(),
    primary_in_bytes: z.number().describe('Memory consumed, in bytes, by indexing requests in the primary stage.').optional(),
    replica: types_byte_size.optional(),
    replica_in_bytes: z.number().describe('Memory consumed, in bytes, by indexing requests in the replica stage.').optional(),
    coordinating_rejections: z.number().describe('Number of indexing requests rejected in the coordinating stage.').optional(),
    primary_rejections: z.number().describe('Number of indexing requests rejected in the primary stage.').optional(),
    replica_rejections: z.number().describe('Number of indexing requests rejected in the replica stage.').optional(),
    primary_document_rejections: z.number().optional(),
    large_operation_rejections: z.number().optional()
});

export const nodes_types_indexing_pressure_memory = z.object({
    limit: types_byte_size.optional(),
    limit_in_bytes: z.number().describe('Configured memory limit, in bytes, for the indexing requests.\nReplica requests have an automatic limit that is 1.5x this value.').optional(),
    current: nodes_types_pressure_memory.optional(),
    total: nodes_types_pressure_memory.optional()
});

export const cluster_stats_indexing_pressure = z.object({
    memory: nodes_types_indexing_pressure_memory
});

export const cluster_stats_cluster_processor = z.object({
    count: z.number(),
    current: z.number(),
    failed: z.number(),
    time: types_duration.optional(),
    time_in_millis: types_duration_value_unit_millis
});

export const cluster_stats_cluster_ingest = z.object({
    number_of_pipelines: z.number(),
    processor_stats: z.record(cluster_stats_cluster_processor)
});

export const cluster_stats_cluster_jvm_memory = z.object({
    heap_max_in_bytes: z.number().describe('Maximum amount of memory, in bytes, available for use by the heap across all selected nodes.'),
    heap_max: types_byte_size.optional(),
    heap_used_in_bytes: z.number().describe('Memory, in bytes, currently in use by the heap across all selected nodes.'),
    heap_used: types_byte_size.optional()
});

export const cluster_stats_cluster_jvm_version = z.object({
    bundled_jdk: z.boolean().describe('Always `true`. All distributions come with a bundled Java Development Kit (JDK).'),
    count: z.number().describe('Total number of selected nodes using JVM.'),
    using_bundled_jdk: z.boolean().describe('If `true`, a bundled JDK is in use by JVM.'),
    version: types_version_string,
    vm_name: z.string().describe('Name of the JVM.'),
    vm_vendor: z.string().describe('Vendor of the JVM.'),
    vm_version: types_version_string
});

export const cluster_stats_cluster_jvm = z.object({
    max_uptime_in_millis: types_duration_value_unit_millis,
    max_uptime: types_duration.optional(),
    mem: cluster_stats_cluster_jvm_memory,
    threads: z.number().describe('Number of active threads in use by JVM across all selected nodes.'),
    versions: z.array(cluster_stats_cluster_jvm_version).describe('Contains statistics about the JVM versions used by selected nodes.')
});

export const cluster_stats_cluster_network_types = z.object({
    http_types: z.record(z.number()).describe('Contains statistics about the HTTP network types used by selected nodes.'),
    transport_types: z.record(z.number()).describe('Contains statistics about the transport network types used by selected nodes.')
});

export const cluster_stats_cluster_operating_system_architecture = z.object({
    arch: z.string().describe('Name of an architecture used by one or more selected nodes.'),
    count: z.number().describe('Number of selected nodes using the architecture.')
});

export const cluster_stats_operating_system_memory_info = z.object({
    adjusted_total_in_bytes: z.number().describe('Total amount, in bytes, of memory across all selected nodes, but using the value specified using the `es.total_memory_bytes` system property instead of measured total memory for those nodes where that system property was set.').optional(),
    adjusted_total: types_byte_size.optional(),
    free_in_bytes: z.number().describe('Amount, in bytes, of free physical memory across all selected nodes.'),
    free: types_byte_size.optional(),
    free_percent: z.number().describe('Percentage of free physical memory across all selected nodes.'),
    total_in_bytes: z.number().describe('Total amount, in bytes, of physical memory across all selected nodes.'),
    total: types_byte_size.optional(),
    used_in_bytes: z.number().describe('Amount, in bytes, of physical memory in use across all selected nodes.'),
    used: types_byte_size.optional(),
    used_percent: z.number().describe('Percentage of physical memory in use across all selected nodes.')
});

export const cluster_stats_cluster_operating_system_name = z.object({
    count: z.number().describe('Number of selected nodes using the operating system.'),
    name: types_name
});

export const cluster_stats_cluster_operating_system_pretty_name = z.object({
    count: z.number().describe('Number of selected nodes using the operating system.'),
    pretty_name: types_name
});

export const cluster_stats_cluster_operating_system = z.object({
    allocated_processors: z.number().describe('Number of processors used to calculate thread pool size across all selected nodes.\nThis number can be set with the processors setting of a node and defaults to the number of processors reported by the operating system.\nIn both cases, this number will never be larger than 32.'),
    architectures: z.array(cluster_stats_cluster_operating_system_architecture).describe('Contains statistics about processor architectures (for example, x86_64 or aarch64) used by selected nodes.').optional(),
    available_processors: z.number().describe('Number of processors available to JVM across all selected nodes.'),
    mem: cluster_stats_operating_system_memory_info,
    names: z.array(cluster_stats_cluster_operating_system_name).describe('Contains statistics about operating systems used by selected nodes.'),
    pretty_names: z.array(cluster_stats_cluster_operating_system_pretty_name).describe('Contains statistics about operating systems used by selected nodes.')
});

export const cluster_stats_node_packaging_type = z.object({
    count: z.number().describe('Number of selected nodes using the distribution flavor and file type.'),
    flavor: z.string().describe('Type of Elasticsearch distribution. This is always `default`.'),
    type: z.string().describe('File type (such as `tar` or `zip`) used for the distribution package.')
});

export const types_plugin_stats = z.object({
    classname: z.string(),
    description: z.string(),
    elasticsearch_version: types_version_string,
    extended_plugins: z.array(z.string()),
    has_native_controller: z.boolean(),
    java_version: types_version_string,
    name: types_name,
    version: types_version_string,
    licensed: z.boolean()
});

export const cluster_stats_cluster_process_cpu = z.object({
    percent: z.number().describe('Percentage of CPU used across all selected nodes.\nReturns `-1` if not supported.')
});

export const cluster_stats_cluster_process_open_file_descriptors = z.object({
    avg: z.number().describe('Average number of concurrently open file descriptors.\nReturns `-1` if not supported.'),
    max: z.number().describe('Maximum number of concurrently open file descriptors allowed across all selected nodes.\nReturns `-1` if not supported.'),
    min: z.number().describe('Minimum number of concurrently open file descriptors across all selected nodes.\nReturns -1 if not supported.')
});

export const cluster_stats_cluster_process = z.object({
    cpu: cluster_stats_cluster_process_cpu,
    open_file_descriptors: cluster_stats_cluster_process_open_file_descriptors
});

export const cluster_stats_cluster_nodes = z.object({
    count: cluster_stats_cluster_node_count,
    discovery_types: z.record(z.number()).describe('Contains statistics about the discovery types used by selected nodes.'),
    fs: cluster_stats_cluster_file_system,
    indexing_pressure: cluster_stats_indexing_pressure,
    ingest: cluster_stats_cluster_ingest,
    jvm: cluster_stats_cluster_jvm,
    network_types: cluster_stats_cluster_network_types,
    os: cluster_stats_cluster_operating_system,
    packaging_types: z.array(cluster_stats_node_packaging_type).describe('Contains statistics about Elasticsearch distributions installed on selected nodes.'),
    plugins: z.array(types_plugin_stats).describe('Contains statistics about installed plugins and modules by selected nodes.\nIf no plugins or modules are installed, this array is empty.'),
    process: cluster_stats_cluster_process,
    versions: z.array(types_version_string).describe('Array of Elasticsearch versions used on selected nodes.')
});

export const cluster_stats_snapshot_current_counts = z.object({
    snapshots: z.number().describe('Snapshots currently in progress'),
    shard_snapshots: z.number().describe('Incomplete shard snapshots'),
    snapshot_deletions: z.number().describe('Snapshots deletions in progress'),
    concurrent_operations: z.number().describe('Sum of snapshots and snapshot_deletions'),
    cleanups: z.number().describe('Cleanups in progress, not counted in concurrent_operations as they are not concurrent')
});

export const cluster_stats_repository_stats_shards = z.object({
    total: z.number(),
    complete: z.number(),
    incomplete: z.number(),
    states: z.record(z.number())
});

export const cluster_stats_repository_stats_current_counts = z.object({
    snapshots: z.number(),
    clones: z.number(),
    finalizations: z.number(),
    deletions: z.number(),
    snapshot_deletions: z.number(),
    active_deletions: z.number(),
    shards: cluster_stats_repository_stats_shards
});

export const cluster_stats_per_repository_stats = z.object({
    type: z.string(),
    oldest_start_time_millis: types_unit_millis,
    oldest_start_time: types_date_format.optional(),
    current_counts: cluster_stats_repository_stats_current_counts
});

export const cluster_stats_cluster_snapshot_stats = z.object({
    current_counts: cluster_stats_snapshot_current_counts,
    repositories: z.record(cluster_stats_per_repository_stats)
});

export const cluster_stats_remote_cluster_info = z.object({
    cluster_uuid: z.string().describe('The UUID of the remote cluster.'),
    mode: z.string().describe('The connection mode used to communicate with the remote cluster.'),
    skip_unavailable: z.boolean().describe('The `skip_unavailable` setting used for this remote cluster.'),
    'transport.compress': z.string().describe('Transport compression setting used for this remote cluster.'),
    status: types_health_status,
    version: z.array(types_version_string).describe('The list of Elasticsearch versions used by the nodes on the remote cluster.'),
    nodes_count: z.number().describe('The total count of nodes in the remote cluster.'),
    shards_count: z.number().describe('The total number of shards in the remote cluster.'),
    indices_count: z.number().describe('The total number of indices in the remote cluster.'),
    indices_total_size_in_bytes: z.number().describe('Total data set size, in bytes, of all shards assigned to selected nodes.'),
    indices_total_size: z.string().describe('Total data set size of all shards assigned to selected nodes, as a human-readable string.').optional(),
    max_heap_in_bytes: z.number().describe('Maximum amount of memory, in bytes, available for use by the heap across the nodes of the remote cluster.'),
    max_heap: z.string().describe('Maximum amount of memory available for use by the heap across the nodes of the remote cluster, as a human-readable string.').optional(),
    mem_total_in_bytes: z.number().describe('Total amount, in bytes, of physical memory across the nodes of the remote cluster.'),
    mem_total: z.string().describe('Total amount of physical memory across the nodes of the remote cluster, as a human-readable string.').optional()
});

export const cluster_stats_ccs_usage_time_value = z.object({
    max: types_duration_value_unit_millis,
    avg: types_duration_value_unit_millis,
    p90: types_duration_value_unit_millis
});

export const cluster_stats_ccs_usage_cluster_stats = z.object({
    total: z.number().describe('The total number of successful (not skipped) cross-cluster search requests that were executed against this cluster. This may include requests where partial results were returned, but not requests in which the cluster has been skipped entirely.'),
    skipped: z.number().describe('The total number of cross-cluster search requests for which this cluster was skipped.'),
    took: cluster_stats_ccs_usage_time_value
});

export const cluster_stats_ccs_usage_stats = z.object({
    total: z.number().describe('The total number of cross-cluster search requests that have been executed by the cluster.'),
    success: z.number().describe('The total number of cross-cluster search requests that have been successfully executed by the cluster.'),
    skipped: z.number().describe('The total number of cross-cluster search requests (successful or failed) that had at least one remote cluster skipped.'),
    took: cluster_stats_ccs_usage_time_value,
    took_mrt_true: cluster_stats_ccs_usage_time_value.optional(),
    took_mrt_false: cluster_stats_ccs_usage_time_value.optional(),
    remotes_per_search_max: z.number().describe('The maximum number of remote clusters that were queried in a single cross-cluster search request.'),
    remotes_per_search_avg: z.number().describe('The average number of remote clusters that were queried in a single cross-cluster search request.'),
    failure_reasons: z.record(z.number()).describe('Statistics about the reasons for cross-cluster search request failures. The keys are the failure reason names and the values are the number of requests that failed for that reason.'),
    features: z.record(z.number()).describe('The keys are the names of the search feature, and the values are the number of requests that used that feature. Single request can use more than one feature (e.g. both `async` and `wildcard`).'),
    clients: z.record(z.number()).describe('Statistics about the clients that executed cross-cluster search requests. The keys are the names of the clients, and the values are the number of requests that were executed by that client. Only known clients (such as `kibana` or `elasticsearch`) are counted.'),
    clusters: z.record(cluster_stats_ccs_usage_cluster_stats).describe('Statistics about the clusters that were queried in cross-cluster search requests. The keys are cluster names, and the values are per-cluster telemetry data. This also includes the local cluster itself, which uses the name `(local)`.')
});

export const cluster_stats_ccs_stats = z.object({
    clusters: z.record(cluster_stats_remote_cluster_info).describe('Contains remote cluster settings and metrics collected from them.\nThe keys are cluster names, and the values are per-cluster data.\nOnly present if `include_remotes` option is set to true.').optional(),
    _search: cluster_stats_ccs_usage_stats,
    _esql: cluster_stats_ccs_usage_stats.optional()
});

/**
 * Contains statistics about the number of nodes selected by the request.
 */
export const types_node_statistics = z.object({
    failures: z.array(types_error_cause).optional(),
    total: z.number().describe('Total number of nodes selected by the request.'),
    successful: z.number().describe('Number of nodes that responded successfully to the request.'),
    failed: z.number().describe('Number of nodes that rejected the request or failed to respond. If this value is not 0, a reason for the rejection or failure is included in the response.')
}).describe('Contains statistics about the number of nodes selected by the request.');

export const nodes_types_nodes_response_base = z.object({
    _nodes: types_node_statistics.optional()
});

export const cluster_stats_stats_response_base = nodes_types_nodes_response_base.and(z.object({
    cluster_name: types_name,
    cluster_uuid: types_uuid,
    indices: cluster_stats_cluster_indices,
    nodes: cluster_stats_cluster_nodes,
    repositories: z.record(z.record(z.number())).describe('Contains stats on repository feature usage exposed in cluster stats for telemetry.'),
    snapshots: cluster_stats_cluster_snapshot_stats,
    status: types_health_status.optional(),
    timestamp: z.number().describe('Unix timestamp, in milliseconds, for the last time the cluster statistics were refreshed.'),
    ccs: cluster_stats_ccs_stats
}));

export const types_result = z.enum([
    'created',
    'updated',
    'deleted',
    'not_found',
    'noop'
]);

/**
 * A scalar value.
 */
export const types_scalar_value = z.union([
    z.number(),
    z.string(),
    z.boolean(),
    z.null()
]);

export const connector_types_dependency = z.object({
    field: z.string(),
    value: types_scalar_value
});

export const connector_types_display_type = z.enum([
    'textbox',
    'textarea',
    'numeric',
    'toggle',
    'dropdown'
]);

export const connector_types_select_option = z.object({
    label: z.string(),
    value: types_scalar_value
});

export const connector_types_connector_field_type = z.enum([
    'str',
    'int',
    'list',
    'bool'
]);

export const connector_types_less_than_validation = z.object({
    type: z.enum(['less_than']),
    constraint: z.number()
});

export const connector_types_greater_than_validation = z.object({
    type: z.enum(['greater_than']),
    constraint: z.number()
});

export const connector_types_list_type_validation = z.object({
    type: z.enum(['list_type']),
    constraint: z.string()
});

export const connector_types_included_in_validation = z.object({
    type: z.enum(['included_in']),
    constraint: z.array(types_scalar_value)
});

export const connector_types_regex_validation = z.object({
    type: z.enum(['regex']),
    constraint: z.string()
});

export const connector_types_validation = z.union([
    connector_types_less_than_validation,
    connector_types_greater_than_validation,
    connector_types_list_type_validation,
    connector_types_included_in_validation,
    connector_types_regex_validation
]);

export const connector_types_connector_config_properties = z.object({
    category: z.string().optional(),
    default_value: types_scalar_value,
    depends_on: z.array(connector_types_dependency),
    display: connector_types_display_type,
    label: z.string(),
    options: z.array(connector_types_select_option),
    order: z.number().optional(),
    placeholder: z.string().optional(),
    required: z.boolean(),
    sensitive: z.boolean(),
    tooltip: z.union([
        z.string(),
        z.null()
    ]).optional(),
    type: connector_types_connector_field_type.optional(),
    ui_restrictions: z.array(z.string()).optional(),
    validations: z.array(connector_types_validation).optional(),
    value: z.record(z.unknown())
});

export const connector_types_connector_configuration = z.record(connector_types_connector_config_properties);

export const connector_types_custom_scheduling_configuration_overrides = z.object({
    max_crawl_depth: z.number().optional(),
    sitemap_discovery_disabled: z.boolean().optional(),
    domain_allowlist: z.array(z.string()).optional(),
    sitemap_urls: z.array(z.string()).optional(),
    seed_urls: z.array(z.string()).optional()
});

export const connector_types_custom_scheduling = z.object({
    configuration_overrides: connector_types_custom_scheduling_configuration_overrides,
    enabled: z.boolean(),
    interval: z.string(),
    last_synced: types_date_time.optional(),
    name: z.string()
});

export const connector_types_connector_custom_scheduling = z.record(connector_types_custom_scheduling);

export const connector_types_feature_enabled = z.object({
    enabled: z.boolean()
});

export const connector_types_sync_rules_feature = z.object({
    advanced: connector_types_feature_enabled.optional(),
    basic: connector_types_feature_enabled.optional()
});

export const connector_types_connector_features = z.object({
    document_level_security: connector_types_feature_enabled.optional(),
    incremental_sync: connector_types_feature_enabled.optional(),
    native_connector_api_keys: connector_types_feature_enabled.optional(),
    sync_rules: connector_types_sync_rules_feature.optional()
});

export const connector_types_filtering_advanced_snippet = z.object({
    created_at: types_date_time.optional(),
    updated_at: types_date_time.optional(),
    value: z.record(z.unknown())
});

export const connector_types_filtering_policy = z.enum(['exclude', 'include']);

export const connector_types_filtering_rule_rule = z.enum([
    'contains',
    'ends_with',
    'equals',
    'regex',
    'starts_with',
    '>',
    '<'
]);

export const connector_types_filtering_rule = z.object({
    created_at: types_date_time.optional(),
    field: types_field,
    id: types_id,
    order: z.number(),
    policy: connector_types_filtering_policy,
    rule: connector_types_filtering_rule_rule,
    updated_at: types_date_time.optional(),
    value: z.string()
});

export const connector_types_filtering_validation = z.object({
    ids: z.array(types_id),
    messages: z.array(z.string())
});

export const connector_types_filtering_validation_state = z.enum([
    'edited',
    'invalid',
    'valid'
]);

export const connector_types_filtering_rules_validation = z.object({
    errors: z.array(connector_types_filtering_validation),
    state: connector_types_filtering_validation_state
});

export const connector_types_filtering_rules = z.object({
    advanced_snippet: connector_types_filtering_advanced_snippet,
    rules: z.array(connector_types_filtering_rule),
    validation: connector_types_filtering_rules_validation
});

export const connector_types_filtering_config = z.object({
    active: connector_types_filtering_rules,
    domain: z.string().optional(),
    draft: connector_types_filtering_rules
});

export const connector_types_sync_status = z.enum([
    'canceling',
    'canceled',
    'completed',
    'error',
    'in_progress',
    'pending',
    'suspended'
]);

export const connector_types_ingest_pipeline_params = z.object({
    extract_binary_content: z.boolean(),
    name: z.string(),
    reduce_whitespace: z.boolean(),
    run_ml_inference: z.boolean()
});

export const connector_types_connector_scheduling = z.object({
    enabled: z.boolean(),
    interval: z.string().describe('The interval is expressed using the crontab syntax')
});

export const connector_types_scheduling_configuration = z.object({
    access_control: connector_types_connector_scheduling.optional(),
    full: connector_types_connector_scheduling.optional(),
    incremental: connector_types_connector_scheduling.optional()
});

export const connector_types_connector_status = z.enum([
    'created',
    'needs_configuration',
    'configured',
    'connected',
    'error'
]);

export const connector_types_connector = z.object({
    api_key_id: z.string().optional(),
    api_key_secret_id: z.string().optional(),
    configuration: connector_types_connector_configuration,
    custom_scheduling: connector_types_connector_custom_scheduling,
    deleted: z.boolean(),
    description: z.string().optional(),
    error: z.union([
        z.string(),
        z.null()
    ]).optional(),
    features: connector_types_connector_features.optional(),
    filtering: z.array(connector_types_filtering_config),
    id: types_id.optional(),
    index_name: z.union([
        types_index_name,
        z.string(),
        z.null()
    ]).optional(),
    is_native: z.boolean(),
    language: z.string().optional(),
    last_access_control_sync_error: z.string().optional(),
    last_access_control_sync_scheduled_at: types_date_time.optional(),
    last_access_control_sync_status: connector_types_sync_status.optional(),
    last_deleted_document_count: z.number().optional(),
    last_incremental_sync_scheduled_at: types_date_time.optional(),
    last_indexed_document_count: z.number().optional(),
    last_seen: types_date_time.optional(),
    last_sync_error: z.string().optional(),
    last_sync_scheduled_at: types_date_time.optional(),
    last_sync_status: connector_types_sync_status.optional(),
    last_synced: types_date_time.optional(),
    name: z.string().optional(),
    pipeline: connector_types_ingest_pipeline_params.optional(),
    scheduling: connector_types_scheduling_configuration,
    service_type: z.string().optional(),
    status: connector_types_connector_status,
    sync_cursor: z.record(z.unknown()).optional(),
    sync_now: z.boolean()
});

export const connector_types_sync_job_connector_reference = z.object({
    configuration: connector_types_connector_configuration,
    filtering: connector_types_filtering_rules,
    id: types_id,
    index_name: z.string(),
    language: z.string().optional(),
    pipeline: connector_types_ingest_pipeline_params.optional(),
    service_type: z.string(),
    sync_cursor: z.record(z.unknown()).optional()
});

export const connector_types_sync_job_type = z.enum([
    'full',
    'incremental',
    'access_control'
]);

export const connector_types_sync_job_trigger_method = z.enum(['on_demand', 'scheduled']);

export const connector_types_connector_sync_job = z.object({
    cancelation_requested_at: types_date_time.optional(),
    canceled_at: types_date_time.optional(),
    completed_at: types_date_time.optional(),
    connector: connector_types_sync_job_connector_reference,
    created_at: types_date_time,
    deleted_document_count: z.number(),
    error: z.string().optional(),
    id: types_id,
    indexed_document_count: z.number(),
    indexed_document_volume: z.number(),
    job_type: connector_types_sync_job_type,
    last_seen: types_date_time.optional(),
    metadata: z.record(z.record(z.unknown())),
    started_at: types_date_time.optional(),
    status: connector_types_sync_status,
    total_document_count: z.number(),
    trigger_method: connector_types_sync_job_trigger_method,
    worker_hostname: z.string().optional()
});

export const types_write_response_base = z.object({
    _id: types_id,
    _index: types_index_name,
    _primary_term: z.number().describe('The primary term assigned to the document for the indexing operation.').optional(),
    result: types_result,
    _seq_no: types_sequence_number.optional(),
    _shards: types_shard_statistics,
    _version: types_version_number,
    failure_store: global_bulk_failure_store_status.optional(),
    forced_refresh: z.boolean().optional()
});

export const dangling_indices_list_dangling_indices_dangling_index = z.object({
    index_name: z.string(),
    index_uuid: z.string(),
    creation_date_millis: types_epoch_time_unit_millis,
    node_ids: types_ids
});

export const types_conflicts = z.enum(['abort', 'proceed']);

export const types_slices_calculation = z.enum(['auto']);

/**
 * Slices configuration used to parallelize a process.
 */
export const types_slices = z.union([
    z.number(),
    types_slices_calculation
]);

export const types_bulk_index_by_scroll_failure = z.object({
    cause: types_error_cause,
    id: types_id,
    index: types_index_name,
    status: z.number()
});

export const types_retries = z.object({
    bulk: z.number().describe('The number of bulk actions retried.'),
    search: z.number().describe('The number of search actions retried.')
});

export const types_task_id = z.string();

export const types_task_failure = z.object({
    task_id: z.number(),
    node_id: types_node_id,
    status: z.string(),
    reason: types_error_cause
});

export const tasks_types_task_info = z.object({
    action: z.string(),
    cancelled: z.boolean().optional(),
    cancellable: z.boolean(),
    description: z.string().describe('Human readable text that identifies the particular request that the task is performing.\nFor example, it might identify the search request being performed by a search task.\nOther kinds of tasks have different descriptions, like `_reindex` which has the source and the destination, or `_bulk` which just has the number of requests and the destination indices.\nMany requests will have only an empty description because more detailed information about the request is not easily available or particularly helpful in identifying the request.').optional(),
    headers: z.record(z.string()),
    id: z.number(),
    node: types_node_id,
    running_time: types_duration.optional(),
    running_time_in_nanos: types_duration_value_unit_nanos,
    start_time_in_millis: types_epoch_time_unit_millis,
    status: z.record(z.unknown()).describe('The internal status of the task, which varies from task to task.\nThe format also varies.\nWhile the goal is to keep the status for a particular task consistent from version to version, this is not always possible because sometimes the implementation changes.\nFields might be removed from the status for a particular request so any parsing you do of the status might break in minor releases.').optional(),
    type: z.string(),
    parent_task_id: types_task_id.optional()
});

export const tasks_types_node_tasks = z.object({
    name: types_node_id.optional(),
    transport_address: types_transport_address.optional(),
    host: types_host.optional(),
    ip: types_ip.optional(),
    roles: z.array(z.string()).optional(),
    attributes: z.record(z.string()).optional(),
    tasks: z.record(tasks_types_task_info)
});

export const tasks_types_parent_task_info = tasks_types_task_info.and(z.object({
    children: z.array(tasks_types_task_info).optional()
}));

export const tasks_types_task_infos = z.union([
    z.array(tasks_types_task_info),
    z.record(tasks_types_parent_task_info)
]);

export const tasks_types_task_list_response_base = z.object({
    node_failures: z.array(types_error_cause).optional(),
    task_failures: z.array(types_task_failure).optional(),
    nodes: z.record(tasks_types_node_tasks).describe('Task information grouped by node, if `group_by` was set to `node` (the default).').optional(),
    tasks: tasks_types_task_infos.optional()
});

export const enrich_execute_policy_enrich_policy_phase = z.enum([
    'SCHEDULED',
    'RUNNING',
    'COMPLETE',
    'FAILED',
    'CANCELLED'
]);

export const enrich_execute_policy_execute_enrich_policy_status = z.object({
    phase: enrich_execute_policy_enrich_policy_phase,
    step: z.string().optional()
});

export const enrich_stats_coordinator_stats = z.object({
    executed_searches_total: z.number(),
    node_id: types_id,
    queue_size: z.number(),
    remote_requests_current: z.number(),
    remote_requests_total: z.number()
});

export const enrich_stats_executing_policy = z.object({
    name: types_name,
    task: tasks_types_task_info
});

export const enrich_stats_cache_stats = z.object({
    node_id: types_id,
    count: z.number(),
    hits: z.number(),
    hits_time_in_millis: types_duration_value_unit_millis,
    misses: z.number(),
    misses_time_in_millis: types_duration_value_unit_millis,
    evictions: z.number(),
    size_in_bytes: z.number()
});

export const eql_types_hits_event = z.object({
    _index: types_index_name,
    _id: types_id,
    _source: z.record(z.unknown()).describe('Original JSON body passed for the event at index time.'),
    missing: z.boolean().describe('Set to `true` for events in a timespan-constrained sequence that do not meet a given condition.').optional(),
    fields: z.record(z.array(z.record(z.unknown()))).optional()
});

export const eql_types_hits_sequence = z.object({
    events: z.array(eql_types_hits_event).describe('Contains events matching the query. Each object represents a matching event.'),
    join_keys: z.array(z.record(z.unknown())).describe('Shared field values used to constrain matches in the sequence. These are defined using the by keyword in the EQL query syntax.').optional()
});

export const eql_types_eql_hits = z.object({
    total: global_search_types_total_hits.optional(),
    events: z.array(eql_types_hits_event).describe('Contains events matching the query. Each object represents a matching event.').optional(),
    sequences: z.array(eql_types_hits_sequence).describe('Contains event sequences matching the query. Each object represents a matching sequence. This parameter is only returned for EQL queries containing a sequence.').optional()
});

export const eql_types_eql_search_response_base = z.object({
    id: types_id.optional(),
    is_partial: z.boolean().describe('If true, the response does not contain complete search results.').optional(),
    is_running: z.boolean().describe('If true, the search request is still executing.').optional(),
    took: types_duration_value_unit_millis.optional(),
    timed_out: z.boolean().describe('If true, the request timed out before completion.').optional(),
    hits: eql_types_eql_hits,
    shard_failures: z.array(types_shard_failure).describe('Contains information about shard failures (if any), in case allow_partial_search_results=true').optional()
});

export const eql_search_result_position = z.enum(['tail', 'head']);

export const esql_types_esql_format = z.enum([
    'csv',
    'json',
    'tsv',
    'txt',
    'yaml',
    'cbor',
    'smile',
    'arrow'
]);

export const esql_types_table_values_integer_value = z.union([
    z.number(),
    z.array(z.number())
]);

export const esql_types_table_values_keyword_value = z.union([
    z.string(),
    z.array(z.string())
]);

export const esql_types_table_values_long_value = z.union([
    z.number(),
    z.array(z.number())
]);

export const esql_types_table_values_long_double = z.union([
    z.number(),
    z.array(z.number())
]);

export const esql_types_table_values_container = z.object({
    integer: z.array(esql_types_table_values_integer_value).optional(),
    keyword: z.array(esql_types_table_values_keyword_value).optional(),
    long: z.array(esql_types_table_values_long_value).optional(),
    double: z.array(esql_types_table_values_long_double).optional()
});

export const esql_types_esql_column_info = z.object({
    name: z.string(),
    type: z.string()
});

export const esql_types_esql_cluster_status = z.enum([
    'running',
    'successful',
    'partial',
    'skipped',
    'failed'
]);

export const esql_types_esql_shard_info = z.object({
    total: z.number(),
    successful: z.number().optional(),
    skipped: z.number().optional(),
    failed: z.number().optional()
});

export const esql_types_esql_shard_failure = z.object({
    shard: z.number(),
    index: z.union([
        types_index_name,
        z.string(),
        z.null()
    ]),
    node: types_node_id.optional(),
    reason: types_error_cause
});

export const esql_types_esql_cluster_details = z.object({
    status: esql_types_esql_cluster_status,
    indices: z.string(),
    took: types_duration_value_unit_millis.optional(),
    _shards: esql_types_esql_shard_info.optional(),
    failures: z.array(esql_types_esql_shard_failure).optional()
});

export const esql_types_esql_cluster_info = z.object({
    total: z.number(),
    successful: z.number(),
    running: z.number(),
    skipped: z.number(),
    partial: z.number(),
    failed: z.number(),
    details: z.record(esql_types_esql_cluster_details)
});

export const esql_types_esql_result = z.object({
    took: types_duration_value_unit_millis.optional(),
    is_partial: z.boolean().optional(),
    all_columns: z.array(esql_types_esql_column_info).optional(),
    columns: z.array(esql_types_esql_column_info),
    values: z.array(z.array(types_field_value)),
    _clusters: esql_types_esql_cluster_info.optional(),
    profile: z.record(z.unknown()).describe('Profiling information. Present if `profile` was `true` in the request.\nThe contents of this field are currently unstable.').optional()
});

export const esql_types_async_esql_result = esql_types_esql_result.and(z.object({
    id: z.string().describe('The ID of the async query, to be used in subsequent requests to check the status or retrieve results.\n\nAlso available in the `X-Elasticsearch-Async-Id` HTTP header.').optional(),
    is_running: z.boolean().describe('Indicates whether the async query is still running or has completed.\n\nAlso available in the `X-Elasticsearch-Async-Is-Running` HTTP header.')
}));

export const esql_list_queries_body = z.object({
    id: z.number(),
    node: types_node_id,
    start_time_millis: z.number(),
    running_time_nanos: z.number(),
    query: z.string()
});

export const esql_types_esql_param = z.union([
    types_field_value,
    z.array(types_field_value)
]);

export const types_inline_get = z.object({
    fields: z.record(z.record(z.unknown())).optional(),
    found: z.boolean(),
    _seq_no: types_sequence_number.optional(),
    _primary_term: z.number().optional(),
    _routing: types_routing.optional(),
    _source: z.record(z.unknown()).optional()
});

export const features_types_feature = z.object({
    name: z.string(),
    description: z.string()
});

export const global_field_caps_field_capability = z.object({
    aggregatable: z.boolean().describe('Whether this field can be aggregated on all indices.'),
    indices: types_indices.optional(),
    meta: types_metadata.optional(),
    non_aggregatable_indices: types_indices.optional(),
    non_searchable_indices: types_indices.optional(),
    searchable: z.boolean().describe('Whether this field is indexed for search on all indices.'),
    type: z.string(),
    metadata_field: z.boolean().describe('Whether this field is registered as a metadata field.').optional(),
    time_series_dimension: z.boolean().describe('Whether this field is used as a time series dimension.').optional(),
    time_series_metric: types_mapping_time_series_metric_type.optional(),
    non_dimension_indices: z.array(types_index_name).describe('If this list is present in response then some indices have the\nfield marked as a dimension and other indices, the ones in this list, do not.').optional(),
    metric_conflicts_indices: z.array(types_index_name).describe('The list of indices where this field is present if these indices\ndont have the same `time_series_metric` value for this field.').optional()
});

export const types_index_alias = z.string();

export const fleet_types_checkpoint = z.number();

export const types_project_routing = z.string();

/**
 * Contains parameters used to limit or change the subsequent search body request.
 */
export const global_msearch_multisearch_header = z.object({
    allow_no_indices: z.boolean().optional(),
    expand_wildcards: types_expand_wildcards.optional(),
    ignore_unavailable: z.boolean().optional(),
    index: types_indices.optional(),
    preference: z.string().optional(),
    project_routing: types_project_routing.optional(),
    request_cache: z.boolean().optional(),
    routing: types_routing.optional(),
    search_type: types_search_type.optional(),
    ccs_minimize_roundtrips: z.boolean().optional(),
    allow_partial_search_results: z.boolean().optional(),
    ignore_throttled: z.boolean().optional()
}).describe('Contains parameters used to limit or change the subsequent search body request.');

/**
 * The response returned by Elasticsearch when request execution did not succeed.
 */
export const types_error_response_base = z.object({
    error: types_error_cause,
    status: z.number()
}).describe('The response returned by Elasticsearch when request execution did not succeed.');

export const global_get_get_result = z.object({
    _index: types_index_name,
    fields: z.record(z.record(z.unknown())).describe('If the `stored_fields` parameter is set to `true` and `found` is `true`, it contains the document fields stored in the index.').optional(),
    _ignored: z.array(z.string()).optional(),
    found: z.boolean().describe('Indicates whether the document exists.'),
    _id: types_id,
    _primary_term: z.number().describe('The primary term assigned to the document for the indexing operation.').optional(),
    _routing: z.string().describe('The explicit routing, if set.').optional(),
    _seq_no: types_sequence_number.optional(),
    _source: z.record(z.unknown()).describe('If `found` is `true`, it contains the document data formatted in JSON.\nIf the `_source` parameter is set to `false` or the `stored_fields` parameter is set to `true`, it is excluded.').optional(),
    _version: types_version_number.optional()
});

export const global_get_script_context_context_method_param = z.object({
    name: types_name,
    type: z.string()
});

export const global_get_script_context_context_method = z.object({
    name: types_name,
    return_type: z.string(),
    params: z.array(global_get_script_context_context_method_param)
});

export const global_get_script_context_context = z.object({
    methods: z.array(global_get_script_context_context_method),
    name: types_name
});

export const global_get_script_languages_language_context = z.object({
    contexts: z.array(z.string()),
    language: types_script_language
});

export const graph_types_vertex_include = z.object({
    boost: z.number().optional(),
    term: z.string()
});

export const graph_types_vertex_definition = z.object({
    exclude: z.array(z.string()).describe('Prevents the specified terms from being included in the results.').optional(),
    field: types_field,
    include: z.array(graph_types_vertex_include).describe('Identifies the terms of interest that form the starting points from which you want to spider out.').optional(),
    min_doc_count: z.number().describe('Specifies how many documents must contain a pair of terms before it is considered to be a useful connection.\nThis setting acts as a certainty threshold.').optional().default(3),
    shard_min_doc_count: z.number().describe('Controls how many documents on a particular shard have to contain a pair of terms before the connection is returned for global consideration.').optional().default(2),
    size: z.number().describe('Specifies the maximum number of vertex terms returned for each field.').optional().default(5)
});

export const graph_types_sample_diversity = z.object({
    field: types_field,
    max_docs_per_value: z.number()
});

export const graph_types_explore_controls = z.object({
    sample_diversity: graph_types_sample_diversity.optional(),
    sample_size: z.number().describe('Each hop considers a sample of the best-matching documents on each shard.\nUsing samples improves the speed of execution and keeps exploration focused on meaningfully-connected terms.\nVery small values (less than 50) might not provide sufficient weight-of-evidence to identify significant connections between terms.\nVery large sample sizes can dilute the quality of the results and increase execution times.').optional().default(100),
    timeout: types_duration.optional(),
    use_significance: z.boolean().describe('Filters associated terms so only those that are significantly associated with your query are included.')
});

export const graph_types_connection = z.object({
    doc_count: z.number(),
    source: z.number(),
    target: z.number(),
    weight: z.number()
});

export const graph_types_vertex = z.object({
    depth: z.number(),
    field: types_field,
    term: z.string(),
    weight: z.number()
});

export const global_health_report_indicator_node = z.object({
    name: z.union([
        z.string(),
        z.null()
    ]),
    node_id: z.union([
        z.string(),
        z.null()
    ])
});

export const global_health_report_master_is_stable_indicator_exception_fetching_history = z.object({
    message: z.string(),
    stack_trace: z.string()
});

export const global_health_report_master_is_stable_indicator_cluster_formation_node = z.object({
    name: z.string().optional(),
    node_id: z.string(),
    cluster_formation_message: z.string()
});

export const global_health_report_master_is_stable_indicator_details = z.object({
    current_master: global_health_report_indicator_node,
    recent_masters: z.array(global_health_report_indicator_node),
    exception_fetching_history: global_health_report_master_is_stable_indicator_exception_fetching_history.optional(),
    cluster_formation: z.array(global_health_report_master_is_stable_indicator_cluster_formation_node).optional()
});

export const global_health_report_indicator_health_status = z.enum([
    'green',
    'yellow',
    'red',
    'unknown',
    'unavailable'
]);

export const global_health_report_impact_area = z.enum([
    'search',
    'ingest',
    'backup',
    'deployment_management'
]);

export const global_health_report_impact = z.object({
    description: z.string(),
    id: z.string(),
    impact_areas: z.array(global_health_report_impact_area),
    severity: z.number()
});

export const global_health_report_diagnosis_affected_resources = z.object({
    indices: types_indices.optional(),
    nodes: z.array(global_health_report_indicator_node).optional(),
    slm_policies: z.array(z.string()).optional(),
    feature_states: z.array(z.string()).optional(),
    snapshot_repositories: z.array(z.string()).optional()
});

export const global_health_report_diagnosis = z.object({
    id: z.string(),
    action: z.string(),
    affected_resources: global_health_report_diagnosis_affected_resources,
    cause: z.string(),
    help_url: z.string()
});

export const global_health_report_base_indicator = z.object({
    status: global_health_report_indicator_health_status,
    symptom: z.string(),
    impacts: z.array(global_health_report_impact).optional(),
    diagnosis: z.array(global_health_report_diagnosis).optional()
});

/**
 * MASTER_IS_STABLE
 */
export const global_health_report_master_is_stable_indicator = global_health_report_base_indicator.and(z.object({
    details: global_health_report_master_is_stable_indicator_details.optional()
}));

export const global_health_report_shards_availability_indicator_details = z.object({
    creating_primaries: z.number(),
    creating_replicas: z.number(),
    initializing_primaries: z.number(),
    initializing_replicas: z.number(),
    restarting_primaries: z.number(),
    restarting_replicas: z.number(),
    started_primaries: z.number(),
    started_replicas: z.number(),
    unassigned_primaries: z.number(),
    unassigned_replicas: z.number()
});

/**
 * SHARDS_AVAILABILITY
 */
export const global_health_report_shards_availability_indicator = global_health_report_base_indicator.and(z.object({
    details: global_health_report_shards_availability_indicator_details.optional()
}));

export const global_health_report_disk_indicator_details = z.object({
    indices_with_readonly_block: z.number(),
    nodes_with_enough_disk_space: z.number(),
    nodes_over_high_watermark: z.number(),
    nodes_over_flood_stage_watermark: z.number(),
    nodes_with_unknown_disk_status: z.number()
});

/**
 * DISK
 */
export const global_health_report_disk_indicator = global_health_report_base_indicator.and(z.object({
    details: global_health_report_disk_indicator_details.optional()
}));

export const global_health_report_repository_integrity_indicator_details = z.object({
    total_repositories: z.number().optional(),
    corrupted_repositories: z.number().optional(),
    corrupted: z.array(z.string()).optional()
});

/**
 * REPOSITORY_INTEGRITY
 */
export const global_health_report_repository_integrity_indicator = global_health_report_base_indicator.and(z.object({
    details: global_health_report_repository_integrity_indicator_details.optional()
}));

export const global_health_report_stagnating_backing_indices = z.object({
    index_name: types_index_name,
    first_occurrence_timestamp: z.number(),
    retry_count: z.number()
});

export const global_health_report_data_stream_lifecycle_details = z.object({
    stagnating_backing_indices_count: z.number(),
    total_backing_indices_in_error: z.number(),
    stagnating_backing_indices: z.array(global_health_report_stagnating_backing_indices).optional()
});

/**
 * DATA_STREAM_LIFECYCLE
 */
export const global_health_report_data_stream_lifecycle_indicator = global_health_report_base_indicator.and(z.object({
    details: global_health_report_data_stream_lifecycle_details.optional()
}));

export const types_lifecycle_operation_mode = z.enum([
    'RUNNING',
    'STOPPING',
    'STOPPED'
]);

export const global_health_report_ilm_indicator_details = z.object({
    ilm_status: types_lifecycle_operation_mode,
    policies: z.number(),
    stagnating_indices: z.number()
});

/**
 * ILM
 */
export const global_health_report_ilm_indicator = global_health_report_base_indicator.and(z.object({
    details: global_health_report_ilm_indicator_details.optional()
}));

export const global_health_report_slm_indicator_unhealthy_policies = z.object({
    count: z.number(),
    invocations_since_last_success: z.record(z.number()).optional()
});

export const global_health_report_slm_indicator_details = z.object({
    slm_status: types_lifecycle_operation_mode,
    policies: z.number(),
    unhealthy_policies: global_health_report_slm_indicator_unhealthy_policies.optional()
});

/**
 * SLM
 */
export const global_health_report_slm_indicator = global_health_report_base_indicator.and(z.object({
    details: global_health_report_slm_indicator_details.optional()
}));

export const global_health_report_shards_capacity_indicator_tier_detail = z.object({
    max_shards_in_cluster: z.number(),
    current_used_shards: z.number().optional()
});

export const global_health_report_shards_capacity_indicator_details = z.object({
    data: global_health_report_shards_capacity_indicator_tier_detail,
    frozen: global_health_report_shards_capacity_indicator_tier_detail
});

/**
 * SHARDS_CAPACITY
 */
export const global_health_report_shards_capacity_indicator = global_health_report_base_indicator.and(z.object({
    details: global_health_report_shards_capacity_indicator_details.optional()
}));

export const global_health_report_file_settings_indicator_details = z.object({
    failure_streak: z.number(),
    most_recent_failure: z.string()
});

/**
 * FILE_SETTINGS
 */
export const global_health_report_file_settings_indicator = global_health_report_base_indicator.and(z.object({
    details: global_health_report_file_settings_indicator_details.optional()
}));

export const global_health_report_indicators = z.object({
    master_is_stable: global_health_report_master_is_stable_indicator.optional(),
    shards_availability: global_health_report_shards_availability_indicator.optional(),
    disk: global_health_report_disk_indicator.optional(),
    repository_integrity: global_health_report_repository_integrity_indicator.optional(),
    data_stream_lifecycle: global_health_report_data_stream_lifecycle_indicator.optional(),
    ilm: global_health_report_ilm_indicator.optional(),
    slm: global_health_report_slm_indicator.optional(),
    shards_capacity: global_health_report_shards_capacity_indicator.optional(),
    file_settings: global_health_report_file_settings_indicator.optional()
});

export const ilm_types_allocate_action = z.object({
    number_of_replicas: z.number().optional(),
    total_shards_per_node: z.number().optional(),
    include: z.record(z.string()).optional(),
    exclude: z.record(z.string()).optional(),
    require: z.record(z.string()).optional()
});

export const ilm_types_delete_action = z.object({
    delete_searchable_snapshot: z.boolean().optional()
});

export const ilm_types_downsample_action = z.object({
    fixed_interval: types_duration_large,
    wait_timeout: types_duration.optional()
});

export const ilm_types_force_merge_action = z.object({
    max_num_segments: z.number(),
    index_codec: z.string().optional()
});

export const ilm_types_migrate_action = z.object({
    enabled: z.boolean().optional()
});

export const ilm_types_rollover_action = z.object({
    max_size: types_byte_size.optional(),
    max_primary_shard_size: types_byte_size.optional(),
    max_age: types_duration.optional(),
    max_docs: z.number().optional(),
    max_primary_shard_docs: z.number().optional(),
    min_size: types_byte_size.optional(),
    min_primary_shard_size: types_byte_size.optional(),
    min_age: types_duration.optional(),
    min_docs: z.number().optional(),
    min_primary_shard_docs: z.number().optional()
});

export const ilm_types_set_priority_action = z.object({
    priority: z.number().optional()
});

export const ilm_types_searchable_snapshot_action = z.object({
    snapshot_repository: z.string(),
    force_merge_index: z.boolean().optional()
});

export const ilm_types_shrink_action = z.object({
    number_of_shards: z.number().optional(),
    max_primary_shard_size: types_byte_size.optional(),
    allow_write_after_shrink: z.boolean().optional()
});

export const ilm_types_wait_for_snapshot_action = z.object({
    policy: z.string()
});

export const ilm_types_actions = z.object({
    allocate: ilm_types_allocate_action.optional(),
    delete: ilm_types_delete_action.optional(),
    downsample: ilm_types_downsample_action.optional(),
    freeze: types_empty_object.optional(),
    forcemerge: ilm_types_force_merge_action.optional(),
    migrate: ilm_types_migrate_action.optional(),
    readonly: types_empty_object.optional(),
    rollover: ilm_types_rollover_action.optional(),
    set_priority: ilm_types_set_priority_action.optional(),
    searchable_snapshot: ilm_types_searchable_snapshot_action.optional(),
    shrink: ilm_types_shrink_action.optional(),
    unfollow: types_empty_object.optional(),
    wait_for_snapshot: ilm_types_wait_for_snapshot_action.optional()
});

export const ilm_types_phase = z.object({
    actions: ilm_types_actions.optional(),
    min_age: types_duration.optional()
});

export const ilm_explain_lifecycle_lifecycle_explain_phase_execution = z.object({
    phase_definition: ilm_types_phase.optional(),
    policy: types_name,
    version: types_version_number,
    modified_date_in_millis: types_epoch_time_unit_millis
});

export const ilm_explain_lifecycle_lifecycle_explain_managed = z.object({
    action: types_name.optional(),
    action_time: types_date_time.optional(),
    action_time_millis: types_epoch_time_unit_millis.optional(),
    age: types_duration.optional(),
    age_in_millis: types_duration_value_unit_millis.optional(),
    failed_step: types_name.optional(),
    failed_step_retry_count: z.number().optional(),
    index: types_index_name,
    index_creation_date: types_date_time.optional(),
    index_creation_date_millis: types_epoch_time_unit_millis.optional(),
    is_auto_retryable_error: z.boolean().optional(),
    lifecycle_date: types_date_time.optional(),
    lifecycle_date_millis: types_epoch_time_unit_millis.optional(),
    managed: z.enum(['true']),
    phase: types_name.optional(),
    phase_time: types_date_time.optional(),
    phase_time_millis: types_epoch_time_unit_millis.optional(),
    policy: types_name.optional(),
    previous_step_info: z.record(z.record(z.unknown())).optional(),
    repository_name: z.string().optional(),
    snapshot_name: z.string().optional(),
    shrink_index_name: z.string().optional(),
    step: types_name.optional(),
    step_info: z.record(z.record(z.unknown())).optional(),
    step_time: types_date_time.optional(),
    step_time_millis: types_epoch_time_unit_millis.optional(),
    phase_execution: ilm_explain_lifecycle_lifecycle_explain_phase_execution.optional(),
    time_since_index_creation: types_duration.optional(),
    skip: z.boolean()
});

export const ilm_explain_lifecycle_lifecycle_explain_unmanaged = z.object({
    index: types_index_name,
    managed: z.enum(['false'])
});

export const ilm_explain_lifecycle_lifecycle_explain = z.union([
    ilm_explain_lifecycle_lifecycle_explain_managed,
    ilm_explain_lifecycle_lifecycle_explain_unmanaged
]);

export const ilm_types_phases = z.object({
    cold: ilm_types_phase.optional(),
    delete: ilm_types_phase.optional(),
    frozen: ilm_types_phase.optional(),
    hot: ilm_types_phase.optional(),
    warm: ilm_types_phase.optional()
});

export const ilm_types_policy = z.object({
    phases: ilm_types_phases,
    _meta: types_metadata.optional()
});

export const ilm_get_lifecycle_lifecycle = z.object({
    modified_date: types_date_time,
    policy: ilm_types_policy,
    version: types_version_number
});

export const ilm_move_to_step_step_key = z.object({
    action: z.string().describe('The optional action to which the index will be moved.').optional(),
    name: z.string().describe('The optional step name to which the index will be moved.').optional(),
    phase: z.string()
});

export const types_op_type = z.enum(['index', 'create']);

export const indices_types_indices_block_options = z.enum([
    'metadata',
    'read',
    'read_only',
    'write'
]);

export const indices_add_block_add_indices_block_status = z.object({
    name: types_index_name,
    blocked: z.boolean()
});

export const indices_analyze_text_to_analyze = z.union([
    z.string(),
    z.array(z.string())
]);

export const indices_analyze_explain_analyze_token = z.object({
    bytes: z.string(),
    end_offset: z.number(),
    keyword: z.boolean().optional(),
    position: z.number(),
    positionLength: z.number(),
    start_offset: z.number(),
    termFrequency: z.number(),
    token: z.string(),
    type: z.string()
});

export const indices_analyze_analyzer_detail = z.object({
    name: z.string(),
    tokens: z.array(indices_analyze_explain_analyze_token)
});

export const indices_analyze_char_filter_detail = z.object({
    filtered_text: z.array(z.string()),
    name: z.string()
});

export const indices_analyze_token_detail = z.object({
    name: z.string(),
    tokens: z.array(indices_analyze_explain_analyze_token)
});

export const indices_analyze_analyze_detail = z.object({
    analyzer: indices_analyze_analyzer_detail.optional(),
    charfilters: z.array(indices_analyze_char_filter_detail).optional(),
    custom_analyzer: z.boolean(),
    tokenfilters: z.array(indices_analyze_token_detail).optional(),
    tokenizer: indices_analyze_token_detail.optional()
});

export const indices_analyze_analyze_token = z.object({
    end_offset: z.number(),
    position: z.number(),
    positionLength: z.number().optional(),
    start_offset: z.number(),
    token: z.string(),
    type: z.string()
});

export const types_shards_operation_response_base = z.object({
    _shards: types_shard_statistics.optional()
});

export const indices_close_close_shard_result = z.object({
    failures: z.array(types_shard_failure)
});

export const indices_close_close_index_result = z.object({
    closed: z.boolean(),
    shards: z.record(indices_close_close_shard_result).optional()
});

export const indices_data_streams_stats_data_streams_stats_item = z.object({
    backing_indices: z.number().describe('Current number of backing indices for the data stream.'),
    data_stream: types_name,
    maximum_timestamp: types_epoch_time_unit_millis,
    store_size: types_byte_size.optional(),
    store_size_bytes: z.number().describe('Total size, in bytes, of all shards for the data streams backing indices.')
});

export const types_indices_response_base = types_acknowledged_response_base.and(z.object({
    _shards: types_shard_statistics.optional()
}));

export const indices_delete_alias_indices_aliases_response_body = types_acknowledged_response_base.and(z.object({
    errors: z.boolean().optional()
}));

export const types_data_stream_names = z.union([
    types_data_stream_name,
    z.array(types_data_stream_name)
]);

export const indices_types_sampling_method = z.enum(['aggregate', 'last_value']);

export const indices_types_downsample_config = z.object({
    fixed_interval: types_duration_large,
    sampling_method: indices_types_sampling_method.optional()
});

export const indices_explain_data_lifecycle_data_stream_lifecycle_explain = z.object({
    index: types_index_name,
    managed_by_lifecycle: z.boolean(),
    index_creation_date_millis: types_epoch_time_unit_millis.optional(),
    time_since_index_creation: types_duration.optional(),
    rollover_date_millis: types_epoch_time_unit_millis.optional(),
    time_since_rollover: types_duration.optional(),
    lifecycle: indices_types_data_stream_lifecycle_with_rollover.optional(),
    generation_time: types_duration.optional(),
    error: z.string().optional()
});

export const indices_field_usage_stats_fields_usage_body = z.object({
    _shards: types_shard_statistics
});

export const indices_forcemerge_types_force_merge_response_body = types_shards_operation_response_base.and(z.object({
    task: z.string().describe('task contains a task id returned when wait_for_completion=false,\nyou can use the task_id to get the status of the task at _tasks/<task_id>').optional()
}));

export const indices_get_feature = z.enum([
    'aliases',
    'mappings',
    'settings'
]);

export const indices_get_features = z.union([
    indices_get_feature,
    z.array(indices_get_feature)
]);

export const indices_get_data_lifecycle_data_stream_with_lifecycle = z.object({
    name: types_data_stream_name,
    lifecycle: indices_types_data_stream_lifecycle_with_rollover.optional()
});

export const indices_get_data_lifecycle_stats_data_stream_stats = z.object({
    backing_indices_in_error: z.number().describe('The count of the backing indices for the data stream.'),
    backing_indices_in_total: z.number().describe('The count of the backing indices for the data stream that have encountered an error.'),
    name: types_data_stream_name
});

export const indices_types_managed_by = z.enum([
    'Index Lifecycle Management',
    'Data stream lifecycle',
    'Unmanaged'
]);

export const indices_types_index_mode = z.enum([
    'standard',
    'time_series',
    'logsdb',
    'lookup'
]);

export const indices_types_data_stream_index = z.object({
    index_name: types_index_name,
    index_uuid: types_uuid,
    ilm_policy: types_name.optional(),
    managed_by: indices_types_managed_by.optional(),
    prefer_ilm: z.boolean().describe('Indicates if ILM should take precedence over DSL in case both are configured to manage this index.').optional(),
    index_mode: indices_types_index_mode.optional()
});

export const indices_types_failure_store = z.object({
    enabled: z.boolean(),
    indices: z.array(indices_types_data_stream_index),
    rollover_on_write: z.boolean()
});

export const indices_types_data_stream_timestamp_field = z.object({
    name: types_field
});

/**
 * The failure store lifecycle configures the data stream lifecycle configuration for failure indices.
 */
export const indices_types_failure_store_lifecycle = z.object({
    data_retention: types_duration.optional(),
    enabled: z.boolean().describe('If defined, it turns data stream lifecycle on/off (`true`/`false`) for this data stream. A data stream lifecycle\nthat\'s disabled (enabled: `false`) will have no effect on the data stream.').optional().default(true)
}).describe('The failure store lifecycle configures the data stream lifecycle configuration for failure indices.');

/**
 * Data stream failure store contains the configuration of the failure store for a given data stream.
 */
export const indices_types_data_stream_failure_store = z.object({
    enabled: z.boolean().describe('If defined, it turns the failure store on/off (`true`/`false`) for this data stream. A data stream failure store\nthat\'s disabled (enabled: `false`) will redirect no new failed indices to the failure store; however, it will\nnot remove any existing data from the failure store.').optional().default(true),
    lifecycle: indices_types_failure_store_lifecycle.optional()
}).describe('Data stream failure store contains the configuration of the failure store for a given data stream.');

/**
 * Data stream options contain the configuration of data stream level features for a given data stream, for example,
 * the failure store configuration.
 */
export const indices_types_data_stream_options = z.object({
    failure_store: indices_types_data_stream_failure_store.optional()
}).describe('Data stream options contain the configuration of data stream level features for a given data stream, for example,\nthe failure store configuration.');

export const indices_get_data_stream_options_data_stream_with_options = z.object({
    name: types_data_stream_name,
    options: indices_types_data_stream_options.optional()
});

export const indices_types_index_template_data_stream_configuration = z.object({
    hidden: z.boolean().describe('If true, the data stream is hidden.').optional().default(false),
    allow_custom_routing: z.boolean().describe('If true, the data stream supports custom routing.').optional().default(false)
});

export const indices_get_migrate_reindex_status_status_in_progress = z.object({
    index: z.string(),
    total_doc_count: z.number(),
    reindexed_doc_count: z.number()
});

export const indices_get_migrate_reindex_status_status_error = z.object({
    index: z.string(),
    message: z.string()
});

export const indices_migrate_reindex_mode_enum = z.enum(['upgrade']);

export const indices_migrate_reindex_source_index = z.object({
    index: types_index_name
});

export const indices_migrate_reindex_migrate_reindex = z.object({
    mode: indices_migrate_reindex_mode_enum,
    source: indices_migrate_reindex_source_index
});

export const indices_modify_data_stream_index_and_data_stream_action = z.object({
    data_stream: types_data_stream_name,
    index: types_index_name
});

export const indices_modify_data_stream_action = z.object({
    add_backing_index: indices_modify_data_stream_index_and_data_stream_action.optional(),
    remove_backing_index: indices_modify_data_stream_index_and_data_stream_action.optional()
});

export const indices_put_data_stream_settings_data_stream_settings_error = z.object({
    index: types_index_name,
    error: z.string().describe('A message explaining why the settings could not be applied to specific indices.')
});

export const indices_put_data_stream_settings_index_setting_results = z.object({
    applied_to_data_stream_only: z.array(z.string()).describe('The list of settings that were applied to the data stream but not to backing indices. These will be applied to\nthe write index the next time the data stream is rolled over.'),
    applied_to_data_stream_and_backing_indices: z.array(z.string()).describe('The list of settings that were applied to the data stream and to all of its backing indices. These settings will\nalso be applied to the write index the next time the data stream is rolled over.'),
    errors: z.array(indices_put_data_stream_settings_data_stream_settings_error).optional()
});

export const indices_types_data_stream_visibility = z.object({
    hidden: z.boolean().optional(),
    allow_custom_routing: z.boolean().optional()
});

export const indices_recovery_recovery_bytes = z.object({
    percent: types_percentage,
    recovered: types_byte_size.optional(),
    recovered_in_bytes: types_byte_size,
    recovered_from_snapshot: types_byte_size.optional(),
    recovered_from_snapshot_in_bytes: types_byte_size.optional(),
    reused: types_byte_size.optional(),
    reused_in_bytes: types_byte_size,
    total: types_byte_size.optional(),
    total_in_bytes: types_byte_size
});

export const indices_recovery_file_details = z.object({
    length: z.number(),
    name: z.string(),
    recovered: z.number()
});

export const indices_recovery_recovery_files = z.object({
    details: z.array(indices_recovery_file_details).optional(),
    percent: types_percentage,
    recovered: z.number(),
    reused: z.number(),
    total: z.number()
});

export const indices_recovery_recovery_index_status = z.object({
    bytes: indices_recovery_recovery_bytes.optional(),
    files: indices_recovery_recovery_files,
    size: indices_recovery_recovery_bytes,
    source_throttle_time: types_duration.optional(),
    source_throttle_time_in_millis: types_duration_value_unit_millis,
    target_throttle_time: types_duration.optional(),
    target_throttle_time_in_millis: types_duration_value_unit_millis,
    total_time: types_duration.optional(),
    total_time_in_millis: types_duration_value_unit_millis
});

export const indices_recovery_recovery_origin = z.object({
    hostname: z.string().optional(),
    host: types_host.optional(),
    transport_address: types_transport_address.optional(),
    id: types_id.optional(),
    ip: types_ip.optional(),
    name: types_name.optional(),
    bootstrap_new_history_uuid: z.boolean().optional(),
    repository: types_name.optional(),
    snapshot: types_name.optional(),
    version: types_version_string.optional(),
    restoreUUID: types_uuid.optional(),
    index: types_index_name.optional()
});

export const indices_recovery_recovery_start_status = z.object({
    check_index_time: types_duration.optional(),
    check_index_time_in_millis: types_duration_value_unit_millis,
    total_time: types_duration.optional(),
    total_time_in_millis: types_duration_value_unit_millis
});

export const indices_recovery_translog_status = z.object({
    percent: types_percentage,
    recovered: z.number(),
    total: z.number(),
    total_on_start: z.number(),
    total_time: types_duration.optional(),
    total_time_in_millis: types_duration_value_unit_millis
});

export const indices_recovery_verify_index = z.object({
    check_index_time: types_duration.optional(),
    check_index_time_in_millis: types_duration_value_unit_millis,
    total_time: types_duration.optional(),
    total_time_in_millis: types_duration_value_unit_millis
});

export const indices_recovery_shard_recovery = z.object({
    id: z.number(),
    index: indices_recovery_recovery_index_status,
    primary: z.boolean(),
    source: indices_recovery_recovery_origin,
    stage: z.string(),
    start: indices_recovery_recovery_start_status.optional(),
    start_time: types_date_time.optional(),
    start_time_in_millis: types_epoch_time_unit_millis,
    stop_time: types_date_time.optional(),
    stop_time_in_millis: types_epoch_time_unit_millis.optional(),
    target: indices_recovery_recovery_origin,
    total_time: types_duration.optional(),
    total_time_in_millis: types_duration_value_unit_millis,
    translog: indices_recovery_translog_status,
    type: z.string(),
    verify_index: indices_recovery_verify_index
});

export const indices_recovery_recovery_status = z.object({
    shards: z.array(indices_recovery_shard_recovery)
});

export const indices_reload_search_analyzers_reload_details = z.object({
    index: z.string(),
    reloaded_analyzers: z.array(z.string()),
    reloaded_node_ids: z.array(z.string())
});

export const indices_reload_search_analyzers_reload_result = z.object({
    reload_details: z.array(indices_reload_search_analyzers_reload_details),
    _shards: types_shard_statistics
});

export const indices_remove_block_remove_indices_block_status = z.object({
    name: types_index_name,
    unblocked: z.boolean().optional(),
    exception: types_error_cause.optional()
});

/**
 * Reduced (minimal) info ElasticsearchVersion
 */
export const types_elasticsearch_version_min_info = z.object({
    build_flavor: z.string(),
    minimum_index_compatibility_version: types_version_string,
    minimum_wire_compatibility_version: types_version_string,
    number: z.string()
}).describe('Reduced (minimal) info ElasticsearchVersion');

/**
 * Provides information about each cluster request relevant to doing a cross-cluster search.
 */
export const indices_resolve_cluster_resolve_cluster_info = z.object({
    connected: z.boolean().describe('Whether the remote cluster is connected to the local (querying) cluster.'),
    skip_unavailable: z.boolean().describe('The `skip_unavailable` setting for a remote cluster.'),
    matching_indices: z.boolean().describe('Whether the index expression provided in the request matches any indices, aliases or data streams\non the cluster.').optional(),
    error: z.string().describe('Provides error messages that are likely to occur if you do a search with this index expression\non the specified cluster (for example, lack of security privileges to query an index).').optional(),
    version: types_elasticsearch_version_min_info.optional()
}).describe('Provides information about each cluster request relevant to doing a cross-cluster search.');

export const indices_resolve_index_resolve_index_item = z.object({
    name: types_name,
    aliases: z.array(z.string()).optional(),
    attributes: z.array(z.string()),
    data_stream: types_data_stream_name.optional(),
    mode: indices_types_index_mode.optional()
});

export const indices_resolve_index_resolve_index_alias_item = z.object({
    name: types_name,
    indices: types_indices
});

export const indices_resolve_index_resolve_index_data_streams_item = z.object({
    name: types_data_stream_name,
    timestamp_field: types_field,
    backing_indices: types_indices
});

export const indices_rollover_rollover_conditions = z.object({
    min_age: types_duration.optional(),
    max_age: types_duration.optional(),
    max_age_millis: types_duration_value_unit_millis.optional(),
    min_docs: z.number().optional(),
    max_docs: z.number().optional(),
    max_size: types_byte_size.optional(),
    max_size_bytes: z.number().optional(),
    min_size: types_byte_size.optional(),
    min_size_bytes: z.number().optional(),
    max_primary_shard_size: types_byte_size.optional(),
    max_primary_shard_size_bytes: z.number().optional(),
    min_primary_shard_size: types_byte_size.optional(),
    min_primary_shard_size_bytes: z.number().optional(),
    max_primary_shard_docs: z.number().optional(),
    min_primary_shard_docs: z.number().optional()
});

export const indices_segments_shard_segment_routing = z.object({
    node: z.string(),
    primary: z.boolean(),
    state: z.string()
});

export const indices_segments_segment = z.object({
    attributes: z.record(z.string()),
    committed: z.boolean(),
    compound: z.boolean(),
    deleted_docs: z.number(),
    generation: z.number(),
    search: z.boolean(),
    size_in_bytes: z.number(),
    num_docs: z.number(),
    version: types_version_string
});

export const indices_segments_shards_segment = z.object({
    num_committed_segments: z.number(),
    routing: indices_segments_shard_segment_routing,
    num_search_segments: z.number(),
    segments: z.record(indices_segments_segment)
});

export const indices_segments_index_segment = z.object({
    shards: z.record(z.union([
        indices_segments_shards_segment,
        z.array(indices_segments_shards_segment)
    ]))
});

export const indices_shard_stores_shard_store_status = z.enum([
    'green',
    'yellow',
    'red',
    'all'
]);

export const indices_shard_stores_shard_store_allocation = z.enum([
    'primary',
    'replica',
    'unused'
]);

export const indices_shard_stores_shard_store_exception = z.object({
    reason: z.string(),
    type: z.string()
});

export const indices_shard_stores_shard_store = z.object({
    allocation: indices_shard_stores_shard_store_allocation,
    allocation_id: types_id.optional(),
    store_exception: indices_shard_stores_shard_store_exception.optional()
});

export const indices_shard_stores_shard_store_wrapper = z.object({
    stores: z.array(indices_shard_stores_shard_store)
});

export const indices_shard_stores_indices_shard_stores = z.object({
    shards: z.record(indices_shard_stores_shard_store_wrapper)
});

export const indices_simulate_template_overlapping = z.object({
    name: types_name,
    index_patterns: z.array(z.string())
});

export const types_common_stats_flag = z.enum([
    '_all',
    'store',
    'indexing',
    'get',
    'search',
    'merge',
    'flush',
    'refresh',
    'query_cache',
    'fielddata',
    'docs',
    'warmer',
    'completion',
    'segments',
    'translog',
    'request_cache',
    'recovery',
    'bulk',
    'shard_stats',
    'mappings',
    'dense_vector',
    'sparse_vector'
]);

export const types_common_stats_flags = z.union([
    types_common_stats_flag,
    z.array(types_common_stats_flag)
]);

export const types_flush_stats = z.object({
    periodic: z.number(),
    total: z.number(),
    total_time: types_duration.optional(),
    total_time_in_millis: types_duration_value_unit_millis
});

export const types_get_stats = z.object({
    current: z.number(),
    exists_time: types_duration.optional(),
    exists_time_in_millis: types_duration_value_unit_millis,
    exists_total: z.number(),
    missing_time: types_duration.optional(),
    missing_time_in_millis: types_duration_value_unit_millis,
    missing_total: z.number(),
    time: types_duration.optional(),
    time_in_millis: types_duration_value_unit_millis,
    total: z.number()
});

export const types_indexing_stats: z.AnyZodObject = z.object({
    index_current: z.number(),
    delete_current: z.number(),
    delete_time: types_duration.optional(),
    delete_time_in_millis: types_duration_value_unit_millis,
    delete_total: z.number(),
    is_throttled: z.boolean(),
    noop_update_total: z.number(),
    throttle_time: types_duration.optional(),
    throttle_time_in_millis: types_duration_value_unit_millis,
    index_time: types_duration.optional(),
    index_time_in_millis: types_duration_value_unit_millis,
    index_total: z.number(),
    index_failed: z.number(),
    types: z.record(z.lazy(() => types_indexing_stats)).optional(),
    write_load: z.number().optional(),
    recent_write_load: z.number().optional(),
    peak_write_load: z.number().optional()
});

export const types_merges_stats = z.object({
    current: z.number(),
    current_docs: z.number(),
    current_size: z.string().optional(),
    current_size_in_bytes: z.number(),
    total: z.number(),
    total_auto_throttle: z.string().optional(),
    total_auto_throttle_in_bytes: z.number(),
    total_docs: z.number(),
    total_size: z.string().optional(),
    total_size_in_bytes: z.number(),
    total_stopped_time: types_duration.optional(),
    total_stopped_time_in_millis: types_duration_value_unit_millis,
    total_throttled_time: types_duration.optional(),
    total_throttled_time_in_millis: types_duration_value_unit_millis,
    total_time: types_duration.optional(),
    total_time_in_millis: types_duration_value_unit_millis
});

export const types_recovery_stats = z.object({
    current_as_source: z.number(),
    current_as_target: z.number(),
    throttle_time: types_duration.optional(),
    throttle_time_in_millis: types_duration_value_unit_millis
});

export const types_refresh_stats = z.object({
    external_total: z.number(),
    external_total_time_in_millis: types_duration_value_unit_millis,
    listeners: z.number(),
    total: z.number(),
    total_time: types_duration.optional(),
    total_time_in_millis: types_duration_value_unit_millis
});

export const types_request_cache_stats = z.object({
    evictions: z.number(),
    hit_count: z.number(),
    memory_size: z.string().optional(),
    memory_size_in_bytes: z.number(),
    miss_count: z.number()
});

export const types_search_stats: z.AnyZodObject = z.object({
    fetch_current: z.number(),
    fetch_time: types_duration.optional(),
    fetch_time_in_millis: types_duration_value_unit_millis,
    fetch_total: z.number(),
    open_contexts: z.number().optional(),
    query_current: z.number(),
    query_time: types_duration.optional(),
    query_time_in_millis: types_duration_value_unit_millis,
    query_total: z.number(),
    scroll_current: z.number(),
    scroll_time: types_duration.optional(),
    scroll_time_in_millis: types_duration_value_unit_millis,
    scroll_total: z.number(),
    suggest_current: z.number(),
    suggest_time: types_duration.optional(),
    suggest_time_in_millis: types_duration_value_unit_millis,
    suggest_total: z.number(),
    recent_search_load: z.number().optional(),
    groups: z.record(z.lazy(() => types_search_stats)).optional()
});

export const types_translog_stats = z.object({
    earliest_last_modified_age: z.number(),
    operations: z.number(),
    size: z.string().optional(),
    size_in_bytes: z.number(),
    uncommitted_operations: z.number(),
    uncommitted_size: z.string().optional(),
    uncommitted_size_in_bytes: z.number()
});

export const types_warmer_stats = z.object({
    current: z.number(),
    total: z.number(),
    total_time: types_duration.optional(),
    total_time_in_millis: types_duration_value_unit_millis
});

export const types_bulk_stats = z.object({
    total_operations: z.number(),
    total_time: types_duration.optional(),
    total_time_in_millis: types_duration_value_unit_millis,
    total_size: types_byte_size.optional(),
    total_size_in_bytes: z.number(),
    avg_time: types_duration.optional(),
    avg_time_in_millis: types_duration_value_unit_millis,
    avg_size: types_byte_size.optional(),
    avg_size_in_bytes: z.number()
});

export const indices_stats_shards_total_stats = z.object({
    total_count: z.number()
});

export const indices_stats_shard_commit = z.object({
    generation: z.number(),
    id: types_id,
    num_docs: z.number(),
    user_data: z.record(z.string())
});

export const indices_stats_mapping_stats = z.object({
    total_count: z.number(),
    total_estimated_overhead: types_byte_size.optional(),
    total_estimated_overhead_in_bytes: z.number()
});

export const indices_stats_shard_path = z.object({
    data_path: z.string(),
    is_custom_data_path: z.boolean(),
    state_path: z.string()
});

export const indices_stats_shard_query_cache = z.object({
    cache_count: z.number(),
    cache_size: z.number(),
    evictions: z.number(),
    hit_count: z.number(),
    memory_size_in_bytes: z.number(),
    miss_count: z.number(),
    total_count: z.number()
});

export const indices_stats_shard_lease = z.object({
    id: types_id,
    retaining_seq_no: types_sequence_number,
    timestamp: z.number(),
    source: z.string()
});

export const indices_stats_shard_retention_leases = z.object({
    primary_term: z.number(),
    version: types_version_number,
    leases: z.array(indices_stats_shard_lease)
});

export const indices_stats_shard_routing_state = z.enum([
    'UNASSIGNED',
    'INITIALIZING',
    'STARTED',
    'RELOCATING'
]);

export const indices_stats_shard_routing = z.object({
    node: z.string(),
    primary: z.boolean(),
    relocating_node: z.union([
        z.string(),
        z.null()
    ]).optional(),
    state: indices_stats_shard_routing_state
});

export const indices_stats_shard_sequence_number = z.object({
    global_checkpoint: z.number(),
    local_checkpoint: z.number(),
    max_seq_no: types_sequence_number
});

export const indices_stats_index_metadata_state = z.enum(['open', 'close']);

export const indices_update_aliases_remove_action = z.object({
    alias: types_index_alias.optional(),
    aliases: z.union([
        types_index_alias,
        z.array(types_index_alias)
    ]).optional(),
    index: types_index_name.optional(),
    indices: types_indices.optional(),
    must_exist: z.boolean().describe('If `true`, the alias must exist to perform the action.').optional().default(false)
});

export const indices_update_aliases_remove_index_action = z.object({
    index: types_index_name.optional(),
    indices: types_indices.optional(),
    must_exist: z.boolean().describe('If `true`, the alias must exist to perform the action.').optional().default(false)
});

export const indices_validate_query_indices_validation_explanation = z.object({
    error: z.string().optional(),
    explanation: z.string().optional(),
    index: types_index_name,
    valid: z.boolean()
});

/**
 * An object style representation of a single portion of a conversation.
 */
export const inference_types_content_object = z.object({
    text: z.string().describe('The text content.'),
    type: z.string().describe('The type of content.')
}).describe('An object style representation of a single portion of a conversation.');

export const inference_types_message_content = z.union([
    z.string(),
    z.array(inference_types_content_object)
]);

/**
 * The function that the model called.
 */
export const inference_types_tool_call_function = z.object({
    arguments: z.string().describe('The arguments to call the function with in JSON format.'),
    name: z.string().describe('The name of the function to call.')
}).describe('The function that the model called.');

/**
 * A tool call generated by the model.
 */
export const inference_types_tool_call = z.object({
    id: types_id,
    function: inference_types_tool_call_function,
    type: z.string().describe('The type of the tool call.')
}).describe('A tool call generated by the model.');

/**
 * An object representing part of the conversation.
 */
export const inference_types_message = z.object({
    content: inference_types_message_content.optional(),
    role: z.string().describe('The role of the message author. Valid values are `user`, `assistant`, `system`, and `tool`.'),
    tool_call_id: types_id.optional(),
    tool_calls: z.array(inference_types_tool_call).describe('Only for `assistant` role messages. The tool calls generated by the model. If it\'s specified, the `content` field is optional.\nExample:\n```\n{\n  "tool_calls": [\n      {\n          "id": "call_KcAjWtAww20AihPHphUh46Gd",\n          "type": "function",\n          "function": {\n              "name": "get_current_weather",\n              "arguments": "{\\"location\\":\\"Boston, MA\\"}"\n          }\n      }\n  ]\n}\n```').optional()
}).describe('An object representing part of the conversation.');

/**
 * The tool choice function.
 */
export const inference_types_completion_tool_choice_function = z.object({
    name: z.string().describe('The name of the function to call.')
}).describe('The tool choice function.');

/**
 * Controls which tool is called by the model.
 */
export const inference_types_completion_tool_choice = z.object({
    type: z.string().describe('The type of the tool.'),
    function: inference_types_completion_tool_choice_function
}).describe('Controls which tool is called by the model.');

export const inference_types_completion_tool_type = z.union([
    z.string(),
    inference_types_completion_tool_choice
]);

/**
 * The completion tool function definition.
 */
export const inference_types_completion_tool_function = z.object({
    description: z.string().describe('A description of what the function does.\nThis is used by the model to choose when and how to call the function.').optional(),
    name: z.string().describe('The name of the function.'),
    parameters: z.record(z.unknown()).describe('The parameters the functional accepts. This should be formatted as a JSON object.').optional(),
    strict: z.boolean().describe('Whether to enable schema adherence when generating the function call.').optional()
}).describe('The completion tool function definition.');

/**
 * A list of tools that the model can call.
 */
export const inference_types_completion_tool = z.object({
    type: z.string().describe('The type of tool.'),
    function: inference_types_completion_tool_function
}).describe('A list of tools that the model can call.');

export const inference_types_request_chat_completion = z.object({
    messages: z.array(inference_types_message).describe('A list of objects representing the conversation.\nRequests should generally only add new messages from the user (role `user`).\nThe other message roles (`assistant`, `system`, or `tool`) should generally only be copied from the response to a previous completion request, such that the messages array is built up throughout a conversation.'),
    model: z.string().describe('The ID of the model to use. By default, the model ID is set to the value included when creating the inference endpoint.').optional(),
    max_completion_tokens: z.number().describe('The upper bound limit for the number of tokens that can be generated for a completion request.').optional(),
    stop: z.array(z.string()).describe('A sequence of strings to control when the model should stop generating additional tokens.').optional(),
    temperature: z.number().describe('The sampling temperature to use.').optional(),
    tool_choice: inference_types_completion_tool_type.optional(),
    tools: z.array(inference_types_completion_tool).describe('A list of tools that the model can call.\nExample:\n```\n{\n  "tools": [\n      {\n          "type": "function",\n          "function": {\n              "name": "get_price_of_item",\n              "description": "Get the current price of an item",\n              "parameters": {\n                  "type": "object",\n                  "properties": {\n                      "item": {\n                          "id": "12345"\n                      },\n                      "unit": {\n                          "type": "currency"\n                      }\n                  }\n              }\n          }\n      }\n  ]\n}\n```').optional(),
    top_p: z.number().describe('Nucleus sampling, an alternative to sampling with temperature.').optional()
});

export const types_stream_result = z.record(z.unknown());

export const inference_types_task_settings = z.record(z.unknown());

/**
 * The completion result object
 */
export const inference_types_completion_result = z.object({
    result: z.string()
}).describe('The completion result object');

/**
 * Defines the completion result.
 */
export const inference_types_completion_inference_result = z.object({
    completion: z.array(inference_types_completion_result)
}).describe('Defines the completion result.');

export const inference_types_task_type = z.enum([
    'sparse_embedding',
    'text_embedding',
    'rerank',
    'completion',
    'chat_completion'
]);

/**
 * Acknowledged response. For dry_run, contains the list of pipelines which reference the inference endpoint
 */
export const inference_types_delete_inference_endpoint_result = types_acknowledged_response_base.and(z.object({
    pipelines: z.array(z.string())
}));

/**
 * Chunking configuration object
 */
export const inference_types_inference_chunking_settings = z.object({
    max_chunk_size: z.number().describe('The maximum size of a chunk in words.\nThis value cannot be lower than `20` (for `sentence` strategy) or `10` (for `word` strategy).\nThis value should not exceed the window size for the associated model.').optional().default(250),
    overlap: z.number().describe('The number of overlapping words for chunks.\nIt is applicable only to a `word` chunking strategy.\nThis value cannot be higher than half the `max_chunk_size` value.').optional().default(100),
    sentence_overlap: z.number().describe('The number of overlapping sentences for chunks.\nIt is applicable only for a `sentence` chunking strategy.\nIt can be either `1` or `0`.').optional().default(1),
    separator_group: z.string().describe('Only applicable to the `recursive` strategy and required when using it.\n\nSets a predefined list of separators in the saved chunking settings based on the selected text type.\nValues can be `markdown` or `plaintext`.\n\nUsing this parameter is an alternative to manually specifying a custom `separators` list.').optional(),
    separators: z.array(z.string()).describe('Only applicable to the `recursive` strategy and required when using it.\n\nA list of strings used as possible split points when chunking text.\n\nEach string can be a plain string or a regular expression (regex) pattern.\nThe system tries each separator in order to split the text, starting from the first item in the list.\n\nAfter splitting, it attempts to recombine smaller pieces into larger chunks that stay within\nthe `max_chunk_size` limit, to reduce the total number of chunks generated.').optional(),
    strategy: z.string().describe('The chunking strategy: `sentence`, `word`, `none` or `recursive`.\n\n * If `strategy` is set to `recursive`, you must also specify:\n\n- `max_chunk_size`\n- either `separators` or`separator_group`\n\nLearn more about different chunking strategies in the linked documentation.').optional().default('sentence')
}).describe('Chunking configuration object');

export const inference_types_service_settings = z.record(z.unknown());

/**
 * Configuration options when storing the inference endpoint
 */
export const inference_types_inference_endpoint = z.object({
    chunking_settings: inference_types_inference_chunking_settings.optional(),
    service: z.string().describe('The service type'),
    service_settings: inference_types_service_settings,
    task_settings: inference_types_task_settings.optional()
}).describe('Configuration options when storing the inference endpoint');

/**
 * Represents an inference endpoint as returned by the GET API
 */
export const inference_types_inference_endpoint_info = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type
}));

/**
 * Text Embedding results containing bytes are represented as Dense
 * Vectors of bytes.
 */
export const inference_types_dense_byte_vector = z.array(types_byte).describe('Text Embedding results containing bytes are represented as Dense\nVectors of bytes.');

/**
 * The text embedding result object for byte representation
 */
export const inference_types_text_embedding_byte_result = z.object({
    embedding: inference_types_dense_byte_vector
}).describe('The text embedding result object for byte representation');

/**
 * Text Embedding results are represented as Dense Vectors
 * of floats.
 */
export const inference_types_dense_vector = z.array(z.number()).describe('Text Embedding results are represented as Dense Vectors\nof floats.');

/**
 * The text embedding result object
 */
export const inference_types_text_embedding_result = z.object({
    embedding: inference_types_dense_vector
}).describe('The text embedding result object');

/**
 * Sparse Embedding tokens are represented as a dictionary
 * of string to double.
 */
export const inference_types_sparse_vector = z.record(z.number()).describe('Sparse Embedding tokens are represented as a dictionary\nof string to double.');

export const inference_types_sparse_embedding_result = z.object({
    embedding: inference_types_sparse_vector
});

/**
 * The rerank result object representing a single ranked document
 * id: the original index of the document in the request
 * relevance_score: the relevance_score of the document relative to the query
 * text: Optional, the text of the document, if requested
 */
export const inference_types_ranked_document = z.object({
    index: z.number(),
    relevance_score: z.number(),
    text: z.string().optional()
}).describe('The rerank result object representing a single ranked document\nid: the original index of the document in the request\nrelevance_score: the relevance_score of the document relative to the query\ntext: Optional, the text of the document, if requested');

/**
 * InferenceResult is an aggregation of mutually exclusive variants
 */
export const inference_types_inference_result = z.object({
    text_embedding_bytes: z.array(inference_types_text_embedding_byte_result).optional(),
    text_embedding_bits: z.array(inference_types_text_embedding_byte_result).optional(),
    text_embedding: z.array(inference_types_text_embedding_result).optional(),
    sparse_embedding: z.array(inference_types_sparse_embedding_result).optional(),
    completion: z.array(inference_types_completion_result).optional(),
    rerank: z.array(inference_types_ranked_document).optional()
}).describe('InferenceResult is an aggregation of mutually exclusive variants');

export const inference_types_ai21_task_type = z.enum(['completion', 'chat_completion']);

export const inference_types_ai21_service_type = z.enum(['ai21']);

/**
 * This setting helps to minimize the number of rate limit errors returned from the service.
 */
export const inference_types_rate_limit_setting = z.object({
    requests_per_minute: z.number().describe('The number of requests allowed per minute.\nBy default, the number of requests allowed per minute is set by each service as follows:\n\n* `alibabacloud-ai-search` service: `1000`\n* `anthropic` service: `50`\n* `azureaistudio` service: `240`\n* `azureopenai` service and task type `text_embedding`: `1440`\n* `azureopenai` service and task type `completion`: `120`\n* `cohere` service: `10000`\n* `contextualai` service: `1000`\n* `elastic` service and task type `chat_completion`: `240`\n* `googleaistudio` service: `360`\n* `googlevertexai` service: `30000`\n* `hugging_face` service: `3000`\n* `jinaai` service: `2000`\n* `llama` service: `3000`\n* `mistral` service: `240`\n* `openai` service and task type `text_embedding`: `3000`\n* `openai` service and task type `completion`: `500`\n* `voyageai` service: `2000`\n* `watsonxai` service: `120`').optional()
}).describe('This setting helps to minimize the number of rate limit errors returned from the service.');

export const inference_types_ai21_service_settings = z.object({
    model_id: z.string().describe('The name of the model to use for the inference task.\nRefer to the AI21 models documentation for the list of supported models and versions.\nService has been tested and confirmed to be working for `completion` and `chat_completion` tasks with the following models:\n* `jamba-mini`\n* `jamba-large`'),
    api_key: z.string().describe('A valid API key for accessing AI21 API.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.').optional(),
    rate_limit: inference_types_rate_limit_setting.optional()
});

export const inference_types_task_type_ai21 = z.enum(['completion', 'chat_completion']);

export const inference_types_inference_endpoint_info_ai21 = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_ai21
}));

export const inference_types_alibaba_cloud_task_type = z.enum([
    'completion',
    'rerank',
    'sparse_embedding',
    'text_embedding'
]);

export const inference_types_alibaba_cloud_service_type = z.enum(['alibabacloud-ai-search']);

export const inference_types_alibaba_cloud_service_settings = z.object({
    api_key: z.string().describe('A valid API key for the AlibabaCloud AI Search API.'),
    host: z.string().describe('The name of the host address used for the inference task.\nYou can find the host address in the API keys section of the documentation.'),
    rate_limit: inference_types_rate_limit_setting.optional(),
    service_id: z.string().describe('The name of the model service to use for the inference task.\nThe following service IDs are available for the `completion` task:\n\n* `ops-qwen-turbo`\n* `qwen-turbo`\n* `qwen-plus`\n* `qwen-max  qwen-max-longcontext`\n\nThe following service ID is available for the `rerank` task:\n\n* `ops-bge-reranker-larger`\n\nThe following service ID is available for the `sparse_embedding` task:\n\n* `ops-text-sparse-embedding-001`\n\nThe following service IDs are available for the `text_embedding` task:\n\n`ops-text-embedding-001`\n`ops-text-embedding-zh-001`\n`ops-text-embedding-en-001`\n`ops-text-embedding-002`'),
    workspace: z.string().describe('The name of the workspace used for the inference task.')
});

export const inference_types_alibaba_cloud_task_settings = z.object({
    input_type: z.string().describe('For a `sparse_embedding` or `text_embedding` task, specify the type of input passed to the model.\nValid values are:\n\n* `ingest` for storing document embeddings in a vector database.\n* `search` for storing embeddings of search queries run against a vector database to find relevant documents.').optional(),
    return_token: z.boolean().describe('For a `sparse_embedding` task, it affects whether the token name will be returned in the response.\nIt defaults to `false`, which means only the token ID will be returned in the response.').optional()
});

export const inference_types_task_type_alibaba_cloud_ai = z.enum([
    'text_embedding',
    'rerank',
    'completion',
    'sparse_embedding'
]);

export const inference_types_inference_endpoint_info_alibaba_cloud_ai = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_alibaba_cloud_ai
}));

export const inference_types_amazon_bedrock_task_type = z.enum(['completion', 'text_embedding']);

export const inference_types_amazon_bedrock_service_type = z.enum(['amazonbedrock']);

export const inference_types_amazon_bedrock_service_settings = z.object({
    access_key: z.string().describe('A valid AWS access key that has permissions to use Amazon Bedrock and access to models for inference requests.'),
    model: z.string().describe('The base model ID or an ARN to a custom model based on a foundational model.\nThe base model IDs can be found in the Amazon Bedrock documentation.\nNote that the model ID must be available for the provider chosen and your IAM user must have access to the model.'),
    provider: z.string().describe('The model provider for your deployment.\nNote that some providers may support only certain task types.\nSupported providers include:\n\n* `amazontitan` - available for `text_embedding` and `completion` task types\n* `anthropic` - available for `completion` task type only\n* `ai21labs` - available for `completion` task type only\n* `cohere` - available for `text_embedding` and `completion` task types\n* `meta` - available for `completion` task type only\n* `mistral` - available for `completion` task type only').optional(),
    region: z.string().describe('The region that your model or ARN is deployed in.\nThe list of available regions per model can be found in the Amazon Bedrock documentation.'),
    rate_limit: inference_types_rate_limit_setting.optional(),
    secret_key: z.string().describe('A valid AWS secret key that is paired with the `access_key`.\nFor informationg about creating and managing access and secret keys, refer to the AWS documentation.')
});

export const inference_types_amazon_bedrock_task_settings = z.object({
    max_new_tokens: z.number().describe('For a `completion` task, it sets the maximum number for the output tokens to be generated.').optional().default(64),
    temperature: z.number().describe('For a `completion` task, it is a number between 0.0 and 1.0 that controls the apparent creativity of the results.\nAt temperature 0.0 the model is most deterministic, at temperature 1.0 most random.\nIt should not be used if `top_p` or `top_k` is specified.').optional(),
    top_k: z.number().describe('For a `completion` task, it limits samples to the top-K most likely words, balancing coherence and variability.\nIt is only available for anthropic, cohere, and mistral providers.\nIt is an alternative to `temperature`; it should not be used if `temperature` is specified.').optional(),
    top_p: z.number().describe('For a `completion` task, it is a number in the range of 0.0 to 1.0, to eliminate low-probability tokens.\nTop-p uses nucleus sampling to select top tokens whose sum of likelihoods does not exceed a certain value, ensuring both variety and coherence.\nIt is an alternative to `temperature`; it should not be used if `temperature` is specified.').optional()
});

export const inference_types_task_type_amazon_bedrock = z.enum(['text_embedding', 'completion']);

export const inference_types_inference_endpoint_info_amazon_bedrock = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_amazon_bedrock
}));

export const inference_types_task_type_amazon_sage_maker = z.enum([
    'text_embedding',
    'completion',
    'chat_completion',
    'sparse_embedding',
    'rerank'
]);

export const inference_types_amazon_sage_maker_service_type = z.enum(['amazon_sagemaker']);

export const inference_types_amazon_sage_maker_api = z.enum(['openai', 'elastic']);

export const inference_types_amazon_sage_maker_service_settings = z.object({
    access_key: z.string().describe('A valid AWS access key that has permissions to use Amazon SageMaker and access to models for invoking requests.'),
    endpoint_name: z.string().describe('The name of the SageMaker endpoint.'),
    api: inference_types_amazon_sage_maker_api,
    region: z.string().describe('The region that your endpoint or Amazon Resource Name (ARN) is deployed in.\nThe list of available regions per model can be found in the Amazon SageMaker documentation.'),
    secret_key: z.string().describe('A valid AWS secret key that is paired with the `access_key`.\nFor information about creating and managing access and secret keys, refer to the AWS documentation.'),
    target_model: z.string().describe('The model ID when calling a multi-model endpoint.').optional(),
    target_container_hostname: z.string().describe('The container to directly invoke when calling a multi-container endpoint.').optional(),
    inference_component_name: z.string().describe('The inference component to directly invoke when calling a multi-component endpoint.').optional(),
    batch_size: z.number().describe('The maximum number of inputs in each batch. This value is used by inference ingestion pipelines\nwhen processing semantic values. It correlates to the number of times the SageMaker endpoint is\ninvoked (one per batch of input).').optional().default(256),
    dimensions: z.number().describe('The number of dimensions returned by the text embedding models. If this value is not provided, then\nit is guessed by making invoking the endpoint for the `text_embedding` task.').optional()
});

export const inference_types_amazon_sage_maker_task_settings = z.object({
    custom_attributes: z.string().describe('The AWS custom attributes passed verbatim through to the model running in the SageMaker Endpoint.\nValues will be returned in the `X-elastic-sagemaker-custom-attributes` header.').optional(),
    enable_explanations: z.string().describe('The optional JMESPath expression used to override the EnableExplanations provided during endpoint creation.').optional(),
    inference_id: z.string().describe('The capture data ID when enabled in the endpoint.').optional(),
    session_id: z.string().describe('The stateful session identifier for a new or existing session.\nNew sessions will be returned in the `X-elastic-sagemaker-new-session-id` header.\nClosed sessions will be returned in the `X-elastic-sagemaker-closed-session-id` header.').optional(),
    target_variant: z.string().describe('Specifies the variant when running with multi-variant Endpoints.').optional()
});

export const inference_types_inference_endpoint_info_amazon_sage_maker = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_amazon_sage_maker
}));

export const inference_types_anthropic_task_type = z.enum(['completion']);

export const inference_types_anthropic_service_type = z.enum(['anthropic']);

export const inference_types_anthropic_service_settings = z.object({
    api_key: z.string().describe('A valid API key for the Anthropic API.'),
    model_id: z.string().describe('The name of the model to use for the inference task.\nRefer to the Anthropic documentation for the list of supported models.'),
    rate_limit: inference_types_rate_limit_setting.optional()
});

export const inference_types_anthropic_task_settings = z.object({
    max_tokens: z.number().describe('For a `completion` task, it is the maximum number of tokens to generate before stopping.'),
    temperature: z.number().describe('For a `completion` task, it is the amount of randomness injected into the response.\nFor more details about the supported range, refer to Anthropic documentation.').optional(),
    top_k: z.number().describe('For a `completion` task, it specifies to only sample from the top K options for each subsequent token.\nIt is recommended for advanced use cases only.\nYou usually only need to use `temperature`.').optional(),
    top_p: z.number().describe('For a `completion` task, it specifies to use Anthropic\'s nucleus sampling.\nIn nucleus sampling, Anthropic computes the cumulative distribution over all the options for each subsequent token in decreasing probability order and cuts it off once it reaches the specified probability.\nYou should either alter `temperature` or `top_p`, but not both.\nIt is recommended for advanced use cases only.\nYou usually only need to use `temperature`.').optional()
});

export const inference_types_task_type_anthropic = z.enum(['completion']);

export const inference_types_inference_endpoint_info_anthropic = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_anthropic
}));

export const inference_types_azure_ai_studio_task_type = z.enum([
    'completion',
    'rerank',
    'text_embedding'
]);

export const inference_types_azure_ai_studio_service_type = z.enum(['azureaistudio']);

export const inference_types_azure_ai_studio_service_settings = z.object({
    api_key: z.string().describe('A valid API key of your Azure AI Studio model deployment.\nThis key can be found on the overview page for your deployment in the management section of your Azure AI Studio account.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.'),
    endpoint_type: z.string().describe('The type of endpoint that is available for deployment through Azure AI Studio: `token` or `realtime`.\nThe `token` endpoint type is for "pay as you go" endpoints that are billed per token.\nThe `realtime` endpoint type is for "real-time" endpoints that are billed per hour of usage.'),
    target: z.string().describe('The target URL of your Azure AI Studio model deployment.\nThis can be found on the overview page for your deployment in the management section of your Azure AI Studio account.'),
    provider: z.string().describe('The model provider for your deployment.\nNote that some providers may support only certain task types.\nSupported providers include:\n\n* `cohere` - available for `text_embedding` and `completion` task types\n* `databricks` - available for `completion` task type only\n* `meta` - available for `completion` task type only\n* `microsoft_phi` - available for `completion` task type only\n* `mistral` - available for `completion` task type only\n* `openai` - available for `text_embedding` and `completion` task types'),
    rate_limit: inference_types_rate_limit_setting.optional()
});

export const inference_types_azure_ai_studio_task_settings = z.object({
    do_sample: z.number().describe('For a `completion` task, instruct the inference process to perform sampling.\nIt has no effect unless `temperature` or `top_p` is specified.').optional(),
    max_new_tokens: z.number().describe('For a `completion` task, provide a hint for the maximum number of output tokens to be generated.').optional().default(64),
    temperature: z.number().describe('For a `completion` task, control the apparent creativity of generated completions with a sampling temperature.\nIt must be a number in the range of 0.0 to 2.0.\nIt should not be used if `top_p` is specified.').optional(),
    top_p: z.number().describe('For a `completion` task, make the model consider the results of the tokens with nucleus sampling probability.\nIt is an alternative value to `temperature` and must be a number in the range of 0.0 to 2.0.\nIt should not be used if `temperature` is specified.').optional(),
    user: z.string().describe('For a `text_embedding` task, specify the user issuing the request.\nThis information can be used for abuse detection.').optional(),
    return_documents: z.boolean().describe('For a `rerank` task, return doc text within the results.').optional(),
    top_n: z.number().describe('For a `rerank` task, the number of most relevant documents to return.\nIt defaults to the number of the documents.').optional()
});

export const inference_types_task_type_azure_ai_studio = z.enum([
    'text_embedding',
    'completion',
    'rerank'
]);

export const inference_types_inference_endpoint_info_azure_ai_studio = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_azure_ai_studio
}));

export const inference_types_azure_open_ai_task_type = z.enum(['completion', 'text_embedding']);

export const inference_types_azure_open_ai_service_type = z.enum(['azureopenai']);

export const inference_types_azure_open_ai_service_settings = z.object({
    api_key: z.string().describe('A valid API key for your Azure OpenAI account.\nYou must specify either `api_key` or `entra_id`.\nIf you do not provide either or you provide both, you will receive an error when you try to create your model.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.').optional(),
    api_version: z.string().describe('The Azure API version ID to use.\nIt is recommended to use the latest supported non-preview version.'),
    deployment_id: z.string().describe('The deployment name of your deployed models.\nYour Azure OpenAI deployments can be found though the Azure OpenAI Studio portal that is linked to your subscription.'),
    entra_id: z.string().describe('A valid Microsoft Entra token.\nYou must specify either `api_key` or `entra_id`.\nIf you do not provide either or you provide both, you will receive an error when you try to create your model.').optional(),
    rate_limit: inference_types_rate_limit_setting.optional(),
    resource_name: z.string().describe('The name of your Azure OpenAI resource.\nYou can find this from the list of resources in the Azure Portal for your subscription.')
});

export const inference_types_azure_open_ai_task_settings = z.object({
    user: z.string().describe('For a `completion` or `text_embedding` task, specify the user issuing the request.\nThis information can be used for abuse detection.').optional()
});

export const inference_types_task_type_azure_open_ai = z.enum(['text_embedding', 'completion']);

export const inference_types_inference_endpoint_info_azure_open_ai = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_azure_open_ai
}));

export const inference_types_cohere_task_type = z.enum([
    'completion',
    'rerank',
    'text_embedding'
]);

export const inference_types_cohere_service_type = z.enum(['cohere']);

export const inference_types_cohere_embedding_type = z.enum([
    'binary',
    'bit',
    'byte',
    'float',
    'int8'
]);

export const inference_types_cohere_similarity_type = z.enum([
    'cosine',
    'dot_product',
    'l2_norm'
]);

export const inference_types_cohere_service_settings = z.object({
    api_key: z.string().describe('A valid API key for your Cohere account.\nYou can find or create your Cohere API keys on the Cohere API key settings page.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.'),
    embedding_type: inference_types_cohere_embedding_type.optional(),
    model_id: z.string().describe('For a `completion`, `rerank`, or `text_embedding` task, the name of the model to use for the inference task.\n\n* For the available `completion` models, refer to the [Cohere command docs](https://docs.cohere.com/docs/models#command).\n* For the available `rerank` models, refer to the [Cohere rerank docs](https://docs.cohere.com/reference/rerank-1).\n* For the available `text_embedding` models, refer to [Cohere embed docs](https://docs.cohere.com/reference/embed).'),
    rate_limit: inference_types_rate_limit_setting.optional(),
    similarity: inference_types_cohere_similarity_type.optional()
});

export const inference_types_cohere_input_type = z.enum([
    'classification',
    'clustering',
    'ingest',
    'search'
]);

export const inference_types_cohere_truncate_type = z.enum([
    'END',
    'NONE',
    'START'
]);

export const inference_types_cohere_task_settings = z.object({
    input_type: inference_types_cohere_input_type,
    return_documents: z.boolean().describe('For a `rerank` task, return doc text within the results.').optional(),
    top_n: z.number().describe('For a `rerank` task, the number of most relevant documents to return.\nIt defaults to the number of the documents.\nIf this inference endpoint is used in a `text_similarity_reranker` retriever query and `top_n` is set, it must be greater than or equal to `rank_window_size` in the query.').optional(),
    truncate: inference_types_cohere_truncate_type.optional()
});

export const inference_types_task_type_cohere = z.enum([
    'text_embedding',
    'rerank',
    'completion'
]);

export const inference_types_inference_endpoint_info_cohere = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_cohere
}));

export const inference_types_task_type_contextual_ai = z.enum(['rerank']);

export const inference_types_contextual_ai_service_type = z.enum(['contextualai']);

export const inference_types_contextual_ai_service_settings = z.object({
    api_key: z.string().describe('A valid API key for your Contexutual AI account.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.'),
    model_id: z.string().describe('The name of the model to use for the inference task.\nRefer to the Contextual AI documentation for the list of available rerank models.'),
    rate_limit: inference_types_rate_limit_setting.optional()
});

export const inference_types_contextual_ai_task_settings = z.object({
    instruction: z.string().describe('Instructions for the reranking model. Refer to <https://docs.contextual.ai/api-reference/rerank/rerank#body-instruction>\nOnly for the `rerank` task type.').optional(),
    return_documents: z.boolean().describe('Whether to return the source documents in the response.\nOnly for the `rerank` task type.').optional().default(false),
    top_k: z.number().describe('The number of most relevant documents to return.\nIf not specified, the reranking results of all documents will be returned.\nOnly for the `rerank` task type.').optional()
});

export const inference_types_inference_endpoint_info_contextual_ai = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_contextual_ai
}));

export const inference_types_custom_task_type = z.enum([
    'text_embedding',
    'sparse_embedding',
    'rerank',
    'completion'
]);

export const inference_types_custom_service_type = z.enum(['custom']);

export const inference_types_custom_request_params = z.object({
    content: z.string().describe('The body structure of the request. It requires passing in the string-escaped result of the JSON format HTTP request body.\nFor example:\n```\n"request": "{\\"input\\":${input}}"\n```\n> info\n> The content string needs to be a single line except when using the Kibana console.')
});

export const inference_types_custom_response_params = z.object({
    json_parser: z.record(z.unknown()).describe('Specifies the JSON parser that is used to parse the response from the custom service.\nDifferent task types require different json_parser parameters.\nFor example:\n```\n# text_embedding\n# For a response like this:\n\n{\n "object": "list",\n "data": [\n     {\n       "object": "embedding",\n       "index": 0,\n       "embedding": [\n           0.014539449,\n           -0.015288644\n       ]\n     }\n ],\n "model": "text-embedding-ada-002-v2",\n "usage": {\n     "prompt_tokens": 8,\n     "total_tokens": 8\n }\n}\n\n# the json_parser definition should look like this:\n\n"response":{\n  "json_parser":{\n    "text_embeddings":"$.data[*].embedding[*]"\n  }\n}\n\n# Elasticsearch supports the following embedding types:\n* float\n* byte\n* bit (or binary)\n\nTo specify the embedding type for the response, the `embedding_type`\nfield should be added in the `json_parser` object. Here\'s an example:\n"response":{\n  "json_parser":{\n    "text_embeddings":"$.data[*].embedding[*]",\n    "embedding_type":"bit"\n  }\n}\n\nIf `embedding_type` is not specified, it defaults to `float`.\n\n# sparse_embedding\n# For a response like this:\n\n{\n  "request_id": "75C50B5B-E79E-4930-****-F48DBB392231",\n  "latency": 22,\n  "usage": {\n     "token_count": 11\n  },\n  "result": {\n     "sparse_embeddings": [\n        {\n          "index": 0,\n          "embedding": [\n            {\n              "token_id": 6,\n              "weight": 0.101\n            },\n            {\n              "token_id": 163040,\n              "weight": 0.28417\n            }\n          ]\n        }\n     ]\n  }\n}\n\n# the json_parser definition should look like this:\n\n"response":{\n  "json_parser":{\n    "token_path":"$.result.sparse_embeddings[*].embedding[*].token_id",\n    "weight_path":"$.result.sparse_embeddings[*].embedding[*].weight"\n  }\n}\n\n# rerank\n# For a response like this:\n\n{\n  "results": [\n    {\n      "index": 3,\n      "relevance_score": 0.999071,\n      "document": "abc"\n    },\n    {\n      "index": 4,\n      "relevance_score": 0.7867867,\n      "document": "123"\n    },\n    {\n      "index": 0,\n      "relevance_score": 0.32713068,\n      "document": "super"\n    }\n  ],\n}\n\n# the json_parser definition should look like this:\n\n"response":{\n  "json_parser":{\n    "reranked_index":"$.result.scores[*].index",    // optional\n    "relevance_score":"$.result.scores[*].score",\n    "document_text":"xxx"    // optional\n  }\n}\n\n# completion\n# For a response like this:\n\n{\n "id": "chatcmpl-B9MBs8CjcvOU2jLn4n570S5qMJKcT",\n "object": "chat.completion",\n "created": 1741569952,\n "model": "gpt-4.1-2025-04-14",\n "choices": [\n   {\n    "index": 0,\n    "message": {\n      "role": "assistant",\n      "content": "Hello! How can I assist you today?",\n      "refusal": null,\n      "annotations": []\n    },\n    "logprobs": null,\n    "finish_reason": "stop"\n  }\n ]\n}\n\n# the json_parser definition should look like this:\n\n"response":{\n  "json_parser":{\n    "completion_result":"$.choices[*].message.content"\n  }\n}')
});

export const inference_types_custom_service_settings = z.object({
    batch_size: z.number().describe('Specifies the batch size used for the semantic_text field. If the field is not provided, the default is 10.\nThe batch size is the maximum number of inputs in a single request to the upstream service.\nThe chunk within the batch are controlled by the selected chunking strategy for the semantic_text field.').optional(),
    headers: z.record(z.unknown()).describe('Specifies the HTTP header parameters  such as `Authentication` or `Content-Type`  that are required to access the custom service.\nFor example:\n```\n"headers":{\n  "Authorization": "Bearer ${api_key}",\n  "Content-Type": "application/json;charset=utf-8"\n}\n```').optional(),
    input_type: z.record(z.unknown()).describe('Specifies the input type translation values that are used to replace the `${input_type}` template in the request body.\nFor example:\n```\n"input_type": {\n  "translation": {\n    "ingest": "do_ingest",\n    "search": "do_search"\n  },\n  "default": "a_default"\n},\n```\nIf the subsequent inference requests come from a search context, the `search` key will be used and the template will be replaced with `do_search`.\nIf it comes from the ingest context `do_ingest` is used. If it\'s a different context that is not specified, the default value will be used. If no default is specified an empty string is used.\n`translation` can be:\n* `classification`\n* `clustering`\n* `ingest`\n* `search`').optional(),
    query_parameters: z.record(z.unknown()).describe('Specifies the query parameters as a list of tuples. The arrays inside the `query_parameters` must have two items, a key and a value.\nFor example:\n```\n"query_parameters":[\n  ["param_key", "some_value"],\n  ["param_key", "another_value"],\n  ["other_key", "other_value"]\n]\n```\nIf the base url is `https://www.elastic.co` it results in: `https://www.elastic.co?param_key=some_value&param_key=another_value&other_key=other_value`.').optional(),
    request: inference_types_custom_request_params,
    response: inference_types_custom_response_params,
    secret_parameters: z.record(z.unknown()).describe('Specifies secret parameters, like `api_key` or `api_token`, that are required to access the custom service.\nFor example:\n```\n"secret_parameters":{\n  "api_key":"<api_key>"\n}\n```'),
    url: z.string().describe('The URL endpoint to use for the requests.').optional()
});

export const inference_types_custom_task_settings = z.object({
    parameters: z.record(z.unknown()).describe('Specifies parameters that are required to run the custom service. The parameters depend on the model your custom service uses.\nFor example:\n```\n"task_settings":{\n  "parameters":{\n    "input_type":"query",\n    "return_token":true\n  }\n}\n```').optional()
});

export const inference_types_task_type_custom = z.enum([
    'text_embedding',
    'sparse_embedding',
    'rerank',
    'completion'
]);

export const inference_types_inference_endpoint_info_custom = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_custom
}));

export const inference_types_task_type_deep_seek = z.enum(['completion', 'chat_completion']);

export const inference_types_deep_seek_service_type = z.enum(['deepseek']);

export const inference_types_deep_seek_service_settings = z.object({
    api_key: z.string().describe('A valid API key for your DeepSeek account.\nYou can find or create your DeepSeek API keys on the DeepSeek API key page.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.'),
    model_id: z.string().describe('For a `completion` or `chat_completion` task, the name of the model to use for the inference task.\n\nFor the available `completion` and `chat_completion` models, refer to the [DeepSeek Models & Pricing docs](https://api-docs.deepseek.com/quick_start/pricing).'),
    url: z.string().describe('The URL endpoint to use for the requests. Defaults to `https://api.deepseek.com/chat/completions`.').optional()
});

export const inference_types_inference_endpoint_info_deep_seek = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_deep_seek
}));

export const inference_types_elasticsearch_task_type = z.enum([
    'rerank',
    'sparse_embedding',
    'text_embedding'
]);

export const inference_types_elasticsearch_service_type = z.enum(['elasticsearch']);

export const inference_types_adaptive_allocations = z.object({
    enabled: z.boolean().describe('Turn on `adaptive_allocations`.').optional().default(false),
    max_number_of_allocations: z.number().describe('The maximum number of allocations to scale to.\nIf set, it must be greater than or equal to `min_number_of_allocations`.').optional(),
    min_number_of_allocations: z.number().describe('The minimum number of allocations to scale to.\nIf set, it must be greater than or equal to 0.\nIf not defined, the deployment scales to 0.').optional()
});

export const inference_types_elasticsearch_service_settings = z.object({
    adaptive_allocations: inference_types_adaptive_allocations.optional(),
    deployment_id: z.string().describe('The deployment identifier for a trained model deployment.\nWhen `deployment_id` is used the `model_id` is optional.').optional(),
    model_id: z.string().describe('The name of the model to use for the inference task.\nIt can be the ID of a built-in model (for example, `.multilingual-e5-small` for E5) or a text embedding model that was uploaded by using the Eland client.'),
    num_allocations: z.number().describe('The total number of allocations that are assigned to the model across machine learning nodes.\nIncreasing this value generally increases the throughput.\nIf adaptive allocations are enabled, do not set this value because it\'s automatically set.').optional(),
    num_threads: z.number().describe('The number of threads used by each model allocation during inference.\nThis setting generally increases the speed per inference request.\nThe inference process is a compute-bound process; `threads_per_allocations` must not exceed the number of available allocated processors per node.\nThe value must be a power of 2.\nThe maximum value is 32.'),
    long_document_strategy: z.string().describe('Available only for the `rerank` task type using the Elastic reranker model.\nControls the strategy used for processing long documents during inference.\n\nPossible values:\n- `truncate` (default): Processes only the beginning of each document.\n- `chunk`: Splits long documents into smaller parts (chunks) before inference.\n\nWhen `long_document_strategy` is set to `chunk`, Elasticsearch splits each document into smaller parts but still returns a single score per document.\nThat score reflects the highest relevance score among all chunks.').optional(),
    max_chunks_per_doc: z.number().describe('Only for the `rerank` task type.\nLimits the number of chunks per document that are sent for inference when chunking is enabled.\nIf not set, all chunks generated for the document are processed.').optional()
});

export const inference_types_elasticsearch_task_settings = z.object({
    return_documents: z.boolean().describe('For a `rerank` task, return the document instead of only the index.').optional().default(true)
});

export const inference_types_task_type_elasticsearch = z.enum([
    'sparse_embedding',
    'text_embedding',
    'rerank'
]);

export const inference_types_inference_endpoint_info_elasticsearch = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_elasticsearch
}));

export const inference_types_elser_task_type = z.enum(['sparse_embedding']);

export const inference_types_elser_service_type = z.enum(['elser']);

export const inference_types_elser_service_settings = z.object({
    adaptive_allocations: inference_types_adaptive_allocations.optional(),
    num_allocations: z.number().describe('The total number of allocations this model is assigned across machine learning nodes.\nIncreasing this value generally increases the throughput.\nIf adaptive allocations is enabled, do not set this value because it\'s automatically set.'),
    num_threads: z.number().describe('The number of threads used by each model allocation during inference.\nIncreasing this value generally increases the speed per inference request.\nThe inference process is a compute-bound process; `threads_per_allocations` must not exceed the number of available allocated processors per node.\nThe value must be a power of 2.\nThe maximum value is 32.\n\n> info\n> If you want to optimize your ELSER endpoint for ingest, set the number of threads to 1. If you want to optimize your ELSER endpoint for search, set the number of threads to greater than 1.')
});

export const inference_types_task_type_elser = z.enum(['sparse_embedding']);

export const inference_types_inference_endpoint_info_elser = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_elser
}));

export const inference_types_google_ai_studio_task_type = z.enum(['completion', 'text_embedding']);

export const inference_types_google_ai_service_type = z.enum(['googleaistudio']);

export const inference_types_google_ai_studio_service_settings = z.object({
    api_key: z.string().describe('A valid API key of your Google Gemini account.'),
    model_id: z.string().describe('The name of the model to use for the inference task.\nRefer to the Google documentation for the list of supported models.'),
    rate_limit: inference_types_rate_limit_setting.optional()
});

export const inference_types_task_type_google_ai_studio = z.enum(['text_embedding', 'completion']);

export const inference_types_inference_endpoint_info_google_ai_studio = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_google_ai_studio
}));

export const inference_types_google_vertex_ai_task_type = z.enum([
    'rerank',
    'text_embedding',
    'completion',
    'chat_completion'
]);

export const inference_types_google_vertex_ai_service_type = z.enum(['googlevertexai']);

export const inference_types_google_model_garden_provider = z.enum([
    'google',
    'anthropic',
    'meta',
    'hugging_face',
    'mistral',
    'ai21'
]);

export const inference_types_google_vertex_ai_service_settings = z.object({
    provider: inference_types_google_model_garden_provider.optional(),
    url: z.string().describe('The URL for non-streaming `completion` requests to a Google Model Garden provider endpoint.\nIf both `url` and `streaming_url` are provided, each is used for its respective mode.\nIf `streaming_url` is not provided, `url` is also used for streaming `completion` and `chat_completion`.\nIf `provider` is not provided or set to `google` (Google Vertex AI), do not set `url` (or `streaming_url`).\nAt least one of `url` or `streaming_url` must be provided for Google Model Garden endpoint usage.\nCertain providers require separate URLs for streaming and non-streaming operations (e.g., Anthropic, Mistral, AI21). Others support both operation types through a single URL (e.g., Meta, Hugging Face).\nInformation on constructing the URL for various providers can be found in the Google Model Garden documentation for the model, or on the endpoints `Sample request` page. The request examples also illustrate the proper formatting for the `url`.').optional(),
    streaming_url: z.string().describe('The URL for streaming `completion` and `chat_completion` requests to a Google Model Garden provider endpoint.\nIf both `streaming_url` and `url` are provided, each is used for its respective mode.\nIf `url` is not provided, `streaming_url` is also used for non-streaming `completion` requests.\nIf `provider` is not provided or set to `google` (Google Vertex AI), do not set `streaming_url` (or `url`).\nAt least one of `streaming_url` or `url` must be provided for Google Model Garden endpoint usage.\nCertain providers require separate URLs for streaming and non-streaming operations (e.g., Anthropic, Mistral, AI21). Others support both operation types through a single URL (e.g., Meta, Hugging Face).\nInformation on constructing the URL for various providers can be found in the Google Model Garden documentation for the model, or on the endpoints `Sample request` page. The request examples also illustrate the proper formatting for the `streaming_url`.').optional(),
    location: z.string().describe('The name of the location to use for the inference task for the Google Vertex AI inference task.\nFor Google Vertex AI, when `provider` is omitted or `google` `location` is mandatory.\nFor Google Model Garden\'s `completion` and `chat_completion` tasks, when `provider` is a supported non-`google` value - `location` is ignored.\nRefer to the Google documentation for the list of supported locations.').optional(),
    model_id: z.string().describe('The name of the model to use for the inference task.\nFor Google Vertex AI `model_id` is mandatory.\nFor Google Model Garden\'s `completion` and `chat_completion` tasks, when `provider` is a supported non-`google` value - `model_id` will be used for some providers that require it, otherwise - ignored.\nRefer to the Google documentation for the list of supported models for Google Vertex AI.').optional(),
    project_id: z.string().describe('The name of the project to use for the Google Vertex AI inference task.\nFor Google Vertex AI `project_id` is mandatory.\nFor Google Model Garden\'s `completion` and `chat_completion` tasks, when `provider` is a supported non-`google` value - `project_id` is ignored.').optional(),
    rate_limit: inference_types_rate_limit_setting.optional(),
    service_account_json: z.string().describe('A valid service account in JSON format for the Google Vertex AI API.'),
    dimensions: z.number().describe('For a `text_embedding` task, the number of dimensions the resulting output embeddings should have.\nBy default, the model\'s standard output dimension is used.\nRefer to the Google documentation for more information.').optional()
});

export const inference_types_thinking_config = z.object({
    thinking_budget: z.number().describe('Indicates the desired thinking budget in tokens.').optional()
});

export const inference_types_google_vertex_ai_task_settings = z.object({
    auto_truncate: z.boolean().describe('For a `text_embedding` task, truncate inputs longer than the maximum token length automatically.').optional(),
    top_n: z.number().describe('For a `rerank` task, the number of the top N documents that should be returned.').optional(),
    thinking_config: inference_types_thinking_config.optional(),
    max_tokens: z.number().describe('For `completion` and `chat_completion` tasks, specifies the `max_tokens` value for requests sent to the Google Model Garden `anthropic` provider.\nIf `provider` is not set to `anthropic`, this field is ignored.\nIf `max_tokens` is specified - it must be a positive integer. If not specified, the default value of 1024 is used.\nAnthropic models require `max_tokens` to be set for each request. Please refer to the Anthropic documentation for more information.').optional()
});

export const inference_types_task_type_google_vertex_ai = z.enum([
    'chat_completion',
    'completion',
    'text_embedding',
    'rerank'
]);

export const inference_types_inference_endpoint_info_google_vertex_ai = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_google_vertex_ai
}));

export const inference_types_hugging_face_task_type = z.enum([
    'chat_completion',
    'completion',
    'rerank',
    'text_embedding'
]);

export const inference_types_hugging_face_service_type = z.enum(['hugging_face']);

export const inference_types_hugging_face_service_settings = z.object({
    api_key: z.string().describe('A valid access token for your HuggingFace account.\nYou can create or find your access tokens on the HuggingFace settings page.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.'),
    rate_limit: inference_types_rate_limit_setting.optional(),
    url: z.string().describe('The URL endpoint to use for the requests.\nFor `completion` and `chat_completion` tasks, the deployed model must be compatible with the Hugging Face Chat Completion interface (see the linked external documentation for details). The endpoint URL for the request must include `/v1/chat/completions`.\nIf the model supports the OpenAI Chat Completion schema, a toggle should appear in the interface. Enabling this toggle doesn\'t change any model behavior, it reveals the full endpoint URL needed (which should include `/v1/chat/completions`) when configuring the inference endpoint in Elasticsearch. If the model doesn\'t support this schema, the toggle may not be shown.'),
    model_id: z.string().describe('The name of the HuggingFace model to use for the inference task.\nFor `completion` and `chat_completion` tasks, this field is optional but may be required for certain models  particularly when using serverless inference endpoints.\nFor the `text_embedding` task, this field should not be included. Otherwise, the request will fail.').optional()
});

export const inference_types_hugging_face_task_settings = z.object({
    return_documents: z.boolean().describe('For a `rerank` task, return doc text within the results.').optional(),
    top_n: z.number().describe('For a `rerank` task, the number of most relevant documents to return.\nIt defaults to the number of the documents.').optional()
});

export const inference_types_task_type_hugging_face = z.enum([
    'chat_completion',
    'completion',
    'rerank',
    'text_embedding'
]);

export const inference_types_inference_endpoint_info_hugging_face = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_hugging_face
}));

export const inference_types_jina_ai_task_type = z.enum(['rerank', 'text_embedding']);

export const inference_types_jina_ai_service_type = z.enum(['jinaai']);

export const inference_types_jina_ai_similarity_type = z.enum([
    'cosine',
    'dot_product',
    'l2_norm'
]);

export const inference_types_jina_ai_service_settings = z.object({
    api_key: z.string().describe('A valid API key of your JinaAI account.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.'),
    model_id: z.string().describe('The name of the model to use for the inference task.\nFor a `rerank` task, it is required.\nFor a `text_embedding` task, it is optional.').optional(),
    rate_limit: inference_types_rate_limit_setting.optional(),
    similarity: inference_types_jina_ai_similarity_type.optional()
});

export const inference_types_jina_ai_text_embedding_task = z.enum([
    'classification',
    'clustering',
    'ingest',
    'search'
]);

export const inference_types_jina_ai_task_settings = z.object({
    return_documents: z.boolean().describe('For a `rerank` task, return the doc text within the results.').optional(),
    task: inference_types_jina_ai_text_embedding_task.optional(),
    top_n: z.number().describe('For a `rerank` task, the number of most relevant documents to return.\nIt defaults to the number of the documents.\nIf this inference endpoint is used in a `text_similarity_reranker` retriever query and `top_n` is set, it must be greater than or equal to `rank_window_size` in the query.').optional()
});

export const inference_types_task_type_jina_ai = z.enum(['text_embedding', 'rerank']);

export const inference_types_inference_endpoint_info_jina_ai = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_jina_ai
}));

export const inference_types_llama_task_type = z.enum([
    'text_embedding',
    'completion',
    'chat_completion'
]);

export const inference_types_llama_service_type = z.enum(['llama']);

export const inference_types_llama_similarity_type = z.enum([
    'cosine',
    'dot_product',
    'l2_norm'
]);

export const inference_types_llama_service_settings = z.object({
    url: z.string().describe('The URL endpoint of the Llama stack endpoint.\nURL must contain:\n* For `text_embedding` task - `/v1/inference/embeddings`.\n* For `completion` and `chat_completion` tasks - `/v1/openai/v1/chat/completions`.'),
    model_id: z.string().describe('The name of the model to use for the inference task.\nRefer to the Llama downloading models documentation for different ways of getting a list of available models and downloading them.\nService has been tested and confirmed to be working with the following models:\n* For `text_embedding` task - `all-MiniLM-L6-v2`.\n* For `completion` and `chat_completion` tasks - `llama3.2:3b`.'),
    max_input_tokens: z.number().describe('For a `text_embedding` task, the maximum number of tokens per input before chunking occurs.').optional(),
    similarity: inference_types_llama_similarity_type.optional(),
    rate_limit: inference_types_rate_limit_setting.optional()
});

export const inference_types_task_type_llama = z.enum([
    'text_embedding',
    'chat_completion',
    'completion'
]);

export const inference_types_inference_endpoint_info_llama = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_llama
}));

export const inference_types_mistral_task_type = z.enum([
    'text_embedding',
    'completion',
    'chat_completion'
]);

export const inference_types_mistral_service_type = z.enum(['mistral']);

export const inference_types_mistral_service_settings = z.object({
    api_key: z.string().describe('A valid API key of your Mistral account.\nYou can find your Mistral API keys or you can create a new one on the API Keys page.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.'),
    max_input_tokens: z.number().describe('The maximum number of tokens per input before chunking occurs.').optional(),
    model: z.string().describe('The name of the model to use for the inference task.\nRefer to the Mistral models documentation for the list of available models.'),
    rate_limit: inference_types_rate_limit_setting.optional()
});

export const inference_types_task_type_mistral = z.enum([
    'text_embedding',
    'chat_completion',
    'completion'
]);

export const inference_types_inference_endpoint_info_mistral = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_mistral
}));

export const inference_types_open_ai_task_type = z.enum([
    'chat_completion',
    'completion',
    'text_embedding'
]);

export const inference_types_open_ai_service_type = z.enum(['openai']);

export const inference_types_open_ai_service_settings = z.object({
    api_key: z.string().describe('A valid API key of your OpenAI account.\nYou can find your OpenAI API keys in your OpenAI account under the API keys section.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.'),
    dimensions: z.number().describe('The number of dimensions the resulting output embeddings should have.\nIt is supported only in `text-embedding-3` and later models.\nIf it is not set, the OpenAI defined default for the model is used.').optional(),
    model_id: z.string().describe('The name of the model to use for the inference task.\nRefer to the OpenAI documentation for the list of available text embedding models.'),
    organization_id: z.string().describe('The unique identifier for your organization.\nYou can find the Organization ID in your OpenAI account under *Settings > Organizations*.').optional(),
    rate_limit: inference_types_rate_limit_setting.optional(),
    url: z.string().describe('The URL endpoint to use for the requests.\nIt can be changed for testing purposes.').optional().default('https://api.openai.com/v1/embeddings.')
});

export const inference_types_open_ai_task_settings = z.object({
    user: z.string().describe('For a `completion` or `text_embedding` task, specify the user issuing the request.\nThis information can be used for abuse detection.').optional(),
    headers: z.record(z.unknown()).describe('Specifies custom HTTP header parameters.\nFor example:\n```\n"headers":{\n  "Custom-Header": "Some-Value",\n  "Another-Custom-Header": "Another-Value"\n}\n```').optional()
});

export const inference_types_task_type_open_ai = z.enum([
    'text_embedding',
    'chat_completion',
    'completion'
]);

export const inference_types_inference_endpoint_info_open_ai = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_open_ai
}));

export const inference_types_voyage_ai_task_type = z.enum(['text_embedding', 'rerank']);

export const inference_types_voyage_ai_service_type = z.enum(['voyageai']);

export const inference_types_voyage_ai_service_settings = z.object({
    dimensions: z.number().describe('The number of dimensions for resulting output embeddings.\nThis setting maps to `output_dimension` in the VoyageAI documentation.\nOnly for the `text_embedding` task type.').optional(),
    model_id: z.string().describe('The name of the model to use for the inference task.\nRefer to the VoyageAI documentation for the list of available text embedding and rerank models.'),
    rate_limit: inference_types_rate_limit_setting.optional(),
    embedding_type: z.number().describe('The data type for the embeddings to be returned.\nThis setting maps to `output_dtype` in the VoyageAI documentation.\nPermitted values: float, int8, bit.\n`int8` is a synonym of `byte` in the VoyageAI documentation.\n`bit` is a synonym of `binary` in the VoyageAI documentation.\nOnly for the `text_embedding` task type.').optional()
});

export const inference_types_voyage_ai_task_settings = z.object({
    input_type: z.string().describe('Type of the input text.\nPermitted values: `ingest` (maps to `document` in the VoyageAI documentation), `search` (maps to `query` in the VoyageAI documentation).\nOnly for the `text_embedding` task type.').optional(),
    return_documents: z.boolean().describe('Whether to return the source documents in the response.\nOnly for the `rerank` task type.').optional().default(false),
    top_k: z.number().describe('The number of most relevant documents to return.\nIf not specified, the reranking results of all documents will be returned.\nOnly for the `rerank` task type.').optional(),
    truncation: z.boolean().describe('Whether to truncate the input texts to fit within the context length.').optional().default(true)
});

export const inference_types_task_type_voyage_ai = z.enum(['text_embedding', 'rerank']);

export const inference_types_inference_endpoint_info_voyage_ai = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_voyage_ai
}));

export const inference_types_watsonx_task_type = z.enum([
    'text_embedding',
    'chat_completion',
    'completion'
]);

export const inference_types_watsonx_service_type = z.enum(['watsonxai']);

export const inference_types_watsonx_service_settings = z.object({
    api_key: z.string().describe('A valid API key of your Watsonx account.\nYou can find your Watsonx API keys or you can create a new one on the API keys page.\n\nIMPORTANT: You need to provide the API key only once, during the inference model creation.\nThe get inference endpoint API does not retrieve your API key.\nAfter creating the inference model, you cannot change the associated API key.\nIf you want to use a different API key, delete the inference model and recreate it with the same name and the updated API key.'),
    api_version: z.string().describe('A version parameter that takes a version date in the format of `YYYY-MM-DD`.\nFor the active version data parameters, refer to the Wastonx documentation.'),
    model_id: z.string().describe('The name of the model to use for the inference task.\nRefer to the IBM Embedding Models section in the Watsonx documentation for the list of available text embedding models.\nRefer to the IBM library - Foundation models in Watsonx.ai.'),
    project_id: z.string().describe('The identifier of the IBM Cloud project to use for the inference task.'),
    rate_limit: inference_types_rate_limit_setting.optional(),
    url: z.string().describe('The URL of the inference endpoint that you created on Watsonx.')
});

export const inference_types_task_type_watsonx = z.enum([
    'text_embedding',
    'chat_completion',
    'completion'
]);

export const inference_types_inference_endpoint_info_watsonx = inference_types_inference_endpoint.and(z.object({
    inference_id: z.string().describe('The inference Id'),
    task_type: inference_types_task_type_watsonx
}));

/**
 * Defines the response for a rerank request.
 */
export const inference_types_reranked_inference_result = z.object({
    rerank: z.array(inference_types_ranked_document)
}).describe('Defines the response for a rerank request.');

/**
 * The response format for the sparse embedding request.
 */
export const inference_types_sparse_embedding_inference_result = z.object({
    sparse_embedding: z.array(inference_types_sparse_embedding_result)
}).describe('The response format for the sparse embedding request.');

/**
 * TextEmbeddingInferenceResult is an aggregation of mutually exclusive text_embedding variants
 */
export const inference_types_text_embedding_inference_result = z.object({
    text_embedding_bytes: z.array(inference_types_text_embedding_byte_result).optional(),
    text_embedding_bits: z.array(inference_types_text_embedding_byte_result).optional(),
    text_embedding: z.array(inference_types_text_embedding_result).optional()
}).describe('TextEmbeddingInferenceResult is an aggregation of mutually exclusive text_embedding variants');

export const types_elasticsearch_version_info = z.object({
    build_date: types_date_time,
    build_flavor: z.string().describe('The build flavor. For example, `default`.'),
    build_hash: z.string().describe('The Elasticsearch Git commit\'s SHA hash.'),
    build_snapshot: z.boolean().describe('Indicates whether the Elasticsearch build was a snapshot.'),
    build_type: z.string().describe('The build type that corresponds to how Elasticsearch was installed.\nFor example, `docker`, `rpm`, or `tar`.'),
    lucene_version: types_version_string,
    minimum_index_compatibility_version: types_version_string,
    minimum_wire_compatibility_version: types_version_string,
    number: z.string().describe('The Elasticsearch version number.\n\n::: IMPORTANT: For Serverless deployments, this static value is always `8.11.0` and is used solely for backward compatibility with legacy clients.\n Serverless environments are versionless and automatically upgraded, so this value can be safely ignored.')
});

export const ingest_geo_ip_stats_geo_ip_download_statistics = z.object({
    successful_downloads: z.number().describe('Total number of successful database downloads.'),
    failed_downloads: z.number().describe('Total number of failed database downloads.'),
    total_download_time: types_duration_value_unit_millis,
    databases_count: z.number().describe('Current number of databases available for use.'),
    skipped_updates: z.number().describe('Total number of database updates skipped.'),
    expired_databases: z.number().describe('Total number of databases not updated after 30 days')
});

export const ingest_geo_ip_stats_geo_ip_node_database_name = z.object({
    name: types_name
});

/**
 * Downloaded databases for the node. The field key is the node ID.
 */
export const ingest_geo_ip_stats_geo_ip_node_databases = z.object({
    databases: z.array(ingest_geo_ip_stats_geo_ip_node_database_name).describe('Downloaded databases for the node.'),
    files_in_temp: z.array(z.string()).describe('Downloaded database files, including related license files. Elasticsearch stores these files in the nodes temporary directory: $ES_TMPDIR/geoip-databases/<node_id>.')
}).describe('Downloaded databases for the node. The field key is the node ID.');

export const ingest_types_maxmind = z.object({
    account_id: types_id
});

export const ingest_types_ipinfo = z.record(z.unknown());

/**
 * The configuration necessary to identify which IP geolocation provider to use to download a database, as well as any provider-specific configuration necessary for such downloading.
 * At present, the only supported providers are `maxmind` and `ipinfo`, and the `maxmind` provider requires that an `account_id` (string) is configured.
 * A provider (either `maxmind` or `ipinfo`) must be specified. The web and local providers can be returned as read only configurations.
 */
export const ingest_types_database_configuration = z.object({
    name: types_name
}).and(z.object({
    maxmind: ingest_types_maxmind.optional(),
    ipinfo: ingest_types_ipinfo.optional()
}));

export const ingest_get_geoip_database_database_configuration_metadata = z.object({
    id: types_id,
    version: z.number(),
    modified_date_millis: types_epoch_time_unit_millis,
    database: ingest_types_database_configuration
});

export const ingest_types_web = z.record(z.unknown());

export const ingest_types_local = z.object({
    type: z.string()
});

export const ingest_types_database_configuration_full = z.object({
    name: types_name
}).and(z.object({
    web: ingest_types_web.optional(),
    local: ingest_types_local.optional(),
    maxmind: ingest_types_maxmind.optional(),
    ipinfo: ingest_types_ipinfo.optional()
}));

export const ingest_get_ip_location_database_database_configuration_metadata = z.object({
    id: types_id,
    version: types_version_number,
    modified_date_millis: types_epoch_time_unit_millis.optional(),
    modified_date: types_epoch_time_unit_millis.optional(),
    database: ingest_types_database_configuration_full
});

export const ingest_types_shape_type = z.enum(['geo_shape', 'shape']);

export const ingest_types_convert_type = z.enum([
    'integer',
    'long',
    'double',
    'float',
    'boolean',
    'ip',
    'string',
    'auto'
]);

export const types_geo_shape_relation = z.enum([
    'intersects',
    'disjoint',
    'within',
    'contains'
]);

export const ingest_types_fingerprint_digest = z.enum([
    'MD5',
    'SHA-1',
    'SHA-256',
    'SHA-512',
    'MurmurHash3'
]);

export const ingest_types_geo_grid_tile_type = z.enum([
    'geotile',
    'geohex',
    'geohash'
]);

export const ingest_types_geo_grid_target_format = z.enum(['geojson', 'wkt']);

export const types_grok_pattern = z.string();

export const ingest_types_inference_config_regression = z.object({
    results_field: types_field.optional(),
    num_top_feature_importance_values: z.number().describe('Specifies the maximum number of feature importance values per document.').optional().default(0)
});

export const ingest_types_inference_config_classification = z.object({
    num_top_classes: z.number().describe('Specifies the number of top class predictions to return.').optional().default(0),
    num_top_feature_importance_values: z.number().describe('Specifies the maximum number of feature importance values per document.').optional().default(0),
    results_field: types_field.optional(),
    top_classes_results_field: types_field.optional(),
    prediction_field_type: z.string().describe('Specifies the type of the predicted field to write.\nValid values are: `string`, `number`, `boolean`.').optional()
});

export const ingest_types_inference_config = z.object({
    regression: ingest_types_inference_config_regression.optional(),
    classification: ingest_types_inference_config_classification.optional()
});

export const ingest_types_input_config = z.object({
    input_field: z.string(),
    output_field: z.string()
});

export const ingest_types_json_processor_conflict_strategy = z.enum(['replace', 'merge']);

export const ingest_types_user_agent_property = z.enum([
    'name',
    'os',
    'device',
    'original',
    'version'
]);

export const ingest_types_field_access_pattern = z.enum(['classic', 'flexible']);

export const ingest_types_document = z.object({
    _id: types_id.optional(),
    _index: types_index_name.optional(),
    _source: z.record(z.unknown()).describe('JSON body for the document.')
});

export const ingest_types_redact = z.object({
    _is_redacted: z.boolean().describe('indicates if document has been redacted')
});

export const ingest_types_ingest = z.object({
    _redact: ingest_types_redact.optional(),
    timestamp: types_date_time,
    pipeline: types_name.optional()
});

/**
 * Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior
 * is used to capture this behavior while keeping the semantics of the field type.
 *
 * Depending on the target language, code generators can keep the union or remove it and leniently parse
 * strings to the target type.
 */
export const spec_utils_stringified_version_number = z.union([
    types_version_number,
    z.string()
]);

/**
 * The simulated document, with optional metadata.
 */
export const ingest_types_document_simulation = z.object({
    _id: types_id,
    _index: types_index_name,
    _ingest: ingest_types_ingest,
    _routing: z.string().describe('Value used to send the document to a specific primary shard.').optional(),
    _source: z.record(z.record(z.unknown())).describe('JSON body for the document.'),
    _version: spec_utils_stringified_version_number.optional(),
    _version_type: types_version_type.optional()
}).describe('The simulated document, with optional metadata.');

export const ingest_types_pipeline_simulation_status_options = z.enum([
    'success',
    'error',
    'error_ignored',
    'skipped',
    'dropped'
]);

export const ingest_types_pipeline_processor_result = z.object({
    doc: ingest_types_document_simulation.optional(),
    tag: z.string().optional(),
    processor_type: z.string().optional(),
    status: ingest_types_pipeline_simulation_status_options.optional(),
    description: z.string().optional(),
    ignored_error: types_error_cause.optional(),
    error: types_error_cause.optional()
});

export const ingest_types_simulate_document_result = z.object({
    doc: ingest_types_document_simulation.optional(),
    error: types_error_cause.optional(),
    processor_results: z.array(ingest_types_pipeline_processor_result).optional()
});

export const license_types_license_status = z.enum([
    'active',
    'valid',
    'invalid',
    'expired'
]);

export const license_types_license_type = z.enum([
    'missing',
    'trial',
    'basic',
    'standard',
    'dev',
    'silver',
    'gold',
    'platinum',
    'enterprise'
]);

export const license_get_license_information = z.object({
    expiry_date: types_date_time.optional(),
    expiry_date_in_millis: types_epoch_time_unit_millis.optional(),
    issue_date: types_date_time,
    issue_date_in_millis: types_epoch_time_unit_millis,
    issued_to: z.string(),
    issuer: z.string(),
    max_nodes: z.union([
        z.number(),
        z.string(),
        z.null()
    ]),
    max_resource_units: z.union([
        z.number(),
        z.string(),
        z.null()
    ]).optional(),
    status: license_types_license_status,
    type: license_types_license_type,
    uid: types_uuid,
    start_date_in_millis: types_epoch_time_unit_millis
});

export const license_types_license = z.object({
    expiry_date_in_millis: types_epoch_time_unit_millis,
    issue_date_in_millis: types_epoch_time_unit_millis,
    start_date_in_millis: types_epoch_time_unit_millis.optional(),
    issued_to: z.string(),
    issuer: z.string(),
    max_nodes: z.union([
        z.number(),
        z.string(),
        z.null()
    ]).optional(),
    max_resource_units: z.number().optional(),
    signature: z.string(),
    type: license_types_license_type,
    uid: z.string()
});

export const license_post_acknowledgement = z.object({
    license: z.array(z.string()),
    message: z.string()
});

export const logstash_types_pipeline_metadata = z.object({
    type: z.string(),
    version: z.string()
});

export const logstash_types_pipeline_settings = z.object({
    'pipeline.workers': z.number().describe('The number of workers that will, in parallel, execute the filter and output stages of the pipeline.'),
    'pipeline.batch.size': z.number().describe('The maximum number of events an individual worker thread will collect from inputs before attempting to execute its filters and outputs.'),
    'pipeline.batch.delay': z.number().describe('When creating pipeline event batches, how long in milliseconds to wait for each event before dispatching an undersized batch to pipeline workers.'),
    'queue.type': z.string().describe('The internal queuing model to use for event buffering.'),
    'queue.max_bytes': z.string().describe('The total capacity of the queue (`queue.type: persisted`) in number of bytes.'),
    'queue.checkpoint.writes': z.number().describe('The maximum number of written events before forcing a checkpoint when persistent queues are enabled (`queue.type: persisted`).')
});

export const logstash_types_pipeline = z.object({
    description: z.string().describe('A description of the pipeline.\nThis description is not used by Elasticsearch or Logstash.'),
    last_modified: types_date_time,
    pipeline: z.string().describe('The configuration for the pipeline.'),
    pipeline_metadata: logstash_types_pipeline_metadata,
    pipeline_settings: logstash_types_pipeline_settings,
    username: z.string().describe('The user who last updated the pipeline.')
});

export const global_mget_operation = z.object({
    _id: types_id,
    _index: types_index_name.optional(),
    routing: types_routing.optional(),
    _source: global_search_types_source_config.optional(),
    stored_fields: types_fields.optional(),
    version: types_version_number.optional(),
    version_type: types_version_type.optional()
});

export const global_mget_multi_get_error = z.object({
    error: types_error_cause,
    _id: types_id,
    _index: types_index_name
});

export const global_mget_response_item = z.union([
    global_get_get_result,
    global_mget_multi_get_error
]);

export const migration_deprecations_deprecation_level = z.enum([
    'none',
    'info',
    'warning',
    'critical'
]);

export const migration_deprecations_deprecation = z.object({
    details: z.string().describe('Optional details about the deprecation warning.').optional(),
    level: migration_deprecations_deprecation_level,
    message: z.string().describe('Descriptive information about the deprecation warning.'),
    url: z.string().describe('A link to the breaking change documentation, where you can find more information about this change.'),
    resolve_during_rolling_upgrade: z.boolean(),
    _meta: z.record(z.record(z.unknown())).optional()
});

export const migration_get_feature_upgrade_status_migration_status = z.enum([
    'NO_MIGRATION_NEEDED',
    'MIGRATION_NEEDED',
    'IN_PROGRESS',
    'ERROR'
]);

export const migration_get_feature_upgrade_status_migration_feature_index_info = z.object({
    index: types_index_name,
    version: types_version_string,
    failure_cause: types_error_cause.optional()
});

export const migration_get_feature_upgrade_status_migration_feature = z.object({
    feature_name: z.string(),
    minimum_index_version: types_version_string,
    migration_status: migration_get_feature_upgrade_status_migration_status,
    indices: z.array(migration_get_feature_upgrade_status_migration_feature_index_info)
});

export const migration_post_feature_upgrade_migration_feature = z.object({
    feature_name: z.string()
});

export const ml_types_rule_action = z.enum(['skip_result', 'skip_model_update']);

export const ml_types_applies_to = z.enum([
    'actual',
    'typical',
    'diff_from_typical',
    'time'
]);

export const ml_types_condition_operator = z.enum([
    'gt',
    'gte',
    'lt',
    'lte'
]);

export const ml_types_rule_condition = z.object({
    applies_to: ml_types_applies_to,
    operator: ml_types_condition_operator,
    value: z.number().describe('The value that is compared against the `applies_to` field using the operator.')
});

export const ml_types_filter_type = z.enum(['include', 'exclude']);

export const ml_types_filter_ref = z.object({
    filter_id: types_id,
    filter_type: ml_types_filter_type.optional()
});

export const ml_types_detection_rule = z.object({
    actions: z.array(ml_types_rule_action).describe('The set of actions to be triggered when the rule applies. If more than one action is specified the effects of all actions are combined.').optional().default(['skip_result']),
    conditions: z.array(ml_types_rule_condition).describe('An array of numeric conditions when the rule applies. A rule must either have a non-empty scope or at least one condition. Multiple conditions are combined together with a logical AND.').optional(),
    scope: z.record(ml_types_filter_ref).describe('A scope of series where the rule applies. A rule must either have a non-empty scope or at least one condition. By default, the scope includes all series. Scoping is allowed for any of the fields that are also specified in `by_field_name`, `over_field_name`, or `partition_field_name`.').optional()
});

export const ml_types_exclude_frequent = z.enum([
    'all',
    'none',
    'by',
    'over'
]);

export const ml_types_detector = z.object({
    by_field_name: types_field.optional(),
    custom_rules: z.array(ml_types_detection_rule).describe('Custom rules enable you to customize the way detectors operate. For example, a rule may dictate conditions under which results should be skipped. Kibana refers to custom rules as job rules.').optional(),
    detector_description: z.string().describe('A description of the detector.').optional(),
    detector_index: z.number().describe('A unique identifier for the detector. This identifier is based on the order of the detectors in the `analysis_config`, starting at zero. If you specify a value for this property, it is ignored.').optional(),
    exclude_frequent: ml_types_exclude_frequent.optional(),
    field_name: types_field.optional(),
    function: z.string().describe('The analysis function that is used. For example, `count`, `rare`, `mean`, `min`, `max`, or `sum`.').optional(),
    over_field_name: types_field.optional(),
    partition_field_name: types_field.optional(),
    use_null: z.boolean().describe('Defines whether a new series is used as the null series when there is no value for the by or partition fields.').optional().default(false)
});

export const ml_types_per_partition_categorization = z.object({
    enabled: z.boolean().describe('To enable this setting, you must also set the `partition_field_name` property to the same value in every detector that uses the keyword `mlcategory`. Otherwise, job creation fails.').optional(),
    stop_on_warn: z.boolean().describe('This setting can be set to true only if per-partition categorization is enabled. If true, both categorization and subsequent anomaly detection stops for partitions where the categorization status changes to warn. This setting makes it viable to have a job where it is expected that categorization works well for some partitions but not others; you do not pay the cost of bad categorization forever in the partitions where it works badly.').optional()
});

export const ml_types_dataframe_evaluation_classification_metrics_auc_roc = z.object({
    class_name: types_name.optional(),
    include_curve: z.boolean().describe('Whether or not the curve should be returned in addition to the score. Default value is false.').optional()
});

export const ml_types_dataframe_evaluation_metrics = z.object({
    auc_roc: ml_types_dataframe_evaluation_classification_metrics_auc_roc.optional(),
    precision: z.record(z.record(z.unknown())).describe('Precision of predictions (per-class and average).').optional(),
    recall: z.record(z.record(z.unknown())).describe('Recall of predictions (per-class and average).').optional()
});

export const ml_types_dataframe_evaluation_classification_metrics = ml_types_dataframe_evaluation_metrics.and(z.object({
    accuracy: z.record(z.record(z.unknown())).describe('Accuracy of predictions (per-class and overall).').optional(),
    multiclass_confusion_matrix: z.record(z.record(z.unknown())).describe('Multiclass confusion matrix.').optional()
}));

export const ml_types_dataframe_evaluation_classification = z.object({
    actual_field: types_field,
    predicted_field: types_field.optional(),
    top_classes_field: types_field.optional(),
    metrics: ml_types_dataframe_evaluation_classification_metrics.optional()
});

export const ml_types_dataframe_evaluation_outlier_detection_metrics = ml_types_dataframe_evaluation_metrics.and(z.object({
    confusion_matrix: z.record(z.record(z.unknown())).describe('Accuracy of predictions (per-class and overall).').optional()
}));

export const ml_types_dataframe_evaluation_outlier_detection = z.object({
    actual_field: types_field,
    predicted_probability_field: types_field,
    metrics: ml_types_dataframe_evaluation_outlier_detection_metrics.optional()
});

export const ml_types_dataframe_evaluation_regression_metrics_msle = z.object({
    offset: z.number().describe('Defines the transition point at which you switch from minimizing quadratic error to minimizing quadratic log error. Defaults to 1.').optional()
});

export const ml_types_dataframe_evaluation_regression_metrics_huber = z.object({
    delta: z.number().describe('Approximates 1/2 (prediction - actual)2 for values much less than delta and approximates a straight line with slope delta for values much larger than delta. Defaults to 1. Delta needs to be greater than 0.').optional()
});

export const ml_types_dataframe_evaluation_regression_metrics = z.object({
    mse: z.record(z.record(z.unknown())).describe('Average squared difference between the predicted values and the actual (ground truth) value. For more information, read this wiki article.').optional(),
    msle: ml_types_dataframe_evaluation_regression_metrics_msle.optional(),
    huber: ml_types_dataframe_evaluation_regression_metrics_huber.optional(),
    r_squared: z.record(z.record(z.unknown())).describe('Proportion of the variance in the dependent variable that is predictable from the independent variables.').optional()
});

export const ml_types_dataframe_evaluation_regression = z.object({
    actual_field: types_field,
    predicted_field: types_field,
    metrics: ml_types_dataframe_evaluation_regression_metrics.optional()
});

export const ml_types_dataframe_evaluation_container = z.object({
    classification: ml_types_dataframe_evaluation_classification.optional(),
    outlier_detection: ml_types_dataframe_evaluation_outlier_detection.optional(),
    regression: ml_types_dataframe_evaluation_regression.optional()
});

export const ml_evaluate_data_frame_dataframe_evaluation_summary_auc_roc_curve_item = z.object({
    tpr: z.number(),
    fpr: z.number(),
    threshold: z.number()
});

export const ml_evaluate_data_frame_dataframe_evaluation_value = z.object({
    value: z.number()
});

export const ml_evaluate_data_frame_dataframe_evaluation_summary_auc_roc = ml_evaluate_data_frame_dataframe_evaluation_value.and(z.object({
    curve: z.array(ml_evaluate_data_frame_dataframe_evaluation_summary_auc_roc_curve_item).optional()
}));

export const ml_evaluate_data_frame_dataframe_evaluation_class = ml_evaluate_data_frame_dataframe_evaluation_value.and(z.object({
    class_name: types_name
}));

export const ml_evaluate_data_frame_dataframe_classification_summary_accuracy = z.object({
    classes: z.array(ml_evaluate_data_frame_dataframe_evaluation_class),
    overall_accuracy: z.number()
});

export const ml_evaluate_data_frame_confusion_matrix_prediction = z.object({
    predicted_class: types_name,
    count: z.number()
});

export const ml_evaluate_data_frame_confusion_matrix_item = z.object({
    actual_class: types_name,
    actual_class_doc_count: z.number(),
    predicted_classes: z.array(ml_evaluate_data_frame_confusion_matrix_prediction),
    other_predicted_class_doc_count: z.number()
});

export const ml_evaluate_data_frame_dataframe_classification_summary_multiclass_confusion_matrix = z.object({
    confusion_matrix: z.array(ml_evaluate_data_frame_confusion_matrix_item),
    other_actual_class_count: z.number()
});

export const ml_evaluate_data_frame_dataframe_classification_summary_precision = z.object({
    classes: z.array(ml_evaluate_data_frame_dataframe_evaluation_class),
    avg_precision: z.number()
});

export const ml_evaluate_data_frame_dataframe_classification_summary_recall = z.object({
    classes: z.array(ml_evaluate_data_frame_dataframe_evaluation_class),
    avg_recall: z.number()
});

export const ml_evaluate_data_frame_dataframe_classification_summary = z.object({
    auc_roc: ml_evaluate_data_frame_dataframe_evaluation_summary_auc_roc.optional(),
    accuracy: ml_evaluate_data_frame_dataframe_classification_summary_accuracy.optional(),
    multiclass_confusion_matrix: ml_evaluate_data_frame_dataframe_classification_summary_multiclass_confusion_matrix.optional(),
    precision: ml_evaluate_data_frame_dataframe_classification_summary_precision.optional(),
    recall: ml_evaluate_data_frame_dataframe_classification_summary_recall.optional()
});

export const ml_evaluate_data_frame_confusion_matrix_threshold = z.object({
    tp: z.number().describe('True Positive'),
    fp: z.number().describe('False Positive'),
    tn: z.number().describe('True Negative'),
    fn: z.number().describe('False Negative')
});

export const ml_evaluate_data_frame_dataframe_outlier_detection_summary = z.object({
    auc_roc: ml_evaluate_data_frame_dataframe_evaluation_summary_auc_roc.optional(),
    precision: z.record(z.number()).describe('Set the different thresholds of the outlier score at where the metric is calculated.').optional(),
    recall: z.record(z.number()).describe('Set the different thresholds of the outlier score at where the metric is calculated.').optional(),
    confusion_matrix: z.record(ml_evaluate_data_frame_confusion_matrix_threshold).describe('Set the different thresholds of the outlier score at where the metrics (`tp` - true positive, `fp` - false positive, `tn` - true negative, `fn` - false negative) are calculated.').optional()
});

export const ml_evaluate_data_frame_dataframe_regression_summary = z.object({
    huber: ml_evaluate_data_frame_dataframe_evaluation_value.optional(),
    mse: ml_evaluate_data_frame_dataframe_evaluation_value.optional(),
    msle: ml_evaluate_data_frame_dataframe_evaluation_value.optional(),
    r_squared: ml_evaluate_data_frame_dataframe_evaluation_value.optional()
});

export const ml_types_dataframe_analysis_analyzed_fields = z.object({
    includes: z.array(z.string()).describe('An array of strings that defines the fields that will be excluded from the analysis. You do not need to add fields with unsupported data types to excludes, these fields are excluded from the analysis automatically.').optional(),
    excludes: z.array(z.string()).describe('An array of strings that defines the fields that will be included in the analysis.').optional()
});

export const ml_types_dataframe_analytics_destination = z.object({
    index: types_index_name,
    results_field: types_field.optional()
});

export const ml_types_dataframe_analysis_feature_processor_frequency_encoding = z.object({
    feature_name: types_name,
    field: types_field,
    frequency_map: z.record(z.number()).describe('The resulting frequency map for the field value. If the field value is missing from the frequency_map, the resulting value is 0.')
});

export const ml_types_dataframe_analysis_feature_processor_multi_encoding = z.object({
    processors: z.array(z.number()).describe('The ordered array of custom processors to execute. Must be more than 1.')
});

export const ml_types_dataframe_analysis_feature_processor_n_gram_encoding = z.object({
    feature_prefix: z.string().describe('The feature name prefix. Defaults to ngram_<start>_<length>.').optional(),
    field: types_field,
    length: z.number().describe('Specifies the length of the n-gram substring. Defaults to 50. Must be greater than 0.').optional(),
    n_grams: z.array(z.number()).describe('Specifies which n-grams to gather. Its an array of integer values where the minimum value is 1, and a maximum value is 5.'),
    start: z.number().describe('Specifies the zero-indexed start of the n-gram substring. Negative values are allowed for encoding n-grams of string suffixes. Defaults to 0.').optional(),
    custom: z.boolean().optional()
});

export const ml_types_dataframe_analysis_feature_processor_one_hot_encoding = z.object({
    field: types_field,
    hot_map: z.string().describe('The one hot map mapping the field value with the column name.')
});

export const ml_types_dataframe_analysis_feature_processor_target_mean_encoding = z.object({
    default_value: z.number().describe('The default value if field value is not found in the target_map.'),
    feature_name: types_name,
    field: types_field,
    target_map: z.record(z.record(z.unknown())).describe('The field value to target mean transition map.')
});

export const ml_types_dataframe_analysis_feature_processor = z.object({
    frequency_encoding: ml_types_dataframe_analysis_feature_processor_frequency_encoding.optional(),
    multi_encoding: ml_types_dataframe_analysis_feature_processor_multi_encoding.optional(),
    n_gram_encoding: ml_types_dataframe_analysis_feature_processor_n_gram_encoding.optional(),
    one_hot_encoding: ml_types_dataframe_analysis_feature_processor_one_hot_encoding.optional(),
    target_mean_encoding: ml_types_dataframe_analysis_feature_processor_target_mean_encoding.optional()
});

export const ml_types_dataframe_analysis = z.object({
    alpha: z.number().describe('Advanced configuration option. Machine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly. This parameter affects loss calculations by acting as a multiplier of the tree depth. Higher alpha values result in shallower trees and faster training times. By default, this value is calculated during hyperparameter optimization. It must be greater than or equal to zero.').optional(),
    dependent_variable: z.string().describe('Defines which field of the document is to be predicted. It must match one of the fields in the index being used to train. If this field is missing from a document, then that document will not be used for training, but a prediction with the trained model will be generated for it. It is also known as continuous target variable.\nFor classification analysis, the data type of the field must be numeric (`integer`, `short`, `long`, `byte`), categorical (`ip` or `keyword`), or `boolean`. There must be no more than 30 different values in this field.\nFor regression analysis, the data type of the field must be numeric.'),
    downsample_factor: z.number().describe('Advanced configuration option. Controls the fraction of data that is used to compute the derivatives of the loss function for tree training. A small value results in the use of a small fraction of the data. If this value is set to be less than 1, accuracy typically improves. However, too small a value may result in poor convergence for the ensemble and so require more trees. By default, this value is calculated during hyperparameter optimization. It must be greater than zero and less than or equal to 1.').optional(),
    early_stopping_enabled: z.boolean().describe('Advanced configuration option. Specifies whether the training process should finish if it is not finding any better performing models. If disabled, the training process can take significantly longer and the chance of finding a better performing model is unremarkable.').optional().default(true),
    eta: z.number().describe('Advanced configuration option. The shrinkage applied to the weights. Smaller values result in larger forests which have a better generalization error. However, larger forests cause slower training. By default, this value is calculated during hyperparameter optimization. It must be a value between 0.001 and 1.').optional(),
    eta_growth_rate_per_tree: z.number().describe('Advanced configuration option. Specifies the rate at which `eta` increases for each new tree that is added to the forest. For example, a rate of 1.05 increases `eta` by 5% for each extra tree. By default, this value is calculated during hyperparameter optimization. It must be between 0.5 and 2.').optional(),
    feature_bag_fraction: z.number().describe('Advanced configuration option. Defines the fraction of features that will be used when selecting a random bag for each candidate split. By default, this value is calculated during hyperparameter optimization.').optional(),
    feature_processors: z.array(ml_types_dataframe_analysis_feature_processor).describe('Advanced configuration option. A collection of feature preprocessors that modify one or more included fields. The analysis uses the resulting one or more features instead of the original document field. However, these features are ephemeral; they are not stored in the destination index. Multiple `feature_processors` entries can refer to the same document fields. Automatic categorical feature encoding still occurs for the fields that are unprocessed by a custom processor or that have categorical values. Use this property only if you want to override the automatic feature encoding of the specified fields.').optional(),
    gamma: z.number().describe('Advanced configuration option. Regularization parameter to prevent overfitting on the training data set. Multiplies a linear penalty associated with the size of individual trees in the forest. A high gamma value causes training to prefer small trees. A small gamma value results in larger individual trees and slower training. By default, this value is calculated during hyperparameter optimization. It must be a nonnegative value.').optional(),
    lambda: z.number().describe('Advanced configuration option. Regularization parameter to prevent overfitting on the training data set. Multiplies an L2 regularization term which applies to leaf weights of the individual trees in the forest. A high lambda value causes training to favor small leaf weights. This behavior makes the prediction function smoother at the expense of potentially not being able to capture relevant relationships between the features and the dependent variable. A small lambda value results in large individual trees and slower training. By default, this value is calculated during hyperparameter optimization. It must be a nonnegative value.').optional(),
    max_optimization_rounds_per_hyperparameter: z.number().describe('Advanced configuration option. A multiplier responsible for determining the maximum number of hyperparameter optimization steps in the Bayesian optimization procedure. The maximum number of steps is determined based on the number of undefined hyperparameters times the maximum optimization rounds per hyperparameter. By default, this value is calculated during hyperparameter optimization.').optional(),
    max_trees: z.number().describe('Advanced configuration option. Defines the maximum number of decision trees in the forest. The maximum value is 2000. By default, this value is calculated during hyperparameter optimization.').optional(),
    num_top_feature_importance_values: z.number().describe('Advanced configuration option. Specifies the maximum number of feature importance values per document to return. By default, no feature importance calculation occurs.').optional().default(0),
    prediction_field_name: types_field.optional(),
    randomize_seed: z.number().describe('Defines the seed for the random generator that is used to pick training data. By default, it is randomly generated. Set it to a specific value to use the same training data each time you start a job (assuming other related parameters such as `source` and `analyzed_fields` are the same).').optional(),
    soft_tree_depth_limit: z.number().describe('Advanced configuration option. Machine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly. This soft limit combines with the `soft_tree_depth_tolerance` to penalize trees that exceed the specified depth; the regularized loss increases quickly beyond this depth. By default, this value is calculated during hyperparameter optimization. It must be greater than or equal to 0.').optional(),
    soft_tree_depth_tolerance: z.number().describe('Advanced configuration option. This option controls how quickly the regularized loss increases when the tree depth exceeds `soft_tree_depth_limit`. By default, this value is calculated during hyperparameter optimization. It must be greater than or equal to 0.01.').optional(),
    training_percent: types_percentage.optional()
});

export const ml_types_dataframe_analysis_classification = ml_types_dataframe_analysis.and(z.object({
    class_assignment_objective: z.string().optional(),
    num_top_classes: z.number().describe('Defines the number of categories for which the predicted probabilities are reported. It must be non-negative or -1. If it is -1 or greater than the total number of categories, probabilities are reported for all categories; if you have a large number of categories, there could be a significant effect on the size of your destination index. NOTE: To use the AUC ROC evaluation method, `num_top_classes` must be set to -1 or a value greater than or equal to the total number of categories.').optional().default(2)
}));

export const ml_types_dataframe_analysis_outlier_detection = z.object({
    compute_feature_influence: z.boolean().describe('Specifies whether the feature influence calculation is enabled.').optional().default(true),
    feature_influence_threshold: z.number().describe('The minimum outlier score that a document needs to have in order to calculate its feature influence score. Value range: 0-1.').optional().default(0.1),
    method: z.string().describe('The method that outlier detection uses. Available methods are `lof`, `ldof`, `distance_kth_nn`, `distance_knn`, and `ensemble`. The default value is ensemble, which means that outlier detection uses an ensemble of different methods and normalises and combines their individual outlier scores to obtain the overall outlier score.').optional().default('ensemble'),
    n_neighbors: z.number().describe('Defines the value for how many nearest neighbors each method of outlier detection uses to calculate its outlier score. When the value is not set, different values are used for different ensemble members. This default behavior helps improve the diversity in the ensemble; only override it if you are confident that the value you choose is appropriate for the data set.').optional(),
    outlier_fraction: z.number().describe('The proportion of the data set that is assumed to be outlying prior to outlier detection. For example, 0.05 means it is assumed that 5% of values are real outliers and 95% are inliers.').optional(),
    standardization_enabled: z.boolean().describe('If true, the following operation is performed on the columns before computing outlier scores: `(x_i - mean(x_i)) / sd(x_i)`.').optional().default(true)
});

export const ml_types_dataframe_analysis_regression = ml_types_dataframe_analysis.and(z.object({
    loss_function: z.string().describe('The loss function used during regression. Available options are `mse` (mean squared error), `msle` (mean squared logarithmic error), `huber` (Pseudo-Huber loss).').optional().default('mse'),
    loss_function_parameter: z.number().describe('A positive number that is used as a parameter to the `loss_function`.').optional()
}));

export const ml_types_dataframe_analysis_container = z.object({
    classification: ml_types_dataframe_analysis_classification.optional(),
    outlier_detection: ml_types_dataframe_analysis_outlier_detection.optional(),
    regression: ml_types_dataframe_analysis_regression.optional()
});

export const ml_types_dataframe_analytics_field_selection = z.object({
    is_included: z.boolean().describe('Whether the field is selected to be included in the analysis.'),
    is_required: z.boolean().describe('Whether the field is required.'),
    feature_type: z.string().describe('The feature type of this field for the analysis. May be categorical or numerical.').optional(),
    mapping_types: z.array(z.string()).describe('The mapping types of the field.'),
    name: types_field,
    reason: z.string().describe('The reason a field is not selected to be included in the analysis.').optional()
});

export const ml_types_dataframe_analytics_memory_estimation = z.object({
    expected_memory_with_disk: z.string().describe('Estimated memory usage under the assumption that overflowing to disk is allowed during data frame analytics. expected_memory_with_disk is usually smaller than expected_memory_without_disk as using disk allows to limit the main memory needed to perform data frame analytics.'),
    expected_memory_without_disk: z.string().describe('Estimated memory usage under the assumption that the whole data frame analytics should happen in memory (i.e. without overflowing to disk).')
});

export const ml_types_page = z.object({
    from: z.number().describe('Skips the specified number of items.').optional().default(0),
    size: z.number().describe('Specifies the maximum number of items to obtain.').optional().default(10000)
});

export const types_duration_value_unit_seconds = types_unit_seconds;

export const ml_types_bucket_influencer = z.object({
    anomaly_score: z.number().describe('A normalized score between 0-100, which is calculated for each bucket influencer. This score might be updated as\nnewer data is analyzed.'),
    bucket_span: types_duration_value_unit_seconds,
    influencer_field_name: types_field,
    initial_anomaly_score: z.number().describe('The score between 0-100 for each bucket influencer. This score is the initial value that was calculated at the\ntime the bucket was processed.'),
    is_interim: z.boolean().describe('If true, this is an interim result. In other words, the results are calculated based on partial input data.'),
    job_id: types_id,
    probability: z.number().describe('The probability that the bucket has this behavior, in the range 0 to 1. This value can be held to a high precision\nof over 300 decimal places, so the `anomaly_score` is provided as a human-readable and friendly interpretation of\nthis.'),
    raw_anomaly_score: z.number().describe('Internal.'),
    result_type: z.string().describe('Internal. This value is always set to `bucket_influencer`.'),
    timestamp: types_epoch_time_unit_millis,
    timestamp_string: types_date_time.optional()
});

export const ml_types_bucket_summary = z.object({
    anomaly_score: z.number().describe('The maximum anomaly score, between 0-100, for any of the bucket influencers. This is an overall, rate-limited\nscore for the job. All the anomaly records in the bucket contribute to this score. This value might be updated as\nnew data is analyzed.'),
    bucket_influencers: z.array(ml_types_bucket_influencer),
    bucket_span: types_duration_value_unit_seconds,
    event_count: z.number().describe('The number of input data records processed in this bucket.'),
    initial_anomaly_score: z.number().describe('The maximum anomaly score for any of the bucket influencers. This is the initial value that was calculated at the\ntime the bucket was processed.'),
    is_interim: z.boolean().describe('If true, this is an interim result. In other words, the results are calculated based on partial input data.'),
    job_id: types_id,
    processing_time_ms: types_duration_value_unit_millis,
    result_type: z.string().describe('Internal. This value is always set to bucket.'),
    timestamp: types_epoch_time_unit_millis,
    timestamp_string: types_date_time.optional()
});

export const ml_types_calendar_event = z.object({
    calendar_id: types_id.optional(),
    event_id: types_id.optional(),
    description: z.string().describe('A description of the scheduled event.'),
    end_time: types_date_time,
    start_time: types_date_time,
    skip_result: z.boolean().describe('When true the model will not create results for this calendar period.').optional().default(true),
    skip_model_update: z.boolean().describe('When true the model will not be updated for this calendar period.').optional().default(true),
    force_time_shift: z.number().describe('Shift time by this many seconds. For example adjust time for daylight savings changes').optional()
});

export const ml_get_calendars_calendar = z.object({
    calendar_id: types_id,
    description: z.string().describe('A description of the calendar.').optional(),
    job_ids: z.array(types_id).describe('An array of anomaly detection job identifiers.')
});

export const types_category_id = z.string();

export const ml_types_category = z.object({
    category_id: types_ulong,
    examples: z.array(z.string()).describe('A list of examples of actual values that matched the category.'),
    grok_pattern: types_grok_pattern.optional(),
    job_id: types_id,
    max_matching_length: types_ulong,
    partition_field_name: z.string().describe('If per-partition categorization is enabled, this property identifies the field used to segment the categorization. It is not present when per-partition categorization is disabled.').optional(),
    partition_field_value: z.string().describe('If per-partition categorization is enabled, this property identifies the value of the partition_field_name for the category. It is not present when per-partition categorization is disabled.').optional(),
    regex: z.string().describe('A regular expression that is used to search for values that match the category.'),
    terms: z.string().describe('A space separated list of the common tokens that are matched in values of the category.'),
    num_matches: z.number().describe('The number of messages that have been matched by this category. This is only guaranteed to have the latest accurate count after a job _flush or _close').optional(),
    preferred_to_categories: z.array(types_id).describe('A list of category_id entries that this current category encompasses. Any new message that is processed by the categorizer will match against this category and not any of the categories in this list. This is only guaranteed to have the latest accurate list of categories after a job _flush or _close').optional(),
    p: z.string().optional(),
    result_type: z.string(),
    mlcategory: z.string()
});

export const ml_types_api_key_authorization = z.object({
    id: z.string().describe('The identifier for the API key.'),
    name: z.string().describe('The name of the API key.')
});

export const ml_types_dataframe_analytics_authorization = z.object({
    api_key: ml_types_api_key_authorization.optional(),
    roles: z.array(z.string()).describe('If a user ID was used for the most recent update to the job, its roles at the time of the update are listed in the response.').optional(),
    service_account: z.string().describe('If a service account was used for the most recent update to the job, the account name is listed in the response.').optional()
});

export const ml_types_hyperparameters = z.object({
    alpha: z.number().describe('Advanced configuration option.\nMachine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly.\nThis parameter affects loss calculations by acting as a multiplier of the tree depth.\nHigher alpha values result in shallower trees and faster training times.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than or equal to zero.').optional(),
    lambda: z.number().describe('Advanced configuration option.\nRegularization parameter to prevent overfitting on the training data set.\nMultiplies an L2 regularization term which applies to leaf weights of the individual trees in the forest.\nA high lambda value causes training to favor small leaf weights.\nThis behavior makes the prediction function smoother at the expense of potentially not being able to capture relevant relationships between the features and the dependent variable.\nA small lambda value results in large individual trees and slower training.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be a nonnegative value.').optional(),
    gamma: z.number().describe('Advanced configuration option.\nRegularization parameter to prevent overfitting on the training data set.\nMultiplies a linear penalty associated with the size of individual trees in the forest.\nA high gamma value causes training to prefer small trees.\nA small gamma value results in larger individual trees and slower training.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be a nonnegative value.').optional(),
    eta: z.number().describe('Advanced configuration option.\nThe shrinkage applied to the weights.\nSmaller values result in larger forests which have a better generalization error.\nHowever, larger forests cause slower training.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be a value between `0.001` and `1`.').optional(),
    eta_growth_rate_per_tree: z.number().describe('Advanced configuration option.\nSpecifies the rate at which `eta` increases for each new tree that is added to the forest.\nFor example, a rate of 1.05 increases `eta` by 5% for each extra tree.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be between `0.5` and `2`.').optional(),
    feature_bag_fraction: z.number().describe('Advanced configuration option.\nDefines the fraction of features that will be used when selecting a random bag for each candidate split.\nBy default, this value is calculated during hyperparameter optimization.').optional(),
    downsample_factor: z.number().describe('Advanced configuration option.\nControls the fraction of data that is used to compute the derivatives of the loss function for tree training.\nA small value results in the use of a small fraction of the data.\nIf this value is set to be less than 1, accuracy typically improves.\nHowever, too small a value may result in poor convergence for the ensemble and so require more trees.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than zero and less than or equal to 1.').optional(),
    max_attempts_to_add_tree: z.number().describe('If the algorithm fails to determine a non-trivial tree (more than a single leaf), this parameter determines how many of such consecutive failures are tolerated.\nOnce the number of attempts exceeds the threshold, the forest training stops.').optional(),
    max_optimization_rounds_per_hyperparameter: z.number().describe('Advanced configuration option.\nA multiplier responsible for determining the maximum number of hyperparameter optimization steps in the Bayesian optimization procedure.\nThe maximum number of steps is determined based on the number of undefined hyperparameters times the maximum optimization rounds per hyperparameter.\nBy default, this value is calculated during hyperparameter optimization.').optional(),
    max_trees: z.number().describe('Advanced configuration option.\nDefines the maximum number of decision trees in the forest.\nThe maximum value is 2000.\nBy default, this value is calculated during hyperparameter optimization.').optional(),
    num_folds: z.number().describe('The maximum number of folds for the cross-validation procedure.').optional(),
    num_splits_per_feature: z.number().describe('Determines the maximum number of splits for every feature that can occur in a decision tree when the tree is trained.').optional(),
    soft_tree_depth_limit: z.number().describe('Advanced configuration option.\nMachine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly.\nThis soft limit combines with the `soft_tree_depth_tolerance` to penalize trees that exceed the specified depth; the regularized loss increases quickly beyond this depth.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than or equal to 0.').optional(),
    soft_tree_depth_tolerance: z.number().describe('Advanced configuration option.\nThis option controls how quickly the regularized loss increases when the tree depth exceeds `soft_tree_depth_limit`.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than or equal to 0.01.').optional()
});

export const ml_types_timing_stats = z.object({
    elapsed_time: types_duration_value_unit_millis,
    iteration_time: types_duration_value_unit_millis.optional()
});

export const ml_types_validation_loss = z.object({
    fold_values: z.array(z.string()).describe('Validation loss values for every added decision tree during the forest growing procedure.'),
    loss_type: z.string().describe('The type of the loss metric. For example, binomial_logistic.')
});

export const ml_types_dataframe_analytics_stats_hyperparameters = z.object({
    hyperparameters: ml_types_hyperparameters,
    iteration: z.number().describe('The number of iterations on the analysis.'),
    timestamp: types_epoch_time_unit_millis,
    timing_stats: ml_types_timing_stats,
    validation_loss: ml_types_validation_loss
});

export const ml_types_outlier_detection_parameters = z.object({
    compute_feature_influence: z.boolean().describe('Specifies whether the feature influence calculation is enabled.').optional().default(true),
    feature_influence_threshold: z.number().describe('The minimum outlier score that a document needs to have in order to calculate its feature influence score.\nValue range: 0-1').optional().default(0.1),
    method: z.string().describe('The method that outlier detection uses.\nAvailable methods are `lof`, `ldof`, `distance_kth_nn`, `distance_knn`, and `ensemble`.\nThe default value is ensemble, which means that outlier detection uses an ensemble of different methods and normalises and combines their individual outlier scores to obtain the overall outlier score.').optional(),
    n_neighbors: z.number().describe('Defines the value for how many nearest neighbors each method of outlier detection uses to calculate its outlier score.\nWhen the value is not set, different values are used for different ensemble members.\nThis default behavior helps improve the diversity in the ensemble; only override it if you are confident that the value you choose is appropriate for the data set.').optional(),
    outlier_fraction: z.number().describe('The proportion of the data set that is assumed to be outlying prior to outlier detection.\nFor example, 0.05 means it is assumed that 5% of values are real outliers and 95% are inliers.').optional(),
    standardization_enabled: z.boolean().describe('If `true`, the following operation is performed on the columns before computing outlier scores: (x_i - mean(x_i)) / sd(x_i).').optional().default(true)
});

export const ml_types_dataframe_analytics_stats_outlier_detection = z.object({
    parameters: ml_types_outlier_detection_parameters,
    timestamp: types_epoch_time_unit_millis,
    timing_stats: ml_types_timing_stats
});

export const ml_types_dataframe_analytics_stats_container = z.object({
    classification_stats: ml_types_dataframe_analytics_stats_hyperparameters.optional(),
    outlier_detection_stats: ml_types_dataframe_analytics_stats_outlier_detection.optional(),
    regression_stats: ml_types_dataframe_analytics_stats_hyperparameters.optional()
});

export const ml_types_dataframe_analytics_stats_data_counts = z.object({
    skipped_docs_count: z.number().describe('The number of documents that are skipped during the analysis because they contained values that are not supported by the analysis. For example, outlier detection does not support missing fields so it skips documents with missing fields. Likewise, all types of analysis skip documents that contain arrays with more than one element.'),
    test_docs_count: z.number().describe('The number of documents that are not used for training the model and can be used for testing.'),
    training_docs_count: z.number().describe('The number of documents that are used for training the model.')
});

export const ml_types_dataframe_analytics_stats_memory_usage = z.object({
    memory_reestimate_bytes: z.number().describe('This value is present when the status is hard_limit and it is a new estimate of how much memory the job needs.').optional(),
    peak_usage_bytes: z.number().describe('The number of bytes used at the highest peak of memory usage.'),
    status: z.string().describe('The memory usage status.'),
    timestamp: types_epoch_time_unit_millis.optional()
});

export const types_node_attributes = z.object({
    attributes: z.record(z.string()).describe('Lists node attributes.'),
    ephemeral_id: types_id,
    id: types_node_id.optional(),
    name: types_node_name,
    transport_address: types_transport_address
});

export const ml_types_dataframe_analytics_stats_progress = z.object({
    phase: z.string().describe('Defines the phase of the data frame analytics job.'),
    progress_percent: z.number().describe('The progress that the data frame analytics job has made expressed in percentage.')
});

export const ml_types_dataframe_state = z.enum([
    'started',
    'stopped',
    'starting',
    'stopping',
    'failed'
]);

export const ml_types_dataframe_analytics = z.object({
    analysis_stats: ml_types_dataframe_analytics_stats_container.optional(),
    assignment_explanation: z.string().describe('For running jobs only, contains messages relating to the selection of a node to run the job.').optional(),
    data_counts: ml_types_dataframe_analytics_stats_data_counts,
    id: types_id,
    memory_usage: ml_types_dataframe_analytics_stats_memory_usage,
    node: types_node_attributes.optional(),
    progress: z.array(ml_types_dataframe_analytics_stats_progress).describe('The progress report of the data frame analytics job by phase.'),
    state: ml_types_dataframe_state
});

/**
 * Alternative representation of DiscoveryNode used in ml.get_job_stats and ml.get_datafeed_stats
 */
export const ml_types_discovery_node_compact = z.object({
    name: types_name,
    ephemeral_id: types_id,
    id: types_id,
    transport_address: types_transport_address,
    attributes: z.record(z.string())
}).describe('Alternative representation of DiscoveryNode used in ml.get_job_stats and ml.get_datafeed_stats');

/**
 * Time unit for fractional milliseconds
 */
export const types_unit_float_millis = z.number().describe('Time unit for fractional milliseconds');

export const types_duration_value_unit_float_millis = types_unit_float_millis;

export const ml_types_exponential_average_calculation_context = z.object({
    incremental_metric_value_ms: types_duration_value_unit_float_millis,
    latest_timestamp: types_epoch_time_unit_millis.optional(),
    previous_exponential_average_ms: types_duration_value_unit_float_millis.optional()
});

export const ml_types_datafeed_timing_stats = z.object({
    bucket_count: z.number().describe('The number of buckets processed.'),
    exponential_average_search_time_per_hour_ms: types_duration_value_unit_float_millis,
    exponential_average_calculation_context: ml_types_exponential_average_calculation_context.optional(),
    job_id: types_id,
    search_count: z.number().describe('The number of searches run by the datafeed.'),
    total_search_time_ms: types_duration_value_unit_float_millis,
    average_search_time_per_bucket_ms: types_duration_value_unit_float_millis.optional()
});

export const ml_types_running_state_search_interval = z.object({
    end: types_duration.optional(),
    end_ms: types_duration_value_unit_millis,
    start: types_duration.optional(),
    start_ms: types_duration_value_unit_millis
});

export const ml_types_datafeed_running_state = z.object({
    real_time_configured: z.boolean().describe('Indicates if the datafeed is "real-time"; meaning that the datafeed has no configured `end` time.'),
    real_time_running: z.boolean().describe('Indicates whether the datafeed has finished running on the available past data.\nFor datafeeds without a configured `end` time, this means that the datafeed is now running on "real-time" data.'),
    search_interval: ml_types_running_state_search_interval.optional()
});

export const ml_types_datafeed_stats = z.object({
    assignment_explanation: z.string().describe('For started datafeeds only, contains messages relating to the selection of a node.').optional(),
    datafeed_id: types_id,
    node: ml_types_discovery_node_compact.optional(),
    state: ml_types_datafeed_state,
    timing_stats: ml_types_datafeed_timing_stats.optional(),
    running_state: ml_types_datafeed_running_state.optional()
});

export const ml_types_datafeed_authorization = z.object({
    api_key: ml_types_api_key_authorization.optional(),
    roles: z.array(z.string()).describe('If a user ID was used for the most recent update to the datafeed, its roles at the time of the update are listed in the response.').optional(),
    service_account: z.string().describe('If a service account was used for the most recent update to the datafeed, the account name is listed in the response.').optional()
});

export const ml_types_chunking_mode = z.enum([
    'auto',
    'manual',
    'off'
]);

export const ml_types_chunking_config = z.object({
    mode: ml_types_chunking_mode,
    time_span: types_duration.optional()
});

export const ml_types_delayed_data_check_config = z.object({
    check_window: types_duration.optional(),
    enabled: z.boolean().describe('Specifies whether the datafeed periodically checks for delayed data.')
});

/**
 * Controls how to deal with unavailable concrete indices (closed or missing), how wildcard expressions are expanded
 * to actual indices (all, closed or open indices) and how to deal with wildcard expressions that resolve to no indices.
 */
export const types_indices_options = z.object({
    allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only\nmissing or closed indices. This behavior applies even if the request targets other open indices. For example,\na request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
    expand_wildcards: types_expand_wildcards.optional(),
    ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional().default(false),
    ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional().default(true)
}).describe('Controls how to deal with unavailable concrete indices (closed or missing), how wildcard expressions are expanded\nto actual indices (all, closed or open indices) and how to deal with wildcard expressions that resolve to no indices.');

export const ml_types_filter = z.object({
    description: z.string().describe('A description of the filter.').optional(),
    filter_id: types_id,
    items: z.array(z.string()).describe('An array of strings which is the filter item list.')
});

export const ml_types_influencer = z.object({
    bucket_span: types_duration_value_unit_seconds,
    influencer_score: z.number().describe('A normalized score between 0-100, which is based on the probability of the influencer in this bucket aggregated\nacross detectors. Unlike `initial_influencer_score`, this value is updated by a re-normalization process as new\ndata is analyzed.'),
    influencer_field_name: types_field,
    influencer_field_value: z.string().describe('The entity that influenced, contributed to, or was to blame for the anomaly.'),
    initial_influencer_score: z.number().describe('A normalized score between 0-100, which is based on the probability of the influencer aggregated across detectors.\nThis is the initial value that was calculated at the time the bucket was processed.'),
    is_interim: z.boolean().describe('If true, this is an interim result. In other words, the results are calculated based on partial input data.'),
    job_id: types_id,
    probability: z.number().describe('The probability that the influencer has this behavior, in the range 0 to 1. This value can be held to a high\nprecision of over 300 decimal places, so the `influencer_score` is provided as a human-readable and friendly\ninterpretation of this value.'),
    result_type: z.string().describe('Internal. This value is always set to `influencer`.'),
    timestamp: types_epoch_time_unit_millis,
    foo: z.string().describe('Additional influencer properties are added, depending on the fields being analyzed. For example, if its\nanalyzing `user_name` as an influencer, a field `user_name` is added to the result document. This\ninformation enables you to filter the anomaly results more easily.').optional()
});

export const ml_types_data_counts = z.object({
    bucket_count: z.number(),
    earliest_record_timestamp: z.number().optional(),
    empty_bucket_count: z.number(),
    input_bytes: z.number(),
    input_field_count: z.number(),
    input_record_count: z.number(),
    invalid_date_count: z.number(),
    job_id: types_id,
    last_data_time: z.number().optional(),
    latest_empty_bucket_timestamp: z.number().optional(),
    latest_record_timestamp: z.number().optional(),
    latest_sparse_bucket_timestamp: z.number().optional(),
    latest_bucket_timestamp: z.number().optional(),
    log_time: z.number().optional(),
    missing_field_count: z.number(),
    out_of_order_timestamp_count: z.number(),
    processed_field_count: z.number(),
    processed_record_count: z.number(),
    sparse_bucket_count: z.number()
});

export const ml_types_job_statistics = z.object({
    avg: z.number(),
    max: z.number(),
    min: z.number(),
    total: z.number()
});

export const ml_types_job_forecast_statistics = z.object({
    memory_bytes: ml_types_job_statistics.optional(),
    processing_time_ms: ml_types_job_statistics.optional(),
    records: ml_types_job_statistics.optional(),
    status: z.record(z.number()).optional(),
    total: z.number(),
    forecasted_jobs: z.number()
});

export const ml_types_model_size_stats = z.object({
    bucket_allocation_failures_count: z.number(),
    job_id: types_id,
    log_time: types_date_time,
    memory_status: ml_types_memory_status,
    model_bytes: types_byte_size,
    model_bytes_exceeded: types_byte_size.optional(),
    model_bytes_memory_limit: types_byte_size.optional(),
    output_memory_allocator_bytes: types_byte_size.optional(),
    peak_model_bytes: types_byte_size.optional(),
    assignment_memory_basis: z.string().optional(),
    result_type: z.string(),
    total_by_field_count: z.number(),
    total_over_field_count: z.number(),
    total_partition_field_count: z.number(),
    categorization_status: ml_types_categorization_status,
    categorized_doc_count: z.number(),
    dead_category_count: z.number(),
    failed_category_count: z.number(),
    frequent_category_count: z.number(),
    rare_category_count: z.number(),
    total_category_count: z.number(),
    timestamp: z.number().optional()
});

export const ml_types_job_timing_stats = z.object({
    average_bucket_processing_time_ms: types_duration_value_unit_float_millis.optional(),
    bucket_count: z.number(),
    exponential_average_bucket_processing_time_ms: types_duration_value_unit_float_millis.optional(),
    exponential_average_bucket_processing_time_per_hour_ms: types_duration_value_unit_float_millis,
    job_id: types_id,
    total_bucket_processing_time_ms: types_duration_value_unit_float_millis,
    maximum_bucket_processing_time_ms: types_duration_value_unit_float_millis.optional(),
    minimum_bucket_processing_time_ms: types_duration_value_unit_float_millis.optional()
});

export const ml_types_job_stats = z.object({
    assignment_explanation: z.string().describe('For open anomaly detection jobs only, contains messages relating to the selection of a node to run the job.').optional(),
    data_counts: ml_types_data_counts,
    forecasts_stats: ml_types_job_forecast_statistics,
    job_id: z.string().describe('Identifier for the anomaly detection job.'),
    model_size_stats: ml_types_model_size_stats,
    node: ml_types_discovery_node_compact.optional(),
    open_time: types_date_time.optional(),
    state: ml_types_job_state,
    timing_stats: ml_types_job_timing_stats,
    deleting: z.boolean().describe('Indicates that the process of deleting the job is in progress but not yet completed. It is only reported when `true`.').optional()
});

export const ml_types_analysis_limits = z.object({
    categorization_examples_limit: z.number().describe('The maximum number of examples stored per category in memory and in the results data store. If you increase this value, more examples are available, however it requires that you have more storage available. If you set this value to 0, no examples are stored. NOTE: The `categorization_examples_limit` applies only to analysis that uses categorization.').optional().default(4),
    model_memory_limit: types_byte_size.optional()
});

export const ml_types_job_blocked_reason = z.enum([
    'delete',
    'reset',
    'revert'
]);

export const ml_types_job_blocked = z.object({
    reason: ml_types_job_blocked_reason,
    task_id: types_task_id.optional()
});

/**
 * Custom metadata about the job
 */
export const ml_types_custom_settings = z.record(z.unknown()).describe('Custom metadata about the job');

export const ml_types_data_description = z.object({
    format: z.string().describe('Only JSON format is supported at this time.').optional(),
    time_field: types_field.optional(),
    time_format: z.string().describe('The time format, which can be `epoch`, `epoch_ms`, or a custom pattern. The value `epoch` refers to UNIX or Epoch time (the number of seconds since 1 Jan 1970). The value `epoch_ms` indicates that time is measured in milliseconds since the epoch. The `epoch` and `epoch_ms` time formats accept either integer or real values. Custom patterns must conform to the Java DateTimeFormatter class. When you use date-time formatting patterns, it is recommended that you provide the full date, time and time zone. For example: `yyyy-MM-dd\'T\'HH:mm:ssX`. If the pattern that you specify is not sufficient to produce a complete timestamp, job creation fails.').optional().default('epoch'),
    field_delimiter: z.string().optional()
});

export const ml_types_model_plot_config = z.object({
    annotations_enabled: z.boolean().describe('If true, enables calculation and storage of the model change annotations for each entity that is being analyzed.').optional().default(true),
    enabled: z.boolean().describe('If true, enables calculation and storage of the model bounds for each entity that is being analyzed.').optional().default(false),
    terms: types_field.optional()
});

export const ml_get_memory_stats_jvm_stats = z.object({
    heap_max: types_byte_size.optional(),
    heap_max_in_bytes: z.number().describe('Maximum amount of memory, in bytes, available for use by the heap.'),
    java_inference: types_byte_size.optional(),
    java_inference_in_bytes: z.number().describe('Amount of Java heap, in bytes, currently being used for caching inference models.'),
    java_inference_max: types_byte_size.optional(),
    java_inference_max_in_bytes: z.number().describe('Maximum amount of Java heap, in bytes, to be used for caching inference models.')
});

export const ml_get_memory_stats_mem_ml_stats = z.object({
    anomaly_detectors: types_byte_size.optional(),
    anomaly_detectors_in_bytes: z.number().describe('Amount of native memory, in bytes, set aside for anomaly detection jobs.'),
    data_frame_analytics: types_byte_size.optional(),
    data_frame_analytics_in_bytes: z.number().describe('Amount of native memory, in bytes, set aside for data frame analytics jobs.'),
    max: types_byte_size.optional(),
    max_in_bytes: z.number().describe('Maximum amount of native memory (separate to the JVM heap), in bytes, that may be used by machine learning native processes.'),
    native_code_overhead: types_byte_size.optional(),
    native_code_overhead_in_bytes: z.number().describe('Amount of native memory, in bytes, set aside for loading machine learning native code shared libraries.'),
    native_inference: types_byte_size.optional(),
    native_inference_in_bytes: z.number().describe('Amount of native memory, in bytes, set aside for trained models that have a PyTorch model_type.')
});

export const ml_get_memory_stats_mem_stats = z.object({
    adjusted_total: types_byte_size.optional(),
    adjusted_total_in_bytes: z.number().describe('If the amount of physical memory has been overridden using the `es.total_memory_bytes` system property\nthen this reports the overridden value in bytes. Otherwise it reports the same value as `total_in_bytes`.'),
    total: types_byte_size.optional(),
    total_in_bytes: z.number().describe('Total amount of physical memory in bytes.'),
    ml: ml_get_memory_stats_mem_ml_stats
});

export const ml_get_memory_stats_memory = z.object({
    attributes: z.record(z.string()),
    jvm: ml_get_memory_stats_jvm_stats,
    mem: ml_get_memory_stats_mem_stats,
    name: types_name,
    roles: z.array(z.string()).describe('Roles assigned to the node.'),
    transport_address: types_transport_address,
    ephemeral_id: types_id
});

export const ml_types_snapshot_upgrade_state = z.enum([
    'loading_old_state',
    'saving_new_state',
    'stopped',
    'failed'
]);

export const ml_types_discovery_node_content = z.object({
    name: types_name.optional(),
    ephemeral_id: types_id,
    transport_address: types_transport_address,
    external_id: z.string(),
    attributes: z.record(z.string()),
    roles: z.array(z.string()),
    version: types_version_string,
    min_index_version: z.number(),
    max_index_version: z.number()
});

export const ml_types_discovery_node = z.record(ml_types_discovery_node_content);

export const ml_types_model_snapshot_upgrade = z.object({
    job_id: types_id,
    snapshot_id: types_id,
    state: ml_types_snapshot_upgrade_state,
    node: ml_types_discovery_node,
    assignment_explanation: z.string()
});

export const ml_types_model_snapshot = z.object({
    description: z.string().describe('An optional description of the job.').optional(),
    job_id: types_id,
    latest_record_time_stamp: z.number().describe('The timestamp of the latest processed record.').optional(),
    latest_result_time_stamp: z.number().describe('The timestamp of the latest bucket result.').optional(),
    min_version: types_version_string,
    model_size_stats: ml_types_model_size_stats.optional(),
    retain: z.boolean().describe('If true, this snapshot will not be deleted during automatic cleanup of snapshots older than model_snapshot_retention_days. However, this snapshot will be deleted when the job is deleted. The default value is false.'),
    snapshot_doc_count: z.number().describe('For internal use only.'),
    snapshot_id: types_id,
    timestamp: z.number().describe('The creation timestamp for the snapshot.')
});

export const ml_types_overall_bucket_job = z.object({
    job_id: types_id,
    max_anomaly_score: z.number()
});

export const ml_types_overall_bucket = z.object({
    bucket_span: types_duration_value_unit_seconds,
    is_interim: z.boolean().describe('If true, this is an interim result. In other words, the results are calculated based on partial input data.'),
    jobs: z.array(ml_types_overall_bucket_job).describe('An array of objects that contain the max_anomaly_score per job_id.'),
    overall_score: z.number().describe('The top_n average of the maximum bucket anomaly_score per job.'),
    result_type: z.string().describe('Internal. This is always set to overall_bucket.'),
    timestamp: types_epoch_time_unit_millis,
    timestamp_string: types_date_time.optional()
});

export const ml_types_anomaly_explanation = z.object({
    anomaly_characteristics_impact: z.number().describe('Impact from the duration and magnitude of the detected anomaly relative to the historical average.').optional(),
    anomaly_length: z.number().describe('Length of the detected anomaly in the number of buckets.').optional(),
    anomaly_type: z.string().describe('Type of the detected anomaly: `spike` or `dip`.').optional(),
    high_variance_penalty: z.boolean().describe('Indicates reduction of anomaly score for the bucket with large confidence intervals. If a bucket has large confidence intervals, the score is reduced.').optional(),
    incomplete_bucket_penalty: z.boolean().describe('If the bucket contains fewer samples than expected, the score is reduced.').optional(),
    lower_confidence_bound: z.number().describe('Lower bound of the 95% confidence interval.').optional(),
    multi_bucket_impact: z.number().describe('Impact of the deviation between actual and typical values in the past 12 buckets.').optional(),
    single_bucket_impact: z.number().describe('Impact of the deviation between actual and typical values in the current bucket.').optional(),
    typical_value: z.number().describe('Typical (expected) value for this bucket.').optional(),
    upper_confidence_bound: z.number().describe('Upper bound of the 95% confidence interval.').optional()
});

export const ml_types_geo_results = z.object({
    actual_point: z.string().describe('The actual value for the bucket formatted as a `geo_point`.').optional(),
    typical_point: z.string().describe('The typical value for the bucket formatted as a `geo_point`.').optional()
});

export const ml_types_influence = z.object({
    influencer_field_name: z.string(),
    influencer_field_values: z.array(z.string())
});

export const ml_types_anomaly_cause = z.object({
    actual: z.array(z.number()).optional(),
    by_field_name: types_name.optional(),
    by_field_value: z.string().optional(),
    correlated_by_field_value: z.string().optional(),
    field_name: types_field.optional(),
    function: z.string().optional(),
    function_description: z.string().optional(),
    geo_results: ml_types_geo_results.optional(),
    influencers: z.array(ml_types_influence).optional(),
    over_field_name: types_name.optional(),
    over_field_value: z.string().optional(),
    partition_field_name: z.string().optional(),
    partition_field_value: z.string().optional(),
    probability: z.number(),
    typical: z.array(z.number()).optional()
});

export const ml_types_anomaly = z.object({
    actual: z.array(z.number()).describe('The actual value for the bucket.').optional(),
    anomaly_score_explanation: ml_types_anomaly_explanation.optional(),
    bucket_span: types_duration_value_unit_seconds,
    by_field_name: z.string().describe('The field used to split the data. In particular, this property is used for analyzing the splits with respect to their own history. It is used for finding unusual values in the context of the split.').optional(),
    by_field_value: z.string().describe('The value of `by_field_name`.').optional(),
    causes: z.array(ml_types_anomaly_cause).describe('For population analysis, an over field must be specified in the detector. This property contains an array of anomaly records that are the causes for the anomaly that has been identified for the over field. This sub-resource contains the most anomalous records for the `over_field_name`. For scalability reasons, a maximum of the 10 most significant causes of the anomaly are returned. As part of the core analytical modeling, these low-level anomaly records are aggregated for their parent over field record. The `causes` resource contains similar elements to the record resource, namely `actual`, `typical`, `geo_results.actual_point`, `geo_results.typical_point`, `*_field_name` and `*_field_value`. Probability and scores are not applicable to causes.').optional(),
    detector_index: z.number().describe('A unique identifier for the detector.'),
    field_name: z.string().describe('Certain functions require a field to operate on, for example, `sum()`. For those functions, this value is the name of the field to be analyzed.').optional(),
    function: z.string().describe('The function in which the anomaly occurs, as specified in the detector configuration. For example, `max`.').optional(),
    function_description: z.string().describe('The description of the function in which the anomaly occurs, as specified in the detector configuration.').optional(),
    geo_results: ml_types_geo_results.optional(),
    influencers: z.array(ml_types_influence).describe('If influencers were specified in the detector configuration, this array contains influencers that contributed to or were to blame for an anomaly.').optional(),
    initial_record_score: z.number().describe('A normalized score between 0-100, which is based on the probability of the anomalousness of this record. This is the initial value that was calculated at the time the bucket was processed.'),
    is_interim: z.boolean().describe('If true, this is an interim result. In other words, the results are calculated based on partial input data.'),
    job_id: z.string().describe('Identifier for the anomaly detection job.'),
    over_field_name: z.string().describe('The field used to split the data. In particular, this property is used for analyzing the splits with respect to the history of all splits. It is used for finding unusual values in the population of all splits.').optional(),
    over_field_value: z.string().describe('The value of `over_field_name`.').optional(),
    partition_field_name: z.string().describe('The field used to segment the analysis. When you use this property, you have completely independent baselines for each value of this field.').optional(),
    partition_field_value: z.string().describe('The value of `partition_field_name`.').optional(),
    probability: z.number().describe('The probability of the individual anomaly occurring, in the range 0 to 1. For example, `0.0000772031`. This value can be held to a high precision of over 300 decimal places, so the `record_score` is provided as a human-readable and friendly interpretation of this.'),
    record_score: z.number().describe('A normalized score between 0-100, which is based on the probability of the anomalousness of this record. Unlike `initial_record_score`, this value will be updated by a re-normalization process as new data is analyzed.'),
    result_type: z.string().describe('Internal. This is always set to `record`.'),
    timestamp: types_epoch_time_unit_millis,
    typical: z.array(z.number()).describe('The typical value for the bucket, according to analytical modeling.').optional()
});

export const ml_types_include = z.enum([
    'definition',
    'feature_importance_baseline',
    'hyperparameters',
    'total_feature_importance',
    'definition_status'
]);

export const ml_types_trained_model_type = z.enum([
    'tree_ensemble',
    'lang_ident',
    'pytorch'
]);

export const ml_types_tokenization_truncate = z.enum([
    'first',
    'second',
    'none'
]);

export const ml_types_common_tokenization_config = z.object({
    do_lower_case: z.boolean().describe('Should the tokenizer lower case the text').optional().default(false),
    max_sequence_length: z.number().describe('Maximum input sequence length for the model').optional().default(512),
    span: z.number().describe('Tokenization spanning options. Special value of -1 indicates no spanning takes place').optional().default(-1),
    truncate: ml_types_tokenization_truncate.optional(),
    with_special_tokens: z.boolean().describe('Is tokenization completed with special tokens').optional().default(true)
});

/**
 * BERT and MPNet tokenization configuration options
 */
export const ml_types_nlp_bert_tokenization_config = ml_types_common_tokenization_config.and(z.record(z.unknown()));

/**
 * RoBERTa tokenization configuration options
 */
export const ml_types_nlp_roberta_tokenization_config = ml_types_common_tokenization_config.and(z.object({
    add_prefix_space: z.boolean().describe('Should the tokenizer prefix input with a space character').optional().default(false)
}));

export const ml_types_xlm_roberta_tokenization_config = ml_types_common_tokenization_config.and(z.record(z.unknown()));

/**
 * Tokenization options stored in inference configuration
 */
export const ml_types_tokenization_config_container = z.object({
    bert: ml_types_nlp_bert_tokenization_config.optional(),
    bert_ja: ml_types_nlp_bert_tokenization_config.optional(),
    mpnet: ml_types_nlp_bert_tokenization_config.optional(),
    roberta: ml_types_nlp_roberta_tokenization_config.optional(),
    xlm_roberta: ml_types_xlm_roberta_tokenization_config.optional()
}).describe('Tokenization options stored in inference configuration');

export const ml_types_vocabulary = z.object({
    index: types_index_name
});

/**
 * Text classification configuration options
 */
export const ml_types_text_classification_inference_options = z.object({
    num_top_classes: z.number().describe('Specifies the number of top class predictions to return. Defaults to 0.').optional(),
    tokenization: ml_types_tokenization_config_container.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    classification_labels: z.array(z.string()).describe('Classification labels to apply other than the stored labels. Must have the same deminsions as the default configured labels').optional(),
    vocabulary: ml_types_vocabulary.optional()
}).describe('Text classification configuration options');

/**
 * Zero shot classification configuration options
 */
export const ml_types_zero_shot_classification_inference_options = z.object({
    tokenization: ml_types_tokenization_config_container.optional(),
    hypothesis_template: z.string().describe('Hypothesis template used when tokenizing labels for prediction').optional().default('"This example is {}."'),
    classification_labels: z.array(z.string()).describe('The zero shot classification labels indicating entailment, neutral, and contradiction\nMust contain exactly and only entailment, neutral, and contradiction'),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    multi_label: z.boolean().describe('Indicates if more than one true label exists.').optional().default(false),
    labels: z.array(z.string()).describe('The labels to predict.').optional()
}).describe('Zero shot classification configuration options');

/**
 * Fill mask inference options
 */
export const ml_types_fill_mask_inference_options = z.object({
    mask_token: z.string().describe('The string/token which will be removed from incoming documents and replaced with the inference prediction(s).\nIn a response, this field contains the mask token for the specified model/tokenizer. Each model and tokenizer\nhas a predefined mask token which cannot be changed. Thus, it is recommended not to set this value in requests.\nHowever, if this field is present in a request, its value must match the predefined value for that model/tokenizer,\notherwise the request will fail.').optional(),
    num_top_classes: z.number().describe('Specifies the number of top class predictions to return. Defaults to 0.').optional(),
    tokenization: ml_types_tokenization_config_container.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    vocabulary: ml_types_vocabulary.optional()
}).describe('Fill mask inference options');

/**
 * Named entity recognition options
 */
export const ml_types_ner_inference_options = z.object({
    tokenization: ml_types_tokenization_config_container.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    classification_labels: z.array(z.string()).describe('The token classification labels. Must be IOB formatted tags').optional(),
    vocabulary: ml_types_vocabulary.optional()
}).describe('Named entity recognition options');

/**
 * Pass through configuration options
 */
export const ml_types_pass_through_inference_options = z.object({
    tokenization: ml_types_tokenization_config_container.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    vocabulary: ml_types_vocabulary.optional()
}).describe('Pass through configuration options');

/**
 * Text embedding inference options
 */
export const ml_types_text_embedding_inference_options = z.object({
    embedding_size: z.number().describe('The number of dimensions in the embedding output').optional(),
    tokenization: ml_types_tokenization_config_container.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    vocabulary: ml_types_vocabulary.optional()
}).describe('Text embedding inference options');

/**
 * Text expansion inference options
 */
export const ml_types_text_expansion_inference_options = z.object({
    tokenization: ml_types_tokenization_config_container.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    vocabulary: ml_types_vocabulary.optional()
}).describe('Text expansion inference options');

/**
 * Question answering inference options
 */
export const ml_types_question_answering_inference_options = z.object({
    num_top_classes: z.number().describe('Specifies the number of top class predictions to return. Defaults to 0.').optional(),
    tokenization: ml_types_tokenization_config_container.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    max_answer_length: z.number().describe('The maximum answer length to consider').optional()
}).describe('Question answering inference options');

export const ml_types_trained_model_config_input = z.object({
    field_names: z.array(types_field).describe('An array of input field names for the model.')
});

export const ml_types_hyperparameter = z.object({
    absolute_importance: z.number().describe('A positive number showing how much the parameter influences the variation of the loss function. For hyperparameters with values that are not specified by the user but tuned during hyperparameter optimization.').optional(),
    name: types_name,
    relative_importance: z.number().describe('A number between 0 and 1 showing the proportion of influence on the variation of the loss function among all tuned hyperparameters. For hyperparameters with values that are not specified by the user but tuned during hyperparameter optimization.').optional(),
    supplied: z.boolean().describe('Indicates if the hyperparameter is specified by the user (true) or optimized (false).'),
    value: z.number().describe('The value of the hyperparameter, either optimized or specified by the user.')
});

export const ml_types_total_feature_importance_statistics = z.object({
    mean_magnitude: z.number().describe('The average magnitude of this feature across all the training data. This value is the average of the absolute values of the importance for this feature.'),
    max: z.number().describe('The maximum importance value across all the training data for this feature.'),
    min: z.number().describe('The minimum importance value across all the training data for this feature.')
});

export const ml_types_total_feature_importance_class = z.object({
    class_name: types_name,
    importance: z.array(ml_types_total_feature_importance_statistics).describe('A collection of feature importance statistics related to the training data set for this particular feature.')
});

export const ml_types_total_feature_importance = z.object({
    feature_name: types_name,
    importance: z.array(ml_types_total_feature_importance_statistics).describe('A collection of feature importance statistics related to the training data set for this particular feature.'),
    classes: z.array(ml_types_total_feature_importance_class).describe('If the trained model is a classification model, feature importance statistics are gathered per target class value.')
});

export const ml_types_trained_model_config_metadata = z.object({
    model_aliases: z.array(z.string()).optional(),
    feature_importance_baseline: z.record(z.string()).describe('An object that contains the baseline for feature importance values. For regression analysis, it is a single value. For classification analysis, there is a value for each class.').optional(),
    hyperparameters: z.array(ml_types_hyperparameter).describe('List of the available hyperparameters optimized during the fine_parameter_tuning phase as well as specified by the user.').optional(),
    total_feature_importance: z.array(ml_types_total_feature_importance).describe('An array of the total feature importance for each feature used from the training data set. This array of objects is returned if data frame analytics trained the model and the request includes total_feature_importance in the include request parameter.').optional()
});

export const ml_types_trained_model_prefix_strings = z.object({
    ingest: z.string().describe('String prepended to input at ingest').optional(),
    search: z.string().describe('String prepended to input at search').optional()
});

export const ml_types_model_package_config = z.object({
    create_time: types_epoch_time_unit_millis.optional(),
    description: z.string().optional(),
    inference_config: z.record(z.record(z.unknown())).optional(),
    metadata: types_metadata.optional(),
    minimum_version: z.string().optional(),
    model_repository: z.string().optional(),
    model_type: z.string().optional(),
    packaged_model_id: types_id,
    platform_architecture: z.string().optional(),
    prefix_strings: ml_types_trained_model_prefix_strings.optional(),
    size: types_byte_size.optional(),
    sha256: z.string().optional(),
    tags: z.array(z.string()).optional(),
    vocabulary_file: z.string().optional()
});

export const ml_types_trained_model_location_index = z.object({
    name: types_index_name
});

export const ml_types_trained_model_location = z.object({
    index: ml_types_trained_model_location_index
});

export const ml_types_adaptive_allocations_settings = z.object({
    enabled: z.boolean().describe('If true, adaptive_allocations is enabled'),
    min_number_of_allocations: z.number().describe('Specifies the minimum number of allocations to scale to.\nIf set, it must be greater than or equal to 0.\nIf not defined, the deployment scales to 0.').optional(),
    max_number_of_allocations: z.number().describe('Specifies the maximum number of allocations to scale to.\nIf set, it must be greater than or equal to min_number_of_allocations.').optional()
});

export const ml_types_deployment_allocation_state = z.enum([
    'started',
    'starting',
    'fully_allocated'
]);

export const ml_types_trained_model_deployment_allocation_status = z.object({
    allocation_count: z.number().describe('The current number of nodes where the model is allocated.'),
    state: ml_types_deployment_allocation_state,
    target_allocation_count: z.number().describe('The desired number of nodes for model allocation.')
});

export const ml_types_routing_state = z.enum([
    'failed',
    'started',
    'starting',
    'stopped',
    'stopping'
]);

export const ml_types_trained_model_assignment_routing_state_and_reason = z.object({
    reason: z.string().describe('The reason for the current state. It is usually populated only when the\n`routing_state` is `failed`.').optional(),
    routing_state: ml_types_routing_state
});

export const ml_types_trained_model_deployment_nodes_stats = z.object({
    average_inference_time_ms: types_duration_value_unit_float_millis.optional(),
    average_inference_time_ms_last_minute: types_duration_value_unit_float_millis.optional(),
    average_inference_time_ms_excluding_cache_hits: types_duration_value_unit_float_millis.optional(),
    error_count: z.number().describe('The number of errors when evaluating the trained model.').optional(),
    inference_count: z.number().describe('The total number of inference calls made against this node for this model.').optional(),
    inference_cache_hit_count: z.number().optional(),
    inference_cache_hit_count_last_minute: z.number().optional(),
    last_access: types_epoch_time_unit_millis.optional(),
    node: ml_types_discovery_node.optional(),
    number_of_allocations: z.number().describe('The number of allocations assigned to this node.').optional(),
    number_of_pending_requests: z.number().describe('The number of inference requests queued to be processed.').optional(),
    peak_throughput_per_minute: z.number(),
    rejected_execution_count: z.number().describe('The number of inference requests that were not processed because the queue was full.').optional(),
    routing_state: ml_types_trained_model_assignment_routing_state_and_reason,
    start_time: types_epoch_time_unit_millis.optional(),
    threads_per_allocation: z.number().describe('The number of threads used by each allocation during inference.').optional(),
    throughput_last_minute: z.number(),
    timeout_count: z.number().describe('The number of inference requests that timed out before being processed.').optional()
});

export const ml_types_training_priority = z.enum(['normal', 'low']);

export const ml_types_deployment_assignment_state = z.enum([
    'started',
    'starting',
    'stopping',
    'failed'
]);

export const ml_types_trained_model_deployment_stats = z.object({
    adaptive_allocations: ml_types_adaptive_allocations_settings.optional(),
    allocation_status: ml_types_trained_model_deployment_allocation_status.optional(),
    cache_size: types_byte_size.optional(),
    deployment_id: types_id,
    error_count: z.number().describe('The sum of `error_count` for all nodes in the deployment.').optional(),
    inference_count: z.number().describe('The sum of `inference_count` for all nodes in the deployment.').optional(),
    model_id: types_id,
    nodes: z.array(ml_types_trained_model_deployment_nodes_stats).describe('The deployment stats for each node that currently has the model allocated.\nIn serverless, stats are reported for a single unnamed virtual node.'),
    number_of_allocations: z.number().describe('The number of allocations requested.').optional(),
    peak_throughput_per_minute: z.number(),
    priority: ml_types_training_priority,
    queue_capacity: z.number().describe('The number of inference requests that can be queued before new requests are rejected.').optional(),
    rejected_execution_count: z.number().describe('The sum of `rejected_execution_count` for all nodes in the deployment.\nIndividual nodes reject an inference request if the inference queue is full.\nThe queue size is controlled by the `queue_capacity` setting in the start\ntrained model deployment API.').optional(),
    reason: z.string().describe('The reason for the current deployment state. Usually only populated when\nthe model is not deployed to a node.').optional(),
    start_time: types_epoch_time_unit_millis,
    state: ml_types_deployment_assignment_state.optional(),
    threads_per_allocation: z.number().describe('The number of threads used be each allocation during inference.').optional(),
    timeout_count: z.number().describe('The sum of `timeout_count` for all nodes in the deployment.').optional()
});

export const ml_types_trained_model_inference_stats = z.object({
    cache_miss_count: z.number().describe('The number of times the model was loaded for inference and was not retrieved from the cache.\nIf this number is close to the `inference_count`, the cache is not being appropriately used.\nThis can be solved by increasing the cache size or its time-to-live (TTL).\nRefer to general machine learning settings for the appropriate settings.'),
    failure_count: z.number().describe('The number of failures when using the model for inference.'),
    inference_count: z.number().describe('The total number of times the model has been called for inference.\nThis is across all inference contexts, including all pipelines.'),
    missing_all_fields_count: z.number().describe('The number of inference calls where all the training features for the model were missing.'),
    timestamp: types_epoch_time_unit_millis
});

export const ml_types_trained_model_size_stats = z.object({
    model_size_bytes: types_byte_size,
    required_native_memory_bytes: types_byte_size
});

export const ml_types_trained_model_stats = z.object({
    deployment_stats: ml_types_trained_model_deployment_stats.optional(),
    inference_stats: ml_types_trained_model_inference_stats.optional(),
    ingest: z.record(z.record(z.unknown())).describe('A collection of ingest stats for the model across all nodes.\nThe values are summations of the individual node statistics.\nThe format matches the ingest section in the nodes stats API.').optional(),
    model_id: types_id,
    model_size_stats: ml_types_trained_model_size_stats,
    pipeline_count: z.number().describe('The number of ingest pipelines that currently refer to the model.')
});

export const ml_types_nlp_tokenization_update_options = z.object({
    truncate: ml_types_tokenization_truncate.optional(),
    span: z.number().describe('Span options to apply').optional()
});

export const ml_types_text_classification_inference_update_options = z.object({
    num_top_classes: z.number().describe('Specifies the number of top class predictions to return. Defaults to 0.').optional(),
    tokenization: ml_types_nlp_tokenization_update_options.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    classification_labels: z.array(z.string()).describe('Classification labels to apply other than the stored labels. Must have the same deminsions as the default configured labels').optional()
});

export const ml_types_zero_shot_classification_inference_update_options = z.object({
    tokenization: ml_types_nlp_tokenization_update_options.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    multi_label: z.boolean().describe('Update the configured multi label option. Indicates if more than one true label exists. Defaults to the configured value.').optional(),
    labels: z.array(z.string()).describe('The labels to predict.')
});

export const ml_types_fill_mask_inference_update_options = z.object({
    num_top_classes: z.number().describe('Specifies the number of top class predictions to return. Defaults to 0.').optional(),
    tokenization: ml_types_nlp_tokenization_update_options.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional()
});

export const ml_types_ner_inference_update_options = z.object({
    tokenization: ml_types_nlp_tokenization_update_options.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional()
});

export const ml_types_pass_through_inference_update_options = z.object({
    tokenization: ml_types_nlp_tokenization_update_options.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional()
});

export const ml_types_text_embedding_inference_update_options = z.object({
    tokenization: ml_types_nlp_tokenization_update_options.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional()
});

export const ml_types_text_expansion_inference_update_options = z.object({
    tokenization: ml_types_nlp_tokenization_update_options.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional()
});

export const ml_types_question_answering_inference_update_options = z.object({
    question: z.string().describe('The question to answer given the inference context'),
    num_top_classes: z.number().describe('Specifies the number of top class predictions to return. Defaults to 0.').optional(),
    tokenization: ml_types_nlp_tokenization_update_options.optional(),
    results_field: z.string().describe('The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.').optional(),
    max_answer_length: z.number().describe('The maximum answer length to consider for extraction').optional()
});

export const ml_types_inference_config_update_container = z.object({
    regression: ml_types_regression_inference_options.optional(),
    classification: ml_types_classification_inference_options.optional(),
    text_classification: ml_types_text_classification_inference_update_options.optional(),
    zero_shot_classification: ml_types_zero_shot_classification_inference_update_options.optional(),
    fill_mask: ml_types_fill_mask_inference_update_options.optional(),
    ner: ml_types_ner_inference_update_options.optional(),
    pass_through: ml_types_pass_through_inference_update_options.optional(),
    text_embedding: ml_types_text_embedding_inference_update_options.optional(),
    text_expansion: ml_types_text_expansion_inference_update_options.optional(),
    question_answering: ml_types_question_answering_inference_update_options.optional()
});

export const ml_types_trained_model_entities = z.object({
    class_name: z.string(),
    class_probability: z.number(),
    entity: z.string(),
    start_pos: z.number(),
    end_pos: z.number()
});

export const ml_types_predicted_value = z.union([
    types_scalar_value,
    z.array(types_scalar_value)
]);

export const ml_types_top_class_entry = z.object({
    class_name: z.string(),
    class_probability: z.number(),
    class_score: z.number()
});

export const ml_types_trained_model_inference_class_importance = z.object({
    class_name: z.string(),
    importance: z.number()
});

export const ml_types_trained_model_inference_feature_importance = z.object({
    feature_name: z.string(),
    importance: z.number().optional(),
    classes: z.array(ml_types_trained_model_inference_class_importance).optional()
});

export const ml_types_inference_response_result = z.object({
    entities: z.array(ml_types_trained_model_entities).describe('If the model is trained for named entity recognition (NER) tasks, the response contains the recognized entities.').optional(),
    is_truncated: z.boolean().describe('Indicates whether the input text was truncated to meet the model\'s maximum sequence length limit. This property\nis present only when it is true.').optional(),
    predicted_value: z.union([
        ml_types_predicted_value,
        z.array(ml_types_predicted_value)
    ]).optional(),
    predicted_value_sequence: z.string().describe('For fill mask tasks, the response contains the input text sequence with the mask token replaced by the predicted\nvalue.\nAdditionally').optional(),
    prediction_probability: z.number().describe('Specifies a probability for the predicted value.').optional(),
    prediction_score: z.number().describe('Specifies a confidence score for the predicted value.').optional(),
    top_classes: z.array(ml_types_top_class_entry).describe('For fill mask, text classification, and zero shot classification tasks, the response contains a list of top\nclass entries.').optional(),
    warning: z.string().describe('If the request failed, the response contains the reason for the failure.').optional(),
    feature_importance: z.array(ml_types_trained_model_inference_feature_importance).describe('The feature importance for the inference results. Relevant only for classification or regression models').optional()
});

export const ml_info_datafeeds = z.object({
    scroll_size: z.number()
});

export const ml_info_limits = z.object({
    max_single_ml_node_processors: z.number().optional(),
    total_ml_processors: z.number().optional(),
    max_model_memory_limit: types_byte_size.optional(),
    effective_max_model_memory_limit: types_byte_size.optional(),
    total_ml_memory: types_byte_size
});

export const ml_info_native_code = z.object({
    build_hash: z.string(),
    version: types_version_string
});

export const types_http_headers = z.record(z.union([
    z.string(),
    z.array(z.string())
]));

export const ml_types_detector_read = z.object({
    by_field_name: types_field.optional(),
    custom_rules: z.array(ml_types_detection_rule).describe('An array of custom rule objects, which enable you to customize the way detectors operate.\nFor example, a rule may dictate to the detector conditions under which results should be skipped.\nKibana refers to custom rules as job rules.').optional(),
    detector_description: z.string().describe('A description of the detector.').optional(),
    detector_index: z.number().describe('A unique identifier for the detector.\nThis identifier is based on the order of the detectors in the `analysis_config`, starting at zero.').optional(),
    exclude_frequent: ml_types_exclude_frequent.optional(),
    field_name: types_field.optional(),
    function: z.string().describe('The analysis function that is used.\nFor example, `count`, `rare`, `mean`, `min`, `max`, and `sum`.'),
    over_field_name: types_field.optional(),
    partition_field_name: types_field.optional(),
    use_null: z.boolean().describe('Defines whether a new series is used as the null series when there is no value for the by or partition fields.').optional().default(false)
});

export const ml_put_trained_model_frequency_encoding_preprocessor = z.object({
    field: z.string(),
    feature_name: z.string(),
    frequency_map: z.record(z.number())
});

export const ml_put_trained_model_one_hot_encoding_preprocessor = z.object({
    field: z.string(),
    hot_map: z.record(z.string())
});

export const ml_put_trained_model_target_mean_encoding_preprocessor = z.object({
    field: z.string(),
    feature_name: z.string(),
    target_map: z.record(z.number()),
    default_value: z.number()
});

export const ml_put_trained_model_preprocessor = z.object({
    frequency_encoding: ml_put_trained_model_frequency_encoding_preprocessor.optional(),
    one_hot_encoding: ml_put_trained_model_one_hot_encoding_preprocessor.optional(),
    target_mean_encoding: ml_put_trained_model_target_mean_encoding_preprocessor.optional()
});

export const ml_put_trained_model_trained_model_tree_node = z.object({
    decision_type: z.string().optional(),
    default_left: z.boolean().optional(),
    leaf_value: z.number().optional(),
    left_child: z.number().optional(),
    node_index: z.number(),
    right_child: z.number().optional(),
    split_feature: z.number().optional(),
    split_gain: z.number().optional(),
    threshold: z.number().optional()
});

export const ml_put_trained_model_trained_model_tree = z.object({
    classification_labels: z.array(z.string()).optional(),
    feature_names: z.array(z.string()),
    target_type: z.string().optional(),
    tree_structure: z.array(ml_put_trained_model_trained_model_tree_node)
});

export const ml_put_trained_model_weights = z.object({
    weights: z.number()
});

export const ml_put_trained_model_aggregate_output = z.object({
    logistic_regression: ml_put_trained_model_weights.optional(),
    weighted_sum: ml_put_trained_model_weights.optional(),
    weighted_mode: ml_put_trained_model_weights.optional(),
    exponent: ml_put_trained_model_weights.optional()
});

export const ml_put_trained_model_input = z.object({
    field_names: types_names
});

export const ml_types_trained_model_assignment_routing_table = z.object({
    reason: z.string().describe('The reason for the current state. It is usually populated only when the\n`routing_state` is `failed`.').optional(),
    routing_state: ml_types_routing_state,
    current_allocations: z.number().describe('Current number of allocations.'),
    target_allocations: z.number().describe('Target number of allocations.')
});

export const ml_types_trained_model_assignment_task_parameters = z.object({
    model_bytes: types_byte_size,
    model_id: types_id,
    deployment_id: types_id,
    cache_size: types_byte_size.optional(),
    number_of_allocations: z.number().describe('The total number of allocations this model is assigned across ML nodes.'),
    priority: ml_types_training_priority,
    per_deployment_memory_bytes: types_byte_size,
    per_allocation_memory_bytes: types_byte_size,
    queue_capacity: z.number().describe('Number of inference requests are allowed in the queue at a time.'),
    threads_per_allocation: z.number().describe('Number of threads per allocation.')
});

export const ml_types_trained_model_assignment = z.object({
    adaptive_allocations: z.union([
        ml_types_adaptive_allocations_settings,
        z.string(),
        z.null()
    ]).optional(),
    assignment_state: ml_types_deployment_assignment_state,
    max_assigned_allocations: z.number().optional(),
    reason: z.string().optional(),
    routing_table: z.record(ml_types_trained_model_assignment_routing_table).describe('The allocation state for each node.'),
    start_time: types_date_time,
    task_parameters: ml_types_trained_model_assignment_task_parameters
});

export const ml_types_analysis_memory_limit = z.object({
    model_memory_limit: z.string().describe('Limits can be applied for the resources required to hold the mathematical models in memory. These limits are approximate and can be set per job. They do not control the memory used by other processes, for example the Elasticsearch Java processes.')
});

export const ml_types_detector_update = z.object({
    detector_index: z.number().describe('A unique identifier for the detector.\nThis identifier is based on the order of the detectors in the `analysis_config`, starting at zero.'),
    description: z.string().describe('A description of the detector.').optional(),
    custom_rules: z.array(ml_types_detection_rule).describe('An array of custom rule objects, which enable you to customize the way detectors operate.\nFor example, a rule may dictate to the detector conditions under which results should be skipped.\nKibana refers to custom rules as job rules.').optional()
});

export const global_termvectors_filter = z.object({
    max_doc_freq: z.number().describe('Ignore words which occur in more than this many docs.\nDefaults to unbounded.').optional(),
    max_num_terms: z.number().describe('The maximum number of terms that must be returned per field.').optional().default(25),
    max_term_freq: z.number().describe('Ignore words with more than this frequency in the source doc.\nIt defaults to unbounded.').optional(),
    max_word_length: z.number().describe('The maximum word length above which words will be ignored.\nDefaults to unbounded.').optional().default(0),
    min_doc_freq: z.number().describe('Ignore terms which do not occur in at least this many docs.').optional().default(1),
    min_term_freq: z.number().describe('Ignore words with less than this frequency in the source doc.').optional().default(1),
    min_word_length: z.number().describe('The minimum word length below which words will be ignored.').optional().default(0)
});

export const global_mtermvectors_operation = z.object({
    _id: types_id.optional(),
    _index: types_index_name.optional(),
    doc: z.record(z.unknown()).describe('An artificial document (a document not present in the index) for which you want to retrieve term vectors.').optional(),
    fields: types_fields.optional(),
    field_statistics: z.boolean().describe('If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.').optional().default(true),
    filter: global_termvectors_filter.optional(),
    offsets: z.boolean().describe('If `true`, the response includes term offsets.').optional().default(true),
    payloads: z.boolean().describe('If `true`, the response includes term payloads.').optional().default(true),
    positions: z.boolean().describe('If `true`, the response includes term positions.').optional().default(true),
    routing: types_routing.optional(),
    term_statistics: z.boolean().describe('If true, the response includes term frequency and document frequency.').optional().default(false),
    version: types_version_number.optional(),
    version_type: types_version_type.optional()
});

export const global_termvectors_field_statistics = z.object({
    doc_count: z.number(),
    sum_doc_freq: z.number(),
    sum_ttf: z.number()
});

export const global_termvectors_token = z.object({
    end_offset: z.number().optional(),
    payload: z.string().optional(),
    position: z.number(),
    start_offset: z.number().optional()
});

export const global_termvectors_term = z.object({
    doc_freq: z.number().optional(),
    score: z.number().optional(),
    term_freq: z.number(),
    tokens: z.array(global_termvectors_token).optional(),
    ttf: z.number().optional()
});

export const global_termvectors_term_vector = z.object({
    field_statistics: global_termvectors_field_statistics.optional(),
    terms: z.record(global_termvectors_term)
});

export const global_mtermvectors_term_vectors_result = z.object({
    _id: types_id.optional(),
    _index: types_index_name,
    _version: types_version_number.optional(),
    took: z.number().optional(),
    found: z.boolean().optional(),
    term_vectors: z.record(global_termvectors_term_vector).optional(),
    error: types_error_cause.optional()
});

export const nodes_types_repository_location = z.object({
    base_path: z.string(),
    container: z.string().describe('Container name (Azure)').optional(),
    bucket: z.string().describe('Bucket name (GCP, S3)').optional()
});

export const nodes_types_request_counts = z.object({
    GetBlobProperties: z.number().describe('Number of Get Blob Properties requests (Azure)').optional(),
    GetBlob: z.number().describe('Number of Get Blob requests (Azure)').optional(),
    ListBlobs: z.number().describe('Number of List Blobs requests (Azure)').optional(),
    PutBlob: z.number().describe('Number of Put Blob requests (Azure)').optional(),
    PutBlock: z.number().describe('Number of Put Block (Azure)').optional(),
    PutBlockList: z.number().describe('Number of Put Block List requests').optional(),
    GetObject: z.number().describe('Number of get object requests (GCP, S3)').optional(),
    ListObjects: z.number().describe('Number of list objects requests (GCP, S3)').optional(),
    InsertObject: z.number().describe('Number of insert object requests, including simple, multipart and resumable uploads. Resumable uploads\ncan perform multiple http requests to insert a single object but they are considered as a single request\nsince they are billed as an individual operation. (GCP)').optional(),
    PutObject: z.number().describe('Number of PutObject requests (S3)').optional(),
    PutMultipartObject: z.number().describe('Number of Multipart requests, including CreateMultipartUpload, UploadPart and CompleteMultipartUpload requests (S3)').optional()
});

export const nodes_types_repository_metering_information = z.object({
    repository_name: types_name,
    repository_type: z.string().describe('Repository type.'),
    repository_location: nodes_types_repository_location,
    repository_ephemeral_id: types_id,
    repository_started_at: types_epoch_time_unit_millis,
    repository_stopped_at: types_epoch_time_unit_millis.optional(),
    archived: z.boolean().describe('A flag that tells whether or not this object has been archived. When a repository is closed or updated the\nrepository metering information is archived and kept for a certain period of time. This allows retrieving the\nrepository metering information of previous repository instantiations.'),
    cluster_version: types_version_number.optional(),
    request_counts: nodes_types_request_counts
});

export const nodes_clear_repositories_metering_archive_response_base = nodes_types_nodes_response_base.and(z.object({
    cluster_name: types_name,
    nodes: z.record(nodes_types_repository_metering_information).describe('Contains repositories metering information for the nodes selected by the request.')
}));

export const nodes_get_repositories_metering_info_response_base = nodes_types_nodes_response_base.and(z.object({
    cluster_name: types_name,
    nodes: z.record(nodes_types_repository_metering_information).describe('Contains repositories metering information for the nodes selected by the request.')
}));

export const types_thread_type = z.enum([
    'cpu',
    'wait',
    'block',
    'gpu',
    'mem'
]);

export const nodes_info_nodes_info_metric = z.enum([
    '_all',
    '_none',
    'settings',
    'os',
    'process',
    'jvm',
    'thread_pool',
    'transport',
    'http',
    'remote_cluster_server',
    'plugins',
    'ingest',
    'aggregations',
    'indices'
]);

export const nodes_info_nodes_info_metrics = z.union([
    nodes_info_nodes_info_metric,
    z.array(nodes_info_nodes_info_metric)
]);

export const nodes_info_node_info_http = z.object({
    bound_address: z.array(z.string()),
    max_content_length: types_byte_size.optional(),
    max_content_length_in_bytes: z.number(),
    publish_address: z.string()
});

export const nodes_info_node_info_jvm_memory = z.object({
    direct_max: types_byte_size.optional(),
    direct_max_in_bytes: z.number(),
    heap_init: types_byte_size.optional(),
    heap_init_in_bytes: z.number(),
    heap_max: types_byte_size.optional(),
    heap_max_in_bytes: z.number(),
    non_heap_init: types_byte_size.optional(),
    non_heap_init_in_bytes: z.number(),
    non_heap_max: types_byte_size.optional(),
    non_heap_max_in_bytes: z.number()
});

export const nodes_info_node_jvm_info = z.object({
    gc_collectors: z.array(z.string()),
    mem: nodes_info_node_info_jvm_memory,
    memory_pools: z.array(z.string()),
    pid: z.number(),
    start_time_in_millis: types_epoch_time_unit_millis,
    version: types_version_string,
    vm_name: types_name,
    vm_vendor: z.string(),
    vm_version: types_version_string,
    using_bundled_jdk: z.boolean(),
    using_compressed_ordinary_object_pointers: z.union([
        z.boolean(),
        z.string()
    ]).optional(),
    input_arguments: z.array(z.string())
});

export const nodes_info_node_info_oscpu = z.object({
    cache_size: z.string(),
    cache_size_in_bytes: z.number(),
    cores_per_socket: z.number(),
    mhz: z.number(),
    model: z.string(),
    total_cores: z.number(),
    total_sockets: z.number(),
    vendor: z.string()
});

export const nodes_info_node_info_memory = z.object({
    total: z.string(),
    total_in_bytes: z.number()
});

export const nodes_info_node_operating_system_info = z.object({
    arch: z.string().describe('Name of the JVM architecture (ex: amd64, x86)'),
    available_processors: z.number().describe('Number of processors available to the Java virtual machine'),
    allocated_processors: z.number().describe('The number of processors actually used to calculate thread pool size. This number can be set with the node.processors setting of a node and defaults to the number of processors reported by the OS.').optional(),
    name: types_name,
    pretty_name: types_name,
    refresh_interval_in_millis: types_duration_value_unit_millis,
    version: types_version_string,
    cpu: nodes_info_node_info_oscpu.optional(),
    mem: nodes_info_node_info_memory.optional(),
    swap: nodes_info_node_info_memory.optional()
});

export const nodes_info_node_process_info = z.object({
    id: z.number().describe('Process identifier (PID)'),
    mlockall: z.boolean().describe('Indicates if the process address space has been successfully locked in memory'),
    refresh_interval_in_millis: types_duration_value_unit_millis
});

export const nodes_info_node_info_settings_cluster_election = z.object({
    strategy: types_name
});

export const nodes_info_deprecation_indexing = z.object({
    enabled: z.union([
        z.boolean(),
        z.string()
    ])
});

export const nodes_info_node_info_settings_cluster = z.object({
    name: types_name,
    routing: indices_types_index_routing.optional(),
    election: nodes_info_node_info_settings_cluster_election,
    initial_master_nodes: z.union([
        z.array(z.string()),
        z.string()
    ]).optional(),
    deprecation_indexing: nodes_info_deprecation_indexing.optional()
});

export const nodes_info_node_info_settings_node = z.object({
    name: types_name,
    attr: z.record(z.record(z.unknown())),
    max_local_storage_nodes: z.string().optional()
});

export const nodes_info_node_info_path = z.object({
    logs: z.string().optional(),
    home: z.string().optional(),
    repo: z.array(z.string()).optional(),
    data: z.union([
        z.string(),
        z.array(z.string())
    ]).optional()
});

export const nodes_info_node_info_repositories_url = z.object({
    allowed_urls: z.string()
});

export const nodes_info_node_info_repositories = z.object({
    url: nodes_info_node_info_repositories_url
});

export const nodes_info_node_info_discover = z.object({
    seed_hosts: z.union([
        z.array(z.string()),
        z.string()
    ]).optional(),
    type: z.string().optional(),
    seed_providers: z.array(z.string()).optional()
});

export const nodes_info_node_info_action = z.object({
    destructive_requires_name: z.string()
});

export const nodes_info_node_info_client = z.object({
    type: z.string()
});

export const nodes_info_node_info_settings_http_type = z.object({
    default: z.string()
});

export const nodes_info_node_info_settings_http = z.object({
    type: nodes_info_node_info_settings_http_type,
    'type.default': z.string().optional(),
    compression: z.union([
        z.boolean(),
        z.string()
    ]).optional(),
    port: z.union([
        z.number(),
        z.string()
    ]).optional()
});

export const nodes_info_node_info_bootstrap = z.object({
    memory_lock: z.string()
});

export const nodes_info_node_info_settings_transport_type = z.object({
    default: z.string()
});

export const nodes_info_node_info_settings_transport_features = z.object({
    'x-pack': z.string()
});

export const nodes_info_node_info_settings_transport = z.object({
    type: nodes_info_node_info_settings_transport_type,
    'type.default': z.string().optional(),
    features: nodes_info_node_info_settings_transport_features.optional()
});

export const nodes_info_node_info_settings_network = z.object({
    host: z.union([
        types_host,
        z.array(types_host)
    ]).optional()
});

export const nodes_info_node_info_xpack_license_type = z.object({
    type: z.string()
});

export const nodes_info_node_info_xpack_license = z.object({
    self_generated: nodes_info_node_info_xpack_license_type
});

export const nodes_info_node_info_xpack_security_ssl = z.object({
    ssl: z.record(z.string())
});

export const nodes_info_node_info_xpack_security_authc_realms_status = z.object({
    enabled: z.string().optional(),
    order: z.string()
});

export const nodes_info_node_info_xpack_security_authc_realms = z.object({
    file: z.record(nodes_info_node_info_xpack_security_authc_realms_status).optional(),
    native: z.record(nodes_info_node_info_xpack_security_authc_realms_status).optional(),
    pki: z.record(nodes_info_node_info_xpack_security_authc_realms_status).optional()
});

export const nodes_info_node_info_xpack_security_authc_token = z.object({
    enabled: z.string()
});

export const nodes_info_node_info_xpack_security_authc = z.object({
    realms: nodes_info_node_info_xpack_security_authc_realms.optional(),
    token: nodes_info_node_info_xpack_security_authc_token.optional()
});

export const nodes_info_node_info_xpack_security = z.object({
    http: nodes_info_node_info_xpack_security_ssl.optional(),
    enabled: z.string(),
    transport: nodes_info_node_info_xpack_security_ssl.optional(),
    authc: nodes_info_node_info_xpack_security_authc.optional()
});

export const nodes_info_node_info_xpack_ml = z.object({
    use_auto_machine_memory_percent: z.boolean().optional()
});

export const nodes_info_node_info_xpack = z.object({
    license: nodes_info_node_info_xpack_license.optional(),
    security: nodes_info_node_info_xpack_security,
    notification: z.record(z.record(z.unknown())).optional(),
    ml: nodes_info_node_info_xpack_ml.optional()
});

export const nodes_info_node_info_script = z.object({
    allowed_types: z.string(),
    disable_max_compilations_rate: z.string().optional()
});

export const nodes_info_node_info_search_remote = z.object({
    connect: z.string()
});

export const nodes_info_node_info_search = z.object({
    remote: nodes_info_node_info_search_remote
});

export const nodes_info_node_info_ingest_downloader = z.object({
    enabled: z.string()
});

export const nodes_info_node_info_ingest_info = z.object({
    downloader: nodes_info_node_info_ingest_downloader
});

export const nodes_info_node_info_settings_ingest = z.object({
    attachment: nodes_info_node_info_ingest_info.optional(),
    append: nodes_info_node_info_ingest_info.optional(),
    csv: nodes_info_node_info_ingest_info.optional(),
    convert: nodes_info_node_info_ingest_info.optional(),
    date: nodes_info_node_info_ingest_info.optional(),
    date_index_name: nodes_info_node_info_ingest_info.optional(),
    dot_expander: nodes_info_node_info_ingest_info.optional(),
    enrich: nodes_info_node_info_ingest_info.optional(),
    fail: nodes_info_node_info_ingest_info.optional(),
    foreach: nodes_info_node_info_ingest_info.optional(),
    json: nodes_info_node_info_ingest_info.optional(),
    user_agent: nodes_info_node_info_ingest_info.optional(),
    kv: nodes_info_node_info_ingest_info.optional(),
    geoip: nodes_info_node_info_ingest_info.optional(),
    grok: nodes_info_node_info_ingest_info.optional(),
    gsub: nodes_info_node_info_ingest_info.optional(),
    join: nodes_info_node_info_ingest_info.optional(),
    lowercase: nodes_info_node_info_ingest_info.optional(),
    remove: nodes_info_node_info_ingest_info.optional(),
    rename: nodes_info_node_info_ingest_info.optional(),
    script: nodes_info_node_info_ingest_info.optional(),
    set: nodes_info_node_info_ingest_info.optional(),
    sort: nodes_info_node_info_ingest_info.optional(),
    split: nodes_info_node_info_ingest_info.optional(),
    trim: nodes_info_node_info_ingest_info.optional(),
    uppercase: nodes_info_node_info_ingest_info.optional(),
    urldecode: nodes_info_node_info_ingest_info.optional(),
    bytes: nodes_info_node_info_ingest_info.optional(),
    dissect: nodes_info_node_info_ingest_info.optional(),
    set_security_user: nodes_info_node_info_ingest_info.optional(),
    pipeline: nodes_info_node_info_ingest_info.optional(),
    drop: nodes_info_node_info_ingest_info.optional(),
    circle: nodes_info_node_info_ingest_info.optional(),
    inference: nodes_info_node_info_ingest_info.optional()
});

export const nodes_info_node_info_settings = z.object({
    cluster: nodes_info_node_info_settings_cluster,
    node: nodes_info_node_info_settings_node,
    path: nodes_info_node_info_path.optional(),
    repositories: nodes_info_node_info_repositories.optional(),
    discovery: nodes_info_node_info_discover.optional(),
    action: nodes_info_node_info_action.optional(),
    client: nodes_info_node_info_client.optional(),
    http: nodes_info_node_info_settings_http,
    bootstrap: nodes_info_node_info_bootstrap.optional(),
    transport: nodes_info_node_info_settings_transport,
    network: nodes_info_node_info_settings_network.optional(),
    xpack: nodes_info_node_info_xpack.optional(),
    script: nodes_info_node_info_script.optional(),
    search: nodes_info_node_info_search.optional(),
    ingest: nodes_info_node_info_settings_ingest.optional()
});

export const nodes_info_node_thread_pool_info = z.object({
    core: z.number().optional(),
    keep_alive: types_duration.optional(),
    max: z.number().optional(),
    queue_size: z.number(),
    size: z.number().optional(),
    type: z.string()
});

export const nodes_info_node_info_transport = z.object({
    bound_address: z.array(z.string()),
    publish_address: z.string(),
    profiles: z.record(z.string())
});

export const nodes_info_node_info_ingest_processor = z.object({
    type: z.string()
});

export const nodes_info_node_info_ingest = z.object({
    processors: z.array(nodes_info_node_info_ingest_processor)
});

export const nodes_info_node_info_aggregation = z.object({
    types: z.array(z.string())
});

export const nodes_info_remove_cluster_server = z.object({
    bound_address: z.array(types_transport_address),
    publish_address: types_transport_address
});

export const nodes_info_node_info = z.object({
    attributes: z.record(z.string()),
    build_flavor: z.string(),
    build_hash: z.string().describe('Short hash of the last git commit in this release.'),
    build_type: z.string(),
    component_versions: z.record(z.number()),
    host: types_host,
    http: nodes_info_node_info_http.optional(),
    index_version: types_version_number,
    ip: types_ip,
    jvm: nodes_info_node_jvm_info.optional(),
    name: types_name,
    os: nodes_info_node_operating_system_info.optional(),
    plugins: z.array(types_plugin_stats).optional(),
    process: nodes_info_node_process_info.optional(),
    roles: types_node_roles,
    settings: nodes_info_node_info_settings.optional(),
    thread_pool: z.record(nodes_info_node_thread_pool_info).optional(),
    total_indexing_buffer: z.number().describe('Total heap allowed to be used to hold recently indexed documents before they must be written to disk. This size is a shared pool across all shards on this node, and is controlled by Indexing Buffer settings.').optional(),
    total_indexing_buffer_in_bytes: types_byte_size.optional(),
    transport: nodes_info_node_info_transport.optional(),
    transport_address: types_transport_address,
    transport_version: types_version_number,
    version: types_version_string,
    modules: z.array(types_plugin_stats).optional(),
    ingest: nodes_info_node_info_ingest.optional(),
    aggregations: z.record(nodes_info_node_info_aggregation).optional(),
    remote_cluster_server: nodes_info_remove_cluster_server.optional()
});

export const nodes_info_response_base = nodes_types_nodes_response_base.and(z.object({
    cluster_name: types_name,
    nodes: z.record(nodes_info_node_info)
}));

export const types_password = z.string();

export const nodes_types_node_reload_result = z.object({
    name: types_name,
    reload_exception: types_error_cause.optional()
});

export const nodes_reload_secure_settings_response_base = nodes_types_nodes_response_base.and(z.object({
    cluster_name: types_name,
    nodes: z.record(nodes_types_node_reload_result)
}));

export const nodes_stats_node_stats_metric = z.enum([
    '_all',
    '_none',
    'indices',
    'os',
    'process',
    'jvm',
    'thread_pool',
    'fs',
    'transport',
    'http',
    'breaker',
    'script',
    'discovery',
    'ingest',
    'adaptive_selection',
    'script_cache',
    'indexing_pressure',
    'repositories',
    'allocations'
]);

export const nodes_stats_node_stats_metrics = z.union([
    nodes_stats_node_stats_metric,
    z.array(nodes_stats_node_stats_metric)
]);

export const types_node_stats_level = z.enum([
    'node',
    'indices',
    'shards'
]);

export const nodes_types_adaptive_selection = z.object({
    avg_queue_size: z.number().describe('The exponentially weighted moving average queue size of search requests on the keyed node.').optional(),
    avg_response_time: types_duration.optional(),
    avg_response_time_ns: z.number().describe('The exponentially weighted moving average response time, in nanoseconds, of search requests on the keyed node.').optional(),
    avg_service_time: types_duration.optional(),
    avg_service_time_ns: z.number().describe('The exponentially weighted moving average service time, in nanoseconds, of search requests on the keyed node.').optional(),
    outgoing_searches: z.number().describe('The number of outstanding search requests to the keyed node from the node these stats are for.').optional(),
    rank: z.string().describe('The rank of this node; used for shard selection when routing search requests.').optional()
});

export const nodes_types_breaker = z.object({
    estimated_size: z.string().describe('Estimated memory used for the operation.').optional(),
    estimated_size_in_bytes: z.number().describe('Estimated memory used, in bytes, for the operation.').optional(),
    limit_size: z.string().describe('Memory limit for the circuit breaker.').optional(),
    limit_size_in_bytes: z.number().describe('Memory limit, in bytes, for the circuit breaker.').optional(),
    overhead: z.number().describe('A constant that all estimates for the circuit breaker are multiplied with to calculate a final estimate.').optional(),
    tripped: z.number().describe('Total number of times the circuit breaker has been triggered and prevented an out of memory error.').optional()
});

export const nodes_types_data_path_stats = z.object({
    available: z.string().describe('Total amount of disk space available to this Java virtual machine on this file store.').optional(),
    available_in_bytes: z.number().describe('Total number of bytes available to this Java virtual machine on this file store.').optional(),
    disk_queue: z.string().optional(),
    disk_reads: z.number().optional(),
    disk_read_size: z.string().optional(),
    disk_read_size_in_bytes: z.number().optional(),
    disk_writes: z.number().optional(),
    disk_write_size: z.string().optional(),
    disk_write_size_in_bytes: z.number().optional(),
    free: z.string().describe('Total amount of unallocated disk space in the file store.').optional(),
    free_in_bytes: z.number().describe('Total number of unallocated bytes in the file store.').optional(),
    mount: z.string().describe('Mount point of the file store (for example: `/dev/sda2`).').optional(),
    path: z.string().describe('Path to the file store.').optional(),
    total: z.string().describe('Total size of the file store.').optional(),
    total_in_bytes: z.number().describe('Total size of the file store in bytes.').optional(),
    type: z.string().describe('Type of the file store (ex: ext4).').optional()
});

export const nodes_types_file_system_total = z.object({
    available: z.string().describe('Total disk space available to this Java virtual machine on all file stores.\nDepending on OS or process level restrictions, this might appear less than `free`.\nThis is the actual amount of free disk space the Elasticsearch node can utilise.').optional(),
    available_in_bytes: z.number().describe('Total number of bytes available to this Java virtual machine on all file stores.\nDepending on OS or process level restrictions, this might appear less than `free_in_bytes`.\nThis is the actual amount of free disk space the Elasticsearch node can utilise.').optional(),
    free: z.string().describe('Total unallocated disk space in all file stores.').optional(),
    free_in_bytes: z.number().describe('Total number of unallocated bytes in all file stores.').optional(),
    total: z.string().describe('Total size of all file stores.').optional(),
    total_in_bytes: z.number().describe('Total size of all file stores in bytes.').optional()
});

export const nodes_types_io_stat_device = z.object({
    device_name: z.string().describe('The Linux device name.').optional(),
    operations: z.number().describe('The total number of read and write operations for the device completed since starting Elasticsearch.').optional(),
    read_kilobytes: z.number().describe('The total number of kilobytes read for the device since starting Elasticsearch.').optional(),
    read_operations: z.number().describe('The total number of read operations for the device completed since starting Elasticsearch.').optional(),
    write_kilobytes: z.number().describe('The total number of kilobytes written for the device since starting Elasticsearch.').optional(),
    write_operations: z.number().describe('The total number of write operations for the device completed since starting Elasticsearch.').optional()
});

export const nodes_types_io_stats = z.object({
    devices: z.array(nodes_types_io_stat_device).describe('Array of disk metrics for each device that is backing an Elasticsearch data path.\nThese disk metrics are probed periodically and averages between the last probe and the current probe are computed.').optional(),
    total: nodes_types_io_stat_device.optional()
});

export const nodes_types_file_system = z.object({
    data: z.array(nodes_types_data_path_stats).describe('List of all file stores.').optional(),
    timestamp: z.number().describe('Last time the file stores statistics were refreshed.\nRecorded in milliseconds since the Unix Epoch.').optional(),
    total: nodes_types_file_system_total.optional(),
    io_stats: nodes_types_io_stats.optional()
});

export const nodes_types_node_buffer_pool = z.object({
    count: z.number().describe('Number of buffer pools.').optional(),
    total_capacity: z.string().describe('Total capacity of buffer pools.').optional(),
    total_capacity_in_bytes: z.number().describe('Total capacity of buffer pools in bytes.').optional(),
    used: z.string().describe('Size of buffer pools.').optional(),
    used_in_bytes: z.number().describe('Size of buffer pools in bytes.').optional()
});

export const nodes_types_jvm_classes = z.object({
    current_loaded_count: z.number().describe('Number of classes currently loaded by JVM.').optional(),
    total_loaded_count: z.number().describe('Total number of classes loaded since the JVM started.').optional(),
    total_unloaded_count: z.number().describe('Total number of classes unloaded since the JVM started.').optional()
});

export const nodes_types_garbage_collector_total = z.object({
    collection_count: z.number().describe('Total number of JVM garbage collectors that collect objects.').optional(),
    collection_time: z.string().describe('Total time spent by JVM collecting objects.').optional(),
    collection_time_in_millis: z.number().describe('Total time, in milliseconds, spent by JVM collecting objects.').optional()
});

export const nodes_types_garbage_collector = z.object({
    collectors: z.record(nodes_types_garbage_collector_total).describe('Contains statistics about JVM garbage collectors for the node.').optional()
});

export const nodes_types_pool = z.object({
    used_in_bytes: z.number().describe('Memory, in bytes, used by the heap.').optional(),
    max_in_bytes: z.number().describe('Maximum amount of memory, in bytes, available for use by the heap.').optional(),
    peak_used_in_bytes: z.number().describe('Largest amount of memory, in bytes, historically used by the heap.').optional(),
    peak_max_in_bytes: z.number().describe('Largest amount of memory, in bytes, historically used by the heap.').optional()
});

export const nodes_types_jvm_memory_stats = z.object({
    heap_used_in_bytes: z.number().describe('Memory, in bytes, currently in use by the heap.').optional(),
    heap_used_percent: z.number().describe('Percentage of memory currently in use by the heap.').optional(),
    heap_committed_in_bytes: z.number().describe('Amount of memory, in bytes, available for use by the heap.').optional(),
    heap_max_in_bytes: z.number().describe('Maximum amount of memory, in bytes, available for use by the heap.').optional(),
    heap_max: types_byte_size.optional(),
    non_heap_used_in_bytes: z.number().describe('Non-heap memory used, in bytes.').optional(),
    non_heap_committed_in_bytes: z.number().describe('Amount of non-heap memory available, in bytes.').optional(),
    pools: z.record(nodes_types_pool).describe('Contains statistics about heap memory usage for the node.').optional()
});

export const nodes_types_jvm_threads = z.object({
    count: z.number().describe('Number of active threads in use by JVM.').optional(),
    peak_count: z.number().describe('Highest number of threads used by JVM.').optional()
});

export const nodes_types_jvm = z.object({
    buffer_pools: z.record(nodes_types_node_buffer_pool).describe('Contains statistics about JVM buffer pools for the node.').optional(),
    classes: nodes_types_jvm_classes.optional(),
    gc: nodes_types_garbage_collector.optional(),
    mem: nodes_types_jvm_memory_stats.optional(),
    threads: nodes_types_jvm_threads.optional(),
    timestamp: z.number().describe('Last time JVM statistics were refreshed.').optional(),
    uptime: z.string().describe('Human-readable JVM uptime.\nOnly returned if the `human` query parameter is `true`.').optional(),
    uptime_in_millis: z.number().describe('JVM uptime in milliseconds.').optional()
});

export const nodes_types_cpu = z.object({
    percent: z.number().optional(),
    sys: types_duration.optional(),
    sys_in_millis: types_duration_value_unit_millis.optional(),
    total: types_duration.optional(),
    total_in_millis: types_duration_value_unit_millis.optional(),
    user: types_duration.optional(),
    user_in_millis: types_duration_value_unit_millis.optional(),
    load_average: z.record(z.number()).optional()
});

export const nodes_types_memory_stats = z.object({
    adjusted_total_in_bytes: z.number().describe('If the amount of physical memory has been overridden using the `es`.`total_memory_bytes` system property then this reports the overridden value in bytes.\nOtherwise it reports the same value as `total_in_bytes`.').optional(),
    resident: z.string().optional(),
    resident_in_bytes: z.number().optional(),
    share: z.string().optional(),
    share_in_bytes: z.number().optional(),
    total_virtual: z.string().optional(),
    total_virtual_in_bytes: z.number().optional(),
    total_in_bytes: z.number().describe('Total amount of physical memory in bytes.').optional(),
    free_in_bytes: z.number().describe('Amount of free physical memory in bytes.').optional(),
    used_in_bytes: z.number().describe('Amount of used physical memory in bytes.').optional()
});

export const nodes_types_extended_memory_stats = nodes_types_memory_stats.and(z.object({
    free_percent: z.number().describe('Percentage of free memory.').optional(),
    used_percent: z.number().describe('Percentage of used memory.').optional()
}));

export const nodes_types_cpu_acct = z.object({
    control_group: z.string().describe('The `cpuacct` control group to which the Elasticsearch process belongs.').optional(),
    usage_nanos: types_duration_value_unit_nanos.optional()
});

export const nodes_types_cgroup_cpu_stat = z.object({
    number_of_elapsed_periods: z.number().describe('The number of reporting periods (as specified by `cfs_period_micros`) that have elapsed.').optional(),
    number_of_times_throttled: z.number().describe('The number of times all tasks in the same cgroup as the Elasticsearch process have been throttled.').optional(),
    time_throttled_nanos: types_duration_value_unit_nanos.optional()
});

export const nodes_types_cgroup_cpu = z.object({
    control_group: z.string().describe('The `cpu` control group to which the Elasticsearch process belongs.').optional(),
    cfs_period_micros: z.number().describe('The period of time, in microseconds, for how regularly all tasks in the same cgroup as the Elasticsearch process should have their access to CPU resources reallocated.').optional(),
    cfs_quota_micros: z.number().describe('The total amount of time, in microseconds, for which all tasks in the same cgroup as the Elasticsearch process can run during one period `cfs_period_micros`.').optional(),
    stat: nodes_types_cgroup_cpu_stat.optional()
});

export const nodes_types_cgroup_memory = z.object({
    control_group: z.string().describe('The `memory` control group to which the Elasticsearch process belongs.').optional(),
    limit_in_bytes: z.string().describe('The maximum amount of user memory (including file cache) allowed for all tasks in the same cgroup as the Elasticsearch process.\nThis value can be too big to store in a `long`, so is returned as a string so that the value returned can exactly match what the underlying operating system interface returns.\nAny value that is too large to parse into a `long` almost certainly means no limit has been set for the cgroup.').optional(),
    usage_in_bytes: z.string().describe('The total current memory usage by processes in the cgroup, in bytes, by all tasks in the same cgroup as the Elasticsearch process.\nThis value is stored as a string for consistency with `limit_in_bytes`.').optional()
});

export const nodes_types_cgroup = z.object({
    cpuacct: nodes_types_cpu_acct.optional(),
    cpu: nodes_types_cgroup_cpu.optional(),
    memory: nodes_types_cgroup_memory.optional()
});

export const nodes_types_operating_system = z.object({
    cpu: nodes_types_cpu.optional(),
    mem: nodes_types_extended_memory_stats.optional(),
    swap: nodes_types_memory_stats.optional(),
    cgroup: nodes_types_cgroup.optional(),
    timestamp: z.number().optional()
});

export const nodes_types_process = z.object({
    cpu: nodes_types_cpu.optional(),
    mem: nodes_types_memory_stats.optional(),
    open_file_descriptors: z.number().describe('Number of opened file descriptors associated with the current or `-1` if not supported.').optional(),
    max_file_descriptors: z.number().describe('Maximum number of file descriptors allowed on the system, or `-1` if not supported.').optional(),
    timestamp: z.number().describe('Last time the statistics were refreshed.\nRecorded in milliseconds since the Unix Epoch.').optional()
});

export const nodes_types_script_cache = z.object({
    cache_evictions: z.number().describe('Total number of times the script cache has evicted old data.').optional(),
    compilation_limit_triggered: z.number().describe('Total number of times the script compilation circuit breaker has limited inline script compilations.').optional(),
    compilations: z.number().describe('Total number of inline script compilations performed by the node.').optional(),
    context: z.string().optional()
});

export const nodes_types_transport_histogram = z.object({
    count: z.number().describe('The number of times a transport thread took a period of time within the bounds of this bucket to handle an inbound message.').optional(),
    lt_millis: z.number().describe('The exclusive upper bound of the bucket in milliseconds.\nMay be omitted on the last bucket if this bucket has no upper bound.').optional(),
    ge_millis: z.number().describe('The inclusive lower bound of the bucket in milliseconds. May be omitted on the first bucket if this bucket has no lower bound.').optional()
});

export const nodes_types_transport = z.object({
    inbound_handling_time_histogram: z.array(nodes_types_transport_histogram).describe('The distribution of the time spent handling each inbound message on a transport thread, represented as a histogram.').optional(),
    outbound_handling_time_histogram: z.array(nodes_types_transport_histogram).describe('The distribution of the time spent sending each outbound transport message on a transport thread, represented as a histogram.').optional(),
    rx_count: z.number().describe('Total number of RX (receive) packets received by the node during internal cluster communication.').optional(),
    rx_size: z.string().describe('Size of RX packets received by the node during internal cluster communication.').optional(),
    rx_size_in_bytes: z.number().describe('Size, in bytes, of RX packets received by the node during internal cluster communication.').optional(),
    server_open: z.number().describe('Current number of inbound TCP connections used for internal communication between nodes.').optional(),
    tx_count: z.number().describe('Total number of TX (transmit) packets sent by the node during internal cluster communication.').optional(),
    tx_size: z.string().describe('Size of TX packets sent by the node during internal cluster communication.').optional(),
    tx_size_in_bytes: z.number().describe('Size, in bytes, of TX packets sent by the node during internal cluster communication.').optional(),
    total_outbound_connections: z.number().describe('The cumulative number of outbound transport connections that this node has opened since it started.\nEach transport connection may comprise multiple TCP connections but is only counted once in this statistic.\nTransport connections are typically long-lived so this statistic should remain constant in a stable cluster.').optional()
});

export const nodes_types_cluster_state_queue = z.object({
    total: z.number().describe('Total number of cluster states in queue.').optional(),
    pending: z.number().describe('Number of pending cluster states in queue.').optional(),
    committed: z.number().describe('Number of committed cluster states in queue.').optional()
});

export const nodes_types_published_cluster_states = z.object({
    full_states: z.number().describe('Number of published cluster states.').optional(),
    incompatible_diffs: z.number().describe('Number of incompatible differences between published cluster states.').optional(),
    compatible_diffs: z.number().describe('Number of compatible differences between published cluster states.').optional()
});

export const nodes_types_cluster_state_update = z.object({
    count: z.number().describe('The number of cluster state update attempts that did not change the cluster state since the node started.'),
    computation_time: types_duration.optional(),
    computation_time_millis: types_duration_value_unit_millis.optional(),
    publication_time: types_duration.optional(),
    publication_time_millis: types_duration_value_unit_millis.optional(),
    context_construction_time: types_duration.optional(),
    context_construction_time_millis: types_duration_value_unit_millis.optional(),
    commit_time: types_duration.optional(),
    commit_time_millis: types_duration_value_unit_millis.optional(),
    completion_time: types_duration.optional(),
    completion_time_millis: types_duration_value_unit_millis.optional(),
    master_apply_time: types_duration.optional(),
    master_apply_time_millis: types_duration_value_unit_millis.optional(),
    notification_time: types_duration.optional(),
    notification_time_millis: types_duration_value_unit_millis.optional()
});

export const nodes_types_serialized_cluster_state_detail = z.object({
    count: z.number().optional(),
    uncompressed_size: z.string().optional(),
    uncompressed_size_in_bytes: z.number().optional(),
    compressed_size: z.string().optional(),
    compressed_size_in_bytes: z.number().optional()
});

export const nodes_types_serialized_cluster_state = z.object({
    full_states: nodes_types_serialized_cluster_state_detail.optional(),
    diffs: nodes_types_serialized_cluster_state_detail.optional()
});

export const nodes_types_recording = z.object({
    name: z.string().optional(),
    cumulative_execution_count: z.number().optional(),
    cumulative_execution_time: types_duration.optional(),
    cumulative_execution_time_millis: types_duration_value_unit_millis.optional()
});

export const nodes_types_cluster_applied_stats = z.object({
    recordings: z.array(nodes_types_recording).optional()
});

export const nodes_types_discovery = z.object({
    cluster_state_queue: nodes_types_cluster_state_queue.optional(),
    published_cluster_states: nodes_types_published_cluster_states.optional(),
    cluster_state_update: z.record(nodes_types_cluster_state_update).describe('Contains low-level statistics about how long various activities took during cluster state updates while the node was the elected master.\nOmitted if the node is not master-eligible.\nEvery field whose name ends in `_time` within this object is also represented as a raw number of milliseconds in a field whose name ends in `_time_millis`.\nThe human-readable fields with a `_time` suffix are only returned if requested with the `?human=true` query parameter.').optional(),
    serialized_cluster_states: nodes_types_serialized_cluster_state.optional(),
    cluster_applier_stats: nodes_types_cluster_applied_stats.optional()
});

export const nodes_types_indexing_pressure = z.object({
    memory: nodes_types_indexing_pressure_memory.optional()
});

export const nodes_usage_nodes_usage_metric = z.enum([
    '_all',
    'rest_actions',
    'aggregations'
]);

export const nodes_usage_nodes_usage_metrics = z.union([
    nodes_usage_nodes_usage_metric,
    z.array(nodes_usage_nodes_usage_metric)
]);

export const nodes_usage_node_usage = z.object({
    rest_actions: z.record(z.number()),
    since: types_epoch_time_unit_millis,
    timestamp: types_epoch_time_unit_millis,
    aggregations: z.record(z.record(z.unknown()))
});

export const nodes_usage_response_base = nodes_types_nodes_response_base.and(z.object({
    cluster_name: types_name,
    nodes: z.record(nodes_usage_node_usage)
}));

export const query_rules_types_query_rule_type = z.enum(['pinned', 'exclude']);

export const query_rules_types_query_rule_criteria_type = z.enum([
    'global',
    'exact',
    'exact_fuzzy',
    'fuzzy',
    'prefix',
    'suffix',
    'contains',
    'lt',
    'lte',
    'gt',
    'gte',
    'always'
]);

export const query_rules_types_query_rule_criteria = z.object({
    type: query_rules_types_query_rule_criteria_type,
    metadata: z.string().describe('The metadata field to match against.\nThis metadata will be used to match against `match_criteria` sent in the rule.\nIt is required for all criteria types except `always`.').optional(),
    values: z.array(z.record(z.unknown())).describe('The values to match against the `metadata` field.\nOnly one value must match for the criteria to be met.\nIt is required for all criteria types except `always`.').optional()
});

export const query_rules_types_query_rule_actions = z.object({
    ids: z.array(types_id).describe('The unique document IDs of the documents to apply the rule to.\nOnly one of `ids` or `docs` may be specified and at least one must be specified.').optional(),
    docs: z.array(types_query_dsl_pinned_doc).describe('The documents to apply the rule to.\nOnly one of `ids` or `docs` may be specified and at least one must be specified.\nThere is a maximum value of 100 documents in a rule.\nYou can specify the following attributes for each document:\n\n* `_index`: The index of the document to pin.\n* `_id`: The unique document ID.').optional()
});

export const query_rules_types_query_rule = z.object({
    rule_id: types_id,
    type: query_rules_types_query_rule_type,
    criteria: z.union([
        query_rules_types_query_rule_criteria,
        z.array(query_rules_types_query_rule_criteria)
    ]),
    actions: query_rules_types_query_rule_actions,
    priority: z.number().optional()
});

export const query_rules_types_query_ruleset = z.object({
    ruleset_id: types_id,
    rules: z.array(query_rules_types_query_rule).describe('Rules associated with the query ruleset.')
});

export const query_rules_list_rulesets_query_ruleset_list_item = z.object({
    ruleset_id: types_id,
    rule_total_count: z.number().describe('The number of rules associated with the ruleset.'),
    rule_criteria_types_counts: z.record(z.number()).describe('A map of criteria type (for example, `exact`) to the number of rules of that type.\n\nNOTE: The counts in `rule_criteria_types_counts` may be larger than the value of `rule_total_count` because a rule may have multiple criteria.'),
    rule_type_counts: z.record(z.number()).describe('A map of rule type (for example, `pinned`) to the number of rules of that type.')
});

export const query_rules_test_query_ruleset_matched_rule = z.object({
    ruleset_id: types_id,
    rule_id: types_id
});

export const global_rank_eval_document_rating = z.object({
    _id: types_id,
    _index: types_index_name,
    rating: z.number().describe('The documents relevance with regard to this search request.')
});

export const global_rank_eval_rank_eval_metric_base = z.object({
    k: z.number().describe('Sets the maximum number of documents retrieved per query. This value will act in place of the usual size parameter in the query.').optional().default(10)
});

export const global_rank_eval_rank_eval_metric_rating_treshold = global_rank_eval_rank_eval_metric_base.and(z.object({
    relevant_rating_threshold: z.number().describe('Sets the rating threshold above which documents are considered to be "relevant".').optional().default(1)
}));

/**
 * Precision at K (P@k)
 */
export const global_rank_eval_rank_eval_metric_precision = global_rank_eval_rank_eval_metric_rating_treshold.and(z.object({
    ignore_unlabeled: z.boolean().describe('Controls how unlabeled documents in the search results are counted. If set to true, unlabeled documents are ignored and neither count as relevant or irrelevant. Set to false (the default), they are treated as irrelevant.').optional().default(false)
}));

/**
 * Recall at K (R@k)
 */
export const global_rank_eval_rank_eval_metric_recall = global_rank_eval_rank_eval_metric_rating_treshold.and(z.record(z.unknown()));

/**
 * Mean Reciprocal Rank
 */
export const global_rank_eval_rank_eval_metric_mean_reciprocal_rank = global_rank_eval_rank_eval_metric_rating_treshold.and(z.record(z.unknown()));

/**
 * Discounted cumulative gain (DCG)
 */
export const global_rank_eval_rank_eval_metric_discounted_cumulative_gain = global_rank_eval_rank_eval_metric_base.and(z.object({
    normalize: z.boolean().describe('If set to true, this metric will calculate the Normalized DCG.').optional().default(false)
}));

/**
 * Expected Reciprocal Rank (ERR)
 */
export const global_rank_eval_rank_eval_metric_expected_reciprocal_rank = global_rank_eval_rank_eval_metric_base.and(z.object({
    maximum_relevance: z.number().describe('The highest relevance grade used in the user-supplied relevance judgments.')
}));

export const global_rank_eval_rank_eval_metric = z.object({
    precision: global_rank_eval_rank_eval_metric_precision.optional(),
    recall: global_rank_eval_rank_eval_metric_recall.optional(),
    mean_reciprocal_rank: global_rank_eval_rank_eval_metric_mean_reciprocal_rank.optional(),
    dcg: global_rank_eval_rank_eval_metric_discounted_cumulative_gain.optional(),
    expected_reciprocal_rank: global_rank_eval_rank_eval_metric_expected_reciprocal_rank.optional()
});

export const global_rank_eval_unrated_document = z.object({
    _id: types_id,
    _index: types_index_name
});

export const global_rank_eval_rank_eval_hit = z.object({
    _id: types_id,
    _index: types_index_name,
    _score: z.number()
});

export const global_rank_eval_rank_eval_hit_item = z.object({
    hit: global_rank_eval_rank_eval_hit,
    rating: z.union([
        z.number(),
        z.string(),
        z.null()
    ]).optional()
});

export const global_rank_eval_rank_eval_metric_detail = z.object({
    metric_score: z.number().describe('The metric_score in the details section shows the contribution of this query to the global quality metric score'),
    unrated_docs: z.array(global_rank_eval_unrated_document).describe('The unrated_docs section contains an _index and _id entry for each document in the search result for this query that didnt have a ratings value. This can be used to ask the user to supply ratings for these documents'),
    hits: z.array(global_rank_eval_rank_eval_hit_item).describe('The hits section shows a grouping of the search results with their supplied ratings'),
    metric_details: z.record(z.record(z.record(z.unknown()))).describe('The metric_details give additional information about the calculated quality metric (e.g. how many of the retrieved documents were relevant). The content varies for each metric but allows for better interpretation of the results')
});

export const global_reindex_destination = z.object({
    index: types_index_name,
    op_type: types_op_type.optional(),
    pipeline: z.string().describe('The name of the pipeline to use.').optional(),
    routing: types_routing.optional(),
    version_type: types_version_type.optional()
});

export const types_username = z.string();

export const global_reindex_remote_source = z.object({
    connect_timeout: types_duration.optional(),
    headers: z.record(z.string()).describe('An object containing the headers of the request.').optional(),
    host: types_host,
    username: types_username.optional(),
    password: types_password.optional(),
    api_key: z.string().describe('The API key to use for authentication with the remote host (as an alternative to basic auth when the remote cluster is in Elastic Cloud).\n(It is not permitted to set this and also to set an `Authorization` header via `headers`.)').optional(),
    socket_timeout: types_duration.optional()
});

export const global_reindex_rethrottle_reindex_status = z.object({
    batches: z.number().describe('The number of scroll responses pulled back by the reindex.'),
    created: z.number().describe('The number of documents that were successfully created.'),
    deleted: z.number().describe('The number of documents that were successfully deleted.'),
    noops: z.number().describe('The number of documents that were ignored because the script used for the reindex returned a `noop` value for `ctx.op`.'),
    requests_per_second: z.number().describe('The number of requests per second effectively executed during the reindex.'),
    retries: types_retries,
    throttled: types_duration.optional(),
    throttled_millis: types_duration_value_unit_millis,
    throttled_until: types_duration.optional(),
    throttled_until_millis: types_duration_value_unit_millis,
    total: z.number().describe('The number of documents that were successfully processed.'),
    updated: z.number().describe('The number of documents that were successfully updated, for example, a document with same ID already existed prior to reindex updating it.'),
    version_conflicts: z.number().describe('The number of version conflicts that reindex hits.')
});

export const global_reindex_rethrottle_reindex_task = z.object({
    action: z.string(),
    cancellable: z.boolean(),
    description: z.string(),
    id: z.number(),
    node: types_name,
    running_time_in_nanos: types_duration_value_unit_nanos,
    start_time_in_millis: types_epoch_time_unit_millis,
    status: global_reindex_rethrottle_reindex_status,
    type: z.string(),
    headers: types_http_headers
});

export const spec_utils_base_node = z.object({
    attributes: z.record(z.string()),
    host: types_host,
    ip: types_ip,
    name: types_name,
    roles: types_node_roles.optional(),
    transport_address: types_transport_address
});

export const global_reindex_rethrottle_reindex_node = spec_utils_base_node.and(z.object({
    tasks: z.record(global_reindex_rethrottle_reindex_task)
}));

export const rollup_types_date_histogram_grouping = z.object({
    delay: types_duration.optional(),
    field: types_field,
    format: z.string().optional(),
    interval: types_duration.optional(),
    calendar_interval: types_duration.optional(),
    fixed_interval: types_duration.optional(),
    time_zone: types_time_zone.optional()
});

export const rollup_types_histogram_grouping = z.object({
    fields: types_fields,
    interval: z.number().describe('The interval of histogram buckets to be generated when rolling up.\nFor example, a value of `5` creates buckets that are five units wide (`0-5`, `5-10`, etc).\nNote that only one interval can be specified in the histogram group, meaning that all fields being grouped via the histogram must share the same interval.')
});

export const rollup_types_terms_grouping = z.object({
    fields: types_fields
});

export const rollup_types_groupings = z.object({
    date_histogram: rollup_types_date_histogram_grouping.optional(),
    histogram: rollup_types_histogram_grouping.optional(),
    terms: rollup_types_terms_grouping.optional()
});

export const rollup_types_metric = z.enum([
    'min',
    'max',
    'sum',
    'avg',
    'value_count'
]);

export const rollup_types_field_metric = z.object({
    field: types_field,
    metrics: z.array(rollup_types_metric).describe('An array of metrics to collect for the field. At least one metric must be configured.')
});

export const rollup_get_jobs_rollup_job_configuration = z.object({
    cron: z.string(),
    groups: rollup_types_groupings,
    id: types_id,
    index_pattern: z.string(),
    metrics: z.array(rollup_types_field_metric),
    page_size: z.number(),
    rollup_index: types_index_name,
    timeout: types_duration
});

export const rollup_get_jobs_rollup_job_stats = z.object({
    documents_processed: z.number(),
    index_failures: z.number(),
    index_time_in_ms: types_duration_value_unit_millis,
    index_total: z.number(),
    pages_processed: z.number(),
    rollups_indexed: z.number(),
    search_failures: z.number(),
    search_time_in_ms: types_duration_value_unit_millis,
    search_total: z.number(),
    trigger_count: z.number(),
    processing_time_in_ms: types_duration_value_unit_millis,
    processing_total: z.number()
});

export const rollup_get_jobs_indexing_job_state = z.enum([
    'started',
    'indexing',
    'stopping',
    'stopped',
    'aborting'
]);

export const rollup_get_jobs_rollup_job_status = z.object({
    current_position: z.record(z.record(z.unknown())).optional(),
    job_state: rollup_get_jobs_indexing_job_state,
    upgraded_doc_id: z.boolean().optional()
});

export const rollup_get_jobs_rollup_job = z.object({
    config: rollup_get_jobs_rollup_job_configuration,
    stats: rollup_get_jobs_rollup_job_stats,
    status: rollup_get_jobs_rollup_job_status
});

export const rollup_get_rollup_caps_rollup_field_summary = z.object({
    agg: z.string(),
    calendar_interval: types_duration.optional(),
    time_zone: types_time_zone.optional()
});

export const rollup_get_rollup_caps_rollup_capability_summary = z.object({
    fields: z.record(z.array(rollup_get_rollup_caps_rollup_field_summary)),
    index_pattern: z.string(),
    job_id: z.string(),
    rollup_index: z.string()
});

export const rollup_get_rollup_caps_rollup_capabilities = z.object({
    rollup_jobs: z.array(rollup_get_rollup_caps_rollup_capability_summary).describe('There can be multiple, independent jobs configured for a single index or index pattern. Each of these jobs may have different configurations, so the API returns a list of all the various configurations available.')
});

export const rollup_get_rollup_index_caps_rollup_job_summary_field = z.object({
    agg: z.string(),
    time_zone: types_time_zone.optional(),
    calendar_interval: types_duration.optional()
});

export const rollup_get_rollup_index_caps_rollup_job_summary = z.object({
    fields: z.record(z.array(rollup_get_rollup_index_caps_rollup_job_summary_field)),
    index_pattern: z.string(),
    job_id: types_id,
    rollup_index: types_index_name
});

export const rollup_get_rollup_index_caps_index_capabilities = z.object({
    rollup_jobs: z.array(rollup_get_rollup_index_caps_rollup_job_summary)
});

export const global_scripts_painless_execute_painless_context = z.enum([
    'painless_test',
    'filter',
    'score',
    'boolean_field',
    'date_field',
    'double_field',
    'geo_point_field',
    'ip_field',
    'keyword_field',
    'long_field',
    'composite_field'
]);

export const search_application_types_event_data_stream = z.object({
    name: types_index_name
});

export const search_application_types_analytics_collection = z.object({
    event_data_stream: search_application_types_event_data_stream
});

export const search_application_types_event_type = z.enum([
    'page_view',
    'search',
    'search_click'
]);

export const search_application_put_behavioral_analytics_analytics_acknowledge_response_base = types_acknowledged_response_base.and(z.object({
    name: types_name
}));

export const global_search_mvt_types_zoom_level = z.number();

export const global_search_mvt_types_coordinate = z.number();

export const global_search_mvt_types_grid_aggregation_type = z.enum(['geotile', 'geohex']);

export const global_search_mvt_types_grid_type = z.enum([
    'grid',
    'point',
    'centroid'
]);

export const types_mapbox_vector_tiles = z.record(z.unknown());

export const global_search_shards_search_shards_node_attributes = z.object({
    name: types_node_name,
    ephemeral_id: types_id,
    transport_address: types_transport_address,
    external_id: z.string(),
    attributes: z.record(z.string()).describe('Lists node attributes.'),
    roles: types_node_roles,
    version: types_version_string,
    min_index_version: z.number(),
    max_index_version: z.number()
});

export const types_relocation_failure_info = z.object({
    failed_attempts: z.number()
});

export const types_node_shard = z.object({
    state: indices_stats_shard_routing_state,
    primary: z.boolean(),
    node: types_node_name.optional(),
    shard: z.number(),
    index: types_index_name,
    allocation_id: z.record(types_id).optional(),
    recovery_source: z.record(types_id).optional(),
    unassigned_info: cluster_allocation_explain_unassigned_information.optional(),
    relocating_node: z.union([
        types_node_id,
        z.string(),
        z.null()
    ]).optional(),
    relocation_failure_info: types_relocation_failure_info.optional()
});

export const searchable_snapshots_cache_stats_shared = z.object({
    reads: z.number(),
    bytes_read_in_bytes: types_byte_size,
    writes: z.number(),
    bytes_written_in_bytes: types_byte_size,
    evictions: z.number(),
    num_regions: z.number(),
    size_in_bytes: types_byte_size,
    region_size_in_bytes: types_byte_size
});

export const searchable_snapshots_cache_stats_node = z.object({
    shared_cache: searchable_snapshots_cache_stats_shared
});

export const searchable_snapshots_mount_mounted_snapshot = z.object({
    snapshot: types_name,
    indices: types_indices,
    shards: types_shard_statistics
});

export const searchable_snapshots_types_stats_level = z.enum([
    'cluster',
    'indices',
    'shards'
]);

export const security_types_grant_type = z.enum(['password', 'access_token']);

export const security_types_user_profile_hit_metadata = z.object({
    _primary_term: z.number(),
    _seq_no: types_sequence_number
});

export const security_types_user_profile_id = z.string();

export const security_types_user_profile_user = z.object({
    email: z.union([
        z.string(),
        z.null()
    ]).optional(),
    full_name: z.union([
        types_name,
        z.string(),
        z.null()
    ]).optional(),
    realm_name: types_name,
    realm_domain: types_name.optional(),
    roles: z.array(z.string()),
    username: types_username
});

export const security_types_user_profile = z.object({
    uid: security_types_user_profile_id,
    user: security_types_user_profile_user,
    data: z.record(z.record(z.unknown())),
    labels: z.record(z.record(z.unknown())),
    enabled: z.boolean().optional()
});

export const security_types_user_profile_with_metadata = security_types_user_profile.and(z.object({
    last_synchronized: z.number(),
    _doc: security_types_user_profile_hit_metadata
}));

export const security_types_api_key_managed_by = z.enum(['cloud', 'elasticsearch']);

export const security_authenticate_authenticate_api_key = z.object({
    id: types_id,
    name: types_name.optional(),
    managed_by: security_types_api_key_managed_by,
    internal: z.boolean().optional()
});

export const security_types_realm_info = z.object({
    name: types_name,
    type: z.string()
});

export const security_authenticate_token = z.object({
    name: types_name,
    type: z.string().optional()
});

export const security_types_bulk_error = z.object({
    count: z.number().describe('The number of errors'),
    details: z.record(types_error_cause).describe('Details about the errors, keyed by role name')
});

export const security_types_cluster_privilege = z.union([
    z.enum([
        'all',
        'cancel_task',
        'create_snapshot',
        'cross_cluster_replication',
        'cross_cluster_search',
        'delegate_pki',
        'grant_api_key',
        'manage',
        'manage_api_key',
        'manage_autoscaling',
        'manage_behavioral_analytics',
        'manage_ccr',
        'manage_data_frame_transforms',
        'manage_data_stream_global_retention',
        'manage_enrich',
        'manage_esql',
        'manage_ilm',
        'manage_index_templates',
        'manage_inference',
        'manage_ingest_pipelines',
        'manage_logstash_pipelines',
        'manage_ml',
        'manage_oidc',
        'manage_own_api_key',
        'manage_pipeline',
        'manage_rollup',
        'manage_saml',
        'manage_search_application',
        'manage_search_query_rules',
        'manage_search_synonyms',
        'manage_security',
        'manage_service_account',
        'manage_slm',
        'manage_token',
        'manage_transform',
        'manage_user_profile',
        'manage_watcher',
        'monitor',
        'monitor_data_frame_transforms',
        'monitor_data_stream_global_retention',
        'monitor_enrich',
        'monitor_esql',
        'monitor_inference',
        'monitor_ml',
        'monitor_rollup',
        'monitor_snapshot',
        'monitor_stats',
        'monitor_text_structure',
        'monitor_transform',
        'monitor_watcher',
        'none',
        'post_behavioral_analytics_event',
        'read_ccr',
        'read_fleet_secrets',
        'read_ilm',
        'read_pipeline',
        'read_security',
        'read_slm',
        'transport_client',
        'write_connector_secrets',
        'write_fleet_secrets'
    ]),
    z.string()
]);

export const security_types_field_security = z.object({
    except: types_fields.optional(),
    grant: types_fields.optional()
});

export const security_types_index_privilege = z.union([
    z.enum([
        'all',
        'auto_configure',
        'create',
        'create_doc',
        'create_index',
        'cross_cluster_replication',
        'cross_cluster_replication_internal',
        'delete',
        'delete_index',
        'index',
        'maintenance',
        'manage',
        'manage_data_stream_lifecycle',
        'manage_follow_index',
        'manage_ilm',
        'manage_leader_index',
        'monitor',
        'none',
        'read',
        'read_cross_cluster',
        'view_index_metadata',
        'write'
    ]),
    z.string()
]);

export const security_types_remote_cluster_privilege = z.enum(['monitor_enrich', 'monitor_stats']);

/**
 * The subset of cluster level privileges that can be defined for remote clusters.
 */
export const security_types_remote_cluster_privileges = z.object({
    clusters: types_names,
    privileges: z.array(security_types_remote_cluster_privilege).describe('The cluster level privileges that owners of the role have on the remote cluster.')
}).describe('The subset of cluster level privileges that can be defined for remote clusters.');

export const security_types_manage_user_privileges = z.object({
    applications: z.array(z.string())
});

export const security_types_application_global_user_privileges = z.object({
    manage: security_types_manage_user_privileges
});

export const security_types_global_privilege = z.object({
    application: security_types_application_global_user_privileges
});

export const security_types_application_privileges = z.object({
    application: z.string().describe('The name of the application to which this entry applies.'),
    privileges: z.array(z.string()).describe('A list of strings, where each element is the name of an application privilege or action.'),
    resources: z.array(z.string()).describe('A list resources to which the privileges are applied.')
});

export const security_types_restriction_workflow = z.union([
    z.enum(['search_application_query']),
    z.string()
]);

export const security_types_restriction = z.object({
    workflows: z.array(security_types_restriction_workflow).describe('A list of workflows to which the API key is restricted.\nNOTE: In order to use a role restriction, an API key must be created with a single role descriptor.')
});

export const security_types_cluster_node = z.object({
    name: types_name
});

export const types_namespace = z.string();

export const types_service = z.string();

export const security_types_replication_access = z.object({
    names: z.union([
        types_index_name,
        z.array(types_index_name)
    ]),
    allow_restricted_indices: z.boolean().describe('This needs to be set to true if the patterns in the names field should cover system indices.').optional().default(false)
});

export const security_create_service_token_token = z.object({
    name: types_name,
    value: z.string()
});

export const security_delegate_pki_authentication_realm = z.object({
    name: z.string(),
    type: z.string(),
    domain: z.string().optional()
});

export const security_delegate_pki_authentication = z.object({
    username: z.string(),
    roles: z.array(z.string()),
    full_name: z.union([
        z.string(),
        z.null()
    ]),
    email: z.union([
        z.string(),
        z.null()
    ]),
    token: z.record(z.string()).optional(),
    metadata: types_metadata,
    enabled: z.boolean(),
    authentication_realm: security_delegate_pki_authentication_realm,
    lookup_realm: security_delegate_pki_authentication_realm,
    authentication_type: z.string(),
    api_key: z.record(z.string()).optional()
});

export const security_delete_privileges_found_status = z.object({
    found: z.boolean()
});

export const security_enroll_kibana_token = z.object({
    name: z.string().describe('The name of the bearer token for the `elastic/kibana` service account.'),
    value: z.string().describe('The value of the bearer token for the `elastic/kibana` service account.\nUse this value to authenticate the service account with Elasticsearch.')
});

export const security_types_api_key_type = z.enum(['rest', 'cross_cluster']);

export const security_put_privileges_actions = z.object({
    actions: z.array(z.string()),
    application: z.string().optional(),
    name: types_name.optional(),
    metadata: types_metadata.optional()
});

export const security_types_template_format = z.enum(['string', 'json']);

export const security_types_role_mapping_rule: z.AnyZodObject = z.object({
    any: z.array(z.lazy(() => security_types_role_mapping_rule)).optional(),
    all: z.array(z.lazy(() => security_types_role_mapping_rule)).optional(),
    field: z.record(z.union([
        types_field_value,
        z.array(types_field_value)
    ])).optional(),
    except: z.lazy(() => security_types_role_mapping_rule).optional()
});

export const security_get_service_credentials_nodes_credentials_file_token = z.object({
    nodes: z.array(z.string())
});

export const security_get_service_credentials_nodes_credentials = z.object({
    _nodes: types_node_statistics,
    file_tokens: z.record(security_get_service_credentials_nodes_credentials_file_token).describe('File-backed tokens collected from all nodes')
});

export const xpack_usage_security_roles_dls_bit_set_cache = z.object({
    count: z.number().describe('Number of entries in the cache.'),
    memory: types_byte_size.optional(),
    memory_in_bytes: types_ulong,
    hits: z.number().describe('Total number of cache hits.'),
    misses: z.number().describe('Total number of cache misses.'),
    evictions: z.number().describe('Total number of cache evictions.'),
    hits_time_in_millis: types_duration_value_unit_millis,
    misses_time_in_millis: types_duration_value_unit_millis
});

export const xpack_usage_security_roles_dls = z.object({
    bit_set_cache: xpack_usage_security_roles_dls_bit_set_cache
});

export const security_types_roles_stats = z.object({
    dls: xpack_usage_security_roles_dls
});

export const security_types_node_security_stats = z.object({
    roles: security_types_roles_stats
});

export const security_get_token_access_token_grant_type = z.enum([
    'password',
    'client_credentials',
    '_kerberos',
    'refresh_token'
]);

export const security_get_token_user_realm = z.object({
    name: types_name,
    type: z.string()
});

export const security_get_token_authentication_provider = z.object({
    type: z.string(),
    name: types_name
});

export const security_types_user = z.object({
    email: z.union([
        z.string(),
        z.null()
    ]).optional(),
    full_name: z.union([
        types_name,
        z.string(),
        z.null()
    ]).optional(),
    metadata: types_metadata,
    roles: z.array(z.string()),
    username: types_username,
    enabled: z.boolean(),
    profile_uid: security_types_user_profile_id.optional()
});

export const security_get_token_authenticated_user = security_types_user.and(z.object({
    authentication_realm: security_get_token_user_realm,
    lookup_realm: security_get_token_user_realm,
    authentication_provider: security_get_token_authentication_provider.optional(),
    authentication_type: z.string()
}));

export const security_get_user_profile_get_user_profile_errors = z.object({
    count: z.number(),
    details: z.record(types_error_cause)
});

export const security_grant_api_key_api_key_grant_type = z.enum(['access_token', 'password']);

export const security_has_privileges_application_privileges_check = z.object({
    application: z.string().describe('The name of the application.'),
    privileges: z.array(z.string()).describe('A list of the privileges that you want to check for the specified resources.\nIt may be either application privilege names or the names of actions that are granted by those privileges'),
    resources: z.array(z.string()).describe('A list of resource names against which the privileges should be checked.')
});

export const security_has_privileges_index_privileges_check = z.object({
    names: types_indices,
    privileges: z.array(security_types_index_privilege).describe('A list of the privileges that you want to check for the specified indices.'),
    allow_restricted_indices: z.boolean().describe('This needs to be set to `true` (default is `false`) if using wildcards or regexps for patterns that cover restricted indices.\nImplicitly, restricted indices do not match index patterns because restricted indices usually have limited privileges and including them in pattern tests would render most such tests false.\nIf restricted indices are explicitly included in the names list, privileges will be checked against them regardless of the value of `allow_restricted_indices`.').optional()
});

export const security_has_privileges_privileges = z.record(z.boolean());

export const security_has_privileges_resource_privileges = z.record(security_has_privileges_privileges);

export const security_has_privileges_applications_privileges = z.record(security_has_privileges_resource_privileges);

export const security_has_privileges_user_profile_privileges_check = z.object({
    application: z.array(security_has_privileges_application_privileges_check).optional(),
    cluster: z.array(security_types_cluster_privilege).describe('A list of the cluster privileges that you want to check.').optional(),
    index: z.array(security_has_privileges_index_privileges_check).optional()
});

export const security_has_privileges_user_profile_has_privileges_user_profile_errors = z.object({
    count: z.number(),
    details: z.record(types_error_cause)
});

export const security_types_created_status = z.object({
    created: z.boolean()
});

export const security_query_api_keys_api_key_aggregate = z.union([
    types_aggregations_cardinality_aggregate,
    types_aggregations_value_count_aggregate,
    types_aggregations_string_terms_aggregate,
    types_aggregations_long_terms_aggregate,
    types_aggregations_double_terms_aggregate,
    types_aggregations_unmapped_terms_aggregate,
    types_aggregations_multi_terms_aggregate,
    types_aggregations_missing_aggregate,
    types_aggregations_filter_aggregate,
    types_aggregations_filters_aggregate,
    types_aggregations_range_aggregate,
    types_aggregations_date_range_aggregate,
    types_aggregations_composite_aggregate
]);

export const security_query_user_query_user = security_types_user.and(z.object({
    _sort: types_sort_results.optional()
}));

export const security_suggest_user_profiles_hint = z.object({
    uids: z.array(security_types_user_profile_id).describe('A list of profile UIDs to match against.').optional(),
    labels: z.record(z.union([
        z.string(),
        z.array(z.string())
    ])).describe('A single key-value pair to match against the labels section\nof a profile. A profile is considered matching if it matches\nat least one of the strings.').optional()
});

export const security_suggest_user_profiles_total_user_profiles = z.object({
    value: z.number(),
    relation: types_relation_name
});

export const simulate_ingest_merge_type = z.enum(['index', 'template']);

export const slm_types_in_progress = z.object({
    name: types_name,
    start_time_millis: types_epoch_time_unit_millis,
    state: z.string(),
    uuid: types_uuid
});

export const slm_types_invocation = z.object({
    snapshot_name: types_name,
    time: types_date_time
});

export const slm_types_configuration = z.object({
    ignore_unavailable: z.boolean().describe('If false, the snapshot fails if any data stream or index in indices is missing or closed. If true, the snapshot ignores missing or closed data streams and indices.').optional().default(false),
    indices: types_indices.optional(),
    include_global_state: z.boolean().describe('If true, the current global state is included in the snapshot.').optional().default(true),
    feature_states: z.array(z.string()).describe('A list of feature states to be included in this snapshot. A list of features available for inclusion in the snapshot and their descriptions be can be retrieved using the get features API.\nEach feature state includes one or more system indices containing data necessary for the function of that feature. Providing an empty array will include no feature states in the snapshot, regardless of the value of include_global_state. By default, all available feature states will be included in the snapshot if include_global_state is true, or no feature states if include_global_state is false.').optional(),
    metadata: types_metadata.optional(),
    partial: z.boolean().describe('If false, the entire snapshot will fail if one or more indices included in the snapshot do not have all primary shards available.').optional().default(false)
});

export const slm_types_retention = z.object({
    expire_after: types_duration,
    max_count: z.number().describe('Maximum number of snapshots to retain, even if the snapshots have not yet expired. If the number of snapshots in the repository exceeds this limit, the policy retains the most recent snapshots and deletes older snapshots.'),
    min_count: z.number().describe('Minimum number of snapshots to retain, even if the snapshots have expired.')
});

export const watcher_types_cron_expression = z.string();

export const slm_types_policy = z.object({
    config: slm_types_configuration.optional(),
    name: types_name,
    repository: z.string(),
    retention: slm_types_retention.optional(),
    schedule: watcher_types_cron_expression
});

export const slm_types_statistics = z.object({
    retention_deletion_time: types_duration.optional(),
    retention_deletion_time_millis: types_duration_value_unit_millis.optional(),
    retention_failed: z.number().optional(),
    retention_runs: z.number().optional(),
    retention_timed_out: z.number().optional(),
    policy: types_id.optional(),
    total_snapshots_deleted: z.number().optional(),
    total_snapshot_deletion_failures: z.number().optional(),
    total_snapshots_failed: z.number().optional(),
    total_snapshots_taken: z.number().optional()
});

export const slm_types_snapshot_lifecycle = z.object({
    in_progress: slm_types_in_progress.optional(),
    last_failure: slm_types_invocation.optional(),
    last_success: slm_types_invocation.optional(),
    modified_date: types_date_time.optional(),
    modified_date_millis: types_epoch_time_unit_millis,
    next_execution: types_date_time.optional(),
    next_execution_millis: types_epoch_time_unit_millis,
    policy: slm_types_policy,
    version: types_version_number,
    stats: slm_types_statistics
});

export const slm_types_snapshot_policy_stats = z.object({
    policy: z.string(),
    snapshots_taken: z.number(),
    snapshots_failed: z.number(),
    snapshots_deleted: z.number(),
    snapshot_deletion_failures: z.number()
});

export const snapshot_cleanup_repository_cleanup_repository_results = z.object({
    deleted_blobs: z.number().describe('The number of binary large objects (blobs) removed from the snapshot repository during cleanup operations.\nA non-zero value indicates that unreferenced blobs were found and subsequently cleaned up.'),
    deleted_bytes: z.number().describe('The number of bytes freed by cleanup operations.')
});

export const snapshot_types_snapshot_shard_failure = z.object({
    index: types_index_name,
    node_id: types_id.optional(),
    reason: z.string(),
    shard_id: z.number(),
    index_uuid: types_id,
    status: z.string()
});

export const snapshot_types_index_details = z.object({
    shard_count: z.number(),
    size: types_byte_size.optional(),
    size_in_bytes: z.number(),
    max_segments_per_shard: z.number()
});

export const snapshot_types_info_feature_state = z.object({
    feature_name: z.string(),
    indices: types_indices
});

export const snapshot_types_snapshot_info = z.object({
    data_streams: z.array(z.string()),
    duration: types_duration.optional(),
    duration_in_millis: types_duration_value_unit_millis.optional(),
    end_time: types_date_time.optional(),
    end_time_in_millis: types_epoch_time_unit_millis.optional(),
    failures: z.array(snapshot_types_snapshot_shard_failure).optional(),
    include_global_state: z.boolean().optional(),
    indices: z.array(types_index_name).optional(),
    index_details: z.record(snapshot_types_index_details).optional(),
    metadata: types_metadata.optional(),
    reason: z.string().optional(),
    repository: types_name.optional(),
    snapshot: types_name,
    shards: types_shard_statistics.optional(),
    start_time: types_date_time.optional(),
    start_time_in_millis: types_epoch_time_unit_millis.optional(),
    state: z.string().optional(),
    uuid: types_uuid,
    version: types_version_string.optional(),
    version_id: types_version_number.optional(),
    feature_states: z.array(snapshot_types_info_feature_state).optional()
});

export const snapshot_types_repository_settings_base = z.object({
    chunk_size: types_byte_size.optional(),
    compress: z.boolean().describe('When set to `true`, metadata files are stored in compressed format.\nThis setting doesn\'t affect index files that are already compressed by default.').optional().default(true),
    max_restore_bytes_per_sec: types_byte_size.optional(),
    max_snapshot_bytes_per_sec: types_byte_size.optional()
});

export const snapshot_types_azure_repository_settings = snapshot_types_repository_settings_base.and(z.object({
    base_path: z.string().describe('The path to the repository data within the container.\nIt defaults to the root directory.\n\nNOTE: Don\'t set `base_path` when configuring a snapshot repository for Elastic Cloud Enterprise.\nElastic Cloud Enterprise automatically generates the `base_path` for each deployment so that multiple deployments can share the same bucket.').optional(),
    client: z.string().describe('The name of the Azure repository client to use.').optional().default('default'),
    container: z.string().describe('The Azure container.').optional().default('elasticsearch-snapshots'),
    delete_objects_max_size: z.number().describe('The maxmimum batch size, between 1 and 256, used for `BlobBatch` requests.\nDefaults to 256 which is the maximum number supported by the Azure blob batch API.').optional().default(256),
    location_mode: z.string().describe('Either `primary_only` or `secondary_only`.\nNote that if you set it to `secondary_only`, it will force `readonly` to `true`.').optional().default('primary_only'),
    max_concurrent_batch_deletes: z.number().describe('The maximum number of concurrent batch delete requests that will be submitted for any individual bulk delete with `BlobBatch`.\nNote that the effective number of concurrent deletes is further limited by the Azure client connection and event loop thread limits.\nDefaults to 10, minimum is 1, maximum is 100.').optional().default(10),
    readonly: z.boolean().describe('If `true`, the repository is read-only.\nThe cluster can retrieve and restore snapshots from the repository but not write to the repository or create snapshots in it.\n\nOnly a cluster with write access can create snapshots in the repository.\nAll other clusters connected to the repository should have the `readonly` parameter set to `true`.\nIf `false`, the cluster can write to the repository and create snapshots in it.\n\nIMPORTANT: If you register the same snapshot repository with multiple clusters, only one cluster should have write access to the repository.\nHaving multiple clusters write to the repository at the same time risks corrupting the contents of the repository.').optional().default(false)
}));

export const snapshot_types_repository_base = z.object({
    uuid: types_uuid.optional()
});

export const snapshot_types_azure_repository = snapshot_types_repository_base.and(z.object({
    type: z.enum(['azure']).describe('The Azure repository type.'),
    settings: snapshot_types_azure_repository_settings.optional()
}));

export const snapshot_types_gcs_repository_settings = snapshot_types_repository_settings_base.and(z.object({
    bucket: z.string().describe('The name of the bucket to be used for snapshots.'),
    application_name: z.string().describe('The name used by the client when it uses the Google Cloud Storage service.').optional(),
    base_path: z.string().describe('The path to the repository data within the bucket.\nIt defaults to the root of the bucket.\n\nNOTE: Don\'t set `base_path` when configuring a snapshot repository for Elastic Cloud Enterprise.\nElastic Cloud Enterprise automatically generates the `base_path` for each deployment so that multiple deployments can share the same bucket.').optional(),
    client: z.string().describe('The name of the client to use to connect to Google Cloud Storage.').optional().default('default'),
    readonly: z.boolean().describe('If `true`, the repository is read-only.\nThe cluster can retrieve and restore snapshots from the repository but not write to the repository or create snapshots in it.\n\nOnly a cluster with write access can create snapshots in the repository.\nAll other clusters connected to the repository should have the `readonly` parameter set to `true`.\n\nIf `false`, the cluster can write to the repository and create snapshots in it.\n\nIMPORTANT: If you register the same snapshot repository with multiple clusters, only one cluster should have write access to the repository.\nHaving multiple clusters write to the repository at the same time risks corrupting the contents of the repository.').optional().default(false)
}));

export const snapshot_types_gcs_repository = snapshot_types_repository_base.and(z.object({
    type: z.enum(['gcs']).describe('The Google Cloud Storage repository type.'),
    settings: snapshot_types_gcs_repository_settings
}));

export const snapshot_types_s3_repository_settings = snapshot_types_repository_settings_base.and(z.object({
    bucket: z.string().describe('The name of the S3 bucket to use for snapshots.\nThe bucket name must adhere to Amazon\'s S3 bucket naming rules.'),
    base_path: z.string().describe('The path to the repository data within its bucket.\nIt defaults to an empty string, meaning that the repository is at the root of the bucket.\nThe value of this setting should not start or end with a forward slash (`/`).\n\nNOTE: Don\'t set base_path when configuring a snapshot repository for Elastic Cloud Enterprise.\nElastic Cloud Enterprise automatically generates the `base_path` for each deployment so that multiple deployments may share the same bucket.').optional(),
    buffer_size: types_byte_size.optional(),
    canned_acl: z.string().describe('The S3 repository supports all S3 canned ACLs: `private`, `public-read`, `public-read-write`, `authenticated-read`, `log-delivery-write`, `bucket-owner-read`, `bucket-owner-full-control`.\nYou could specify a canned ACL using the `canned_acl` setting.\nWhen the S3 repository creates buckets and objects, it adds the canned ACL into the buckets and objects.').optional().default('private'),
    client: z.string().describe('The name of the S3 client to use to connect to S3.').optional().default('default'),
    delete_objects_max_size: z.number().describe('The maxmimum batch size, between 1 and 1000, used for `DeleteObjects` requests.\nDefaults to 1000 which is the maximum number supported by the  AWS DeleteObjects API.').optional().default(1000),
    get_register_retry_delay: types_duration.optional(),
    max_multipart_parts: z.number().describe('The maximum number of parts that Elasticsearch will write during a multipart upload of a single object.\nFiles which are larger than `buffer_size  max_multipart_parts` will be chunked into several smaller objects.\nElasticsearch may also split a file across multiple objects to satisfy other constraints such as the `chunk_size` limit.\nDefaults to `10000` which is the maximum number of parts in a multipart upload in AWS S3.').optional().default(10000),
    max_multipart_upload_cleanup_size: z.number().describe('The maximum number of possibly-dangling multipart uploads to clean up in each batch of snapshot deletions.\nDefaults to 1000 which is the maximum number supported by the AWS ListMultipartUploads API.\nIf set to `0`, Elasticsearch will not attempt to clean up dangling multipart uploads.').optional().default(1000),
    readonly: z.boolean().describe('If true, the repository is read-only.\nThe cluster can retrieve and restore snapshots from the repository but not write to the repository or create snapshots in it.\n\nOnly a cluster with write access can create snapshots in the repository.\nAll other clusters connected to the repository should have the `readonly` parameter set to `true`.\n\nIf `false`, the cluster can write to the repository and create snapshots in it.\n\nIMPORTANT: If you register the same snapshot repository with multiple clusters, only one cluster should have write access to the repository.\nHaving multiple clusters write to the repository at the same time risks corrupting the contents of the repository.').optional().default(false),
    server_side_encryption: z.boolean().describe('When set to `true`, files are encrypted on server side using an AES256 algorithm.').optional().default(false),
    storage_class: z.string().describe('The S3 storage class for objects written to the repository.\nValues may be `standard`, `reduced_redundancy`, `standard_ia`, `onezone_ia`, and `intelligent_tiering`.').optional().default('standard'),
    'throttled_delete_retry.delay_increment': types_duration.optional(),
    'throttled_delete_retry.maximum_delay': types_duration.optional(),
    'throttled_delete_retry.maximum_number_of_retries': z.number().describe('The number times to retry a throttled snapshot deletion.\nThe default is 10 and the minimum value is 0 which will disable retries altogether.\nNote that if retries are enabled in the Azure client, each of these retries comprises that many client-level retries.').optional()
}));

export const snapshot_types_s3_repository = snapshot_types_repository_base.and(z.object({
    type: z.enum(['s3']).describe('The S3 repository type.'),
    settings: snapshot_types_s3_repository_settings
}));

export const snapshot_types_shared_file_system_repository_settings = snapshot_types_repository_settings_base.and(z.object({
    location: z.string().describe('The location of the shared filesystem used to store and retrieve snapshots.\nThis location must be registered in the `path.repo` setting on all master and data nodes in the cluster.\nUnlike `path.repo`, this setting supports only a single file path.'),
    max_number_of_snapshots: z.number().describe('The maximum number of snapshots the repository can contain.\nThe default is `Integer.MAX_VALUE`, which is 2^31-1 or `2147483647`.').optional().default(2147483647),
    readonly: z.boolean().describe('If `true`, the repository is read-only.\nThe cluster can retrieve and restore snapshots from the repository but not write to the repository or create snapshots in it.\n\nOnly a cluster with write access can create snapshots in the repository.\nAll other clusters connected to the repository should have the `readonly` parameter set to `true`.\n\nIf `false`, the cluster can write to the repository and create snapshots in it.\n\nIMPORTANT: If you register the same snapshot repository with multiple clusters, only one cluster should have write access to the repository.\nHaving multiple clusters write to the repository at the same time risks corrupting the contents of the repository.').optional().default(false)
}));

export const snapshot_types_shared_file_system_repository = snapshot_types_repository_base.and(z.object({
    type: z.enum(['fs']).describe('The shared file system repository type.'),
    settings: snapshot_types_shared_file_system_repository_settings
}));

export const snapshot_types_read_only_url_repository_settings = snapshot_types_repository_settings_base.and(z.object({
    http_max_retries: z.number().describe('The maximum number of retries for HTTP and HTTPS URLs.').optional().default(5),
    http_socket_timeout: types_duration.optional(),
    max_number_of_snapshots: z.number().describe('The maximum number of snapshots the repository can contain.\nThe default is `Integer.MAX_VALUE`, which is 2^31-1 or `2147483647`.').optional().default(2147483647),
    url: z.string().describe('The URL location of the root of the shared filesystem repository.\nThe following protocols are supported:\n\n* `file`\n* `ftp`\n* `http`\n* `https`\n* `jar`\n\nURLs using the HTTP, HTTPS, or FTP protocols must be explicitly allowed with the `repositories.url.allowed_urls` cluster setting.\nThis setting supports wildcards in the place of a host, path, query, or fragment in the URL.\n\nURLs using the file protocol must point to the location of a shared filesystem accessible to all master and data nodes in the cluster.\nThis location must be registered in the `path.repo` setting.\nYou don\'t need to register URLs using the FTP, HTTP, HTTPS, or JAR protocols in the `path.repo` setting.')
}));

export const snapshot_types_read_only_url_repository = snapshot_types_repository_base.and(z.object({
    type: z.enum(['url']).describe('The read-only URL repository type.'),
    settings: snapshot_types_read_only_url_repository_settings
}));

export const snapshot_types_source_only_repository_settings = snapshot_types_repository_settings_base.and(z.object({
    delegate_type: z.string().describe('The delegated repository type. For valid values, refer to the `type` parameter.\nSource repositories can use `settings` properties for its delegated repository type.').optional(),
    max_number_of_snapshots: z.number().describe('The maximum number of snapshots the repository can contain.\nThe default is `Integer.MAX_VALUE`, which is 2^31-1 or `2147483647`.').optional().default(2147483647),
    read_only: z.boolean().describe('If `true`, the repository is read-only.\nThe cluster can retrieve and restore snapshots from the repository but not write to the repository or create snapshots in it.\n\nOnly a cluster with write access can create snapshots in the repository.\nAll other clusters connected to the repository should have the `readonly` parameter set to `true`.\n\nIf `false`, the cluster can write to the repository and create snapshots in it.\n\nIMPORTANT: If you register the same snapshot repository with multiple clusters, only one cluster should have write access to the repository.\nHaving multiple clusters write to the repository at the same time risks corrupting the contents of the repository.').optional().default(false)
}));

export const snapshot_types_source_only_repository = snapshot_types_repository_base.and(z.object({
    type: z.enum(['source']).describe('The source-only repository type.'),
    settings: snapshot_types_source_only_repository_settings
}));

export const snapshot_types_repository = z.union([
    snapshot_types_azure_repository,
    snapshot_types_gcs_repository,
    snapshot_types_s3_repository,
    snapshot_types_shared_file_system_repository,
    snapshot_types_read_only_url_repository,
    snapshot_types_source_only_repository
]);

export const snapshot_types_snapshot_sort = z.enum([
    'start_time',
    'duration',
    'name',
    'index_count',
    'repository',
    'shard_count',
    'failed_shard_count'
]);

export const snapshot_types_snapshot_state = z.enum([
    'IN_PROGRESS',
    'SUCCESS',
    'FAILED',
    'PARTIAL',
    'INCOMPATIBLE'
]);

export const snapshot_get_snapshot_response_item = z.object({
    repository: types_name,
    snapshots: z.array(snapshot_types_snapshot_info).optional(),
    error: types_error_cause.optional()
});

export const snapshot_repository_analyze_snapshot_node_info = z.object({
    id: types_id,
    name: types_name
});

export const snapshot_repository_analyze_read_blob_details = z.object({
    before_write_complete: z.boolean().describe('Indicates whether the read operation may have started before the write operation was complete.').optional(),
    elapsed: types_duration.optional(),
    elapsed_nanos: types_duration_value_unit_nanos.optional(),
    first_byte_time: types_duration.optional(),
    first_byte_time_nanos: types_duration_value_unit_nanos,
    found: z.boolean().describe('Indicates whether the blob was found by the read operation.\nIf the read was started before the write completed or the write was ended before completion, it might be false.'),
    node: snapshot_repository_analyze_snapshot_node_info,
    throttled: types_duration.optional(),
    throttled_nanos: types_duration_value_unit_nanos.optional()
});

export const snapshot_repository_analyze_blob_details = z.object({
    name: z.string().describe('The name of the blob.'),
    overwritten: z.boolean().describe('Indicates whether the blob was overwritten while the read operations were ongoing.\n  /**'),
    read_early: z.boolean(),
    read_end: z.number().describe('The position, in bytes, at which read operations completed.'),
    read_start: z.number().describe('The position, in bytes, at which read operations started.'),
    reads: snapshot_repository_analyze_read_blob_details,
    size: types_byte_size,
    size_bytes: z.number().describe('The size of the blob in bytes.')
});

export const snapshot_repository_analyze_details_info = z.object({
    blob: snapshot_repository_analyze_blob_details,
    overwrite_elapsed: types_duration.optional(),
    overwrite_elapsed_nanos: types_duration_value_unit_nanos.optional(),
    write_elapsed: types_duration,
    write_elapsed_nanos: types_duration_value_unit_nanos,
    write_throttled: types_duration,
    write_throttled_nanos: types_duration_value_unit_nanos,
    writer_node: snapshot_repository_analyze_snapshot_node_info
});

export const snapshot_repository_analyze_read_summary_info = z.object({
    count: z.number().describe('The number of read operations performed in the test.'),
    max_wait: types_duration,
    max_wait_nanos: types_duration_value_unit_nanos,
    total_elapsed: types_duration,
    total_elapsed_nanos: types_duration_value_unit_nanos,
    total_size: types_byte_size,
    total_size_bytes: z.number().describe('The total size of all the blobs or partial blobs read in the test, in bytes.'),
    total_throttled: types_duration,
    total_throttled_nanos: types_duration_value_unit_nanos,
    total_wait: types_duration,
    total_wait_nanos: types_duration_value_unit_nanos
});

export const snapshot_repository_analyze_write_summary_info = z.object({
    count: z.number().describe('The number of write operations performed in the test.'),
    total_elapsed: types_duration,
    total_elapsed_nanos: types_duration_value_unit_nanos,
    total_size: types_byte_size,
    total_size_bytes: z.number().describe('The total size of all the blobs written in the test, in bytes.'),
    total_throttled: types_duration,
    total_throttled_nanos: z.number().describe('The total time spent waiting due to the `max_snapshot_bytes_per_sec` throttle, in nanoseconds.')
});

export const snapshot_repository_analyze_summary_info = z.object({
    read: snapshot_repository_analyze_read_summary_info,
    write: snapshot_repository_analyze_write_summary_info
});

export const snapshot_restore_snapshot_restore = z.object({
    indices: z.array(types_index_name),
    snapshot: z.string(),
    shards: types_shard_statistics
});

export const snapshot_types_shards_stats_stage = z.enum([
    'DONE',
    'FAILURE',
    'FINALIZE',
    'INIT',
    'STARTED'
]);

export const snapshot_types_shards_stats_summary_item = z.object({
    file_count: z.number(),
    size_in_bytes: z.number()
});

export const snapshot_types_shards_stats_summary = z.object({
    incremental: snapshot_types_shards_stats_summary_item,
    total: snapshot_types_shards_stats_summary_item,
    start_time_in_millis: types_epoch_time_unit_millis,
    time: types_duration.optional(),
    time_in_millis: types_duration_value_unit_millis
});

export const snapshot_types_snapshot_shards_status = z.object({
    stage: snapshot_types_shards_stats_stage,
    stats: snapshot_types_shards_stats_summary
});

export const snapshot_types_shards_stats = z.object({
    done: z.number().describe('The number of shards that initialized, started, and finalized successfully.'),
    failed: z.number().describe('The number of shards that failed to be included in the snapshot.'),
    finalizing: z.number().describe('The number of shards that are finalizing but are not done.'),
    initializing: z.number().describe('The number of shards that are still initializing.'),
    started: z.number().describe('The number of shards that have started but are not finalized.'),
    total: z.number().describe('The total number of shards included in the snapshot.')
});

export const snapshot_types_file_count_snapshot_stats = z.object({
    file_count: z.number(),
    size_in_bytes: z.number()
});

export const snapshot_types_snapshot_stats = z.object({
    incremental: snapshot_types_file_count_snapshot_stats,
    start_time_in_millis: types_epoch_time_unit_millis,
    time: types_duration.optional(),
    time_in_millis: types_duration_value_unit_millis,
    total: snapshot_types_file_count_snapshot_stats
});

export const snapshot_types_snapshot_index_stats = z.object({
    shards: z.record(snapshot_types_snapshot_shards_status),
    shards_stats: snapshot_types_shards_stats,
    stats: snapshot_types_snapshot_stats
});

export const snapshot_types_status = z.object({
    include_global_state: z.boolean().describe('Indicates whether the current cluster state is included in the snapshot.'),
    indices: z.record(snapshot_types_snapshot_index_stats),
    repository: z.string().describe('The name of the repository that includes the snapshot.'),
    shards_stats: snapshot_types_shards_stats,
    snapshot: z.string().describe('The name of the snapshot.'),
    state: z.string().describe('The current snapshot state:\n\n* `FAILED`: The snapshot finished with an error and failed to store any data.\n* `STARTED`: The snapshot is currently running.\n* `SUCCESS`: The snapshot completed.'),
    stats: snapshot_types_snapshot_stats,
    uuid: types_uuid
});

export const snapshot_verify_repository_compact_node_info = z.object({
    name: types_name
});

export const sql_types_column = z.object({
    name: types_name,
    type: z.string()
});

export const sql_types_row = z.array(z.record(z.unknown()));

export const sql_query_sql_format = z.enum([
    'csv',
    'json',
    'tsv',
    'txt',
    'yaml',
    'cbor',
    'smile'
]);

export const ssl_certificates_certificate_information = z.object({
    alias: z.union([
        z.string(),
        z.null()
    ]),
    expiry: types_date_time,
    format: z.string().describe('The format of the file.\nValid values include `jks`, `PKCS12`, and `PEM`.'),
    has_private_key: z.boolean().describe('Indicates whether Elasticsearch has access to the private key for this certificate.'),
    issuer: z.string().describe('The Distinguished Name of the certificate\'s issuer.').optional(),
    path: z.string().describe('The path to the certificate, as configured in the `elasticsearch.yml` file.'),
    serial_number: z.string().describe('The hexadecimal representation of the certificate\'s serial number.'),
    subject_dn: z.string().describe('The Distinguished Name of the certificate\'s subject.')
});

export const synonyms_types_synonyms_update_result = z.object({
    result: types_result,
    reload_analyzers_details: indices_reload_search_analyzers_reload_result.optional()
});

export const synonyms_types_synonym_string = z.string();

export const synonyms_types_synonym_rule_read = z.object({
    id: types_id,
    synonyms: synonyms_types_synonym_string
});

export const synonyms_get_synonyms_sets_synonyms_set_item = z.object({
    synonyms_set: types_id,
    count: z.number().describe('Number of synonym rules that the synonym set contains')
});

export const synonyms_types_synonym_rule = z.object({
    id: types_id.optional(),
    synonyms: synonyms_types_synonym_string
});

export const tasks_types_group_by = z.enum([
    'nodes',
    'parents',
    'none'
]);

export const text_structure_types_ecs_compatibility_type = z.enum(['disabled', 'v1']);

export const text_structure_types_format_type = z.enum([
    'delimited',
    'ndjson',
    'semi_structured_text',
    'xml'
]);

export const text_structure_types_top_hit = z.object({
    count: z.number(),
    value: z.record(z.unknown())
});

export const text_structure_types_field_stat = z.object({
    count: z.number(),
    cardinality: z.number(),
    top_hits: z.array(text_structure_types_top_hit),
    mean_value: z.number().optional(),
    median_value: z.number().optional(),
    max_value: z.number().optional(),
    min_value: z.number().optional(),
    earliest: z.string().optional(),
    latest: z.string().optional()
});

export const text_structure_test_grok_pattern_matched_field = z.object({
    match: z.string(),
    offset: z.number(),
    length: z.number()
});

export const text_structure_test_grok_pattern_matched_text = z.object({
    matched: z.boolean(),
    fields: z.record(z.array(text_structure_test_grok_pattern_matched_field)).optional()
});

export const ml_types_transform_authorization = z.object({
    api_key: ml_types_api_key_authorization.optional(),
    roles: z.array(z.string()).describe('If a user ID was used for the most recent update to the transform, its roles at the time of the update are listed in the response.').optional(),
    service_account: z.string().describe('If a service account was used for the most recent update to the transform, the account name is listed in the response.').optional()
});

export const transform_types_latest = z.object({
    sort: types_field,
    unique_key: z.array(types_field).describe('Specifies an array of one or more fields that are used to group the data.')
});

export const transform_types_retention_policy = z.object({
    field: types_field,
    max_age: types_duration
});

export const transform_types_retention_policy_container = z.object({
    time: transform_types_retention_policy.optional()
});

/**
 * The source of the data for the transform.
 */
export const transform_types_settings = z.object({
    align_checkpoints: z.boolean().describe('Specifies whether the transform checkpoint ranges should be optimized for performance. Such optimization can align\ncheckpoint ranges with the date histogram interval when date histogram is specified as a group source in the\ntransform config. As a result, less document updates in the destination index will be performed thus improving\noverall performance.').optional().default(true),
    dates_as_epoch_millis: z.boolean().describe('Defines if dates in the ouput should be written as ISO formatted string or as millis since epoch. epoch_millis was\nthe default for transforms created before version 7.11. For compatible output set this value to `true`.').optional().default(false),
    deduce_mappings: z.boolean().describe('Specifies whether the transform should deduce the destination index mappings from the transform configuration.').optional().default(true),
    docs_per_second: z.number().describe('Specifies a limit on the number of input documents per second. This setting throttles the transform by adding a\nwait time between search requests. The default value is null, which disables throttling.').optional(),
    max_page_search_size: z.number().describe('Defines the initial page size to use for the composite aggregation for each checkpoint. If circuit breaker\nexceptions occur, the page size is dynamically adjusted to a lower value. The minimum value is `10` and the\nmaximum is `65,536`.').optional().default(500),
    use_point_in_time: z.boolean().describe('Specifies whether the transform checkpoint will use the Point In Time API while searching over the source index.\nIn general, Point In Time is an optimization that will reduce pressure on the source index by reducing the amount\nof refreshes and merges, but it can be expensive if a large number of Point In Times are opened and closed for a\ngiven index. The benefits and impact depend on the data being searched, the ingest rate into the source index, and\nthe amount of other consumers searching the same source index.').optional().default(true),
    unattended: z.boolean().describe('If `true`, the transform runs in unattended mode. In unattended mode, the transform retries indefinitely in case\nof an error which means the transform never fails. Setting the number of retries other than infinite fails in\nvalidation.').optional().default(false)
}).describe('The source of the data for the transform.');

export const transform_types_time_sync = z.object({
    delay: types_duration.optional(),
    field: types_field
});

export const transform_types_sync_container = z.object({
    time: transform_types_time_sync.optional()
});

export const transform_get_transform_stats_transform_progress = z.object({
    docs_indexed: z.number(),
    docs_processed: z.number(),
    docs_remaining: z.number().optional(),
    percent_complete: z.number().optional(),
    total_docs: z.number().optional()
});

export const transform_get_transform_stats_checkpoint_stats = z.object({
    checkpoint: z.number(),
    checkpoint_progress: transform_get_transform_stats_transform_progress.optional(),
    timestamp: types_date_time.optional(),
    timestamp_millis: types_epoch_time_unit_millis.optional(),
    time_upper_bound: types_date_time.optional(),
    time_upper_bound_millis: types_epoch_time_unit_millis.optional()
});

export const transform_get_transform_stats_checkpointing = z.object({
    changes_last_detected_at: z.number().optional(),
    changes_last_detected_at_string: types_date_time.optional(),
    last: transform_get_transform_stats_checkpoint_stats,
    next: transform_get_transform_stats_checkpoint_stats.optional(),
    operations_behind: z.number().optional(),
    last_search_time: z.number().optional(),
    last_search_time_string: types_date_time.optional()
});

export const transform_get_transform_stats_transform_health_issue = z.object({
    type: z.string().describe('The type of the issue'),
    issue: z.string().describe('A description of the issue'),
    details: z.string().describe('Details about the issue').optional(),
    count: z.number().describe('Number of times this issue has occurred since it started'),
    first_occurrence: types_epoch_time_unit_millis.optional(),
    first_occurence_string: types_date_time.optional()
});

export const transform_get_transform_stats_transform_stats_health = z.object({
    status: types_health_status,
    issues: z.array(transform_get_transform_stats_transform_health_issue).describe('If a non-healthy status is returned, contains a list of issues of the transform.').optional()
});

export const transform_get_transform_stats_transform_indexer_stats = z.object({
    delete_time_in_ms: types_epoch_time_unit_millis.optional(),
    documents_indexed: z.number(),
    documents_deleted: z.number().optional(),
    documents_processed: z.number(),
    exponential_avg_checkpoint_duration_ms: types_duration_value_unit_float_millis,
    exponential_avg_documents_indexed: z.number(),
    exponential_avg_documents_processed: z.number(),
    index_failures: z.number(),
    index_time_in_ms: types_duration_value_unit_millis,
    index_total: z.number(),
    pages_processed: z.number(),
    processing_time_in_ms: types_duration_value_unit_millis,
    processing_total: z.number(),
    search_failures: z.number(),
    search_time_in_ms: types_duration_value_unit_millis,
    search_total: z.number(),
    trigger_count: z.number()
});

export const transform_get_transform_stats_transform_stats = z.object({
    checkpointing: transform_get_transform_stats_checkpointing,
    health: transform_get_transform_stats_transform_stats_health.optional(),
    id: types_id,
    node: types_node_attributes.optional(),
    reason: z.string().optional(),
    state: z.string(),
    stats: transform_get_transform_stats_transform_indexer_stats
});

export const transform_types_destination = z.object({
    index: types_index_name.optional(),
    pipeline: z.string().describe('The unique identifier for an ingest pipeline.').optional()
});

export const global_update_update_write_response_base = types_write_response_base.and(z.object({
    get: types_inline_get.optional()
}));

export const global_update_by_query_rethrottle_update_by_query_rethrottle_node = spec_utils_base_node.and(z.object({
    tasks: z.record(tasks_types_task_info)
}));

export const watcher_types_acknowledgement_options = z.enum([
    'awaits_successful_execution',
    'ackable',
    'acked'
]);

export const watcher_types_acknowledge_state = z.object({
    state: watcher_types_acknowledgement_options,
    timestamp: types_date_time
});

export const watcher_types_execution_state = z.object({
    successful: z.boolean(),
    timestamp: types_date_time,
    reason: z.string().optional()
});

export const watcher_types_throttle_state = z.object({
    reason: z.string(),
    timestamp: types_date_time
});

export const watcher_types_action_status = z.object({
    ack: watcher_types_acknowledge_state,
    last_execution: watcher_types_execution_state.optional(),
    last_successful_execution: watcher_types_execution_state.optional(),
    last_throttle: watcher_types_throttle_state.optional()
});

export const watcher_types_actions = z.record(watcher_types_action_status);

export const watcher_types_activation_state = z.object({
    active: z.boolean(),
    timestamp: types_date_time
});

export const watcher_types_watch_status = z.object({
    actions: watcher_types_actions,
    last_checked: types_date_time.optional(),
    last_met_condition: types_date_time.optional(),
    state: watcher_types_activation_state,
    version: types_version_number,
    execution_state: z.string().optional()
});

export const watcher_types_activation_status = z.object({
    actions: watcher_types_actions,
    state: watcher_types_activation_state,
    version: types_version_number
});

export const watcher_types_action_execution_mode = z.enum([
    'simulate',
    'force_simulate',
    'execute',
    'force_execute',
    'skip'
]);

export const watcher_types_simulated_actions: z.AnyZodObject = z.object({
    actions: z.array(z.string()),
    all: z.lazy(() => watcher_types_simulated_actions),
    use_all: z.boolean()
});

export const watcher_types_schedule_trigger_event = z.object({
    scheduled_time: types_date_time,
    triggered_time: types_date_time.optional()
});

export const watcher_types_action_type = z.enum([
    'email',
    'webhook',
    'index',
    'logging',
    'slack',
    'pagerduty'
]);

export const watcher_types_always_condition = z.record(z.unknown());

export const watcher_types_array_compare_condition = z.object({
    path: z.string()
});

export const watcher_types_never_condition = z.record(z.unknown());

export const watcher_types_search_template_request_body = z.object({
    explain: z.boolean().optional().default(false),
    id: types_id.optional(),
    params: z.record(z.record(z.unknown())).optional(),
    profile: z.boolean().optional().default(false),
    source: z.string().describe('An inline search template. Supports the same parameters as the search API\'s\nrequest body. Also supports Mustache variables. If no id is specified, this\nparameter is required.').optional()
});

export const watcher_types_index_action = z.object({
    index: types_index_name,
    doc_id: types_id.optional(),
    refresh: types_refresh.optional(),
    op_type: types_op_type.optional(),
    timeout: types_duration.optional(),
    execution_time_field: types_field.optional()
});

export const watcher_types_logging_action = z.object({
    level: z.string().optional(),
    text: z.string(),
    category: z.string().optional()
});

export const watcher_types_email_body = z.object({
    html: z.string().optional(),
    text: z.string().optional()
});

export const watcher_types_email_priority = z.enum([
    'lowest',
    'low',
    'normal',
    'high',
    'highest'
]);

export const watcher_types_http_input_basic_authentication = z.object({
    password: types_password,
    username: types_username
});

export const watcher_types_http_input_authentication = z.object({
    basic: watcher_types_http_input_basic_authentication
});

export const watcher_types_http_input_method = z.enum([
    'head',
    'get',
    'post',
    'put',
    'delete'
]);

export const watcher_types_http_input_proxy = z.object({
    host: types_host,
    port: types_uint
});

export const watcher_types_connection_scheme = z.enum(['http', 'https']);

export const watcher_types_http_input_request_definition = z.object({
    auth: watcher_types_http_input_authentication.optional(),
    body: z.string().optional(),
    connection_timeout: types_duration.optional(),
    headers: z.record(z.string()).optional(),
    host: types_host.optional(),
    method: watcher_types_http_input_method.optional(),
    params: z.record(z.string()).optional(),
    path: z.string().optional(),
    port: types_uint.optional(),
    proxy: watcher_types_http_input_proxy.optional(),
    read_timeout: types_duration.optional(),
    scheme: watcher_types_connection_scheme.optional(),
    url: z.string().optional()
});

export const watcher_types_http_email_attachment = z.object({
    content_type: z.string().optional(),
    inline: z.boolean().optional(),
    request: watcher_types_http_input_request_definition.optional()
});

export const watcher_types_reporting_email_attachment = z.object({
    url: z.string(),
    inline: z.boolean().optional(),
    retries: z.number().optional().default(40),
    interval: types_duration.optional(),
    request: watcher_types_http_input_request_definition.optional()
});

export const watcher_types_data_attachment_format = z.enum(['json', 'yaml']);

export const watcher_types_data_email_attachment = z.object({
    format: watcher_types_data_attachment_format.optional()
});

export const watcher_types_email_attachment_container = z.object({
    http: watcher_types_http_email_attachment.optional(),
    reporting: watcher_types_reporting_email_attachment.optional(),
    data: watcher_types_data_email_attachment.optional()
});

export const watcher_types_email = z.object({
    id: types_id.optional(),
    bcc: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    body: watcher_types_email_body.optional(),
    cc: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    from: z.string().optional(),
    priority: watcher_types_email_priority.optional(),
    reply_to: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    sent_date: types_date_time.optional(),
    subject: z.string(),
    to: z.union([
        z.string(),
        z.array(z.string())
    ]),
    attachments: z.record(watcher_types_email_attachment_container).optional()
});

export const watcher_types_email_action = watcher_types_email.and(z.record(z.unknown()));

export const watcher_types_pager_duty_context_type = z.enum(['link', 'image']);

export const watcher_types_pager_duty_context = z.object({
    href: z.string().optional(),
    src: z.string().optional(),
    type: watcher_types_pager_duty_context_type
});

export const watcher_types_pager_duty_event_type = z.enum([
    'trigger',
    'resolve',
    'acknowledge'
]);

export const watcher_types_pager_duty_event_proxy = z.object({
    host: types_host.optional(),
    port: z.number().optional()
});

export const watcher_types_pager_duty_event = z.object({
    account: z.string().optional(),
    attach_payload: z.boolean(),
    client: z.string().optional(),
    client_url: z.string().optional(),
    contexts: z.array(watcher_types_pager_duty_context).optional(),
    description: z.string(),
    event_type: watcher_types_pager_duty_event_type.optional(),
    incident_key: z.string(),
    proxy: watcher_types_pager_duty_event_proxy.optional()
});

export const watcher_types_pager_duty_action = watcher_types_pager_duty_event.and(z.record(z.unknown()));

export const watcher_types_slack_attachment_field = z.object({
    short: z.boolean(),
    title: z.string(),
    value: z.string()
});

export const watcher_types_slack_attachment = z.object({
    author_icon: z.string().optional(),
    author_link: z.string().optional(),
    author_name: z.string(),
    color: z.string().optional(),
    fallback: z.string().optional(),
    fields: z.array(watcher_types_slack_attachment_field).optional(),
    footer: z.string().optional(),
    footer_icon: z.string().optional(),
    image_url: z.string().optional(),
    pretext: z.string().optional(),
    text: z.string().optional(),
    thumb_url: z.string().optional(),
    title: z.string(),
    title_link: z.string().optional(),
    ts: types_epoch_time_unit_seconds.optional()
});

export const watcher_types_slack_dynamic_attachment = z.object({
    attachment_template: watcher_types_slack_attachment,
    list_path: z.string()
});

export const watcher_types_slack_message = z.object({
    attachments: z.array(watcher_types_slack_attachment),
    dynamic_attachments: watcher_types_slack_dynamic_attachment.optional(),
    from: z.string(),
    icon: z.string().optional(),
    text: z.string(),
    to: z.array(z.string())
});

export const watcher_types_slack_action = z.object({
    account: z.string().optional(),
    message: watcher_types_slack_message
});

export const watcher_types_webhook_action = watcher_types_http_input_request_definition.and(z.record(z.unknown()));

export const watcher_types_response_content_type = z.enum([
    'json',
    'yaml',
    'text'
]);

export const watcher_types_http_input = z.object({
    extract: z.array(z.string()).optional(),
    request: watcher_types_http_input_request_definition.optional(),
    response_content_type: watcher_types_response_content_type.optional()
});

export const watcher_types_daily_schedule = z.object({
    at: z.array(watcher_types_schedule_time_of_day)
});

export const watcher_types_hourly_schedule = z.object({
    minute: z.array(z.number())
});

export const watcher_types_time_of_month = z.object({
    at: z.array(z.string()),
    on: z.array(z.number())
});

export const watcher_types_day = z.enum([
    'sunday',
    'monday',
    'tuesday',
    'wednesday',
    'thursday',
    'friday',
    'saturday'
]);

export const watcher_types_time_of_week = z.object({
    at: z.array(z.string()),
    on: z.array(watcher_types_day)
});

export const watcher_types_month = z.enum([
    'january',
    'february',
    'march',
    'april',
    'may',
    'june',
    'july',
    'august',
    'september',
    'october',
    'november',
    'december'
]);

export const watcher_types_time_of_year = z.object({
    at: z.array(z.string()),
    int: z.array(watcher_types_month),
    on: z.array(z.number())
});

export const watcher_types_schedule_container = z.object({
    timezone: z.string().optional(),
    cron: watcher_types_cron_expression.optional(),
    daily: watcher_types_daily_schedule.optional(),
    hourly: watcher_types_hourly_schedule.optional(),
    interval: types_duration.optional(),
    monthly: z.union([
        watcher_types_time_of_month,
        z.array(watcher_types_time_of_month)
    ]).optional(),
    weekly: z.union([
        watcher_types_time_of_week,
        z.array(watcher_types_time_of_week)
    ]).optional(),
    yearly: z.union([
        watcher_types_time_of_year,
        z.array(watcher_types_time_of_year)
    ]).optional()
});

export const watcher_types_trigger_container = z.object({
    schedule: watcher_types_schedule_container.optional()
});

export const watcher_types_email_result = z.object({
    account: z.string().optional(),
    message: watcher_types_email,
    reason: z.string().optional()
});

export const watcher_types_index_result_summary = z.object({
    created: z.boolean(),
    id: types_id,
    index: types_index_name,
    result: types_result,
    version: types_version_number
});

export const watcher_types_index_result = z.object({
    response: watcher_types_index_result_summary
});

export const watcher_types_logging_result = z.object({
    logged_text: z.string()
});

export const watcher_types_http_input_request_result = watcher_types_http_input_request_definition.and(z.record(z.unknown()));

export const watcher_types_http_input_response_result = z.object({
    body: z.string(),
    headers: types_http_headers,
    status: z.number()
});

export const watcher_types_pager_duty_result = z.object({
    event: watcher_types_pager_duty_event,
    reason: z.string().optional(),
    request: watcher_types_http_input_request_result.optional(),
    response: watcher_types_http_input_response_result.optional()
});

export const watcher_types_slack_result = z.object({
    account: z.string().optional(),
    message: watcher_types_slack_message
});

export const watcher_types_action_status_options = z.enum([
    'success',
    'failure',
    'simulated',
    'throttled'
]);

export const watcher_types_webhook_result = z.object({
    request: watcher_types_http_input_request_result,
    response: watcher_types_http_input_response_result.optional()
});

export const watcher_types_execution_result_action = z.object({
    email: watcher_types_email_result.optional(),
    id: types_id,
    index: watcher_types_index_result.optional(),
    logging: watcher_types_logging_result.optional(),
    pagerduty: watcher_types_pager_duty_result.optional(),
    reason: z.string().optional(),
    slack: watcher_types_slack_result.optional(),
    status: watcher_types_action_status_options,
    type: watcher_types_action_type,
    webhook: watcher_types_webhook_result.optional(),
    error: types_error_cause.optional()
});

export const watcher_types_condition_type = z.enum([
    'always',
    'never',
    'script',
    'compare',
    'array_compare'
]);

export const watcher_types_execution_result_condition = z.object({
    met: z.boolean(),
    status: watcher_types_action_status_options,
    type: watcher_types_condition_type
});

export const watcher_types_input_type = z.enum([
    'http',
    'search',
    'simple'
]);

export const watcher_types_execution_result_input = z.object({
    payload: z.record(z.record(z.unknown())),
    status: watcher_types_action_status_options,
    type: watcher_types_input_type
});

export const watcher_types_execution_result = z.object({
    actions: z.array(watcher_types_execution_result_action),
    condition: watcher_types_execution_result_condition,
    execution_duration: types_duration_value_unit_millis,
    execution_time: types_date_time,
    input: watcher_types_execution_result_input
});

export const watcher_types_execution_status = z.enum([
    'awaits_execution',
    'checking',
    'execution_not_needed',
    'throttled',
    'executed',
    'failed',
    'deleted_while_queued',
    'not_executed_already_queued'
]);

export const watcher_types_trigger_event_container = z.object({
    schedule: watcher_types_schedule_trigger_event.optional()
});

export const watcher_types_trigger_event_result = z.object({
    manual: watcher_types_trigger_event_container,
    triggered_time: types_date_time,
    type: z.string()
});

export const watcher_stats_watcher_metric = z.enum([
    '_all',
    'all',
    'queued_watches',
    'current_watches',
    'pending_watches'
]);

export const watcher_types_execution_phase = z.enum([
    'awaits_execution',
    'started',
    'input',
    'condition',
    'actions',
    'watch_transform',
    'aborted',
    'finished'
]);

export const watcher_stats_watch_record_queued_stats = z.object({
    execution_time: types_date_time
});

export const watcher_stats_watch_record_stats = watcher_stats_watch_record_queued_stats.and(z.object({
    execution_phase: watcher_types_execution_phase,
    triggered_time: types_date_time,
    executed_actions: z.array(z.string()).optional(),
    watch_id: types_id,
    watch_record_id: types_id
}));

export const watcher_types_execution_thread_pool = z.object({
    max_size: z.number().describe('The largest size of the execution thread pool, which indicates the largest number of concurrent running watches.'),
    queue_size: z.number().describe('The number of watches that were triggered and are currently queued.')
});

export const watcher_stats_watcher_state = z.enum([
    'stopped',
    'starting',
    'started',
    'stopping'
]);

export const watcher_stats_watcher_node_stats = z.object({
    current_watches: z.array(watcher_stats_watch_record_stats).describe('The current executing watches metric gives insight into the watches that are currently being executed by Watcher.\nAdditional information is shared per watch that is currently executing.\nThis information includes the `watch_id`, the time its execution started and its current execution phase.\nTo include this metric, the `metric` option should be set to `current_watches` or `_all`.\nIn addition you can also specify the `emit_stacktraces=true` parameter, which adds stack traces for each watch that is being run.\nThese stack traces can give you more insight into an execution of a watch.').optional(),
    execution_thread_pool: watcher_types_execution_thread_pool,
    queued_watches: z.array(watcher_stats_watch_record_queued_stats).describe('Watcher moderates the execution of watches such that their execution won\'t put too much pressure on the node and its resources.\nIf too many watches trigger concurrently and there isn\'t enough capacity to run them all, some of the watches are queued, waiting for the current running watches to finish.s\nThe queued watches metric gives insight on these queued watches.\n\nTo include this metric, the `metric` option should include `queued_watches` or `_all`.').optional(),
    watch_count: z.number().describe('The number of watches currently registered.'),
    watcher_state: watcher_stats_watcher_state,
    node_id: types_id
});

export const xpack_info_x_pack_category = z.enum([
    'build',
    'features',
    'license'
]);

export const xpack_info_build_information = z.object({
    date: types_date_time,
    hash: z.string()
});

export const xpack_info_native_code_information = z.object({
    build_hash: z.string(),
    version: types_version_string
});

export const xpack_info_feature = z.object({
    available: z.boolean(),
    description: z.string().optional(),
    enabled: z.boolean(),
    native_code_info: xpack_info_native_code_information.optional()
});

export const xpack_info_features = z.object({
    aggregate_metric: xpack_info_feature,
    analytics: xpack_info_feature,
    ccr: xpack_info_feature,
    data_streams: xpack_info_feature,
    data_tiers: xpack_info_feature,
    enrich: xpack_info_feature,
    enterprise_search: xpack_info_feature,
    eql: xpack_info_feature,
    esql: xpack_info_feature,
    graph: xpack_info_feature,
    ilm: xpack_info_feature,
    logstash: xpack_info_feature,
    logsdb: xpack_info_feature,
    ml: xpack_info_feature,
    monitoring: xpack_info_feature,
    rollup: xpack_info_feature,
    runtime_fields: xpack_info_feature.optional(),
    searchable_snapshots: xpack_info_feature,
    security: xpack_info_feature,
    slm: xpack_info_feature,
    spatial: xpack_info_feature,
    sql: xpack_info_feature,
    transform: xpack_info_feature,
    universal_profiling: xpack_info_feature,
    voting_only: xpack_info_feature,
    watcher: xpack_info_feature,
    archive: xpack_info_feature
});

export const xpack_info_minimal_license_information = z.object({
    expiry_date_in_millis: types_epoch_time_unit_millis,
    mode: license_types_license_type,
    status: license_types_license_status,
    type: license_types_license_type,
    uid: z.string()
});

export const xpack_usage_base = z.object({
    available: z.boolean(),
    enabled: z.boolean()
});

export const xpack_usage_analytics_statistics = z.object({
    boxplot_usage: z.number(),
    cumulative_cardinality_usage: z.number(),
    string_stats_usage: z.number(),
    top_metrics_usage: z.number(),
    t_test_usage: z.number(),
    moving_percentiles_usage: z.number(),
    normalize_usage: z.number(),
    rate_usage: z.number(),
    multi_terms_usage: z.number().optional()
});

export const xpack_usage_analytics = xpack_usage_base.and(z.object({
    stats: xpack_usage_analytics_statistics
}));

export const xpack_usage_archive = xpack_usage_base.and(z.object({
    indices_count: z.number()
}));

export const xpack_usage_watcher_action_totals = z.object({
    total: types_duration,
    total_time_in_ms: types_duration_value_unit_millis
});

export const xpack_usage_watcher_actions = z.object({
    actions: z.record(xpack_usage_watcher_action_totals)
});

export const xpack_usage_counter = z.object({
    active: z.number(),
    total: z.number()
});

export const xpack_usage_watcher_watch_trigger_schedule = xpack_usage_counter.and(z.object({
    cron: xpack_usage_counter,
    _all: xpack_usage_counter
}));

export const xpack_usage_watcher_watch_trigger = z.object({
    schedule: xpack_usage_watcher_watch_trigger_schedule.optional(),
    _all: xpack_usage_counter
});

export const xpack_usage_watcher_watch = z.object({
    input: z.record(xpack_usage_counter),
    condition: z.record(xpack_usage_counter).optional(),
    action: z.record(xpack_usage_counter).optional(),
    trigger: xpack_usage_watcher_watch_trigger
});

export const xpack_usage_watcher = xpack_usage_base.and(z.object({
    execution: xpack_usage_watcher_actions,
    watch: xpack_usage_watcher_watch,
    count: xpack_usage_counter
}));

export const xpack_usage_ccr = xpack_usage_base.and(z.object({
    auto_follow_patterns_count: z.number(),
    follower_indices_count: z.number()
}));

export const xpack_usage_data_streams = xpack_usage_base.and(z.object({
    data_streams: z.number(),
    indices_count: z.number()
}));

export const xpack_usage_data_tier_phase_statistics = z.object({
    node_count: z.number(),
    index_count: z.number(),
    total_shard_count: z.number(),
    primary_shard_count: z.number(),
    doc_count: z.number(),
    total_size_bytes: z.number(),
    primary_size_bytes: z.number(),
    primary_shard_size_avg_bytes: z.number(),
    primary_shard_size_median_bytes: z.number(),
    primary_shard_size_mad_bytes: z.number()
});

export const xpack_usage_data_tiers = xpack_usage_base.and(z.object({
    data_warm: xpack_usage_data_tier_phase_statistics,
    data_frozen: xpack_usage_data_tier_phase_statistics.optional(),
    data_cold: xpack_usage_data_tier_phase_statistics,
    data_content: xpack_usage_data_tier_phase_statistics,
    data_hot: xpack_usage_data_tier_phase_statistics
}));

export const xpack_usage_eql_features_join = z.object({
    join_queries_two: types_uint,
    join_queries_three: types_uint,
    join_until: types_uint,
    join_queries_five_or_more: types_uint,
    join_queries_four: types_uint
});

export const xpack_usage_eql_features_keys = z.object({
    join_keys_two: types_uint,
    join_keys_one: types_uint,
    join_keys_three: types_uint,
    join_keys_five_or_more: types_uint,
    join_keys_four: types_uint
});

export const xpack_usage_eql_features_pipes = z.object({
    pipe_tail: types_uint,
    pipe_head: types_uint
});

export const xpack_usage_eql_features_sequences = z.object({
    sequence_queries_three: types_uint,
    sequence_queries_four: types_uint,
    sequence_queries_two: types_uint,
    sequence_until: types_uint,
    sequence_queries_five_or_more: types_uint,
    sequence_maxspan: types_uint
});

export const xpack_usage_eql_features = z.object({
    join: types_uint,
    joins: xpack_usage_eql_features_join,
    keys: xpack_usage_eql_features_keys,
    event: types_uint,
    pipes: xpack_usage_eql_features_pipes,
    sequence: types_uint,
    sequences: xpack_usage_eql_features_sequences
});

export const xpack_usage_query = z.object({
    count: z.number().optional(),
    failed: z.number().optional(),
    paging: z.number().optional(),
    total: z.number().optional()
});

export const xpack_usage_eql = xpack_usage_base.and(z.object({
    features: xpack_usage_eql_features,
    queries: z.record(xpack_usage_query)
}));

export const xpack_usage_flattened = xpack_usage_base.and(z.object({
    field_count: z.number()
}));

export const xpack_usage_invocations = z.object({
    total: z.number()
});

export const xpack_usage_health_statistics = xpack_usage_base.and(z.object({
    invocations: xpack_usage_invocations
}));

export const xpack_usage_phase = z.object({
    actions: z.array(z.string()),
    min_age: types_duration_value_unit_millis
});

export const xpack_usage_phases = z.object({
    cold: xpack_usage_phase.optional(),
    delete: xpack_usage_phase.optional(),
    frozen: xpack_usage_phase.optional(),
    hot: xpack_usage_phase.optional(),
    warm: xpack_usage_phase.optional()
});

export const xpack_usage_ilm_policy_statistics = z.object({
    indices_managed: z.number(),
    phases: xpack_usage_phases
});

export const xpack_usage_ilm = z.object({
    policy_count: z.number(),
    policy_stats: z.array(xpack_usage_ilm_policy_statistics)
});

export const xpack_usage_datafeed = z.object({
    count: z.number()
});

export const xpack_usage_ml_job_forecasts = z.object({
    total: z.number(),
    forecasted_jobs: z.number()
});

export const xpack_usage_job_usage = z.object({
    count: z.number(),
    created_by: z.record(z.number()),
    detectors: ml_types_job_statistics,
    forecasts: xpack_usage_ml_job_forecasts,
    model_size: ml_types_job_statistics
});

export const xpack_usage_ml_data_frame_analytics_jobs_memory = z.object({
    peak_usage_bytes: ml_types_job_statistics
});

export const xpack_usage_ml_data_frame_analytics_jobs_count = z.object({
    count: z.number()
});

export const xpack_usage_ml_data_frame_analytics_jobs_analysis = z.object({
    classification: z.number().optional(),
    outlier_detection: z.number().optional(),
    regression: z.number().optional()
});

export const xpack_usage_ml_data_frame_analytics_jobs = z.object({
    memory_usage: xpack_usage_ml_data_frame_analytics_jobs_memory.optional(),
    _all: xpack_usage_ml_data_frame_analytics_jobs_count,
    analysis_counts: xpack_usage_ml_data_frame_analytics_jobs_analysis.optional(),
    stopped: xpack_usage_ml_data_frame_analytics_jobs_count.optional()
});

export const xpack_usage_ml_inference_ingest_processor_count = z.object({
    max: z.number(),
    sum: z.number(),
    min: z.number()
});

export const xpack_usage_ml_counter = z.object({
    count: z.number()
});

export const xpack_usage_ml_inference_ingest_processor = z.object({
    num_docs_processed: xpack_usage_ml_inference_ingest_processor_count,
    pipelines: xpack_usage_ml_counter,
    num_failures: xpack_usage_ml_inference_ingest_processor_count,
    time_ms: xpack_usage_ml_inference_ingest_processor_count
});

export const xpack_usage_ml_inference_trained_models_count = z.object({
    total: z.number(),
    prepackaged: z.number(),
    other: z.number(),
    pass_through: z.number().optional(),
    regression: z.number().optional(),
    classification: z.number().optional(),
    ner: z.number().optional(),
    text_embedding: z.number().optional()
});

export const xpack_usage_ml_inference_trained_models = z.object({
    estimated_operations: ml_types_job_statistics.optional(),
    estimated_heap_memory_usage_bytes: ml_types_job_statistics.optional(),
    count: xpack_usage_ml_inference_trained_models_count.optional(),
    _all: xpack_usage_ml_counter,
    model_size_bytes: ml_types_job_statistics.optional()
});

export const xpack_usage_ml_inference_deployments_time_ms = z.object({
    avg: z.number()
});

export const xpack_usage_ml_inference_deployments = z.object({
    count: z.number(),
    inference_counts: ml_types_job_statistics,
    model_sizes_bytes: ml_types_job_statistics,
    time_ms: xpack_usage_ml_inference_deployments_time_ms
});

export const xpack_usage_ml_inference = z.object({
    ingest_processors: z.record(xpack_usage_ml_inference_ingest_processor),
    trained_models: xpack_usage_ml_inference_trained_models,
    deployments: xpack_usage_ml_inference_deployments.optional()
});

export const xpack_usage_machine_learning = xpack_usage_base.and(z.object({
    datafeeds: z.record(xpack_usage_datafeed),
    jobs: z.record(xpack_usage_job_usage).describe('Job usage statistics. The `_all` entry is always present and gathers statistics for all jobs.'),
    node_count: z.number(),
    data_frame_analytics_jobs: xpack_usage_ml_data_frame_analytics_jobs,
    inference: xpack_usage_ml_inference
}));

export const xpack_usage_monitoring = xpack_usage_base.and(z.object({
    collection_enabled: z.boolean(),
    enabled_exporters: z.record(z.number())
}));

export const xpack_usage_runtime_fields_type = z.object({
    chars_max: z.number(),
    chars_total: z.number(),
    count: z.number(),
    doc_max: z.number(),
    doc_total: z.number(),
    index_count: z.number(),
    lang: z.array(z.string()),
    lines_max: z.number(),
    lines_total: z.number(),
    name: types_field,
    scriptless_count: z.number(),
    shadowed_count: z.number(),
    source_max: z.number(),
    source_total: z.number()
});

export const xpack_usage_runtime_field_types = xpack_usage_base.and(z.object({
    field_types: z.array(xpack_usage_runtime_fields_type)
}));

export const xpack_usage_searchable_snapshots = xpack_usage_base.and(z.object({
    indices_count: z.number(),
    full_copy_indices_count: z.number().optional(),
    shared_cache_indices_count: z.number().optional()
}));

export const xpack_usage_feature_toggle = z.object({
    enabled: z.boolean()
});

export const xpack_usage_audit = xpack_usage_feature_toggle.and(z.object({
    outputs: z.array(z.string()).optional()
}));

export const xpack_usage_ip_filter = z.object({
    http: z.boolean(),
    transport: z.boolean()
});

export const xpack_usage_realm_cache = z.object({
    size: z.number()
});

export const xpack_usage_realm = xpack_usage_base.and(z.object({
    name: z.array(z.string()).optional(),
    order: z.array(z.number()).optional(),
    size: z.array(z.number()).optional(),
    cache: z.array(xpack_usage_realm_cache).optional(),
    has_authorization_realms: z.array(z.boolean()).optional(),
    has_default_username_pattern: z.array(z.boolean()).optional(),
    has_truststore: z.array(z.boolean()).optional(),
    is_authentication_delegated: z.array(z.boolean()).optional()
}));

export const xpack_usage_role_mapping = z.object({
    enabled: z.number(),
    size: z.number()
});

export const xpack_usage_security_roles_native = z.object({
    dls: z.boolean(),
    fls: z.boolean(),
    size: z.number()
});

export const xpack_usage_security_roles_file = z.object({
    dls: z.boolean(),
    fls: z.boolean(),
    size: z.number()
});

export const xpack_usage_security_roles = z.object({
    native: xpack_usage_security_roles_native,
    dls: xpack_usage_security_roles_dls,
    file: xpack_usage_security_roles_file
});

export const xpack_usage_ssl = z.object({
    http: xpack_usage_feature_toggle,
    transport: xpack_usage_feature_toggle
});

export const xpack_usage_security = xpack_usage_base.and(z.object({
    api_key_service: xpack_usage_feature_toggle,
    anonymous: xpack_usage_feature_toggle,
    audit: xpack_usage_audit,
    fips_140: xpack_usage_feature_toggle,
    ipfilter: xpack_usage_ip_filter,
    realms: z.record(xpack_usage_realm),
    role_mapping: z.record(xpack_usage_role_mapping),
    roles: xpack_usage_security_roles,
    ssl: xpack_usage_ssl,
    system_key: xpack_usage_feature_toggle.optional(),
    token_service: xpack_usage_feature_toggle,
    operator_privileges: xpack_usage_base
}));

export const xpack_usage_slm = xpack_usage_base.and(z.object({
    policy_count: z.number().optional(),
    policy_stats: slm_types_statistics.optional()
}));

export const xpack_usage_sql = xpack_usage_base.and(z.object({
    features: z.record(z.number()),
    queries: z.record(xpack_usage_query)
}));

export const xpack_usage_vector = xpack_usage_base.and(z.object({
    dense_vector_dims_avg_count: z.number(),
    dense_vector_fields_count: z.number(),
    sparse_vector_fields_count: z.number().optional()
}));

export const async_search_types_async_search_document_response_base: z.ZodTypeAny = async_search_types_async_search_response_base.and(z.object({
    response: z.lazy(() => async_search_types_async_search)
}));

export const async_search_types_async_search: z.AnyZodObject = z.object({
    aggregations: z.record(z.lazy(() => types_aggregations_aggregate)).describe('Partial aggregations results, coming from the shards that have already completed running the query.').optional(),
    _clusters: types_cluster_statistics.optional(),
    fields: z.record(z.record(z.unknown())).optional(),
    hits: z.lazy(() => global_search_types_hits_metadata),
    max_score: z.number().optional(),
    num_reduce_phases: z.number().describe('Indicates how many reductions of the results have been performed.\nIf this number increases compared to the last retrieved results for a get asynch search request, you can expect additional results included in the search response.').optional(),
    profile: global_search_types_profile.optional(),
    pit_id: types_id.optional(),
    _scroll_id: types_scroll_id.optional(),
    _shards: types_shard_statistics,
    suggest: z.record(z.array(global_search_types_suggest)).optional(),
    terminated_early: z.boolean().optional(),
    timed_out: z.boolean(),
    took: z.number()
});

export const types_aggregations_aggregate: z.ZodTypeAny = z.union([
    types_aggregations_cardinality_aggregate,
    types_aggregations_hdr_percentiles_aggregate,
    types_aggregations_hdr_percentile_ranks_aggregate,
    types_aggregations_t_digest_percentiles_aggregate,
    types_aggregations_t_digest_percentile_ranks_aggregate,
    types_aggregations_percentiles_bucket_aggregate,
    types_aggregations_median_absolute_deviation_aggregate,
    types_aggregations_min_aggregate,
    types_aggregations_max_aggregate,
    types_aggregations_sum_aggregate,
    types_aggregations_avg_aggregate,
    types_aggregations_weighted_avg_aggregate,
    types_aggregations_value_count_aggregate,
    types_aggregations_simple_value_aggregate,
    types_aggregations_derivative_aggregate,
    types_aggregations_bucket_metric_value_aggregate,
    types_aggregations_change_point_aggregate,
    types_aggregations_stats_aggregate,
    types_aggregations_stats_bucket_aggregate,
    types_aggregations_extended_stats_aggregate,
    types_aggregations_extended_stats_bucket_aggregate,
    types_aggregations_cartesian_bounds_aggregate,
    types_aggregations_cartesian_centroid_aggregate,
    types_aggregations_geo_bounds_aggregate,
    types_aggregations_geo_centroid_aggregate,
    types_aggregations_histogram_aggregate,
    types_aggregations_date_histogram_aggregate,
    types_aggregations_auto_date_histogram_aggregate,
    types_aggregations_variable_width_histogram_aggregate,
    types_aggregations_string_terms_aggregate,
    types_aggregations_long_terms_aggregate,
    types_aggregations_double_terms_aggregate,
    types_aggregations_unmapped_terms_aggregate,
    types_aggregations_long_rare_terms_aggregate,
    types_aggregations_string_rare_terms_aggregate,
    types_aggregations_unmapped_rare_terms_aggregate,
    types_aggregations_multi_terms_aggregate,
    types_aggregations_missing_aggregate,
    types_aggregations_nested_aggregate,
    types_aggregations_reverse_nested_aggregate,
    types_aggregations_global_aggregate,
    types_aggregations_filter_aggregate,
    types_aggregations_children_aggregate,
    types_aggregations_parent_aggregate,
    types_aggregations_sampler_aggregate,
    types_aggregations_unmapped_sampler_aggregate,
    types_aggregations_geo_hash_grid_aggregate,
    types_aggregations_geo_tile_grid_aggregate,
    types_aggregations_geo_hex_grid_aggregate,
    types_aggregations_range_aggregate,
    types_aggregations_date_range_aggregate,
    types_aggregations_geo_distance_aggregate,
    types_aggregations_ip_range_aggregate,
    types_aggregations_ip_prefix_aggregate,
    types_aggregations_filters_aggregate,
    types_aggregations_adjacency_matrix_aggregate,
    types_aggregations_significant_long_terms_aggregate,
    types_aggregations_significant_string_terms_aggregate,
    types_aggregations_unmapped_significant_terms_aggregate,
    types_aggregations_composite_aggregate,
    types_aggregations_frequent_item_sets_aggregate,
    types_aggregations_time_series_aggregate,
    types_aggregations_scripted_metric_aggregate,
    z.lazy(() => types_aggregations_top_hits_aggregate),
    types_aggregations_inference_aggregate,
    types_aggregations_string_stats_aggregate,
    types_aggregations_box_plot_aggregate,
    types_aggregations_top_metrics_aggregate,
    types_aggregations_t_test_aggregate,
    types_aggregations_rate_aggregate,
    types_aggregations_cumulative_cardinality_aggregate,
    types_aggregations_matrix_stats_aggregate,
    types_aggregations_geo_line_aggregate
]);

export const types_aggregations_top_hits_aggregate: z.ZodTypeAny = types_aggregations_aggregate_base.and(z.object({
    hits: z.lazy(() => global_search_types_hits_metadata)
}));

export const global_search_types_hits_metadata: z.AnyZodObject = z.object({
    total: z.union([
        global_search_types_total_hits,
        z.number()
    ]).optional(),
    hits: z.array(z.lazy(() => global_search_types_hit)),
    max_score: z.union([
        z.number(),
        z.string(),
        z.null()
    ]).optional()
});

export const global_search_types_hit: z.AnyZodObject = z.object({
    _index: types_index_name,
    _id: types_id.optional(),
    _score: z.union([
        z.number(),
        z.string(),
        z.null()
    ]).optional(),
    _explanation: global_explain_explanation.optional(),
    fields: z.record(z.record(z.unknown())).optional(),
    highlight: z.record(z.array(z.string())).optional(),
    inner_hits: z.record(z.lazy(() => global_search_types_inner_hits_result)).optional(),
    matched_queries: z.union([
        z.array(z.string()),
        z.record(z.number())
    ]).optional(),
    _nested: global_search_types_nested_identity.optional(),
    _ignored: z.array(z.string()).optional(),
    ignored_field_values: z.record(z.array(z.record(z.unknown()))).optional(),
    _shard: z.string().optional(),
    _node: z.string().optional(),
    _routing: z.string().optional(),
    _source: z.record(z.unknown()).optional(),
    _rank: z.number().optional(),
    _seq_no: types_sequence_number.optional(),
    _primary_term: z.number().optional(),
    _version: types_version_number.optional(),
    sort: types_sort_results.optional()
});

export const global_search_types_inner_hits_result = z.object({
    hits: global_search_types_hits_metadata
});

export const types_aggregations_aggregation_container: z.ZodTypeAny = z.object({
    aggregations: z.record(z.lazy(() => types_aggregations_aggregation_container)).describe('Sub-aggregations for this aggregation.\nOnly applies to bucket aggregations.').optional(),
    meta: types_metadata.optional()
}).and(z.object({
    adjacency_matrix: z.lazy(() => types_aggregations_adjacency_matrix_aggregation).optional(),
    auto_date_histogram: z.lazy(() => types_aggregations_auto_date_histogram_aggregation).optional(),
    avg: z.lazy(() => types_aggregations_average_aggregation).optional(),
    avg_bucket: types_aggregations_average_bucket_aggregation.optional(),
    boxplot: z.lazy(() => types_aggregations_boxplot_aggregation).optional(),
    bucket_script: z.lazy(() => types_aggregations_bucket_script_aggregation).optional(),
    bucket_selector: z.lazy(() => types_aggregations_bucket_selector_aggregation).optional(),
    bucket_sort: z.lazy(() => types_aggregations_bucket_sort_aggregation).optional(),
    bucket_count_ks_test: types_aggregations_bucket_ks_aggregation.optional(),
    bucket_correlation: types_aggregations_bucket_correlation_aggregation.optional(),
    cardinality: z.lazy(() => types_aggregations_cardinality_aggregation).optional(),
    cartesian_bounds: z.lazy(() => types_aggregations_cartesian_bounds_aggregation).optional(),
    cartesian_centroid: z.lazy(() => types_aggregations_cartesian_centroid_aggregation).optional(),
    categorize_text: types_aggregations_categorize_text_aggregation.optional(),
    change_point: types_aggregations_change_point_aggregation.optional(),
    children: types_aggregations_children_aggregation.optional(),
    composite: z.lazy(() => types_aggregations_composite_aggregation).optional(),
    cumulative_cardinality: types_aggregations_cumulative_cardinality_aggregation.optional(),
    cumulative_sum: types_aggregations_cumulative_sum_aggregation.optional(),
    date_histogram: z.lazy(() => types_aggregations_date_histogram_aggregation).optional(),
    date_range: types_aggregations_date_range_aggregation.optional(),
    derivative: types_aggregations_derivative_aggregation.optional(),
    diversified_sampler: z.lazy(() => types_aggregations_diversified_sampler_aggregation).optional(),
    extended_stats: z.lazy(() => types_aggregations_extended_stats_aggregation).optional(),
    extended_stats_bucket: types_aggregations_extended_stats_bucket_aggregation.optional(),
    frequent_item_sets: z.lazy(() => types_aggregations_frequent_item_sets_aggregation).optional(),
    filter: z.lazy(() => types_query_dsl_query_container).optional(),
    filters: z.lazy(() => types_aggregations_filters_aggregation).optional(),
    geo_bounds: z.lazy(() => types_aggregations_geo_bounds_aggregation).optional(),
    geo_centroid: z.lazy(() => types_aggregations_geo_centroid_aggregation).optional(),
    geo_distance: types_aggregations_geo_distance_aggregation.optional(),
    geohash_grid: types_aggregations_geo_hash_grid_aggregation.optional(),
    geo_line: types_aggregations_geo_line_aggregation.optional(),
    geotile_grid: types_aggregations_geo_tile_grid_aggregation.optional(),
    geohex_grid: types_aggregations_geohex_grid_aggregation.optional(),
    global: types_aggregations_global_aggregation.optional(),
    histogram: z.lazy(() => types_aggregations_histogram_aggregation).optional(),
    ip_range: types_aggregations_ip_range_aggregation.optional(),
    ip_prefix: types_aggregations_ip_prefix_aggregation.optional(),
    inference: types_aggregations_inference_aggregation.optional(),
    line: types_aggregations_geo_line_aggregation.optional(),
    matrix_stats: types_aggregations_matrix_stats_aggregation.optional(),
    max: z.lazy(() => types_aggregations_max_aggregation).optional(),
    max_bucket: types_aggregations_max_bucket_aggregation.optional(),
    median_absolute_deviation: z.lazy(() => types_aggregations_median_absolute_deviation_aggregation).optional(),
    min: z.lazy(() => types_aggregations_min_aggregation).optional(),
    min_bucket: types_aggregations_min_bucket_aggregation.optional(),
    missing: types_aggregations_missing_aggregation.optional(),
    moving_avg: types_aggregations_moving_average_aggregation.optional(),
    moving_percentiles: types_aggregations_moving_percentiles_aggregation.optional(),
    moving_fn: types_aggregations_moving_function_aggregation.optional(),
    multi_terms: types_aggregations_multi_terms_aggregation.optional(),
    nested: types_aggregations_nested_aggregation.optional(),
    normalize: types_aggregations_normalize_aggregation.optional(),
    parent: types_aggregations_parent_aggregation.optional(),
    percentile_ranks: z.lazy(() => types_aggregations_percentile_ranks_aggregation).optional(),
    percentiles: z.lazy(() => types_aggregations_percentiles_aggregation).optional(),
    percentiles_bucket: types_aggregations_percentiles_bucket_aggregation.optional(),
    range: z.lazy(() => types_aggregations_range_aggregation).optional(),
    rare_terms: types_aggregations_rare_terms_aggregation.optional(),
    rate: z.lazy(() => types_aggregations_rate_aggregation).optional(),
    reverse_nested: types_aggregations_reverse_nested_aggregation.optional(),
    random_sampler: types_aggregations_random_sampler_aggregation.optional(),
    sampler: types_aggregations_sampler_aggregation.optional(),
    scripted_metric: z.lazy(() => types_aggregations_scripted_metric_aggregation).optional(),
    serial_diff: types_aggregations_serial_differencing_aggregation.optional(),
    significant_terms: z.lazy(() => types_aggregations_significant_terms_aggregation).optional(),
    significant_text: z.lazy(() => types_aggregations_significant_text_aggregation).optional(),
    stats: z.lazy(() => types_aggregations_stats_aggregation).optional(),
    stats_bucket: types_aggregations_stats_bucket_aggregation.optional(),
    string_stats: z.lazy(() => types_aggregations_string_stats_aggregation).optional(),
    sum: z.lazy(() => types_aggregations_sum_aggregation).optional(),
    sum_bucket: types_aggregations_sum_bucket_aggregation.optional(),
    terms: z.lazy(() => types_aggregations_terms_aggregation).optional(),
    time_series: types_aggregations_time_series_aggregation.optional(),
    top_hits: z.lazy(() => types_aggregations_top_hits_aggregation).optional(),
    t_test: z.lazy(() => types_aggregations_t_test_aggregation).optional(),
    top_metrics: z.lazy(() => types_aggregations_top_metrics_aggregation).optional(),
    value_count: z.lazy(() => types_aggregations_value_count_aggregation).optional(),
    weighted_avg: z.lazy(() => types_aggregations_weighted_average_aggregation).optional(),
    variable_width_histogram: z.lazy(() => types_aggregations_variable_width_histogram_aggregation).optional()
}));

export const types_aggregations_adjacency_matrix_aggregation: z.ZodTypeAny = types_aggregations_bucket_aggregation_base.and(z.object({
    filters: z.record(z.lazy(() => types_query_dsl_query_container)).describe('Filters used to create buckets.\nAt least one filter is required.').optional(),
    separator: z.string().describe('Separator used to concatenate filter names. Defaults to &.').optional()
}));

/**
 * An Elasticsearch Query DSL (Domain Specific Language) object that defines a query.
 */
export const types_query_dsl_query_container: z.AnyZodObject = z.object({
    bool: z.lazy(() => types_query_dsl_bool_query).optional(),
    boosting: z.lazy(() => types_query_dsl_boosting_query).optional(),
    common: z.record(types_query_dsl_common_terms_query).optional(),
    combined_fields: types_query_dsl_combined_fields_query.optional(),
    constant_score: z.lazy(() => types_query_dsl_constant_score_query).optional(),
    dis_max: z.lazy(() => types_query_dsl_dis_max_query).optional(),
    distance_feature: types_query_dsl_distance_feature_query.optional(),
    exists: types_query_dsl_exists_query.optional(),
    function_score: z.lazy(() => types_query_dsl_function_score_query).optional(),
    fuzzy: z.record(types_query_dsl_fuzzy_query).describe('Returns documents that contain terms similar to the search term, as measured by a Levenshtein edit distance.').optional(),
    geo_bounding_box: types_query_dsl_geo_bounding_box_query.optional(),
    geo_distance: types_query_dsl_geo_distance_query.optional(),
    geo_grid: z.record(types_query_dsl_geo_grid_query).describe('Matches `geo_point` and `geo_shape` values that intersect a grid cell from a GeoGrid aggregation.').optional(),
    geo_polygon: types_query_dsl_geo_polygon_query.optional(),
    geo_shape: types_query_dsl_geo_shape_query.optional(),
    has_child: z.lazy(() => types_query_dsl_has_child_query).optional(),
    has_parent: z.lazy(() => types_query_dsl_has_parent_query).optional(),
    ids: types_query_dsl_ids_query.optional(),
    intervals: z.record(z.lazy(() => types_query_dsl_intervals_query)).describe('Returns documents based on the order and proximity of matching terms.').optional(),
    knn: z.lazy(() => types_knn_query).optional(),
    match: z.record(types_query_dsl_match_query).describe('Returns documents that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.').optional(),
    match_all: types_query_dsl_match_all_query.optional(),
    match_bool_prefix: z.record(types_query_dsl_match_bool_prefix_query).describe('Analyzes its input and constructs a `bool` query from the terms.\nEach term except the last is used in a `term` query.\nThe last term is used in a prefix query.').optional(),
    match_none: types_query_dsl_match_none_query.optional(),
    match_phrase: z.record(types_query_dsl_match_phrase_query).describe('Analyzes the text and creates a phrase query out of the analyzed text.').optional(),
    match_phrase_prefix: z.record(types_query_dsl_match_phrase_prefix_query).describe('Returns documents that contain the words of a provided text, in the same order as provided.\nThe last term of the provided text is treated as a prefix, matching any words that begin with that term.').optional(),
    more_like_this: types_query_dsl_more_like_this_query.optional(),
    multi_match: types_query_dsl_multi_match_query.optional(),
    nested: z.lazy(() => types_query_dsl_nested_query).optional(),
    parent_id: types_query_dsl_parent_id_query.optional(),
    percolate: types_query_dsl_percolate_query.optional(),
    pinned: z.lazy(() => types_query_dsl_pinned_query).optional(),
    prefix: z.record(types_query_dsl_prefix_query).describe('Returns documents that contain a specific prefix in a provided field.').optional(),
    query_string: types_query_dsl_query_string_query.optional(),
    range: z.record(types_query_dsl_range_query).describe('Returns documents that contain terms within a provided range.').optional(),
    rank_feature: types_query_dsl_rank_feature_query.optional(),
    regexp: z.record(types_query_dsl_regexp_query).describe('Returns documents that contain terms matching a regular expression.').optional(),
    rule: z.lazy(() => types_query_dsl_rule_query).optional(),
    script: z.lazy(() => types_query_dsl_script_query).optional(),
    script_score: z.lazy(() => types_query_dsl_script_score_query).optional(),
    semantic: types_query_dsl_semantic_query.optional(),
    shape: types_query_dsl_shape_query.optional(),
    simple_query_string: types_query_dsl_simple_query_string_query.optional(),
    span_containing: z.lazy(() => types_query_dsl_span_containing_query).optional(),
    span_field_masking: z.lazy(() => types_query_dsl_span_field_masking_query).optional(),
    span_first: z.lazy(() => types_query_dsl_span_first_query).optional(),
    span_multi: z.lazy(() => types_query_dsl_span_multi_term_query).optional(),
    span_near: z.lazy(() => types_query_dsl_span_near_query).optional(),
    span_not: z.lazy(() => types_query_dsl_span_not_query).optional(),
    span_or: z.lazy(() => types_query_dsl_span_or_query).optional(),
    span_term: z.record(types_query_dsl_span_term_query).describe('Matches spans containing a term.').optional(),
    span_within: z.lazy(() => types_query_dsl_span_within_query).optional(),
    sparse_vector: types_query_dsl_sparse_vector_query.optional(),
    term: z.record(types_query_dsl_term_query).describe('Returns documents that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field\'s value, including whitespace and capitalization.').optional(),
    terms: types_query_dsl_terms_query.optional(),
    terms_set: z.record(z.lazy(() => types_query_dsl_terms_set_query)).describe('Returns documents that contain a minimum number of exact terms in a provided field.\nTo return a document, a required number of terms must exactly match the field values, including whitespace and capitalization.').optional(),
    text_expansion: z.record(types_query_dsl_text_expansion_query).describe('Uses a natural language processing model to convert the query text into a list of token-weight pairs which are then used in a query against a sparse vector or rank features field.').optional(),
    weighted_tokens: z.record(types_query_dsl_weighted_tokens_query).describe('Supports returning text_expansion query results by sending in precomputed tokens with the query.').optional(),
    wildcard: z.record(types_query_dsl_wildcard_query).describe('Returns documents that contain terms matching a wildcard pattern.').optional(),
    wrapper: types_query_dsl_wrapper_query.optional(),
    type: types_query_dsl_type_query.optional()
}).describe('An Elasticsearch Query DSL (Domain Specific Language) object that defines a query.');

export const types_query_dsl_bool_query = types_query_dsl_query_base.and(z.object({
    filter: z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ]).optional(),
    minimum_should_match: types_minimum_should_match.optional(),
    must: z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ]).optional(),
    must_not: z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ]).optional(),
    should: z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ]).optional()
}));

export const types_query_dsl_boosting_query = types_query_dsl_query_base.and(z.object({
    negative_boost: z.number().describe('Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query.'),
    negative: types_query_dsl_query_container,
    positive: types_query_dsl_query_container
}));

export const types_query_dsl_constant_score_query = types_query_dsl_query_base.and(z.object({
    filter: types_query_dsl_query_container
}));

export const types_query_dsl_dis_max_query = types_query_dsl_query_base.and(z.object({
    queries: z.array(types_query_dsl_query_container).describe('One or more query clauses.\nReturned documents must match one or more of these queries.\nIf a document matches multiple queries, Elasticsearch uses the highest relevance score.'),
    tie_breaker: z.number().describe('Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses.').optional().default(0)
}));

export const types_query_dsl_function_score_query: z.ZodTypeAny = types_query_dsl_query_base.and(z.object({
    boost_mode: types_query_dsl_function_boost_mode.optional(),
    functions: z.array(z.lazy(() => types_query_dsl_function_score_container)).describe('One or more functions that compute a new score for each document returned by the query.').optional(),
    max_boost: z.number().describe('Restricts the new score to not exceed the provided limit.').optional(),
    min_score: z.number().describe('Excludes documents that do not meet the provided score threshold.').optional(),
    query: types_query_dsl_query_container.optional(),
    score_mode: types_query_dsl_function_score_mode.optional()
}));

export const types_query_dsl_function_score_container: z.ZodTypeAny = z.object({
    filter: types_query_dsl_query_container.optional(),
    weight: z.number().optional()
}).and(z.object({
    exp: types_query_dsl_decay_function.optional(),
    gauss: types_query_dsl_decay_function.optional(),
    linear: types_query_dsl_decay_function.optional(),
    field_value_factor: types_query_dsl_field_value_factor_score_function.optional(),
    random_score: types_query_dsl_random_score_function.optional(),
    script_score: z.lazy(() => types_query_dsl_script_score_function).optional()
}));

export const types_query_dsl_script_score_function: z.AnyZodObject = z.object({
    script: z.lazy(() => types_script)
});

export const types_script: z.AnyZodObject = z.object({
    source: z.lazy(() => types_script_source).optional(),
    id: types_id.optional(),
    params: z.record(z.record(z.unknown())).describe('Specifies any named parameters that are passed into the script as variables.\nUse parameters instead of hard-coded values to decrease compile time.').optional(),
    lang: types_script_language.optional(),
    options: z.record(z.string()).optional()
});

export const types_script_source: z.ZodTypeAny = z.union([
    z.string(),
    z.lazy(() => global_search_types_search_request_body)
]);

export const global_search_types_search_request_body: z.AnyZodObject = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).describe('Defines the aggregations that are run as part of the search request.').optional(),
    collapse: z.lazy(() => global_search_types_field_collapse).optional(),
    explain: z.boolean().describe('If `true`, the request returns detailed information about score computation as part of a hit.').optional().default(false),
    ext: z.record(z.record(z.unknown())).describe('Configuration of search extensions defined by Elasticsearch plugins.').optional(),
    from: z.number().describe('The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional().default(0),
    highlight: z.lazy(() => global_search_types_highlight).optional(),
    track_total_hits: global_search_types_track_hits.optional(),
    indices_boost: z.array(z.record(z.number())).describe('Boost the `_score` of documents from specified indices.\nThe boost value is the factor by which scores are multiplied.\nA boost value greater than `1.0` increases the score.\nA boost value between `0` and `1.0` decreases the score.').optional(),
    docvalue_fields: z.array(types_query_dsl_field_and_format).describe('An array of wildcard (`*`) field patterns.\nThe request returns doc values for field names matching these patterns in the `hits.fields` property of the response.').optional(),
    knn: z.union([
        z.lazy(() => types_knn_search),
        z.array(z.lazy(() => types_knn_search))
    ]).optional(),
    rank: types_rank_container.optional(),
    min_score: z.number().describe('The minimum `_score` for matching documents.\nDocuments with a lower `_score` are not included in search results or results collected by aggregations.').optional(),
    post_filter: types_query_dsl_query_container.optional(),
    profile: z.boolean().describe('Set to `true` to return detailed timing information about the execution of individual components in a search request.\nNOTE: This is a debugging tool and adds significant overhead to search execution.').optional().default(false),
    query: types_query_dsl_query_container.optional(),
    rescore: z.union([
        z.lazy(() => global_search_types_rescore),
        z.array(z.lazy(() => global_search_types_rescore))
    ]).optional(),
    retriever: z.lazy(() => types_retriever_container).optional(),
    script_fields: z.record(z.lazy(() => types_script_field)).describe('Retrieve a script evaluation (based on different fields) for each hit.').optional(),
    search_after: types_sort_results.optional(),
    size: z.number().describe('The number of hits to return, which must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` property.').optional().default(10),
    slice: types_sliced_scroll.optional(),
    sort: z.lazy(() => types_sort).optional(),
    _source: global_search_types_source_config.optional(),
    fields: z.array(types_query_dsl_field_and_format).describe('An array of wildcard (`*`) field patterns.\nThe request returns values for field names matching these patterns in the `hits.fields` property of the response.').optional(),
    suggest: global_search_types_suggester.optional(),
    terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this property to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this property for requests that target data streams with backing indices across multiple data tiers.\n\nIf set to `0` (default), the query does not terminate early.').optional().default(0),
    timeout: z.string().describe('The period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.').optional(),
    track_scores: z.boolean().describe('If `true`, calculate and return document scores, even if the scores are not used for sorting.').optional().default(false),
    version: z.boolean().describe('If `true`, the request returns the document version as part of a hit.').optional().default(false),
    seq_no_primary_term: z.boolean().describe('If `true`, the request returns sequence number and primary term of the last modification of each hit.').optional(),
    stored_fields: types_fields.optional(),
    pit: global_search_types_point_in_time_reference.optional(),
    runtime_mappings: z.lazy(() => types_mapping_runtime_fields).optional(),
    stats: z.array(z.string()).describe('The stats groups to associate with the search.\nEach group maintains a statistics aggregation for its associated searches.\nYou can retrieve these stats using the indices stats API.').optional()
});

export const global_search_types_field_collapse: z.AnyZodObject = z.object({
    field: types_field,
    inner_hits: z.union([
        z.lazy(() => global_search_types_inner_hits),
        z.array(z.lazy(() => global_search_types_inner_hits))
    ]).optional(),
    max_concurrent_group_searches: z.number().describe('The number of concurrent requests allowed to retrieve the inner_hits per group').optional(),
    collapse: z.lazy(() => global_search_types_field_collapse).optional()
});

export const global_search_types_inner_hits: z.AnyZodObject = z.object({
    name: types_name.optional(),
    size: z.number().describe('The maximum number of hits to return per `inner_hits`.').optional().default(3),
    from: z.number().describe('Inner hit starting document offset.').optional().default(0),
    collapse: global_search_types_field_collapse.optional(),
    docvalue_fields: z.array(types_query_dsl_field_and_format).optional(),
    explain: z.boolean().optional(),
    highlight: z.lazy(() => global_search_types_highlight).optional(),
    ignore_unmapped: z.boolean().optional(),
    script_fields: z.record(z.lazy(() => types_script_field)).optional(),
    seq_no_primary_term: z.boolean().optional(),
    fields: z.array(types_field).optional(),
    sort: z.lazy(() => types_sort).optional(),
    _source: global_search_types_source_config.optional(),
    stored_fields: types_fields.optional(),
    track_scores: z.boolean().optional().default(false),
    version: z.boolean().optional()
});

export const global_search_types_highlight: z.ZodTypeAny = z.lazy(() => global_search_types_highlight_base).and(z.object({
    encoder: global_search_types_highlighter_encoder.optional(),
    fields: z.union([
        z.record(z.lazy(() => global_search_types_highlight_field)),
        z.array(z.record(z.lazy(() => global_search_types_highlight_field)))
    ])
}));

export const global_search_types_highlight_field: z.ZodTypeAny = z.lazy(() => global_search_types_highlight_base).and(z.object({
    fragment_offset: z.number().optional(),
    matched_fields: types_fields.optional()
}));

export const global_search_types_highlight_base = z.object({
    type: global_search_types_highlighter_type.optional(),
    boundary_chars: z.string().describe('A string that contains each boundary character.').optional().default('.,!? \\t\\n'),
    boundary_max_scan: z.number().describe('How far to scan for boundary characters.').optional().default(20),
    boundary_scanner: global_search_types_boundary_scanner.optional(),
    boundary_scanner_locale: z.string().describe('Controls which locale is used to search for sentence and word boundaries.\nThis parameter takes a form of a language tag, for example: `"en-US"`, `"fr-FR"`, `"ja-JP"`.').optional().default('Locale.ROOT'),
    force_source: z.boolean().optional(),
    fragmenter: global_search_types_highlighter_fragmenter.optional(),
    fragment_size: z.number().describe('The size of the highlighted fragment in characters.').optional().default(100),
    highlight_filter: z.boolean().optional(),
    highlight_query: types_query_dsl_query_container.optional(),
    max_fragment_length: z.number().optional(),
    max_analyzed_offset: z.number().describe('If set to a non-negative value, highlighting stops at this defined maximum limit.\nThe rest of the text is not processed, thus not highlighted and no error is returned\nThe `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when its set to lower value than the query setting.').optional(),
    no_match_size: z.number().describe('The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.').optional().default(0),
    number_of_fragments: z.number().describe('The maximum number of fragments to return.\nIf the number of fragments is set to `0`, no fragments are returned.\nInstead, the entire field contents are highlighted and returned.\nThis can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.\nIf `number_of_fragments` is `0`, `fragment_size` is ignored.').optional().default(5),
    options: z.record(z.record(z.unknown())).optional(),
    order: global_search_types_highlighter_order.optional(),
    phrase_limit: z.number().describe('Controls the number of matching phrases in a document that are considered.\nPrevents the `fvh` highlighter from analyzing too many phrases and consuming too much memory.\nWhen using `matched_fields`, `phrase_limit` phrases per matched field are considered. Raising the limit increases query time and consumes more memory.\nOnly supported by the `fvh` highlighter.').optional().default(256),
    post_tags: z.array(z.string()).describe('Use in conjunction with `pre_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags.').optional(),
    pre_tags: z.array(z.string()).describe('Use in conjunction with `post_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags.').optional(),
    require_field_match: z.boolean().describe('By default, only fields that contains a query match are highlighted.\nSet to `false` to highlight all fields.').optional().default(true),
    tags_schema: global_search_types_highlighter_tags_schema.optional()
});

export const types_script_field = z.object({
    script: types_script,
    ignore_failure: z.boolean().optional()
});

export const types_sort: z.ZodTypeAny = z.union([
    z.lazy(() => types_sort_combinations),
    z.array(z.lazy(() => types_sort_combinations))
]);

export const types_sort_combinations: z.ZodTypeAny = z.union([
    types_field,
    z.lazy(() => types_sort_options)
]);

export const types_sort_options: z.AnyZodObject = z.object({
    _score: types_score_sort.optional(),
    _doc: types_score_sort.optional(),
    _geo_distance: z.lazy(() => types_geo_distance_sort).optional(),
    _script: z.lazy(() => types_script_sort).optional()
});

export const types_geo_distance_sort: z.AnyZodObject = z.object({
    mode: types_sort_mode.optional(),
    distance_type: types_geo_distance_type.optional(),
    ignore_unmapped: z.boolean().optional(),
    order: types_sort_order.optional(),
    unit: types_distance_unit.optional(),
    nested: z.lazy(() => types_nested_sort_value).optional()
});

export const types_nested_sort_value: z.AnyZodObject = z.object({
    filter: types_query_dsl_query_container.optional(),
    max_children: z.number().optional(),
    nested: z.lazy(() => types_nested_sort_value).optional(),
    path: types_field
});

export const types_script_sort = z.object({
    order: types_sort_order.optional(),
    script: types_script,
    type: types_script_sort_type.optional(),
    mode: types_sort_mode.optional(),
    nested: types_nested_sort_value.optional()
});

export const types_knn_search = z.object({
    field: types_field,
    query_vector: types_query_vector.optional(),
    query_vector_builder: types_query_vector_builder.optional(),
    k: z.number().describe('The final number of nearest neighbors to return as top hits').optional(),
    num_candidates: z.number().describe('The number of nearest neighbor candidates to consider per shard').optional(),
    visit_percentage: z.number().describe('The percentage of vectors to explore per shard while doing knn search with bbq_disk').optional(),
    boost: z.number().describe('Boost value to apply to kNN scores').optional(),
    filter: z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ]).optional(),
    similarity: z.number().describe('The minimum similarity for a vector to be considered a match').optional(),
    inner_hits: global_search_types_inner_hits.optional(),
    rescore_vector: types_rescore_vector.optional()
});

export const global_search_types_rescore: z.ZodTypeAny = z.object({
    window_size: z.number().optional()
}).and(z.object({
    query: z.lazy(() => global_search_types_rescore_query).optional(),
    learning_to_rank: global_search_types_learning_to_rank.optional(),
    script: z.lazy(() => global_search_types_script_rescore).optional()
}));

export const global_search_types_rescore_query = z.object({
    rescore_query: types_query_dsl_query_container,
    query_weight: z.number().describe('Relative importance of the original query versus the rescore query.').optional().default(1),
    rescore_query_weight: z.number().describe('Relative importance of the rescore query versus the original query.').optional().default(1),
    score_mode: global_search_types_score_mode.optional()
});

export const global_search_types_script_rescore = z.object({
    script: types_script
});

export const types_retriever_container: z.AnyZodObject = z.object({
    standard: z.lazy(() => types_standard_retriever).optional(),
    knn: z.lazy(() => types_knn_retriever).optional(),
    rrf: z.lazy(() => types_rrf_retriever).optional(),
    text_similarity_reranker: z.lazy(() => types_text_similarity_reranker).optional(),
    rule: z.lazy(() => types_rule_retriever).optional(),
    rescorer: z.lazy(() => types_rescorer_retriever).optional(),
    linear: z.lazy(() => types_linear_retriever).optional(),
    pinned: z.lazy(() => types_pinned_retriever).optional()
});

export const types_standard_retriever: z.ZodTypeAny = z.lazy(() => types_retriever_base).and(z.object({
    query: types_query_dsl_query_container.optional(),
    search_after: types_sort_results.optional(),
    terminate_after: z.number().describe('Maximum number of documents to collect for each shard.').optional(),
    sort: types_sort.optional(),
    collapse: global_search_types_field_collapse.optional()
}));

export const types_retriever_base = z.object({
    filter: z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ]).optional(),
    min_score: z.number().describe('Minimum _score for matching documents. Documents with a lower _score are not included in the top documents.').optional(),
    _name: z.string().describe('Retriever name.').optional()
});

export const types_knn_retriever = types_retriever_base.and(z.object({
    field: z.string().describe('The name of the vector field to search against.'),
    query_vector: types_query_vector.optional(),
    query_vector_builder: types_query_vector_builder.optional(),
    k: z.number().describe('Number of nearest neighbors to return as top hits.'),
    num_candidates: z.number().describe('Number of nearest neighbor candidates to consider per shard.'),
    visit_percentage: z.number().describe('The percentage of vectors to explore per shard while doing knn search with bbq_disk').optional(),
    similarity: z.number().describe('The minimum similarity required for a document to be considered a match.').optional(),
    rescore_vector: types_rescore_vector.optional()
}));

export const types_rrf_retriever: z.ZodTypeAny = types_retriever_base.and(z.object({
    retrievers: z.array(z.lazy(() => types_rrf_retriever_entry)).describe('A list of child retrievers to specify which sets of returned top documents will have the RRF formula applied to them. Each retriever can optionally include a weight parameter.'),
    rank_constant: z.number().describe('This value determines how much influence documents in individual result sets per query have over the final ranked result set.').optional(),
    rank_window_size: z.number().describe('This value determines the size of the individual result sets per query.').optional(),
    query: z.string().optional(),
    fields: z.array(z.string()).optional()
}));

/**
 * Either a direct RetrieverContainer (backward compatible) or an RRFRetrieverComponent with weight.
 */
export const types_rrf_retriever_entry: z.ZodTypeAny = z.union([
    types_retriever_container,
    z.lazy(() => types_rrf_retriever_component)
]);

/**
 * Wraps a retriever with an optional weight for RRF scoring.
 */
export const types_rrf_retriever_component = z.object({
    retriever: types_retriever_container,
    weight: z.number().describe('Weight multiplier for this retriever\'s contribution to the RRF score. Higher values increase influence. Defaults to 1.0 if not specified. Must be non-negative.').optional().default(1)
}).describe('Wraps a retriever with an optional weight for RRF scoring.');

export const types_text_similarity_reranker = types_retriever_base.and(z.object({
    retriever: types_retriever_container,
    rank_window_size: z.number().describe('This value determines how many documents we will consider from the nested retriever.').optional(),
    inference_id: z.string().describe('Unique identifier of the inference endpoint created using the inference API.').optional(),
    inference_text: z.string().describe('The text snippet used as the basis for similarity comparison.'),
    field: z.string().describe('The document field to be used for text similarity comparisons. This field should contain the text that will be evaluated against the inference_text.'),
    chunk_rescorer: types_chunk_rescorer.optional()
}));

export const types_rule_retriever = types_retriever_base.and(z.object({
    ruleset_ids: z.union([
        types_id,
        z.array(types_id)
    ]),
    match_criteria: z.record(z.unknown()).describe('The match criteria that will determine if a rule in the provided rulesets should be applied.'),
    retriever: types_retriever_container,
    rank_window_size: z.number().describe('This value determines the size of the individual result set.').optional()
}));

export const types_rescorer_retriever = types_retriever_base.and(z.object({
    retriever: types_retriever_container,
    rescore: z.union([
        global_search_types_rescore,
        z.array(global_search_types_rescore)
    ])
}));

export const types_linear_retriever: z.ZodTypeAny = types_retriever_base.and(z.object({
    retrievers: z.array(z.lazy(() => types_inner_retriever)).describe('Inner retrievers.').optional(),
    rank_window_size: z.number().optional(),
    query: z.string().optional(),
    fields: z.array(z.string()).optional(),
    normalizer: types_score_normalizer.optional()
}));

export const types_inner_retriever = z.object({
    retriever: types_retriever_container,
    weight: z.number(),
    normalizer: types_score_normalizer
});

export const types_pinned_retriever = types_retriever_base.and(z.object({
    retriever: types_retriever_container,
    ids: z.array(z.string()).optional(),
    docs: z.array(types_specified_document).optional(),
    rank_window_size: z.number().optional()
}));

export const types_mapping_runtime_fields: z.AnyZodObject = z.record(z.lazy(() => types_mapping_runtime_field));

export const types_mapping_runtime_field = z.object({
    fields: z.record(types_mapping_composite_sub_field).describe('For type `composite`').optional(),
    fetch_fields: z.array(types_mapping_runtime_field_fetch_fields).describe('For type `lookup`').optional(),
    format: z.string().describe('A custom format for `date` type runtime fields.').optional(),
    input_field: types_field.optional(),
    target_field: types_field.optional(),
    target_index: types_index_name.optional(),
    script: types_script.optional(),
    type: types_mapping_runtime_field_type
});

export const types_query_dsl_has_child_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.boolean().describe('Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.').optional().default(false),
    inner_hits: global_search_types_inner_hits.optional(),
    max_children: z.number().describe('Maximum number of child documents that match the query allowed for a returned parent document.\nIf the parent document exceeds this limit, it is excluded from the search results.').optional(),
    min_children: z.number().describe('Minimum number of child documents that match the query required to match the query for a returned parent document.\nIf the parent document does not meet this limit, it is excluded from the search results.').optional(),
    query: types_query_dsl_query_container,
    score_mode: types_query_dsl_child_score_mode.optional(),
    type: types_relation_name
}));

export const types_query_dsl_has_parent_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.boolean().describe('Indicates whether to ignore an unmapped `parent_type` and not return any documents instead of an error.\nYou can use this parameter to query multiple indices that may not contain the `parent_type`.').optional().default(false),
    inner_hits: global_search_types_inner_hits.optional(),
    parent_type: types_relation_name,
    query: types_query_dsl_query_container,
    score: z.boolean().describe('Indicates whether the relevance score of a matching parent document is aggregated into its child documents.').optional().default(false)
}));

export const types_query_dsl_intervals_query: z.ZodTypeAny = types_query_dsl_query_base.and(z.object({
    all_of: z.lazy(() => types_query_dsl_intervals_all_of).optional(),
    any_of: z.lazy(() => types_query_dsl_intervals_any_of).optional(),
    fuzzy: types_query_dsl_intervals_fuzzy.optional(),
    match: z.lazy(() => types_query_dsl_intervals_match).optional(),
    prefix: types_query_dsl_intervals_prefix.optional(),
    range: types_query_dsl_intervals_range.optional(),
    regexp: types_query_dsl_intervals_regexp.optional(),
    wildcard: types_query_dsl_intervals_wildcard.optional()
}));

export const types_query_dsl_intervals_all_of: z.AnyZodObject = z.object({
    intervals: z.array(z.lazy(() => types_query_dsl_intervals_container)).describe('An array of rules to combine. All rules must produce a match in a document for the overall source to match.'),
    max_gaps: z.number().describe('Maximum number of positions between the matching terms.\nIntervals produced by the rules further apart than this are not considered matches.').optional().default(-1),
    ordered: z.boolean().describe('If `true`, intervals produced by the rules should appear in the order in which they are specified.').optional().default(false),
    filter: z.lazy(() => types_query_dsl_intervals_filter).optional()
});

export const types_query_dsl_intervals_container: z.AnyZodObject = z.object({
    all_of: types_query_dsl_intervals_all_of.optional(),
    any_of: z.lazy(() => types_query_dsl_intervals_any_of).optional(),
    fuzzy: types_query_dsl_intervals_fuzzy.optional(),
    match: z.lazy(() => types_query_dsl_intervals_match).optional(),
    prefix: types_query_dsl_intervals_prefix.optional(),
    range: types_query_dsl_intervals_range.optional(),
    regexp: types_query_dsl_intervals_regexp.optional(),
    wildcard: types_query_dsl_intervals_wildcard.optional()
});

export const types_query_dsl_intervals_any_of: z.AnyZodObject = z.object({
    intervals: z.array(types_query_dsl_intervals_container).describe('An array of rules to match.'),
    filter: z.lazy(() => types_query_dsl_intervals_filter).optional()
});

export const types_query_dsl_intervals_filter = z.object({
    after: types_query_dsl_intervals_container.optional(),
    before: types_query_dsl_intervals_container.optional(),
    contained_by: types_query_dsl_intervals_container.optional(),
    containing: types_query_dsl_intervals_container.optional(),
    not_contained_by: types_query_dsl_intervals_container.optional(),
    not_containing: types_query_dsl_intervals_container.optional(),
    not_overlapping: types_query_dsl_intervals_container.optional(),
    overlapping: types_query_dsl_intervals_container.optional(),
    script: types_script.optional()
});

export const types_query_dsl_intervals_match = z.object({
    analyzer: z.string().describe('Analyzer used to analyze terms in the query.').optional(),
    max_gaps: z.number().describe('Maximum number of positions between the matching terms.\nTerms further apart than this are not considered matches.').optional().default(-1),
    ordered: z.boolean().describe('If `true`, matching terms must appear in their specified order.').optional().default(false),
    query: z.string().describe('Text you wish to find in the provided field.'),
    use_field: types_field.optional(),
    filter: types_query_dsl_intervals_filter.optional()
});

export const types_knn_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    query_vector: types_query_vector.optional(),
    query_vector_builder: types_query_vector_builder.optional(),
    num_candidates: z.number().describe('The number of nearest neighbor candidates to consider per shard').optional(),
    visit_percentage: z.number().describe('The percentage of vectors to explore per shard while doing knn search with bbq_disk').optional(),
    k: z.number().describe('The final number of nearest neighbors to return as top hits').optional(),
    filter: z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ]).optional(),
    similarity: z.number().describe('The minimum similarity for a vector to be considered a match').optional(),
    rescore_vector: types_rescore_vector.optional()
}));

export const types_query_dsl_nested_query = types_query_dsl_query_base.and(z.object({
    ignore_unmapped: z.boolean().describe('Indicates whether to ignore an unmapped path and not return any documents instead of an error.').optional().default(false),
    inner_hits: global_search_types_inner_hits.optional(),
    path: types_field,
    query: types_query_dsl_query_container,
    score_mode: types_query_dsl_child_score_mode.optional()
}));

export const types_query_dsl_pinned_query = types_query_dsl_query_base.and(z.object({
    organic: types_query_dsl_query_container
}).and(z.object({
    ids: z.array(types_id).describe('Document IDs listed in the order they are to appear in results.\nRequired if `docs` is not specified.').optional(),
    docs: z.array(types_query_dsl_pinned_doc).describe('Documents listed in the order they are to appear in results.\nRequired if `ids` is not specified.').optional()
})));

export const types_query_dsl_rule_query = types_query_dsl_query_base.and(z.object({
    organic: types_query_dsl_query_container,
    ruleset_ids: z.union([
        types_id,
        z.array(types_id)
    ]).optional(),
    ruleset_id: z.string().optional(),
    match_criteria: z.record(z.unknown())
}));

export const types_query_dsl_script_query = types_query_dsl_query_base.and(z.object({
    script: types_script
}));

export const types_query_dsl_script_score_query = types_query_dsl_query_base.and(z.object({
    min_score: z.number().describe('Documents with a score lower than this floating point number are excluded from the search results.').optional(),
    query: types_query_dsl_query_container,
    script: types_script
}));

export const types_query_dsl_span_containing_query: z.ZodTypeAny = types_query_dsl_query_base.and(z.object({
    big: z.lazy(() => types_query_dsl_span_query),
    little: z.lazy(() => types_query_dsl_span_query)
}));

export const types_query_dsl_span_query: z.AnyZodObject = z.object({
    span_containing: types_query_dsl_span_containing_query.optional(),
    span_field_masking: z.lazy(() => types_query_dsl_span_field_masking_query).optional(),
    span_first: z.lazy(() => types_query_dsl_span_first_query).optional(),
    span_gap: types_query_dsl_span_gap_query.optional(),
    span_multi: z.lazy(() => types_query_dsl_span_multi_term_query).optional(),
    span_near: z.lazy(() => types_query_dsl_span_near_query).optional(),
    span_not: z.lazy(() => types_query_dsl_span_not_query).optional(),
    span_or: z.lazy(() => types_query_dsl_span_or_query).optional(),
    span_term: z.record(types_query_dsl_span_term_query).describe('The equivalent of the `term` query but for use with other span queries.').optional(),
    span_within: z.lazy(() => types_query_dsl_span_within_query).optional()
});

export const types_query_dsl_span_field_masking_query = types_query_dsl_query_base.and(z.object({
    field: types_field,
    query: types_query_dsl_span_query
}));

export const types_query_dsl_span_first_query = types_query_dsl_query_base.and(z.object({
    end: z.number().describe('Controls the maximum end position permitted in a match.'),
    match: types_query_dsl_span_query
}));

export const types_query_dsl_span_multi_term_query = types_query_dsl_query_base.and(z.object({
    match: types_query_dsl_query_container
}));

export const types_query_dsl_span_near_query = types_query_dsl_query_base.and(z.object({
    clauses: z.array(types_query_dsl_span_query).describe('Array of one or more other span type queries.'),
    in_order: z.boolean().describe('Controls whether matches are required to be in-order.').optional(),
    slop: z.number().describe('Controls the maximum number of intervening unmatched positions permitted.').optional()
}));

export const types_query_dsl_span_not_query = types_query_dsl_query_base.and(z.object({
    dist: z.number().describe('The number of tokens from within the include span that cant have overlap with the exclude span.\nEquivalent to setting both `pre` and `post`.').optional(),
    exclude: types_query_dsl_span_query,
    include: types_query_dsl_span_query,
    post: z.number().describe('The number of tokens after the include span that cant have overlap with the exclude span.').optional().default(0),
    pre: z.number().describe('The number of tokens before the include span that cant have overlap with the exclude span.').optional().default(0)
}));

export const types_query_dsl_span_or_query = types_query_dsl_query_base.and(z.object({
    clauses: z.array(types_query_dsl_span_query).describe('Array of one or more other span type queries.')
}));

export const types_query_dsl_span_within_query = types_query_dsl_query_base.and(z.object({
    big: types_query_dsl_span_query,
    little: types_query_dsl_span_query
}));

export const types_query_dsl_terms_set_query = types_query_dsl_query_base.and(z.object({
    minimum_should_match: types_minimum_should_match.optional(),
    minimum_should_match_field: types_field.optional(),
    minimum_should_match_script: types_script.optional(),
    terms: z.array(types_field_value).describe('Array of terms you wish to find in the provided field.')
}));

export const types_aggregations_auto_date_histogram_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    buckets: z.number().describe('The target number of buckets.').optional().default(10),
    field: types_field.optional(),
    format: z.string().describe('The date format used to format `key_as_string` in the response.\nIf no `format` is specified, the first date format specified in the field mapping is used.').optional(),
    minimum_interval: types_aggregations_minimum_interval.optional(),
    missing: types_date_time.optional(),
    offset: z.string().describe('Time zone specified as a ISO 8601 UTC offset.').optional(),
    params: z.record(z.record(z.unknown())).optional(),
    script: types_script.optional(),
    time_zone: types_time_zone.optional()
}));

export const types_aggregations_average_aggregation: z.ZodTypeAny = z.lazy(() => types_aggregations_format_metric_aggregation_base).and(z.record(z.unknown()));

export const types_aggregations_format_metric_aggregation_base: z.ZodTypeAny = z.lazy(() => types_aggregations_metric_aggregation_base).and(z.object({
    format: z.string().optional()
}));

export const types_aggregations_metric_aggregation_base = z.object({
    field: types_field.optional(),
    missing: types_aggregations_missing.optional(),
    script: types_script.optional()
});

export const types_aggregations_boxplot_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    compression: z.number().describe('Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.').optional(),
    execution_hint: types_aggregations_t_digest_execution_hint.optional()
}));

export const types_aggregations_bucket_script_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    script: types_script.optional()
}));

export const types_aggregations_bucket_selector_aggregation = types_aggregations_pipeline_aggregation_base.and(z.object({
    script: types_script.optional()
}));

export const types_aggregations_bucket_sort_aggregation = types_aggregations_aggregation.and(z.object({
    from: z.number().describe('Buckets in positions prior to `from` will be truncated.').optional(),
    gap_policy: types_aggregations_gap_policy.optional(),
    size: z.number().describe('The number of buckets to return.\nDefaults to all buckets of the parent aggregation.').optional(),
    sort: types_sort.optional()
}));

export const types_aggregations_cardinality_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    precision_threshold: z.number().describe('A unique count below which counts are expected to be close to accurate.\nThis allows to trade memory for accuracy.').optional().default(3000),
    rehash: z.boolean().optional(),
    execution_hint: types_aggregations_cardinality_execution_mode.optional()
}));

export const types_aggregations_cartesian_bounds_aggregation = types_aggregations_metric_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_cartesian_centroid_aggregation = types_aggregations_metric_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_composite_aggregation: z.ZodTypeAny = types_aggregations_bucket_aggregation_base.and(z.object({
    after: types_aggregations_composite_aggregate_key.optional(),
    size: z.number().describe('The number of composite buckets that should be returned.').optional().default(10),
    sources: z.array(z.record(z.lazy(() => types_aggregations_composite_aggregation_source))).describe('The value sources used to build composite buckets.\nKeys are returned in the order of the `sources` definition.').optional()
}));

export const types_aggregations_composite_aggregation_source: z.AnyZodObject = z.object({
    terms: z.lazy(() => types_aggregations_composite_terms_aggregation).optional(),
    histogram: z.lazy(() => types_aggregations_composite_histogram_aggregation).optional(),
    date_histogram: z.lazy(() => types_aggregations_composite_date_histogram_aggregation).optional(),
    geotile_grid: z.lazy(() => types_aggregations_composite_geo_tile_grid_aggregation).optional()
});

export const types_aggregations_composite_terms_aggregation: z.ZodTypeAny = z.lazy(() => types_aggregations_composite_aggregation_base).and(z.record(z.unknown()));

export const types_aggregations_composite_aggregation_base = z.object({
    field: types_field.optional(),
    missing_bucket: z.boolean().optional(),
    missing_order: types_aggregations_missing_order.optional(),
    script: types_script.optional(),
    value_type: types_aggregations_value_type.optional(),
    order: types_sort_order.optional()
});

export const types_aggregations_composite_histogram_aggregation = types_aggregations_composite_aggregation_base.and(z.object({
    interval: z.number()
}));

export const types_aggregations_composite_date_histogram_aggregation = types_aggregations_composite_aggregation_base.and(z.object({
    format: z.string().optional(),
    calendar_interval: types_duration_large.optional(),
    fixed_interval: types_duration_large.optional(),
    offset: types_duration.optional(),
    time_zone: types_time_zone.optional()
}));

export const types_aggregations_composite_geo_tile_grid_aggregation = types_aggregations_composite_aggregation_base.and(z.object({
    precision: z.number().optional(),
    bounds: types_geo_bounds.optional()
}));

export const types_aggregations_date_histogram_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    calendar_interval: types_aggregations_calendar_interval.optional(),
    extended_bounds: types_aggregations_extended_bounds_field_date_math.optional(),
    hard_bounds: types_aggregations_extended_bounds_field_date_math.optional(),
    field: types_field.optional(),
    fixed_interval: types_duration.optional(),
    format: z.string().describe('The date format used to format `key_as_string` in the response.\nIf no `format` is specified, the first date format specified in the field mapping is used.').optional(),
    interval: types_duration.optional(),
    min_doc_count: z.number().describe('Only returns buckets that have `min_doc_count` number of documents.\nBy default, all buckets between the first bucket that matches documents and the last one are returned.').optional(),
    missing: types_date_time.optional(),
    offset: types_duration.optional(),
    order: types_aggregations_aggregate_order.optional(),
    params: z.record(z.record(z.unknown())).optional(),
    script: types_script.optional(),
    time_zone: types_time_zone.optional(),
    keyed: z.boolean().describe('Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array.').optional()
}));

export const types_aggregations_diversified_sampler_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    execution_hint: types_aggregations_sampler_aggregation_execution_hint.optional(),
    max_docs_per_value: z.number().describe('Limits how many documents are permitted per choice of de-duplicating value.').optional().default(1),
    script: types_script.optional(),
    shard_size: z.number().describe('Limits how many top-scoring documents are collected in the sample processed on each shard.').optional().default(100),
    field: types_field.optional()
}));

export const types_aggregations_extended_stats_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    sigma: z.number().describe('The number of standard deviations above/below the mean to display.').optional()
}));

export const types_aggregations_frequent_item_sets_aggregation = z.object({
    fields: z.array(types_aggregations_frequent_item_sets_field).describe('Fields to analyze.'),
    minimum_set_size: z.number().describe('The minimum size of one item set.').optional().default(1),
    minimum_support: z.number().describe('The minimum support of one item set.').optional().default(0.1),
    size: z.number().describe('The number of top item sets to return.').optional().default(10),
    filter: types_query_dsl_query_container.optional()
});

export const types_aggregations_filters_aggregation: z.ZodTypeAny = types_aggregations_bucket_aggregation_base.and(z.object({
    filters: z.lazy(() => types_aggregations_buckets_query_container).optional(),
    other_bucket: z.boolean().describe('Set to `true` to add a bucket to the response which will contain all documents that do not match any of the given filters.').optional(),
    other_bucket_key: z.string().describe('The key with which the other bucket is returned.').optional().default('_other_'),
    keyed: z.boolean().describe('By default, the named filters aggregation returns the buckets as an object.\nSet to `false` to return the buckets as an array of objects.').optional().default(true)
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_query_container = z.union([
    z.record(types_query_dsl_query_container),
    z.array(types_query_dsl_query_container)
]);

export const types_aggregations_geo_bounds_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    wrap_longitude: z.boolean().describe('Specifies whether the bounding box should be allowed to overlap the international date line.').optional().default(true)
}));

export const types_aggregations_geo_centroid_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    count: z.number().optional(),
    location: types_geo_location.optional()
}));

export const types_aggregations_histogram_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    extended_bounds: types_aggregations_extended_boundsdouble.optional(),
    hard_bounds: types_aggregations_extended_boundsdouble.optional(),
    field: types_field.optional(),
    interval: z.number().describe('The interval for the buckets.\nMust be a positive decimal.').optional(),
    min_doc_count: z.number().describe('Only returns buckets that have `min_doc_count` number of documents.\nBy default, the response will fill gaps in the histogram with empty buckets.').optional(),
    missing: z.number().describe('The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.').optional(),
    offset: z.number().describe('By default, the bucket keys start with 0 and then continue in even spaced steps of `interval`.\nThe bucket boundaries can be shifted by using the `offset` option.').optional(),
    order: types_aggregations_aggregate_order.optional(),
    script: types_script.optional(),
    format: z.string().optional(),
    keyed: z.boolean().describe('If `true`, returns buckets as a hash instead of an array, keyed by the bucket keys.').optional().default(false)
}));

export const types_aggregations_max_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_median_absolute_deviation_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    compression: z.number().describe('Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.').optional().default(1000),
    execution_hint: types_aggregations_t_digest_execution_hint.optional()
}));

export const types_aggregations_min_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_percentile_ranks_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    keyed: z.boolean().describe('By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array.\nSet to `false` to disable this behavior.').optional().default(true),
    values: z.union([
        z.array(z.number()),
        z.string(),
        z.null()
    ]).optional(),
    hdr: types_aggregations_hdr_method.optional(),
    tdigest: types_aggregations_t_digest.optional()
}));

export const types_aggregations_percentiles_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    keyed: z.boolean().describe('By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array.\nSet to `false` to disable this behavior.').optional().default(true),
    percents: z.union([
        z.number(),
        z.array(z.number())
    ]).optional(),
    hdr: types_aggregations_hdr_method.optional(),
    tdigest: types_aggregations_t_digest.optional()
}));

export const types_aggregations_range_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    field: types_field.optional(),
    missing: z.number().describe('The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.').optional(),
    ranges: z.array(types_aggregations_aggregation_range).describe('An array of ranges used to bucket documents.').optional(),
    script: types_script.optional(),
    keyed: z.boolean().describe('Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array.').optional(),
    format: z.string().optional()
}));

export const types_aggregations_rate_aggregation = types_aggregations_format_metric_aggregation_base.and(z.object({
    unit: types_aggregations_calendar_interval.optional(),
    mode: types_aggregations_rate_mode.optional()
}));

export const types_aggregations_scripted_metric_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    combine_script: types_script.optional(),
    init_script: types_script.optional(),
    map_script: types_script.optional(),
    params: z.record(z.record(z.unknown())).describe('A global object with script parameters for `init`, `map` and `combine` scripts.\nIt is shared between the scripts.').optional(),
    reduce_script: types_script.optional()
}));

export const types_aggregations_significant_terms_aggregation: z.ZodTypeAny = types_aggregations_bucket_aggregation_base.and(z.object({
    background_filter: types_query_dsl_query_container.optional(),
    chi_square: types_aggregations_chi_square_heuristic.optional(),
    exclude: types_aggregations_terms_exclude.optional(),
    execution_hint: types_aggregations_terms_aggregation_execution_hint.optional(),
    field: types_field.optional(),
    gnd: types_aggregations_google_normalized_distance_heuristic.optional(),
    include: types_aggregations_terms_include.optional(),
    jlh: types_empty_object.optional(),
    min_doc_count: z.number().describe('Only return terms that are found in more than `min_doc_count` hits.').optional().default(3),
    mutual_information: types_aggregations_mutual_information_heuristic.optional(),
    percentage: types_aggregations_percentage_score_heuristic.optional(),
    script_heuristic: z.lazy(() => types_aggregations_scripted_heuristic).optional(),
    p_value: types_aggregations_p_value_heuristic.optional(),
    shard_min_doc_count: z.number().describe('Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`.\nTerms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.').optional(),
    shard_size: z.number().describe('Can be used to control the volumes of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.').optional(),
    size: z.number().describe('The number of buckets returned out of the overall terms list.').optional()
}));

export const types_aggregations_scripted_heuristic = z.object({
    script: types_script
});

export const types_aggregations_significant_text_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    background_filter: types_query_dsl_query_container.optional(),
    chi_square: types_aggregations_chi_square_heuristic.optional(),
    exclude: types_aggregations_terms_exclude.optional(),
    execution_hint: types_aggregations_terms_aggregation_execution_hint.optional(),
    field: types_field.optional(),
    filter_duplicate_text: z.boolean().describe('Whether to out duplicate text to deal with noisy data.').optional(),
    gnd: types_aggregations_google_normalized_distance_heuristic.optional(),
    include: types_aggregations_terms_include.optional(),
    jlh: types_empty_object.optional(),
    min_doc_count: z.number().describe('Only return values that are found in more than `min_doc_count` hits.').optional().default(3),
    mutual_information: types_aggregations_mutual_information_heuristic.optional(),
    percentage: types_aggregations_percentage_score_heuristic.optional(),
    script_heuristic: types_aggregations_scripted_heuristic.optional(),
    shard_min_doc_count: z.number().describe('Regulates the certainty a shard has if the values should actually be added to the candidate list or not with respect to the min_doc_count.\nValues will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.').optional(),
    shard_size: z.number().describe('The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.').optional(),
    size: z.number().describe('The number of buckets returned out of the overall terms list.').optional(),
    source_fields: types_fields.optional()
}));

export const types_aggregations_stats_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_string_stats_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    show_distribution: z.boolean().describe('Shows the probability distribution for all characters.').optional().default(false)
}));

export const types_aggregations_sum_aggregation = types_aggregations_format_metric_aggregation_base.and(z.record(z.unknown()));

export const types_aggregations_terms_aggregation = types_aggregations_bucket_aggregation_base.and(z.object({
    collect_mode: types_aggregations_terms_aggregation_collect_mode.optional(),
    exclude: types_aggregations_terms_exclude.optional(),
    execution_hint: types_aggregations_terms_aggregation_execution_hint.optional(),
    field: types_field.optional(),
    include: types_aggregations_terms_include.optional(),
    min_doc_count: z.number().describe('Only return values that are found in more than `min_doc_count` hits.').optional().default(1),
    missing: types_aggregations_missing.optional(),
    missing_order: types_aggregations_missing_order.optional(),
    missing_bucket: z.boolean().optional(),
    value_type: z.string().describe('Coerced unmapped fields into the specified type.').optional(),
    order: types_aggregations_aggregate_order.optional(),
    script: types_script.optional(),
    shard_min_doc_count: z.number().describe('Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`.\nTerms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.').optional(),
    shard_size: z.number().describe('The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.').optional(),
    show_term_doc_count_error: z.boolean().describe('Set to `true` to return the `doc_count_error_upper_bound`, which is an upper bound to the error on the `doc_count` returned by each shard.').optional(),
    size: z.number().describe('The number of buckets returned out of the overall terms list.').optional().default(10),
    format: z.string().optional()
}));

export const types_aggregations_top_hits_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    docvalue_fields: z.array(types_query_dsl_field_and_format).describe('Fields for which to return doc values.').optional(),
    explain: z.boolean().describe('If `true`, returns detailed information about score computation as part of a hit.').optional().default(false),
    fields: z.array(types_query_dsl_field_and_format).describe('Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.').optional(),
    from: z.number().describe('Starting document offset.').optional().default(0),
    highlight: global_search_types_highlight.optional(),
    script_fields: z.record(types_script_field).describe('Returns the result of one or more script evaluations for each hit.').optional(),
    size: z.number().describe('The maximum number of top matching hits to return per bucket.').optional().default(3),
    sort: types_sort.optional(),
    _source: global_search_types_source_config.optional(),
    stored_fields: types_fields.optional(),
    track_scores: z.boolean().describe('If `true`, calculates and returns document scores, even if the scores are not used for sorting.').optional().default(false),
    version: z.boolean().describe('If `true`, returns document version as part of a hit.').optional().default(false),
    seq_no_primary_term: z.boolean().describe('If `true`, returns sequence number and primary term of the last modification of each hit.').optional()
}));

export const types_aggregations_t_test_aggregation: z.ZodTypeAny = types_aggregations_aggregation.and(z.object({
    a: z.lazy(() => types_aggregations_test_population).optional(),
    b: z.lazy(() => types_aggregations_test_population).optional(),
    type: types_aggregations_t_test_type.optional()
}));

export const types_aggregations_test_population = z.object({
    field: types_field,
    script: types_script.optional(),
    filter: types_query_dsl_query_container.optional()
});

export const types_aggregations_top_metrics_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    metrics: z.union([
        types_aggregations_top_metrics_value,
        z.array(types_aggregations_top_metrics_value)
    ]).optional(),
    size: z.number().describe('The number of top documents from which to return metrics.').optional().default(1),
    sort: types_sort.optional()
}));

export const types_aggregations_value_count_aggregation: z.ZodTypeAny = z.lazy(() => types_aggregations_formattable_metric_aggregation).and(z.record(z.unknown()));

export const types_aggregations_formattable_metric_aggregation = types_aggregations_metric_aggregation_base.and(z.object({
    format: z.string().optional()
}));

export const types_aggregations_weighted_average_aggregation: z.ZodTypeAny = types_aggregations_aggregation.and(z.object({
    format: z.string().describe('A numeric response formatter.').optional(),
    value: z.lazy(() => types_aggregations_weighted_average_value).optional(),
    value_type: types_aggregations_value_type.optional(),
    weight: z.lazy(() => types_aggregations_weighted_average_value).optional()
}));

export const types_aggregations_weighted_average_value = z.object({
    field: types_field.optional(),
    missing: z.number().describe('A value or weight to use if the field is missing.').optional(),
    script: types_script.optional()
});

export const types_aggregations_variable_width_histogram_aggregation = z.object({
    field: types_field.optional(),
    buckets: z.number().describe('The target number of buckets.').optional().default(10),
    shard_size: z.number().describe('The number of buckets that the coordinating node will request from each shard.\nDefaults to `buckets * 50`.').optional(),
    initial_buffer: z.number().describe('Specifies the number of individual documents that will be stored in memory on a shard before the initial bucketing algorithm is run.\nDefaults to `min(10 * shard_size, 50000)`.').optional(),
    script: types_script.optional()
});

export const global_bulk_update_action = z.object({
    detect_noop: z.boolean().describe('If true, the `result` in the response is set to \'noop\' when no changes to the document occur.').optional().default(true),
    doc: z.record(z.unknown()).describe('A partial update to an existing document.').optional(),
    doc_as_upsert: z.boolean().describe('Set to `true` to use the contents of `doc` as the value of `upsert`.').optional().default(false),
    script: types_script.optional(),
    scripted_upsert: z.boolean().describe('Set to `true` to run the script whether or not the document exists.').optional().default(false),
    _source: global_search_types_source_config.optional(),
    upsert: z.record(z.unknown()).describe('If the document does not already exist, the contents of `upsert` are inserted as a new document.\nIf the document exists, the `script` is run.').optional()
});

export const indices_types_index_settings: z.AnyZodObject = z.object({
    index: z.lazy(() => indices_types_index_settings).optional(),
    mode: z.string().optional(),
    routing_path: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    soft_deletes: indices_types_soft_deletes.optional(),
    sort: indices_types_index_segment_sort.optional(),
    number_of_shards: z.union([
        z.number(),
        z.string()
    ]).optional(),
    number_of_replicas: z.union([
        z.number(),
        z.string()
    ]).optional(),
    number_of_routing_shards: z.number().optional(),
    check_on_startup: indices_types_index_check_on_startup.optional(),
    codec: z.string().optional().default('LZ4'),
    routing_partition_size: spec_utils_stringifiedinteger.optional(),
    load_fixed_bitset_filters_eagerly: z.boolean().optional().default(true),
    hidden: z.union([
        z.boolean(),
        z.string()
    ]).optional(),
    auto_expand_replicas: z.union([
        z.string(),
        spec_utils_null_value
    ]).optional(),
    merge: indices_types_merge.optional(),
    search: indices_types_settings_search.optional(),
    refresh_interval: types_duration.optional(),
    max_result_window: z.number().optional().default(10000),
    max_inner_result_window: z.number().optional().default(100),
    max_rescore_window: z.number().optional().default(10000),
    max_docvalue_fields_search: z.number().optional().default(100),
    max_script_fields: z.number().optional().default(32),
    max_ngram_diff: z.number().optional().default(1),
    max_shingle_diff: z.number().optional().default(3),
    blocks: indices_types_index_setting_blocks.optional(),
    max_refresh_listeners: z.number().optional(),
    analyze: indices_types_settings_analyze.optional(),
    highlight: indices_types_settings_highlight.optional(),
    max_terms_count: z.number().optional().default(65536),
    max_regex_length: z.number().optional().default(1000),
    routing: indices_types_index_routing.optional(),
    gc_deletes: types_duration.optional(),
    default_pipeline: types_pipeline_name.optional(),
    final_pipeline: types_pipeline_name.optional(),
    lifecycle: indices_types_index_settings_lifecycle.optional(),
    provided_name: types_name.optional(),
    creation_date: spec_utils_stringified_epoch_time_unit_millis.optional(),
    creation_date_string: types_date_time.optional(),
    uuid: types_uuid.optional(),
    version: indices_types_index_versioning.optional(),
    verified_before_close: z.union([
        z.boolean(),
        z.string()
    ]).optional(),
    format: z.union([
        z.string(),
        z.number()
    ]).optional(),
    max_slices_per_scroll: z.number().optional(),
    translog: indices_types_translog.optional(),
    query_string: indices_types_settings_query_string.optional(),
    priority: z.union([
        z.number(),
        z.string()
    ]).optional(),
    top_metrics_max_size: z.number().optional(),
    analysis: z.lazy(() => indices_types_index_settings_analysis).optional(),
    settings: z.lazy(() => indices_types_index_settings).optional(),
    time_series: indices_types_index_settings_time_series.optional(),
    queries: indices_types_queries.optional(),
    similarity: z.record(z.lazy(() => indices_types_settings_similarity)).describe('Configure custom similarity settings to customize how search results are scored.').optional(),
    mapping: indices_types_mapping_limit_settings.optional(),
    'indexing.slowlog': indices_types_indexing_slowlog_settings.optional(),
    indexing_pressure: indices_types_indexing_pressure.optional(),
    store: indices_types_storage.optional()
});

export const indices_types_index_settings_analysis: z.AnyZodObject = z.object({
    analyzer: z.record(types_analysis_analyzer).optional(),
    char_filter: z.record(types_analysis_char_filter).optional(),
    filter: z.record(z.lazy(() => types_analysis_token_filter)).optional(),
    normalizer: z.record(types_analysis_normalizer).optional(),
    tokenizer: z.record(types_analysis_tokenizer).optional()
});

export const types_analysis_token_filter: z.ZodTypeAny = z.union([
    z.string(),
    z.lazy(() => types_analysis_token_filter_definition)
]);

export const types_analysis_token_filter_definition: z.ZodTypeAny = z.union([
    types_analysis_apostrophe_token_filter,
    types_analysis_arabic_stem_token_filter,
    types_analysis_arabic_normalization_token_filter,
    types_analysis_ascii_folding_token_filter,
    types_analysis_bengali_normalization_token_filter,
    types_analysis_brazilian_stem_token_filter,
    types_analysis_cjk_bigram_token_filter,
    types_analysis_cjk_width_token_filter,
    types_analysis_classic_token_filter,
    types_analysis_common_grams_token_filter,
    z.lazy(() => types_analysis_condition_token_filter),
    types_analysis_czech_stem_token_filter,
    types_analysis_decimal_digit_token_filter,
    types_analysis_delimited_payload_token_filter,
    types_analysis_dutch_stem_token_filter,
    types_analysis_edge_n_gram_token_filter,
    types_analysis_elision_token_filter,
    types_analysis_fingerprint_token_filter,
    types_analysis_flatten_graph_token_filter,
    types_analysis_french_stem_token_filter,
    types_analysis_german_normalization_token_filter,
    types_analysis_german_stem_token_filter,
    types_analysis_hindi_normalization_token_filter,
    types_analysis_hunspell_token_filter,
    types_analysis_hyphenation_decompounder_token_filter,
    types_analysis_indic_normalization_token_filter,
    types_analysis_keep_types_token_filter,
    types_analysis_keep_words_token_filter,
    types_analysis_keyword_marker_token_filter,
    types_analysis_keyword_repeat_token_filter,
    types_analysis_k_stem_token_filter,
    types_analysis_length_token_filter,
    types_analysis_limit_token_count_token_filter,
    types_analysis_lowercase_token_filter,
    types_analysis_min_hash_token_filter,
    types_analysis_multiplexer_token_filter,
    types_analysis_n_gram_token_filter,
    types_analysis_nori_part_of_speech_token_filter,
    types_analysis_pattern_capture_token_filter,
    types_analysis_pattern_replace_token_filter,
    types_analysis_persian_normalization_token_filter,
    types_analysis_persian_stem_token_filter,
    types_analysis_porter_stem_token_filter,
    z.lazy(() => types_analysis_predicate_token_filter),
    types_analysis_remove_duplicates_token_filter,
    types_analysis_reverse_token_filter,
    types_analysis_russian_stem_token_filter,
    types_analysis_scandinavian_folding_token_filter,
    types_analysis_scandinavian_normalization_token_filter,
    types_analysis_serbian_normalization_token_filter,
    types_analysis_shingle_token_filter,
    types_analysis_snowball_token_filter,
    types_analysis_sorani_normalization_token_filter,
    types_analysis_stemmer_override_token_filter,
    types_analysis_stemmer_token_filter,
    types_analysis_stop_token_filter,
    types_analysis_synonym_graph_token_filter,
    types_analysis_synonym_token_filter,
    types_analysis_trim_token_filter,
    types_analysis_truncate_token_filter,
    types_analysis_unique_token_filter,
    types_analysis_uppercase_token_filter,
    types_analysis_word_delimiter_graph_token_filter,
    types_analysis_word_delimiter_token_filter,
    types_analysis_ja_stop_token_filter,
    types_analysis_kuromoji_stemmer_token_filter,
    types_analysis_kuromoji_reading_form_token_filter,
    types_analysis_kuromoji_part_of_speech_token_filter,
    types_analysis_icu_collation_token_filter,
    types_analysis_icu_folding_token_filter,
    types_analysis_icu_normalization_token_filter,
    types_analysis_icu_transform_token_filter,
    types_analysis_phonetic_token_filter,
    types_analysis_dictionary_decompounder_token_filter
]);

export const types_analysis_condition_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['condition']),
    filter: z.array(z.string()).describe('Array of token filters. If a token matches the predicate script in the `script` parameter, these filters are applied to the token in the order provided.'),
    script: types_script
}));

export const types_analysis_predicate_token_filter = types_analysis_token_filter_base.and(z.object({
    type: z.enum(['predicate_token_filter']),
    script: types_script
}));

export const indices_types_settings_similarity: z.ZodTypeAny = z.union([
    indices_types_settings_similarity_bm25,
    indices_types_settings_similarity_boolean,
    indices_types_settings_similarity_dfi,
    indices_types_settings_similarity_dfr,
    indices_types_settings_similarity_ib,
    indices_types_settings_similarity_lmd,
    indices_types_settings_similarity_lmj,
    z.lazy(() => indices_types_settings_similarity_scripted)
]);

export const indices_types_settings_similarity_scripted = z.object({
    type: z.enum(['scripted']),
    script: types_script,
    weight_script: types_script.optional()
});

export const cluster_types_component_template: z.AnyZodObject = z.object({
    name: types_name,
    component_template: z.lazy(() => cluster_types_component_template_node)
});

export const cluster_types_component_template_node: z.AnyZodObject = z.object({
    template: z.lazy(() => cluster_types_component_template_summary),
    version: types_version_number.optional(),
    _meta: types_metadata.optional(),
    deprecated: z.boolean().optional(),
    created_date: types_date_time.optional(),
    created_date_millis: types_epoch_time_unit_millis.optional(),
    modified_date: types_date_time.optional(),
    modified_date_millis: types_epoch_time_unit_millis.optional()
});

export const cluster_types_component_template_summary: z.AnyZodObject = z.object({
    _meta: types_metadata.optional(),
    version: types_version_number.optional(),
    settings: z.record(indices_types_index_settings).optional(),
    mappings: z.lazy(() => types_mapping_type_mapping).optional(),
    aliases: z.record(z.lazy(() => indices_types_alias_definition)).optional(),
    lifecycle: indices_types_data_stream_lifecycle_with_rollover.optional(),
    data_stream_options: z.union([
        indices_types_data_stream_options_template,
        z.string(),
        z.null()
    ]).optional()
});

export const types_mapping_type_mapping: z.AnyZodObject = z.object({
    all_field: types_mapping_all_field.optional(),
    date_detection: z.boolean().optional(),
    dynamic: types_mapping_dynamic_mapping.optional(),
    dynamic_date_formats: z.array(z.string()).optional(),
    dynamic_templates: z.array(z.record(z.lazy(() => types_mapping_dynamic_template))).optional(),
    _field_names: types_mapping_field_names_field.optional(),
    index_field: types_mapping_index_field.optional(),
    _meta: types_metadata.optional(),
    numeric_detection: z.boolean().optional(),
    properties: z.record(z.lazy(() => types_mapping_property)).optional(),
    _routing: types_mapping_routing_field.optional(),
    _size: types_mapping_size_field.optional(),
    _source: types_mapping_source_field.optional(),
    runtime: z.record(types_mapping_runtime_field).optional(),
    enabled: z.boolean().optional(),
    subobjects: types_mapping_subobjects.optional(),
    _data_stream_timestamp: types_mapping_data_stream_timestamp.optional()
});

export const types_mapping_dynamic_template: z.ZodTypeAny = z.object({
    match: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    path_match: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    unmatch: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    path_unmatch: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    match_mapping_type: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    unmatch_mapping_type: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    match_pattern: types_mapping_match_type.optional()
}).and(z.object({
    mapping: z.lazy(() => types_mapping_property).optional(),
    runtime: types_mapping_runtime_field.optional()
}));

export const types_mapping_property: z.ZodTypeAny = z.union([
    z.lazy(() => types_mapping_binary_property),
    z.lazy(() => types_mapping_boolean_property),
    z.lazy(() => types_mapping_dynamic_property),
    z.lazy(() => types_mapping_join_property),
    z.lazy(() => types_mapping_keyword_property),
    z.lazy(() => types_mapping_match_only_text_property),
    z.lazy(() => types_mapping_percolator_property),
    z.lazy(() => types_mapping_rank_feature_property),
    z.lazy(() => types_mapping_rank_features_property),
    z.lazy(() => types_mapping_search_as_you_type_property),
    z.lazy(() => types_mapping_text_property),
    z.lazy(() => types_mapping_version_property),
    z.lazy(() => types_mapping_wildcard_property),
    z.lazy(() => types_mapping_date_nanos_property),
    z.lazy(() => types_mapping_date_property),
    z.lazy(() => types_mapping_aggregate_metric_double_property),
    z.lazy(() => types_mapping_dense_vector_property),
    z.lazy(() => types_mapping_flattened_property),
    z.lazy(() => types_mapping_nested_property),
    z.lazy(() => types_mapping_object_property),
    z.lazy(() => types_mapping_passthrough_object_property),
    z.lazy(() => types_mapping_rank_vector_property),
    z.lazy(() => types_mapping_semantic_text_property),
    z.lazy(() => types_mapping_sparse_vector_property),
    z.lazy(() => types_mapping_completion_property),
    z.lazy(() => types_mapping_constant_keyword_property),
    z.lazy(() => types_mapping_counted_keyword_property),
    z.lazy(() => types_mapping_field_alias_property),
    z.lazy(() => types_mapping_histogram_property),
    z.lazy(() => types_mapping_ip_property),
    z.lazy(() => types_mapping_murmur3_hash_property),
    z.lazy(() => types_mapping_token_count_property),
    z.lazy(() => types_mapping_geo_point_property),
    z.lazy(() => types_mapping_geo_shape_property),
    z.lazy(() => types_mapping_point_property),
    z.lazy(() => types_mapping_shape_property),
    z.lazy(() => types_mapping_byte_number_property),
    z.lazy(() => types_mapping_double_number_property),
    z.lazy(() => types_mapping_float_number_property),
    z.lazy(() => types_mapping_half_float_number_property),
    z.lazy(() => types_mapping_integer_number_property),
    z.lazy(() => types_mapping_long_number_property),
    z.lazy(() => types_mapping_scaled_float_number_property),
    z.lazy(() => types_mapping_short_number_property),
    z.lazy(() => types_mapping_unsigned_long_number_property),
    z.lazy(() => types_mapping_date_range_property),
    z.lazy(() => types_mapping_double_range_property),
    z.lazy(() => types_mapping_float_range_property),
    z.lazy(() => types_mapping_integer_range_property),
    z.lazy(() => types_mapping_ip_range_property),
    z.lazy(() => types_mapping_long_range_property),
    z.lazy(() => types_mapping_icu_collation_property)
]);

export const types_mapping_binary_property: z.ZodTypeAny = z.lazy(() => types_mapping_doc_values_property_base).and(z.object({
    type: z.enum(['binary'])
}));

export const types_mapping_doc_values_property_base: z.ZodTypeAny = z.lazy(() => types_mapping_core_property_base).and(z.object({
    doc_values: z.boolean().optional()
}));

export const types_mapping_core_property_base: z.ZodTypeAny = z.lazy(() => types_mapping_property_base).and(z.object({
    copy_to: types_fields.optional(),
    store: z.boolean().optional()
}));

export const types_mapping_property_base = z.object({
    meta: z.record(z.string()).describe('Metadata about the field.').optional(),
    properties: z.record(types_mapping_property).optional(),
    ignore_above: z.number().optional(),
    dynamic: types_mapping_dynamic_mapping.optional(),
    fields: z.record(types_mapping_property).optional(),
    synthetic_source_keep: types_mapping_synthetic_source_keep_enum.optional()
});

export const types_mapping_boolean_property = types_mapping_doc_values_property_base.and(z.object({
    boost: z.number().optional(),
    fielddata: indices_types_numeric_fielddata.optional(),
    index: z.boolean().optional(),
    null_value: z.boolean().optional(),
    ignore_malformed: z.boolean().optional(),
    script: types_script.optional(),
    on_script_error: types_mapping_on_script_error.optional(),
    time_series_dimension: z.boolean().describe('For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.').optional(),
    type: z.enum(['boolean'])
}));

export const types_mapping_dynamic_property = types_mapping_doc_values_property_base.and(z.object({
    type: z.enum(['{dynamic_type}']),
    enabled: z.boolean().optional(),
    null_value: types_field_value.optional(),
    boost: z.number().optional(),
    coerce: z.boolean().optional(),
    script: types_script.optional(),
    on_script_error: types_mapping_on_script_error.optional(),
    ignore_malformed: z.boolean().optional(),
    time_series_metric: types_mapping_time_series_metric_type.optional(),
    analyzer: z.string().optional(),
    eager_global_ordinals: z.boolean().optional(),
    index: z.boolean().optional(),
    index_options: types_mapping_index_options.optional(),
    index_phrases: z.boolean().optional(),
    index_prefixes: z.union([
        types_mapping_text_index_prefixes,
        z.string(),
        z.null()
    ]).optional(),
    norms: z.boolean().optional(),
    position_increment_gap: z.number().optional(),
    search_analyzer: z.string().optional(),
    search_quote_analyzer: z.string().optional(),
    term_vector: types_mapping_term_vector_option.optional(),
    format: z.string().optional(),
    precision_step: z.number().optional(),
    locale: z.string().optional()
}));

export const types_mapping_join_property = types_mapping_property_base.and(z.object({
    relations: z.record(z.union([
        types_relation_name,
        z.array(types_relation_name)
    ])).optional(),
    eager_global_ordinals: z.boolean().optional(),
    type: z.enum(['join'])
}));

export const types_mapping_keyword_property = types_mapping_doc_values_property_base.and(z.object({
    boost: z.number().optional(),
    eager_global_ordinals: z.boolean().optional(),
    index: z.boolean().optional(),
    index_options: types_mapping_index_options.optional(),
    script: types_script.optional(),
    on_script_error: types_mapping_on_script_error.optional(),
    normalizer: z.string().optional(),
    norms: z.boolean().optional(),
    null_value: z.string().optional(),
    similarity: z.union([
        z.string(),
        z.null()
    ]).optional(),
    split_queries_on_whitespace: z.boolean().optional(),
    time_series_dimension: z.boolean().describe('For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.').optional(),
    type: z.enum(['keyword'])
}));

/**
 * A variant of text that trades scoring and efficiency of positional queries for space efficiency. This field
 * effectively stores data the same way as a text field that only indexes documents (index_options: docs) and
 * disables norms (norms: false). Term queries perform as fast if not faster as on text fields, however queries
 * that need positions such as the match_phrase query perform slower as they need to look at the _source document
 * to verify whether a phrase matches. All queries return constant scores that are equal to 1.0.
 */
export const types_mapping_match_only_text_property = z.object({
    type: z.enum(['match_only_text']),
    fields: z.record(types_mapping_property).describe('Multi-fields allow the same string value to be indexed in multiple ways for different purposes, such as one\nfield for search and a multi-field for sorting and aggregations, or the same string value analyzed by different analyzers.').optional(),
    meta: z.record(z.string()).describe('Metadata about the field.').optional(),
    copy_to: types_fields.optional()
}).describe('A variant of text that trades scoring and efficiency of positional queries for space efficiency. This field\neffectively stores data the same way as a text field that only indexes documents (index_options: docs) and\ndisables norms (norms: false). Term queries perform as fast if not faster as on text fields, however queries\nthat need positions such as the match_phrase query perform slower as they need to look at the _source document\nto verify whether a phrase matches. All queries return constant scores that are equal to 1.0.');

export const types_mapping_percolator_property = types_mapping_property_base.and(z.object({
    type: z.enum(['percolator'])
}));

export const types_mapping_rank_feature_property = types_mapping_property_base.and(z.object({
    positive_score_impact: z.boolean().optional(),
    type: z.enum(['rank_feature'])
}));

export const types_mapping_rank_features_property = types_mapping_property_base.and(z.object({
    positive_score_impact: z.boolean().optional(),
    type: z.enum(['rank_features'])
}));

export const types_mapping_search_as_you_type_property = types_mapping_core_property_base.and(z.object({
    analyzer: z.string().optional(),
    index: z.boolean().optional(),
    index_options: types_mapping_index_options.optional(),
    max_shingle_size: z.number().optional(),
    norms: z.boolean().optional(),
    search_analyzer: z.string().optional(),
    search_quote_analyzer: z.string().optional(),
    similarity: z.union([
        z.string(),
        z.null()
    ]).optional(),
    term_vector: types_mapping_term_vector_option.optional(),
    type: z.enum(['search_as_you_type'])
}));

export const types_mapping_text_property = types_mapping_core_property_base.and(z.object({
    analyzer: z.string().optional(),
    boost: z.number().optional(),
    eager_global_ordinals: z.boolean().optional(),
    fielddata: z.boolean().optional(),
    fielddata_frequency_filter: indices_types_fielddata_frequency_filter.optional(),
    index: z.boolean().optional(),
    index_options: types_mapping_index_options.optional(),
    index_phrases: z.boolean().optional(),
    index_prefixes: z.union([
        types_mapping_text_index_prefixes,
        z.string(),
        z.null()
    ]).optional(),
    norms: z.boolean().optional(),
    position_increment_gap: z.number().optional(),
    search_analyzer: z.string().optional(),
    search_quote_analyzer: z.string().optional(),
    similarity: z.union([
        z.string(),
        z.null()
    ]).optional(),
    term_vector: types_mapping_term_vector_option.optional(),
    type: z.enum(['text'])
}));

export const types_mapping_version_property = types_mapping_doc_values_property_base.and(z.object({
    type: z.enum(['version'])
}));

export const types_mapping_wildcard_property = types_mapping_doc_values_property_base.and(z.object({
    type: z.enum(['wildcard']),
    null_value: z.string().optional()
}));

export const types_mapping_date_nanos_property = types_mapping_doc_values_property_base.and(z.object({
    boost: z.number().optional(),
    format: z.string().optional(),
    ignore_malformed: z.boolean().optional(),
    index: z.boolean().optional(),
    script: types_script.optional(),
    on_script_error: types_mapping_on_script_error.optional(),
    null_value: types_date_time.optional(),
    precision_step: z.number().optional(),
    type: z.enum(['date_nanos'])
}));

export const types_mapping_date_property = types_mapping_doc_values_property_base.and(z.object({
    boost: z.number().optional(),
    fielddata: indices_types_numeric_fielddata.optional(),
    format: z.string().optional(),
    ignore_malformed: z.boolean().optional(),
    index: z.boolean().optional(),
    script: types_script.optional(),
    on_script_error: types_mapping_on_script_error.optional(),
    null_value: types_date_time.optional(),
    precision_step: z.number().optional(),
    locale: z.string().optional(),
    type: z.enum(['date'])
}));

export const types_mapping_aggregate_metric_double_property = types_mapping_property_base.and(z.object({
    type: z.enum(['aggregate_metric_double']),
    default_metric: z.string(),
    ignore_malformed: z.boolean().optional(),
    metrics: z.array(z.string()),
    time_series_metric: types_mapping_time_series_metric_type.optional()
}));

export const types_mapping_dense_vector_property = types_mapping_property_base.and(z.object({
    type: z.enum(['dense_vector']),
    dims: z.number().describe('Number of vector dimensions. Can\'t exceed `4096`. If `dims` is not specified, it will be set to the length of\nthe first vector added to the field.').optional(),
    element_type: types_mapping_dense_vector_element_type.optional(),
    index: z.boolean().describe('If `true`, you can search this field using the kNN search API.').optional().default(true),
    index_options: types_mapping_dense_vector_index_options.optional(),
    similarity: types_mapping_dense_vector_similarity.optional()
}));

export const types_mapping_flattened_property = types_mapping_property_base.and(z.object({
    boost: z.number().optional(),
    depth_limit: z.number().optional(),
    doc_values: z.boolean().optional(),
    eager_global_ordinals: z.boolean().optional(),
    index: z.boolean().optional(),
    index_options: types_mapping_index_options.optional(),
    null_value: z.string().optional(),
    similarity: z.string().optional(),
    split_queries_on_whitespace: z.boolean().optional(),
    time_series_dimensions: z.array(z.string()).optional(),
    type: z.enum(['flattened'])
}));

export const types_mapping_nested_property = types_mapping_core_property_base.and(z.object({
    enabled: z.boolean().optional(),
    include_in_parent: z.boolean().optional(),
    include_in_root: z.boolean().optional(),
    type: z.enum(['nested'])
}));

export const types_mapping_object_property = types_mapping_core_property_base.and(z.object({
    enabled: z.boolean().optional(),
    subobjects: types_mapping_subobjects.optional(),
    type: z.enum(['object']).optional()
}));

export const types_mapping_passthrough_object_property = types_mapping_core_property_base.and(z.object({
    type: z.enum(['passthrough']).optional(),
    enabled: z.boolean().optional(),
    priority: z.number().optional(),
    time_series_dimension: z.boolean().optional()
}));

/**
 * Technical preview
 */
export const types_mapping_rank_vector_property = types_mapping_property_base.and(z.object({
    type: z.enum(['rank_vectors']),
    element_type: types_mapping_rank_vector_element_type.optional(),
    dims: z.number().optional()
}));

export const types_mapping_semantic_text_property = z.object({
    type: z.enum(['semantic_text']),
    meta: z.record(z.string()).optional(),
    inference_id: types_id.optional(),
    search_inference_id: types_id.optional(),
    index_options: types_mapping_semantic_text_index_options.optional(),
    chunking_settings: z.union([
        types_mapping_chunking_settings,
        z.string(),
        z.null()
    ]).optional(),
    fields: z.record(types_mapping_property).describe('Multi-fields allow the same string value to be indexed in multiple ways for different purposes, such as one\nfield for search and a multi-field for sorting and aggregations, or the same string value analyzed by different analyzers.').optional()
});

export const types_mapping_sparse_vector_property = types_mapping_property_base.and(z.object({
    store: z.boolean().optional(),
    type: z.enum(['sparse_vector']),
    index_options: types_mapping_sparse_vector_index_options.optional()
}));

export const types_mapping_completion_property = types_mapping_doc_values_property_base.and(z.object({
    analyzer: z.string().optional(),
    contexts: z.array(types_mapping_suggest_context).optional(),
    max_input_length: z.number().optional(),
    preserve_position_increments: z.boolean().optional(),
    preserve_separators: z.boolean().optional(),
    search_analyzer: z.string().optional(),
    type: z.enum(['completion'])
}));

export const types_mapping_constant_keyword_property = types_mapping_property_base.and(z.object({
    value: z.record(z.unknown()).optional(),
    type: z.enum(['constant_keyword'])
}));

export const types_mapping_counted_keyword_property = types_mapping_property_base.and(z.object({
    type: z.enum(['counted_keyword']),
    index: z.boolean().optional()
}));

export const types_mapping_field_alias_property = types_mapping_property_base.and(z.object({
    path: types_field.optional(),
    type: z.enum(['alias'])
}));

export const types_mapping_histogram_property = types_mapping_property_base.and(z.object({
    ignore_malformed: z.boolean().optional(),
    type: z.enum(['histogram'])
}));

export const types_mapping_ip_property = types_mapping_doc_values_property_base.and(z.object({
    boost: z.number().optional(),
    index: z.boolean().optional(),
    ignore_malformed: z.boolean().optional(),
    null_value: z.string().optional(),
    on_script_error: types_mapping_on_script_error.optional(),
    script: types_script.optional(),
    time_series_dimension: z.boolean().describe('For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.').optional(),
    type: z.enum(['ip'])
}));

export const types_mapping_murmur3_hash_property = types_mapping_doc_values_property_base.and(z.object({
    type: z.enum(['murmur3'])
}));

export const types_mapping_token_count_property = types_mapping_doc_values_property_base.and(z.object({
    analyzer: z.string().optional(),
    boost: z.number().optional(),
    index: z.boolean().optional(),
    null_value: z.number().optional(),
    enable_position_increments: z.boolean().optional(),
    type: z.enum(['token_count'])
}));

export const types_mapping_geo_point_property = types_mapping_doc_values_property_base.and(z.object({
    ignore_malformed: z.boolean().optional(),
    ignore_z_value: z.boolean().optional(),
    null_value: types_geo_location.optional(),
    index: z.boolean().optional(),
    on_script_error: types_mapping_on_script_error.optional(),
    script: types_script.optional(),
    type: z.enum(['geo_point']),
    time_series_metric: types_mapping_geo_point_metric_type.optional()
}));

/**
 * The `geo_shape` data type facilitates the indexing of and searching with arbitrary geo shapes such as rectangles
 * and polygons.
 */
export const types_mapping_geo_shape_property = types_mapping_doc_values_property_base.and(z.object({
    coerce: z.boolean().optional(),
    ignore_malformed: z.boolean().optional(),
    ignore_z_value: z.boolean().optional(),
    index: z.boolean().optional(),
    orientation: types_mapping_geo_orientation.optional(),
    strategy: types_mapping_geo_strategy.optional(),
    type: z.enum(['geo_shape'])
}));

export const types_mapping_point_property = types_mapping_doc_values_property_base.and(z.object({
    ignore_malformed: z.boolean().optional(),
    ignore_z_value: z.boolean().optional(),
    null_value: z.string().optional(),
    type: z.enum(['point'])
}));

/**
 * The `shape` data type facilitates the indexing of and searching with arbitrary `x, y` cartesian shapes such as
 * rectangles and polygons.
 */
export const types_mapping_shape_property = types_mapping_doc_values_property_base.and(z.object({
    coerce: z.boolean().optional(),
    ignore_malformed: z.boolean().optional(),
    ignore_z_value: z.boolean().optional(),
    orientation: types_mapping_geo_orientation.optional(),
    type: z.enum(['shape'])
}));

export const types_mapping_byte_number_property: z.ZodTypeAny = z.lazy(() => types_mapping_number_property_base).and(z.object({
    type: z.enum(['byte']),
    null_value: types_byte.optional()
}));

export const types_mapping_number_property_base = types_mapping_doc_values_property_base.and(z.object({
    boost: z.number().optional(),
    coerce: z.boolean().optional(),
    ignore_malformed: z.boolean().optional(),
    index: z.boolean().optional(),
    on_script_error: types_mapping_on_script_error.optional(),
    script: types_script.optional(),
    time_series_metric: types_mapping_time_series_metric_type.optional(),
    time_series_dimension: z.boolean().describe('For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.').optional().default(false)
}));

export const types_mapping_double_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['double']),
    null_value: z.number().optional()
}));

export const types_mapping_float_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['float']),
    null_value: z.number().optional()
}));

export const types_mapping_half_float_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['half_float']),
    null_value: z.number().optional()
}));

export const types_mapping_integer_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['integer']),
    null_value: z.number().optional()
}));

export const types_mapping_long_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['long']),
    null_value: z.number().optional()
}));

export const types_mapping_scaled_float_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['scaled_float']),
    null_value: z.number().optional(),
    scaling_factor: z.number().optional()
}));

export const types_mapping_short_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['short']),
    null_value: types_short.optional()
}));

export const types_mapping_unsigned_long_number_property = types_mapping_number_property_base.and(z.object({
    type: z.enum(['unsigned_long']),
    null_value: types_ulong.optional()
}));

export const types_mapping_date_range_property: z.ZodTypeAny = z.lazy(() => types_mapping_range_property_base).and(z.object({
    format: z.string().optional(),
    type: z.enum(['date_range'])
}));

export const types_mapping_range_property_base = types_mapping_doc_values_property_base.and(z.object({
    boost: z.number().optional(),
    coerce: z.boolean().optional(),
    index: z.boolean().optional()
}));

export const types_mapping_double_range_property = types_mapping_range_property_base.and(z.object({
    type: z.enum(['double_range'])
}));

export const types_mapping_float_range_property = types_mapping_range_property_base.and(z.object({
    type: z.enum(['float_range'])
}));

export const types_mapping_integer_range_property = types_mapping_range_property_base.and(z.object({
    type: z.enum(['integer_range'])
}));

export const types_mapping_ip_range_property = types_mapping_range_property_base.and(z.object({
    type: z.enum(['ip_range'])
}));

export const types_mapping_long_range_property = types_mapping_range_property_base.and(z.object({
    type: z.enum(['long_range'])
}));

export const types_mapping_icu_collation_property = types_mapping_doc_values_property_base.and(z.object({
    type: z.enum(['icu_collation_keyword']),
    norms: z.boolean().optional(),
    index_options: types_mapping_index_options.optional(),
    index: z.boolean().describe('Should the field be searchable?').optional(),
    null_value: z.string().describe('Accepts a string value which is substituted for any explicit null values. Defaults to null, which means the field is treated as missing.').optional(),
    rules: z.string().optional(),
    language: z.string().optional(),
    country: z.string().optional(),
    variant: z.string().optional(),
    strength: types_analysis_icu_collation_strength.optional(),
    decomposition: types_analysis_icu_collation_decomposition.optional(),
    alternate: types_analysis_icu_collation_alternate.optional(),
    case_level: z.boolean().optional(),
    case_first: types_analysis_icu_collation_case_first.optional(),
    numeric: z.boolean().optional(),
    variable_top: z.string().optional(),
    hiragana_quaternary_mode: z.boolean().optional()
}));

export const indices_types_alias_definition = z.object({
    filter: types_query_dsl_query_container.optional(),
    index_routing: z.string().describe('Value used to route indexing operations to a specific shard.\nIf specified, this overwrites the `routing` value for indexing operations.').optional(),
    is_write_index: z.boolean().describe('If `true`, the index is the write index for the alias.').optional().default(false),
    routing: z.string().describe('Value used to route indexing and search operations to a specific shard.').optional(),
    search_routing: z.string().describe('Value used to route search operations to a specific shard.\nIf specified, this overwrites the `routing` value for search operations.').optional(),
    is_hidden: z.boolean().describe('If `true`, the alias is hidden.\nAll indices for the alias must have the same `is_hidden` value.').optional().default(false)
});

export const indices_types_index_state: z.AnyZodObject = z.object({
    aliases: z.record(z.lazy(() => indices_types_alias)).optional(),
    mappings: types_mapping_type_mapping.optional(),
    settings: indices_types_index_settings.optional(),
    defaults: indices_types_index_settings.optional(),
    data_stream: types_data_stream_name.optional(),
    lifecycle: indices_types_data_stream_lifecycle.optional()
});

export const indices_types_alias = z.object({
    filter: types_query_dsl_query_container.optional(),
    index_routing: types_routing.optional(),
    is_hidden: z.boolean().describe('If `true`, the alias is hidden.\nAll indices for the alias must have the same `is_hidden` value.').optional().default(false),
    is_write_index: z.boolean().describe('If `true`, the index is the write index for the alias.').optional().default(false),
    routing: types_routing.optional(),
    search_routing: types_routing.optional()
});

export const enrich_types_summary: z.AnyZodObject = z.object({
    config: z.record(z.lazy(() => enrich_types_policy))
});

export const enrich_types_policy = z.object({
    enrich_fields: types_fields,
    indices: types_indices,
    match_field: types_field,
    query: types_query_dsl_query_container.optional(),
    name: types_name.optional(),
    elasticsearch_version: z.string().optional()
});

export const global_msearch_request_item = z.union([
    global_msearch_multisearch_header,
    global_search_types_search_request_body
]);

export const global_msearch_response_item: z.ZodTypeAny = z.union([
    z.lazy(() => global_msearch_multi_search_item),
    types_error_response_base
]);

export const global_msearch_multi_search_item: z.ZodTypeAny = z.lazy(() => global_search_response_body).and(z.object({
    status: z.number().optional()
}));

export const global_search_response_body = z.object({
    took: z.number().describe('The number of milliseconds it took Elasticsearch to run the request.\nThis value is calculated by measuring the time elapsed between receipt of a request on the coordinating node and the time at which the coordinating node is ready to send the response.\nIt includes:\n\n* Communication time between the coordinating node and data nodes\n* Time the request spends in the search thread pool, queued for execution\n* Actual run time\n\nIt does not include:\n\n* Time needed to send the request to Elasticsearch\n* Time needed to serialize the JSON response\n* Time needed to send the response to a client'),
    timed_out: z.boolean().describe('If `true`, the request timed out before completion; returned results may be partial or empty.'),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.record(types_aggregations_aggregate).optional(),
    _clusters: types_cluster_statistics.optional(),
    fields: z.record(z.record(z.unknown())).optional(),
    max_score: z.number().optional(),
    num_reduce_phases: z.number().optional(),
    profile: global_search_types_profile.optional(),
    pit_id: types_id.optional(),
    _scroll_id: types_scroll_id.optional(),
    suggest: z.record(z.array(global_search_types_suggest)).optional(),
    terminated_early: z.boolean().optional()
});

export const types_stored_script = z.object({
    lang: types_script_language,
    options: z.record(z.string()).optional(),
    source: types_script_source
});

export const graph_types_hop: z.AnyZodObject = z.object({
    connections: z.lazy(() => graph_types_hop).optional(),
    query: types_query_dsl_query_container.optional(),
    vertices: z.array(graph_types_vertex_definition).describe('Contains the fields you are interested in.')
});

export const indices_create_from_create_from = z.object({
    mappings_override: types_mapping_type_mapping.optional(),
    settings_override: indices_types_index_settings.optional(),
    remove_index_blocks: z.boolean().describe('If index blocks should be removed when creating destination index (optional)').optional().default(true)
});

export const indices_get_alias_types_index_aliases = z.object({
    aliases: z.record(indices_types_alias_definition)
});

export const indices_types_data_stream = z.object({
    _meta: types_metadata.optional(),
    allow_custom_routing: z.boolean().describe('If `true`, the data stream allows custom routing on write request.').optional(),
    failure_store: indices_types_failure_store.optional(),
    generation: z.number().describe('Current generation for the data stream. This number acts as a cumulative count of the streams rollovers, starting at 1.'),
    hidden: z.boolean().describe('If `true`, the data stream is hidden.'),
    ilm_policy: types_name.optional(),
    next_generation_managed_by: indices_types_managed_by,
    prefer_ilm: z.boolean().describe('Indicates if ILM should take precedence over DSL in case both are configured to managed this data stream.'),
    indices: z.array(indices_types_data_stream_index).describe('Array of objects containing information about the data streams backing indices.\nThe last item in this array contains information about the streams current write index.'),
    lifecycle: indices_types_data_stream_lifecycle_with_rollover.optional(),
    name: types_data_stream_name,
    replicated: z.boolean().describe('If `true`, the data stream is created and managed by cross-cluster replication and the local cluster can not write into this data stream or change its mappings.').optional(),
    rollover_on_write: z.boolean().describe('If `true`, the next write to this data stream will trigger a rollover first and the document will be indexed in the new backing index. If the rollover fails the indexing request will fail too.'),
    settings: indices_types_index_settings,
    mappings: types_mapping_type_mapping.optional(),
    status: types_health_status,
    system: z.boolean().describe('If `true`, the data stream is created and managed by an Elastic stack component and cannot be modified through normal user interaction.').optional(),
    template: types_name,
    timestamp_field: indices_types_data_stream_timestamp_field,
    index_mode: indices_types_index_mode.optional()
});

export const indices_get_data_stream_mappings_data_stream_mappings = z.object({
    name: z.string().describe('The name of the data stream.'),
    mappings: types_mapping_type_mapping,
    effective_mappings: types_mapping_type_mapping
});

export const indices_get_data_stream_settings_data_stream_settings = z.object({
    name: z.string().describe('The name of the data stream.'),
    settings: indices_types_index_settings,
    effective_settings: indices_types_index_settings
});

export const indices_get_field_mapping_type_field_mappings: z.AnyZodObject = z.object({
    mappings: z.record(z.lazy(() => types_mapping_field_mapping))
});

export const types_mapping_field_mapping = z.object({
    full_name: z.string(),
    mapping: z.record(types_mapping_property)
});

export const indices_get_index_template_index_template_item: z.AnyZodObject = z.object({
    name: types_name,
    index_template: z.lazy(() => indices_types_index_template)
});

export const indices_types_index_template: z.AnyZodObject = z.object({
    index_patterns: types_names,
    composed_of: z.array(types_name).describe('An ordered list of component template names.\nComponent templates are merged in the order specified, meaning that the last component template specified has the highest precedence.'),
    template: z.lazy(() => indices_types_index_template_summary).optional(),
    version: types_version_number.optional(),
    priority: z.number().describe('Priority to determine index template precedence when a new data stream or index is created.\nThe index template with the highest priority is chosen.\nIf no priority is specified the template is treated as though it is of priority 0 (lowest priority).\nThis number is not automatically generated by Elasticsearch.').optional(),
    _meta: types_metadata.optional(),
    allow_auto_create: z.boolean().optional(),
    data_stream: indices_types_index_template_data_stream_configuration.optional(),
    deprecated: z.boolean().describe('Marks this index template as deprecated.\nWhen creating or updating a non-deprecated index template that uses deprecated components,\nElasticsearch will emit a deprecation warning.').optional(),
    ignore_missing_component_templates: types_names.optional(),
    created_date: types_date_time.optional(),
    created_date_millis: types_epoch_time_unit_millis.optional(),
    modified_date: types_date_time.optional(),
    modified_date_millis: types_epoch_time_unit_millis.optional()
});

export const indices_types_index_template_summary = z.object({
    aliases: z.record(indices_types_alias).describe('Aliases to add.\nIf the index template includes a `data_stream` object, these are data stream aliases.\nOtherwise, these are index aliases.\nData stream aliases ignore the `index_routing`, `routing`, and `search_routing` options.').optional(),
    mappings: types_mapping_type_mapping.optional(),
    settings: indices_types_index_settings.optional(),
    lifecycle: indices_types_data_stream_lifecycle_with_rollover.optional(),
    data_stream_options: z.union([
        indices_types_data_stream_options_template,
        z.string(),
        z.null()
    ]).optional()
});

export const indices_get_mapping_index_mapping_record = z.object({
    item: types_mapping_type_mapping.optional(),
    mappings: types_mapping_type_mapping
});

export const indices_types_template_mapping = z.object({
    aliases: z.record(indices_types_alias),
    index_patterns: z.array(types_name),
    mappings: types_mapping_type_mapping,
    order: z.number(),
    settings: z.record(z.record(z.unknown())),
    version: types_version_number.optional()
});

export const indices_put_data_stream_mappings_updated_data_stream_mappings = z.object({
    name: types_index_name,
    applied_to_data_stream: z.boolean().describe('If the mappings were successfully applied to the data stream (or would have been, if running in `dry_run`\nmode), it is `true`. If an error occurred, it is `false`.'),
    error: z.string().describe('A message explaining why the mappings could not be applied to the data stream.').optional(),
    mappings: types_mapping_type_mapping.optional(),
    effective_mappings: types_mapping_type_mapping.optional()
});

export const indices_put_data_stream_settings_updated_data_stream_settings = z.object({
    name: types_index_name,
    applied_to_data_stream: z.boolean().describe('If the settings were successfully applied to the data stream (or would have been, if running in `dry_run`\nmode), it is `true`. If an error occurred, it is `false`.'),
    error: z.string().describe('A message explaining why the settings could not be applied to the data stream.').optional(),
    settings: indices_types_index_settings,
    effective_settings: indices_types_index_settings,
    index_settings_results: indices_put_data_stream_settings_index_setting_results
});

export const indices_put_index_template_index_template_mapping = z.object({
    aliases: z.record(indices_types_alias).describe('Aliases to add.\nIf the index template includes a `data_stream` object, these are data stream aliases.\nOtherwise, these are index aliases.\nData stream aliases ignore the `index_routing`, `routing`, and `search_routing` options.').optional(),
    mappings: types_mapping_type_mapping.optional(),
    settings: indices_types_index_settings.optional(),
    lifecycle: indices_types_data_stream_lifecycle.optional()
});

export const indices_simulate_template_template = z.object({
    aliases: z.record(indices_types_alias),
    mappings: types_mapping_type_mapping,
    settings: indices_types_index_settings
});

export const indices_stats_indices_stats: z.AnyZodObject = z.object({
    primaries: z.lazy(() => indices_stats_index_stats).optional(),
    shards: z.record(z.array(z.lazy(() => indices_stats_shard_stats))).optional(),
    total: z.lazy(() => indices_stats_index_stats).optional(),
    uuid: types_uuid.optional(),
    health: types_health_status.optional(),
    status: indices_stats_index_metadata_state.optional()
});

export const indices_stats_index_stats = z.object({
    completion: types_completion_stats.optional(),
    docs: types_doc_stats.optional(),
    fielddata: types_fielddata_stats.optional(),
    flush: types_flush_stats.optional(),
    get: types_get_stats.optional(),
    indexing: types_indexing_stats.optional(),
    indices: indices_stats_indices_stats.optional(),
    merges: types_merges_stats.optional(),
    query_cache: types_query_cache_stats.optional(),
    recovery: types_recovery_stats.optional(),
    refresh: types_refresh_stats.optional(),
    request_cache: types_request_cache_stats.optional(),
    search: types_search_stats.optional(),
    segments: types_segments_stats.optional(),
    store: types_store_stats.optional(),
    translog: types_translog_stats.optional(),
    warmer: types_warmer_stats.optional(),
    bulk: types_bulk_stats.optional(),
    shard_stats: indices_stats_shards_total_stats.optional()
});

export const indices_stats_shard_stats = z.object({
    commit: indices_stats_shard_commit.optional(),
    completion: types_completion_stats.optional(),
    docs: types_doc_stats.optional(),
    fielddata: types_fielddata_stats.optional(),
    flush: types_flush_stats.optional(),
    get: types_get_stats.optional(),
    indexing: types_indexing_stats.optional(),
    mappings: indices_stats_mapping_stats.optional(),
    merges: types_merges_stats.optional(),
    shard_path: indices_stats_shard_path.optional(),
    query_cache: indices_stats_shard_query_cache.optional(),
    recovery: types_recovery_stats.optional(),
    refresh: types_refresh_stats.optional(),
    request_cache: types_request_cache_stats.optional(),
    retention_leases: indices_stats_shard_retention_leases.optional(),
    routing: indices_stats_shard_routing.optional(),
    search: types_search_stats.optional(),
    segments: types_segments_stats.optional(),
    seq_no: indices_stats_shard_sequence_number.optional(),
    store: types_store_stats.optional(),
    translog: types_translog_stats.optional(),
    warmer: types_warmer_stats.optional(),
    bulk: types_bulk_stats.optional(),
    shards: z.record(z.record(z.unknown())).optional(),
    shard_stats: indices_stats_shards_total_stats.optional(),
    indices: indices_stats_indices_stats.optional()
});

export const indices_update_aliases_action: z.AnyZodObject = z.object({
    add: z.lazy(() => indices_update_aliases_add_action).optional(),
    remove: indices_update_aliases_remove_action.optional(),
    remove_index: indices_update_aliases_remove_index_action.optional()
});

export const indices_update_aliases_add_action = z.object({
    alias: types_index_alias.optional(),
    aliases: z.union([
        types_index_alias,
        z.array(types_index_alias)
    ]).optional(),
    filter: types_query_dsl_query_container.optional(),
    index: types_index_name.optional(),
    indices: types_indices.optional(),
    index_routing: types_routing.optional(),
    is_hidden: z.boolean().describe('If `true`, the alias is hidden.').optional().default(false),
    is_write_index: z.boolean().describe('If `true`, sets the write index or data stream for the alias.').optional(),
    routing: types_routing.optional(),
    search_routing: types_routing.optional(),
    must_exist: z.boolean().describe('If `true`, the alias must exist to perform the action.').optional().default(false)
});

export const ingest_types_pipeline: z.AnyZodObject = z.object({
    description: z.string().describe('Description of the ingest pipeline.').optional(),
    on_failure: z.array(z.lazy(() => ingest_types_processor_container)).describe('Processors to run immediately after a processor failure.').optional(),
    processors: z.array(z.lazy(() => ingest_types_processor_container)).describe('Processors used to perform transformations on documents before indexing.\nProcessors run sequentially in the order specified.').optional(),
    version: types_version_number.optional(),
    deprecated: z.boolean().describe('Marks this ingest pipeline as deprecated.\nWhen a deprecated ingest pipeline is referenced as the default or final pipeline when creating or updating a non-deprecated index template, Elasticsearch will emit a deprecation warning.').optional().default(false),
    _meta: types_metadata.optional(),
    created_date: types_date_time.optional(),
    created_date_millis: types_epoch_time_unit_millis.optional(),
    modified_date: types_date_time.optional(),
    modified_date_millis: types_epoch_time_unit_millis.optional(),
    field_access_pattern: ingest_types_field_access_pattern.optional()
});

export const ingest_types_processor_container: z.AnyZodObject = z.object({
    append: z.lazy(() => ingest_types_append_processor).optional(),
    attachment: z.lazy(() => ingest_types_attachment_processor).optional(),
    bytes: z.lazy(() => ingest_types_bytes_processor).optional(),
    circle: z.lazy(() => ingest_types_circle_processor).optional(),
    community_id: z.lazy(() => ingest_types_community_id_processor).optional(),
    convert: z.lazy(() => ingest_types_convert_processor).optional(),
    csv: z.lazy(() => ingest_types_csv_processor).optional(),
    date: z.lazy(() => ingest_types_date_processor).optional(),
    date_index_name: z.lazy(() => ingest_types_date_index_name_processor).optional(),
    dissect: z.lazy(() => ingest_types_dissect_processor).optional(),
    dot_expander: z.lazy(() => ingest_types_dot_expander_processor).optional(),
    drop: z.lazy(() => ingest_types_drop_processor).optional(),
    enrich: z.lazy(() => ingest_types_enrich_processor).optional(),
    fail: z.lazy(() => ingest_types_fail_processor).optional(),
    fingerprint: z.lazy(() => ingest_types_fingerprint_processor).optional(),
    foreach: z.lazy(() => ingest_types_foreach_processor).optional(),
    ip_location: z.lazy(() => ingest_types_ip_location_processor).optional(),
    geo_grid: z.lazy(() => ingest_types_geo_grid_processor).optional(),
    geoip: z.lazy(() => ingest_types_geo_ip_processor).optional(),
    grok: z.lazy(() => ingest_types_grok_processor).optional(),
    gsub: z.lazy(() => ingest_types_gsub_processor).optional(),
    html_strip: z.lazy(() => ingest_types_html_strip_processor).optional(),
    inference: z.lazy(() => ingest_types_inference_processor).optional(),
    join: z.lazy(() => ingest_types_join_processor).optional(),
    json: z.lazy(() => ingest_types_json_processor).optional(),
    kv: z.lazy(() => ingest_types_key_value_processor).optional(),
    lowercase: z.lazy(() => ingest_types_lowercase_processor).optional(),
    network_direction: z.lazy(() => ingest_types_network_direction_processor).optional(),
    pipeline: z.lazy(() => ingest_types_pipeline_processor).optional(),
    redact: z.lazy(() => ingest_types_redact_processor).optional(),
    registered_domain: z.lazy(() => ingest_types_registered_domain_processor).optional(),
    remove: z.lazy(() => ingest_types_remove_processor).optional(),
    rename: z.lazy(() => ingest_types_rename_processor).optional(),
    reroute: z.lazy(() => ingest_types_reroute_processor).optional(),
    script: z.lazy(() => ingest_types_script_processor).optional(),
    set: z.lazy(() => ingest_types_set_processor).optional(),
    set_security_user: z.lazy(() => ingest_types_set_security_user_processor).optional(),
    sort: z.lazy(() => ingest_types_sort_processor).optional(),
    split: z.lazy(() => ingest_types_split_processor).optional(),
    terminate: z.lazy(() => ingest_types_terminate_processor).optional(),
    trim: z.lazy(() => ingest_types_trim_processor).optional(),
    uppercase: z.lazy(() => ingest_types_uppercase_processor).optional(),
    urldecode: z.lazy(() => ingest_types_url_decode_processor).optional(),
    uri_parts: z.lazy(() => ingest_types_uri_parts_processor).optional(),
    user_agent: z.lazy(() => ingest_types_user_agent_processor).optional()
});

export const ingest_types_append_processor: z.ZodTypeAny = z.lazy(() => ingest_types_processor_base).and(z.object({
    field: types_field,
    value: z.union([
        z.record(z.unknown()),
        z.array(z.record(z.unknown()))
    ]).optional(),
    copy_from: types_field.optional(),
    allow_duplicates: z.boolean().describe('If `false`, the processor does not append values already present in the field.').optional().default(true)
}));

export const ingest_types_processor_base = z.object({
    description: z.string().describe('Description of the processor.\nUseful for describing the purpose of the processor or its configuration.').optional(),
    if: types_script.optional(),
    ignore_failure: z.boolean().describe('Ignore failures for the processor.').optional(),
    on_failure: z.array(ingest_types_processor_container).describe('Handle failures for the processor.').optional(),
    tag: z.string().describe('Identifier for the processor.\nUseful for debugging and metrics.').optional()
});

export const ingest_types_attachment_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and field does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    indexed_chars: z.number().describe('The number of chars being used for extraction to prevent huge fields.\nUse `-1` for no limit.').optional().default(100000),
    indexed_chars_field: types_field.optional(),
    properties: z.array(z.string()).describe('Array of properties to select to be stored.\nCan be `content`, `title`, `name`, `author`, `keywords`, `date`, `content_type`, `content_length`, `language`.').optional(),
    target_field: types_field.optional(),
    remove_binary: z.boolean().describe('If true, the binary field will be removed from the document').optional().default(false),
    resource_name: z.string().describe('Field containing the name of the resource to decode.\nIf specified, the processor passes this resource name to the underlying Tika library to enable Resource Name Based Detection.').optional()
}));

export const ingest_types_bytes_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false),
    target_field: types_field.optional()
}));

export const ingest_types_circle_processor = ingest_types_processor_base.and(z.object({
    error_distance: z.number().describe('The difference between the resulting inscribed distance from center to side and the circles radius (measured in meters for `geo_shape`, unit-less for `shape`).'),
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    shape_type: ingest_types_shape_type,
    target_field: types_field.optional()
}));

export const ingest_types_community_id_processor = ingest_types_processor_base.and(z.object({
    source_ip: types_field.optional(),
    source_port: types_field.optional(),
    destination_ip: types_field.optional(),
    destination_port: types_field.optional(),
    iana_number: types_field.optional(),
    icmp_type: types_field.optional(),
    icmp_code: types_field.optional(),
    transport: types_field.optional(),
    target_field: types_field.optional(),
    seed: z.number().describe('Seed for the community ID hash. Must be between 0 and 65535 (inclusive). The\nseed can prevent hash collisions between network domains, such as a staging\nand production network that use the same addressing scheme.').optional().default(0),
    ignore_missing: z.boolean().describe('If true and any required fields are missing, the processor quietly exits\nwithout modifying the document.').optional().default(true)
}));

export const ingest_types_convert_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false),
    target_field: types_field.optional(),
    type: ingest_types_convert_type
}));

export const ingest_types_csv_processor = ingest_types_processor_base.and(z.object({
    empty_value: z.record(z.unknown()).describe('Value used to fill empty fields.\nEmpty fields are skipped if this is not provided.\nAn empty field is one with no value (2 consecutive separators) or empty quotes (`""`).').optional(),
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional(),
    quote: z.string().describe('Quote used in CSV, has to be single character string.').optional().default('"'),
    separator: z.string().describe('Separator used in CSV, has to be single character string.').optional().default(','),
    target_fields: types_fields,
    trim: z.boolean().describe('Trim whitespaces in unquoted fields.').optional()
}));

export const ingest_types_date_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    formats: z.array(z.string()).describe('An array of the expected date formats.\nCan be a java time pattern or one of the following formats: ISO8601, UNIX, UNIX_MS, or TAI64N.'),
    locale: z.string().describe('The locale to use when parsing the date, relevant when parsing month names or week days.\nSupports template snippets.').optional().default('ENGLISH'),
    target_field: types_field.optional(),
    timezone: z.string().describe('The timezone to use when parsing the date.\nSupports template snippets.').optional().default('UTC'),
    output_format: z.string().describe('The format to use when writing the date to target_field. Must be a valid\njava time pattern.').optional().default('yyyy-MM-dd\'T\'HH:mm:ss.SSSXXX')
}));

export const ingest_types_date_index_name_processor = ingest_types_processor_base.and(z.object({
    date_formats: z.array(z.string()).describe('An array of the expected date formats for parsing dates / timestamps in the document being preprocessed.\nCan be a java time pattern or one of the following formats: ISO8601, UNIX, UNIX_MS, or TAI64N.').optional(),
    date_rounding: z.string().describe('How to round the date when formatting the date into the index name. Valid values are:\n`y` (year), `M` (month), `w` (week), `d` (day), `h` (hour), `m` (minute) and `s` (second).\nSupports template snippets.'),
    field: types_field,
    index_name_format: z.string().describe('The format to be used when printing the parsed date into the index name.\nA valid java time pattern is expected here.\nSupports template snippets.').optional().default('yyyy-MM-dd'),
    index_name_prefix: z.string().describe('A prefix of the index name to be prepended before the printed date.\nSupports template snippets.').optional(),
    locale: z.string().describe('The locale to use when parsing the date from the document being preprocessed, relevant when parsing month names or week days.').optional().default('ENGLISH'),
    timezone: z.string().describe('The timezone to use when parsing the date and when date math index supports resolves expressions into concrete index names.').optional().default('UTC')
}));

export const ingest_types_dissect_processor = ingest_types_processor_base.and(z.object({
    append_separator: z.string().describe('The character(s) that separate the appended fields.').optional().default('""'),
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false),
    pattern: z.string().describe('The pattern to apply to the field.')
}));

export const ingest_types_dot_expander_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    override: z.boolean().describe('Controls the behavior when there is already an existing nested object that conflicts with the expanded field.\nWhen `false`, the processor will merge conflicts by combining the old and the new values into an array.\nWhen `true`, the value from the expanded field will overwrite the existing value.').optional().default(false),
    path: z.string().describe('The field that contains the field to expand.\nOnly required if the field to expand is part another object field, because the `field` option can only understand leaf fields.').optional()
}));

export const ingest_types_drop_processor = ingest_types_processor_base.and(z.record(z.unknown()));

export const ingest_types_enrich_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    max_matches: z.number().describe('The maximum number of matched documents to include under the configured target field.\nThe `target_field` will be turned into a json array if `max_matches` is higher than 1, otherwise `target_field` will become a json object.\nIn order to avoid documents getting too large, the maximum allowed value is 128.').optional().default(1),
    override: z.boolean().describe('If processor will update fields with pre-existing non-null-valued field.\nWhen set to `false`, such fields will not be touched.').optional().default(true),
    policy_name: z.string().describe('The name of the enrich policy to use.'),
    shape_relation: types_geo_shape_relation.optional(),
    target_field: types_field
}));

export const ingest_types_fail_processor = ingest_types_processor_base.and(z.object({
    message: z.string().describe('The error message thrown by the processor.\nSupports template snippets.')
}));

export const ingest_types_fingerprint_processor = ingest_types_processor_base.and(z.object({
    fields: types_fields,
    target_field: types_field.optional(),
    salt: z.string().describe('Salt value for the hash function.').optional(),
    method: ingest_types_fingerprint_digest.optional(),
    ignore_missing: z.boolean().describe('If true, the processor ignores any missing fields. If all fields are\nmissing, the processor silently exits without modifying the document.').optional().default(false)
}));

export const ingest_types_foreach_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true`, the processor silently exits without changing the document if the `field` is `null` or missing.').optional().default(false),
    processor: ingest_types_processor_container
}));

export const ingest_types_ip_location_processor = ingest_types_processor_base.and(z.object({
    database_file: z.string().describe('The database filename referring to a database the module ships with (GeoLite2-City.mmdb, GeoLite2-Country.mmdb, or GeoLite2-ASN.mmdb) or a custom database in the ingest-geoip config directory.').optional().default('GeoLite2-City.mmdb'),
    field: types_field,
    first_only: z.boolean().describe('If `true`, only the first found IP location data will be returned, even if the field contains an array.').optional().default(true),
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    properties: z.array(z.string()).describe('Controls what properties are added to the `target_field` based on the IP location lookup.').optional(),
    target_field: types_field.optional(),
    download_database_on_pipeline_creation: z.boolean().describe('If `true` (and if `ingest.geoip.downloader.eager.download` is `false`), the missing database is downloaded when the pipeline is created.\nElse, the download is triggered by when the pipeline is used as the `default_pipeline` or `final_pipeline` in an index.').optional()
}));

export const ingest_types_geo_grid_processor = ingest_types_processor_base.and(z.object({
    field: z.string().describe('The field to interpret as a geo-tile.=\nThe field format is determined by the `tile_type`.'),
    tile_type: ingest_types_geo_grid_tile_type,
    target_field: types_field.optional(),
    parent_field: types_field.optional(),
    children_field: types_field.optional(),
    non_children_field: types_field.optional(),
    precision_field: types_field.optional(),
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    target_format: ingest_types_geo_grid_target_format.optional()
}));

export const ingest_types_geo_ip_processor = ingest_types_processor_base.and(z.object({
    database_file: z.string().describe('The database filename referring to a database the module ships with (GeoLite2-City.mmdb, GeoLite2-Country.mmdb, or GeoLite2-ASN.mmdb) or a custom database in the ingest-geoip config directory.').optional().default('GeoLite2-City.mmdb'),
    field: types_field,
    first_only: z.boolean().describe('If `true`, only the first found geoip data will be returned, even if the field contains an array.').optional().default(true),
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    properties: z.array(z.string()).describe('Controls what properties are added to the `target_field` based on the geoip lookup.').optional(),
    target_field: types_field.optional(),
    download_database_on_pipeline_creation: z.boolean().describe('If `true` (and if `ingest.geoip.downloader.eager.download` is `false`), the missing database is downloaded when the pipeline is created.\nElse, the download is triggered by when the pipeline is used as the `default_pipeline` or `final_pipeline` in an index.').optional()
}));

export const ingest_types_grok_processor = ingest_types_processor_base.and(z.object({
    ecs_compatibility: z.string().describe('Must be disabled or v1. If v1, the processor uses patterns with Elastic\nCommon Schema (ECS) field names.').optional().default('disabled'),
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false),
    pattern_definitions: z.record(z.string()).describe('A map of pattern-name and pattern tuples defining custom patterns to be used by the current processor.\nPatterns matching existing names will override the pre-existing definition.').optional(),
    patterns: z.array(types_grok_pattern).describe('An ordered list of grok expression to match and extract named captures with.\nReturns on the first expression in the list that matches.'),
    trace_match: z.boolean().describe('When `true`, `_ingest._grok_match_index` will be inserted into your matched documents metadata with the index into the pattern found in `patterns` that matched.').optional().default(false)
}));

export const ingest_types_gsub_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false),
    pattern: z.string().describe('The pattern to be replaced.'),
    replacement: z.string().describe('The string to replace the matching patterns with.'),
    target_field: types_field.optional()
}));

export const ingest_types_html_strip_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document,').optional().default(false),
    target_field: types_field.optional()
}));

export const ingest_types_inference_processor = ingest_types_processor_base.and(z.object({
    model_id: types_id,
    target_field: types_field.optional(),
    field_map: z.record(z.record(z.unknown())).describe('Maps the document field names to the known field names of the model.\nThis mapping takes precedence over any default mappings provided in the model configuration.').optional(),
    inference_config: ingest_types_inference_config.optional(),
    input_output: z.union([
        ingest_types_input_config,
        z.array(ingest_types_input_config)
    ]).optional(),
    ignore_missing: z.boolean().describe('If true and any of the input fields defined in input_ouput are missing\nthen those missing fields are quietly ignored, otherwise a missing field causes a failure.\nOnly applies when using input_output configurations to explicitly list the input fields.').optional()
}));

export const ingest_types_join_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    separator: z.string().describe('The separator character.'),
    target_field: types_field.optional()
}));

export const ingest_types_json_processor = ingest_types_processor_base.and(z.object({
    add_to_root: z.boolean().describe('Flag that forces the parsed JSON to be added at the top level of the document.\n`target_field` must not be set when this option is chosen.').optional().default(false),
    add_to_root_conflict_strategy: ingest_types_json_processor_conflict_strategy.optional(),
    allow_duplicate_keys: z.boolean().describe('When set to `true`, the JSON parser will not fail if the JSON contains duplicate keys.\nInstead, the last encountered value for any duplicate key wins.').optional().default(false),
    field: types_field,
    target_field: types_field.optional()
}));

export const ingest_types_key_value_processor = ingest_types_processor_base.and(z.object({
    exclude_keys: z.array(z.string()).describe('List of keys to exclude from document.').optional(),
    field: types_field,
    field_split: z.string().describe('Regex pattern to use for splitting key-value pairs.'),
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false),
    include_keys: z.array(z.string()).describe('List of keys to filter and insert into document.\nDefaults to including all keys.').optional(),
    prefix: z.string().describe('Prefix to be added to extracted keys.').optional().default('null'),
    strip_brackets: z.boolean().describe('If `true`. strip brackets `()`, `<>`, `[]` as well as quotes `\'` and `"` from extracted values.').optional().default(false),
    target_field: types_field.optional(),
    trim_key: z.string().describe('String of characters to trim from extracted keys.').optional(),
    trim_value: z.string().describe('String of characters to trim from extracted values.').optional(),
    value_split: z.string().describe('Regex pattern to use for splitting the key from the value within a key-value pair.')
}));

export const ingest_types_lowercase_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false),
    target_field: types_field.optional()
}));

export const ingest_types_network_direction_processor = ingest_types_processor_base.and(z.object({
    source_ip: types_field.optional(),
    destination_ip: types_field.optional(),
    target_field: types_field.optional(),
    internal_networks: z.array(z.string()).describe('List of internal networks. Supports IPv4 and IPv6 addresses and ranges in\nCIDR notation. Also supports the named ranges listed below. These may be\nconstructed with template snippets. Must specify only one of\ninternal_networks or internal_networks_field.').optional(),
    internal_networks_field: types_field.optional(),
    ignore_missing: z.boolean().describe('If true and any required fields are missing, the processor quietly exits\nwithout modifying the document.').optional().default(true)
}));

export const ingest_types_pipeline_processor = ingest_types_processor_base.and(z.object({
    name: types_name,
    ignore_missing_pipeline: z.boolean().describe('Whether to ignore missing pipelines instead of failing.').optional().default(false)
}));

export const ingest_types_redact_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    patterns: z.array(types_grok_pattern).describe('A list of grok expressions to match and redact named captures with'),
    pattern_definitions: z.record(z.string()).optional(),
    prefix: z.string().describe('Start a redacted section with this token').optional().default('<'),
    suffix: z.string().describe('End a redacted section with this token').optional().default('>'),
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false),
    skip_if_unlicensed: z.boolean().describe('If `true` and the current license does not support running redact processors, then the processor quietly exits without modifying the document').optional().default(false),
    trace_redact: z.boolean().describe('If `true` then ingest metadata `_ingest._redact._is_redacted` is set to `true` if the document has been redacted').optional().default(false)
}));

export const ingest_types_registered_domain_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    target_field: types_field.optional(),
    ignore_missing: z.boolean().describe('If true and any required fields are missing, the processor quietly exits\nwithout modifying the document.').optional().default(true)
}));

export const ingest_types_remove_processor = ingest_types_processor_base.and(z.object({
    field: types_fields,
    keep: types_fields.optional(),
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false)
}));

export const ingest_types_rename_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    target_field: types_field
}));

export const ingest_types_reroute_processor = ingest_types_processor_base.and(z.object({
    destination: z.string().describe('A static value for the target. Cant be set when the dataset or namespace option is set.').optional(),
    dataset: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    namespace: z.union([
        z.string(),
        z.array(z.string())
    ]).optional()
}));

export const ingest_types_script_processor = ingest_types_processor_base.and(z.object({
    id: types_id.optional(),
    lang: types_script_language.optional(),
    params: z.record(z.record(z.unknown())).describe('Object containing parameters for the script.').optional(),
    source: types_script_source.optional()
}));

export const ingest_types_set_processor = ingest_types_processor_base.and(z.object({
    copy_from: types_field.optional(),
    field: types_field,
    ignore_empty_value: z.boolean().describe('If `true` and `value` is a template snippet that evaluates to `null` or the empty string, the processor quietly exits without modifying the document.').optional().default(false),
    media_type: z.string().describe('The media type for encoding `value`.\nApplies only when value is a template snippet.\nMust be one of `application/json`, `text/plain`, or `application/x-www-form-urlencoded`.').optional(),
    override: z.boolean().describe('If `true` processor will update fields with pre-existing non-null-valued field.\nWhen set to `false`, such fields will not be touched.').optional().default(true),
    value: z.record(z.unknown()).describe('The value to be set for the field.\nSupports template snippets.\nMay specify only one of `value` or `copy_from`.').optional()
}));

export const ingest_types_set_security_user_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    properties: z.array(z.string()).describe('Controls what user related properties are added to the field.').optional()
}));

export const ingest_types_sort_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    order: types_sort_order.optional(),
    target_field: types_field.optional()
}));

export const ingest_types_split_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    preserve_trailing: z.boolean().describe('Preserves empty trailing fields, if any.').optional().default(false),
    separator: z.string().describe('A regex which matches the separator, for example, `,` or `\\s+`.'),
    target_field: types_field.optional()
}));

export const ingest_types_terminate_processor = ingest_types_processor_base.and(z.record(z.unknown()));

export const ingest_types_trim_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    target_field: types_field.optional()
}));

export const ingest_types_uppercase_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false),
    target_field: types_field.optional()
}));

export const ingest_types_url_decode_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.').optional().default(false),
    target_field: types_field.optional()
}));

export const ingest_types_uri_parts_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    keep_original: z.boolean().describe('If `true`, the processor copies the unparsed URI to `<target_field>.original`.').optional().default(true),
    remove_if_successful: z.boolean().describe('If `true`, the processor removes the `field` after parsing the URI string.\nIf parsing fails, the processor does not remove the `field`.').optional().default(false),
    target_field: types_field.optional()
}));

export const ingest_types_user_agent_processor = ingest_types_processor_base.and(z.object({
    field: types_field,
    ignore_missing: z.boolean().describe('If `true` and `field` does not exist, the processor quietly exits without modifying the document.').optional().default(false),
    regex_file: z.string().describe('The name of the file in the `config/ingest-user-agent` directory containing the regular expressions for parsing the user agent string. Both the directory and the file have to be created before starting Elasticsearch. If not specified, ingest-user-agent will use the `regexes.yaml` from uap-core it ships with.').optional(),
    target_field: types_field.optional(),
    properties: z.array(ingest_types_user_agent_property).describe('Controls what properties are added to `target_field`.').optional().default([
        'name',
        'major',
        'minor',
        'patch',
        'build',
        'os',
        'os_name',
        'os_major',
        'os_minor',
        'device'
    ]),
    extract_device_type: z.boolean().describe('Extracts device type from the user agent string on a best-effort basis.').optional().default(false)
}));

export const ml_types_analysis_config: z.AnyZodObject = z.object({
    bucket_span: types_duration.optional(),
    categorization_analyzer: z.lazy(() => ml_types_categorization_analyzer).optional(),
    categorization_field_name: types_field.optional(),
    categorization_filters: z.array(z.string()).describe('If `categorization_field_name` is specified, you can also define optional filters. This property expects an array of regular expressions. The expressions are used to filter out matching sequences from the categorization field values. You can use this functionality to fine tune the categorization by excluding sequences from consideration when categories are defined. For example, you can exclude SQL statements that appear in your log files. This property cannot be used at the same time as `categorization_analyzer`. If you only want to define simple regular expression filters that are applied prior to tokenization, setting this property is the easiest method. If you also want to customize the tokenizer or post-tokenization filtering, use the `categorization_analyzer` property instead and include the filters as pattern_replace character filters. The effect is exactly the same.').optional(),
    detectors: z.array(ml_types_detector).describe('Detector configuration objects specify which data fields a job analyzes. They also specify which analytical functions are used. You can specify multiple detectors for a job. If the detectors array does not contain at least one detector, no analysis can occur and an error is returned.'),
    influencers: z.array(types_field).describe('A comma separated list of influencer field names. Typically these can be the by, over, or partition fields that are used in the detector configuration. You might also want to use a field name that is not specifically named in a detector, but is available as part of the input data. When you use multiple detectors, the use of influencers is recommended as it aggregates results for each influencer entity.').optional(),
    latency: types_duration.optional(),
    model_prune_window: types_duration.optional(),
    multivariate_by_fields: z.boolean().describe('This functionality is reserved for internal use. It is not supported for use in customer environments and is not subject to the support SLA of official GA features. If set to `true`, the analysis will automatically find correlations between metrics for a given by field value and report anomalies when those correlations cease to hold. For example, suppose CPU and memory usage on host A is usually highly correlated with the same metrics on host B. Perhaps this correlation occurs because they are running a load-balanced application. If you enable this property, anomalies will be reported when, for example, CPU usage on host A is high and the value of CPU usage on host B is low. That is to say, youll see an anomaly when the CPU of host A is unusual given the CPU of host B. To use the `multivariate_by_fields` property, you must also specify `by_field_name` in your detector.').optional(),
    per_partition_categorization: ml_types_per_partition_categorization.optional(),
    summary_count_field_name: types_field.optional()
});

export const ml_types_categorization_analyzer: z.ZodTypeAny = z.union([
    z.string(),
    z.lazy(() => ml_types_categorization_analyzer_definition)
]);

export const ml_types_categorization_analyzer_definition = z.object({
    char_filter: z.array(types_analysis_char_filter).describe('One or more character filters. In addition to the built-in character filters, other plugins can provide more character filters. If this property is not specified, no character filters are applied prior to categorization. If you are customizing some other aspect of the analyzer and you need to achieve the equivalent of `categorization_filters` (which are not permitted when some other aspect of the analyzer is customized), add them here as pattern replace character filters.').optional(),
    filter: z.array(types_analysis_token_filter).describe('One or more token filters. In addition to the built-in token filters, other plugins can provide more token filters. If this property is not specified, no token filters are applied prior to categorization.').optional(),
    tokenizer: types_analysis_tokenizer.optional()
});

export const ml_types_dataframe_analytics_source = z.object({
    index: types_indices,
    query: types_query_dsl_query_container.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional(),
    _source: ml_types_dataframe_analysis_analyzed_fields.optional()
});

export const ml_types_dataframe_analytics_summary = z.object({
    allow_lazy_start: z.boolean().optional(),
    analysis: ml_types_dataframe_analysis_container,
    analyzed_fields: ml_types_dataframe_analysis_analyzed_fields.optional(),
    authorization: ml_types_dataframe_analytics_authorization.optional(),
    create_time: types_epoch_time_unit_millis.optional(),
    description: z.string().optional(),
    dest: ml_types_dataframe_analytics_destination,
    id: types_id,
    max_num_threads: z.number().optional(),
    model_memory_limit: z.string().optional(),
    source: ml_types_dataframe_analytics_source,
    version: types_version_string.optional(),
    _meta: types_metadata.optional()
});

export const ml_types_datafeed = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).optional(),
    authorization: ml_types_datafeed_authorization.optional(),
    chunking_config: ml_types_chunking_config.optional(),
    datafeed_id: types_id,
    frequency: types_duration.optional(),
    indices: z.array(z.string()),
    indexes: z.array(z.string()).optional(),
    job_id: types_id,
    max_empty_searches: z.number().optional(),
    query: types_query_dsl_query_container,
    query_delay: types_duration.optional(),
    script_fields: z.record(types_script_field).optional(),
    scroll_size: z.number().optional(),
    delayed_data_check_config: ml_types_delayed_data_check_config,
    runtime_mappings: types_mapping_runtime_fields.optional(),
    indices_options: types_indices_options.optional()
});

export const ml_types_job = z.object({
    allow_lazy_open: z.boolean().describe('Advanced configuration option.\nSpecifies whether this job can open when there is insufficient machine learning node capacity for it to be immediately assigned to a node.'),
    analysis_config: ml_types_analysis_config,
    analysis_limits: ml_types_analysis_limits.optional(),
    background_persist_interval: types_duration.optional(),
    blocked: ml_types_job_blocked.optional(),
    create_time: types_date_time.optional(),
    custom_settings: ml_types_custom_settings.optional(),
    daily_model_snapshot_retention_after_days: z.number().describe('Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies a period of time (in days) after which only the first snapshot per day is retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.\nValid values range from 0 to `model_snapshot_retention_days`.').optional().default(1),
    data_description: ml_types_data_description,
    datafeed_config: ml_types_datafeed.optional(),
    deleting: z.boolean().describe('Indicates that the process of deleting the job is in progress but not yet completed.\nIt is only reported when `true`.').optional(),
    description: z.string().describe('A description of the job.').optional(),
    finished_time: types_date_time.optional(),
    groups: z.array(z.string()).describe('A list of job groups.\nA job can belong to no groups or many.').optional(),
    job_id: types_id,
    job_type: z.string().describe('Reserved for future use, currently set to `anomaly_detector`.').optional(),
    job_version: types_version_string.optional(),
    model_plot_config: ml_types_model_plot_config.optional(),
    model_snapshot_id: types_id.optional(),
    model_snapshot_retention_days: z.number().describe('Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies the maximum period of time (in days) that snapshots are retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.\nBy default, snapshots ten days older than the newest snapshot are deleted.'),
    renormalization_window_days: z.number().describe('Advanced configuration option.\nThe period over which adjustments to the score are applied, as new data is seen.\nThe default value is the longer of 30 days or 100 `bucket_spans`.').optional(),
    results_index_name: types_index_name,
    results_retention_days: z.number().describe('Advanced configuration option.\nThe period of time (in days) that results are retained.\nAge is calculated relative to the timestamp of the latest bucket result.\nIf this property has a non-null value, once per day at 00:30 (server time), results that are the specified number of days older than the latest bucket result are deleted from Elasticsearch.\nThe default value is null, which means all results are retained.\nAnnotations generated by the system also count as results for retention purposes; they are deleted after the same number of days as results.\nAnnotations added by users are retained forever.').optional()
});

export const ml_types_trained_model_config: z.AnyZodObject = z.object({
    model_id: types_id,
    model_type: ml_types_trained_model_type.optional(),
    tags: z.array(z.string()).describe('A comma delimited string of tags. A trained model can have many tags, or none.'),
    version: types_version_string.optional(),
    compressed_definition: z.string().optional(),
    created_by: z.string().describe('Information on the creator of the trained model.').optional(),
    create_time: types_date_time.optional(),
    default_field_map: z.record(z.string()).describe('Any field map described in the inference configuration takes precedence.').optional(),
    description: z.string().describe('The free-text description of the trained model.').optional(),
    estimated_heap_memory_usage_bytes: z.number().describe('The estimated heap usage in bytes to keep the trained model in memory.').optional(),
    estimated_operations: z.number().describe('The estimated number of operations to use the trained model.').optional(),
    fully_defined: z.boolean().describe('True if the full model definition is present.').optional(),
    inference_config: z.lazy(() => ml_types_inference_config_create_container).optional(),
    input: ml_types_trained_model_config_input,
    license_level: z.string().describe('The license level of the trained model.').optional(),
    metadata: ml_types_trained_model_config_metadata.optional(),
    model_size_bytes: types_byte_size.optional(),
    model_package: ml_types_model_package_config.optional(),
    location: ml_types_trained_model_location.optional(),
    platform_architecture: z.string().optional(),
    prefix_strings: ml_types_trained_model_prefix_strings.optional()
});

/**
 * Inference configuration provided when storing the model config
 */
export const ml_types_inference_config_create_container: z.AnyZodObject = z.object({
    regression: ml_types_regression_inference_options.optional(),
    classification: ml_types_classification_inference_options.optional(),
    text_classification: ml_types_text_classification_inference_options.optional(),
    zero_shot_classification: ml_types_zero_shot_classification_inference_options.optional(),
    fill_mask: ml_types_fill_mask_inference_options.optional(),
    learning_to_rank: z.lazy(() => ml_types_learning_to_rank_config).optional(),
    ner: ml_types_ner_inference_options.optional(),
    pass_through: ml_types_pass_through_inference_options.optional(),
    text_embedding: ml_types_text_embedding_inference_options.optional(),
    text_expansion: ml_types_text_expansion_inference_options.optional(),
    question_answering: ml_types_question_answering_inference_options.optional()
}).describe('Inference configuration provided when storing the model config');

export const ml_types_learning_to_rank_config: z.AnyZodObject = z.object({
    default_params: z.record(z.record(z.unknown())).optional(),
    feature_extractors: z.array(z.record(z.lazy(() => ml_types_feature_extractor))).optional(),
    num_top_feature_importance_values: z.number()
});

export const ml_types_feature_extractor: z.ZodTypeAny = z.lazy(() => ml_types_query_feature_extractor);

export const ml_types_query_feature_extractor = z.object({
    default_score: z.number().optional(),
    feature_name: z.string(),
    query: types_query_dsl_query_container
});

export const ml_info_defaults: z.AnyZodObject = z.object({
    anomaly_detectors: z.lazy(() => ml_info_anomaly_detectors),
    datafeeds: ml_info_datafeeds
});

export const ml_info_anomaly_detectors = z.object({
    categorization_analyzer: ml_types_categorization_analyzer,
    categorization_examples_limit: z.number(),
    model_memory_limit: z.string(),
    model_snapshot_retention_days: z.number(),
    daily_model_snapshot_retention_after_days: z.number()
});

export const ml_preview_data_frame_analytics_dataframe_preview_config = z.object({
    source: ml_types_dataframe_analytics_source,
    analysis: ml_types_dataframe_analysis_container,
    model_memory_limit: z.string().optional(),
    max_num_threads: z.number().optional(),
    analyzed_fields: ml_types_dataframe_analysis_analyzed_fields.optional()
});

export const ml_types_datafeed_config = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).describe('If set, the datafeed performs aggregation searches. Support for aggregations is limited and should be used only with low cardinality data.').optional(),
    chunking_config: ml_types_chunking_config.optional(),
    datafeed_id: types_id.optional(),
    delayed_data_check_config: ml_types_delayed_data_check_config.optional(),
    frequency: types_duration.optional(),
    indices: types_indices.optional(),
    indices_options: types_indices_options.optional(),
    job_id: types_id.optional(),
    max_empty_searches: z.number().describe('If a real-time datafeed has never seen any data (including during any initial training period) then it will automatically stop itself and close its associated job after this many real-time searches that return no documents. In other words, it will stop after `frequency` times `max_empty_searches` of real-time operation. If not set then a datafeed with no end time that sees no data will remain started until it is explicitly stopped.').optional(),
    query: types_query_dsl_query_container.optional(),
    query_delay: types_duration.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional(),
    script_fields: z.record(types_script_field).describe('Specifies scripts that evaluate custom expressions and returns script fields to the datafeed. The detector configuration objects in a job can contain functions that use these script fields.').optional(),
    scroll_size: z.number().describe('The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations. The maximum value is the value of `index.max_result_window`, which is 10,000 by default.').optional().default(1000)
});

export const ml_types_job_config = z.object({
    allow_lazy_open: z.boolean().describe('Advanced configuration option. Specifies whether this job can open when there is insufficient machine learning node capacity for it to be immediately assigned to a node.').optional().default(false),
    analysis_config: ml_types_analysis_config,
    analysis_limits: ml_types_analysis_limits.optional(),
    background_persist_interval: types_duration.optional(),
    custom_settings: ml_types_custom_settings.optional(),
    daily_model_snapshot_retention_after_days: z.number().describe('Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies a period of time (in days) after which only the first snapshot per day is retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.').optional().default(1),
    data_description: ml_types_data_description,
    datafeed_config: ml_types_datafeed_config.optional(),
    description: z.string().describe('A description of the job.').optional(),
    groups: z.array(z.string()).describe('A list of job groups. A job can belong to no groups or many.').optional(),
    job_id: types_id.optional(),
    model_plot_config: ml_types_model_plot_config.optional(),
    model_snapshot_retention_days: z.number().describe('Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies the maximum period of time (in days) that snapshots are retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.\nThe default value is `10`, which means snapshots ten days older than the newest snapshot are deleted.').optional().default(10),
    renormalization_window_days: z.number().describe('Advanced configuration option.\nThe period over which adjustments to the score are applied, as new data is seen.\nThe default value is the longer of 30 days or 100 `bucket_spans`.').optional(),
    results_index_name: types_index_name.optional(),
    results_retention_days: z.number().describe('Advanced configuration option.\nThe period of time (in days) that results are retained.\nAge is calculated relative to the timestamp of the latest bucket result.\nIf this property has a non-null value, once per day at 00:30 (server time), results that are the specified number of days older than the latest bucket result are deleted from Elasticsearch.\nThe default value is null, which means all results are retained.\nAnnotations generated by the system also count as results for retention purposes; they are deleted after the same number of days as results.\nAnnotations added by users are retained forever.').optional()
});

export const ml_types_analysis_config_read = z.object({
    bucket_span: types_duration,
    categorization_analyzer: ml_types_categorization_analyzer.optional(),
    categorization_field_name: types_field.optional(),
    categorization_filters: z.array(z.string()).describe('If `categorization_field_name` is specified, you can also define optional filters.\nThis property expects an array of regular expressions.\nThe expressions are used to filter out matching sequences from the categorization field values.').optional(),
    detectors: z.array(ml_types_detector_read).describe('An array of detector configuration objects.\nDetector configuration objects specify which data fields a job analyzes.\nThey also specify which analytical functions are used.\nYou can specify multiple detectors for a job.'),
    influencers: z.array(types_field).describe('A comma separated list of influencer field names.\nTypically these can be the by, over, or partition fields that are used in the detector configuration.\nYou might also want to use a field name that is not specifically named in a detector, but is available as part of the input data.\nWhen you use multiple detectors, the use of influencers is recommended as it aggregates results for each influencer entity.'),
    model_prune_window: types_duration.optional(),
    latency: types_duration.optional(),
    multivariate_by_fields: z.boolean().describe('This functionality is reserved for internal use.\nIt is not supported for use in customer environments and is not subject to the support SLA of official GA features.\nIf set to `true`, the analysis will automatically find correlations between metrics for a given by field value and report anomalies when those correlations cease to hold.').optional(),
    per_partition_categorization: ml_types_per_partition_categorization.optional(),
    summary_count_field_name: types_field.optional()
});

export const ml_put_trained_model_definition: z.AnyZodObject = z.object({
    preprocessors: z.array(ml_put_trained_model_preprocessor).describe('Collection of preprocessors').optional(),
    trained_model: z.lazy(() => ml_put_trained_model_trained_model)
});

export const ml_put_trained_model_trained_model: z.AnyZodObject = z.object({
    tree: ml_put_trained_model_trained_model_tree.optional(),
    tree_node: ml_put_trained_model_trained_model_tree_node.optional(),
    ensemble: z.lazy(() => ml_put_trained_model_ensemble).optional()
});

export const ml_put_trained_model_ensemble = z.object({
    aggregate_output: ml_put_trained_model_aggregate_output.optional(),
    classification_labels: z.array(z.string()).optional(),
    feature_names: z.array(z.string()).optional(),
    target_type: z.string().optional(),
    trained_models: z.array(ml_put_trained_model_trained_model)
});

export const global_msearch_multi_search_result = z.object({
    took: z.number(),
    responses: z.array(global_msearch_response_item)
});

export const global_msearch_template_request_item: z.ZodTypeAny = z.union([
    global_msearch_multisearch_header,
    z.lazy(() => global_msearch_template_template_config)
]);

export const global_msearch_template_template_config = z.object({
    explain: z.boolean().describe('If `true`, returns detailed information about score calculation as part of each hit.').optional().default(false),
    id: types_id.optional(),
    params: z.record(z.record(z.unknown())).describe('Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value.').optional(),
    profile: z.boolean().describe('If `true`, the query execution is profiled.').optional().default(false),
    source: types_script_source.optional()
});

export const nodes_stats_response_base: z.ZodTypeAny = nodes_types_nodes_response_base.and(z.object({
    cluster_name: types_name.optional(),
    nodes: z.record(z.lazy(() => nodes_types_stats))
}));

export const nodes_types_stats = z.object({
    adaptive_selection: z.record(nodes_types_adaptive_selection).describe('Statistics about adaptive replica selection.').optional(),
    breakers: z.record(nodes_types_breaker).describe('Statistics about the field data circuit breaker.').optional(),
    fs: nodes_types_file_system.optional(),
    host: types_host.optional(),
    http: nodes_types_http.optional(),
    ingest: nodes_types_ingest.optional(),
    ip: z.union([
        types_ip,
        z.array(types_ip)
    ]).optional(),
    jvm: nodes_types_jvm.optional(),
    name: types_name.optional(),
    os: nodes_types_operating_system.optional(),
    process: nodes_types_process.optional(),
    roles: types_node_roles.optional(),
    script: nodes_types_scripting.optional(),
    script_cache: z.record(z.union([
        nodes_types_script_cache,
        z.array(nodes_types_script_cache)
    ])).optional(),
    thread_pool: z.record(nodes_types_thread_count).describe('Statistics about each thread pool, including current size, queue and rejected tasks.').optional(),
    timestamp: z.number().optional(),
    transport: nodes_types_transport.optional(),
    transport_address: types_transport_address.optional(),
    attributes: z.record(z.string()).describe('Contains a list of attributes for the node.').optional(),
    discovery: nodes_types_discovery.optional(),
    indexing_pressure: nodes_types_indexing_pressure.optional(),
    indices: indices_stats_shard_stats.optional()
});

export const global_rank_eval_rank_eval_request_item: z.AnyZodObject = z.object({
    id: types_id,
    request: z.lazy(() => global_rank_eval_rank_eval_query).optional(),
    ratings: z.array(global_rank_eval_document_rating).describe('List of document ratings'),
    template_id: types_id.optional(),
    params: z.record(z.record(z.unknown())).describe('The search template parameters.').optional()
});

export const global_rank_eval_rank_eval_query = z.object({
    query: types_query_dsl_query_container,
    size: z.number().optional()
});

export const global_reindex_source = z.object({
    index: types_indices,
    query: types_query_dsl_query_container.optional(),
    remote: global_reindex_remote_source.optional(),
    size: z.number().describe('The number of documents to index per batch.\nUse it when you are indexing from remote to ensure that the batches fit within the on-heap buffer, which defaults to a maximum size of 100 MB.').optional().default(1000),
    slice: types_sliced_scroll.optional(),
    sort: types_sort.optional(),
    _source: global_search_types_source_config.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional()
});

export const global_scripts_painless_execute_painless_context_setup = z.object({
    document: z.record(z.unknown()).describe('Document that\'s temporarily indexed in-memory and accessible from the script.'),
    index: types_index_name,
    query: types_query_dsl_query_container.optional()
});

export const search_application_types_search_application: z.ZodTypeAny = z.lazy(() => search_application_types_search_application_parameters).and(z.object({
    name: types_name,
    updated_at_millis: types_epoch_time_unit_millis
}));

export const search_application_types_search_application_parameters: z.AnyZodObject = z.object({
    indices: z.array(types_index_name).describe('Indices that are part of the Search Application.'),
    analytics_collection_name: types_name.optional(),
    template: z.lazy(() => search_application_types_search_application_template).optional()
});

export const search_application_types_search_application_template = z.object({
    script: types_script
});

export const global_search_shards_shard_store_index = z.object({
    aliases: z.array(types_name).optional(),
    filter: types_query_dsl_query_container.optional()
});

export const security_types_role_descriptor: z.AnyZodObject = z.object({
    cluster: z.array(security_types_cluster_privilege).describe('A list of cluster privileges. These privileges define the cluster level actions that API keys are able to execute.').optional(),
    indices: z.array(z.lazy(() => security_types_indices_privileges)).describe('A list of indices permissions entries.').optional(),
    remote_indices: z.array(z.lazy(() => security_types_remote_indices_privileges)).describe('A list of indices permissions for remote clusters.').optional(),
    remote_cluster: z.array(security_types_remote_cluster_privileges).describe('A list of cluster permissions for remote clusters.\nNOTE: This is limited a subset of the cluster permissions.').optional(),
    global: z.union([
        z.array(security_types_global_privilege),
        security_types_global_privilege
    ]).optional(),
    applications: z.array(security_types_application_privileges).describe('A list of application privilege entries').optional(),
    metadata: types_metadata.optional(),
    run_as: z.array(z.string()).describe('A list of users that the API keys can impersonate.\nNOTE: In Elastic Cloud Serverless, the run-as feature is disabled.\nFor API compatibility, you can still specify an empty `run_as` field, but a non-empty list will be rejected.').optional(),
    description: z.string().describe('Optional description of the role descriptor').optional(),
    restriction: security_types_restriction.optional(),
    transient_metadata: z.record(z.record(z.unknown())).optional()
});

export const security_types_indices_privileges: z.AnyZodObject = z.object({
    field_security: security_types_field_security.optional(),
    names: z.union([
        types_index_name,
        z.array(types_index_name)
    ]),
    privileges: z.array(security_types_index_privilege).describe('The index level privileges that owners of the role have on the specified indices.'),
    query: z.lazy(() => security_types_indices_privileges_query).optional(),
    allow_restricted_indices: z.boolean().describe('Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.').optional().default(false)
});

/**
 * While creating or updating a role you can provide either a JSON structure or a string to the API.
 * However, the response provided by Elasticsearch will only be string with a json-as-text content.
 *
 * Since this is embedded in `IndicesPrivileges`, the same structure is used for clarity in both contexts.
 */
export const security_types_indices_privileges_query: z.ZodTypeAny = z.union([
    z.string(),
    types_query_dsl_query_container,
    z.lazy(() => security_types_role_template_query)
]);

export const security_types_role_template_query: z.AnyZodObject = z.object({
    template: z.lazy(() => security_types_role_template_script).optional()
});

export const security_types_role_template_script: z.AnyZodObject = z.object({
    source: z.lazy(() => security_types_role_template_inline_query).optional(),
    id: types_id.optional(),
    params: z.record(z.record(z.unknown())).describe('Specifies any named parameters that are passed into the script as variables.\nUse parameters instead of hard-coded values to decrease compile time.').optional(),
    lang: types_script_language.optional(),
    options: z.record(z.string()).optional()
});

export const security_types_role_template_inline_query = z.union([
    z.string(),
    types_query_dsl_query_container
]);

/**
 * The subset of index level privileges that can be defined for remote clusters.
 */
export const security_types_remote_indices_privileges = z.object({
    clusters: types_names,
    field_security: security_types_field_security.optional(),
    names: z.union([
        types_index_name,
        z.array(types_index_name)
    ]),
    privileges: z.array(security_types_index_privilege).describe('The index level privileges that owners of the role have on the specified indices.'),
    query: security_types_indices_privileges_query.optional(),
    allow_restricted_indices: z.boolean().describe('Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.').optional().default(false)
}).describe('The subset of index level privileges that can be defined for remote clusters.');

export const security_types_access: z.AnyZodObject = z.object({
    replication: z.array(security_types_replication_access).describe('A list of indices permission entries for cross-cluster replication.').optional(),
    search: z.array(z.lazy(() => security_types_search_access)).describe('A list of indices permission entries for cross-cluster search.').optional()
});

export const security_types_search_access = z.object({
    field_security: security_types_field_security.optional(),
    names: z.union([
        types_index_name,
        z.array(types_index_name)
    ]),
    query: security_types_indices_privileges_query.optional(),
    allow_restricted_indices: z.boolean().describe('Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.').optional().default(false)
});

export const security_types_api_key = z.object({
    id: types_id,
    name: types_name,
    type: security_types_api_key_type,
    creation: types_epoch_time_unit_millis,
    expiration: types_epoch_time_unit_millis.optional(),
    invalidated: z.boolean().describe('Invalidation status for the API key.\nIf the key has been invalidated, it has a value of `true`. Otherwise, it is `false`.'),
    invalidation: types_epoch_time_unit_millis.optional(),
    username: types_username,
    realm: z.string().describe('Realm name of the principal for which this API key was created.'),
    realm_type: z.string().describe('Realm type of the principal for which this API key was created').optional(),
    metadata: types_metadata,
    role_descriptors: z.record(security_types_role_descriptor).describe('The role descriptors assigned to this API key when it was created or last updated.\nAn empty role descriptor means the API key inherits the owner users permissions.').optional(),
    limited_by: z.array(z.record(security_types_role_descriptor)).describe('The owner users permissions associated with the API key.\nIt is a point-in-time snapshot captured at creation and subsequent updates.\nAn API keys effective permissions are an intersection of its assigned privileges and the owner users permissions.').optional(),
    access: security_types_access.optional(),
    certificate_identity: z.string().describe('The certificate identity associated with a cross-cluster API key.\nRestricts the API key to connections authenticated by a specific TLS certificate.\nOnly applicable to cross-cluster API keys.').optional(),
    profile_uid: z.string().describe('The profile uid for the API key owner principal, if requested and if it exists').optional(),
    _sort: types_sort_results.optional()
});

export const security_get_role_role: z.AnyZodObject = z.object({
    cluster: z.array(security_types_cluster_privilege),
    indices: z.array(security_types_indices_privileges),
    remote_indices: z.array(security_types_remote_indices_privileges).optional(),
    remote_cluster: z.array(security_types_remote_cluster_privileges).optional(),
    metadata: types_metadata,
    description: z.string().optional(),
    run_as: z.array(z.string()).optional(),
    transient_metadata: z.record(z.record(z.unknown())).optional(),
    applications: z.array(security_types_application_privileges),
    role_templates: z.array(z.lazy(() => security_types_role_template)).optional(),
    global: z.record(z.record(z.record(z.array(z.string())))).optional()
});

export const security_types_role_template = z.object({
    format: security_types_template_format.optional(),
    template: types_script
});

export const security_types_role_mapping = z.object({
    enabled: z.boolean(),
    metadata: types_metadata,
    roles: z.array(z.string()).optional(),
    role_templates: z.array(security_types_role_template).optional(),
    rules: security_types_role_mapping_rule
});

export const security_get_service_accounts_role_descriptor_wrapper: z.AnyZodObject = z.object({
    role_descriptor: z.lazy(() => security_types_role_descriptor_read)
});

export const security_types_role_descriptor_read = z.object({
    cluster: z.array(security_types_cluster_privilege).describe('A list of cluster privileges. These privileges define the cluster level actions that API keys are able to execute.'),
    indices: z.array(security_types_indices_privileges).describe('A list of indices permissions entries.'),
    remote_indices: z.array(security_types_remote_indices_privileges).describe('A list of indices permissions for remote clusters.').optional(),
    remote_cluster: z.array(security_types_remote_cluster_privileges).describe('A list of cluster permissions for remote clusters.\nNOTE: This is limited a subset of the cluster permissions.').optional(),
    global: z.union([
        z.array(security_types_global_privilege),
        security_types_global_privilege
    ]).optional(),
    applications: z.array(security_types_application_privileges).describe('A list of application privilege entries').optional(),
    metadata: types_metadata.optional(),
    run_as: z.array(z.string()).describe('A list of users that the API keys can impersonate.').optional(),
    description: z.string().describe('An optional description of the role descriptor.').optional(),
    restriction: security_types_restriction.optional(),
    transient_metadata: z.record(z.record(z.unknown())).optional()
});

export const security_types_security_settings = z.object({
    index: indices_types_index_settings.optional()
});

export const security_types_user_indices_privileges = z.object({
    field_security: z.array(security_types_field_security).describe('The document fields that the owners of the role have read access to.').optional(),
    names: z.union([
        types_index_name,
        z.array(types_index_name)
    ]),
    privileges: z.array(security_types_index_privilege).describe('The index level privileges that owners of the role have on the specified indices.'),
    query: z.array(security_types_indices_privileges_query).describe('Search queries that define the documents the user has access to. A document within the specified indices must match these queries for it to be accessible by the owners of the role.').optional(),
    allow_restricted_indices: z.boolean().describe('Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.')
});

export const security_types_remote_user_indices_privileges = z.object({
    field_security: z.array(security_types_field_security).describe('The document fields that the owners of the role have read access to.').optional(),
    names: z.union([
        types_index_name,
        z.array(types_index_name)
    ]),
    privileges: z.array(security_types_index_privilege).describe('The index level privileges that owners of the role have on the specified indices.'),
    query: z.array(security_types_indices_privileges_query).describe('Search queries that define the documents the user has access to. A document within the specified indices must match these queries for it to be accessible by the owners of the role.').optional(),
    allow_restricted_indices: z.boolean().describe('Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.'),
    clusters: z.array(z.string())
});

export const security_grant_api_key_grant_api_key = z.object({
    name: types_name,
    expiration: types_duration_large.optional(),
    role_descriptors: z.union([
        z.record(security_types_role_descriptor),
        z.array(z.record(security_types_role_descriptor))
    ]).optional(),
    metadata: types_metadata.optional()
});

export const security_query_api_keys_api_key_aggregation_container: z.ZodTypeAny = z.object({
    aggregations: z.record(z.lazy(() => security_query_api_keys_api_key_aggregation_container)).describe('Sub-aggregations for this aggregation.\nOnly applies to bucket aggregations.').optional(),
    meta: types_metadata.optional()
}).and(z.object({
    cardinality: types_aggregations_cardinality_aggregation.optional(),
    composite: types_aggregations_composite_aggregation.optional(),
    date_range: types_aggregations_date_range_aggregation.optional(),
    filter: z.lazy(() => security_query_api_keys_api_key_query_container).optional(),
    filters: z.lazy(() => security_query_api_keys_api_key_filters_aggregation).optional(),
    missing: types_aggregations_missing_aggregation.optional(),
    range: types_aggregations_range_aggregation.optional(),
    terms: types_aggregations_terms_aggregation.optional(),
    value_count: types_aggregations_value_count_aggregation.optional()
}));

export const security_query_api_keys_api_key_query_container = z.object({
    bool: types_query_dsl_bool_query.optional(),
    exists: types_query_dsl_exists_query.optional(),
    ids: types_query_dsl_ids_query.optional(),
    match: z.record(types_query_dsl_match_query).describe('Returns documents that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.').optional(),
    match_all: types_query_dsl_match_all_query.optional(),
    prefix: z.record(types_query_dsl_prefix_query).describe('Returns documents that contain a specific prefix in a provided field.').optional(),
    range: z.record(types_query_dsl_range_query).describe('Returns documents that contain terms within a provided range.').optional(),
    simple_query_string: types_query_dsl_simple_query_string_query.optional(),
    term: z.record(types_query_dsl_term_query).describe('Returns documents that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field\'s value, including whitespace and capitalization.').optional(),
    terms: types_query_dsl_terms_query.optional(),
    wildcard: z.record(types_query_dsl_wildcard_query).describe('Returns documents that contain terms matching a wildcard pattern.').optional()
});

export const security_query_api_keys_api_key_filters_aggregation: z.ZodTypeAny = types_aggregations_bucket_aggregation_base.and(z.object({
    filters: z.lazy(() => types_aggregations_buckets_api_key_query_container).optional(),
    other_bucket: z.boolean().describe('Set to `true` to add a bucket to the response which will contain all documents that do not match any of the given filters.').optional(),
    other_bucket_key: z.string().describe('The key with which the other bucket is returned.').optional().default('_other_'),
    keyed: z.boolean().describe('By default, the named filters aggregation returns the buckets as an object.\nSet to `false` to return the buckets as an array of objects.').optional().default(true)
}));

/**
 * Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for
 * the different buckets, the result is a dictionary.
 */
export const types_aggregations_buckets_api_key_query_container = z.union([
    z.record(security_query_api_keys_api_key_query_container),
    z.array(security_query_api_keys_api_key_query_container)
]);

export const security_query_role_role_query_container = z.object({
    bool: types_query_dsl_bool_query.optional(),
    exists: types_query_dsl_exists_query.optional(),
    ids: types_query_dsl_ids_query.optional(),
    match: z.record(types_query_dsl_match_query).describe('Returns roles that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.').optional(),
    match_all: types_query_dsl_match_all_query.optional(),
    prefix: z.record(types_query_dsl_prefix_query).describe('Returns roles that contain a specific prefix in a provided field.').optional(),
    range: z.record(types_query_dsl_range_query).describe('Returns roles that contain terms within a provided range.').optional(),
    simple_query_string: types_query_dsl_simple_query_string_query.optional(),
    term: z.record(types_query_dsl_term_query).describe('Returns roles that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field\'s value, including whitespace and capitalization.').optional(),
    terms: types_query_dsl_terms_query.optional(),
    wildcard: z.record(types_query_dsl_wildcard_query).describe('Returns roles that contain terms matching a wildcard pattern.').optional()
});

export const security_query_role_query_role = security_types_role_descriptor.and(z.object({
    _sort: types_sort_results.optional(),
    name: z.string().describe('Name of the role.')
}));

export const security_query_user_user_query_container = z.object({
    ids: types_query_dsl_ids_query.optional(),
    bool: types_query_dsl_bool_query.optional(),
    exists: types_query_dsl_exists_query.optional(),
    match: z.record(types_query_dsl_match_query).describe('Returns users that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.').optional(),
    match_all: types_query_dsl_match_all_query.optional(),
    prefix: z.record(types_query_dsl_prefix_query).describe('Returns users that contain a specific prefix in a provided field.').optional(),
    range: z.record(types_query_dsl_range_query).describe('Returns users that contain terms within a provided range.').optional(),
    simple_query_string: types_query_dsl_simple_query_string_query.optional(),
    term: z.record(types_query_dsl_term_query).describe('Returns users that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field\'s value, including whitespace and capitalization.').optional(),
    terms: types_query_dsl_terms_query.optional(),
    wildcard: z.record(types_query_dsl_wildcard_query).describe('Returns users that contain terms matching a wildcard pattern.').optional()
});

export const simulate_ingest_simulate_ingest_document_result: z.AnyZodObject = z.object({
    doc: z.lazy(() => simulate_ingest_ingest_document_simulation).optional()
});

/**
 * The results of ingest simulation on a single document. The _source of the document contains
 * the results after running all pipelines listed in executed_pipelines on the document. The
 * list of executed pipelines is derived from the pipelines that would be executed if this
 * document had been ingested into _index.
 */
export const simulate_ingest_ingest_document_simulation = z.object({
    _id: types_id,
    _index: types_index_name,
    _source: z.record(z.record(z.unknown())).describe('JSON body for the document.'),
    _version: spec_utils_stringified_version_number,
    executed_pipelines: z.array(z.string()).describe('A list of the names of the pipelines executed on this document.'),
    ignored_fields: z.array(z.record(z.string())).describe('A list of the fields that would be ignored at the indexing step. For example, a field whose\nvalue is larger than the allowed limit would make it through all of the pipelines, but\nwould not be indexed into Elasticsearch.').optional(),
    error: types_error_cause.optional(),
    effective_mapping: types_mapping_type_mapping.optional()
}).describe('The results of ingest simulation on a single document. The _source of the document contains\nthe results after running all pipelines listed in executed_pipelines on the document. The\nlist of executed pipelines is derived from the pipelines that would be executed if this\ndocument had been ingested into _index.');

export const ingest_types_pipeline_config = z.object({
    description: z.string().describe('Description of the ingest pipeline.').optional(),
    version: types_version_number.optional(),
    processors: z.array(ingest_types_processor_container).describe('Processors used to perform transformations on documents before indexing.\nProcessors run sequentially in the order specified.')
});

export const transform_get_transform_transform_summary: z.AnyZodObject = z.object({
    authorization: ml_types_transform_authorization.optional(),
    create_time: types_epoch_time_unit_millis.optional(),
    create_time_string: types_date_time.optional(),
    description: z.string().describe('Free text description of the transform.').optional(),
    dest: global_reindex_destination,
    frequency: types_duration.optional(),
    id: types_id,
    latest: transform_types_latest.optional(),
    pivot: z.lazy(() => transform_types_pivot).optional(),
    retention_policy: transform_types_retention_policy_container.optional(),
    settings: transform_types_settings.optional(),
    source: z.lazy(() => transform_types_source),
    sync: transform_types_sync_container.optional(),
    version: types_version_string.optional(),
    _meta: types_metadata.optional()
});

export const transform_types_pivot: z.AnyZodObject = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).describe('Defines how to aggregate the grouped data. The following aggregations are currently supported: average, bucket\nscript, bucket selector, cardinality, filter, geo bounds, geo centroid, geo line, max, median absolute deviation,\nmin, missing, percentiles, rare terms, scripted metric, stats, sum, terms, top metrics, value count, weighted\naverage.').optional(),
    group_by: z.record(z.lazy(() => transform_types_pivot_group_by_container)).describe('Defines how to group the data. More than one grouping can be defined per pivot. The following groupings are\ncurrently supported: date histogram, geotile grid, histogram, terms.').optional()
});

export const transform_types_pivot_group_by_container = z.object({
    date_histogram: types_aggregations_date_histogram_aggregation.optional(),
    geotile_grid: types_aggregations_geo_tile_grid_aggregation.optional(),
    histogram: types_aggregations_histogram_aggregation.optional(),
    terms: types_aggregations_terms_aggregation.optional()
});

export const transform_types_source = z.object({
    index: types_indices,
    query: types_query_dsl_query_container.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional()
});

export const watcher_types_watch: z.AnyZodObject = z.object({
    actions: z.record(z.lazy(() => watcher_types_action)),
    condition: z.lazy(() => watcher_types_condition_container),
    input: z.lazy(() => watcher_types_input_container),
    metadata: types_metadata.optional(),
    status: watcher_types_watch_status.optional(),
    throttle_period: types_duration.optional(),
    throttle_period_in_millis: types_duration_value_unit_millis.optional(),
    transform: z.lazy(() => types_transform_container).optional(),
    trigger: watcher_types_trigger_container
});

export const watcher_types_action: z.AnyZodObject = z.object({
    action_type: watcher_types_action_type.optional(),
    condition: z.lazy(() => watcher_types_condition_container).optional(),
    foreach: z.string().optional(),
    max_iterations: z.number().optional(),
    name: types_name.optional(),
    throttle_period: types_duration.optional(),
    throttle_period_in_millis: types_duration_value_unit_millis.optional(),
    transform: z.lazy(() => types_transform_container).optional(),
    index: watcher_types_index_action.optional(),
    logging: watcher_types_logging_action.optional(),
    email: watcher_types_email_action.optional(),
    pagerduty: watcher_types_pager_duty_action.optional(),
    slack: watcher_types_slack_action.optional(),
    webhook: watcher_types_webhook_action.optional()
});

export const watcher_types_condition_container: z.AnyZodObject = z.object({
    always: watcher_types_always_condition.optional(),
    array_compare: z.record(watcher_types_array_compare_condition).optional(),
    compare: z.record(z.record(types_field_value)).optional(),
    never: watcher_types_never_condition.optional(),
    script: z.lazy(() => watcher_types_script_condition).optional()
});

export const watcher_types_script_condition = z.object({
    lang: types_script_language.optional(),
    params: z.record(z.record(z.unknown())).optional(),
    source: types_script_source.optional(),
    id: z.string().optional()
});

export const types_transform_container: z.AnyZodObject = z.object({
    chain: z.array(z.lazy(() => types_transform_container)).optional(),
    script: z.lazy(() => types_script_transform).optional(),
    search: z.lazy(() => types_search_transform).optional()
});

export const types_script_transform = z.object({
    lang: z.string().optional().default('painless'),
    params: z.record(z.record(z.unknown())).optional(),
    source: types_script_source.optional(),
    id: z.string().optional()
});

export const types_search_transform: z.AnyZodObject = z.object({
    request: z.lazy(() => watcher_types_search_input_request_definition),
    timeout: types_duration
});

export const watcher_types_search_input_request_definition: z.AnyZodObject = z.object({
    body: z.lazy(() => watcher_types_search_input_request_body).optional(),
    indices: z.array(types_index_name).optional(),
    indices_options: types_indices_options.optional(),
    search_type: types_search_type.optional(),
    template: watcher_types_search_template_request_body.optional(),
    rest_total_hits_as_int: z.boolean().optional()
});

export const watcher_types_search_input_request_body = z.object({
    query: types_query_dsl_query_container
});

export const watcher_types_input_container: z.AnyZodObject = z.object({
    chain: z.lazy(() => watcher_types_chain_input).optional(),
    http: watcher_types_http_input.optional(),
    search: z.lazy(() => watcher_types_search_input).optional(),
    simple: z.record(z.record(z.unknown())).optional()
});

export const watcher_types_chain_input = z.object({
    inputs: z.array(z.record(watcher_types_input_container))
});

export const watcher_types_search_input = z.object({
    extract: z.array(z.string()).optional(),
    request: watcher_types_search_input_request_definition,
    timeout: types_duration.optional()
});

export const watcher_execute_watch_watch_record = z.object({
    condition: watcher_types_condition_container,
    input: watcher_types_input_container,
    messages: z.array(z.string()),
    metadata: types_metadata.optional(),
    node: z.string(),
    result: watcher_types_execution_result,
    state: watcher_types_execution_status,
    trigger_event: watcher_types_trigger_event_result,
    user: types_username,
    watch_id: types_id,
    status: watcher_types_watch_status.optional()
});

export const watcher_types_query_watch = z.object({
    _id: types_id,
    status: watcher_types_watch_status.optional(),
    watch: watcher_types_watch.optional(),
    _primary_term: z.number().optional(),
    _seq_no: types_sequence_number.optional()
});

/**
 * A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
 */
export const async_search_submit_index = types_indices;

/**
 * Blocks and waits until the search is completed up to a certain timeout.
 * When the async search completes within the timeout, the response wont include the ID as the results are not stored in the cluster.
 */
export const async_search_submit_wait_for_completion_timeout = types_duration;

/**
 * Specifies how long the async search needs to be available.
 * Ongoing async searches and any saved search results are deleted after this period.
 */
export const async_search_submit_keep_alive = types_duration;

/**
 * If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`.
 */
export const async_search_submit_keep_on_completion = z.boolean().describe('If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`.');

/**
 * Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
 */
export const async_search_submit_allow_no_indices = z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)');

/**
 * Indicate if an error should be returned if there is a partial search failure or timeout
 */
export const async_search_submit_allow_partial_search_results = z.boolean().describe('Indicate if an error should be returned if there is a partial search failure or timeout');

/**
 * The analyzer to use for the query string
 */
export const async_search_submit_analyzer = z.string().describe('The analyzer to use for the query string');

/**
 * Specify whether wildcard and prefix queries should be analyzed (default: false)
 */
export const async_search_submit_analyze_wildcard = z.boolean().describe('Specify whether wildcard and prefix queries should be analyzed (default: false)');

/**
 * Affects how often partial results become available, which happens whenever shard results are reduced.
 * A partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).
 */
export const async_search_submit_batched_reduce_size = z.number().describe('Affects how often partial results become available, which happens whenever shard results are reduced.\nA partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).');

/**
 * The default value is the only supported value.
 */
export const async_search_submit_ccs_minimize_roundtrips = z.boolean().describe('The default value is the only supported value.');

/**
 * The default operator for query string query (AND or OR)
 */
export const async_search_submit_default_operator = types_query_dsl_operator;

/**
 * The field to use as default where no field prefix is given in the query string
 */
export const async_search_submit_df = z.string().describe('The field to use as default where no field prefix is given in the query string');

/**
 * A comma-separated list of fields to return as the docvalue representation of a field for each hit
 */
export const async_search_submit_docvalue_fields = types_fields;

/**
 * Whether to expand wildcard expression to concrete indices that are open, closed or both.
 */
export const async_search_submit_expand_wildcards = types_expand_wildcards;

/**
 * Specify whether to return detailed information about score computation as part of a hit
 */
export const async_search_submit_explain = z.boolean().describe('Specify whether to return detailed information about score computation as part of a hit');

/**
 * Whether specified concrete, expanded or aliased indices should be ignored when throttled
 */
export const async_search_submit_ignore_throttled = z.boolean().describe('Whether specified concrete, expanded or aliased indices should be ignored when throttled');

/**
 * Whether specified concrete indices should be ignored when unavailable (missing or closed)
 */
export const async_search_submit_ignore_unavailable = z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)');

/**
 * Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
 */
export const async_search_submit_lenient = z.boolean().describe('Specify whether format-based query failures (such as providing text to a numeric field) should be ignored');

/**
 * The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests
 */
export const async_search_submit_max_concurrent_shard_requests = z.number().describe('The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests');

/**
 * Specify the node or shard the operation should be performed on (default: random)
 */
export const async_search_submit_preference = z.string().describe('Specify the node or shard the operation should be performed on (default: random)');

/**
 * Specify if request cache should be used for this request or not, defaults to true
 */
export const async_search_submit_request_cache = z.boolean().describe('Specify if request cache should be used for this request or not, defaults to true');

/**
 * A comma-separated list of specific routing values
 */
export const async_search_submit_routing = types_routing;

/**
 * Search operation type
 */
export const async_search_submit_search_type = types_search_type;

/**
 * Specific 'tag' of the request for logging and statistical purposes
 */
export const async_search_submit_stats = z.array(z.string()).describe('Specific \'tag\' of the request for logging and statistical purposes');

/**
 * A comma-separated list of stored fields to return as part of a hit
 */
export const async_search_submit_stored_fields = types_fields;

/**
 * Specifies which field to use for suggestions.
 */
export const async_search_submit_suggest_field = types_field;

/**
 * Specify suggest mode
 */
export const async_search_submit_suggest_mode = types_suggest_mode;

/**
 * How many suggestions to return in response
 */
export const async_search_submit_suggest_size = z.number().describe('How many suggestions to return in response');

/**
 * The source text for which the suggestions should be returned.
 */
export const async_search_submit_suggest_text = z.string().describe('The source text for which the suggestions should be returned.');

/**
 * The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
 */
export const async_search_submit_terminate_after = z.number().describe('The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.');

/**
 * Explicit operation timeout
 */
export const async_search_submit_timeout = types_duration;

/**
 * Indicate if the number of documents that match the query should be tracked. A number can also be specified, to accurately track the total hit count up to the number.
 */
export const async_search_submit_track_total_hits = global_search_types_track_hits;

/**
 * Whether to calculate and return scores even if they are not used for sorting
 */
export const async_search_submit_track_scores = z.boolean().describe('Whether to calculate and return scores even if they are not used for sorting');

/**
 * Specify whether aggregation and suggester names should be prefixed by their respective types in the response
 */
export const async_search_submit_typed_keys = z.boolean().describe('Specify whether aggregation and suggester names should be prefixed by their respective types in the response');

/**
 * Indicates whether hits.total should be rendered as an integer or an object in the rest search response
 */
export const async_search_submit_rest_total_hits_as_int = z.boolean().describe('Indicates whether hits.total should be rendered as an integer or an object in the rest search response');

/**
 * Specify whether to return document version as part of a hit
 */
export const async_search_submit_version = z.boolean().describe('Specify whether to return document version as part of a hit');

/**
 * True or false to return the _source field or not, or a list of fields to return
 */
export const async_search_submit_source = global_search_types_source_config_param;

/**
 * A list of fields to exclude from the returned _source field
 */
export const async_search_submit_source_excludes = types_fields;

/**
 * A list of fields to extract and return from the _source field
 */
export const async_search_submit_source_includes = types_fields;

/**
 * Specify whether to return sequence number and primary term of the last modification of each hit
 */
export const async_search_submit_seq_no_primary_term = z.boolean().describe('Specify whether to return sequence number and primary term of the last modification of each hit');

/**
 * Query in the Lucene query string syntax
 */
export const async_search_submit_q = z.string().describe('Query in the Lucene query string syntax');

/**
 * Number of hits to return (default: 10)
 */
export const async_search_submit_size = z.number().describe('Number of hits to return (default: 10)');

/**
 * Starting offset (default: 0)
 */
export const async_search_submit_from = z.number().describe('Starting offset (default: 0)');

/**
 * A comma-separated list of <field>:<direction> pairs
 */
export const async_search_submit_sort = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * The name of the data stream, index, or index alias to perform bulk actions on.
 */
export const bulk_index = types_index_name;

/**
 * True or false if to include the document source in the error message in case of parsing errors.
 */
export const bulk_include_source_on_error = z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.');

/**
 * If `true`, the response will include the ingest pipelines that were run for each index or create.
 */
export const bulk_list_executed_pipelines = z.boolean().describe('If `true`, the response will include the ingest pipelines that were run for each index or create.');

/**
 * The pipeline identifier to use to preprocess incoming documents.
 * If the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.
 * If a final pipeline is configured, it will always run regardless of the value of this parameter.
 */
export const bulk_pipeline = z.string().describe('The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.');

/**
 * If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search.
 * If `wait_for`, wait for a refresh to make this operation visible to search.
 * If `false`, do nothing with refreshes.
 * Valid values: `true`, `false`, `wait_for`.
 */
export const bulk_refresh = types_refresh;

/**
 * A custom value that is used to route operations to a specific shard.
 */
export const bulk_routing = types_routing;

/**
 * Indicates whether to return the `_source` field (`true` or `false`) or contains a list of fields to return.
 */
export const bulk_source = global_search_types_source_config_param;

/**
 * A comma-separated list of source fields to exclude from the response.
 * You can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const bulk_source_excludes = types_fields;

/**
 * A comma-separated list of source fields to include in the response.
 * If this parameter is specified, only these source fields are returned.
 * You can exclude fields from this subset using the `_source_excludes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const bulk_source_includes = types_fields;

/**
 * The period each action waits for the following operations: automatic index creation, dynamic mapping updates, and waiting for active shards.
 * The default is `1m` (one minute), which guarantees Elasticsearch waits for at least the timeout before failing.
 * The actual wait time could be longer, particularly when multiple waits occur.
 */
export const bulk_timeout = types_duration;

/**
 * The number of shard copies that must be active before proceeding with the operation.
 * Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).
 * The default is `1`, which waits for each primary shard to be active.
 */
export const bulk_wait_for_active_shards = types_wait_for_active_shards;

/**
 * If `true`, the request's actions must target an index alias.
 */
export const bulk_require_alias = z.boolean().describe('If `true`, the request\'s actions must target an index alias.');

/**
 * If `true`, the request's actions must target a data stream (existing or to be created).
 */
export const bulk_require_data_stream = z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).');

/**
 * A comma-separated list of aliases to retrieve. Supports wildcards (`*`).  To retrieve all aliases, omit this parameter or use `*` or `_all`.
 */
export const cat_aliases_name = types_names;

/**
 * A comma-separated list of columns names to display. It supports simple wildcards.
 */
export const cat_aliases_h = cat_types_cat_aliases_columns;

/**
 * List of columns that determine how the table should be sorted.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_aliases_s = types_names;

/**
 * The type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * It supports comma-separated values, such as `open,hidden`.
 */
export const cat_aliases_expand_wildcards = types_expand_wildcards;

/**
 * The period to wait for a connection to the master node.
 * If the master node is not available before the timeout expires, the request fails and returns an error.
 * To indicated that the request should never timeout, you can set it to `-1`.
 */
export const cat_aliases_master_timeout = types_duration;

/**
 * A comma-separated list of node identifiers or names used to limit the returned information.
 */
export const cat_allocation_node_id = types_node_ids;

/**
 * A comma-separated list of columns names to display. It supports simple wildcards.
 */
export const cat_allocation_h = cat_types_cat_allocation_columns;

/**
 * List of columns that determine how the table should be sorted.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_allocation_s = types_names;

/**
 * If `true`, the request computes the list of selected nodes from the
 * local cluster state. If `false` the list of selected nodes are computed
 * from the cluster state of the master node. In both cases the coordinating
 * node will send requests for further information to each selected node.
 */
export const cat_allocation_local = z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.');

/**
 * Period to wait for a connection to the master node.
 */
export const cat_allocation_master_timeout = types_duration;

/**
 * The name of the component template.
 * It accepts wildcard expressions.
 * If it is omitted, all component templates are returned.
 */
export const cat_component_templates_name = z.string().describe('The name of the component template.\nIt accepts wildcard expressions.\nIf it is omitted, all component templates are returned.');

/**
 * A comma-separated list of columns names to display. It supports simple wildcards.
 */
export const cat_component_templates_h = cat_types_cat_component_columns;

/**
 * List of columns that determine how the table should be sorted.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_component_templates_s = types_names;

/**
 * If `true`, the request computes the list of selected nodes from the
 * local cluster state. If `false` the list of selected nodes are computed
 * from the cluster state of the master node. In both cases the coordinating
 * node will send requests for further information to each selected node.
 */
export const cat_component_templates_local = z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.');

/**
 * The period to wait for a connection to the master node.
 */
export const cat_component_templates_master_timeout = types_duration;

/**
 * A comma-separated list of data streams, indices, and aliases used to limit the request.
 * It supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const cat_count_index = types_indices;

/**
 * A comma-separated list of columns names to display. It supports simple wildcards.
 */
export const cat_count_h = cat_types_cat_count_columns;

/**
 * List of columns that determine how the table should be sorted.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_count_s = types_names;

/**
 * Comma-separated list of fields used to limit returned information.
 * To retrieve all fields, omit this parameter.
 */
export const cat_fielddata_fields = types_fields;

/**
 * Comma-separated list of fields used to limit returned information.
 */
export const cat_fielddata_fields2 = types_fields;

/**
 * A comma-separated list of columns names to display. It supports simple wildcards.
 */
export const cat_fielddata_h = cat_types_cat_field_data_columns;

/**
 * List of columns that determine how the table should be sorted.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_fielddata_s = types_names;

/**
 * Comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`). To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const cat_indices_index = types_indices;

/**
 * The type of index that wildcard patterns can match.
 */
export const cat_indices_expand_wildcards = types_expand_wildcards;

/**
 * The health status used to limit returned indices. By default, the response includes indices of any health status.
 */
export const cat_indices_health = types_health_status;

/**
 * If true, the response includes information from segments that are not loaded into memory.
 */
export const cat_indices_include_unloaded_segments = z.boolean().describe('If true, the response includes information from segments that are not loaded into memory.');

/**
 * If true, the response only includes information from primary shards.
 */
export const cat_indices_pri = z.boolean().describe('If true, the response only includes information from primary shards.');

/**
 * Period to wait for a connection to the master node.
 */
export const cat_indices_master_timeout = types_duration;

/**
 * A comma-separated list of columns names to display. It supports simple wildcards.
 */
export const cat_indices_h = cat_types_cat_indices_columns;

/**
 * List of columns that determine how the table should be sorted.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_indices_s = types_names;

/**
 * The ID of the data frame analytics to fetch
 */
export const cat_ml_data_frame_analytics_id = types_id;

/**
 * Whether to ignore if a wildcard expression matches no configs.
 * (This includes `_all` string or when no configs have been specified.)
 */
export const cat_ml_data_frame_analytics_allow_no_match = z.boolean().describe('Whether to ignore if a wildcard expression matches no configs.\n(This includes `_all` string or when no configs have been specified.)');

/**
 * Comma-separated list of column names to display.
 */
export const cat_ml_data_frame_analytics_h = cat_types_cat_dfa_columns;

/**
 * Comma-separated list of column names or column aliases used to sort the
 * response.
 */
export const cat_ml_data_frame_analytics_s = cat_types_cat_dfa_columns;

/**
 * A numerical character string that uniquely identifies the datafeed.
 */
export const cat_ml_datafeeds_datafeed_id = types_id;

/**
 * Specifies what to do when the request:
 *
 * * Contains wildcard expressions and there are no datafeeds that match.
 * * Contains the `_all` string or no identifiers and there are no matches.
 * * Contains wildcard expressions and there are only partial matches.
 *
 * If `true`, the API returns an empty datafeeds array when there are no matches and the subset of results when
 * there are partial matches. If `false`, the API returns a 404 status code when there are no matches or only
 * partial matches.
 */
export const cat_ml_datafeeds_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no datafeeds that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty datafeeds array when there are no matches and the subset of results when\nthere are partial matches. If `false`, the API returns a 404 status code when there are no matches or only\npartial matches.');

/**
 * Comma-separated list of column names to display.
 */
export const cat_ml_datafeeds_h = cat_types_cat_datafeed_columns;

/**
 * Comma-separated list of column names or column aliases used to sort the response.
 */
export const cat_ml_datafeeds_s = cat_types_cat_datafeed_columns;

/**
 * Identifier for the anomaly detection job.
 */
export const cat_ml_jobs_job_id = types_id;

/**
 * Specifies what to do when the request:
 *
 * * Contains wildcard expressions and there are no jobs that match.
 * * Contains the `_all` string or no identifiers and there are no matches.
 * * Contains wildcard expressions and there are only partial matches.
 *
 * If `true`, the API returns an empty jobs array when there are no matches and the subset of results when there
 * are partial matches. If `false`, the API returns a 404 status code when there are no matches or only partial
 * matches.
 */
export const cat_ml_jobs_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no jobs that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty jobs array when there are no matches and the subset of results when there\nare partial matches. If `false`, the API returns a 404 status code when there are no matches or only partial\nmatches.');

/**
 * Comma-separated list of column names to display.
 */
export const cat_ml_jobs_h = cat_types_cat_anomaly_detector_columns;

/**
 * Comma-separated list of column names or column aliases used to sort the response.
 */
export const cat_ml_jobs_s = cat_types_cat_anomaly_detector_columns;

/**
 * A unique identifier for the trained model.
 */
export const cat_ml_trained_models_model_id = types_id;

/**
 * Specifies what to do when the request: contains wildcard expressions and there are no models that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.
 * If `true`, the API returns an empty array when there are no matches and the subset of results when there are partial matches.
 * If `false`, the API returns a 404 status code when there are no matches or only partial matches.
 */
export const cat_ml_trained_models_allow_no_match = z.boolean().describe('Specifies what to do when the request: contains wildcard expressions and there are no models that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.\nIf `true`, the API returns an empty array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the API returns a 404 status code when there are no matches or only partial matches.');

/**
 * A comma-separated list of column names to display.
 */
export const cat_ml_trained_models_h = cat_types_cat_trained_models_columns;

/**
 * A comma-separated list of column names or aliases used to sort the response.
 */
export const cat_ml_trained_models_s = cat_types_cat_trained_models_columns;

/**
 * Skips the specified number of transforms.
 */
export const cat_ml_trained_models_from = z.number().describe('Skips the specified number of transforms.');

/**
 * The maximum number of transforms to display.
 */
export const cat_ml_trained_models_size = z.number().describe('The maximum number of transforms to display.');

/**
 * A comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`). To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const cat_recovery_index = types_indices;

/**
 * If `true`, the response only includes ongoing shard recoveries.
 */
export const cat_recovery_active_only = z.boolean().describe('If `true`, the response only includes ongoing shard recoveries.');

/**
 * If `true`, the response includes detailed information about shard recoveries.
 */
export const cat_recovery_detailed = z.boolean().describe('If `true`, the response includes detailed information about shard recoveries.');

/**
 * Comma-separated list or wildcard expression of index names to limit the returned information
 */
export const cat_recovery_index2 = types_indices;

/**
 * A comma-separated list of columns names to display.
 * It supports simple wildcards.
 */
export const cat_recovery_h = cat_types_cat_recovery_columns;

/**
 * A comma-separated list of column names or aliases that determines the sort order.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_recovery_s = types_names;

/**
 * A comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const cat_segments_index = types_indices;

/**
 * A comma-separated list of columns names to display.
 * It supports simple wildcards.
 */
export const cat_segments_h = cat_types_cat_segments_columns;

/**
 * A comma-separated list of column names or aliases that determines the sort order.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_segments_s = types_names;

/**
 * If `true`, the request computes the list of selected nodes from the
 * local cluster state. If `false` the list of selected nodes are computed
 * from the cluster state of the master node. In both cases the coordinating
 * node will send requests for further information to each selected node.
 */
export const cat_segments_local = z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.');

/**
 * Period to wait for a connection to the master node.
 */
export const cat_segments_master_timeout = types_duration;

/**
 * Type of index that wildcard expressions can match. If the request can target data streams, this argument
 * determines whether wildcard expressions match hidden data streams. Supports comma-separated values,
 * such as open,hidden.
 */
export const cat_segments_expand_wildcards = types_expand_wildcards;

/**
 * If false, the request returns an error if any wildcard expression, index alias, or _all value targets only
 * missing or closed indices. This behavior applies even if the request targets other open indices. For example,
 * a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.
 */
export const cat_segments_allow_no_indices = z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only\nmissing or closed indices. This behavior applies even if the request targets other open indices. For example,\na request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.');

/**
 * If true, concrete, expanded or aliased indices are ignored when frozen.
 */
export const cat_segments_ignore_throttled = z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.');

/**
 * If true, missing or closed indices are not included in the response.
 */
export const cat_segments_ignore_unavailable = z.boolean().describe('If true, missing or closed indices are not included in the response.');

/**
 * If true, allow closed indices to be returned in the response otherwise if false, keep the legacy behaviour
 * of throwing an exception if index pattern matches closed indices
 */
export const cat_segments_allow_closed = z.boolean().describe('If true, allow closed indices to be returned in the response otherwise if false, keep the legacy behaviour\nof throwing an exception if index pattern matches closed indices');

/**
 * A comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const cat_shards_index = types_indices;

/**
 * List of columns to appear in the response. Supports simple wildcards.
 */
export const cat_shards_h = cat_types_cat_shard_columns;

/**
 * A comma-separated list of column names or aliases that determines the sort order.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_shards_s = types_names;

/**
 * The period to wait for a connection to the master node.
 */
export const cat_shards_master_timeout = types_duration;

/**
 * A comma-separated list of snapshot repositories used to limit the request.
 * Accepts wildcard expressions.
 * `_all` returns all repositories.
 * If any repository fails during the request, Elasticsearch returns an error.
 */
export const cat_snapshots_repository = types_names;

/**
 * If `true`, the response does not include information from unavailable snapshots.
 */
export const cat_snapshots_ignore_unavailable = z.boolean().describe('If `true`, the response does not include information from unavailable snapshots.');

/**
 * A comma-separated list of columns names to display.
 * It supports simple wildcards.
 */
export const cat_snapshots_h = cat_types_cat_snapshots_columns;

/**
 * List of columns that determine how the table should be sorted.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_snapshots_s = types_names;

/**
 * Period to wait for a connection to the master node.
 */
export const cat_snapshots_master_timeout = types_duration;

/**
 * The name of the template to return.
 * Accepts wildcard expressions. If omitted, all templates are returned.
 */
export const cat_templates_name = types_name;

/**
 * A comma-separated list of columns names to display. It supports simple wildcards.
 */
export const cat_templates_h = cat_types_cat_templates_columns;

/**
 * List of columns that determine how the table should be sorted.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_templates_s = types_names;

/**
 * If `true`, the request computes the list of selected nodes from the
 * local cluster state. If `false` the list of selected nodes are computed
 * from the cluster state of the master node. In both cases the coordinating
 * node will send requests for further information to each selected node.
 */
export const cat_templates_local = z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.');

/**
 * Period to wait for a connection to the master node.
 */
export const cat_templates_master_timeout = types_duration;

/**
 * A comma-separated list of thread pool names used to limit the request.
 * Accepts wildcard expressions.
 */
export const cat_thread_pool_thread_pool_patterns = types_names;

/**
 * List of columns to appear in the response. Supports simple wildcards.
 */
export const cat_thread_pool_h = cat_types_cat_thread_pool_columns;

/**
 * A comma-separated list of column names or aliases that determines the sort order.
 * Sorting defaults to ascending and can be changed by setting `:asc`
 * or `:desc` as a suffix to the column name.
 */
export const cat_thread_pool_s = types_names;

/**
 * If `true`, the request computes the list of selected nodes from the
 * local cluster state. If `false` the list of selected nodes are computed
 * from the cluster state of the master node. In both cases the coordinating
 * node will send requests for further information to each selected node.
 */
export const cat_thread_pool_local = z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.');

/**
 * The period to wait for a connection to the master node.
 */
export const cat_thread_pool_master_timeout = types_duration;

/**
 * A transform identifier or a wildcard expression.
 * If you do not specify one of these options, the API returns information for all transforms.
 */
export const cat_transforms_transform_id = types_id;

/**
 * Specifies what to do when the request: contains wildcard expressions and there are no transforms that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.
 * If `true`, it returns an empty transforms array when there are no matches and the subset of results when there are partial matches.
 * If `false`, the request returns a 404 status code when there are no matches or only partial matches.
 */
export const cat_transforms_allow_no_match = z.boolean().describe('Specifies what to do when the request: contains wildcard expressions and there are no transforms that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.\nIf `true`, it returns an empty transforms array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.');

/**
 * Skips the specified number of transforms.
 */
export const cat_transforms_from = z.number().describe('Skips the specified number of transforms.');

/**
 * Comma-separated list of column names to display.
 */
export const cat_transforms_h = cat_types_cat_transform_columns;

/**
 * Comma-separated list of column names or column aliases used to sort the response.
 */
export const cat_transforms_s = cat_types_cat_transform_columns;

/**
 * The maximum number of transforms to obtain.
 */
export const cat_transforms_size = z.number().describe('The maximum number of transforms to obtain.');

/**
 * The auto-follow pattern collection that you want to retrieve.
 * If you do not specify a name, the API returns information for all collections.
 */
export const ccr_get_auto_follow_pattern_name = types_name;

/**
 * The period to wait for a connection to the master node.
 * If the master node is not available before the timeout expires, the request fails and returns an error.
 * It can also be set to `-1` to indicate that the request should never timeout.
 */
export const ccr_get_auto_follow_pattern_master_timeout = types_duration;

/**
 * A comma-separated list of scroll IDs to clear.
 * To clear all scroll IDs, use `_all`.
 * IMPORTANT: Scroll IDs can be long. It is recommended to specify scroll IDs in the request body parameter.
 *
 * @deprecated
 */
export const clear_scroll_scroll_id = types_scroll_ids;

/**
 * The name of the index that you would like an explanation for.
 */
export const cluster_allocation_explain_index = types_index_name;

/**
 * An identifier for the shard that you would like an explanation for.
 */
export const cluster_allocation_explain_shard = z.number().describe('An identifier for the shard that you would like an explanation for.');

/**
 * If true, returns an explanation for the primary shard for the specified shard ID.
 */
export const cluster_allocation_explain_primary = z.boolean().describe('If true, returns an explanation for the primary shard for the specified shard ID.');

/**
 * Explain a shard only if it is currently located on the specified node name or node ID.
 */
export const cluster_allocation_explain_current_node2 = types_node_id;

/**
 * If true, returns information about disk usage and shard sizes.
 */
export const cluster_allocation_explain_include_disk_info = z.boolean().describe('If true, returns information about disk usage and shard sizes.');

/**
 * If true, returns YES decisions in explanation.
 */
export const cluster_allocation_explain_include_yes_decisions = z.boolean().describe('If true, returns YES decisions in explanation.');

/**
 * Period to wait for a connection to the master node.
 */
export const cluster_allocation_explain_master_timeout = types_duration;

/**
 * Comma-separated list of component template names used to limit the request.
 * Wildcard (`*`) expressions are supported.
 */
export const cluster_get_component_template_name = types_name;

/**
 * If `true`, returns settings in flat format.
 */
export const cluster_get_component_template_flat_settings = z.boolean().describe('If `true`, returns settings in flat format.');

/**
 * Filter out results, for example to filter out sensitive information. Supports wildcards or full settings keys
 */
export const cluster_get_component_template_settings_filter = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * Return all default configurations for the component template (default: false)
 */
export const cluster_get_component_template_include_defaults = z.boolean().describe('Return all default configurations for the component template (default: false)');

/**
 * If `true`, the request retrieves information from the local node only.
 * If `false`, information is retrieved from the master node.
 *
 * @deprecated
 */
export const cluster_get_component_template_local = z.boolean().describe('If `true`, the request retrieves information from the local node only.\nIf `false`, information is retrieved from the master node.');

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const cluster_get_component_template_master_timeout = types_duration;

/**
 * Comma-separated list of data streams, indices, and index aliases used to limit the request. Wildcard expressions (`*`) are supported. To target all data streams and indices in a cluster, omit this parameter or use _all or `*`.
 */
export const cluster_health_index = types_indices;

/**
 * Whether to expand wildcard expression to concrete indices that are open, closed or both.
 */
export const cluster_health_expand_wildcards = types_expand_wildcards;

/**
 * Can be one of cluster, indices or shards. Controls the details level of the health information returned.
 */
export const cluster_health_level = types_level;

/**
 * If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.
 */
export const cluster_health_local = z.boolean().describe('If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.');

/**
 * Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.
 */
export const cluster_health_master_timeout = types_duration;

/**
 * Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.
 */
export const cluster_health_timeout = types_duration;

/**
 * A number controlling to how many active shards to wait for, all to wait for all shards in the cluster to be active, or 0 to not wait.
 */
export const cluster_health_wait_for_active_shards = types_wait_for_active_shards;

/**
 * Can be one of immediate, urgent, high, normal, low, languid. Wait until all currently queued events with the given priority are processed.
 */
export const cluster_health_wait_for_events = types_wait_for_events;

/**
 * The request waits until the specified number N of nodes is available. It also accepts >=N, <=N, >N and <N. Alternatively, it is possible to use ge(N), le(N), gt(N) and lt(N) notation.
 */
export const cluster_health_wait_for_nodes2 = cluster_health_wait_for_nodes;

/**
 * A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard initializations. Defaults to false, which means it will not wait for initializing shards.
 */
export const cluster_health_wait_for_no_initializing_shards = z.boolean().describe('A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard initializations. Defaults to false, which means it will not wait for initializing shards.');

/**
 * A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard relocations. Defaults to false, which means it will not wait for relocating shards.
 */
export const cluster_health_wait_for_no_relocating_shards = z.boolean().describe('A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard relocations. Defaults to false, which means it will not wait for relocating shards.');

/**
 * One of green, yellow or red. Will wait (until the timeout provided) until the status of the cluster changes to the one provided or better, i.e. green > yellow > red. By default, will not wait for any status.
 */
export const cluster_health_wait_for_status = types_health_status;

/**
 * Name of the component template to create.
 * Elasticsearch includes the following built-in component templates: `logs-mappings`; `logs-settings`; `metrics-mappings`; `metrics-settings`;`synthetics-mapping`; `synthetics-settings`.
 * Elastic Agent uses these templates to configure backing indices for its data streams.
 * If you use Elastic Agent and want to overwrite one of these templates, set the `version` for your replacement template higher than the current version.
 * If you dont use Elastic Agent and want to disable all built-in component and index templates, set `stack.templates.enabled` to `false` using the cluster update settings API.
 */
export const cluster_put_component_template_name = types_name;

/**
 * If `true`, this request cannot replace or update existing component templates.
 */
export const cluster_put_component_template_create = z.boolean().describe('If `true`, this request cannot replace or update existing component templates.');

/**
 * User defined reason for create the component template.
 */
export const cluster_put_component_template_cause = z.string().describe('User defined reason for create the component template.');

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const cluster_put_component_template_master_timeout = types_duration;

/**
 * Limit the information returned to the specified metrics
 */
export const cluster_state_metric = cluster_state_cluster_state_metrics;

/**
 * A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
 */
export const cluster_state_index = types_indices;

/**
 * Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
 */
export const cluster_state_allow_no_indices = z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)');

/**
 * Whether to expand wildcard expression to concrete indices that are open, closed or both.
 */
export const cluster_state_expand_wildcards = types_expand_wildcards;

/**
 * Return settings in flat format (default: false)
 */
export const cluster_state_flat_settings = z.boolean().describe('Return settings in flat format (default: false)');

/**
 * Whether specified concrete indices should be ignored when unavailable (missing or closed)
 */
export const cluster_state_ignore_unavailable = z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)');

/**
 * Return local information, do not retrieve the state from master node (default: false)
 *
 * @deprecated
 */
export const cluster_state_local = z.boolean().describe('Return local information, do not retrieve the state from master node (default: false)');

/**
 * Timeout for waiting for new cluster state in case it is blocked
 */
export const cluster_state_master_timeout = types_duration;

/**
 * Wait for the metadata version to be equal or greater than the specified metadata version
 */
export const cluster_state_wait_for_metadata_version = types_version_number;

/**
 * The maximum time to wait for wait_for_metadata_version before timing out
 */
export const cluster_state_wait_for_timeout = types_duration;

/**
 * Comma-separated list of node filters used to limit returned information. Defaults to all nodes in the cluster.
 */
export const cluster_stats_node_id = types_node_ids;

/**
 * Include remote cluster data into the response
 */
export const cluster_stats_include_remotes = z.boolean().describe('Include remote cluster data into the response');

/**
 * Period to wait for each node to respond.
 * If a node does not respond before its timeout expires, the response does not include its stats.
 * However, timed out nodes are included in the responses `_nodes.failed` property. Defaults to no timeout.
 */
export const cluster_stats_timeout = types_duration;

/**
 * The unique identifier of the connector to be created or updated. ID is auto-generated if not provided.
 */
export const connector_put_connector_id = types_id;

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 * To search all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const count_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 * For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const count_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.');

/**
 * The analyzer to use for the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const count_analyzer = z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * If `true`, wildcard and prefix queries are analyzed.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const count_analyze_wildcard = z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * The default operator for query string query: `and` or `or`.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const count_default_operator = types_query_dsl_operator;

/**
 * The field to use as a default when no field prefix is given in the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const count_df = z.string().describe('The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * The type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * It supports comma-separated values, such as `open,hidden`.
 */
export const count_expand_wildcards = types_expand_wildcards;

/**
 * If `true`, concrete, expanded, or aliased indices are ignored when frozen.
 *
 * @deprecated
 */
export const count_ignore_throttled = z.boolean().describe('If `true`, concrete, expanded, or aliased indices are ignored when frozen.');

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const count_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const count_lenient = z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * The minimum `_score` value that documents must have to be included in the result.
 */
export const count_min_score = z.number().describe('The minimum `_score` value that documents must have to be included in the result.');

/**
 * The node or shard the operation should be performed on.
 * By default, it is random.
 */
export const count_preference = z.string().describe('The node or shard the operation should be performed on.\nBy default, it is random.');

/**
 * A custom value used to route operations to a specific shard.
 */
export const count_routing = types_routing;

/**
 * The maximum number of documents to collect for each shard.
 * If a query reaches this limit, Elasticsearch terminates the query early.
 * Elasticsearch collects documents before sorting.
 *
 * IMPORTANT: Use with caution.
 * Elasticsearch applies this parameter to each shard handling the request.
 * When possible, let Elasticsearch perform early termination automatically.
 * Avoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.
 */
export const count_terminate_after = z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.');

/**
 * The query in Lucene query string syntax. This parameter cannot be used with a request body.
 */
export const count_q = z.string().describe('The query in Lucene query string syntax. This parameter cannot be used with a request body.');

/**
 * A unique identifier for the document.
 * To automatically generate a document ID, use the `POST /<target>/_doc/` request format.
 */
export const create_id = types_id;

/**
 * The name of the data stream or index to target.
 * If the target doesn't exist and matches the name or wildcard (`*`) pattern of an index template with a `data_stream` definition, this request creates the data stream.
 * If the target doesn't exist and doesnt match a data stream template, this request creates the index.
 */
export const create_index = types_index_name;

/**
 * True or false if to include the document source in the error message in case of parsing errors.
 */
export const create_include_source_on_error = z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.');

/**
 * The ID of the pipeline to use to preprocess incoming documents.
 * If the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.
 * If a final pipeline is configured, it will always run regardless of the value of this parameter.
 */
export const create_pipeline = z.string().describe('The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.');

/**
 * If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search.
 * If `wait_for`, it waits for a refresh to make this operation visible to search.
 * If `false`, it does nothing with refreshes.
 */
export const create_refresh = types_refresh;

/**
 * If `true`, the destination must be an index alias.
 */
export const create_require_alias = z.boolean().describe('If `true`, the destination must be an index alias.');

/**
 * If `true`, the request's actions must target a data stream (existing or to be created).
 */
export const create_require_data_stream = z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).');

/**
 * A custom value that is used to route operations to a specific shard.
 */
export const create_routing = types_routing;

/**
 * The period the request waits for the following operations: automatic index creation, dynamic mapping updates, waiting for active shards.
 * Elasticsearch waits for at least the specified timeout period before failing.
 * The actual wait time could be longer, particularly when multiple waits occur.
 *
 * This parameter is useful for situations where the primary shard assigned to perform the operation might not be available when the operation runs.
 * Some reasons for this might be that the primary shard is currently recovering from a gateway or undergoing relocation.
 * By default, the operation will wait on the primary shard to become available for at least 1 minute before failing and responding with an error.
 * The actual wait time could be longer, particularly when multiple waits occur.
 */
export const create_timeout = types_duration;

/**
 * The explicit version number for concurrency control.
 * It must be a non-negative long number.
 */
export const create_version = types_version_number;

/**
 * The version type.
 */
export const create_version_type = types_version_type;

/**
 * The number of shard copies that must be active before proceeding with the operation.
 * You can set it to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).
 * The default value of `1` means it waits for each primary shard to be active.
 */
export const create_wait_for_active_shards = types_wait_for_active_shards;

/**
 * Comma-separated list of enrich policy names used to limit the request.
 * To return information for all enrich policies, omit this parameter.
 */
export const enrich_get_policy_name = types_names;

/**
 * Period to wait for a connection to the master node.
 */
export const enrich_get_policy_master_timeout = types_duration;

/**
 * The name of the index to scope the operation
 */
export const eql_search_index = types_indices;

/**
 * Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
 */
export const eql_search_allow_no_indices = z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)');

/**
 * If true, returns partial results if there are shard failures. If false, returns an error with no partial results.
 */
export const eql_search_allow_partial_search_results = z.boolean().describe('If true, returns partial results if there are shard failures. If false, returns an error with no partial results.');

/**
 * If true, sequence queries will return partial results in case of shard failures. If false, they will return no results at all.
 * This flag has effect only if allow_partial_search_results is true.
 */
export const eql_search_allow_partial_sequence_results = z.boolean().describe('If true, sequence queries will return partial results in case of shard failures. If false, they will return no results at all.\nThis flag has effect only if allow_partial_search_results is true.');

/**
 * Whether to expand wildcard expression to concrete indices that are open, closed or both.
 */
export const eql_search_expand_wildcards = types_expand_wildcards;

/**
 * Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution
 */
export const eql_search_ccs_minimize_roundtrips = z.boolean().describe('Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution');

/**
 * If true, missing or closed indices are not included in the response.
 */
export const eql_search_ignore_unavailable = z.boolean().describe('If true, missing or closed indices are not included in the response.');

/**
 * Period for which the search and its results are stored on the cluster.
 */
export const eql_search_keep_alive = types_duration;

/**
 * If true, the search and its results are stored on the cluster.
 */
export const eql_search_keep_on_completion = z.boolean().describe('If true, the search and its results are stored on the cluster.');

/**
 * Timeout duration to wait for the request to finish. Defaults to no timeout, meaning the request waits for complete search results.
 */
export const eql_search_wait_for_completion_timeout = types_duration;

/**
 * The document identifier.
 */
export const explain_id = types_id;

/**
 * Index names that are used to limit the request.
 * Only a single index name can be provided to this parameter.
 */
export const explain_index = types_index_name;

/**
 * The analyzer to use for the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const explain_analyzer = z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * If `true`, wildcard and prefix queries are analyzed.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const explain_analyze_wildcard = z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * The default operator for query string query: `and` or `or`.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const explain_default_operator = types_query_dsl_operator;

/**
 * The field to use as default where no field prefix is given in the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const explain_df = z.string().describe('The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const explain_lenient = z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * The node or shard the operation should be performed on.
 * It is random by default.
 */
export const explain_preference = z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.');

/**
 * A custom value used to route operations to a specific shard.
 */
export const explain_routing = types_routing;

/**
 * `True` or `false` to return the `_source` field or not or a list of fields to return.
 */
export const explain_source = global_search_types_source_config_param;

/**
 * A comma-separated list of source fields to exclude from the response.
 * You can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const explain_source_excludes = types_fields;

/**
 * A comma-separated list of source fields to include in the response.
 * If this parameter is specified, only these source fields are returned.
 * You can exclude fields from this subset using the `_source_excludes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const explain_source_includes = types_fields;

/**
 * A comma-separated list of stored fields to return in the response.
 */
export const explain_stored_fields = types_fields;

/**
 * The query in the Lucene query string syntax.
 */
export const explain_q = z.string().describe('The query in the Lucene query string syntax.');

/**
 * A comma-separated list of data streams, indices, and aliases used to limit the request. Supports wildcards (*). To target all data streams and indices, omit this parameter or use * or _all.
 */
export const field_caps_index = types_indices;

/**
 * If false, the request returns an error if any wildcard expression, index alias,
 * or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request
 * targeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar.
 */
export const field_caps_allow_no_indices = z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar.');

/**
 * The type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`.
 */
export const field_caps_expand_wildcards = types_expand_wildcards;

/**
 * A comma-separated list of fields to retrieve capabilities for. Wildcard (`*`) expressions are supported.
 */
export const field_caps_fields = types_fields;

/**
 * If `true`, missing or closed indices are not included in the response.
 */
export const field_caps_ignore_unavailable = z.boolean().describe('If `true`, missing or closed indices are not included in the response.');

/**
 * If true, unmapped fields are included in the response.
 */
export const field_caps_include_unmapped = z.boolean().describe('If true, unmapped fields are included in the response.');

/**
 * A comma-separated list of filters to apply to the response.
 */
export const field_caps_filters = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * A comma-separated list of field types to include.
 * Any fields that do not match one of these types will be excluded from the results.
 * It defaults to empty, meaning that all field types are returned.
 */
export const field_caps_types = z.array(z.string()).describe('A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned.');

/**
 * If false, empty fields are not included in the response.
 */
export const field_caps_include_empty_fields = z.boolean().describe('If false, empty fields are not included in the response.');

/**
 * A single target to search. If the target is an index alias, it must resolve to a single index.
 */
export const fleet_msearch_index = z.union([
    types_index_name,
    types_index_alias
]);

/**
 * If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.
 */
export const fleet_msearch_allow_no_indices = z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.');

/**
 * If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.
 */
export const fleet_msearch_ccs_minimize_roundtrips = z.boolean().describe('If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.');

/**
 * Type of index that wildcard expressions can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 */
export const fleet_msearch_expand_wildcards = types_expand_wildcards;

/**
 * If true, concrete, expanded or aliased indices are ignored when frozen.
 */
export const fleet_msearch_ignore_throttled = z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.');

/**
 * If true, missing or closed indices are not included in the response.
 */
export const fleet_msearch_ignore_unavailable = z.boolean().describe('If true, missing or closed indices are not included in the response.');

/**
 * Maximum number of concurrent searches the multi search API can execute.
 */
export const fleet_msearch_max_concurrent_searches = z.number().describe('Maximum number of concurrent searches the multi search API can execute.');

/**
 * Maximum number of concurrent shard requests that each sub-search request executes per node.
 */
export const fleet_msearch_max_concurrent_shard_requests = z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.');

/**
 * Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.
 */
export const fleet_msearch_pre_filter_shard_size = z.number().describe('Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.');

/**
 * Indicates whether global term and document frequencies should be used when scoring returned documents.
 */
export const fleet_msearch_search_type = types_search_type;

/**
 * If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.
 */
export const fleet_msearch_rest_total_hits_as_int = z.boolean().describe('If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.');

/**
 * Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.
 */
export const fleet_msearch_typed_keys = z.boolean().describe('Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.');

/**
 * A comma separated list of checkpoints. When configured, the search API will only be executed on a shard
 * after the relevant checkpoint has become visible for search. Defaults to an empty list which will cause
 * Elasticsearch to immediately execute the search.
 */
export const fleet_msearch_wait_for_checkpoints = z.array(fleet_types_checkpoint).describe('A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.');

/**
 * If true, returns partial results if there are shard request timeouts or shard failures.
 * If false, returns an error with no partial results.
 * Defaults to the configured cluster setting `search.default_allow_partial_results`, which is true by default.
 */
export const fleet_msearch_allow_partial_search_results = z.boolean().describe('If true, returns partial results if there are shard request timeouts or shard failures.\nIf false, returns an error with no partial results.\nDefaults to the configured cluster setting `search.default_allow_partial_results`, which is true by default.');

/**
 * A single target to search. If the target is an index alias, it must resolve to a single index.
 */
export const fleet_search_index = z.union([
    types_index_name,
    types_index_alias
]);

export const fleet_search_allow_no_indices = z.boolean();

export const fleet_search_analyzer = z.string();

export const fleet_search_analyze_wildcard = z.boolean();

export const fleet_search_batched_reduce_size = z.number();

export const fleet_search_ccs_minimize_roundtrips = z.boolean();

export const fleet_search_default_operator = types_query_dsl_operator;

export const fleet_search_df = z.string();

export const fleet_search_docvalue_fields = types_fields;

export const fleet_search_expand_wildcards = types_expand_wildcards;

export const fleet_search_explain = z.boolean();

export const fleet_search_ignore_throttled = z.boolean();

export const fleet_search_ignore_unavailable = z.boolean();

export const fleet_search_lenient = z.boolean();

export const fleet_search_max_concurrent_shard_requests = z.number();

export const fleet_search_preference = z.string();

export const fleet_search_pre_filter_shard_size = z.number();

export const fleet_search_request_cache = z.boolean();

export const fleet_search_routing = types_routing;

export const fleet_search_scroll = types_duration;

export const fleet_search_search_type = types_search_type;

export const fleet_search_stats = z.array(z.string());

export const fleet_search_stored_fields = types_fields;

/**
 * Specifies which field to use for suggestions.
 */
export const fleet_search_suggest_field = types_field;

export const fleet_search_suggest_mode = types_suggest_mode;

export const fleet_search_suggest_size = z.number();

/**
 * The source text for which the suggestions should be returned.
 */
export const fleet_search_suggest_text = z.string().describe('The source text for which the suggestions should be returned.');

export const fleet_search_terminate_after = z.number();

export const fleet_search_timeout = types_duration;

export const fleet_search_track_total_hits = global_search_types_track_hits;

export const fleet_search_track_scores = z.boolean();

export const fleet_search_typed_keys = z.boolean();

export const fleet_search_rest_total_hits_as_int = z.boolean();

export const fleet_search_version = z.boolean();

export const fleet_search_source = global_search_types_source_config_param;

export const fleet_search_source_excludes = types_fields;

export const fleet_search_source_includes = types_fields;

export const fleet_search_seq_no_primary_term = z.boolean();

export const fleet_search_q = z.string();

export const fleet_search_size = z.number();

export const fleet_search_from = z.number();

export const fleet_search_sort = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * A comma separated list of checkpoints. When configured, the search API will only be executed on a shard
 * after the relevant checkpoint has become visible for search. Defaults to an empty list which will cause
 * Elasticsearch to immediately execute the search.
 */
export const fleet_search_wait_for_checkpoints = z.array(fleet_types_checkpoint).describe('A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.');

/**
 * If true, returns partial results if there are shard request timeouts or shard failures.
 * If false, returns an error with no partial results.
 * Defaults to the configured cluster setting `search.default_allow_partial_results`, which is true by default.
 */
export const fleet_search_allow_partial_search_results = z.boolean().describe('If true, returns partial results if there are shard request timeouts or shard failures.\nIf false, returns an error with no partial results.\nDefaults to the configured cluster setting `search.default_allow_partial_results`, which is true by default.');

/**
 * Name of the index.
 */
export const graph_explore_index = types_indices;

/**
 * Custom value used to route operations to a specific shard.
 */
export const graph_explore_routing = types_routing;

/**
 * Specifies the period of time to wait for a response from each shard.
 * If no response is received before the timeout expires, the request fails and returns an error.
 * Defaults to no timeout.
 */
export const graph_explore_timeout = types_duration;

/**
 * A feature of the cluster, as returned by the top-level health report API.
 */
export const health_report_feature = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * Explicit operation timeout.
 */
export const health_report_timeout = types_duration;

/**
 * Opt-in for more information about the health of the system.
 */
export const health_report_verbose = z.boolean().describe('Opt-in for more information about the health of the system.');

/**
 * Limit the number of affected resources the health report API returns.
 */
export const health_report_size = z.number().describe('Limit the number of affected resources the health report API returns.');

/**
 * Identifier for the policy.
 */
export const ilm_get_lifecycle_policy = types_name;

/**
 * Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.
 */
export const ilm_get_lifecycle_master_timeout = types_duration;

/**
 * Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.
 */
export const ilm_get_lifecycle_timeout = types_duration;

/**
 * A unique identifier for the document.
 * To automatically generate a document ID, use the `POST /<target>/_doc/` request format and omit this parameter.
 */
export const index_id = types_id;

/**
 * The name of the data stream or index to target.
 * If the target doesn't exist and matches the name or wildcard (`*`) pattern of an index template with a `data_stream` definition, this request creates the data stream.
 * If the target doesn't exist and doesn't match a data stream template, this request creates the index.
 * You can check for existing targets with the resolve index API.
 */
export const index_index = types_index_name;

/**
 * Only perform the operation if the document has this primary term.
 */
export const index_if_primary_term = z.number().describe('Only perform the operation if the document has this primary term.');

/**
 * Only perform the operation if the document has this sequence number.
 */
export const index_if_seq_no = types_sequence_number;

/**
 * True or false if to include the document source in the error message in case of parsing errors.
 */
export const index_include_source_on_error = z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.');

/**
 * Set to `create` to only index the document if it does not already exist (put if absent).
 * If a document with the specified `_id` already exists, the indexing operation will fail.
 * The behavior is the same as using the `<index>/_create` endpoint.
 * If a document ID is specified, this paramater defaults to `index`.
 * Otherwise, it defaults to `create`.
 * If the request targets a data stream, an `op_type` of `create` is required.
 */
export const index_op_type = types_op_type;

/**
 * The ID of the pipeline to use to preprocess incoming documents.
 * If the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.
 * If a final pipeline is configured it will always run, regardless of the value of this parameter.
 */
export const index_pipeline = z.string().describe('The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.');

/**
 * If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search.
 * If `wait_for`, it waits for a refresh to make this operation visible to search.
 * If `false`, it does nothing with refreshes.
 */
export const index_refresh = types_refresh;

/**
 * A custom value that is used to route operations to a specific shard.
 */
export const index_routing = types_routing;

/**
 * The period the request waits for the following operations: automatic index creation, dynamic mapping updates, waiting for active shards.
 *
 * This parameter is useful for situations where the primary shard assigned to perform the operation might not be available when the operation runs.
 * Some reasons for this might be that the primary shard is currently recovering from a gateway or undergoing relocation.
 * By default, the operation will wait on the primary shard to become available for at least 1 minute before failing and responding with an error.
 * The actual wait time could be longer, particularly when multiple waits occur.
 */
export const index_timeout = types_duration;

/**
 * An explicit version number for concurrency control.
 * It must be a non-negative long number.
 */
export const index_version = types_version_number;

/**
 * The version type.
 */
export const index_version_type = types_version_type;

/**
 * The number of shard copies that must be active before proceeding with the operation.
 * You can set it to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).
 * The default value of `1` means it waits for each primary shard to be active.
 */
export const index_wait_for_active_shards = types_wait_for_active_shards;

/**
 * If `true`, the destination must be an index alias.
 */
export const index_require_alias = z.boolean().describe('If `true`, the destination must be an index alias.');

/**
 * If `true`, the request's actions must target a data stream (existing or to be created).
 */
export const index_require_data_stream = z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).');

/**
 * Index used to derive the analyzer.
 * If specified, the `analyzer` or field parameter overrides this value.
 * If no index is specified or the index does not have a default analyzer, the analyze API uses the standard analyzer.
 */
export const indices_analyze_index = types_index_name;

/**
 * Index used to derive the analyzer.
 * If specified, the `analyzer` or field parameter overrides this value.
 * If no index is specified or the index does not have a default analyzer, the analyze API uses the standard analyzer.
 */
export const indices_analyze_index2 = types_index_name;

/**
 * Comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const indices_clear_cache_index = types_indices;

/**
 * Comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const indices_clear_cache_index2 = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_clear_cache_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_clear_cache_expand_wildcards = types_expand_wildcards;

/**
 * If `true`, clears the fields cache.
 * Use the `fields` parameter to clear the cache of specific fields only.
 */
export const indices_clear_cache_fielddata = z.boolean().describe('If `true`, clears the fields cache.\nUse the `fields` parameter to clear the cache of specific fields only.');

/**
 * Comma-separated list of field names used to limit the `fielddata` parameter.
 */
export const indices_clear_cache_fields = types_fields;

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_clear_cache_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * If `true`, clears the query cache.
 */
export const indices_clear_cache_query = z.boolean().describe('If `true`, clears the query cache.');

/**
 * If `true`, clears the request cache.
 */
export const indices_clear_cache_request = z.boolean().describe('If `true`, clears the request cache.');

/**
 * Name of the source index to clone.
 */
export const indices_clone_index = types_index_name;

/**
 * Name of the target index to create.
 */
export const indices_clone_target = types_name;

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_clone_master_timeout = types_duration;

/**
 * Period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_clone_timeout = types_duration;

/**
 * The number of shard copies that must be active before proceeding with the operation.
 * Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).
 */
export const indices_clone_wait_for_active_shards = types_wait_for_active_shards;

/**
 * The source index or data stream name
 */
export const indices_create_from_source = types_index_name;

/**
 * The destination index or data stream name
 */
export const indices_create_from_dest = types_index_name;

/**
 * Comma-separated list of data streams used to limit the request.
 * Wildcard expressions (`*`) are supported.
 * To target all data streams in a cluster, omit this parameter or use `*`.
 */
export const indices_data_streams_stats_name = types_indices;

/**
 * Type of data stream that wildcard patterns can match.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_data_streams_stats_expand_wildcards = types_expand_wildcards;

/**
 * Comma-separated list of data streams or indices used to limit the request.
 * Supports wildcards (`*`).
 */
export const indices_delete_alias_index = types_indices;

/**
 * Comma-separated list of aliases to remove.
 * Supports wildcards (`*`). To remove all aliases, use `*` or `_all`.
 */
export const indices_delete_alias_name = types_names;

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_delete_alias_master_timeout = types_duration;

/**
 * Period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_delete_alias_timeout = types_duration;

/**
 * Comma-separated list of aliases to check. Supports wildcards (`*`).
 */
export const indices_exists_alias_name = types_names;

/**
 * Comma-separated list of data streams or indices used to limit the request. Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const indices_exists_alias_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_exists_alias_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_exists_alias_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, requests that include a missing data stream or index in the target indices or data streams return an error.
 */
export const indices_exists_alias_ignore_unavailable = z.boolean().describe('If `false`, requests that include a missing data stream or index in the target indices or data streams return an error.');

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_exists_alias_master_timeout = types_duration;

/**
 * Comma-separated list of data streams, indices, and aliases to flush.
 * Supports wildcards (`*`).
 * To flush all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const indices_flush_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_flush_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_flush_expand_wildcards = types_expand_wildcards;

/**
 * If `true`, the request forces a flush even if there are no changes to commit to the index.
 */
export const indices_flush_force = z.boolean().describe('If `true`, the request forces a flush even if there are no changes to commit to the index.');

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_flush_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * If `true`, the flush operation blocks until execution when another flush operation is running.
 * If `false`, Elasticsearch returns an error if you request a flush when another flush operation is running.
 */
export const indices_flush_wait_if_ongoing = z.boolean().describe('If `true`, the flush operation blocks until execution when another flush operation is running.\nIf `false`, Elasticsearch returns an error if you request a flush when another flush operation is running.');

/**
 * A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
 */
export const indices_forcemerge_index = types_indices;

/**
 * Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
 */
export const indices_forcemerge_allow_no_indices = z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)');

/**
 * Whether to expand wildcard expression to concrete indices that are open, closed or both.
 */
export const indices_forcemerge_expand_wildcards = types_expand_wildcards;

/**
 * Specify whether the index should be flushed after performing the operation (default: true)
 */
export const indices_forcemerge_flush = z.boolean().describe('Specify whether the index should be flushed after performing the operation (default: true)');

/**
 * Whether specified concrete indices should be ignored when unavailable (missing or closed)
 */
export const indices_forcemerge_ignore_unavailable = z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)');

/**
 * The number of segments the index should be merged into (default: dynamic)
 */
export const indices_forcemerge_max_num_segments = z.number().describe('The number of segments the index should be merged into (default: dynamic)');

/**
 * Specify whether the operation should only expunge deleted documents
 */
export const indices_forcemerge_only_expunge_deletes = z.boolean().describe('Specify whether the operation should only expunge deleted documents');

/**
 * Should the request wait until the force merge is completed.
 */
export const indices_forcemerge_wait_for_completion = z.boolean().describe('Should the request wait until the force merge is completed.');

/**
 * Comma-separated list of aliases to retrieve.
 * Supports wildcards (`*`).
 * To retrieve all aliases, omit this parameter or use `*` or `_all`.
 */
export const indices_get_alias_name = types_names;

/**
 * Comma-separated list of data streams or indices used to limit the request.
 * Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const indices_get_alias_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_get_alias_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_get_alias_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_get_alias_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_get_alias_master_timeout = types_duration;

/**
 * Comma-separated list of data stream names used to limit the request.
 * Wildcard (`*`) expressions are supported. If omitted, all data streams are returned.
 */
export const indices_get_data_stream_name = types_data_stream_names;

/**
 * Type of data stream that wildcard patterns can match.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_get_data_stream_expand_wildcards = types_expand_wildcards;

/**
 * If true, returns all relevant default configurations for the index template.
 */
export const indices_get_data_stream_include_defaults = z.boolean().describe('If true, returns all relevant default configurations for the index template.');

/**
 * Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_get_data_stream_master_timeout = types_duration;

/**
 * Whether the maximum timestamp for each data stream should be calculated and returned.
 */
export const indices_get_data_stream_verbose = z.boolean().describe('Whether the maximum timestamp for each data stream should be calculated and returned.');

/**
 * Comma-separated list or wildcard expression of fields used to limit returned information.
 * Supports wildcards (`*`).
 */
export const indices_get_field_mapping_fields = types_fields;

/**
 * Comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const indices_get_field_mapping_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_get_field_mapping_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_get_field_mapping_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_get_field_mapping_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * If `true`, return all default settings in the response.
 */
export const indices_get_field_mapping_include_defaults = z.boolean().describe('If `true`, return all default settings in the response.');

/**
 * Name of index template to retrieve. Wildcard (*) expressions are supported.
 */
export const indices_get_index_template_name = types_name;

/**
 * If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.
 *
 * @deprecated
 */
export const indices_get_index_template_local = z.boolean().describe('If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.');

/**
 * If true, returns settings in flat format.
 */
export const indices_get_index_template_flat_settings = z.boolean().describe('If true, returns settings in flat format.');

/**
 * Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_get_index_template_master_timeout = types_duration;

/**
 * If true, returns all relevant default configurations for the index template.
 */
export const indices_get_index_template_include_defaults = z.boolean().describe('If true, returns all relevant default configurations for the index template.');

/**
 * Comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const indices_get_mapping_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_get_mapping_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_get_mapping_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_get_mapping_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * If `true`, the request retrieves information from the local node only.
 *
 * @deprecated
 */
export const indices_get_mapping_local = z.boolean().describe('If `true`, the request retrieves information from the local node only.');

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_get_mapping_master_timeout = types_duration;

/**
 * Comma-separated list of data streams, indices, and aliases used to limit
 * the request. Supports wildcards (`*`). To target all data streams and
 * indices, omit this parameter or use `*` or `_all`.
 */
export const indices_get_settings_index = types_indices;

/**
 * Comma-separated list or wildcard expression of settings to retrieve.
 */
export const indices_get_settings_name = types_names;

/**
 * If `false`, the request returns an error if any wildcard expression, index
 * alias, or `_all` value targets only missing or closed indices. This
 * behavior applies even if the request targets other open indices. For
 * example, a request targeting `foo*,bar*` returns an error if an index
 * starts with foo but no index starts with `bar`.
 */
export const indices_get_settings_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with foo but no index starts with `bar`.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_get_settings_expand_wildcards = types_expand_wildcards;

/**
 * If `true`, returns settings in flat format.
 */
export const indices_get_settings_flat_settings = z.boolean().describe('If `true`, returns settings in flat format.');

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_get_settings_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * If `true`, return all default settings in the response.
 */
export const indices_get_settings_include_defaults = z.boolean().describe('If `true`, return all default settings in the response.');

/**
 * If `true`, the request retrieves information from the local node only. If
 * `false`, information is retrieved from the master node.
 *
 * @deprecated
 */
export const indices_get_settings_local = z.boolean().describe('If `true`, the request retrieves information from the local node only. If\n`false`, information is retrieved from the master node.');

/**
 * Period to wait for a connection to the master node. If no response is
 * received before the timeout expires, the request fails and returns an
 * error.
 */
export const indices_get_settings_master_timeout = types_duration;

/**
 * Comma-separated list of index template names used to limit the request.
 * Wildcard (`*`) expressions are supported.
 * To return all index templates, omit this parameter or use a value of `_all` or `*`.
 */
export const indices_get_template_name = types_names;

/**
 * If `true`, returns settings in flat format.
 */
export const indices_get_template_flat_settings = z.boolean().describe('If `true`, returns settings in flat format.');

/**
 * If `true`, the request retrieves information from the local node only.
 *
 * @deprecated
 */
export const indices_get_template_local = z.boolean().describe('If `true`, the request retrieves information from the local node only.');

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_get_template_master_timeout = types_duration;

/**
 * Comma-separated list of data streams or indices to add.
 * Supports wildcards (`*`).
 * Wildcard patterns that match both data streams and indices return an error.
 */
export const indices_put_alias_index = types_indices;

/**
 * Alias to update.
 * If the alias doesnt exist, the request creates it.
 * Index alias names support date math.
 */
export const indices_put_alias_name = types_name;

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_put_alias_master_timeout = types_duration;

/**
 * Period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_put_alias_timeout = types_duration;

/**
 * Index or template name
 */
export const indices_put_index_template_name = types_name;

/**
 * If `true`, this request cannot replace or update existing index templates.
 */
export const indices_put_index_template_create = z.boolean().describe('If `true`, this request cannot replace or update existing index templates.');

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_put_index_template_master_timeout = types_duration;

/**
 * User defined reason for creating/updating the index template
 */
export const indices_put_index_template_cause = z.string().describe('User defined reason for creating/updating the index template');

/**
 * A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
 */
export const indices_put_mapping_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_put_mapping_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_put_mapping_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_put_mapping_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_put_mapping_master_timeout = types_duration;

/**
 * Period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_put_mapping_timeout = types_duration;

/**
 * If `true`, the mappings are applied only to the current write index for the target.
 */
export const indices_put_mapping_write_index_only = z.boolean().describe('If `true`, the mappings are applied only to the current write index for the target.');

/**
 * Comma-separated list of data streams, indices, and aliases used to limit
 * the request. Supports wildcards (`*`). To target all data streams and
 * indices, omit this parameter or use `*` or `_all`.
 */
export const indices_put_settings_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index
 * alias, or `_all` value targets only missing or closed indices. This
 * behavior applies even if the request targets other open indices. For
 * example, a request targeting `foo*,bar*` returns an error if an index
 * starts with `foo` but no index starts with `bar`.
 */
export const indices_put_settings_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with `foo` but no index starts with `bar`.');

/**
 * Type of index that wildcard patterns can match. If the request can target
 * data streams, this argument determines whether wildcard expressions match
 * hidden data streams. Supports comma-separated values, such as
 * `open,hidden`.
 */
export const indices_put_settings_expand_wildcards = types_expand_wildcards;

/**
 * If `true`, returns settings in flat format.
 */
export const indices_put_settings_flat_settings = z.boolean().describe('If `true`, returns settings in flat format.');

/**
 * If `true`, returns settings in flat format.
 */
export const indices_put_settings_ignore_unavailable = z.boolean().describe('If `true`, returns settings in flat format.');

/**
 * Period to wait for a connection to the master node. If no response is
 * received before the timeout expires, the request fails and returns an
 * error.
 */
export const indices_put_settings_master_timeout = types_duration;

/**
 * If `true`, existing index settings remain unchanged.
 */
export const indices_put_settings_preserve_existing = z.boolean().describe('If `true`, existing index settings remain unchanged.');

/**
 * Whether to close and reopen the index to apply non-dynamic settings.
 * If set to `true` the indices to which the settings are being applied
 * will be closed temporarily and then reopened in order to apply the changes.
 */
export const indices_put_settings_reopen = z.boolean().describe('Whether to close and reopen the index to apply non-dynamic settings.\nIf set to `true` the indices to which the settings are being applied\nwill be closed temporarily and then reopened in order to apply the changes.');

/**
 * Period to wait for a response. If no response is received before the
 * timeout expires, the request fails and returns an error.
 */
export const indices_put_settings_timeout = types_duration;

/**
 * The name of the template
 */
export const indices_put_template_name = types_name;

/**
 * If true, this request cannot replace or update existing index templates.
 */
export const indices_put_template_create = z.boolean().describe('If true, this request cannot replace or update existing index templates.');

/**
 * Period to wait for a connection to the master node. If no response is
 * received before the timeout expires, the request fails and returns an error.
 */
export const indices_put_template_master_timeout = types_duration;

/**
 * Order in which Elasticsearch applies this template if index
 * matches multiple templates.
 *
 * Templates with lower 'order' values are merged first. Templates with higher
 * 'order' values are merged later, overriding templates with lower values.
 */
export const indices_put_template_order = z.number().describe('Order in which Elasticsearch applies this template if index\nmatches multiple templates.\n\nTemplates with lower \'order\' values are merged first. Templates with higher\n\'order\' values are merged later, overriding templates with lower values.');

/**
 * User defined reason for creating/updating the index template
 */
export const indices_put_template_cause = z.string().describe('User defined reason for creating/updating the index template');

/**
 * Comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const indices_recovery_index = types_indices;

/**
 * If `true`, the response only includes ongoing shard recoveries.
 */
export const indices_recovery_active_only = z.boolean().describe('If `true`, the response only includes ongoing shard recoveries.');

/**
 * If `true`, the response includes detailed information about shard recoveries.
 */
export const indices_recovery_detailed = z.boolean().describe('If `true`, the response includes detailed information about shard recoveries.');

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_recovery_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_recovery_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_recovery_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * Comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const indices_refresh_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_refresh_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_refresh_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_refresh_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * A comma-separated list of index names to reload analyzers for
 */
export const indices_reload_search_analyzers_index = types_indices;

/**
 * Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
 */
export const indices_reload_search_analyzers_allow_no_indices = z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)');

/**
 * Whether to expand wildcard expression to concrete indices that are open, closed or both.
 */
export const indices_reload_search_analyzers_expand_wildcards = types_expand_wildcards;

/**
 * Whether specified concrete indices should be ignored when unavailable (missing or closed)
 */
export const indices_reload_search_analyzers_ignore_unavailable = z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)');

/**
 * Changed resource to reload analyzers from if applicable
 */
export const indices_reload_search_analyzers_resource = z.string().describe('Changed resource to reload analyzers from if applicable');

/**
 * A comma-separated list of names or index patterns for the indices, aliases, and data streams to resolve.
 * Resources on remote clusters can be specified using the `<cluster>`:`<name>` syntax.
 * Index and cluster exclusions (e.g., `-cluster1:*`) are also supported.
 * If no index expression is specified, information about all remote clusters configured on the local cluster
 * is returned without doing any index matching
 */
export const indices_resolve_cluster_name = types_names;

/**
 * If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing
 * or closed indices. This behavior applies even if the request targets other open indices. For example, a request
 * targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 * NOTE: This option is only supported when specifying an index expression. You will get an error if you specify index
 * options to the `_resolve/cluster` API endpoint that takes no index expression.
 */
export const indices_resolve_cluster_allow_no_indices = z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing\nor closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.\nNOTE: This option is only supported when specifying an index expression. You will get an error if you specify index\noptions to the `_resolve/cluster` API endpoint that takes no index expression.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 * NOTE: This option is only supported when specifying an index expression. You will get an error if you specify index
 * options to the `_resolve/cluster` API endpoint that takes no index expression.
 */
export const indices_resolve_cluster_expand_wildcards = types_expand_wildcards;

/**
 * If true, concrete, expanded, or aliased indices are ignored when frozen.
 * NOTE: This option is only supported when specifying an index expression. You will get an error if you specify index
 * options to the `_resolve/cluster` API endpoint that takes no index expression.
 *
 * @deprecated
 */
export const indices_resolve_cluster_ignore_throttled = z.boolean().describe('If true, concrete, expanded, or aliased indices are ignored when frozen.\nNOTE: This option is only supported when specifying an index expression. You will get an error if you specify index\noptions to the `_resolve/cluster` API endpoint that takes no index expression.');

/**
 * If false, the request returns an error if it targets a missing or closed index.
 * NOTE: This option is only supported when specifying an index expression. You will get an error if you specify index
 * options to the `_resolve/cluster` API endpoint that takes no index expression.
 */
export const indices_resolve_cluster_ignore_unavailable = z.boolean().describe('If false, the request returns an error if it targets a missing or closed index.\nNOTE: This option is only supported when specifying an index expression. You will get an error if you specify index\noptions to the `_resolve/cluster` API endpoint that takes no index expression.');

/**
 * The maximum time to wait for remote clusters to respond.
 * If a remote cluster does not respond within this timeout period, the API response
 * will show the cluster as not connected and include an error message that the
 * request timed out.
 *
 * The default timeout is unset and the query can take
 * as long as the networking layer is configured to wait for remote clusters that are
 * not responding (typically 30 seconds).
 */
export const indices_resolve_cluster_timeout = types_duration;

/**
 * Name of the data stream or index alias to roll over.
 */
export const indices_rollover_alias = types_index_alias;

/**
 * Name of the index to create.
 * Supports date math.
 * Data streams do not support this parameter.
 */
export const indices_rollover_new_index = types_index_name;

/**
 * If `true`, checks whether the current index satisfies the specified conditions but does not perform a rollover.
 */
export const indices_rollover_dry_run = z.boolean().describe('If `true`, checks whether the current index satisfies the specified conditions but does not perform a rollover.');

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_rollover_master_timeout = types_duration;

/**
 * Period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_rollover_timeout = types_duration;

/**
 * The number of shard copies that must be active before proceeding with the operation.
 * Set to all or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).
 */
export const indices_rollover_wait_for_active_shards = types_wait_for_active_shards;

/**
 * If set to true, the rollover action will only mark a data stream to signal that it needs to be rolled over at the next write.
 * Only allowed on data streams.
 */
export const indices_rollover_lazy = z.boolean().describe('If set to true, the rollover action will only mark a data stream to signal that it needs to be rolled over at the next write.\nOnly allowed on data streams.');

/**
 * Comma-separated list of data streams, indices, and aliases used to limit the request.
 * Supports wildcards (`*`).
 * To target all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const indices_segments_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_segments_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_segments_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_segments_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * List of data streams, indices, and aliases used to limit the request.
 */
export const indices_shard_stores_index = types_indices;

/**
 * If false, the request returns an error if any wildcard expression, index alias, or _all
 * value targets only missing or closed indices. This behavior applies even if the request
 * targets other open indices.
 */
export const indices_shard_stores_allow_no_indices = z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all\nvalue targets only missing or closed indices. This behavior applies even if the request\ntargets other open indices.');

/**
 * Type of index that wildcard patterns can match. If the request can target data streams,
 * this argument determines whether wildcard expressions match hidden data streams.
 */
export const indices_shard_stores_expand_wildcards = types_expand_wildcards;

/**
 * If true, missing or closed indices are not included in the response.
 */
export const indices_shard_stores_ignore_unavailable = z.boolean().describe('If true, missing or closed indices are not included in the response.');

/**
 * List of shard health statuses used to limit the request.
 */
export const indices_shard_stores_status = z.union([
    indices_shard_stores_shard_store_status,
    z.array(indices_shard_stores_shard_store_status)
]);

/**
 * Name of the source index to shrink.
 */
export const indices_shrink_index = types_index_name;

/**
 * Name of the target index to create.
 */
export const indices_shrink_target = types_index_name;

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_shrink_master_timeout = types_duration;

/**
 * Period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_shrink_timeout = types_duration;

/**
 * The number of shard copies that must be active before proceeding with the operation.
 * Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).
 */
export const indices_shrink_wait_for_active_shards = types_wait_for_active_shards;

/**
 * Name of the index template to simulate. To test a template configuration before you add it to the cluster, omit
 * this parameter and specify the template configuration in the request body.
 */
export const indices_simulate_template_name = types_name;

/**
 * If true, the template passed in the body is only used if no existing templates match the same index patterns. If false, the simulation uses the template with the highest priority. Note that the template is not permanently added or updated in either case; it is only used for the simulation.
 */
export const indices_simulate_template_create = z.boolean().describe('If true, the template passed in the body is only used if no existing templates match the same index patterns. If false, the simulation uses the template with the highest priority. Note that the template is not permanently added or updated in either case; it is only used for the simulation.');

/**
 * User defined reason for dry-run creating the new template for simulation purposes
 */
export const indices_simulate_template_cause = z.string().describe('User defined reason for dry-run creating the new template for simulation purposes');

/**
 * Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_simulate_template_master_timeout = types_duration;

/**
 * If true, returns all relevant default configurations for the index template.
 */
export const indices_simulate_template_include_defaults = z.boolean().describe('If true, returns all relevant default configurations for the index template.');

/**
 * Name of the source index to split.
 */
export const indices_split_index = types_index_name;

/**
 * Name of the target index to create.
 */
export const indices_split_target = types_index_name;

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_split_master_timeout = types_duration;

/**
 * Period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const indices_split_timeout = types_duration;

/**
 * The number of shard copies that must be active before proceeding with the operation.
 * Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).
 */
export const indices_split_wait_for_active_shards = types_wait_for_active_shards;

/**
 * Limit the information returned the specific metrics.
 */
export const indices_stats_metric = types_common_stats_flags;

/**
 * A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
 */
export const indices_stats_index = types_indices;

/**
 * Comma-separated list or wildcard expressions of fields to include in fielddata and suggest statistics.
 */
export const indices_stats_completion_fields = types_fields;

/**
 * Type of index that wildcard patterns can match. If the request can target data streams, this argument
 * determines whether wildcard expressions match hidden data streams. Supports comma-separated values,
 * such as `open,hidden`.
 */
export const indices_stats_expand_wildcards = types_expand_wildcards;

/**
 * Comma-separated list or wildcard expressions of fields to include in fielddata statistics.
 */
export const indices_stats_fielddata_fields = types_fields;

/**
 * Comma-separated list or wildcard expressions of fields to include in the statistics.
 */
export const indices_stats_fields = types_fields;

/**
 * If true, statistics are not collected from closed indices.
 */
export const indices_stats_forbid_closed_indices = z.boolean().describe('If true, statistics are not collected from closed indices.');

/**
 * Comma-separated list of search groups to include in the search statistics.
 */
export const indices_stats_groups = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
 */
export const indices_stats_include_segment_file_sizes = z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).');

/**
 * If true, the response includes information from segments that are not loaded into memory.
 */
export const indices_stats_include_unloaded_segments = z.boolean().describe('If true, the response includes information from segments that are not loaded into memory.');

/**
 * Indicates whether statistics are aggregated at the cluster, indices, or shards level.
 */
export const indices_stats_level = types_level;

/**
 * Comma-separated list of data streams, indices, and aliases to search.
 * Supports wildcards (`*`).
 * To search all data streams or indices, omit this parameter or use `*` or `_all`.
 */
export const indices_validate_query_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 */
export const indices_validate_query_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.');

/**
 * If `true`, the validation is executed on all shards instead of one random shard per index.
 */
export const indices_validate_query_all_shards = z.boolean().describe('If `true`, the validation is executed on all shards instead of one random shard per index.');

/**
 * Analyzer to use for the query string.
 * This parameter can only be used when the `q` query string parameter is specified.
 */
export const indices_validate_query_analyzer = z.string().describe('Analyzer to use for the query string.\nThis parameter can only be used when the `q` query string parameter is specified.');

/**
 * If `true`, wildcard and prefix queries are analyzed.
 */
export const indices_validate_query_analyze_wildcard = z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.');

/**
 * The default operator for query string query: `and` or `or`.
 */
export const indices_validate_query_default_operator = types_query_dsl_operator;

/**
 * Field to use as default where no field prefix is given in the query string.
 * This parameter can only be used when the `q` query string parameter is specified.
 */
export const indices_validate_query_df = z.string().describe('Field to use as default where no field prefix is given in the query string.\nThis parameter can only be used when the `q` query string parameter is specified.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const indices_validate_query_expand_wildcards = types_expand_wildcards;

/**
 * If `true`, the response returns detailed information if an error has occurred.
 */
export const indices_validate_query_explain = z.boolean().describe('If `true`, the response returns detailed information if an error has occurred.');

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const indices_validate_query_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.
 */
export const indices_validate_query_lenient = z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.');

/**
 * If `true`, returns a more detailed explanation showing the actual Lucene query that will be executed.
 */
export const indices_validate_query_rewrite = z.boolean().describe('If `true`, returns a more detailed explanation showing the actual Lucene query that will be executed.');

/**
 * Query in the Lucene query string syntax.
 */
export const indices_validate_query_q = z.string().describe('Query in the Lucene query string syntax.');

/**
 * The task type
 */
export const inference_delete_task_type = inference_types_task_type;

/**
 * The inference identifier.
 */
export const inference_delete_inference_id = types_id;

/**
 * When true, checks the semantic_text fields and inference processors that reference the endpoint and returns them in a list, but does not delete the endpoint.
 */
export const inference_delete_dry_run = z.boolean().describe('When true, checks the semantic_text fields and inference processors that reference the endpoint and returns them in a list, but does not delete the endpoint.');

/**
 * When true, the inference endpoint is forcefully deleted even if it is still being used by ingest processors or semantic text fields.
 */
export const inference_delete_force = z.boolean().describe('When true, the inference endpoint is forcefully deleted even if it is still being used by ingest processors or semantic text fields.');

/**
 * The task type
 */
export const inference_get_task_type = inference_types_task_type;

/**
 * The inference Id
 */
export const inference_get_inference_id = types_id;

/**
 * The type of inference task that the model performs.
 */
export const inference_inference_task_type = inference_types_task_type;

/**
 * The unique identifier for the inference endpoint.
 */
export const inference_inference_inference_id = types_id;

/**
 * The amount of time to wait for the inference request to complete.
 */
export const inference_inference_timeout = types_duration;

/**
 * The task type. Refer to the integration list in the API description for the available task types.
 */
export const inference_put_task_type = inference_types_task_type;

/**
 * The inference Id
 */
export const inference_put_inference_id = types_id;

/**
 * Specifies the amount of time to wait for the inference endpoint to be created.
 */
export const inference_put_timeout = types_duration;

/**
 * The unique identifier of the inference endpoint.
 */
export const inference_update_inference_id = types_id;

/**
 * The type of inference task that the model performs.
 */
export const inference_update_task_type = inference_types_task_type;

/**
 * A comma-separated list of database configuration IDs to retrieve.
 * Wildcard (`*`) expressions are supported.
 * To get all database configurations, omit this parameter or use `*`.
 */
export const ingest_get_geoip_database_id = types_ids;

/**
 * Comma-separated list of database configuration IDs to retrieve.
 * Wildcard (`*`) expressions are supported.
 * To get all database configurations, omit this parameter or use `*`.
 */
export const ingest_get_ip_location_database_id = types_ids;

/**
 * Comma-separated list of pipeline IDs to retrieve.
 * Wildcard (`*`) expressions are supported.
 * To get all ingest pipelines, omit this parameter or use `*`.
 */
export const ingest_get_pipeline_id = types_id;

/**
 * Period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const ingest_get_pipeline_master_timeout = types_duration;

/**
 * Return pipelines without their definitions (default: false)
 */
export const ingest_get_pipeline_summary = z.boolean().describe('Return pipelines without their definitions (default: false)');

/**
 * The pipeline to test.
 * If you don't specify a `pipeline` in the request body, this parameter is required.
 */
export const ingest_simulate_id = types_id;

/**
 * If `true`, the response includes output data for each processor in the executed pipeline.
 */
export const ingest_simulate_verbose = z.boolean().describe('If `true`, the response includes output data for each processor in the executed pipeline.');

/**
 * Specifies whether you acknowledge the license changes.
 */
export const license_post_acknowledge = z.boolean().describe('Specifies whether you acknowledge the license changes.');

/**
 * The period to wait for a connection to the master node.
 */
export const license_post_master_timeout = types_duration;

/**
 * The period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.
 */
export const license_post_timeout = types_duration;

/**
 * A comma-separated list of pipeline identifiers.
 */
export const logstash_get_pipeline_id = types_ids;

/**
 * Name of the index to retrieve documents from when `ids` are specified, or when a document in the `docs` array does not specify an index.
 */
export const mget_index = types_index_name;

/**
 * Specifies the node or shard the operation should be performed on. Random by default.
 */
export const mget_preference = z.string().describe('Specifies the node or shard the operation should be performed on. Random by default.');

/**
 * If `true`, the request is real-time as opposed to near-real-time.
 */
export const mget_realtime = z.boolean().describe('If `true`, the request is real-time as opposed to near-real-time.');

/**
 * If `true`, the request refreshes relevant shards before retrieving documents.
 */
export const mget_refresh = z.boolean().describe('If `true`, the request refreshes relevant shards before retrieving documents.');

/**
 * Custom value used to route operations to a specific shard.
 */
export const mget_routing = types_routing;

/**
 * True or false to return the `_source` field or not, or a list of fields to return.
 */
export const mget_source = global_search_types_source_config_param;

/**
 * A comma-separated list of source fields to exclude from the response.
 * You can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.
 */
export const mget_source_excludes = types_fields;

/**
 * A comma-separated list of source fields to include in the response.
 * If this parameter is specified, only these source fields are returned. You can exclude fields from this subset using the `_source_excludes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const mget_source_includes = types_fields;

/**
 * If `true`, retrieves the document fields stored in the index rather than the document `_source`.
 */
export const mget_stored_fields = types_fields;

/**
 * Comma-separate list of data streams or indices to check. Wildcard (*) expressions are supported.
 */
export const migration_deprecations_index = types_index_name;

/**
 * Identifier for an anomaly detection job. It can be a job identifier, a
 * group name, or a wildcard expression.
 */
export const ml_delete_expired_data_job_id = types_id;

/**
 * The desired requests per second for the deletion processes. The default
 * behavior is no throttling.
 */
export const ml_delete_expired_data_requests_per_second = z.number().describe('The desired requests per second for the deletion processes. The default\nbehavior is no throttling.');

/**
 * How long can the underlying delete processes run until they are canceled.
 */
export const ml_delete_expired_data_timeout = types_duration;

/**
 * Identifier for the anomaly detection job.
 */
export const ml_delete_forecast_job_id = types_id;

/**
 * A comma-separated list of forecast identifiers. If you do not specify
 * this optional parameter or if you specify `_all` or `*` the API deletes
 * all forecasts from the job.
 */
export const ml_delete_forecast_forecast_id = types_id;

/**
 * Specifies whether an error occurs when there are no forecasts. In
 * particular, if this parameter is set to `false` and there are no
 * forecasts associated with the job, attempts to delete all forecasts
 * return an error.
 */
export const ml_delete_forecast_allow_no_forecasts = z.boolean().describe('Specifies whether an error occurs when there are no forecasts. In\nparticular, if this parameter is set to `false` and there are no\nforecasts associated with the job, attempts to delete all forecasts\nreturn an error.');

/**
 * Specifies the period of time to wait for the completion of the delete
 * operation. When this period of time elapses, the API fails and returns an
 * error.
 */
export const ml_delete_forecast_timeout = types_duration;

/**
 * Identifier for the data frame analytics job. This identifier can contain
 * lowercase alphanumeric characters (a-z and 0-9), hyphens, and
 * underscores. It must start and end with alphanumeric characters.
 */
export const ml_explain_data_frame_analytics_id = types_id;

/**
 * Identifier for the anomaly detection job.
 */
export const ml_get_buckets_job_id = types_id;

/**
 * The timestamp of a single bucket result. If you do not specify this
 * parameter, the API returns information about all buckets.
 */
export const ml_get_buckets_timestamp = types_date_time;

/**
 * Returns buckets with anomaly scores greater or equal than this value.
 */
export const ml_get_buckets_anomaly_score = z.number().describe('Returns buckets with anomaly scores greater or equal than this value.');

/**
 * If `true`, the buckets are sorted in descending order.
 */
export const ml_get_buckets_desc = z.boolean().describe('If `true`, the buckets are sorted in descending order.');

/**
 * Returns buckets with timestamps earlier than this time. `-1` means it is
 * unset and results are not limited to specific timestamps.
 */
export const ml_get_buckets_end = types_date_time;

/**
 * If `true`, the output excludes interim results.
 */
export const ml_get_buckets_exclude_interim = z.boolean().describe('If `true`, the output excludes interim results.');

/**
 * If true, the output includes anomaly records.
 */
export const ml_get_buckets_expand = z.boolean().describe('If true, the output includes anomaly records.');

/**
 * Skips the specified number of buckets.
 */
export const ml_get_buckets_from = z.number().describe('Skips the specified number of buckets.');

/**
 * Specifies the maximum number of buckets to obtain.
 */
export const ml_get_buckets_size = z.number().describe('Specifies the maximum number of buckets to obtain.');

/**
 * Specifies the sort field for the requested buckets.
 */
export const ml_get_buckets_sort = types_field;

/**
 * Returns buckets with timestamps after this time. `-1` means it is unset
 * and results are not limited to specific timestamps.
 */
export const ml_get_buckets_start = types_date_time;

/**
 * A string that uniquely identifies a calendar. You can get information for multiple calendars by using a comma-separated list of ids or a wildcard expression. You can get information for all calendars by using `_all` or `*` or by omitting the calendar identifier.
 */
export const ml_get_calendars_calendar_id = types_id;

/**
 * Skips the specified number of calendars. This parameter is supported only when you omit the calendar identifier.
 */
export const ml_get_calendars_from = z.number().describe('Skips the specified number of calendars. This parameter is supported only when you omit the calendar identifier.');

/**
 * Specifies the maximum number of calendars to obtain. This parameter is supported only when you omit the calendar identifier.
 */
export const ml_get_calendars_size = z.number().describe('Specifies the maximum number of calendars to obtain. This parameter is supported only when you omit the calendar identifier.');

/**
 * Identifier for the anomaly detection job.
 */
export const ml_get_categories_job_id = types_id;

/**
 * Identifier for the category, which is unique in the job. If you specify
 * neither the category ID nor the partition_field_value, the API returns
 * information about all categories. If you specify only the
 * partition_field_value, it returns information about all categories for
 * the specified partition.
 */
export const ml_get_categories_category_id = types_category_id;

/**
 * Skips the specified number of categories.
 */
export const ml_get_categories_from = z.number().describe('Skips the specified number of categories.');

/**
 * Only return categories for the specified partition.
 */
export const ml_get_categories_partition_field_value = z.string().describe('Only return categories for the specified partition.');

/**
 * Specifies the maximum number of categories to obtain.
 */
export const ml_get_categories_size = z.number().describe('Specifies the maximum number of categories to obtain.');

/**
 * Identifier for the data frame analytics job. If you do not specify this
 * option, the API returns information for the first hundred data frame
 * analytics jobs.
 */
export const ml_get_data_frame_analytics_id = types_id;

/**
 * Specifies what to do when the request:
 *
 * 1. Contains wildcard expressions and there are no data frame analytics
 * jobs that match.
 * 2. Contains the `_all` string or no identifiers and there are no matches.
 * 3. Contains wildcard expressions and there are only partial matches.
 *
 * The default value returns an empty data_frame_analytics array when there
 * are no matches and the subset of results when there are partial matches.
 * If this parameter is `false`, the request returns a 404 status code when
 * there are no matches or only partial matches.
 */
export const ml_get_data_frame_analytics_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value returns an empty data_frame_analytics array when there\nare no matches and the subset of results when there are partial matches.\nIf this parameter is `false`, the request returns a 404 status code when\nthere are no matches or only partial matches.');

/**
 * Skips the specified number of data frame analytics jobs.
 */
export const ml_get_data_frame_analytics_from = z.number().describe('Skips the specified number of data frame analytics jobs.');

/**
 * Specifies the maximum number of data frame analytics jobs to obtain.
 */
export const ml_get_data_frame_analytics_size = z.number().describe('Specifies the maximum number of data frame analytics jobs to obtain.');

/**
 * Indicates if certain fields should be removed from the configuration on
 * retrieval. This allows the configuration to be in an acceptable format to
 * be retrieved and then added to another cluster.
 */
export const ml_get_data_frame_analytics_exclude_generated = z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.');

/**
 * Identifier for the data frame analytics job. If you do not specify this
 * option, the API returns information for the first hundred data frame
 * analytics jobs.
 */
export const ml_get_data_frame_analytics_stats_id = types_id;

/**
 * Specifies what to do when the request:
 *
 * 1. Contains wildcard expressions and there are no data frame analytics
 * jobs that match.
 * 2. Contains the `_all` string or no identifiers and there are no matches.
 * 3. Contains wildcard expressions and there are only partial matches.
 *
 * The default value returns an empty data_frame_analytics array when there
 * are no matches and the subset of results when there are partial matches.
 * If this parameter is `false`, the request returns a 404 status code when
 * there are no matches or only partial matches.
 */
export const ml_get_data_frame_analytics_stats_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value returns an empty data_frame_analytics array when there\nare no matches and the subset of results when there are partial matches.\nIf this parameter is `false`, the request returns a 404 status code when\nthere are no matches or only partial matches.');

/**
 * Skips the specified number of data frame analytics jobs.
 */
export const ml_get_data_frame_analytics_stats_from = z.number().describe('Skips the specified number of data frame analytics jobs.');

/**
 * Specifies the maximum number of data frame analytics jobs to obtain.
 */
export const ml_get_data_frame_analytics_stats_size = z.number().describe('Specifies the maximum number of data frame analytics jobs to obtain.');

/**
 * Defines whether the stats response should be verbose.
 */
export const ml_get_data_frame_analytics_stats_verbose = z.boolean().describe('Defines whether the stats response should be verbose.');

/**
 * Identifier for the datafeed. It can be a datafeed identifier or a
 * wildcard expression. If you do not specify one of these options, the API
 * returns information about all datafeeds.
 */
export const ml_get_datafeed_stats_datafeed_id = types_ids;

/**
 * Specifies what to do when the request:
 *
 * 1. Contains wildcard expressions and there are no datafeeds that match.
 * 2. Contains the `_all` string or no identifiers and there are no matches.
 * 3. Contains wildcard expressions and there are only partial matches.
 *
 * The default value is `true`, which returns an empty `datafeeds` array
 * when there are no matches and the subset of results when there are
 * partial matches. If this parameter is `false`, the request returns a
 * `404` status code when there are no matches or only partial matches.
 */
export const ml_get_datafeed_stats_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no datafeeds that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `datafeeds` array\nwhen there are no matches and the subset of results when there are\npartial matches. If this parameter is `false`, the request returns a\n`404` status code when there are no matches or only partial matches.');

/**
 * Identifier for the datafeed. It can be a datafeed identifier or a
 * wildcard expression. If you do not specify one of these options, the API
 * returns information about all datafeeds.
 */
export const ml_get_datafeeds_datafeed_id = types_ids;

/**
 * Specifies what to do when the request:
 *
 * 1. Contains wildcard expressions and there are no datafeeds that match.
 * 2. Contains the `_all` string or no identifiers and there are no matches.
 * 3. Contains wildcard expressions and there are only partial matches.
 *
 * The default value is `true`, which returns an empty `datafeeds` array
 * when there are no matches and the subset of results when there are
 * partial matches. If this parameter is `false`, the request returns a
 * `404` status code when there are no matches or only partial matches.
 */
export const ml_get_datafeeds_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no datafeeds that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `datafeeds` array\nwhen there are no matches and the subset of results when there are\npartial matches. If this parameter is `false`, the request returns a\n`404` status code when there are no matches or only partial matches.');

/**
 * Indicates if certain fields should be removed from the configuration on
 * retrieval. This allows the configuration to be in an acceptable format to
 * be retrieved and then added to another cluster.
 */
export const ml_get_datafeeds_exclude_generated = z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.');

/**
 * A string that uniquely identifies a filter.
 */
export const ml_get_filters_filter_id = types_ids;

/**
 * Skips the specified number of filters.
 */
export const ml_get_filters_from = z.number().describe('Skips the specified number of filters.');

/**
 * Specifies the maximum number of filters to obtain.
 */
export const ml_get_filters_size = z.number().describe('Specifies the maximum number of filters to obtain.');

/**
 * Identifier for the anomaly detection job.
 */
export const ml_get_influencers_job_id = types_id;

/**
 * If true, the results are sorted in descending order.
 */
export const ml_get_influencers_desc = z.boolean().describe('If true, the results are sorted in descending order.');

/**
 * Returns influencers with timestamps earlier than this time.
 * The default value means it is unset and results are not limited to
 * specific timestamps.
 */
export const ml_get_influencers_end = types_date_time;

/**
 * If true, the output excludes interim results. By default, interim results
 * are included.
 */
export const ml_get_influencers_exclude_interim = z.boolean().describe('If true, the output excludes interim results. By default, interim results\nare included.');

/**
 * Returns influencers with anomaly scores greater than or equal to this
 * value.
 */
export const ml_get_influencers_influencer_score = z.number().describe('Returns influencers with anomaly scores greater than or equal to this\nvalue.');

/**
 * Skips the specified number of influencers.
 */
export const ml_get_influencers_from = z.number().describe('Skips the specified number of influencers.');

/**
 * Specifies the maximum number of influencers to obtain.
 */
export const ml_get_influencers_size = z.number().describe('Specifies the maximum number of influencers to obtain.');

/**
 * Specifies the sort field for the requested influencers. By default, the
 * influencers are sorted by the `influencer_score` value.
 */
export const ml_get_influencers_sort = types_field;

/**
 * Returns influencers with timestamps after this time. The default value
 * means it is unset and results are not limited to specific timestamps.
 */
export const ml_get_influencers_start = types_date_time;

/**
 * Identifier for the anomaly detection job. It can be a job identifier, a
 * group name, a comma-separated list of jobs, or a wildcard expression. If
 * you do not specify one of these options, the API returns information for
 * all anomaly detection jobs.
 */
export const ml_get_job_stats_job_id = types_id;

/**
 * Specifies what to do when the request:
 *
 * 1. Contains wildcard expressions and there are no jobs that match.
 * 2. Contains the _all string or no identifiers and there are no matches.
 * 3. Contains wildcard expressions and there are only partial matches.
 *
 * If `true`, the API returns an empty `jobs` array when
 * there are no matches and the subset of results when there are partial
 * matches. If `false`, the API returns a `404` status
 * code when there are no matches or only partial matches.
 */
export const ml_get_job_stats_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty `jobs` array when\nthere are no matches and the subset of results when there are partial\nmatches. If `false`, the API returns a `404` status\ncode when there are no matches or only partial matches.');

/**
 * Identifier for the anomaly detection job. It can be a job identifier, a
 * group name, or a wildcard expression. If you do not specify one of these
 * options, the API returns information for all anomaly detection jobs.
 */
export const ml_get_jobs_job_id = types_ids;

/**
 * Specifies what to do when the request:
 *
 * 1. Contains wildcard expressions and there are no jobs that match.
 * 2. Contains the _all string or no identifiers and there are no matches.
 * 3. Contains wildcard expressions and there are only partial matches.
 *
 * The default value is `true`, which returns an empty `jobs` array when
 * there are no matches and the subset of results when there are partial
 * matches. If this parameter is `false`, the request returns a `404` status
 * code when there are no matches or only partial matches.
 */
export const ml_get_jobs_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `jobs` array when\nthere are no matches and the subset of results when there are partial\nmatches. If this parameter is `false`, the request returns a `404` status\ncode when there are no matches or only partial matches.');

/**
 * Indicates if certain fields should be removed from the configuration on
 * retrieval. This allows the configuration to be in an acceptable format to
 * be retrieved and then added to another cluster.
 */
export const ml_get_jobs_exclude_generated = z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.');

/**
 * The names of particular nodes in the cluster to target. For example, `nodeId1,nodeId2` or
 * `ml:true`
 */
export const ml_get_memory_stats_node_id = types_id;

/**
 * Period to wait for a connection to the master node. If no response is received before the timeout
 * expires, the request fails and returns an error.
 */
export const ml_get_memory_stats_master_timeout = types_duration;

/**
 * Period to wait for a response. If no response is received before the timeout expires, the request
 * fails and returns an error.
 */
export const ml_get_memory_stats_timeout = types_duration;

/**
 * Identifier for the anomaly detection job.
 */
export const ml_get_model_snapshots_job_id = types_id;

/**
 * A numerical character string that uniquely identifies the model snapshot. You can get information for multiple
 * snapshots by using a comma-separated list or a wildcard expression. You can get all snapshots by using `_all`,
 * by specifying `*` as the snapshot ID, or by omitting the snapshot ID.
 */
export const ml_get_model_snapshots_snapshot_id = types_id;

/**
 * If true, the results are sorted in descending order.
 */
export const ml_get_model_snapshots_desc = z.boolean().describe('If true, the results are sorted in descending order.');

/**
 * Returns snapshots with timestamps earlier than this time.
 */
export const ml_get_model_snapshots_end = types_date_time;

/**
 * Skips the specified number of snapshots.
 */
export const ml_get_model_snapshots_from = z.number().describe('Skips the specified number of snapshots.');

/**
 * Specifies the maximum number of snapshots to obtain.
 */
export const ml_get_model_snapshots_size = z.number().describe('Specifies the maximum number of snapshots to obtain.');

/**
 * Specifies the sort field for the requested snapshots. By default, the
 * snapshots are sorted by their timestamp.
 */
export const ml_get_model_snapshots_sort = types_field;

/**
 * Returns snapshots with timestamps after this time.
 */
export const ml_get_model_snapshots_start = types_date_time;

/**
 * Identifier for the anomaly detection job. It can be a job identifier, a
 * group name, a comma-separated list of jobs or groups, or a wildcard
 * expression.
 *
 * You can summarize the bucket results for all anomaly detection jobs by
 * using `_all` or by specifying `*` as the `<job_id>`.
 */
export const ml_get_overall_buckets_job_id = types_id;

/**
 * Specifies what to do when the request:
 *
 * 1. Contains wildcard expressions and there are no jobs that match.
 * 2. Contains the `_all` string or no identifiers and there are no matches.
 * 3. Contains wildcard expressions and there are only partial matches.
 *
 * If `true`, the request returns an empty `jobs` array when there are no
 * matches and the subset of results when there are partial matches. If this
 * parameter is `false`, the request returns a `404` status code when there
 * are no matches or only partial matches.
 */
export const ml_get_overall_buckets_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the request returns an empty `jobs` array when there are no\nmatches and the subset of results when there are partial matches. If this\nparameter is `false`, the request returns a `404` status code when there\nare no matches or only partial matches.');

/**
 * The span of the overall buckets. Must be greater or equal to the largest
 * bucket span of the specified anomaly detection jobs, which is the default
 * value.
 *
 * By default, an overall bucket has a span equal to the largest bucket span
 * of the specified anomaly detection jobs. To override that behavior, use
 * the optional `bucket_span` parameter.
 */
export const ml_get_overall_buckets_bucket_span = types_duration;

/**
 * Returns overall buckets with timestamps earlier than this time.
 */
export const ml_get_overall_buckets_end = types_date_time;

/**
 * If `true`, the output excludes interim results.
 */
export const ml_get_overall_buckets_exclude_interim = z.boolean().describe('If `true`, the output excludes interim results.');

/**
 * Returns overall buckets with overall scores greater than or equal to this
 * value.
 */
export const ml_get_overall_buckets_overall_score = z.number().describe('Returns overall buckets with overall scores greater than or equal to this\nvalue.');

/**
 * Returns overall buckets with timestamps after this time.
 */
export const ml_get_overall_buckets_start = types_date_time;

/**
 * The number of top anomaly detection job bucket scores to be used in the
 * `overall_score` calculation.
 */
export const ml_get_overall_buckets_top_n = z.number().describe('The number of top anomaly detection job bucket scores to be used in the\n`overall_score` calculation.');

/**
 * Identifier for the anomaly detection job.
 */
export const ml_get_records_job_id = types_id;

/**
 * If true, the results are sorted in descending order.
 */
export const ml_get_records_desc = z.boolean().describe('If true, the results are sorted in descending order.');

/**
 * Returns records with timestamps earlier than this time. The default value
 * means results are not limited to specific timestamps.
 */
export const ml_get_records_end = types_date_time;

/**
 * If `true`, the output excludes interim results.
 */
export const ml_get_records_exclude_interim = z.boolean().describe('If `true`, the output excludes interim results.');

/**
 * Skips the specified number of records.
 */
export const ml_get_records_from = z.number().describe('Skips the specified number of records.');

/**
 * Returns records with anomaly scores greater or equal than this value.
 */
export const ml_get_records_record_score = z.number().describe('Returns records with anomaly scores greater or equal than this value.');

/**
 * Specifies the maximum number of records to obtain.
 */
export const ml_get_records_size = z.number().describe('Specifies the maximum number of records to obtain.');

/**
 * Specifies the sort field for the requested records.
 */
export const ml_get_records_sort = types_field;

/**
 * Returns records with timestamps after this time. The default value means
 * results are not limited to specific timestamps.
 */
export const ml_get_records_start = types_date_time;

/**
 * The unique identifier of the trained model or a model alias.
 *
 * You can get information for multiple trained models in a single API
 * request by using a comma-separated list of model IDs or a wildcard
 * expression.
 */
export const ml_get_trained_models_model_id = types_ids;

/**
 * Specifies what to do when the request:
 *
 * - Contains wildcard expressions and there are no models that match.
 * - Contains the _all string or no identifiers and there are no matches.
 * - Contains wildcard expressions and there are only partial matches.
 *
 * If true, it returns an empty array when there are no matches and the
 * subset of results when there are partial matches.
 */
export const ml_get_trained_models_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n- Contains wildcard expressions and there are no models that match.\n- Contains the _all string or no identifiers and there are no matches.\n- Contains wildcard expressions and there are only partial matches.\n\nIf true, it returns an empty array when there are no matches and the\nsubset of results when there are partial matches.');

/**
 * Specifies whether the included model definition should be returned as a
 * JSON map (true) or in a custom compressed format (false).
 */
export const ml_get_trained_models_decompress_definition = z.boolean().describe('Specifies whether the included model definition should be returned as a\nJSON map (true) or in a custom compressed format (false).');

/**
 * Indicates if certain fields should be removed from the configuration on
 * retrieval. This allows the configuration to be in an acceptable format to
 * be retrieved and then added to another cluster.
 */
export const ml_get_trained_models_exclude_generated = z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.');

/**
 * Skips the specified number of models.
 */
export const ml_get_trained_models_from = z.number().describe('Skips the specified number of models.');

/**
 * A comma delimited string of optional fields to include in the response
 * body.
 */
export const ml_get_trained_models_include = ml_types_include;

/**
 * Specifies the maximum number of models to obtain.
 */
export const ml_get_trained_models_size = z.number().describe('Specifies the maximum number of models to obtain.');

/**
 * A comma delimited string of tags. A trained model can have many tags, or
 * none. When supplied, only trained models that contain all the supplied
 * tags are returned.
 */
export const ml_get_trained_models_tags = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * The unique identifier of the trained model or a model alias. It can be a
 * comma-separated list or a wildcard expression.
 */
export const ml_get_trained_models_stats_model_id = types_ids;

/**
 * Specifies what to do when the request:
 *
 * - Contains wildcard expressions and there are no models that match.
 * - Contains the _all string or no identifiers and there are no matches.
 * - Contains wildcard expressions and there are only partial matches.
 *
 * If true, it returns an empty array when there are no matches and the
 * subset of results when there are partial matches.
 */
export const ml_get_trained_models_stats_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n- Contains wildcard expressions and there are no models that match.\n- Contains the _all string or no identifiers and there are no matches.\n- Contains wildcard expressions and there are only partial matches.\n\nIf true, it returns an empty array when there are no matches and the\nsubset of results when there are partial matches.');

/**
 * Skips the specified number of models.
 */
export const ml_get_trained_models_stats_from = z.number().describe('Skips the specified number of models.');

/**
 * Specifies the maximum number of models to obtain.
 */
export const ml_get_trained_models_stats_size = z.number().describe('Specifies the maximum number of models to obtain.');

/**
 * Identifier for the data frame analytics job.
 */
export const ml_preview_data_frame_analytics_id = types_id;

/**
 * A numerical character string that uniquely identifies the datafeed. This identifier can contain lowercase
 * alphanumeric characters (a-z and 0-9), hyphens, and underscores. It must start and end with alphanumeric
 * characters. NOTE: If you use this path parameter, you cannot provide datafeed or anomaly detection job
 * configuration details in the request body.
 */
export const ml_preview_datafeed_datafeed_id = types_id;

/**
 * The start time from where the datafeed preview should begin
 */
export const ml_preview_datafeed_start = types_date_time;

/**
 * The end time when the datafeed preview should stop
 */
export const ml_preview_datafeed_end = types_date_time;

/**
 * Comma-separated list of data streams, indices, and index aliases to search.
 */
export const msearch_index = types_indices;

/**
 * If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.
 */
export const msearch_allow_no_indices = z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.');

/**
 * If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.
 */
export const msearch_ccs_minimize_roundtrips = z.boolean().describe('If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.');

/**
 * Type of index that wildcard expressions can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 */
export const msearch_expand_wildcards = types_expand_wildcards;

/**
 * If true, concrete, expanded or aliased indices are ignored when frozen.
 *
 * @deprecated
 */
export const msearch_ignore_throttled = z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.');

/**
 * If true, missing or closed indices are not included in the response.
 */
export const msearch_ignore_unavailable = z.boolean().describe('If true, missing or closed indices are not included in the response.');

/**
 * Indicates whether hit.matched_queries should be rendered as a map that includes
 * the name of the matched query associated with its score (true)
 * or as an array containing the name of the matched queries (false)
 * This functionality reruns each named query on every hit in a search response.
 * Typically, this adds a small overhead to a request.
 * However, using computationally expensive named queries on a large number of hits may add significant overhead.
 */
export const msearch_include_named_queries_score = z.boolean().describe('Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.');

/**
 * Comma-separated list of data streams, indices, and index aliases to use as default
 */
export const msearch_index2 = types_indices;

/**
 * Maximum number of concurrent searches the multi search API can execute.
 * Defaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`.
 */
export const msearch_max_concurrent_searches = z.number().describe('Maximum number of concurrent searches the multi search API can execute.\nDefaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`.');

/**
 * Maximum number of concurrent shard requests that each sub-search request executes per node.
 */
export const msearch_max_concurrent_shard_requests = z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.');

/**
 * Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.
 */
export const msearch_pre_filter_shard_size = z.number().describe('Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.');

/**
 * If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.
 */
export const msearch_rest_total_hits_as_int = z.boolean().describe('If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.');

/**
 * Custom routing value used to route search operations to a specific shard.
 */
export const msearch_routing = types_routing;

/**
 * Indicates whether global term and document frequencies should be used when scoring returned documents.
 */
export const msearch_search_type = types_search_type;

/**
 * Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.
 */
export const msearch_typed_keys = z.boolean().describe('Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.');

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 * To search all data streams and indices, omit this parameter or use `*`.
 */
export const msearch_template_index = types_indices;

/**
 * If `true`, network round-trips are minimized for cross-cluster search requests.
 */
export const msearch_template_ccs_minimize_roundtrips = z.boolean().describe('If `true`, network round-trips are minimized for cross-cluster search requests.');

/**
 * The maximum number of concurrent searches the API can run.
 */
export const msearch_template_max_concurrent_searches = z.number().describe('The maximum number of concurrent searches the API can run.');

/**
 * The type of the search operation.
 */
export const msearch_template_search_type = types_search_type;

/**
 * If `true`, the response returns `hits.total` as an integer.
 * If `false`, it returns `hits.total` as an object.
 */
export const msearch_template_rest_total_hits_as_int = z.boolean().describe('If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object.');

/**
 * If `true`, the response prefixes aggregation and suggester names with their respective types.
 */
export const msearch_template_typed_keys = z.boolean().describe('If `true`, the response prefixes aggregation and suggester names with their respective types.');

/**
 * The name of the index that contains the documents.
 */
export const mtermvectors_index = types_index_name;

/**
 * A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
 */
export const mtermvectors_ids = z.array(types_id).describe('A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body');

/**
 * A comma-separated list or wildcard expressions of fields to include in the statistics.
 * It is used as the default list unless a specific field list is provided in the `completion_fields` or `fielddata_fields` parameters.
 */
export const mtermvectors_fields = types_fields;

/**
 * If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.
 */
export const mtermvectors_field_statistics = z.boolean().describe('If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.');

/**
 * If `true`, the response includes term offsets.
 */
export const mtermvectors_offsets = z.boolean().describe('If `true`, the response includes term offsets.');

/**
 * If `true`, the response includes term payloads.
 */
export const mtermvectors_payloads = z.boolean().describe('If `true`, the response includes term payloads.');

/**
 * If `true`, the response includes term positions.
 */
export const mtermvectors_positions = z.boolean().describe('If `true`, the response includes term positions.');

/**
 * The node or shard the operation should be performed on.
 * It is random by default.
 */
export const mtermvectors_preference = z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.');

/**
 * If true, the request is real-time as opposed to near-real-time.
 */
export const mtermvectors_realtime = z.boolean().describe('If true, the request is real-time as opposed to near-real-time.');

/**
 * A custom value used to route operations to a specific shard.
 */
export const mtermvectors_routing = types_routing;

/**
 * If true, the response includes term frequency and document frequency.
 */
export const mtermvectors_term_statistics = z.boolean().describe('If true, the response includes term frequency and document frequency.');

/**
 * If `true`, returns the document version as part of a hit.
 */
export const mtermvectors_version = types_version_number;

/**
 * The version type.
 */
export const mtermvectors_version_type = types_version_type;

/**
 * List of node IDs or names used to limit returned information.
 */
export const nodes_hot_threads_node_id = types_node_ids;

/**
 * If true, known idle threads (e.g. waiting in a socket select, or to get
 * a task from an empty queue) are filtered out.
 */
export const nodes_hot_threads_ignore_idle_threads = z.boolean().describe('If true, known idle threads (e.g. waiting in a socket select, or to get\na task from an empty queue) are filtered out.');

/**
 * The interval to do the second sampling of threads.
 */
export const nodes_hot_threads_interval = types_duration;

/**
 * Number of samples of thread stacktrace.
 */
export const nodes_hot_threads_snapshots = z.number().describe('Number of samples of thread stacktrace.');

/**
 * Specifies the number of hot threads to provide information for.
 */
export const nodes_hot_threads_threads = z.number().describe('Specifies the number of hot threads to provide information for.');

/**
 * Period to wait for a response. If no response is received
 * before the timeout expires, the request fails and returns an error.
 */
export const nodes_hot_threads_timeout = types_duration;

/**
 * The type to sample.
 */
export const nodes_hot_threads_type = types_thread_type;

/**
 * The sort order for 'cpu' type (default: total)
 */
export const nodes_hot_threads_sort = types_thread_type;

/**
 * Comma-separated list of node IDs or names used to limit returned information.
 */
export const nodes_info_node_id = types_node_ids;

/**
 * Limits the information returned to the specific metrics. Supports a comma-separated list, such as http,ingest.
 */
export const nodes_info_metric = nodes_info_nodes_info_metrics;

/**
 * If true, returns settings in flat format.
 */
export const nodes_info_flat_settings = z.boolean().describe('If true, returns settings in flat format.');

/**
 * Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.
 */
export const nodes_info_timeout = types_duration;

/**
 * The names of particular nodes in the cluster to target.
 */
export const nodes_reload_secure_settings_node_id = types_node_ids;

/**
 * Period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const nodes_reload_secure_settings_timeout = types_duration;

/**
 * Comma-separated list of node IDs or names used to limit returned information.
 */
export const nodes_stats_node_id = types_node_ids;

/**
 * Limit the information returned to the specified metrics
 */
export const nodes_stats_metric = nodes_stats_node_stats_metrics;

/**
 * Limit the information returned for indices metric to the specific index metrics. It can be used only if indices (or all) metric is specified.
 */
export const nodes_stats_index_metric = types_common_stats_flags;

/**
 * Comma-separated list or wildcard expressions of fields to include in fielddata and suggest statistics.
 */
export const nodes_stats_completion_fields = types_fields;

/**
 * Comma-separated list or wildcard expressions of fields to include in fielddata statistics.
 */
export const nodes_stats_fielddata_fields = types_fields;

/**
 * Comma-separated list or wildcard expressions of fields to include in the statistics.
 */
export const nodes_stats_fields = types_fields;

/**
 * Comma-separated list of search groups to include in the search statistics.
 */
export const nodes_stats_groups = z.boolean().describe('Comma-separated list of search groups to include in the search statistics.');

/**
 * If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
 */
export const nodes_stats_include_segment_file_sizes = z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).');

/**
 * Indicates whether statistics are aggregated at the node, indices, or shards level.
 */
export const nodes_stats_level = types_node_stats_level;

/**
 * Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.
 */
export const nodes_stats_timeout = types_duration;

/**
 * A comma-separated list of document types for the indexing index metric.
 */
export const nodes_stats_types = z.array(z.string()).describe('A comma-separated list of document types for the indexing index metric.');

/**
 * If `true`, the response includes information from segments that are not loaded into memory.
 */
export const nodes_stats_include_unloaded_segments = z.boolean().describe('If `true`, the response includes information from segments that are not loaded into memory.');

/**
 * A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
 */
export const nodes_usage_node_id = types_node_ids;

/**
 * Limits the information returned to the specific metrics.
 * A comma-separated list of the following options: `_all`, `rest_actions`, `aggregations`.
 */
export const nodes_usage_metric = nodes_usage_nodes_usage_metrics;

/**
 * Period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const nodes_usage_timeout = types_duration;

/**
 * The identifier for the stored script or search template.
 * It must be unique within the cluster.
 */
export const put_script_id = types_id;

/**
 * The context in which the script or search template should run.
 * To prevent errors, the API immediately compiles the script or template in this context.
 */
export const put_script_context = types_name;

/**
 * The context in which the script or search template should run.
 * To prevent errors, the API immediately compiles the script or template in this context.
 * If you specify both this and the `<context>` path parameter, the API uses the request path parameter.
 */
export const put_script_context2 = types_name;

/**
 * The period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 * It can also be set to `-1` to indicate that the request should never timeout.
 */
export const put_script_master_timeout = types_duration;

/**
 * The period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 * It can also be set to `-1` to indicate that the request should never timeout.
 */
export const put_script_timeout = types_duration;

/**
 * A  comma-separated list of data streams, indices, and index aliases used to limit the request.
 * Wildcard (`*`) expressions are supported.
 * To target all data streams and indices in a cluster, omit this parameter or use `_all` or `*`.
 */
export const rank_eval_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const rank_eval_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.');

/**
 * Whether to expand wildcard expression to concrete indices that are open, closed or both.
 */
export const rank_eval_expand_wildcards = types_expand_wildcards;

/**
 * If `true`, missing or closed indices are not included in the response.
 */
export const rank_eval_ignore_unavailable = z.boolean().describe('If `true`, missing or closed indices are not included in the response.');

/**
 * Search operation type
 */
export const rank_eval_search_type = z.string().describe('Search operation type');

/**
 * The ID of the search template to render.
 * If no `source` is specified, this or the `id` request body parameter is required.
 */
export const render_search_template_id = types_id;

/**
 * Identifier for the rollup job.
 * If it is `_all` or omitted, the API returns all rollup jobs.
 */
export const rollup_get_jobs_id = types_id;

/**
 * Index, indices or index-pattern to return rollup capabilities for.
 * `_all` may be used to fetch rollup capabilities from all jobs.
 */
export const rollup_get_rollup_caps_id = types_id;

/**
 * A comma-separated list of data streams and indices used to limit the request.
 * This parameter has the following rules:
 *
 * * At least one data stream, index, or wildcard expression must be specified. This target can include a rollup or non-rollup index. For data streams, the stream's backing indices can only serve as non-rollup indices. Omitting the parameter or using `_all` are not permitted.
 * * Multiple non-rollup indices may be specified.
 * * Only one rollup index may be specified. If more than one are supplied, an exception occurs.
 * * Wildcard expressions (`*`) may be used. If they match more than one rollup index, an exception occurs. However, you can use an expression to match multiple non-rollup indices or data streams.
 */
export const rollup_rollup_search_index = types_indices;

/**
 * Indicates whether hits.total should be rendered as an integer or an object in the rest search response
 */
export const rollup_rollup_search_rest_total_hits_as_int = z.boolean().describe('Indicates whether hits.total should be rendered as an integer or an object in the rest search response');

/**
 * Specify whether aggregation and suggester names should be prefixed by their respective types in the response
 */
export const rollup_rollup_search_typed_keys = z.boolean().describe('Specify whether aggregation and suggester names should be prefixed by their respective types in the response');

/**
 * The scroll ID
 *
 * @deprecated
 */
export const scroll_scroll_id = types_scroll_id;

/**
 * The period to retain the search context for scrolling.
 */
export const scroll_scroll = types_duration;

/**
 * The scroll ID for scrolled search
 *
 * @deprecated
 */
export const scroll_scroll_id2 = types_scroll_id;

/**
 * If true, the API responses hit.total property is returned as an integer. If false, the API responses hit.total property is returned as an object.
 */
export const scroll_rest_total_hits_as_int = z.boolean().describe('If true, the API responses hit.total property is returned as an integer. If false, the API responses hit.total property is returned as an object.');

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 * To search all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const search_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 * For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const search_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.');

/**
 * If `true` and there are shard request timeouts or shard failures, the request returns partial results.
 * If `false`, it returns an error with no partial results.
 *
 * To override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.
 */
export const search_allow_partial_search_results = z.boolean().describe('If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.');

/**
 * The analyzer to use for the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_analyzer = z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * If `true`, wildcard and prefix queries are analyzed.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_analyze_wildcard = z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * The number of shard results that should be reduced at once on the coordinating node.
 * If the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.
 */
export const search_batched_reduce_size = z.number().describe('The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.');

/**
 * If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.
 */
export const search_ccs_minimize_roundtrips = z.boolean().describe('If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.');

/**
 * The default operator for the query string query: `and` or `or`.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_default_operator = types_query_dsl_operator;

/**
 * The field to use as a default when no field prefix is given in the query string.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_df = z.string().describe('The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * A comma-separated list of fields to return as the docvalue representation of a field for each hit.
 */
export const search_docvalue_fields = types_fields;

/**
 * The type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * It supports comma-separated values such as `open,hidden`.
 */
export const search_expand_wildcards = types_expand_wildcards;

/**
 * If `true`, the request returns detailed information about score computation as part of a hit.
 */
export const search_explain = z.boolean().describe('If `true`, the request returns detailed information about score computation as part of a hit.');

/**
 * If `true`, concrete, expanded or aliased indices will be ignored when frozen.
 *
 * @deprecated
 */
export const search_ignore_throttled = z.boolean().describe('If `true`, concrete, expanded or aliased indices will be ignored when frozen.');

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const search_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * If `true`, the response includes the score contribution from any named queries.
 *
 * This functionality reruns each named query on every hit in a search response.
 * Typically, this adds a small overhead to a request.
 * However, using computationally expensive named queries on a large number of hits may add significant overhead.
 */
export const search_include_named_queries_score = z.boolean().describe('If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.');

/**
 * If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.
 * This parameter can be used only when the `q` query string parameter is specified.
 */
export const search_lenient = z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.');

/**
 * The number of concurrent shard requests per node that the search runs concurrently.
 * This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
 */
export const search_max_concurrent_shard_requests = z.number().describe('The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.');

/**
 * The nodes and shards used for the search.
 * By default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.
 * Valid values are:
 *
 * * `_only_local` to run the search only on shards on the local node.
 * * `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.
 * * `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.
 * * `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.
 * * `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.
 * * `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.
 */
export const search_preference = z.string().describe('The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.');

/**
 * A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.
 * This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).
 * When unspecified, the pre-filter phase is executed if any of these conditions is met:
 *
 * * The request targets more than 128 shards.
 * * The request targets one or more read-only index.
 * * The primary sort of the query targets an indexed field.
 */
export const search_pre_filter_shard_size = z.number().describe('A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.');

/**
 * If `true`, the caching of search results is enabled for requests where `size` is `0`.
 * It defaults to index level settings.
 */
export const search_request_cache = z.boolean().describe('If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.');

/**
 * A custom value that is used to route operations to a specific shard.
 */
export const search_routing = types_routing;

/**
 * The period to retain the search context for scrolling.
 * By default, this value cannot exceed `1d` (24 hours).
 * You can change this limit by using the `search.max_keep_alive` cluster-level setting.
 */
export const search_scroll = types_duration;

/**
 * Indicates how distributed term frequencies are calculated for relevance scoring.
 */
export const search_search_type = types_search_type;

/**
 * Specific `tag` of the request for logging and statistical purposes.
 */
export const search_stats = z.array(z.string()).describe('Specific `tag` of the request for logging and statistical purposes.');

/**
 * A comma-separated list of stored fields to return as part of a hit.
 * If no fields are specified, no stored fields are included in the response.
 * If this field is specified, the `_source` parameter defaults to `false`.
 * You can pass `_source: true` to return both source fields and stored fields in the search response.
 */
export const search_stored_fields = types_fields;

/**
 * The field to use for suggestions.
 */
export const search_suggest_field = types_field;

/**
 * The suggest mode.
 * This parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.
 */
export const search_suggest_mode = types_suggest_mode;

/**
 * The number of suggestions to return.
 * This parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.
 */
export const search_suggest_size = z.number().describe('The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.');

/**
 * The source text for which the suggestions should be returned.
 * This parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.
 */
export const search_suggest_text = z.string().describe('The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.');

/**
 * The maximum number of documents to collect for each shard.
 * If a query reaches this limit, Elasticsearch terminates the query early.
 * Elasticsearch collects documents before sorting.
 *
 * IMPORTANT: Use with caution.
 * Elasticsearch applies this parameter to each shard handling the request.
 * When possible, let Elasticsearch perform early termination automatically.
 * Avoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.
 * If set to `0` (default), the query does not terminate early.
 */
export const search_terminate_after = z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.');

/**
 * The period of time to wait for a response from each shard.
 * If no response is received before the timeout expires, the request fails and returns an error.
 * It defaults to no timeout.
 */
export const search_timeout = types_duration;

/**
 * The number of hits matching the query to count accurately.
 * If `true`, the exact number of hits is returned at the cost of some performance.
 * If `false`, the response does not include the total number of hits matching the query.
 */
export const search_track_total_hits = global_search_types_track_hits;

/**
 * If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.
 */
export const search_track_scores = z.boolean().describe('If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.');

/**
 * If `true`, aggregation and suggester names are be prefixed by their respective types in the response.
 */
export const search_typed_keys = z.boolean().describe('If `true`, aggregation and suggester names are be prefixed by their respective types in the response.');

/**
 * Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.
 */
export const search_rest_total_hits_as_int = z.boolean().describe('Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.');

/**
 * If `true`, the request returns the document version as part of a hit.
 */
export const search_version = z.boolean().describe('If `true`, the request returns the document version as part of a hit.');

/**
 * The source fields that are returned for matching documents.
 * These fields are returned in the `hits._source` property of the search response.
 * Valid values are:
 *
 * * `true` to return the entire document source.
 * * `false` to not return the document source.
 * * `<string>` to return the source fields that are specified as a comma-separated list that supports wildcard (`*`) patterns.
 */
export const search_source = global_search_types_source_config_param;

/**
 * A comma-separated list of source fields to exclude from the response.
 * You can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const search_source_excludes = types_fields;

/**
 * Whether vectors should be excluded from _source
 */
export const search_source_exclude_vectors = z.boolean().describe('Whether vectors should be excluded from _source');

/**
 * A comma-separated list of source fields to include in the response.
 * If this parameter is specified, only these source fields are returned.
 * You can exclude fields from this subset using the `_source_excludes` query parameter.
 * If the `_source` parameter is `false`, this parameter is ignored.
 */
export const search_source_includes = types_fields;

/**
 * If `true`, the request returns the sequence number and primary term of the last modification of each hit.
 */
export const search_seq_no_primary_term = z.boolean().describe('If `true`, the request returns the sequence number and primary term of the last modification of each hit.');

/**
 * A query in the Lucene query string syntax.
 * Query parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.
 *
 * IMPORTANT: This parameter overrides the query parameter in the request body.
 * If both parameters are specified, documents matching the query request body parameter are not returned.
 */
export const search_q = z.string().describe('A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.');

/**
 * The number of hits to return.
 * By default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.
 * To page through more hits, use the `search_after` parameter.
 */
export const search_size = z.number().describe('The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.');

/**
 * The starting document offset, which must be non-negative.
 * By default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.
 * To page through more hits, use the `search_after` parameter.
 */
export const search_from = z.number().describe('The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.');

/**
 * A comma-separated list of `<field>:<direction>` pairs.
 */
export const search_sort = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * A list of analytics collections to limit the returned information
 */
export const search_application_get_behavioral_analytics_name = z.array(types_name).describe('A list of analytics collections to limit the returned information');

/**
 * The name of the search application to be searched.
 */
export const search_application_search_name = types_name;

/**
 * Determines whether aggregation names are prefixed by their respective types in the response.
 */
export const search_application_search_typed_keys = z.boolean().describe('Determines whether aggregation names are prefixed by their respective types in the response.');

/**
 * Comma-separated list of data streams, indices, or aliases to search
 */
export const search_mvt_index = types_indices;

/**
 * Field containing geospatial data to return
 */
export const search_mvt_field = types_field;

/**
 * Zoom level for the vector tile to search
 */
export const search_mvt_zoom = global_search_mvt_types_zoom_level;

/**
 * X coordinate for the vector tile to search
 */
export const search_mvt_x = global_search_mvt_types_coordinate;

/**
 * Y coordinate for the vector tile to search
 */
export const search_mvt_y = global_search_mvt_types_coordinate;

/**
 * If `false`, the meta layer's feature is the bounding box of the tile.
 * If true, the meta layer's feature is a bounding box resulting from a
 * geo_bounds aggregation. The aggregation runs on <field> values that intersect
 * the <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting
 * bounding box may be larger than the vector tile.
 */
export const search_mvt_exact_bounds = z.boolean().describe('If `false`, the meta layer\'s feature is the bounding box of the tile.\nIf true, the meta layer\'s feature is a bounding box resulting from a\ngeo_bounds aggregation. The aggregation runs on <field> values that intersect\nthe <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting\nbounding box may be larger than the vector tile.');

/**
 * The size, in pixels, of a side of the tile. Vector tiles are square with equal sides.
 */
export const search_mvt_extent = z.number().describe('The size, in pixels, of a side of the tile. Vector tiles are square with equal sides.');

/**
 * Aggregation used to create a grid for `field`.
 */
export const search_mvt_grid_agg = global_search_mvt_types_grid_aggregation_type;

/**
 * Additional zoom levels available through the aggs layer. For example, if <zoom> is 7
 * and grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results
 * don't include the aggs layer.
 */
export const search_mvt_grid_precision = z.number().describe('Additional zoom levels available through the aggs layer. For example, if <zoom> is 7\nand grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndon\'t include the aggs layer.');

/**
 * Determines the geometry type for features in the aggs layer. In the aggs layer,
 * each feature represents a geotile_grid cell. If 'grid' each feature is a Polygon
 * of the cells bounding box. If 'point' each feature is a Point that is the centroid
 * of the cell.
 */
export const search_mvt_grid_type = global_search_mvt_types_grid_type;

/**
 * Maximum number of features to return in the hits layer. Accepts 0-10000.
 * If 0, results don't include the hits layer.
 */
export const search_mvt_size = z.number().describe('Maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results don\'t include the hits layer.');

/**
 * The number of hits matching the query to count accurately.
 * If `true`, the exact number of hits is returned at the cost of some performance.
 * If `false`, the response does not include the total number of hits matching the query.
 */
export const search_mvt_track_total_hits = global_search_types_track_hits;

/**
 * If `true`, the hits and aggs layers will contain additional point features representing
 * suggested label positions for the original features.
 *
 * * `Point` and `MultiPoint` features will have one of the points selected.
 * * `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.
 * * `LineString` features will likewise provide a roughly central point selected from the triangle-tree.
 * * The aggregation results will provide one central point for each aggregation bucket.
 *
 * All attributes from the original features will also be copied to the new label features.
 * In addition, the new features will be distinguishable using the tag `_mvt_label_position`.
 */
export const search_mvt_with_labels = z.boolean().describe('If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.\n\n* `Point` and `MultiPoint` features will have one of the points selected.\n* `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.\n* `LineString` features will likewise provide a roughly central point selected from the triangle-tree.\n* The aggregation results will provide one central point for each aggregation bucket.\n\nAll attributes from the original features will also be copied to the new label features.\nIn addition, the new features will be distinguishable using the tag `_mvt_label_position`.');

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 * To search all data streams and indices, omit this parameter or use `*` or `_all`.
 */
export const search_shards_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 * For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const search_shards_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.');

/**
 * Type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const search_shards_expand_wildcards = types_expand_wildcards;

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const search_shards_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * If `true`, the request retrieves information from the local node only.
 */
export const search_shards_local = z.boolean().describe('If `true`, the request retrieves information from the local node only.');

/**
 * The period to wait for a connection to the master node.
 * If the master node is not available before the timeout expires, the request fails and returns an error.
 * IT can also be set to `-1` to indicate that the request should never timeout.
 */
export const search_shards_master_timeout = types_duration;

/**
 * The node or shard the operation should be performed on.
 * It is random by default.
 */
export const search_shards_preference = z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.');

/**
 * A custom value used to route operations to a specific shard.
 */
export const search_shards_routing = types_routing;

/**
 * A comma-separated list of data streams, indices, and aliases to search.
 * It supports wildcards (`*`).
 */
export const search_template_index = types_indices;

/**
 * If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.
 * This behavior applies even if the request targets other open indices.
 * For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.
 */
export const search_template_allow_no_indices = z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.');

/**
 * If `true`, network round-trips are minimized for cross-cluster search requests.
 */
export const search_template_ccs_minimize_roundtrips = z.boolean().describe('If `true`, network round-trips are minimized for cross-cluster search requests.');

/**
 * The type of index that wildcard patterns can match.
 * If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
 * Supports comma-separated values, such as `open,hidden`.
 */
export const search_template_expand_wildcards = types_expand_wildcards;

/**
 * If `true`, the response includes additional details about score computation as part of a hit.
 */
export const search_template_explain = z.boolean().describe('If `true`, the response includes additional details about score computation as part of a hit.');

/**
 * If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled.
 *
 * @deprecated
 */
export const search_template_ignore_throttled = z.boolean().describe('If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled.');

/**
 * If `false`, the request returns an error if it targets a missing or closed index.
 */
export const search_template_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.');

/**
 * The node or shard the operation should be performed on.
 * It is random by default.
 */
export const search_template_preference = z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.');

/**
 * If `true`, the query execution is profiled.
 */
export const search_template_profile = z.boolean().describe('If `true`, the query execution is profiled.');

/**
 * A custom value used to route operations to a specific shard.
 */
export const search_template_routing = types_routing;

/**
 * Specifies how long a consistent view of the index
 * should be maintained for scrolled search.
 */
export const search_template_scroll = types_duration;

/**
 * The type of the search operation.
 */
export const search_template_search_type = types_search_type;

/**
 * If `true`, `hits.total` is rendered as an integer in the response.
 * If `false`, it is rendered as an object.
 */
export const search_template_rest_total_hits_as_int = z.boolean().describe('If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object.');

/**
 * If `true`, the response prefixes aggregation and suggester names with their respective types.
 */
export const search_template_typed_keys = z.boolean().describe('If `true`, the response prefixes aggregation and suggester names with their respective types.');

/**
 * The names of the nodes in the cluster to target.
 */
export const searchable_snapshots_cache_stats_node_id = types_node_ids;

export const searchable_snapshots_cache_stats_master_timeout = types_duration;

/**
 * A comma-separated list of data streams, indices, and aliases to clear from the cache.
 * It supports wildcards (`*`).
 */
export const searchable_snapshots_clear_cache_index = types_indices;

/**
 * Whether to expand wildcard expression to concrete indices that are open, closed or both.
 */
export const searchable_snapshots_clear_cache_expand_wildcards = types_expand_wildcards;

/**
 * Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
 */
export const searchable_snapshots_clear_cache_allow_no_indices = z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)');

/**
 * Whether specified concrete indices should be ignored when unavailable (missing or closed)
 */
export const searchable_snapshots_clear_cache_ignore_unavailable = z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)');

/**
 * A comma-separated list of data streams and indices to retrieve statistics for.
 */
export const searchable_snapshots_stats_index = types_indices;

/**
 * Return stats aggregated at cluster, index or shard level
 */
export const searchable_snapshots_stats_level = searchable_snapshots_types_stats_level;

/**
 * The user whose password you want to change. If you do not specify this
 * parameter, the password is changed for the current user.
 */
export const security_change_password_username = types_username;

/**
 * If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.
 */
export const security_change_password_refresh = types_refresh;

/**
 * If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.
 */
export const security_create_api_key_refresh = types_refresh;

/**
 * The name of the namespace, which is a top-level grouping of service accounts.
 */
export const security_create_service_token_namespace = types_namespace;

/**
 * The name of the service.
 */
export const security_create_service_token_service = types_service;

/**
 * The name for the service account token.
 * If omitted, a random name will be generated.
 *
 * Token names must be at least one and no more than 256 characters.
 * They can contain alphanumeric characters (a-z, A-Z, 0-9), dashes (`-`), and underscores (`_`), but cannot begin with an underscore.
 *
 * NOTE: Token names must be unique in the context of the associated service account.
 * They must also be globally unique with their fully qualified names, which are comprised of the service account principal and token name, such as `<namespace>/<service>/<token-name>`.
 */
export const security_create_service_token_name = types_name;

/**
 * If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` (the default) then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.
 */
export const security_create_service_token_refresh = types_refresh;

/**
 * An identifier for the user.
 */
export const security_disable_user_username = types_username;

/**
 * If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.
 */
export const security_disable_user_refresh = types_refresh;

/**
 * Unique identifier for the user profile.
 */
export const security_disable_user_profile_uid = security_types_user_profile_id;

/**
 * If 'true', Elasticsearch refreshes the affected shards to make this operation visible to search.
 * If 'wait_for', it waits for a refresh to make this operation visible to search.
 * If 'false', it does nothing with refreshes.
 */
export const security_disable_user_profile_refresh = types_refresh;

/**
 * An identifier for the user.
 */
export const security_enable_user_username = types_username;

/**
 * If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.
 */
export const security_enable_user_refresh = types_refresh;

/**
 * A unique identifier for the user profile.
 */
export const security_enable_user_profile_uid = security_types_user_profile_id;

/**
 * If 'true', Elasticsearch refreshes the affected shards to make this operation
 * visible to search.
 * If 'wait_for', it waits for a refresh to make this operation visible to search.
 * If 'false', nothing is done with refreshes.
 */
export const security_enable_user_profile_refresh = types_refresh;

/**
 * The name of the application.
 * Application privileges are always associated with exactly one application.
 * If you do not specify this parameter, the API returns information about all privileges for all applications.
 */
export const security_get_privileges_application = types_name;

/**
 * The name of the privilege.
 * If you do not specify this parameter, the API returns information about all privileges for the requested application.
 */
export const security_get_privileges_name = types_names;

/**
 * The name of the role.
 * You can specify multiple roles as a comma-separated list.
 * If you do not specify this parameter, the API returns information about all roles.
 */
export const security_get_role_name = types_names;

/**
 * The distinct name that identifies the role mapping. The name is used solely as an identifier to facilitate interaction via the API; it does not affect the behavior of the mapping in any way. You can specify multiple mapping names as a comma-separated list. If you do not specify this parameter, the API returns information about all role mappings.
 */
export const security_get_role_mapping_name = types_names;

/**
 * The name of the namespace.
 * Omit this parameter to retrieve information about all service accounts.
 * If you omit this parameter, you must also omit the `service` parameter.
 */
export const security_get_service_accounts_namespace = types_namespace;

/**
 * The service name.
 * Omit this parameter to retrieve information about all service accounts that belong to the specified `namespace`.
 */
export const security_get_service_accounts_service = types_service;

/**
 * An identifier for the user. You can specify multiple usernames as a comma-separated list. If you omit this parameter, the API retrieves information about all users.
 */
export const security_get_user_username = z.union([
    types_username,
    z.array(types_username)
]);

/**
 * Determines whether to retrieve the user profile UID, if it exists, for the users.
 */
export const security_get_user_with_profile_uid = z.boolean().describe('Determines whether to retrieve the user profile UID, if it exists, for the users.');

/**
 * Username
 */
export const security_has_privileges_user = types_name;

/**
 * If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.
 */
export const security_put_privileges_refresh = types_refresh;

/**
 * The name of the role that is being created or updated. On Elasticsearch Serverless, the role name must begin with a letter or digit and can only contain letters, digits and the characters '_', '-', and '.'. Each role must have a unique name, as this will serve as the identifier for that role.
 */
export const security_put_role_name = types_name;

/**
 * If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.
 */
export const security_put_role_refresh = types_refresh;

/**
 * The distinct name that identifies the role mapping.
 * The name is used solely as an identifier to facilitate interaction via the API; it does not affect the behavior of the mapping in any way.
 */
export const security_put_role_mapping_name = types_name;

/**
 * If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.
 */
export const security_put_role_mapping_refresh = types_refresh;

/**
 * An identifier for the user.
 *
 * NOTE: Usernames must be at least 1 and no more than 507 characters.
 * They can contain alphanumeric characters (a-z, A-Z, 0-9), spaces, punctuation, and printable symbols in the Basic Latin (ASCII) block.
 * Leading or trailing whitespace is not allowed.
 */
export const security_put_user_username = types_username;

/**
 * Valid values are `true`, `false`, and `wait_for`.
 * These values have the same meaning as in the index API, but the default value for this API is true.
 */
export const security_put_user_refresh = types_refresh;

/**
 * Return the snapshot of the owner user's role descriptors associated with the API key.
 * An API key's actual permission is the intersection of its assigned role descriptors and the owner user's role descriptors (effectively limited by it).
 * An API key cannot retrieve any API keys limited-by role descriptors (including itself) unless it has `manage_api_key` or higher privileges.
 */
export const security_query_api_keys_with_limited_by = z.boolean().describe('Return the snapshot of the owner user\'s role descriptors associated with the API key.\nAn API key\'s actual permission is the intersection of its assigned role descriptors and the owner user\'s role descriptors (effectively limited by it).\nAn API key cannot retrieve any API keys limited-by role descriptors (including itself) unless it has `manage_api_key` or higher privileges.');

/**
 * Determines whether to also retrieve the profile UID for the API key owner principal.
 * If it exists, the profile UID is returned under the `profile_uid` response field for each API key.
 */
export const security_query_api_keys_with_profile_uid = z.boolean().describe('Determines whether to also retrieve the profile UID for the API key owner principal.\nIf it exists, the profile UID is returned under the `profile_uid` response field for each API key.');

/**
 * Determines whether aggregation names are prefixed by their respective types in the response.
 */
export const security_query_api_keys_typed_keys = z.boolean().describe('Determines whether aggregation names are prefixed by their respective types in the response.');

/**
 * Determines whether to retrieve the user profile UID, if it exists, for the users.
 */
export const security_query_user_with_profile_uid = z.boolean().describe('Determines whether to retrieve the user profile UID, if it exists, for the users.');

/**
 * A comma-separated list of filters for the `data` field of the profile document.
 * To return all content use `data=*`.
 * To return a subset of content, use `data=<key>` to retrieve content nested under the specified `<key>`.
 * By default, the API returns no `data` content.
 * It is an error to specify `data` as both the query parameter and the request body field.
 */
export const security_suggest_user_profiles_data = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * A unique identifier for the user profile.
 */
export const security_update_user_profile_data_uid = security_types_user_profile_id;

/**
 * Only perform the operation if the document has this sequence number.
 */
export const security_update_user_profile_data_if_seq_no = types_sequence_number;

/**
 * Only perform the operation if the document has this primary term.
 */
export const security_update_user_profile_data_if_primary_term = z.number().describe('Only perform the operation if the document has this primary term.');

/**
 * If 'true', Elasticsearch refreshes the affected shards to make this operation
 * visible to search.
 * If 'wait_for', it waits for a refresh to make this operation visible to search.
 * If 'false', nothing is done with refreshes.
 */
export const security_update_user_profile_data_refresh = types_refresh;

/**
 * The index to simulate ingesting into.
 * This value can be overridden by specifying an index on each document.
 * If you specify this parameter in the request path, it is used for any documents that do not explicitly specify an index argument.
 */
export const simulate_ingest_index = types_index_name;

/**
 * The pipeline to use as the default pipeline.
 * This value can be used to override the default pipeline of the index.
 */
export const simulate_ingest_pipeline = types_pipeline_name;

/**
 * The mapping merge type if mapping overrides are being provided in mapping_addition.
 * The allowed values are one of index or template.
 * The index option merges mappings the way they would be merged into an existing index.
 * The template option merges mappings the way they would be merged into a template.
 */
export const simulate_ingest_merge_type2 = simulate_ingest_merge_type;

/**
 * Comma-separated list of snapshot lifecycle policies to retrieve
 */
export const slm_get_lifecycle_policy_id = types_names;

/**
 * The period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const slm_get_lifecycle_master_timeout = types_duration;

/**
 * The period to wait for a response.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const slm_get_lifecycle_timeout = types_duration;

/**
 * The name of the repository for the snapshot.
 */
export const snapshot_create_repository = types_name;

/**
 * The name of the snapshot.
 * It supportes date math.
 * It must be unique in the repository.
 */
export const snapshot_create_snapshot = types_name;

/**
 * The period to wait for a connection to the master node.
 * If no response is received before the timeout expires, the request fails and returns an error.
 */
export const snapshot_create_master_timeout = types_duration;

/**
 * If `true`, the request returns a response when the snapshot is complete.
 * If `false`, the request returns a response when the snapshot initializes.
 */
export const snapshot_create_wait_for_completion = z.boolean().describe('If `true`, the request returns a response when the snapshot is complete.\nIf `false`, the request returns a response when the snapshot initializes.');

/**
 * The name of the snapshot repository to register or update.
 */
export const snapshot_create_repository_repository = types_name;

/**
 * The period to wait for the master node.
 * If the master node is not available before the timeout expires, the request fails and returns an error.
 * To indicate that the request should never timeout, set it to `-1`.
 */
export const snapshot_create_repository_master_timeout = types_duration;

/**
 * The period to wait for a response from all relevant nodes in the cluster after updating the cluster metadata.
 * If no response is received before the timeout expires, the cluster metadata update still applies but the response will indicate that it was not completely acknowledged.
 * To indicate that the request should never timeout, set it to `-1`.
 */
export const snapshot_create_repository_timeout = types_duration;

/**
 * If `true`, the request verifies the repository is functional on all master and data nodes in the cluster.
 * If `false`, this verification is skipped.
 * You can also perform this verification with the verify snapshot repository API.
 */
export const snapshot_create_repository_verify = z.boolean().describe('If `true`, the request verifies the repository is functional on all master and data nodes in the cluster.\nIf `false`, this verification is skipped.\nYou can also perform this verification with the verify snapshot repository API.');

/**
 * A comma-separated list of snapshot repository names used to limit the request.
 * Wildcard (`*`) expressions are supported including combining wildcards with exclude patterns starting with `-`.
 *
 * To get information about all snapshot repositories registered in the cluster, omit this parameter or use `*` or `_all`.
 */
export const snapshot_get_repository_repository = types_names;

/**
 * If `true`, the request gets information from the local node only.
 * If `false`, the request gets information from the master node.
 */
export const snapshot_get_repository_local = z.boolean().describe('If `true`, the request gets information from the local node only.\nIf `false`, the request gets information from the master node.');

/**
 * The period to wait for the master node.
 * If the master node is not available before the timeout expires, the request fails and returns an error.
 * To indicate that the request should never timeout, set it to `-1`.
 */
export const snapshot_get_repository_master_timeout = types_duration;

/**
 * The snapshot repository name used to limit the request.
 * It supports wildcards (`*`) if `<snapshot>` isn't specified.
 */
export const snapshot_status_repository = types_name;

/**
 * A comma-separated list of snapshots to retrieve status for.
 * The default is currently running snapshots.
 * Wildcards (`*`) are not supported.
 */
export const snapshot_status_snapshot = types_names;

/**
 * If `false`, the request returns an error for any snapshots that are unavailable.
 * If `true`, the request ignores snapshots that are unavailable, such as those that are corrupted or temporarily cannot be returned.
 */
export const snapshot_status_ignore_unavailable = z.boolean().describe('If `false`, the request returns an error for any snapshots that are unavailable.\nIf `true`, the request ignores snapshots that are unavailable, such as those that are corrupted or temporarily cannot be returned.');

/**
 * The period to wait for the master node.
 * If the master node is not available before the timeout expires, the request fails and returns an error.
 * To indicate that the request should never timeout, set it to `-1`.
 */
export const snapshot_status_master_timeout = types_duration;

/**
 * The format for the response.
 * You can also specify a format using the `Accept` HTTP header.
 * If you specify both this parameter and the `Accept` HTTP header, this parameter takes precedence.
 */
export const sql_query_format = sql_query_sql_format;

/**
 * The task identifier.
 */
export const tasks_cancel_task_id = types_task_id;

/**
 * A comma-separated list or wildcard expression of actions that is used to limit the request.
 */
export const tasks_cancel_actions = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * A comma-separated list of node IDs or names that is used to limit the request.
 */
export const tasks_cancel_nodes = z.array(z.string()).describe('A comma-separated list of node IDs or names that is used to limit the request.');

/**
 * A parent task ID that is used to limit the tasks.
 */
export const tasks_cancel_parent_task_id = z.string().describe('A parent task ID that is used to limit the tasks.');

/**
 * If true, the request blocks until all found tasks are complete.
 */
export const tasks_cancel_wait_for_completion = z.boolean().describe('If true, the request blocks until all found tasks are complete.');

/**
 * A comma-separated list of data streams, indices, and index aliases to search.
 * Wildcard (`*`) expressions are supported.
 * To search all data streams or indices, omit this parameter or use `*`  or `_all`.
 */
export const terms_enum_index = types_indices;

/**
 * The name of the index that contains the document.
 */
export const termvectors_index = types_index_name;

/**
 * A unique identifier for the document.
 */
export const termvectors_id = types_id;

/**
 * A comma-separated list or wildcard expressions of fields to include in the statistics.
 * It is used as the default list unless a specific field list is provided in the `completion_fields` or `fielddata_fields` parameters.
 */
export const termvectors_fields = types_fields;

/**
 * If `true`, the response includes:
 *
 * * The document count (how many documents contain this field).
 * * The sum of document frequencies (the sum of document frequencies for all terms in this field).
 * * The sum of total term frequencies (the sum of total term frequencies of each term in this field).
 */
export const termvectors_field_statistics = z.boolean().describe('If `true`, the response includes:\n\n* The document count (how many documents contain this field).\n* The sum of document frequencies (the sum of document frequencies for all terms in this field).\n* The sum of total term frequencies (the sum of total term frequencies of each term in this field).');

/**
 * If `true`, the response includes term offsets.
 */
export const termvectors_offsets = z.boolean().describe('If `true`, the response includes term offsets.');

/**
 * If `true`, the response includes term payloads.
 */
export const termvectors_payloads = z.boolean().describe('If `true`, the response includes term payloads.');

/**
 * If `true`, the response includes term positions.
 */
export const termvectors_positions = z.boolean().describe('If `true`, the response includes term positions.');

/**
 * The node or shard the operation should be performed on.
 * It is random by default.
 */
export const termvectors_preference = z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.');

/**
 * If true, the request is real-time as opposed to near-real-time.
 */
export const termvectors_realtime = z.boolean().describe('If true, the request is real-time as opposed to near-real-time.');

/**
 * A custom value that is used to route operations to a specific shard.
 */
export const termvectors_routing = types_routing;

/**
 * If `true`, the response includes:
 *
 * * The total term frequency (how often a term occurs in all documents).
 * * The document frequency (the number of documents containing the current term).
 *
 * By default these values are not returned since term statistics can have a serious performance impact.
 */
export const termvectors_term_statistics = z.boolean().describe('If `true`, the response includes:\n\n* The total term frequency (how often a term occurs in all documents).\n* The document frequency (the number of documents containing the current term).\n\nBy default these values are not returned since term statistics can have a serious performance impact.');

/**
 * If `true`, returns the document version as part of a hit.
 */
export const termvectors_version = types_version_number;

/**
 * The version type.
 */
export const termvectors_version_type = types_version_type;

/**
 * If the format is `delimited`, you can specify the column names in a comma-separated list.
 * If this parameter is not specified, the structure finder uses the column names from the header row of the text.
 * If the text does not have a header role, columns are named "column1", "column2", "column3", for example.
 */
export const text_structure_find_message_structure_column_names = z.union([
    z.string(),
    z.array(z.string())
]);

/**
 * If you the format is `delimited`, you can specify the character used to delimit the values in each row.
 * Only a single character is supported; the delimiter cannot have multiple characters.
 * By default, the API considers the following possibilities: comma, tab, semi-colon, and pipe (`|`).
 * In this default scenario, all rows must have the same number of fields for the delimited format to be detected.
 * If you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row.
 */
export const text_structure_find_message_structure_delimiter = z.string().describe('If you the format is `delimited`, you can specify the character used to delimit the values in each row.\nOnly a single character is supported; the delimiter cannot have multiple characters.\nBy default, the API considers the following possibilities: comma, tab, semi-colon, and pipe (`|`).\nIn this default scenario, all rows must have the same number of fields for the delimited format to be detected.\nIf you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row.');

/**
 * The mode of compatibility with ECS compliant Grok patterns.
 * Use this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern.
 * This setting primarily has an impact when a whole message Grok pattern such as `%{CATALINALOG}` matches the input.
 * If the structure finder identifies a common structure but has no idea of meaning then generic field names such as `path`, `ipaddress`, `field1`, and `field2` are used in the `grok_pattern` output, with the intention that a user who knows the meanings rename these fields before using it.
 */
export const text_structure_find_message_structure_ecs_compatibility = text_structure_types_ecs_compatibility_type;

/**
 * If this parameter is set to true, the response includes a field named `explanation`, which is an array of strings that indicate how the structure finder produced its result.
 */
export const text_structure_find_message_structure_explain = z.boolean().describe('If this parameter is set to true, the response includes a field named `explanation`, which is an array of strings that indicate how the structure finder produced its result.');

/**
 * The high level structure of the text.
 * By default, the API chooses the format.
 * In this default scenario, all rows must have the same number of fields for a delimited format to be detected.
 * If the format is `delimited` and the delimiter is not set, however, the API tolerates up to 5% of rows that have a different number of columns than the first row.
 */
export const text_structure_find_message_structure_format = text_structure_types_format_type;

/**
 * If the format is `semi_structured_text`, you can specify a Grok pattern that is used to extract fields from every message in the text.
 * The name of the timestamp field in the Grok pattern must match what is specified in the `timestamp_field` parameter.
 * If that parameter is not specified, the name of the timestamp field in the Grok pattern must match "timestamp".
 * If `grok_pattern` is not specified, the structure finder creates a Grok pattern.
 */
export const text_structure_find_message_structure_grok_pattern = types_grok_pattern;

/**
 * If the format is `delimited`, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character.
 * Only a single character is supported.
 * If this parameter is not specified, the default value is a double quote (`"`).
 * If your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample.
 */
export const text_structure_find_message_structure_quote = z.string().describe('If the format is `delimited`, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character.\nOnly a single character is supported.\nIf this parameter is not specified, the default value is a double quote (`"`).\nIf your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample.');

/**
 * If the format is `delimited`, you can specify whether values between delimiters should have whitespace trimmed from them.
 * If this parameter is not specified and the delimiter is pipe (`|`), the default value is true.
 * Otherwise, the default value is `false`.
 */
export const text_structure_find_message_structure_should_trim_fields = z.boolean().describe('If the format is `delimited`, you can specify whether values between delimiters should have whitespace trimmed from them.\nIf this parameter is not specified and the delimiter is pipe (`|`), the default value is true.\nOtherwise, the default value is `false`.');

/**
 * The maximum amount of time that the structure analysis can take.
 * If the analysis is still running when the timeout expires, it will be stopped.
 */
export const text_structure_find_message_structure_timeout = types_duration;

/**
 * The name of the field that contains the primary timestamp of each record in the text.
 * In particular, if the text was ingested into an index, this is the field that would be used to populate the `@timestamp` field.
 *
 * If the format is `semi_structured_text`, this field must match the name of the appropriate extraction in the `grok_pattern`.
 * Therefore, for semi-structured text, it is best not to specify this parameter unless `grok_pattern` is also specified.
 *
 * For structured text, if you specify this parameter, the field must exist within the text.
 *
 * If this parameter is not specified, the structure finder makes a decision about which field (if any) is the primary timestamp field.
 * For structured text, it is not compulsory to have a timestamp in the text.
 */
export const text_structure_find_message_structure_timestamp_field = types_field;

/**
 * The Java time format of the timestamp field in the text.
 * Only a subset of Java time format letter groups are supported:
 *
 * * `a`
 * * `d`
 * * `dd`
 * * `EEE`
 * * `EEEE`
 * * `H`
 * * `HH`
 * * `h`
 * * `M`
 * * `MM`
 * * `MMM`
 * * `MMMM`
 * * `mm`
 * * `ss`
 * * `XX`
 * * `XXX`
 * * `yy`
 * * `yyyy`
 * * `zzz`
 *
 * Additionally `S` letter groups (fractional seconds) of length one to nine are supported providing they occur after `ss` and are separated from the `ss` by a period (`.`), comma (`,`), or colon (`:`).
 * Spacing and punctuation is also permitted with the exception a question mark (`?`), newline, and carriage return, together with literal text enclosed in single quotes.
 * For example, `MM/dd HH.mm.ss,SSSSSS 'in' yyyy` is a valid override format.
 *
 * One valuable use case for this parameter is when the format is semi-structured text, there are multiple timestamp formats in the text, and you know which format corresponds to the primary timestamp, but you do not want to specify the full `grok_pattern`.
 * Another is when the timestamp format is one that the structure finder does not consider by default.
 *
 * If this parameter is not specified, the structure finder chooses the best format from a built-in set.
 *
 * If the special value `null` is specified, the structure finder will not look for a primary timestamp in the text.
 * When the format is semi-structured text, this will result in the structure finder treating the text as single-line messages.
 */
export const text_structure_find_message_structure_timestamp_format = z.string().describe('The Java time format of the timestamp field in the text.\nOnly a subset of Java time format letter groups are supported:\n\n* `a`\n* `d`\n* `dd`\n* `EEE`\n* `EEEE`\n* `H`\n* `HH`\n* `h`\n* `M`\n* `MM`\n* `MMM`\n* `MMMM`\n* `mm`\n* `ss`\n* `XX`\n* `XXX`\n* `yy`\n* `yyyy`\n* `zzz`\n\nAdditionally `S` letter groups (fractional seconds) of length one to nine are supported providing they occur after `ss` and are separated from the `ss` by a period (`.`), comma (`,`), or colon (`:`).\nSpacing and punctuation is also permitted with the exception a question mark (`?`), newline, and carriage return, together with literal text enclosed in single quotes.\nFor example, `MM/dd HH.mm.ss,SSSSSS \'in\' yyyy` is a valid override format.\n\nOne valuable use case for this parameter is when the format is semi-structured text, there are multiple timestamp formats in the text, and you know which format corresponds to the primary timestamp, but you do not want to specify the full `grok_pattern`.\nAnother is when the timestamp format is one that the structure finder does not consider by default.\n\nIf this parameter is not specified, the structure finder chooses the best format from a built-in set.\n\nIf the special value `null` is specified, the structure finder will not look for a primary timestamp in the text.\nWhen the format is semi-structured text, this will result in the structure finder treating the text as single-line messages.');

/**
 * The mode of compatibility with ECS compliant Grok patterns.
 * Use this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern.
 * Valid values are `disabled` and `v1`.
 */
export const text_structure_test_grok_pattern_ecs_compatibility = z.string().describe('The mode of compatibility with ECS compliant Grok patterns.\nUse this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern.\nValid values are `disabled` and `v1`.');

/**
 * Identifier for the transform. It can be a transform identifier or a
 * wildcard expression. You can get information for all transforms by using
 * `_all`, by specifying `*` as the `<transform_id>`, or by omitting the
 * `<transform_id>`.
 */
export const transform_get_transform_transform_id = types_names;

/**
 * Specifies what to do when the request:
 *
 * 1. Contains wildcard expressions and there are no transforms that match.
 * 2. Contains the _all string or no identifiers and there are no matches.
 * 3. Contains wildcard expressions and there are only partial matches.
 *
 * If this parameter is false, the request returns a 404 status code when
 * there are no matches or only partial matches.
 */
export const transform_get_transform_allow_no_match = z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no transforms that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf this parameter is false, the request returns a 404 status code when\nthere are no matches or only partial matches.');

/**
 * Skips the specified number of transforms.
 */
export const transform_get_transform_from = z.number().describe('Skips the specified number of transforms.');

/**
 * Specifies the maximum number of transforms to obtain.
 */
export const transform_get_transform_size = z.number().describe('Specifies the maximum number of transforms to obtain.');

/**
 * Excludes fields that were automatically added when creating the
 * transform. This allows the configuration to be in an acceptable format to
 * be retrieved and then added to another cluster.
 */
export const transform_get_transform_exclude_generated = z.boolean().describe('Excludes fields that were automatically added when creating the\ntransform. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.');

/**
 * Identifier for the transform to preview. If you specify this path parameter, you cannot provide transform
 * configuration details in the request body.
 */
export const transform_preview_transform_transform_id = types_id;

/**
 * Period to wait for a response. If no response is received before the
 * timeout expires, the request fails and returns an error.
 */
export const transform_preview_transform_timeout = types_duration;

/**
 * The watch identifier.
 */
export const watcher_ack_watch_watch_id = types_name;

/**
 * A comma-separated list of the action identifiers to acknowledge.
 * If you omit this parameter, all of the actions of the watch are acknowledged.
 */
export const watcher_ack_watch_action_id = types_names;

/**
 * The watch identifier.
 */
export const watcher_activate_watch_watch_id = types_name;

/**
 * The watch identifier.
 */
export const watcher_deactivate_watch_watch_id = types_name;

/**
 * The watch identifier.
 */
export const watcher_execute_watch_id = types_id;

/**
 * Defines whether the watch runs in debug mode.
 */
export const watcher_execute_watch_debug = z.boolean().describe('Defines whether the watch runs in debug mode.');

/**
 * The identifier for the watch.
 */
export const watcher_put_watch_id = types_id;

/**
 * The initial state of the watch.
 * The default value is `true`, which means the watch is active by default.
 */
export const watcher_put_watch_active = z.boolean().describe('The initial state of the watch.\nThe default value is `true`, which means the watch is active by default.');

/**
 * only update the watch if the last operation that has changed the watch has the specified primary term
 */
export const watcher_put_watch_if_primary_term = z.number().describe('only update the watch if the last operation that has changed the watch has the specified primary term');

/**
 * only update the watch if the last operation that has changed the watch has the specified sequence number
 */
export const watcher_put_watch_if_seq_no = types_sequence_number;

/**
 * Explicit version number for concurrency control
 */
export const watcher_put_watch_version = types_version_number;

/**
 * Defines which additional metrics are included in the response.
 */
export const watcher_stats_metric = z.union([
    watcher_stats_watcher_metric,
    z.array(watcher_stats_watcher_metric)
]);

/**
 * Defines whether stack traces are generated for each watch that is running.
 */
export const watcher_stats_emit_stacktraces = z.boolean().describe('Defines whether stack traces are generated for each watch that is running.');

/**
 * Defines which additional metrics are included in the response.
 */
export const watcher_stats_metric2 = z.union([
    watcher_stats_watcher_metric,
    z.array(watcher_stats_watcher_metric)
]);

export const clear_scroll = z.object({
    scroll_id: types_scroll_ids.optional()
});

export const cluster_allocation_explain = z.object({
    index: types_index_name.optional(),
    shard: z.number().describe('An identifier for the shard that you would like an explanation for.').optional(),
    primary: z.boolean().describe('If true, returns an explanation for the primary shard for the specified shard ID.').optional(),
    current_node: types_node_id.optional()
});

export const connector_put = z.object({
    description: z.string().optional(),
    index_name: types_index_name.optional(),
    is_native: z.boolean().optional(),
    language: z.string().optional(),
    name: z.string().optional(),
    service_type: z.string().optional()
});

export const create = z.record(z.unknown());

export const index = z.record(z.unknown());

export const inference_inference = z.object({
    query: z.string().describe('The query input, which is required only for the `rerank` task.\nIt is not required for other tasks.').optional(),
    input: z.union([
        z.string(),
        z.array(z.string())
    ]),
    input_type: z.string().describe('Specifies the input data type for the text embedding model. The `input_type` parameter only applies to Inference Endpoints with the `text_embedding` task type. Possible values include:\n* `SEARCH`\n* `INGEST`\n* `CLASSIFICATION`\n* `CLUSTERING`\nNot all services support all values. Unsupported values will trigger a validation exception.\nAccepted values depend on the configured inference service, refer to the relevant service-specific documentation for more info.\n\n> info\n> The `input_type` parameter specified on the root level of the request body will take precedence over the `input_type` parameter specified in `task_settings`.').optional(),
    task_settings: inference_types_task_settings.optional()
});

export const inference_put = inference_types_inference_endpoint;

export const inference_update = inference_types_inference_endpoint;

export const license_post = z.object({
    license: license_types_license.optional(),
    licenses: z.array(license_types_license).describe('A sequence of one or more JSON documents containing the license information.').optional()
});

export const mget = z.object({
    docs: z.array(global_mget_operation).describe('The documents you want to retrieve. Required if no index is specified in the request URI.').optional(),
    ids: types_ids.optional()
});

export const ml_delete_expired_data = z.object({
    requests_per_second: z.number().describe('The desired requests per second for the deletion processes. The default\nbehavior is no throttling.').optional(),
    timeout: types_duration.optional()
});

export const ml_get_buckets = z.object({
    anomaly_score: z.number().describe('Refer to the description for the `anomaly_score` query parameter.').optional().default(0),
    desc: z.boolean().describe('Refer to the description for the `desc` query parameter.').optional().default(false),
    end: types_date_time.optional(),
    exclude_interim: z.boolean().describe('Refer to the description for the `exclude_interim` query parameter.').optional().default(false),
    expand: z.boolean().describe('Refer to the description for the `expand` query parameter.').optional().default(false),
    page: ml_types_page.optional(),
    sort: types_field.optional(),
    start: types_date_time.optional()
});

export const ml_get_calendars = z.object({
    page: ml_types_page.optional()
});

export const ml_get_categories = z.object({
    page: ml_types_page.optional()
});

export const ml_get_influencers = z.object({
    page: ml_types_page.optional()
});

export const ml_get_model_snapshots = z.object({
    desc: z.boolean().describe('Refer to the description for the `desc` query parameter.').optional().default(false),
    end: types_date_time.optional(),
    page: ml_types_page.optional(),
    sort: types_field.optional(),
    start: types_date_time.optional()
});

export const ml_get_overall_buckets = z.object({
    allow_no_match: z.boolean().describe('Refer to the description for the `allow_no_match` query parameter.').optional().default(true),
    bucket_span: types_duration.optional(),
    end: types_date_time.optional(),
    exclude_interim: z.boolean().describe('Refer to the description for the `exclude_interim` query parameter.').optional().default(false),
    overall_score: z.number().describe('Refer to the description for the `overall_score` query parameter.').optional(),
    start: types_date_time.optional(),
    top_n: z.number().describe('Refer to the description for the `top_n` query parameter.').optional().default(1)
});

export const ml_get_records = z.object({
    desc: z.boolean().describe('Refer to the description for the `desc` query parameter.').optional().default(false),
    end: types_date_time.optional(),
    exclude_interim: z.boolean().describe('Refer to the description for the `exclude_interim` query parameter.').optional().default(false),
    page: ml_types_page.optional(),
    record_score: z.number().describe('Refer to the description for the `record_score` query parameter.').optional().default(0),
    sort: types_field.optional(),
    start: types_date_time.optional()
});

export const mtermvectors = z.object({
    docs: z.array(global_mtermvectors_operation).describe('An array of existing or artificial documents.').optional(),
    ids: z.array(types_id).describe('A simplified syntax to specify documents by their ID if they\'re in the same index.').optional()
});

export const nodes_reload_secure_settings = z.object({
    secure_settings_password: types_password.optional()
});

export const scroll = z.object({
    scroll: types_duration.optional(),
    scroll_id: types_scroll_id
});

export const search_application_search = z.object({
    params: z.record(z.record(z.unknown())).describe('Query parameters specific to this request, which will override any defaults specified in the template.').optional()
});

export const security_change_password = z.object({
    password: types_password.optional(),
    password_hash: z.string().describe('A hash of the new password value. This must be produced using the same\nhashing algorithm as has been configured for password storage. For more details,\nsee the explanation of the `xpack.security.authc.password_hashing.algorithm`\nsetting.').optional()
});

export const security_has_privileges = z.object({
    application: z.array(security_has_privileges_application_privileges_check).optional(),
    cluster: z.array(security_types_cluster_privilege).describe('A list of the cluster privileges that you want to check.').optional(),
    index: z.array(security_has_privileges_index_privileges_check).optional()
});

export const security_has_privileges_user_profile = z.object({
    uids: z.array(security_types_user_profile_id).describe('A list of profile IDs. The privileges are checked for associated users of the profiles.'),
    privileges: security_has_privileges_user_profile_privileges_check
});

export const security_put_privileges = z.record(z.record(security_put_privileges_actions));

export const security_put_user = z.object({
    username: types_username.optional(),
    email: z.union([
        z.string(),
        z.null()
    ]).optional(),
    full_name: z.union([
        z.string(),
        z.null()
    ]).optional(),
    metadata: types_metadata.optional(),
    password: types_password.optional(),
    password_hash: z.string().describe('A hash of the user\'s password.\nThis must be produced using the same hashing algorithm as has been configured for password storage.\nFor more details, see the explanation of the `xpack.security.authc.password_hashing.algorithm` setting in the user cache and password hash algorithm documentation.\nUsing this parameter allows the client to pre-hash the password for performance and/or confidentiality reasons.\nThe `password` parameter and the `password_hash` parameter cannot be used in the same request.').optional(),
    roles: z.array(z.string()).describe('A set of roles the user has.\nThe roles determine the user\'s access permissions.\nTo create a user without any roles, specify an empty list (`[]`).').optional(),
    enabled: z.boolean().describe('Specifies whether the user is enabled.').optional().default(true)
});

export const security_suggest_user_profiles = z.object({
    name: z.string().describe('A query string used to match name-related fields in user profile documents.\nName-related fields are the user\'s `username`, `full_name`, and `email`.').optional(),
    size: z.number().describe('The number of profiles to return.').optional().default(10),
    data: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    hint: security_suggest_user_profiles_hint.optional()
});

export const security_update_user_profile_data = z.object({
    labels: z.record(z.record(z.unknown())).describe('Searchable data that you want to associate with the user profile.\nThis field supports a nested data structure.\nWithin the labels object, top-level keys cannot begin with an underscore (`_`) or contain a period (`.`).').optional(),
    data: z.record(z.record(z.unknown())).describe('Non-searchable data that you want to associate with the user profile.\nThis field supports a nested data structure.\nWithin the `data` object, top-level keys cannot begin with an underscore (`_`) or contain a period (`.`).\nThe data object is not searchable, but can be retrieved with the get user profile API.').optional()
});

export const snapshot_create = z.object({
    expand_wildcards: types_expand_wildcards.optional(),
    feature_states: z.array(z.string()).describe('The feature states to include in the snapshot.\nEach feature state includes one or more system indices containing related data.\nYou can view a list of eligible features using the get features API.\n\nIf `include_global_state` is `true`, all current feature states are included by default.\nIf `include_global_state` is `false`, no feature states are included by default.\n\nNote that specifying an empty array will result in the default behavior.\nTo exclude all feature states, regardless of the `include_global_state` value, specify an array with only the value `none` (`["none"]`).').optional(),
    ignore_unavailable: z.boolean().describe('If `true`, the request ignores data streams and indices in `indices` that are missing or closed.\nIf `false`, the request returns an error for any data stream or index that is missing or closed.').optional().default(false),
    include_global_state: z.boolean().describe('If `true`, the current cluster state is included in the snapshot.\nThe cluster state includes persistent cluster settings, composable index templates, legacy index templates, ingest pipelines, and ILM policies.\nIt also includes data stored in system indices, such as Watches and task records (configurable via `feature_states`).').optional().default(true),
    indices: types_indices.optional(),
    metadata: types_metadata.optional(),
    partial: z.boolean().describe('If `true`, it enables you to restore a partial snapshot of indices with unavailable shards.\nOnly shards that were successfully included in the snapshot will be restored.\nAll missing shards will be recreated as empty.\n\nIf `false`, the entire restore operation will fail if one or more indices included in the snapshot do not have all primary shards available.').optional().default(false)
});

export const snapshot_create_repository2 = snapshot_types_repository;

export const termvectors = z.object({
    doc: z.record(z.unknown()).describe('An artificial document (a document not present in the index) for which you want to retrieve term vectors.').optional(),
    filter: global_termvectors_filter.optional(),
    per_field_analyzer: z.record(z.string()).describe('Override the default per-field analyzer.\nThis is useful in order to generate term vectors in any fashion, especially when using artificial documents.\nWhen providing an analyzer for a field that already stores term vectors, the term vectors will be regenerated.').optional(),
    fields: z.array(types_field).describe('A list of fields to include in the statistics.\nIt is used as the default list unless a specific field list is provided in the `completion_fields` or `fielddata_fields` parameters.').optional(),
    field_statistics: z.boolean().describe('If `true`, the response includes:\n\n* The document count (how many documents contain this field).\n* The sum of document frequencies (the sum of document frequencies for all terms in this field).\n* The sum of total term frequencies (the sum of total term frequencies of each term in this field).').optional().default(true),
    offsets: z.boolean().describe('If `true`, the response includes term offsets.').optional().default(true),
    payloads: z.boolean().describe('If `true`, the response includes term payloads.').optional().default(true),
    positions: z.boolean().describe('If `true`, the response includes term positions.').optional().default(true),
    term_statistics: z.boolean().describe('If `true`, the response includes:\n\n* The total term frequency (how often a term occurs in all documents).\n* The document frequency (the number of documents containing the current term).\n\nBy default these values are not returned since term statistics can have a serious performance impact.').optional().default(false),
    routing: types_routing.optional(),
    version: types_version_number.optional(),
    version_type: types_version_type.optional()
});

export const text_structure_find_message_structure = z.object({
    messages: z.array(z.string()).describe('The list of messages you want to analyze.')
});

export const text_structure_test_grok_pattern = z.object({
    grok_pattern: types_grok_pattern,
    text: z.array(z.string()).describe('The lines of text to run the Grok pattern on.')
});

export const async_search_submit = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).optional(),
    collapse: global_search_types_field_collapse.optional(),
    explain: z.boolean().describe('If true, returns detailed information about score computation as part of a hit.').optional().default(false),
    ext: z.record(z.record(z.unknown())).describe('Configuration of search extensions defined by Elasticsearch plugins.').optional(),
    from: z.number().describe('Starting document offset. By default, you cannot page through more than 10,000\nhits using the from and size parameters. To page through more hits, use the\nsearch_after parameter.').optional().default(0),
    highlight: global_search_types_highlight.optional(),
    track_total_hits: global_search_types_track_hits.optional(),
    indices_boost: z.array(z.record(z.number())).describe('Boosts the _score of documents from specified indices.').optional(),
    docvalue_fields: z.array(types_query_dsl_field_and_format).describe('Array of wildcard (*) patterns. The request returns doc values for field\nnames matching these patterns in the hits.fields property of the response.').optional(),
    knn: z.union([
        types_knn_search,
        z.array(types_knn_search)
    ]).optional(),
    min_score: z.number().describe('Minimum _score for matching documents. Documents with a lower _score are\nnot included in search results and results collected by aggregations.').optional(),
    post_filter: types_query_dsl_query_container.optional(),
    profile: z.boolean().optional(),
    query: types_query_dsl_query_container.optional(),
    rescore: z.union([
        global_search_types_rescore,
        z.array(global_search_types_rescore)
    ]).optional(),
    script_fields: z.record(types_script_field).describe('Retrieve a script evaluation (based on different fields) for each hit.').optional(),
    search_after: types_sort_results.optional(),
    size: z.number().describe('The number of hits to return. By default, you cannot page through more\nthan 10,000 hits using the from and size parameters. To page through more\nhits, use the search_after parameter.').optional().default(10),
    slice: types_sliced_scroll.optional(),
    sort: types_sort.optional(),
    _source: global_search_types_source_config.optional(),
    fields: z.array(types_query_dsl_field_and_format).describe('Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.').optional(),
    suggest: global_search_types_suggester.optional(),
    terminate_after: z.number().describe('Maximum number of documents to collect for each shard. If a query reaches this\nlimit, Elasticsearch terminates the query early. Elasticsearch collects documents\nbefore sorting. Defaults to 0, which does not terminate query execution early.').optional().default(0),
    timeout: z.string().describe('Specifies the period of time to wait for a response from each shard. If no response\nis received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.').optional(),
    track_scores: z.boolean().describe('If true, calculate and return document scores, even if the scores are not used for sorting.').optional().default(false),
    version: z.boolean().describe('If true, returns document version as part of a hit.').optional().default(false),
    seq_no_primary_term: z.boolean().describe('If true, returns sequence number and primary term of the last modification\nof each hit. See Optimistic concurrency control.').optional(),
    stored_fields: types_fields.optional(),
    pit: global_search_types_point_in_time_reference.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional(),
    stats: z.array(z.string()).describe('Stats groups to associate with the search. Each group maintains a statistics\naggregation for its associated searches. You can retrieve these stats using\nthe indices stats API.').optional()
});

export const bulk = z.array(z.union([
    global_bulk_operation_container,
    global_bulk_update_action,
    z.record(z.unknown())
]));

export const cluster_put_component_template = z.object({
    template: indices_types_index_state,
    version: types_version_number.optional(),
    _meta: types_metadata.optional(),
    deprecated: z.boolean().describe('Marks this index template as deprecated. When creating or updating a non-deprecated index template\nthat uses deprecated components, Elasticsearch will emit a deprecation warning.').optional()
});

export const count = z.object({
    query: types_query_dsl_query_container.optional()
});

export const eql_search = z.object({
    query: z.string().describe('EQL query you wish to run.'),
    case_sensitive: z.boolean().optional(),
    event_category_field: types_field.optional(),
    tiebreaker_field: types_field.optional(),
    timestamp_field: types_field.optional(),
    fetch_size: types_uint.optional(),
    filter: z.union([
        types_query_dsl_query_container,
        z.array(types_query_dsl_query_container)
    ]).optional(),
    keep_alive: types_duration.optional(),
    keep_on_completion: z.boolean().optional(),
    wait_for_completion_timeout: types_duration.optional(),
    allow_partial_search_results: z.boolean().describe('Allow query execution also in case of shard failures.\nIf true, the query will keep running and will return results based on the available shards.\nFor sequences, the behavior can be further refined using allow_partial_sequence_results').optional().default(true),
    allow_partial_sequence_results: z.boolean().describe('This flag applies only to sequences and has effect only if allow_partial_search_results=true.\nIf true, the sequence query will return results based on the available shards, ignoring the others.\nIf false, the sequence query will return successfully, but will always have empty results.').optional().default(false),
    size: types_uint.optional(),
    fields: z.union([
        types_query_dsl_field_and_format,
        z.array(types_query_dsl_field_and_format)
    ]).optional(),
    result_position: eql_search_result_position.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional(),
    max_samples_per_key: z.number().describe('By default, the response of a sample query contains up to `10` samples, with one sample per unique set of join keys. Use the `size`\nparameter to get a smaller or larger set of samples. To retrieve more than one sample per set of join keys, use the\n`max_samples_per_key` parameter. Pipes are not supported for sample queries.').optional().default(1)
});

export const explain = z.object({
    query: types_query_dsl_query_container.optional()
});

export const field_caps = z.object({
    fields: types_fields.optional(),
    index_filter: types_query_dsl_query_container.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional()
});

export const fleet_msearch = z.array(global_msearch_request_item);

export const fleet_search = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).optional(),
    collapse: global_search_types_field_collapse.optional(),
    explain: z.boolean().describe('If true, returns detailed information about score computation as part of a hit.').optional().default(false),
    ext: z.record(z.record(z.unknown())).describe('Configuration of search extensions defined by Elasticsearch plugins.').optional(),
    from: z.number().describe('Starting document offset. By default, you cannot page through more than 10,000\nhits using the from and size parameters. To page through more hits, use the\nsearch_after parameter.').optional().default(0),
    highlight: global_search_types_highlight.optional(),
    track_total_hits: global_search_types_track_hits.optional(),
    indices_boost: z.array(z.record(z.number())).describe('Boosts the _score of documents from specified indices.').optional(),
    docvalue_fields: z.array(types_query_dsl_field_and_format).describe('Array of wildcard (*) patterns. The request returns doc values for field\nnames matching these patterns in the hits.fields property of the response.').optional(),
    min_score: z.number().describe('Minimum _score for matching documents. Documents with a lower _score are\nnot included in search results and results collected by aggregations.').optional(),
    post_filter: types_query_dsl_query_container.optional(),
    profile: z.boolean().optional(),
    query: types_query_dsl_query_container.optional(),
    rescore: z.union([
        global_search_types_rescore,
        z.array(global_search_types_rescore)
    ]).optional(),
    script_fields: z.record(types_script_field).describe('Retrieve a script evaluation (based on different fields) for each hit.').optional(),
    search_after: types_sort_results.optional(),
    size: z.number().describe('The number of hits to return. By default, you cannot page through more\nthan 10,000 hits using the from and size parameters. To page through more\nhits, use the search_after parameter.').optional().default(10),
    slice: types_sliced_scroll.optional(),
    sort: types_sort.optional(),
    _source: global_search_types_source_config.optional(),
    fields: z.array(types_query_dsl_field_and_format).describe('Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.').optional(),
    suggest: global_search_types_suggester.optional(),
    terminate_after: z.number().describe('Maximum number of documents to collect for each shard. If a query reaches this\nlimit, Elasticsearch terminates the query early. Elasticsearch collects documents\nbefore sorting. Defaults to 0, which does not terminate query execution early.').optional().default(0),
    timeout: z.string().describe('Specifies the period of time to wait for a response from each shard. If no response\nis received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.').optional(),
    track_scores: z.boolean().describe('If true, calculate and return document scores, even if the scores are not used for sorting.').optional().default(false),
    version: z.boolean().describe('If true, returns document version as part of a hit.').optional().default(false),
    seq_no_primary_term: z.boolean().describe('If true, returns sequence number and primary term of the last modification\nof each hit. See Optimistic concurrency control.').optional(),
    stored_fields: types_fields.optional(),
    pit: global_search_types_point_in_time_reference.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional(),
    stats: z.array(z.string()).describe('Stats groups to associate with the search. Each group maintains a statistics\naggregation for its associated searches. You can retrieve these stats using\nthe indices stats API.').optional()
});

export const graph_explore = z.object({
    connections: graph_types_hop.optional(),
    controls: graph_types_explore_controls.optional(),
    query: types_query_dsl_query_container.optional(),
    vertices: z.array(graph_types_vertex_definition).describe('Specifies one or more fields that contain the terms you want to include in the graph as vertices.').optional()
});

export const indices_analyze = z.object({
    analyzer: z.string().describe('The name of the analyzer that should be applied to the provided `text`.\nThis could be a built-in analyzer, or an analyzer thats been configured in the index.').optional(),
    attributes: z.array(z.string()).describe('Array of token attributes used to filter the output of the `explain` parameter.').optional(),
    char_filter: z.array(types_analysis_char_filter).describe('Array of character filters used to preprocess characters before the tokenizer.').optional(),
    explain: z.boolean().describe('If `true`, the response includes token attributes and additional details.').optional().default(false),
    field: types_field.optional(),
    filter: z.array(types_analysis_token_filter).describe('Array of token filters used to apply after the tokenizer.').optional(),
    normalizer: z.string().describe('Normalizer to use to convert text into a single token.').optional(),
    text: indices_analyze_text_to_analyze.optional(),
    tokenizer: types_analysis_tokenizer.optional()
});

export const indices_clone = z.object({
    aliases: z.record(indices_types_alias).describe('Aliases for the resulting index.').optional(),
    settings: z.record(z.record(z.unknown())).describe('Configuration options for the target index.').optional()
});

export const indices_create_from = indices_create_from_create_from;

export const indices_put_alias = z.object({
    filter: types_query_dsl_query_container.optional(),
    index_routing: types_routing.optional(),
    is_write_index: z.boolean().describe('If `true`, sets the write index or data stream for the alias.\nIf an alias points to multiple indices or data streams and `is_write_index` isnt set, the alias rejects write requests.\nIf an index alias points to one index and `is_write_index` isnt set, the index automatically acts as the write index.\nData stream aliases dont automatically set a write data stream, even if the alias points to one data stream.').optional(),
    routing: types_routing.optional(),
    search_routing: types_routing.optional()
});

export const indices_put_index_template = z.object({
    index_patterns: types_indices.optional(),
    composed_of: z.array(types_name).describe('An ordered list of component template names.\nComponent templates are merged in the order specified, meaning that the last component template specified has the highest precedence.').optional(),
    template: indices_put_index_template_index_template_mapping.optional(),
    data_stream: indices_types_data_stream_visibility.optional(),
    priority: z.number().describe('Priority to determine index template precedence when a new data stream or index is created.\nThe index template with the highest priority is chosen.\nIf no priority is specified the template is treated as though it is of priority 0 (lowest priority).\nThis number is not automatically generated by Elasticsearch.').optional(),
    version: types_version_number.optional(),
    _meta: types_metadata.optional(),
    allow_auto_create: z.boolean().describe('This setting overrides the value of the `action.auto_create_index` cluster setting.\nIf set to `true` in a template, then indices can be automatically created using that template even if auto-creation of indices is disabled via `actions.auto_create_index`.\nIf set to `false`, then indices or data streams matching the template must always be explicitly created, and may never be automatically created.').optional(),
    ignore_missing_component_templates: z.array(z.string()).describe('The configuration option ignore_missing_component_templates can be used when an index template\nreferences a component template that might not exist').optional(),
    deprecated: z.boolean().describe('Marks this index template as deprecated. When creating or updating a non-deprecated index template\nthat uses deprecated components, Elasticsearch will emit a deprecation warning.').optional()
});

export const indices_put_mapping = z.object({
    date_detection: z.boolean().describe('Controls whether dynamic date detection is enabled.').optional(),
    dynamic: types_mapping_dynamic_mapping.optional(),
    dynamic_date_formats: z.array(z.string()).describe('If date detection is enabled then new string fields are checked\nagainst \'dynamic_date_formats\' and if the value matches then\na new date field is added instead of string.').optional(),
    dynamic_templates: z.array(z.record(types_mapping_dynamic_template)).describe('Specify dynamic templates for the mapping.').optional(),
    _field_names: types_mapping_field_names_field.optional(),
    _meta: types_metadata.optional(),
    numeric_detection: z.boolean().describe('Automatically map strings into numeric data types for all fields.').optional().default(false),
    properties: z.record(types_mapping_property).describe('Mapping for a field. For new fields, this mapping can include:\n\n- Field name\n- Field data type\n- Mapping parameters').optional(),
    _routing: types_mapping_routing_field.optional(),
    _source: types_mapping_source_field.optional(),
    runtime: types_mapping_runtime_fields.optional()
});

export const indices_put_settings = indices_types_index_settings;

export const indices_put_template = z.object({
    aliases: z.record(indices_types_alias).describe('Aliases for the index.').optional(),
    index_patterns: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    mappings: types_mapping_type_mapping.optional(),
    order: z.number().describe('Order in which Elasticsearch applies this template if index\nmatches multiple templates.\n\nTemplates with lower \'order\' values are merged first. Templates with higher\n\'order\' values are merged later, overriding templates with lower values.').optional(),
    settings: indices_types_index_settings.optional(),
    version: types_version_number.optional()
});

export const indices_rollover = z.object({
    aliases: z.record(indices_types_alias).describe('Aliases for the target index.\nData streams do not support this parameter.').optional(),
    conditions: indices_rollover_rollover_conditions.optional(),
    mappings: types_mapping_type_mapping.optional(),
    settings: z.record(z.record(z.unknown())).describe('Configuration options for the index.\nData streams do not support this parameter.').optional()
});

export const indices_shrink = z.object({
    aliases: z.record(indices_types_alias).describe('The key is the alias name.\nIndex alias names support date math.').optional(),
    settings: z.record(z.record(z.unknown())).describe('Configuration options for the target index.').optional()
});

export const indices_simulate_template = z.object({
    allow_auto_create: z.boolean().describe('This setting overrides the value of the `action.auto_create_index` cluster setting.\nIf set to `true` in a template, then indices can be automatically created using that template even if auto-creation of indices is disabled via `actions.auto_create_index`.\nIf set to `false`, then indices or data streams matching the template must always be explicitly created, and may never be automatically created.').optional(),
    index_patterns: types_indices.optional(),
    composed_of: z.array(types_name).describe('An ordered list of component template names.\nComponent templates are merged in the order specified, meaning that the last component template specified has the highest precedence.').optional(),
    template: indices_put_index_template_index_template_mapping.optional(),
    data_stream: indices_types_data_stream_visibility.optional(),
    priority: z.number().describe('Priority to determine index template precedence when a new data stream or index is created.\nThe index template with the highest priority is chosen.\nIf no priority is specified the template is treated as though it is of priority 0 (lowest priority).\nThis number is not automatically generated by Elasticsearch.').optional(),
    version: types_version_number.optional(),
    _meta: types_metadata.optional(),
    ignore_missing_component_templates: z.array(z.string()).describe('The configuration option ignore_missing_component_templates can be used when an index template\nreferences a component template that might not exist').optional(),
    deprecated: z.boolean().describe('Marks this index template as deprecated. When creating or updating a non-deprecated index template\nthat uses deprecated components, Elasticsearch will emit a deprecation warning.').optional()
});

export const indices_split = z.object({
    aliases: z.record(indices_types_alias).describe('Aliases for the resulting index.').optional(),
    settings: z.record(z.record(z.unknown())).describe('Configuration options for the target index.').optional()
});

export const indices_validate_query = z.object({
    query: types_query_dsl_query_container.optional()
});

export const ingest_simulate = z.object({
    docs: z.array(ingest_types_document).describe('Sample documents to test in the pipeline.'),
    pipeline: ingest_types_pipeline.optional()
});

export const ml_explain_data_frame_analytics = z.object({
    source: ml_types_dataframe_analytics_source.optional(),
    dest: ml_types_dataframe_analytics_destination.optional(),
    analysis: ml_types_dataframe_analysis_container.optional(),
    description: z.string().describe('A description of the job.').optional(),
    model_memory_limit: z.string().describe('The approximate maximum amount of memory resources that are permitted for\nanalytical processing. If your `elasticsearch.yml` file contains an\n`xpack.ml.max_model_memory_limit` setting, an error occurs when you try to\ncreate data frame analytics jobs that have `model_memory_limit` values\ngreater than that setting.').optional().default('1gb'),
    max_num_threads: z.number().describe('The maximum number of threads to be used by the analysis. Using more\nthreads may decrease the time necessary to complete the analysis at the\ncost of using more CPU. Note that the process may use additional threads\nfor operational functionality other than the analysis itself.').optional().default(1),
    analyzed_fields: ml_types_dataframe_analysis_analyzed_fields.optional(),
    allow_lazy_start: z.boolean().describe('Specifies whether this job can start when there is insufficient machine\nlearning node capacity for it to be immediately assigned to a node.').optional().default(false)
});

export const ml_preview_data_frame_analytics = z.object({
    config: ml_preview_data_frame_analytics_dataframe_preview_config.optional()
});

export const ml_preview_datafeed = z.object({
    datafeed_config: ml_types_datafeed_config.optional(),
    job_config: ml_types_job_config.optional()
});

export const msearch = z.array(global_msearch_request_item);

export const msearch_template = z.array(global_msearch_template_request_item);

export const put_script = z.object({
    script: types_stored_script
});

export const rank_eval = z.object({
    requests: z.array(global_rank_eval_rank_eval_request_item).describe('A set of typical search requests, together with their provided ratings.'),
    metric: global_rank_eval_rank_eval_metric.optional()
});

export const render_search_template = z.object({
    id: types_id.optional(),
    file: z.string().optional(),
    params: z.record(z.record(z.unknown())).describe('Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value.').optional(),
    source: types_script_source.optional()
});

export const rollup_rollup_search = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).describe('Specifies aggregations.').optional(),
    query: types_query_dsl_query_container.optional(),
    size: z.number().describe('Must be zero if set, as rollups work on pre-aggregated data.').optional()
});

export const scripts_painless_execute = z.object({
    context: global_scripts_painless_execute_painless_context.optional(),
    context_setup: global_scripts_painless_execute_painless_context_setup.optional(),
    script: types_script.optional()
});

export const search = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).describe('Defines the aggregations that are run as part of the search request.').optional(),
    collapse: global_search_types_field_collapse.optional(),
    explain: z.boolean().describe('If `true`, the request returns detailed information about score computation as part of a hit.').optional().default(false),
    ext: z.record(z.record(z.unknown())).describe('Configuration of search extensions defined by Elasticsearch plugins.').optional(),
    from: z.number().describe('The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional().default(0),
    highlight: global_search_types_highlight.optional(),
    track_total_hits: global_search_types_track_hits.optional(),
    indices_boost: z.array(z.record(z.number())).describe('Boost the `_score` of documents from specified indices.\nThe boost value is the factor by which scores are multiplied.\nA boost value greater than `1.0` increases the score.\nA boost value between `0` and `1.0` decreases the score.').optional(),
    docvalue_fields: z.array(types_query_dsl_field_and_format).describe('An array of wildcard (`*`) field patterns.\nThe request returns doc values for field names matching these patterns in the `hits.fields` property of the response.').optional(),
    knn: z.union([
        types_knn_search,
        z.array(types_knn_search)
    ]).optional(),
    rank: types_rank_container.optional(),
    min_score: z.number().describe('The minimum `_score` for matching documents.\nDocuments with a lower `_score` are not included in search results and results collected by aggregations.').optional(),
    post_filter: types_query_dsl_query_container.optional(),
    profile: z.boolean().describe('Set to `true` to return detailed timing information about the execution of individual components in a search request.\nNOTE: This is a debugging tool and adds significant overhead to search execution.').optional().default(false),
    query: types_query_dsl_query_container.optional(),
    rescore: z.union([
        global_search_types_rescore,
        z.array(global_search_types_rescore)
    ]).optional(),
    retriever: types_retriever_container.optional(),
    script_fields: z.record(types_script_field).describe('Retrieve a script evaluation (based on different fields) for each hit.').optional(),
    search_after: types_sort_results.optional(),
    size: z.number().describe('The number of hits to return, which must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` property.').optional().default(10),
    slice: types_sliced_scroll.optional(),
    sort: types_sort.optional(),
    _source: global_search_types_source_config.optional(),
    fields: z.array(types_query_dsl_field_and_format).describe('An array of wildcard (`*`) field patterns.\nThe request returns values for field names matching these patterns in the `hits.fields` property of the response.').optional(),
    suggest: global_search_types_suggester.optional(),
    terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this property to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this property for requests that target data streams with backing indices across multiple data tiers.\n\nIf set to `0` (default), the query does not terminate early.').optional().default(0),
    timeout: z.string().describe('The period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.').optional(),
    track_scores: z.boolean().describe('If `true`, calculate and return document scores, even if the scores are not used for sorting.').optional().default(false),
    version: z.boolean().describe('If `true`, the request returns the document version as part of a hit.').optional().default(false),
    seq_no_primary_term: z.boolean().describe('If `true`, the request returns sequence number and primary term of the last modification of each hit.').optional(),
    stored_fields: types_fields.optional(),
    pit: global_search_types_point_in_time_reference.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional(),
    stats: z.array(z.string()).describe('The stats groups to associate with the search.\nEach group maintains a statistics aggregation for its associated searches.\nYou can retrieve these stats using the indices stats API.').optional()
});

export const search_mvt = z.object({
    aggs: z.record(types_aggregations_aggregation_container).describe('Sub-aggregations for the geotile_grid.\n\nIt supports the following aggregation types:\n\n- `avg`\n- `boxplot`\n- `cardinality`\n- `extended stats`\n- `max`\n- `median absolute deviation`\n- `min`\n- `percentile`\n- `percentile-rank`\n- `stats`\n- `sum`\n- `value count`\n\nThe aggregation names can\'t start with `_mvt_`. The `_mvt_` prefix is reserved for internal aggregations.').optional(),
    buffer: z.number().describe('The size, in pixels, of a clipping buffer outside the tile. This allows renderers\nto avoid outline artifacts from geometries that extend past the extent of the tile.').optional().default(5),
    exact_bounds: z.boolean().describe('If `false`, the meta layer\'s feature is the bounding box of the tile.\nIf `true`, the meta layer\'s feature is a bounding box resulting from a\n`geo_bounds` aggregation. The aggregation runs on <field> values that intersect\nthe `<zoom>/<x>/<y>` tile with `wrap_longitude` set to `false`. The resulting\nbounding box may be larger than the vector tile.').optional().default(false),
    extent: z.number().describe('The size, in pixels, of a side of the tile. Vector tiles are square with equal sides.').optional().default(4096),
    fields: types_fields.optional(),
    grid_agg: global_search_mvt_types_grid_aggregation_type.optional(),
    grid_precision: z.number().describe('Additional zoom levels available through the aggs layer. For example, if `<zoom>` is `7`\nand `grid_precision` is `8`, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndon\'t include the aggs layer.').optional().default(8),
    grid_type: global_search_mvt_types_grid_type.optional(),
    query: types_query_dsl_query_container.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional(),
    size: z.number().describe('The maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results don\'t include the hits layer.').optional().default(10000),
    sort: types_sort.optional(),
    track_total_hits: global_search_types_track_hits.optional(),
    with_labels: z.boolean().describe('If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.\n\n* `Point` and `MultiPoint` features will have one of the points selected.\n* `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.\n* `LineString` features will likewise provide a roughly central point selected from the triangle-tree.\n* The aggregation results will provide one central point for each aggregation bucket.\n\nAll attributes from the original features will also be copied to the new label features.\nIn addition, the new features will be distinguishable using the tag `_mvt_label_position`.').optional()
});

export const search_template = z.object({
    explain: z.boolean().describe('If `true`, returns detailed information about score calculation as part of each hit.\nIf you specify both this and the `explain` query parameter, the API uses only the query parameter.').optional().default(false),
    id: types_id.optional(),
    params: z.record(z.record(z.unknown())).describe('Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value.').optional(),
    profile: z.boolean().describe('If `true`, the query execution is profiled.').optional().default(false),
    source: types_script_source.optional()
});

export const security_create_api_key = z.object({
    expiration: types_duration.optional(),
    name: types_name.optional(),
    role_descriptors: z.record(security_types_role_descriptor).describe('An array of role descriptors for this API key.\nWhen it is not specified or it is an empty array, the API key will have a point in time snapshot of permissions of the authenticated user.\nIf you supply role descriptors, the resultant permissions are an intersection of API keys permissions and the authenticated user\'s permissions thereby limiting the access scope for API keys.\nThe structure of role descriptor is the same as the request for the create role API.\nFor more details, refer to the create or update roles API.\n\nNOTE: Due to the way in which this permission intersection is calculated, it is not possible to create an API key that is a child of another API key, unless the derived key is created without any privileges.\nIn this case, you must explicitly specify a role descriptor with no privileges.\nThe derived API key can be used for authentication; it will not have authority to call Elasticsearch APIs.').optional(),
    metadata: types_metadata.optional()
});

export const security_put_role = z.object({
    applications: z.array(security_types_application_privileges).describe('A list of application privilege entries.').optional(),
    cluster: z.array(security_types_cluster_privilege).describe('A list of cluster privileges. These privileges define the cluster-level actions for users with this role.').optional(),
    global: z.record(z.record(z.unknown())).describe('An object defining global privileges. A global privilege is a form of cluster privilege that is request-aware. Support for global privileges is currently limited to the management of application privileges.').optional(),
    indices: z.array(security_types_indices_privileges).describe('A list of indices permissions entries.').optional(),
    remote_indices: z.array(security_types_remote_indices_privileges).describe('A list of remote indices permissions entries.\n\nNOTE: Remote indices are effective for remote clusters configured with the API key based model.\nThey have no effect for remote clusters configured with the certificate based model.').optional(),
    remote_cluster: z.array(security_types_remote_cluster_privileges).describe('A list of remote cluster permissions entries.').optional(),
    metadata: types_metadata.optional(),
    run_as: z.array(z.string()).describe('A list of users that the owners of this role can impersonate. *Note*: in Serverless, the run-as feature is disabled. For API compatibility, you can still specify an empty `run_as` field, but a non-empty list will be rejected.').optional(),
    description: z.string().describe('Optional description of the role descriptor').optional(),
    transient_metadata: z.record(z.record(z.unknown())).describe('Indicates roles that might be incompatible with the current cluster license, specifically roles with document and field level security. When the cluster license doesnt allow certain features for a given role, this parameter is updated dynamically to list the incompatible features. If `enabled` is `false`, the role is ignored, but is still listed in the response from the authenticate API.').optional()
});

export const security_put_role_mapping = z.object({
    enabled: z.boolean().describe('Mappings that have `enabled` set to `false` are ignored when role mapping is performed.').optional(),
    metadata: types_metadata.optional(),
    roles: z.array(z.string()).describe('A list of role names that are granted to the users that match the role mapping rules.\nExactly one of `roles` or `role_templates` must be specified.').optional(),
    role_templates: z.array(security_types_role_template).describe('A list of Mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.\nExactly one of `roles` or `role_templates` must be specified.').optional(),
    rules: security_types_role_mapping_rule.optional(),
    run_as: z.array(z.string()).optional()
});

export const security_query_api_keys = z.object({
    aggregations: z.record(security_query_api_keys_api_key_aggregation_container).describe('Any aggregations to run over the corpus of returned API keys.\nAggregations and queries work together. Aggregations are computed only on the API keys that match the query.\nThis supports only a subset of aggregation types, namely: `terms`, `range`, `date_range`, `missing`,\n`cardinality`, `value_count`, `composite`, `filter`, and `filters`.\nAdditionally, aggregations only run over the same subset of fields that query works with.').optional(),
    query: security_query_api_keys_api_key_query_container.optional(),
    from: z.number().describe('The starting document offset.\nIt must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional().default(0),
    sort: types_sort.optional(),
    size: z.number().describe('The number of hits to return.\nIt must not be negative.\nThe `size` parameter can be set to `0`, in which case no API key matches are returned, only the aggregation results.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional().default(10),
    search_after: types_sort_results.optional()
});

export const security_query_role = z.object({
    query: security_query_role_role_query_container.optional(),
    from: z.number().describe('The starting document offset.\nIt must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional().default(0),
    sort: types_sort.optional(),
    size: z.number().describe('The number of hits to return.\nIt must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional().default(10),
    search_after: types_sort_results.optional()
});

export const security_query_user = z.object({
    query: security_query_user_user_query_container.optional(),
    from: z.number().describe('The starting document offset.\nIt must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional().default(0),
    sort: types_sort.optional(),
    size: z.number().describe('The number of hits to return.\nIt must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional().default(10),
    search_after: types_sort_results.optional()
});

export const simulate_ingest = z.object({
    docs: z.array(ingest_types_document).describe('Sample documents to test in the pipeline.'),
    component_template_substitutions: z.record(cluster_types_component_template_node).describe('A map of component template names to substitute component template definition objects.').optional(),
    index_template_substitutions: z.record(indices_types_index_template).describe('A map of index template names to substitute index template definition objects.').optional(),
    mapping_addition: types_mapping_type_mapping.optional(),
    pipeline_substitutions: z.record(ingest_types_pipeline).describe('Pipelines to test.\nIf you dont specify the `pipeline` request path parameter, this parameter is required.\nIf you specify both this and the request path parameter, the API only uses the request path parameter.').optional()
});

export const sql_query = z.object({
    allow_partial_search_results: z.boolean().describe('If `true`, the response has partial results when there are shard request timeouts or shard failures.\nIf `false`, the API returns an error with no partial results.').optional().default(false),
    catalog: z.string().describe('The default catalog (cluster) for queries.\nIf unspecified, the queries execute on the data in the local cluster only.').optional(),
    columnar: z.boolean().describe('If `true`, the results are in a columnar fashion: one row represents all the values of a certain column from the current page of results.\nThe API supports this parameter only for CBOR, JSON, SMILE, and YAML responses.').optional().default(false),
    cursor: z.string().describe('The cursor used to retrieve a set of paginated results.\nIf you specify a cursor, the API only uses the `columnar` and `time_zone` request body parameters.\nIt ignores other request body parameters.').optional(),
    fetch_size: z.number().describe('The maximum number of rows (or entries) to return in one response.').optional().default(1000),
    field_multi_value_leniency: z.boolean().describe('If `false`, the API returns an exception when encountering multiple values for a field.\nIf `true`, the API is lenient and returns the first value from the array with no guarantee of consistent results.').optional().default(false),
    filter: types_query_dsl_query_container.optional(),
    index_using_frozen: z.boolean().describe('If `true`, the search can run on frozen indices.').optional().default(false),
    keep_alive: types_duration.optional(),
    keep_on_completion: z.boolean().describe('If `true`, Elasticsearch stores synchronous searches if you also specify the `wait_for_completion_timeout` parameter.\nIf `false`, Elasticsearch only stores async searches that don\'t finish before the `wait_for_completion_timeout`.').optional().default(false),
    page_timeout: types_duration.optional(),
    params: z.array(z.record(z.unknown())).describe('The values for parameters in the query.').optional(),
    query: z.string().describe('The SQL query to run.').optional(),
    request_timeout: types_duration.optional(),
    runtime_mappings: types_mapping_runtime_fields.optional(),
    time_zone: types_time_zone.optional(),
    wait_for_completion_timeout: types_duration.optional()
});

export const sql_translate = z.object({
    fetch_size: z.number().describe('The maximum number of rows (or entries) to return in one response.').optional().default(1000),
    filter: types_query_dsl_query_container.optional(),
    query: z.string().describe('The SQL query to run.'),
    time_zone: types_time_zone.optional()
});

export const terms_enum = z.object({
    field: types_field,
    size: z.number().describe('The number of matching terms to return.').optional().default(10),
    timeout: types_duration.optional(),
    case_insensitive: z.boolean().describe('When `true`, the provided search string is matched against index terms without case sensitivity.').optional().default(false),
    index_filter: types_query_dsl_query_container.optional(),
    string: z.string().describe('The string to match at the start of indexed terms.\nIf it is not provided, all terms in the field are considered.\n\n> info\n> The prefix string cannot be larger than the largest possible keyword value, which is Lucene\'s term byte-length limit of 32766.').optional(),
    search_after: z.string().describe('The string after which terms in the index should be returned.\nIt allows for a form of pagination if the last result from one request is passed as the `search_after` parameter for a subsequent request.').optional()
});

export const transform_preview_transform = z.object({
    dest: transform_types_destination.optional(),
    description: z.string().describe('Free text description of the transform.').optional(),
    frequency: types_duration.optional(),
    pivot: transform_types_pivot.optional(),
    source: transform_types_source.optional(),
    settings: transform_types_settings.optional(),
    sync: transform_types_sync_container.optional(),
    retention_policy: transform_types_retention_policy_container.optional(),
    latest: transform_types_latest.optional()
});

export const watcher_execute_watch = z.object({
    action_modes: z.record(watcher_types_action_execution_mode).describe('Determines how to handle the watch actions as part of the watch execution.').optional(),
    alternative_input: z.record(z.record(z.unknown())).describe('When present, the watch uses this object as a payload instead of executing its own input.').optional(),
    ignore_condition: z.boolean().describe('When set to `true`, the watch execution uses the always condition. This can also be specified as an HTTP parameter.').optional().default(false),
    record_execution: z.boolean().describe('When set to `true`, the watch record representing the watch execution result is persisted to the `.watcher-history` index for the current time.\nIn addition, the status of the watch is updated, possibly throttling subsequent runs.\nThis can also be specified as an HTTP parameter.').optional().default(false),
    simulated_actions: watcher_types_simulated_actions.optional(),
    trigger_data: watcher_types_schedule_trigger_event.optional(),
    watch: watcher_types_watch.optional()
});

export const watcher_put_watch = z.object({
    actions: z.record(watcher_types_action).describe('The list of actions that will be run if the condition matches.').optional(),
    condition: watcher_types_condition_container.optional(),
    input: watcher_types_input_container.optional(),
    metadata: types_metadata.optional(),
    throttle_period: types_duration.optional(),
    throttle_period_in_millis: types_duration_value_unit_millis.optional(),
    transform: types_transform_container.optional(),
    trigger: watcher_types_trigger_container.optional()
});

export const watcher_query_watches = z.object({
    from: z.number().describe('The offset from the first result to fetch.\nIt must be non-negative.').optional().default(0),
    size: z.number().describe('The number of hits to return.\nIt must be non-negative.').optional().default(10),
    query: types_query_dsl_query_container.optional(),
    sort: types_sort.optional(),
    search_after: types_sort_results.optional()
});

export const async_search_delete_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const async_search_delete_response = types_acknowledged_response_base;

export const async_search_status_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        keep_alive: types_duration.optional()
    }).optional()
});

export const async_search_status_response = async_search_status_status_response_base;

export const cat_aliases_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_aliases_columns.optional(),
        s: types_names.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_aliases_response = z.array(cat_aliases_aliases_record);

export const cat_aliases1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        h: cat_types_cat_aliases_columns.optional(),
        s: types_names.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_aliases1_response = z.array(cat_aliases_aliases_record);

export const cat_allocation_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_allocation_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_allocation_response = z.array(cat_allocation_allocation_record);

export const cat_allocation1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids
    }),
    query: z.object({
        h: cat_types_cat_allocation_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_allocation1_response = z.array(cat_allocation_allocation_record);

export const cat_component_templates_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_component_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_component_templates_response = z.array(cat_component_templates_component_template);

export const cat_component_templates1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: z.string().describe('The name of the component template.\nIt accepts wildcard expressions.\nIf it is omitted, all component templates are returned.')
    }),
    query: z.object({
        h: cat_types_cat_component_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_component_templates1_response = z.array(cat_component_templates_component_template);

export const cat_count_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_count_columns.optional(),
        s: types_names.optional()
    }).optional()
});

export const cat_count_response = z.array(cat_count_count_record);

export const cat_count1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        h: cat_types_cat_count_columns.optional(),
        s: types_names.optional()
    }).optional()
});

export const cat_count1_response = z.array(cat_count_count_record);

export const cat_fielddata_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        fields: types_fields.optional(),
        h: cat_types_cat_field_data_columns.optional(),
        s: types_names.optional()
    }).optional()
});

export const cat_fielddata_response = z.array(cat_fielddata_fielddata_record);

export const cat_fielddata1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        fields: types_fields
    }),
    query: z.object({
        fields: types_fields.optional(),
        h: cat_types_cat_field_data_columns.optional(),
        s: types_names.optional()
    }).optional()
});

export const cat_fielddata1_response = z.array(cat_fielddata_fielddata_record);

export const cat_health_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        ts: z.boolean().describe('If true, returns `HH:MM:SS` and Unix epoch timestamps.').optional(),
        h: cat_types_cat_health_columns.optional(),
        s: types_names.optional()
    }).optional()
});

export const cat_health_response = z.array(cat_health_health_record);

export const cat_help_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const cat_help_response = z.record(z.unknown());

export const cat_indices_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        health: types_health_status.optional(),
        include_unloaded_segments: z.boolean().describe('If true, the response includes information from segments that are not loaded into memory.').optional(),
        pri: z.boolean().describe('If true, the response only includes information from primary shards.').optional(),
        master_timeout: types_duration.optional(),
        h: cat_types_cat_indices_columns.optional(),
        s: types_names.optional()
    }).optional()
});

export const cat_indices_response = z.array(cat_indices_indices_record);

export const cat_indices1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        health: types_health_status.optional(),
        include_unloaded_segments: z.boolean().describe('If true, the response includes information from segments that are not loaded into memory.').optional(),
        pri: z.boolean().describe('If true, the response only includes information from primary shards.').optional(),
        master_timeout: types_duration.optional(),
        h: cat_types_cat_indices_columns.optional(),
        s: types_names.optional()
    }).optional()
});

export const cat_indices1_response = z.array(cat_indices_indices_record);

export const cat_master_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_master_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_master_response = z.array(cat_master_master_record);

export const cat_ml_data_frame_analytics_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Whether to ignore if a wildcard expression matches no configs.\n(This includes `_all` string or when no configs have been specified.)').optional(),
        h: cat_types_cat_dfa_columns.optional(),
        s: cat_types_cat_dfa_columns.optional()
    }).optional()
});

export const cat_ml_data_frame_analytics_response = z.array(cat_ml_data_frame_analytics_data_frame_analytics_record);

export const cat_ml_data_frame_analytics1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Whether to ignore if a wildcard expression matches no configs.\n(This includes `_all` string or when no configs have been specified.)').optional(),
        h: cat_types_cat_dfa_columns.optional(),
        s: cat_types_cat_dfa_columns.optional()
    }).optional()
});

export const cat_ml_data_frame_analytics1_response = z.array(cat_ml_data_frame_analytics_data_frame_analytics_record);

export const cat_ml_datafeeds_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no datafeeds that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty datafeeds array when there are no matches and the subset of results when\nthere are partial matches. If `false`, the API returns a 404 status code when there are no matches or only\npartial matches.').optional(),
        h: cat_types_cat_datafeed_columns.optional(),
        s: cat_types_cat_datafeed_columns.optional()
    }).optional()
});

export const cat_ml_datafeeds_response = z.array(cat_ml_datafeeds_datafeeds_record);

export const cat_ml_datafeeds1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        datafeed_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no datafeeds that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty datafeeds array when there are no matches and the subset of results when\nthere are partial matches. If `false`, the API returns a 404 status code when there are no matches or only\npartial matches.').optional(),
        h: cat_types_cat_datafeed_columns.optional(),
        s: cat_types_cat_datafeed_columns.optional()
    }).optional()
});

export const cat_ml_datafeeds1_response = z.array(cat_ml_datafeeds_datafeeds_record);

export const cat_ml_jobs_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no jobs that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty jobs array when there are no matches and the subset of results when there\nare partial matches. If `false`, the API returns a 404 status code when there are no matches or only partial\nmatches.').optional(),
        h: cat_types_cat_anomaly_detector_columns.optional(),
        s: cat_types_cat_anomaly_detector_columns.optional()
    }).optional()
});

export const cat_ml_jobs_response = z.array(cat_ml_jobs_jobs_record);

export const cat_ml_jobs1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no jobs that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty jobs array when there are no matches and the subset of results when there\nare partial matches. If `false`, the API returns a 404 status code when there are no matches or only partial\nmatches.').optional(),
        h: cat_types_cat_anomaly_detector_columns.optional(),
        s: cat_types_cat_anomaly_detector_columns.optional()
    }).optional()
});

export const cat_ml_jobs1_response = z.array(cat_ml_jobs_jobs_record);

export const cat_ml_trained_models_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request: contains wildcard expressions and there are no models that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.\nIf `true`, the API returns an empty array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the API returns a 404 status code when there are no matches or only partial matches.').optional(),
        h: cat_types_cat_trained_models_columns.optional(),
        s: cat_types_cat_trained_models_columns.optional(),
        from: z.number().describe('Skips the specified number of transforms.').optional(),
        size: z.number().describe('The maximum number of transforms to display.').optional()
    }).optional()
});

export const cat_ml_trained_models_response = z.array(cat_ml_trained_models_trained_models_record);

export const cat_ml_trained_models1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        model_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request: contains wildcard expressions and there are no models that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.\nIf `true`, the API returns an empty array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the API returns a 404 status code when there are no matches or only partial matches.').optional(),
        h: cat_types_cat_trained_models_columns.optional(),
        s: cat_types_cat_trained_models_columns.optional(),
        from: z.number().describe('Skips the specified number of transforms.').optional(),
        size: z.number().describe('The maximum number of transforms to display.').optional()
    }).optional()
});

export const cat_ml_trained_models1_response = z.array(cat_ml_trained_models_trained_models_record);

export const cat_nodeattrs_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_nodeattrs_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_nodeattrs_response = z.array(cat_nodeattrs_node_attributes_record);

export const cat_nodes_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        full_id: z.boolean().describe('If `true`, return the full node ID. If `false`, return the shortened node ID.').optional(),
        include_unloaded_segments: z.boolean().describe('If true, the response includes information from segments that are not loaded into memory.').optional(),
        h: cat_types_cat_node_columns.optional(),
        s: types_names.optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_nodes_response = z.array(cat_nodes_nodes_record);

export const cat_pending_tasks_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_pending_tasks_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_pending_tasks_response = z.array(cat_pending_tasks_pending_tasks_record);

export const cat_plugins_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_plugins_columns.optional(),
        s: types_names.optional(),
        include_bootstrap: z.boolean().describe('Include bootstrap plugins in the response').optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_plugins_response = z.array(cat_plugins_plugins_record);

export const cat_recovery_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        active_only: z.boolean().describe('If `true`, the response only includes ongoing shard recoveries.').optional(),
        detailed: z.boolean().describe('If `true`, the response includes detailed information about shard recoveries.').optional(),
        index: types_indices.optional(),
        h: cat_types_cat_recovery_columns.optional(),
        s: types_names.optional()
    }).optional()
});

export const cat_recovery_response = z.array(cat_recovery_recovery_record);

export const cat_recovery1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        active_only: z.boolean().describe('If `true`, the response only includes ongoing shard recoveries.').optional(),
        detailed: z.boolean().describe('If `true`, the response includes detailed information about shard recoveries.').optional(),
        index: types_indices.optional(),
        h: cat_types_cat_recovery_columns.optional(),
        s: types_names.optional()
    }).optional()
});

export const cat_recovery1_response = z.array(cat_recovery_recovery_record);

export const cat_repositories_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: types_names.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_repositories_response = z.array(cat_repositories_repositories_record);

export const cat_segments_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_segments_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only\nmissing or closed indices. This behavior applies even if the request targets other open indices. For example,\na request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        allow_closed: z.boolean().describe('If true, allow closed indices to be returned in the response otherwise if false, keep the legacy behaviour\nof throwing an exception if index pattern matches closed indices').optional()
    }).optional()
});

export const cat_segments_response = z.array(cat_segments_segments_record);

export const cat_segments1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        h: cat_types_cat_segments_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only\nmissing or closed indices. This behavior applies even if the request targets other open indices. For example,\na request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        allow_closed: z.boolean().describe('If true, allow closed indices to be returned in the response otherwise if false, keep the legacy behaviour\nof throwing an exception if index pattern matches closed indices').optional()
    }).optional()
});

export const cat_segments1_response = z.array(cat_segments_segments_record);

export const cat_shards_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_shard_columns.optional(),
        s: types_names.optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_shards_response = z.array(cat_shards_shards_record);

export const cat_shards1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        h: cat_types_cat_shard_columns.optional(),
        s: types_names.optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_shards1_response = z.array(cat_shards_shards_record);

export const cat_snapshots_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        ignore_unavailable: z.boolean().describe('If `true`, the response does not include information from unavailable snapshots.').optional(),
        h: cat_types_cat_snapshots_columns.optional(),
        s: types_names.optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_snapshots_response = z.array(cat_snapshots_snapshots_record);

export const cat_snapshots1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_names
    }),
    query: z.object({
        ignore_unavailable: z.boolean().describe('If `true`, the response does not include information from unavailable snapshots.').optional(),
        h: cat_types_cat_snapshots_columns.optional(),
        s: types_names.optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_snapshots1_response = z.array(cat_snapshots_snapshots_record);

export const cat_tasks_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        actions: z.array(z.string()).describe('The task action names, which are used to limit the response.').optional(),
        detailed: z.boolean().describe('If `true`, the response includes detailed information about shard recoveries.').optional(),
        nodes: z.array(z.string()).describe('Unique node identifiers, which are used to limit the response.').optional(),
        parent_task_id: z.string().describe('The parent task identifier, which is used to limit the response.').optional(),
        h: cat_types_cat_tasks_columns.optional(),
        s: types_names.optional(),
        timeout: types_duration.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request blocks until the task has completed.').optional()
    }).optional()
});

export const cat_tasks_response = z.array(cat_tasks_tasks_record);

export const cat_templates_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_templates_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_templates_response = z.array(cat_templates_templates_record);

export const cat_templates1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        h: cat_types_cat_templates_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_templates1_response = z.array(cat_templates_templates_record);

export const cat_thread_pool_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        h: cat_types_cat_thread_pool_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_thread_pool_response = z.array(cat_thread_pool_thread_pool_record);

export const cat_thread_pool1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        thread_pool_patterns: types_names
    }),
    query: z.object({
        h: cat_types_cat_thread_pool_columns.optional(),
        s: types_names.optional(),
        local: z.boolean().describe('If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cat_thread_pool1_response = z.array(cat_thread_pool_thread_pool_record);

export const cat_transforms_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request: contains wildcard expressions and there are no transforms that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.\nIf `true`, it returns an empty transforms array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.').optional(),
        from: z.number().describe('Skips the specified number of transforms.').optional(),
        h: cat_types_cat_transform_columns.optional(),
        s: cat_types_cat_transform_columns.optional(),
        size: z.number().describe('The maximum number of transforms to obtain.').optional()
    }).optional()
});

export const cat_transforms_response = z.array(cat_transforms_transforms_record);

export const cat_transforms1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        transform_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request: contains wildcard expressions and there are no transforms that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.\nIf `true`, it returns an empty transforms array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.').optional(),
        from: z.number().describe('Skips the specified number of transforms.').optional(),
        h: cat_types_cat_transform_columns.optional(),
        s: cat_types_cat_transform_columns.optional(),
        size: z.number().describe('The maximum number of transforms to obtain.').optional()
    }).optional()
});

export const cat_transforms1_response = z.array(cat_transforms_transforms_record);

export const ccr_delete_auto_follow_pattern_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const ccr_delete_auto_follow_pattern_response = types_acknowledged_response_base;

export const ccr_get_auto_follow_pattern1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const ccr_get_auto_follow_pattern1_response = z.object({
    patterns: z.array(ccr_get_auto_follow_pattern_auto_follow_pattern)
});

export const ccr_put_auto_follow_pattern_request = z.object({
    body: z.object({
        remote_cluster: z.string().describe('The remote cluster containing the leader indices to match against.'),
        follow_index_pattern: types_index_pattern.optional(),
        leader_index_patterns: types_index_patterns.optional(),
        leader_index_exclusion_patterns: types_index_patterns.optional(),
        max_outstanding_read_requests: z.number().describe('The maximum number of outstanding reads requests from the remote cluster.').optional().default(12),
        settings: z.record(z.record(z.unknown())).describe('Settings to override from the leader index. Note that certain settings can not be overrode (e.g., index.number_of_shards).').optional(),
        max_outstanding_write_requests: z.number().describe('The maximum number of outstanding reads requests from the remote cluster.').optional().default(9),
        read_poll_timeout: types_duration.optional(),
        max_read_request_operation_count: z.number().describe('The maximum number of operations to pull per read from the remote cluster.').optional().default(5120),
        max_read_request_size: types_byte_size.optional(),
        max_retry_delay: types_duration.optional(),
        max_write_buffer_count: z.number().describe('The maximum number of operations that can be queued for writing. When this limit is reached, reads from the remote cluster will be deferred until the number of queued operations goes below the limit.').optional().default(2147483647),
        max_write_buffer_size: types_byte_size.optional(),
        max_write_request_operation_count: z.number().describe('The maximum number of operations per bulk write request executed on the follower.').optional().default(5120),
        max_write_request_size: types_byte_size.optional()
    }),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const ccr_put_auto_follow_pattern_response = types_acknowledged_response_base;

export const ccr_follow_info_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const ccr_follow_info_response = z.object({
    follower_indices: z.array(ccr_follow_info_follower_index)
});

export const ccr_follow_stats_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const ccr_follow_stats_response = z.object({
    indices: z.array(ccr_types_follow_index_stats).describe('An array of follower index statistics.')
});

export const ccr_forget_follower_request = z.object({
    body: z.object({
        follower_cluster: z.string().optional(),
        follower_index: types_index_name.optional(),
        follower_index_uuid: types_uuid.optional(),
        leader_remote_cluster: z.string().optional()
    }),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const ccr_forget_follower_response = z.object({
    _shards: types_shard_statistics
});

export const ccr_get_auto_follow_pattern_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const ccr_get_auto_follow_pattern_response = z.object({
    patterns: z.array(ccr_get_auto_follow_pattern_auto_follow_pattern)
});

export const ccr_pause_auto_follow_pattern_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const ccr_pause_auto_follow_pattern_response = types_acknowledged_response_base;

export const ccr_pause_follow_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const ccr_pause_follow_response = types_acknowledged_response_base;

export const ccr_resume_auto_follow_pattern_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const ccr_resume_auto_follow_pattern_response = types_acknowledged_response_base;

export const ccr_resume_follow_request = z.object({
    body: z.object({
        max_outstanding_read_requests: z.number().optional(),
        max_outstanding_write_requests: z.number().optional(),
        max_read_request_operation_count: z.number().optional(),
        max_read_request_size: z.string().optional(),
        max_retry_delay: types_duration.optional(),
        max_write_buffer_count: z.number().optional(),
        max_write_buffer_size: z.string().optional(),
        max_write_request_operation_count: z.number().optional(),
        max_write_request_size: z.string().optional(),
        read_poll_timeout: types_duration.optional()
    }).optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const ccr_resume_follow_response = types_acknowledged_response_base;

export const ccr_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ccr_stats_response = z.object({
    auto_follow_stats: ccr_stats_auto_follow_stats,
    follow_stats: ccr_stats_follow_stats
});

export const ccr_unfollow_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const ccr_unfollow_response = types_acknowledged_response_base;

export const clear_scroll_request = z.object({
    body: clear_scroll.optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const clear_scroll_response = z.object({
    succeeded: z.boolean().describe('If `true`, the request succeeded.\nThis does not indicate whether any scrolling search requests were cleared.'),
    num_freed: z.number().describe('The number of scrolling search requests cleared.')
});

export const clear_scroll1_request = z.object({
    body: clear_scroll.optional(),
    path: z.object({
        scroll_id: types_scroll_ids
    }),
    query: z.never().optional()
});

export const clear_scroll1_response = z.object({
    succeeded: z.boolean().describe('If `true`, the request succeeded.\nThis does not indicate whether any scrolling search requests were cleared.'),
    num_freed: z.number().describe('The number of scrolling search requests cleared.')
});

export const close_point_in_time_request = z.object({
    body: z.object({
        id: types_id
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const close_point_in_time_response = z.object({
    succeeded: z.boolean().describe('If `true`, all search contexts associated with the point-in-time ID were successfully closed.'),
    num_freed: z.number().describe('The number of search contexts that were successfully closed.')
});

export const cluster_allocation_explain_request = z.object({
    body: cluster_allocation_explain.optional(),
    path: z.never().optional(),
    query: z.object({
        index: types_index_name.optional(),
        shard: z.number().describe('An identifier for the shard that you would like an explanation for.').optional(),
        primary: z.boolean().describe('If true, returns an explanation for the primary shard for the specified shard ID.').optional(),
        current_node: types_node_id.optional(),
        include_disk_info: z.boolean().describe('If true, returns information about disk usage and shard sizes.').optional(),
        include_yes_decisions: z.boolean().describe('If true, returns YES decisions in explanation.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cluster_allocation_explain_response = z.object({
    allocate_explanation: z.string().optional(),
    allocation_delay: types_duration.optional(),
    allocation_delay_in_millis: types_duration_value_unit_millis.optional(),
    can_allocate: cluster_allocation_explain_decision.optional(),
    can_move_to_other_node: cluster_allocation_explain_decision.optional(),
    can_rebalance_cluster: cluster_allocation_explain_decision.optional(),
    can_rebalance_cluster_decisions: z.array(cluster_allocation_explain_allocation_decision).optional(),
    can_rebalance_to_other_node: cluster_allocation_explain_decision.optional(),
    can_remain_decisions: z.array(cluster_allocation_explain_allocation_decision).optional(),
    can_remain_on_current_node: cluster_allocation_explain_decision.optional(),
    cluster_info: cluster_allocation_explain_cluster_info.optional(),
    configured_delay: types_duration.optional(),
    configured_delay_in_millis: types_duration_value_unit_millis.optional(),
    current_node: cluster_allocation_explain_current_node.optional(),
    current_state: z.string(),
    index: types_index_name,
    move_explanation: z.string().optional(),
    node_allocation_decisions: z.array(cluster_allocation_explain_node_allocation_explanation).optional(),
    primary: z.boolean(),
    rebalance_explanation: z.string().optional(),
    remaining_delay: types_duration.optional(),
    remaining_delay_in_millis: types_duration_value_unit_millis.optional(),
    shard: z.number(),
    unassigned_info: cluster_allocation_explain_unassigned_information.optional(),
    note: z.string().optional()
});

export const cluster_allocation_explain1_request = z.object({
    body: cluster_allocation_explain.optional(),
    path: z.never().optional(),
    query: z.object({
        index: types_index_name.optional(),
        shard: z.number().describe('An identifier for the shard that you would like an explanation for.').optional(),
        primary: z.boolean().describe('If true, returns an explanation for the primary shard for the specified shard ID.').optional(),
        current_node: types_node_id.optional(),
        include_disk_info: z.boolean().describe('If true, returns information about disk usage and shard sizes.').optional(),
        include_yes_decisions: z.boolean().describe('If true, returns YES decisions in explanation.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cluster_allocation_explain1_response = z.object({
    allocate_explanation: z.string().optional(),
    allocation_delay: types_duration.optional(),
    allocation_delay_in_millis: types_duration_value_unit_millis.optional(),
    can_allocate: cluster_allocation_explain_decision.optional(),
    can_move_to_other_node: cluster_allocation_explain_decision.optional(),
    can_rebalance_cluster: cluster_allocation_explain_decision.optional(),
    can_rebalance_cluster_decisions: z.array(cluster_allocation_explain_allocation_decision).optional(),
    can_rebalance_to_other_node: cluster_allocation_explain_decision.optional(),
    can_remain_decisions: z.array(cluster_allocation_explain_allocation_decision).optional(),
    can_remain_on_current_node: cluster_allocation_explain_decision.optional(),
    cluster_info: cluster_allocation_explain_cluster_info.optional(),
    configured_delay: types_duration.optional(),
    configured_delay_in_millis: types_duration_value_unit_millis.optional(),
    current_node: cluster_allocation_explain_current_node.optional(),
    current_state: z.string(),
    index: types_index_name,
    move_explanation: z.string().optional(),
    node_allocation_decisions: z.array(cluster_allocation_explain_node_allocation_explanation).optional(),
    primary: z.boolean(),
    rebalance_explanation: z.string().optional(),
    remaining_delay: types_duration.optional(),
    remaining_delay_in_millis: types_duration_value_unit_millis.optional(),
    shard: z.number(),
    unassigned_info: cluster_allocation_explain_unassigned_information.optional(),
    note: z.string().optional()
});

export const cluster_delete_component_template_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const cluster_delete_component_template_response = types_acknowledged_response_base;

export const cluster_exists_component_template_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        local: z.boolean().describe('If true, the request retrieves information from the local node only.\nDefaults to false, which means information is retrieved from the master node.').optional()
    }).optional()
});

export const cluster_delete_voting_config_exclusions_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        wait_for_removal: z.boolean().describe('Specifies whether to wait for all excluded nodes to be removed from the\ncluster before clearing the voting configuration exclusions list.\nDefaults to true, meaning that all excluded nodes must be removed from\nthe cluster before this API takes any action. If set to false then the\nvoting configuration exclusions list is cleared even if some excluded\nnodes are still in the cluster.').optional()
    }).optional()
});

export const cluster_post_voting_config_exclusions_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        node_names: types_names.optional(),
        node_ids: types_ids.optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const cluster_get_settings_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        include_defaults: z.boolean().describe('If `true`, also returns default values for all other cluster settings, reflecting the values\nin the `elasticsearch.yml` file of one of the nodes in the cluster. If the nodes in your\ncluster do not all have the same values in their `elasticsearch.yml` config files then the\nvalues returned by this API may vary from invocation to invocation and may not reflect the\nvalues that Elasticsearch uses in all situations. Use the `GET _nodes/settings` API to\nfetch the settings for each individual node in your cluster.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const cluster_get_settings_response = z.object({
    persistent: z.record(z.record(z.unknown())).describe('The settings that persist after the cluster restarts.'),
    transient: z.record(z.record(z.unknown())).describe('The settings that do not persist after the cluster restarts.'),
    defaults: z.record(z.record(z.unknown())).describe('The default setting values.').optional()
});

export const cluster_put_settings_request = z.object({
    body: z.object({
        persistent: z.record(z.record(z.unknown())).describe('The settings that persist after the cluster restarts.').optional(),
        transient: z.record(z.record(z.unknown())).describe('The settings that do not persist after the cluster restarts.').optional()
    }),
    path: z.never().optional(),
    query: z.object({
        flat_settings: z.boolean().describe('Return settings in flat format (default: false)').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const cluster_put_settings_response = z.object({
    acknowledged: z.boolean(),
    persistent: z.record(z.record(z.unknown())),
    transient: z.record(z.record(z.unknown()))
});

export const cluster_health_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        level: types_level.optional(),
        local: z.boolean().describe('If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        wait_for_events: types_wait_for_events.optional(),
        wait_for_nodes: cluster_health_wait_for_nodes.optional(),
        wait_for_no_initializing_shards: z.boolean().describe('A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard initializations. Defaults to false, which means it will not wait for initializing shards.').optional(),
        wait_for_no_relocating_shards: z.boolean().describe('A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard relocations. Defaults to false, which means it will not wait for relocating shards.').optional(),
        wait_for_status: types_health_status.optional()
    }).optional()
});

export const cluster_health_response = cluster_health_health_response_body;

export const cluster_health1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        level: types_level.optional(),
        local: z.boolean().describe('If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        wait_for_events: types_wait_for_events.optional(),
        wait_for_nodes: cluster_health_wait_for_nodes.optional(),
        wait_for_no_initializing_shards: z.boolean().describe('A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard initializations. Defaults to false, which means it will not wait for initializing shards.').optional(),
        wait_for_no_relocating_shards: z.boolean().describe('A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard relocations. Defaults to false, which means it will not wait for relocating shards.').optional(),
        wait_for_status: types_health_status.optional()
    }).optional()
});

export const cluster_health1_response = cluster_health_health_response_body;

export const cluster_info_request = z.object({
    body: z.never().optional(),
    path: z.object({
        target: types_cluster_info_targets
    }),
    query: z.never().optional()
});

export const cluster_info_response = z.object({
    cluster_name: types_name,
    http: nodes_types_http.optional(),
    ingest: nodes_types_ingest.optional(),
    thread_pool: z.record(nodes_types_thread_count).optional(),
    script: nodes_types_scripting.optional()
});

export const cluster_pending_tasks_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.\nIf `false`, information is retrieved from the master node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cluster_pending_tasks_response = z.object({
    tasks: z.array(cluster_pending_tasks_pending_task)
});

export const cluster_remote_info_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const cluster_remote_info_response = z.record(cluster_remote_info_cluster_remote_info);

export const cluster_reroute_request = z.object({
    body: z.object({
        commands: z.array(cluster_reroute_command).describe('Defines the commands to perform.').optional()
    }).optional(),
    path: z.never().optional(),
    query: z.object({
        dry_run: z.boolean().describe('If true, then the request simulates the operation.\nIt will calculate the result of applying the commands to the current cluster state and return the resulting cluster state after the commands (and rebalancing) have been applied; it will not actually perform the requested changes.').optional(),
        explain: z.boolean().describe('If true, then the response contains an explanation of why the commands can or cannot run.').optional(),
        metric: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        retry_failed: z.boolean().describe('If true, then retries allocation of shards that are blocked due to too many subsequent allocation failures.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const cluster_reroute_response = z.object({
    acknowledged: z.boolean(),
    explanations: z.array(cluster_reroute_reroute_explanation).optional(),
    state: z.record(z.unknown()).describe('There aren\'t any guarantees on the output/structure of the raw cluster state.\nHere you will find the internal representation of the cluster, which can\ndiffer from the external representation.').optional()
});

export const cluster_state_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('Return settings in flat format (default: false)').optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional(),
        local: z.boolean().describe('Return local information, do not retrieve the state from master node (default: false)').optional(),
        master_timeout: types_duration.optional(),
        wait_for_metadata_version: types_version_number.optional(),
        wait_for_timeout: types_duration.optional()
    }).optional()
});

export const cluster_state_response = z.record(z.unknown());

export const cluster_state1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        metric: cluster_state_cluster_state_metrics
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('Return settings in flat format (default: false)').optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional(),
        local: z.boolean().describe('Return local information, do not retrieve the state from master node (default: false)').optional(),
        master_timeout: types_duration.optional(),
        wait_for_metadata_version: types_version_number.optional(),
        wait_for_timeout: types_duration.optional()
    }).optional()
});

export const cluster_state1_response = z.record(z.unknown());

export const cluster_state2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        metric: cluster_state_cluster_state_metrics,
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('Return settings in flat format (default: false)').optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional(),
        local: z.boolean().describe('Return local information, do not retrieve the state from master node (default: false)').optional(),
        master_timeout: types_duration.optional(),
        wait_for_metadata_version: types_version_number.optional(),
        wait_for_timeout: types_duration.optional()
    }).optional()
});

export const cluster_state2_response = z.record(z.unknown());

export const cluster_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        include_remotes: z.boolean().describe('Include remote cluster data into the response').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const cluster_stats_response = cluster_stats_stats_response_base;

export const cluster_stats1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids
    }),
    query: z.object({
        include_remotes: z.boolean().describe('Include remote cluster data into the response').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const cluster_stats1_response = cluster_stats_stats_response_base;

export const connector_check_in_request = z.object({
    body: z.never().optional(),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_check_in_response = z.object({
    result: types_result
});

export const connector_delete_request = z.object({
    body: z.never().optional(),
    path: z.object({
        connector_id: types_id
    }),
    query: z.object({
        delete_sync_jobs: z.boolean().describe('A flag indicating if associated sync jobs should be also removed.').optional(),
        hard: z.boolean().describe('A flag indicating if the connector should be hard deleted.').optional()
    }).optional()
});

export const connector_delete_response = types_acknowledged_response_base;

export const connector_get_request = z.object({
    body: z.never().optional(),
    path: z.object({
        connector_id: types_id
    }),
    query: z.object({
        include_deleted: z.boolean().describe('A flag to indicate if the desired connector should be fetched, even if it was soft-deleted.').optional()
    }).optional()
});

export const connector_get_response = connector_types_connector;

export const connector_put_request = z.object({
    body: connector_put.optional(),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_put_response = z.object({
    result: types_result,
    id: types_id
});

export const connector_list_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        from: z.number().describe('Starting offset').optional(),
        size: z.number().describe('Specifies a max number of results to get').optional(),
        index_name: types_indices.optional(),
        connector_name: types_names.optional(),
        service_type: types_names.optional(),
        include_deleted: z.boolean().describe('A flag to indicate if the desired connector should be fetched, even if it was soft-deleted.').optional(),
        query: z.string().describe('A wildcard query string that filters connectors with matching name, description or index name').optional()
    }).optional()
});

export const connector_list_response = z.object({
    count: z.number(),
    results: z.array(connector_types_connector)
});

export const connector_post_request = z.object({
    body: z.object({
        description: z.string().optional(),
        index_name: types_index_name.optional(),
        is_native: z.boolean().optional(),
        language: z.string().optional(),
        name: z.string().optional(),
        service_type: z.string().optional()
    }).optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const connector_post_response = z.object({
    result: types_result,
    id: types_id
});

export const connector_put1_request = z.object({
    body: connector_put.optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const connector_put1_response = z.object({
    result: types_result,
    id: types_id
});

export const connector_sync_job_cancel_request = z.object({
    body: z.never().optional(),
    path: z.object({
        connector_sync_job_id: types_id
    }),
    query: z.never().optional()
});

export const connector_sync_job_cancel_response = z.object({
    result: types_result
});

export const connector_sync_job_check_in_request = z.object({
    body: z.never().optional(),
    path: z.object({
        connector_sync_job_id: types_id
    }),
    query: z.never().optional()
});

export const connector_sync_job_check_in_response = z.record(z.unknown());

export const connector_sync_job_claim_request = z.object({
    body: z.object({
        sync_cursor: z.record(z.unknown()).describe('The cursor object from the last incremental sync job.\nThis should reference the `sync_cursor` field in the connector state for which the job runs.').optional(),
        worker_hostname: z.string().describe('The host name of the current system that will run the job.')
    }),
    path: z.object({
        connector_sync_job_id: types_id
    }),
    query: z.never().optional()
});

export const connector_sync_job_claim_response = z.record(z.unknown());

export const connector_sync_job_delete_request = z.object({
    body: z.never().optional(),
    path: z.object({
        connector_sync_job_id: types_id
    }),
    query: z.never().optional()
});

export const connector_sync_job_delete_response = types_acknowledged_response_base;

export const connector_sync_job_get_request = z.object({
    body: z.never().optional(),
    path: z.object({
        connector_sync_job_id: types_id
    }),
    query: z.never().optional()
});

export const connector_sync_job_get_response = connector_types_connector_sync_job;

export const connector_sync_job_error_request = z.object({
    body: z.object({
        error: z.string().describe('The error for the connector sync job error field.')
    }),
    path: z.object({
        connector_sync_job_id: types_id
    }),
    query: z.never().optional()
});

export const connector_sync_job_error_response = z.record(z.unknown());

export const connector_sync_job_list_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        from: z.number().describe('Starting offset').optional(),
        size: z.number().describe('Specifies a max number of results to get').optional(),
        status: connector_types_sync_status.optional(),
        connector_id: types_id.optional(),
        job_type: z.union([
            connector_types_sync_job_type,
            z.array(connector_types_sync_job_type)
        ]).optional()
    }).optional()
});

export const connector_sync_job_list_response = z.object({
    count: z.number(),
    results: z.array(connector_types_connector_sync_job)
});

export const connector_sync_job_post_request = z.object({
    body: z.object({
        id: types_id,
        job_type: connector_types_sync_job_type.optional(),
        trigger_method: connector_types_sync_job_trigger_method.optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const connector_sync_job_post_response = z.object({
    id: types_id
});

export const connector_sync_job_update_stats_request = z.object({
    body: z.object({
        deleted_document_count: z.number().describe('The number of documents the sync job deleted.'),
        indexed_document_count: z.number().describe('The number of documents the sync job indexed.'),
        indexed_document_volume: z.number().describe('The total size of the data (in MiB) the sync job indexed.'),
        last_seen: types_duration.optional(),
        metadata: types_metadata.optional(),
        total_document_count: z.number().describe('The total number of documents in the target index after the sync job finished.').optional()
    }),
    path: z.object({
        connector_sync_job_id: types_id
    }),
    query: z.never().optional()
});

export const connector_sync_job_update_stats_response = z.record(z.unknown());

export const connector_update_active_filtering_request = z.object({
    body: z.never().optional(),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_active_filtering_response = z.object({
    result: types_result
});

export const connector_update_api_key_id_request = z.object({
    body: z.object({
        api_key_id: z.string().optional(),
        api_key_secret_id: z.string().optional()
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_api_key_id_response = z.object({
    result: types_result
});

export const connector_update_configuration_request = z.object({
    body: z.object({
        configuration: connector_types_connector_configuration.optional(),
        values: z.record(z.record(z.unknown())).optional()
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_configuration_response = z.object({
    result: types_result
});

export const connector_update_error_request = z.object({
    body: z.object({
        error: z.union([
            z.string(),
            spec_utils_null_value
        ])
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_error_response = z.object({
    result: types_result
});

export const connector_update_features_request = z.object({
    body: z.object({
        features: connector_types_connector_features
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_features_response = z.object({
    result: types_result
});

export const connector_update_filtering_request = z.object({
    body: z.object({
        filtering: z.array(connector_types_filtering_config).optional(),
        rules: z.array(connector_types_filtering_rule).optional(),
        advanced_snippet: connector_types_filtering_advanced_snippet.optional()
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_filtering_response = z.object({
    result: types_result
});

export const connector_update_filtering_validation_request = z.object({
    body: z.object({
        validation: connector_types_filtering_rules_validation
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_filtering_validation_response = z.object({
    result: types_result
});

export const connector_update_index_name_request = z.object({
    body: z.object({
        index_name: z.union([
            types_index_name,
            spec_utils_null_value
        ])
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_index_name_response = z.object({
    result: types_result
});

export const connector_update_name_request = z.object({
    body: z.object({
        name: z.string().optional(),
        description: z.string().optional()
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_name_response = z.object({
    result: types_result
});

export const connector_update_native_request = z.object({
    body: z.object({
        is_native: z.boolean()
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_native_response = z.object({
    result: types_result
});

export const connector_update_pipeline_request = z.object({
    body: z.object({
        pipeline: connector_types_ingest_pipeline_params
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_pipeline_response = z.object({
    result: types_result
});

export const connector_update_scheduling_request = z.object({
    body: z.object({
        scheduling: connector_types_scheduling_configuration
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_scheduling_response = z.object({
    result: types_result
});

export const connector_update_service_type_request = z.object({
    body: z.object({
        service_type: z.string()
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_service_type_response = z.object({
    result: types_result
});

export const connector_update_status_request = z.object({
    body: z.object({
        status: connector_types_connector_status
    }),
    path: z.object({
        connector_id: types_id
    }),
    query: z.never().optional()
});

export const connector_update_status_response = z.object({
    result: types_result
});

export const create1_request = z.object({
    body: create,
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        include_source_on_error: z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.').optional(),
        pipeline: z.string().describe('The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.').optional(),
        refresh: types_refresh.optional(),
        require_alias: z.boolean().describe('If `true`, the destination must be an index alias.').optional(),
        require_data_stream: z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).').optional(),
        routing: types_routing.optional(),
        timeout: types_duration.optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const create1_response = types_write_response_base;

export const create_request = z.object({
    body: create,
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        include_source_on_error: z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.').optional(),
        pipeline: z.string().describe('The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.').optional(),
        refresh: types_refresh.optional(),
        require_alias: z.boolean().describe('If `true`, the destination must be an index alias.').optional(),
        require_data_stream: z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).').optional(),
        routing: types_routing.optional(),
        timeout: types_duration.optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const create_response = types_write_response_base;

export const dangling_indices_delete_dangling_index_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index_uuid: types_uuid
    }),
    query: z.object({
        accept_data_loss: z.boolean().describe('This parameter must be set to true to acknowledge that it will no longer be possible to recove data from the dangling index.'),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    })
});

export const dangling_indices_delete_dangling_index_response = types_acknowledged_response_base;

export const dangling_indices_import_dangling_index_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index_uuid: types_uuid
    }),
    query: z.object({
        accept_data_loss: z.boolean().describe('This parameter must be set to true to import a dangling index.\nBecause Elasticsearch cannot know where the dangling index data came from or determine which shard copies are fresh and which are stale, it cannot guarantee that the imported data represents the latest state of the index when it was last in the cluster.'),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    })
});

export const dangling_indices_import_dangling_index_response = types_acknowledged_response_base;

export const dangling_indices_list_dangling_indices_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const dangling_indices_list_dangling_indices_response = z.object({
    dangling_indices: z.array(dangling_indices_list_dangling_indices_dangling_index)
});

export const delete_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        if_primary_term: z.number().describe('Only perform the operation if the document has this primary term.').optional(),
        if_seq_no: types_sequence_number.optional(),
        refresh: types_refresh.optional(),
        routing: types_routing.optional(),
        timeout: types_duration.optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const delete_response = types_write_response_base;

export const get_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        preference: z.string().describe('The node or shard the operation should be performed on.\nBy default, the operation is randomized between the shard replicas.\n\nIf it is set to `_local`, the operation will prefer to be run on a local allocated shard when possible.\nIf it is set to a custom value, the value is used to guarantee that the same shards will be used for the same custom value.\nThis can help with "jumping values" when hitting different shards in different refresh states.\nA sample value can be something like the web session ID or the user name.').optional(),
        realtime: z.boolean().describe('If `true`, the request is real-time as opposed to near-real-time.').optional(),
        refresh: z.boolean().describe('If `true`, the request refreshes the relevant shards before retrieving the document.\nSetting it to `true` should be done after careful thought and verification that this does not cause a heavy load on the system (and slow down indexing).').optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_exclude_vectors: z.boolean().describe('Whether vectors should be excluded from _source').optional(),
        _source_includes: types_fields.optional(),
        stored_fields: types_fields.optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const get_response = global_get_get_result;

export const exists_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        preference: z.string().describe('The node or shard the operation should be performed on.\nBy default, the operation is randomized between the shard replicas.\n\nIf it is set to `_local`, the operation will prefer to be run on a local allocated shard when possible.\nIf it is set to a custom value, the value is used to guarantee that the same shards will be used for the same custom value.\nThis can help with "jumping values" when hitting different shards in different refresh states.\nA sample value can be something like the web session ID or the user name.').optional(),
        realtime: z.boolean().describe('If `true`, the request is real-time as opposed to near-real-time.').optional(),
        refresh: z.boolean().describe('If `true`, the request refreshes the relevant shards before retrieving the document.\nSetting it to `true` should be done after careful thought and verification that this does not cause a heavy load on the system (and slow down indexing).').optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        stored_fields: types_fields.optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const index1_request = z.object({
    body: index,
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        if_primary_term: z.number().describe('Only perform the operation if the document has this primary term.').optional(),
        if_seq_no: types_sequence_number.optional(),
        include_source_on_error: z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.').optional(),
        op_type: types_op_type.optional(),
        pipeline: z.string().describe('The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.').optional(),
        refresh: types_refresh.optional(),
        routing: types_routing.optional(),
        timeout: types_duration.optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        require_alias: z.boolean().describe('If `true`, the destination must be an index alias.').optional(),
        require_data_stream: z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).').optional()
    }).optional()
});

export const index1_response = types_write_response_base;

export const index_request = z.object({
    body: index,
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        if_primary_term: z.number().describe('Only perform the operation if the document has this primary term.').optional(),
        if_seq_no: types_sequence_number.optional(),
        include_source_on_error: z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.').optional(),
        op_type: types_op_type.optional(),
        pipeline: z.string().describe('The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.').optional(),
        refresh: types_refresh.optional(),
        routing: types_routing.optional(),
        timeout: types_duration.optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        require_alias: z.boolean().describe('If `true`, the destination must be an index alias.').optional(),
        require_data_stream: z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).').optional()
    }).optional()
});

export const index_response = types_write_response_base;

export const delete_by_query_rethrottle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        task_id: types_task_id
    }),
    query: z.object({
        requests_per_second: z.number().describe('The throttle for this request in sub-requests per second.\nTo disable throttling, set it to `-1`.').optional()
    }).optional()
});

export const delete_by_query_rethrottle_response = tasks_types_task_list_response_base;

export const delete_script_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const delete_script_response = types_acknowledged_response_base;

export const enrich_delete_policy_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const enrich_delete_policy_response = types_acknowledged_response_base;

export const enrich_execute_policy_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request blocks other enrich policy execution requests until complete.').optional()
    }).optional()
});

export const enrich_execute_policy_response = z.object({
    status: enrich_execute_policy_execute_enrich_policy_status.optional(),
    task: types_task_id.optional()
});

export const enrich_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const enrich_stats_response = z.object({
    coordinator_stats: z.array(enrich_stats_coordinator_stats).describe('Objects containing information about each coordinating ingest node for configured enrich processors.'),
    executing_policies: z.array(enrich_stats_executing_policy).describe('Objects containing information about each enrich policy that is currently executing.'),
    cache_stats: z.array(enrich_stats_cache_stats).describe('Objects containing information about the enrich cache stats on each ingest node.').optional()
});

export const eql_delete_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const eql_delete_response = types_acknowledged_response_base;

export const eql_get_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        keep_alive: types_duration.optional(),
        wait_for_completion_timeout: types_duration.optional()
    }).optional()
});

export const eql_get_response = eql_types_eql_search_response_base;

export const eql_get_status_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const eql_get_status_response = z.object({
    id: types_id,
    is_partial: z.boolean().describe('If true, the search request is still executing. If false, the search is completed.'),
    is_running: z.boolean().describe('If true, the response does not contain complete search results. This could be because either the search is still running (is_running status is false), or because it is already completed (is_running status is true) and results are partial due to failures or timeouts.'),
    start_time_in_millis: types_epoch_time_unit_millis.optional(),
    expiration_time_in_millis: types_epoch_time_unit_millis.optional(),
    completion_status: z.number().describe('For a completed search shows the http status code of the completed search.').optional()
});

export const esql_async_query_delete_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const esql_async_query_delete_response = types_acknowledged_response_base;

export const esql_async_query_get_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        drop_null_columns: z.boolean().describe('Indicates whether columns that are entirely `null` will be removed from the `columns` and `values` portion of the results.\nIf `true`, the response will include an extra section under the name `all_columns` which has the name of all the columns.').optional(),
        format: esql_types_esql_format.optional(),
        keep_alive: types_duration.optional(),
        wait_for_completion_timeout: types_duration.optional()
    }).optional()
});

export const esql_async_query_get_response = esql_types_async_esql_result;

export const esql_async_query_stop_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        drop_null_columns: z.boolean().describe('Indicates whether columns that are entirely `null` will be removed from the `columns` and `values` portion of the results.\nIf `true`, the response will include an extra section under the name `all_columns` which has the name of all the columns.').optional()
    }).optional()
});

export const esql_async_query_stop_response = esql_types_esql_result;

export const esql_get_query_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const esql_get_query_response = z.object({
    id: z.number(),
    node: types_node_id,
    start_time_millis: z.number(),
    running_time_nanos: z.number(),
    query: z.string(),
    coordinating_node: types_node_id,
    data_nodes: z.array(types_node_id)
});

export const esql_list_queries_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const esql_list_queries_response = z.object({
    queries: z.record(esql_list_queries_body)
});

export const get_source_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        preference: z.string().describe('The node or shard the operation should be performed on.\nBy default, the operation is randomized between the shard replicas.').optional(),
        realtime: z.boolean().describe('If `true`, the request is real-time as opposed to near-real-time.').optional(),
        refresh: z.boolean().describe('If `true`, the request refreshes the relevant shards before retrieving the document.\nSetting it to `true` should be done after careful thought and verification that this does not cause a heavy load on the system (and slow down indexing).').optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const get_source_response = z.record(z.unknown());

export const exists_source_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        preference: z.string().describe('The node or shard the operation should be performed on.\nBy default, the operation is randomized between the shard replicas.').optional(),
        realtime: z.boolean().describe('If `true`, the request is real-time as opposed to near-real-time.').optional(),
        refresh: z.boolean().describe('If `true`, the request refreshes the relevant shards before retrieving the document.\nSetting it to `true` should be done after careful thought and verification that this does not cause a heavy load on the system (and slow down indexing).').optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const features_get_features_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const features_get_features_response = z.object({
    features: z.array(features_types_feature)
});

export const features_reset_features_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const features_reset_features_response = z.object({
    features: z.array(features_types_feature)
});

export const fleet_global_checkpoints_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: z.union([
            types_index_name,
            types_index_alias
        ])
    }),
    query: z.object({
        wait_for_advance: z.boolean().describe('A boolean value which controls whether to wait (until the timeout) for the global checkpoints\nto advance past the provided `checkpoints`.').optional(),
        wait_for_index: z.boolean().describe('A boolean value which controls whether to wait (until the timeout) for the target index to exist\nand all primary shards be active. Can only be true when `wait_for_advance` is true.').optional(),
        checkpoints: z.array(fleet_types_checkpoint).describe('A comma separated list of previous global checkpoints. When used in combination with `wait_for_advance`,\nthe API will only return once the global checkpoints advances past the checkpoints. Providing an empty list\nwill cause Elasticsearch to immediately return the current global checkpoints.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const fleet_global_checkpoints_response = z.object({
    global_checkpoints: z.array(fleet_types_checkpoint),
    timed_out: z.boolean()
});

export const get_script_context_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const get_script_context_response = z.object({
    contexts: z.array(global_get_script_context_context)
});

export const get_script_languages_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const get_script_languages_response = z.object({
    language_contexts: z.array(global_get_script_languages_language_context),
    types_allowed: z.array(z.string())
});

export const health_report_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        timeout: types_duration.optional(),
        verbose: z.boolean().describe('Opt-in for more information about the health of the system.').optional(),
        size: z.number().describe('Limit the number of affected resources the health report API returns.').optional()
    }).optional()
});

export const health_report_response = z.object({
    cluster_name: z.string(),
    indicators: global_health_report_indicators,
    status: global_health_report_indicator_health_status.optional()
});

export const health_report1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        feature: z.union([
            z.string(),
            z.array(z.string())
        ])
    }),
    query: z.object({
        timeout: types_duration.optional(),
        verbose: z.boolean().describe('Opt-in for more information about the health of the system.').optional(),
        size: z.number().describe('Limit the number of affected resources the health report API returns.').optional()
    }).optional()
});

export const health_report1_response = z.object({
    cluster_name: z.string(),
    indicators: global_health_report_indicators,
    status: global_health_report_indicator_health_status.optional()
});

export const ilm_delete_lifecycle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        policy: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ilm_delete_lifecycle_response = types_acknowledged_response_base;

export const ilm_get_lifecycle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        policy: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ilm_get_lifecycle_response = z.record(ilm_get_lifecycle_lifecycle);

export const ilm_put_lifecycle_request = z.object({
    body: z.object({
        policy: ilm_types_policy.optional()
    }),
    path: z.object({
        policy: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ilm_put_lifecycle_response = types_acknowledged_response_base;

export const ilm_explain_lifecycle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        only_errors: z.boolean().describe('Filters the returned indices to only indices that are managed by ILM and are in an error state, either due to an encountering an error while executing the policy, or attempting to use a policy that does not exist.').optional(),
        only_managed: z.boolean().describe('Filters the returned indices to only indices that are managed by ILM.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const ilm_explain_lifecycle_response = z.object({
    indices: z.record(ilm_explain_lifecycle_lifecycle_explain)
});

export const ilm_get_lifecycle1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ilm_get_lifecycle1_response = z.record(ilm_get_lifecycle_lifecycle);

export const ilm_get_status_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ilm_get_status_response = z.object({
    operation_mode: types_lifecycle_operation_mode
});

export const ilm_migrate_to_data_tiers_request = z.object({
    body: z.object({
        legacy_template_to_delete: z.string().optional(),
        node_attribute: z.string().optional()
    }).optional(),
    path: z.never().optional(),
    query: z.object({
        dry_run: z.boolean().describe('If true, simulates the migration from node attributes based allocation filters to data tiers, but does not perform the migration.\nThis provides a way to retrieve the indices and ILM policies that need to be migrated.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const ilm_migrate_to_data_tiers_response = z.object({
    dry_run: z.boolean(),
    removed_legacy_template: z.string().describe('The name of the legacy index template that was deleted.\nThis information is missing if no legacy index templates were deleted.'),
    migrated_ilm_policies: z.array(z.string()).describe('The ILM policies that were updated.'),
    migrated_indices: types_indices,
    migrated_legacy_templates: z.array(z.string()).describe('The legacy index templates that were updated to not contain custom routing settings for the provided data attribute.'),
    migrated_composable_templates: z.array(z.string()).describe('The composable index templates that were updated to not contain custom routing settings for the provided data attribute.'),
    migrated_component_templates: z.array(z.string()).describe('The component templates that were updated to not contain custom routing settings for the provided data attribute.')
});

export const ilm_move_to_step_request = z.object({
    body: z.object({
        current_step: ilm_move_to_step_step_key,
        next_step: ilm_move_to_step_step_key
    }),
    path: z.object({
        index: types_index_name
    }),
    query: z.never().optional()
});

export const ilm_move_to_step_response = types_acknowledged_response_base;

export const ilm_remove_policy_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.never().optional()
});

export const ilm_remove_policy_response = z.object({
    failed_indexes: z.array(types_index_name),
    has_failures: z.boolean()
});

export const ilm_retry_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.never().optional()
});

export const ilm_retry_response = types_acknowledged_response_base;

export const ilm_start_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ilm_start_response = types_acknowledged_response_base;

export const ilm_stop_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ilm_stop_response = types_acknowledged_response_base;

export const index2_request = z.object({
    body: index,
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        if_primary_term: z.number().describe('Only perform the operation if the document has this primary term.').optional(),
        if_seq_no: types_sequence_number.optional(),
        include_source_on_error: z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.').optional(),
        op_type: types_op_type.optional(),
        pipeline: z.string().describe('The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.').optional(),
        refresh: types_refresh.optional(),
        routing: types_routing.optional(),
        timeout: types_duration.optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        require_alias: z.boolean().describe('If `true`, the destination must be an index alias.').optional(),
        require_data_stream: z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).').optional()
    }).optional()
});

export const index2_response = types_write_response_base;

export const indices_remove_block_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices,
        block: indices_types_indices_block_options
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_remove_block_response = z.object({
    acknowledged: z.boolean(),
    indices: z.array(indices_remove_block_remove_indices_block_status)
});

export const indices_add_block_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices,
        block: indices_types_indices_block_options
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_add_block_response = z.object({
    acknowledged: z.boolean(),
    shards_acknowledged: z.boolean(),
    indices: z.array(indices_add_block_add_indices_block_status)
});

export const indices_cancel_migrate_reindex_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.never().optional()
});

export const indices_cancel_migrate_reindex_response = types_acknowledged_response_base;

export const indices_clear_cache_request2 = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        index: types_indices.optional(),
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        fielddata: z.boolean().describe('If `true`, clears the fields cache.\nUse the `fields` parameter to clear the cache of specific fields only.').optional(),
        fields: types_fields.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        query: z.boolean().describe('If `true`, clears the query cache.').optional(),
        request: z.boolean().describe('If `true`, clears the request cache.').optional()
    }).optional()
});

export const indices_clear_cache_response = types_shards_operation_response_base;

export const indices_clear_cache1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        index: types_indices.optional(),
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        fielddata: z.boolean().describe('If `true`, clears the fields cache.\nUse the `fields` parameter to clear the cache of specific fields only.').optional(),
        fields: types_fields.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        query: z.boolean().describe('If `true`, clears the query cache.').optional(),
        request: z.boolean().describe('If `true`, clears the request cache.').optional()
    }).optional()
});

export const indices_clear_cache1_response = types_shards_operation_response_base;

export const indices_close_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const indices_close_response = z.object({
    acknowledged: z.boolean(),
    indices: z.record(indices_close_close_index_result),
    shards_acknowledged: z.boolean()
});

export const indices_delete_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_delete_response = types_indices_response_base;

export const indices_exists_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_defaults: z.boolean().describe('If `true`, return all default settings in the response.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.').optional()
    }).optional()
});

export const indices_delete_data_stream_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_data_stream_names
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        expand_wildcards: types_expand_wildcards.optional()
    }).optional()
});

export const indices_delete_data_stream_response = types_acknowledged_response_base;

export const indices_create_data_stream_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_data_stream_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_create_data_stream_response = types_acknowledged_response_base;

export const indices_data_streams_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional()
    }).optional()
});

export const indices_data_streams_stats_response = z.object({
    _shards: types_shard_statistics,
    backing_indices: z.number().describe('Total number of backing indices for the selected data streams.'),
    data_stream_count: z.number().describe('Total number of selected data streams.'),
    data_streams: z.array(indices_data_streams_stats_data_streams_stats_item).describe('Contains statistics for the selected data streams.'),
    total_store_sizes: types_byte_size.optional(),
    total_store_size_bytes: z.number().describe('Total size, in bytes, of all shards for the selected data streams.')
});

export const indices_data_streams_stats1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_indices
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional()
    }).optional()
});

export const indices_data_streams_stats1_response = z.object({
    _shards: types_shard_statistics,
    backing_indices: z.number().describe('Total number of backing indices for the selected data streams.'),
    data_stream_count: z.number().describe('Total number of selected data streams.'),
    data_streams: z.array(indices_data_streams_stats_data_streams_stats_item).describe('Contains statistics for the selected data streams.'),
    total_store_sizes: types_byte_size.optional(),
    total_store_size_bytes: z.number().describe('Total size, in bytes, of all shards for the selected data streams.')
});

export const indices_delete_alias_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices,
        name: types_names
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_delete_alias_response = indices_delete_alias_indices_aliases_response_body;

export const indices_exists_alias1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices,
        name: types_names
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, requests that include a missing data stream or index in the target indices or data streams return an error.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_delete_alias1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices,
        name: types_names
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_delete_alias1_response = indices_delete_alias_indices_aliases_response_body;

export const indices_delete_data_lifecycle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_data_stream_names
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_delete_data_lifecycle_response = types_acknowledged_response_base;

export const indices_get_data_lifecycle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_data_stream_names
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        include_defaults: z.boolean().describe('If `true`, return all default settings in the response.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_data_lifecycle_response = z.object({
    data_streams: z.array(indices_get_data_lifecycle_data_stream_with_lifecycle)
});

export const indices_put_data_lifecycle_request = z.object({
    body: z.object({
        data_retention: types_duration.optional(),
        downsampling: z.array(indices_types_downsampling_round).describe('The downsampling configuration to execute for the managed backing index after rollover.').optional(),
        enabled: z.boolean().describe('If defined, it turns data stream lifecycle on/off (`true`/`false`) for this data stream. A data stream lifecycle\nthat\'s disabled (enabled: `false`) will have no effect on the data stream.').optional().default(true)
    }),
    path: z.object({
        name: types_data_stream_names
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_put_data_lifecycle_response = types_acknowledged_response_base;

export const indices_delete_data_stream_options_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_data_stream_names
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_delete_data_stream_options_response = types_acknowledged_response_base;

export const indices_get_data_stream_options_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_data_stream_names
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_data_stream_options_response = z.object({
    data_streams: z.array(indices_get_data_stream_options_data_stream_with_options)
});

export const indices_put_data_stream_options_request = z.object({
    body: z.object({
        failure_store: indices_types_data_stream_failure_store.optional()
    }),
    path: z.object({
        name: types_data_stream_names
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_put_data_stream_options_response = types_acknowledged_response_base;

export const indices_delete_index_template_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_delete_index_template_response = types_acknowledged_response_base;

export const indices_exists_index_template_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        local: z.boolean().describe('If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.').optional(),
        flat_settings: z.boolean().describe('If true, returns settings in flat format.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_delete_template_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_delete_template_response = types_acknowledged_response_base;

export const indices_exists_template_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        flat_settings: z.boolean().describe('Indicates whether to use a flat format for the response.').optional(),
        local: z.boolean().describe('Indicates whether to get information from the local node only.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_disk_usage_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flush: z.boolean().describe('If `true`, the API performs a flush before analysis.\nIf `false`, the response may not include uncommitted data.').optional(),
        ignore_unavailable: z.boolean().describe('If `true`, missing or closed indices are not included in the response.').optional(),
        run_expensive_tasks: z.boolean().describe('Analyzing field disk usage is resource-intensive.\nTo use the API, this parameter must be set to `true`.').optional()
    }).optional()
});

export const indices_disk_usage_response = z.record(z.unknown());

export const indices_downsample_request = z.object({
    body: indices_types_downsample_config,
    path: z.object({
        index: types_index_name,
        target_index: types_index_name
    }),
    query: z.never().optional()
});

export const indices_downsample_response = z.record(z.unknown());

export const indices_exists_alias_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, requests that include a missing data stream or index in the target indices or data streams return an error.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_explain_data_lifecycle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        include_defaults: z.boolean().describe('indicates if the API should return the default values the system uses for the index\'s lifecycle').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_explain_data_lifecycle_response = z.object({
    indices: z.record(indices_explain_data_lifecycle_data_stream_lifecycle_explain)
});

export const indices_field_usage_stats_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `true`, missing or closed indices are not included in the response.').optional(),
        fields: types_fields.optional()
    }).optional()
});

export const indices_field_usage_stats_response = indices_field_usage_stats_fields_usage_body;

export const indices_flush1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        force: z.boolean().describe('If `true`, the request forces a flush even if there are no changes to commit to the index.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        wait_if_ongoing: z.boolean().describe('If `true`, the flush operation blocks until execution when another flush operation is running.\nIf `false`, Elasticsearch returns an error if you request a flush when another flush operation is running.').optional()
    }).optional()
});

export const indices_flush1_response = types_shards_operation_response_base;

export const indices_flush_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        force: z.boolean().describe('If `true`, the request forces a flush even if there are no changes to commit to the index.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        wait_if_ongoing: z.boolean().describe('If `true`, the flush operation blocks until execution when another flush operation is running.\nIf `false`, Elasticsearch returns an error if you request a flush when another flush operation is running.').optional()
    }).optional()
});

export const indices_flush_response = types_shards_operation_response_base;

export const indices_flush3_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        force: z.boolean().describe('If `true`, the request forces a flush even if there are no changes to commit to the index.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        wait_if_ongoing: z.boolean().describe('If `true`, the flush operation blocks until execution when another flush operation is running.\nIf `false`, Elasticsearch returns an error if you request a flush when another flush operation is running.').optional()
    }).optional()
});

export const indices_flush3_response = types_shards_operation_response_base;

export const indices_flush2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        force: z.boolean().describe('If `true`, the request forces a flush even if there are no changes to commit to the index.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        wait_if_ongoing: z.boolean().describe('If `true`, the flush operation blocks until execution when another flush operation is running.\nIf `false`, Elasticsearch returns an error if you request a flush when another flush operation is running.').optional()
    }).optional()
});

export const indices_flush2_response = types_shards_operation_response_base;

export const indices_forcemerge_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flush: z.boolean().describe('Specify whether the index should be flushed after performing the operation (default: true)').optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional(),
        max_num_segments: z.number().describe('The number of segments the index should be merged into (default: dynamic)').optional(),
        only_expunge_deletes: z.boolean().describe('Specify whether the operation should only expunge deleted documents').optional(),
        wait_for_completion: z.boolean().describe('Should the request wait until the force merge is completed.').optional()
    }).optional()
});

export const indices_forcemerge_response = indices_forcemerge_types_force_merge_response_body;

export const indices_forcemerge1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flush: z.boolean().describe('Specify whether the index should be flushed after performing the operation (default: true)').optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional(),
        max_num_segments: z.number().describe('The number of segments the index should be merged into (default: dynamic)').optional(),
        only_expunge_deletes: z.boolean().describe('Specify whether the operation should only expunge deleted documents').optional(),
        wait_for_completion: z.boolean().describe('Should the request wait until the force merge is completed.').optional()
    }).optional()
});

export const indices_forcemerge1_response = indices_forcemerge_types_force_merge_response_body;

export const indices_get_data_lifecycle_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const indices_get_data_lifecycle_stats_response = z.object({
    data_stream_count: z.number().describe('The count of data streams currently being managed by the data stream lifecycle.'),
    data_streams: z.array(indices_get_data_lifecycle_stats_data_stream_stats).describe('Information about the data streams that are managed by the data stream lifecycle.'),
    last_run_duration_in_millis: types_duration_value_unit_millis.optional(),
    time_between_starts_in_millis: types_duration_value_unit_millis.optional()
});

export const indices_get_migrate_reindex_status_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.never().optional()
});

export const indices_get_migrate_reindex_status_response = z.object({
    start_time: types_date_time.optional(),
    start_time_millis: types_epoch_time_unit_millis,
    complete: z.boolean(),
    total_indices_in_data_stream: z.number(),
    total_indices_requiring_upgrade: z.number(),
    successes: z.number(),
    in_progress: z.array(indices_get_migrate_reindex_status_status_in_progress),
    pending: z.number(),
    errors: z.array(indices_get_migrate_reindex_status_status_error),
    exception: z.string().optional()
});

export const indices_migrate_reindex_request = z.object({
    body: indices_migrate_reindex_migrate_reindex,
    path: z.never().optional(),
    query: z.never().optional()
});

export const indices_migrate_reindex_response = types_acknowledged_response_base;

export const indices_migrate_to_data_stream_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_migrate_to_data_stream_response = types_acknowledged_response_base;

export const indices_modify_data_stream_request = z.object({
    body: z.object({
        actions: z.array(indices_modify_data_stream_action).describe('Actions to perform.')
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const indices_modify_data_stream_response = types_acknowledged_response_base;

export const indices_open_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const indices_open_response = z.object({
    acknowledged: z.boolean(),
    shards_acknowledged: z.boolean()
});

export const indices_promote_data_stream_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_promote_data_stream_response = z.record(z.unknown());

export const indices_recovery_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        active_only: z.boolean().describe('If `true`, the response only includes ongoing shard recoveries.').optional(),
        detailed: z.boolean().describe('If `true`, the response includes detailed information about shard recoveries.').optional(),
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional()
    }).optional()
});

export const indices_recovery_response = z.record(indices_recovery_recovery_status);

export const indices_recovery1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        active_only: z.boolean().describe('If `true`, the response only includes ongoing shard recoveries.').optional(),
        detailed: z.boolean().describe('If `true`, the response includes detailed information about shard recoveries.').optional(),
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional()
    }).optional()
});

export const indices_recovery1_response = z.record(indices_recovery_recovery_status);

export const indices_refresh1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional()
    }).optional()
});

export const indices_refresh1_response = types_shards_operation_response_base;

export const indices_refresh_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional()
    }).optional()
});

export const indices_refresh_response = types_shards_operation_response_base;

export const indices_refresh3_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional()
    }).optional()
});

export const indices_refresh3_response = types_shards_operation_response_base;

export const indices_refresh2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional()
    }).optional()
});

export const indices_refresh2_response = types_shards_operation_response_base;

export const indices_reload_search_analyzers_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional(),
        resource: z.string().describe('Changed resource to reload analyzers from if applicable').optional()
    }).optional()
});

export const indices_reload_search_analyzers_response = indices_reload_search_analyzers_reload_result;

export const indices_reload_search_analyzers1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional(),
        resource: z.string().describe('Changed resource to reload analyzers from if applicable').optional()
    }).optional()
});

export const indices_reload_search_analyzers1_response = indices_reload_search_analyzers_reload_result;

export const indices_resolve_cluster_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing\nor closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.\nNOTE: This option is only supported when specifying an index expression. You will get an error if you specify index\noptions to the `_resolve/cluster` API endpoint that takes no index expression.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded, or aliased indices are ignored when frozen.\nNOTE: This option is only supported when specifying an index expression. You will get an error if you specify index\noptions to the `_resolve/cluster` API endpoint that takes no index expression.').optional(),
        ignore_unavailable: z.boolean().describe('If false, the request returns an error if it targets a missing or closed index.\nNOTE: This option is only supported when specifying an index expression. You will get an error if you specify index\noptions to the `_resolve/cluster` API endpoint that takes no index expression.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_resolve_cluster_response = z.record(indices_resolve_cluster_resolve_cluster_info);

export const indices_resolve_cluster1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing\nor closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.\nNOTE: This option is only supported when specifying an index expression. You will get an error if you specify index\noptions to the `_resolve/cluster` API endpoint that takes no index expression.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded, or aliased indices are ignored when frozen.\nNOTE: This option is only supported when specifying an index expression. You will get an error if you specify index\noptions to the `_resolve/cluster` API endpoint that takes no index expression.').optional(),
        ignore_unavailable: z.boolean().describe('If false, the request returns an error if it targets a missing or closed index.\nNOTE: This option is only supported when specifying an index expression. You will get an error if you specify index\noptions to the `_resolve/cluster` API endpoint that takes no index expression.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_resolve_cluster1_response = z.record(indices_resolve_cluster_resolve_cluster_info);

export const indices_resolve_index_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        mode: z.union([
            indices_types_index_mode,
            z.array(indices_types_index_mode)
        ]).optional()
    }).optional()
});

export const indices_resolve_index_response = z.object({
    indices: z.array(indices_resolve_index_resolve_index_item),
    aliases: z.array(indices_resolve_index_resolve_index_alias_item),
    data_streams: z.array(indices_resolve_index_resolve_index_data_streams_item)
});

export const indices_segments_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional()
    }).optional()
});

export const indices_segments_response = z.object({
    indices: z.record(indices_segments_index_segment),
    _shards: types_shard_statistics
});

export const indices_segments1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional()
    }).optional()
});

export const indices_segments1_response = z.object({
    indices: z.record(indices_segments_index_segment),
    _shards: types_shard_statistics
});

export const indices_shard_stores_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all\nvalue targets only missing or closed indices. This behavior applies even if the request\ntargets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        status: z.union([
            indices_shard_stores_shard_store_status,
            z.array(indices_shard_stores_shard_store_status)
        ]).optional()
    }).optional()
});

export const indices_shard_stores_response = z.object({
    indices: z.record(indices_shard_stores_indices_shard_stores)
});

export const indices_shard_stores1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all\nvalue targets only missing or closed indices. This behavior applies even if the request\ntargets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        status: z.union([
            indices_shard_stores_shard_store_status,
            z.array(indices_shard_stores_shard_store_status)
        ]).optional()
    }).optional()
});

export const indices_shard_stores1_response = z.object({
    indices: z.record(indices_shard_stores_indices_shard_stores)
});

export const inference_chat_completion_unified_request = z.object({
    body: inference_types_request_chat_completion,
    path: z.object({
        inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_chat_completion_unified_response = types_stream_result;

export const inference_completion_request = z.object({
    body: z.object({
        input: z.union([
            z.string(),
            z.array(z.string())
        ]),
        task_settings: inference_types_task_settings.optional()
    }),
    path: z.object({
        inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_completion_response = inference_types_completion_inference_result;

export const inference_delete_request = z.object({
    body: z.never().optional(),
    path: z.object({
        inference_id: types_id
    }),
    query: z.object({
        dry_run: z.boolean().describe('When true, checks the semantic_text fields and inference processors that reference the endpoint and returns them in a list, but does not delete the endpoint.').optional(),
        force: z.boolean().describe('When true, the inference endpoint is forcefully deleted even if it is still being used by ingest processors or semantic text fields.').optional()
    }).optional()
});

export const inference_delete_response = inference_types_delete_inference_endpoint_result;

export const inference_get1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        inference_id: types_id
    }),
    query: z.never().optional()
});

export const inference_get1_response = z.object({
    endpoints: z.array(inference_types_inference_endpoint_info)
});

export const inference_inference_request = z.object({
    body: inference_inference,
    path: z.object({
        inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_inference_response = inference_types_inference_result;

export const inference_put_request = z.object({
    body: inference_put,
    path: z.object({
        inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_response = inference_types_inference_endpoint_info;

export const inference_delete1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        task_type: inference_types_task_type,
        inference_id: types_id
    }),
    query: z.object({
        dry_run: z.boolean().describe('When true, checks the semantic_text fields and inference processors that reference the endpoint and returns them in a list, but does not delete the endpoint.').optional(),
        force: z.boolean().describe('When true, the inference endpoint is forcefully deleted even if it is still being used by ingest processors or semantic text fields.').optional()
    }).optional()
});

export const inference_delete1_response = inference_types_delete_inference_endpoint_result;

export const inference_get2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        task_type: inference_types_task_type,
        inference_id: types_id
    }),
    query: z.never().optional()
});

export const inference_get2_response = z.object({
    endpoints: z.array(inference_types_inference_endpoint_info)
});

export const inference_inference1_request = z.object({
    body: inference_inference,
    path: z.object({
        task_type: inference_types_task_type,
        inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_inference1_response = inference_types_inference_result;

export const inference_put1_request = z.object({
    body: inference_put,
    path: z.object({
        task_type: inference_types_task_type,
        inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put1_response = inference_types_inference_endpoint_info;

export const inference_get_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const inference_get_response = z.object({
    endpoints: z.array(inference_types_inference_endpoint_info)
});

export const inference_put_ai21_request = z.object({
    body: z.object({
        service: inference_types_ai21_service_type,
        service_settings: inference_types_ai21_service_settings
    }),
    path: z.object({
        task_type: inference_types_ai21_task_type,
        ai21_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_ai21_response = inference_types_inference_endpoint_info_ai21;

export const inference_put_alibabacloud_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_alibaba_cloud_service_type,
        service_settings: inference_types_alibaba_cloud_service_settings,
        task_settings: inference_types_alibaba_cloud_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_alibaba_cloud_task_type,
        alibabacloud_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_alibabacloud_response = inference_types_inference_endpoint_info_alibaba_cloud_ai;

export const inference_put_amazonbedrock_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_amazon_bedrock_service_type,
        service_settings: inference_types_amazon_bedrock_service_settings,
        task_settings: inference_types_amazon_bedrock_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_amazon_bedrock_task_type,
        amazonbedrock_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_amazonbedrock_response = inference_types_inference_endpoint_info_amazon_bedrock;

export const inference_put_amazonsagemaker_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_amazon_sage_maker_service_type,
        service_settings: inference_types_amazon_sage_maker_service_settings,
        task_settings: inference_types_amazon_sage_maker_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_task_type_amazon_sage_maker,
        amazonsagemaker_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_amazonsagemaker_response = inference_types_inference_endpoint_info_amazon_sage_maker;

export const inference_put_anthropic_request = z.object({
    body: z.object({
        service: inference_types_anthropic_service_type,
        service_settings: inference_types_anthropic_service_settings,
        task_settings: inference_types_anthropic_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_anthropic_task_type,
        anthropic_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_anthropic_response = inference_types_inference_endpoint_info_anthropic;

export const inference_put_azureaistudio_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_azure_ai_studio_service_type,
        service_settings: inference_types_azure_ai_studio_service_settings,
        task_settings: inference_types_azure_ai_studio_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_azure_ai_studio_task_type,
        azureaistudio_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_azureaistudio_response = inference_types_inference_endpoint_info_azure_ai_studio;

export const inference_put_azureopenai_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_azure_open_ai_service_type,
        service_settings: inference_types_azure_open_ai_service_settings,
        task_settings: inference_types_azure_open_ai_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_azure_open_ai_task_type,
        azureopenai_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_azureopenai_response = inference_types_inference_endpoint_info_azure_open_ai;

export const inference_put_cohere_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_cohere_service_type,
        service_settings: inference_types_cohere_service_settings,
        task_settings: inference_types_cohere_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_cohere_task_type,
        cohere_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_cohere_response = inference_types_inference_endpoint_info_cohere;

export const inference_put_contextualai_request = z.object({
    body: z.object({
        service: inference_types_contextual_ai_service_type,
        service_settings: inference_types_contextual_ai_service_settings,
        task_settings: inference_types_contextual_ai_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_task_type_contextual_ai,
        contextualai_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_contextualai_response = inference_types_inference_endpoint_info_contextual_ai;

export const inference_put_custom_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_custom_service_type,
        service_settings: inference_types_custom_service_settings,
        task_settings: inference_types_custom_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_custom_task_type,
        custom_inference_id: types_id
    }),
    query: z.never().optional()
});

export const inference_put_custom_response = inference_types_inference_endpoint_info_custom;

export const inference_put_deepseek_request = z.object({
    body: z.object({
        service: inference_types_deep_seek_service_type,
        service_settings: inference_types_deep_seek_service_settings
    }),
    path: z.object({
        task_type: inference_types_task_type_deep_seek,
        deepseek_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_deepseek_response = inference_types_inference_endpoint_info_deep_seek;

export const inference_put_elasticsearch_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_elasticsearch_service_type,
        service_settings: inference_types_elasticsearch_service_settings,
        task_settings: inference_types_elasticsearch_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_elasticsearch_task_type,
        elasticsearch_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_elasticsearch_response = inference_types_inference_endpoint_info_elasticsearch;

export const inference_put_elser_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_elser_service_type,
        service_settings: inference_types_elser_service_settings
    }),
    path: z.object({
        task_type: inference_types_elser_task_type,
        elser_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_elser_response = inference_types_inference_endpoint_info_elser;

export const inference_put_googleaistudio_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_google_ai_service_type,
        service_settings: inference_types_google_ai_studio_service_settings
    }),
    path: z.object({
        task_type: inference_types_google_ai_studio_task_type,
        googleaistudio_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_googleaistudio_response = inference_types_inference_endpoint_info_google_ai_studio;

export const inference_put_googlevertexai_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_google_vertex_ai_service_type,
        service_settings: inference_types_google_vertex_ai_service_settings,
        task_settings: inference_types_google_vertex_ai_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_google_vertex_ai_task_type,
        googlevertexai_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_googlevertexai_response = inference_types_inference_endpoint_info_google_vertex_ai;

export const inference_put_hugging_face_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_hugging_face_service_type,
        service_settings: inference_types_hugging_face_service_settings,
        task_settings: inference_types_hugging_face_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_hugging_face_task_type,
        huggingface_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_hugging_face_response = inference_types_inference_endpoint_info_hugging_face;

export const inference_put_jinaai_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_jina_ai_service_type,
        service_settings: inference_types_jina_ai_service_settings,
        task_settings: inference_types_jina_ai_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_jina_ai_task_type,
        jinaai_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_jinaai_response = inference_types_inference_endpoint_info_jina_ai;

export const inference_put_llama_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_llama_service_type,
        service_settings: inference_types_llama_service_settings
    }),
    path: z.object({
        task_type: inference_types_llama_task_type,
        llama_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_llama_response = inference_types_inference_endpoint_info_llama;

export const inference_put_mistral_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_mistral_service_type,
        service_settings: inference_types_mistral_service_settings
    }),
    path: z.object({
        task_type: inference_types_mistral_task_type,
        mistral_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_mistral_response = inference_types_inference_endpoint_info_mistral;

export const inference_put_openai_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_open_ai_service_type,
        service_settings: inference_types_open_ai_service_settings,
        task_settings: inference_types_open_ai_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_open_ai_task_type,
        openai_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_openai_response = inference_types_inference_endpoint_info_open_ai;

export const inference_put_voyageai_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_voyage_ai_service_type,
        service_settings: inference_types_voyage_ai_service_settings,
        task_settings: inference_types_voyage_ai_task_settings.optional()
    }),
    path: z.object({
        task_type: inference_types_voyage_ai_task_type,
        voyageai_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_voyageai_response = inference_types_inference_endpoint_info_voyage_ai;

export const inference_put_watsonx_request = z.object({
    body: z.object({
        chunking_settings: inference_types_inference_chunking_settings.optional(),
        service: inference_types_watsonx_service_type,
        service_settings: inference_types_watsonx_service_settings
    }),
    path: z.object({
        task_type: inference_types_watsonx_task_type,
        watsonx_inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_put_watsonx_response = inference_types_inference_endpoint_info_watsonx;

export const inference_rerank_request = z.object({
    body: z.object({
        query: z.string().describe('Query input.'),
        input: z.array(z.string()).describe('The documents to rank.'),
        return_documents: z.boolean().describe('Include the document text in the response.').optional(),
        top_n: z.number().describe('Limit the response to the top N documents.').optional(),
        task_settings: inference_types_task_settings.optional()
    }),
    path: z.object({
        inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_rerank_response = inference_types_reranked_inference_result;

export const inference_sparse_embedding_request = z.object({
    body: z.object({
        input: z.union([
            z.string(),
            z.array(z.string())
        ]),
        task_settings: inference_types_task_settings.optional()
    }),
    path: z.object({
        inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_sparse_embedding_response = inference_types_sparse_embedding_inference_result;

export const inference_stream_completion_request = z.object({
    body: z.object({
        input: z.union([
            z.string(),
            z.array(z.string())
        ]),
        task_settings: inference_types_task_settings.optional()
    }),
    path: z.object({
        inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_stream_completion_response = types_stream_result;

export const inference_text_embedding_request = z.object({
    body: z.object({
        input: z.union([
            z.string(),
            z.array(z.string())
        ]),
        input_type: z.string().describe('The input data type for the text embedding model. Possible values include:\n* `SEARCH`\n* `INGEST`\n* `CLASSIFICATION`\n* `CLUSTERING`\nNot all services support all values. Unsupported values will trigger a validation exception.\nAccepted values depend on the configured inference service, refer to the relevant service-specific documentation for more info.\n\n> info\n> The `input_type` parameter specified on the root level of the request body will take precedence over the `input_type` parameter specified in `task_settings`.').optional(),
        task_settings: inference_types_task_settings.optional()
    }),
    path: z.object({
        inference_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const inference_text_embedding_response = inference_types_text_embedding_inference_result;

export const inference_update_request = z.object({
    body: inference_update,
    path: z.object({
        inference_id: types_id
    }),
    query: z.never().optional()
});

export const inference_update_response = inference_types_inference_endpoint_info;

export const inference_update1_request = z.object({
    body: inference_update,
    path: z.object({
        task_type: inference_types_task_type,
        inference_id: types_id
    }),
    query: z.never().optional()
});

export const inference_update1_response = inference_types_inference_endpoint_info;

export const info_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const info_response = z.object({
    cluster_name: types_name,
    cluster_uuid: types_uuid,
    name: types_name,
    tagline: z.string(),
    version: types_elasticsearch_version_info
});

export const ping_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ingest_delete_geoip_database_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_ids
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ingest_delete_geoip_database_response = types_acknowledged_response_base;

export const ingest_get_geoip_database1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_ids
    }),
    query: z.never().optional()
});

export const ingest_get_geoip_database1_response = z.object({
    databases: z.array(ingest_get_geoip_database_database_configuration_metadata)
});

export const ingest_put_geoip_database_request = z.object({
    body: z.object({
        name: types_name,
        maxmind: ingest_types_maxmind
    }),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ingest_put_geoip_database_response = types_acknowledged_response_base;

export const ingest_delete_ip_location_database_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_ids
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ingest_delete_ip_location_database_response = types_acknowledged_response_base;

export const ingest_get_ip_location_database1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_ids
    }),
    query: z.never().optional()
});

export const ingest_get_ip_location_database1_response = z.object({
    databases: z.array(ingest_get_ip_location_database_database_configuration_metadata)
});

export const ingest_put_ip_location_database_request = z.object({
    body: ingest_types_database_configuration,
    path: z.object({
        id: types_id
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ingest_put_ip_location_database_response = types_acknowledged_response_base;

export const ingest_delete_pipeline_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ingest_delete_pipeline_response = types_acknowledged_response_base;

export const ingest_geo_ip_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ingest_geo_ip_stats_response = z.object({
    stats: ingest_geo_ip_stats_geo_ip_download_statistics,
    nodes: z.record(ingest_geo_ip_stats_geo_ip_node_databases).describe('Downloaded GeoIP2 databases for each node.')
});

export const ingest_get_geoip_database_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ingest_get_geoip_database_response = z.object({
    databases: z.array(ingest_get_geoip_database_database_configuration_metadata)
});

export const ingest_get_ip_location_database_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ingest_get_ip_location_database_response = z.object({
    databases: z.array(ingest_get_ip_location_database_database_configuration_metadata)
});

export const ingest_processor_grok_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ingest_processor_grok_response = z.object({
    patterns: z.record(z.string())
});

export const license_delete_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const license_delete_response = types_acknowledged_response_base;

export const license_get_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        accept_enterprise: z.boolean().describe('If `true`, this parameter returns enterprise for Enterprise license types. If `false`, this parameter returns platinum for both platinum and enterprise license types. This behavior is maintained for backwards compatibility.\nThis parameter is deprecated and will always be set to true in 8.x.').optional(),
        local: z.boolean().describe('Specifies whether to retrieve local information.\nFrom 9.2 onwards the default value is `true`, which means the information is retrieved from the responding node.\nIn earlier versions the default is `false`, which means the information is retrieved from the elected master node.').optional()
    }).optional()
});

export const license_get_response = z.object({
    license: license_get_license_information
});

export const license_post1_request = z.object({
    body: license_post.optional(),
    path: z.never().optional(),
    query: z.object({
        acknowledge: z.boolean().describe('Specifies whether you acknowledge the license changes.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const license_post1_response = z.object({
    acknowledge: license_post_acknowledgement.optional(),
    acknowledged: z.boolean(),
    license_status: license_types_license_status
});

export const license_post_request = z.object({
    body: license_post.optional(),
    path: z.never().optional(),
    query: z.object({
        acknowledge: z.boolean().describe('Specifies whether you acknowledge the license changes.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const license_post_response = z.object({
    acknowledge: license_post_acknowledgement.optional(),
    acknowledged: z.boolean(),
    license_status: license_types_license_status
});

export const license_get_basic_status_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const license_get_basic_status_response = z.object({
    eligible_to_start_basic: z.boolean()
});

export const license_get_trial_status_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const license_get_trial_status_response = z.object({
    eligible_to_start_trial: z.boolean()
});

export const license_post_start_basic_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        acknowledge: z.boolean().describe('whether the user has acknowledged acknowledge messages (default: false)').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const license_post_start_basic_response = z.object({
    acknowledged: z.boolean(),
    basic_was_started: z.boolean(),
    error_message: z.string().optional(),
    type: license_types_license_type.optional(),
    acknowledge: z.record(z.union([
        z.string(),
        z.array(z.string())
    ])).optional()
});

export const license_post_start_trial_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        acknowledge: z.boolean().describe('whether the user has acknowledged acknowledge messages (default: false)').optional(),
        type: z.string().describe('The type of trial license to generate (default: "trial")').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const license_post_start_trial_response = z.object({
    acknowledged: z.boolean(),
    error_message: z.string().optional(),
    trial_was_started: z.boolean(),
    type: license_types_license_type.optional()
});

export const logstash_delete_pipeline_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const logstash_get_pipeline1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_ids
    }),
    query: z.never().optional()
});

export const logstash_get_pipeline1_response = z.record(logstash_types_pipeline);

export const logstash_put_pipeline_request = z.object({
    body: logstash_types_pipeline,
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const logstash_get_pipeline_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const logstash_get_pipeline_response = z.record(logstash_types_pipeline);

export const mget_request = z.object({
    body: mget,
    path: z.never().optional(),
    query: z.object({
        preference: z.string().describe('Specifies the node or shard the operation should be performed on. Random by default.').optional(),
        realtime: z.boolean().describe('If `true`, the request is real-time as opposed to near-real-time.').optional(),
        refresh: z.boolean().describe('If `true`, the request refreshes relevant shards before retrieving documents.').optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        stored_fields: types_fields.optional()
    }).optional()
});

export const mget_response = z.object({
    docs: z.array(global_mget_response_item).describe('The response includes a docs array that contains the documents in the order specified in the request.\nThe structure of the returned documents is similar to that returned by the get API.\nIf there is a failure getting a particular document, the error is included in place of the document.')
});

export const mget1_request = z.object({
    body: mget,
    path: z.never().optional(),
    query: z.object({
        preference: z.string().describe('Specifies the node or shard the operation should be performed on. Random by default.').optional(),
        realtime: z.boolean().describe('If `true`, the request is real-time as opposed to near-real-time.').optional(),
        refresh: z.boolean().describe('If `true`, the request refreshes relevant shards before retrieving documents.').optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        stored_fields: types_fields.optional()
    }).optional()
});

export const mget1_response = z.object({
    docs: z.array(global_mget_response_item).describe('The response includes a docs array that contains the documents in the order specified in the request.\nThe structure of the returned documents is similar to that returned by the get API.\nIf there is a failure getting a particular document, the error is included in place of the document.')
});

export const mget2_request = z.object({
    body: mget,
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        preference: z.string().describe('Specifies the node or shard the operation should be performed on. Random by default.').optional(),
        realtime: z.boolean().describe('If `true`, the request is real-time as opposed to near-real-time.').optional(),
        refresh: z.boolean().describe('If `true`, the request refreshes relevant shards before retrieving documents.').optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        stored_fields: types_fields.optional()
    }).optional()
});

export const mget2_response = z.object({
    docs: z.array(global_mget_response_item).describe('The response includes a docs array that contains the documents in the order specified in the request.\nThe structure of the returned documents is similar to that returned by the get API.\nIf there is a failure getting a particular document, the error is included in place of the document.')
});

export const mget3_request = z.object({
    body: mget,
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        preference: z.string().describe('Specifies the node or shard the operation should be performed on. Random by default.').optional(),
        realtime: z.boolean().describe('If `true`, the request is real-time as opposed to near-real-time.').optional(),
        refresh: z.boolean().describe('If `true`, the request refreshes relevant shards before retrieving documents.').optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        stored_fields: types_fields.optional()
    }).optional()
});

export const mget3_response = z.object({
    docs: z.array(global_mget_response_item).describe('The response includes a docs array that contains the documents in the order specified in the request.\nThe structure of the returned documents is similar to that returned by the get API.\nIf there is a failure getting a particular document, the error is included in place of the document.')
});

export const migration_deprecations_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const migration_deprecations_response = z.object({
    cluster_settings: z.array(migration_deprecations_deprecation).describe('Cluster-level deprecation warnings.'),
    index_settings: z.record(z.array(migration_deprecations_deprecation)).describe('Index warnings are sectioned off per index and can be filtered using an index-pattern in the query.\nThis section includes warnings for the backing indices of data streams specified in the request path.'),
    data_streams: z.record(z.array(migration_deprecations_deprecation)),
    node_settings: z.array(migration_deprecations_deprecation).describe('Node-level deprecation warnings.\nSince only a subset of your nodes might incorporate these settings, it is important to read the details section for more information about which nodes are affected.'),
    ml_settings: z.array(migration_deprecations_deprecation).describe('Machine learning-related deprecation warnings.'),
    templates: z.record(z.array(migration_deprecations_deprecation)).describe('Template warnings are sectioned off per template and include deprecations for both component templates and\nindex templates.'),
    ilm_policies: z.record(z.array(migration_deprecations_deprecation)).describe('ILM policy warnings are sectioned off per policy.')
});

export const migration_deprecations1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.never().optional()
});

export const migration_deprecations1_response = z.object({
    cluster_settings: z.array(migration_deprecations_deprecation).describe('Cluster-level deprecation warnings.'),
    index_settings: z.record(z.array(migration_deprecations_deprecation)).describe('Index warnings are sectioned off per index and can be filtered using an index-pattern in the query.\nThis section includes warnings for the backing indices of data streams specified in the request path.'),
    data_streams: z.record(z.array(migration_deprecations_deprecation)),
    node_settings: z.array(migration_deprecations_deprecation).describe('Node-level deprecation warnings.\nSince only a subset of your nodes might incorporate these settings, it is important to read the details section for more information about which nodes are affected.'),
    ml_settings: z.array(migration_deprecations_deprecation).describe('Machine learning-related deprecation warnings.'),
    templates: z.record(z.array(migration_deprecations_deprecation)).describe('Template warnings are sectioned off per template and include deprecations for both component templates and\nindex templates.'),
    ilm_policies: z.record(z.array(migration_deprecations_deprecation)).describe('ILM policy warnings are sectioned off per policy.')
});

export const migration_get_feature_upgrade_status_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const migration_get_feature_upgrade_status_response = z.object({
    features: z.array(migration_get_feature_upgrade_status_migration_feature),
    migration_status: migration_get_feature_upgrade_status_migration_status
});

export const migration_post_feature_upgrade_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const migration_post_feature_upgrade_response = z.object({
    accepted: z.boolean(),
    features: z.array(migration_post_feature_upgrade_migration_feature).optional(),
    reason: z.string().optional()
});

export const ml_clear_trained_model_deployment_cache_request = z.object({
    body: z.never().optional(),
    path: z.object({
        model_id: types_id
    }),
    query: z.never().optional()
});

export const ml_clear_trained_model_deployment_cache_response = z.object({
    cleared: z.boolean()
});

export const ml_close_job_request = z.object({
    body: z.object({
        allow_no_match: z.boolean().describe('Refer to the description for the `allow_no_match` query parameter.').optional().default(true),
        force: z.boolean().describe('Refer to the descriptiion for the `force` query parameter.').optional().default(false),
        timeout: types_duration.optional()
    }).optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request: contains wildcard expressions and there are no jobs that match; contains the  `_all` string or no identifiers and there are no matches; or contains wildcard expressions and there are only partial matches. By default, it returns an empty jobs array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.').optional(),
        force: z.boolean().describe('Use to close a failed job, or to forcefully close a job which has not responded to its initial close request; the request returns without performing the associated actions such as flushing buffers and persisting the model snapshots.\nIf you want the job to be in a consistent state after the close job API returns, do not set to `true`. This parameter should be used only in situations where the job has already failed or where you are not interested in results the job might have recently produced or might produce in the future.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_close_job_response = z.object({
    closed: z.boolean()
});

export const ml_delete_calendar_request = z.object({
    body: z.never().optional(),
    path: z.object({
        calendar_id: types_id
    }),
    query: z.never().optional()
});

export const ml_delete_calendar_response = types_acknowledged_response_base;

export const ml_get_calendars2_request = z.object({
    body: ml_get_calendars.optional(),
    path: z.object({
        calendar_id: types_id
    }),
    query: z.object({
        from: z.number().describe('Skips the specified number of calendars. This parameter is supported only when you omit the calendar identifier.').optional(),
        size: z.number().describe('Specifies the maximum number of calendars to obtain. This parameter is supported only when you omit the calendar identifier.').optional()
    }).optional()
});

export const ml_get_calendars2_response = z.object({
    calendars: z.array(ml_get_calendars_calendar),
    count: z.number()
});

export const ml_get_calendars3_request = z.object({
    body: ml_get_calendars.optional(),
    path: z.object({
        calendar_id: types_id
    }),
    query: z.object({
        from: z.number().describe('Skips the specified number of calendars. This parameter is supported only when you omit the calendar identifier.').optional(),
        size: z.number().describe('Specifies the maximum number of calendars to obtain. This parameter is supported only when you omit the calendar identifier.').optional()
    }).optional()
});

export const ml_get_calendars3_response = z.object({
    calendars: z.array(ml_get_calendars_calendar),
    count: z.number()
});

export const ml_put_calendar_request = z.object({
    body: z.object({
        job_ids: z.array(types_id).describe('An array of anomaly detection job identifiers.').optional(),
        description: z.string().describe('A description of the calendar.').optional()
    }).optional(),
    path: z.object({
        calendar_id: types_id
    }),
    query: z.never().optional()
});

export const ml_put_calendar_response = z.object({
    calendar_id: types_id,
    description: z.string().describe('A description of the calendar.').optional(),
    job_ids: types_ids
});

export const ml_delete_calendar_event_request = z.object({
    body: z.never().optional(),
    path: z.object({
        calendar_id: types_id,
        event_id: types_id
    }),
    query: z.never().optional()
});

export const ml_delete_calendar_event_response = types_acknowledged_response_base;

export const ml_delete_calendar_job_request = z.object({
    body: z.never().optional(),
    path: z.object({
        calendar_id: types_id,
        job_id: types_ids
    }),
    query: z.never().optional()
});

export const ml_delete_calendar_job_response = z.object({
    calendar_id: types_id,
    description: z.string().describe('A description of the calendar.').optional(),
    job_ids: types_ids
});

export const ml_put_calendar_job_request = z.object({
    body: z.never().optional(),
    path: z.object({
        calendar_id: types_id,
        job_id: types_ids
    }),
    query: z.never().optional()
});

export const ml_put_calendar_job_response = z.object({
    calendar_id: types_id,
    description: z.string().describe('A description of the calendar.').optional(),
    job_ids: types_ids
});

export const ml_delete_data_frame_analytics_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        force: z.boolean().describe('If `true`, it deletes a job that is not stopped; this method is quicker than stopping and deleting the job.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_delete_data_frame_analytics_response = types_acknowledged_response_base;

export const ml_delete_datafeed_request = z.object({
    body: z.never().optional(),
    path: z.object({
        datafeed_id: types_id
    }),
    query: z.object({
        force: z.boolean().describe('Use to forcefully delete a started datafeed; this method is quicker than\nstopping and deleting the datafeed.').optional()
    }).optional()
});

export const ml_delete_datafeed_response = types_acknowledged_response_base;

export const ml_delete_expired_data_request = z.object({
    body: ml_delete_expired_data.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        requests_per_second: z.number().describe('The desired requests per second for the deletion processes. The default\nbehavior is no throttling.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_delete_expired_data_response = z.object({
    deleted: z.boolean()
});

export const ml_delete_expired_data1_request = z.object({
    body: ml_delete_expired_data.optional(),
    path: z.never().optional(),
    query: z.object({
        requests_per_second: z.number().describe('The desired requests per second for the deletion processes. The default\nbehavior is no throttling.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_delete_expired_data1_response = z.object({
    deleted: z.boolean()
});

export const ml_delete_filter_request = z.object({
    body: z.never().optional(),
    path: z.object({
        filter_id: types_id
    }),
    query: z.never().optional()
});

export const ml_delete_filter_response = types_acknowledged_response_base;

export const ml_get_filters1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        filter_id: types_ids
    }),
    query: z.object({
        from: z.number().describe('Skips the specified number of filters.').optional(),
        size: z.number().describe('Specifies the maximum number of filters to obtain.').optional()
    }).optional()
});

export const ml_get_filters1_response = z.object({
    count: z.number(),
    filters: z.array(ml_types_filter)
});

export const ml_put_filter_request = z.object({
    body: z.object({
        description: z.string().describe('A description of the filter.').optional(),
        items: z.array(z.string()).describe('The items of the filter. A wildcard `*` can be used at the beginning or the end of an item.\nUp to 10000 items are allowed in each filter.').optional()
    }),
    path: z.object({
        filter_id: types_id
    }),
    query: z.never().optional()
});

export const ml_put_filter_response = z.object({
    description: z.string(),
    filter_id: types_id,
    items: z.array(z.string())
});

export const ml_delete_forecast_request = z.object({
    body: z.never().optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        allow_no_forecasts: z.boolean().describe('Specifies whether an error occurs when there are no forecasts. In\nparticular, if this parameter is set to `false` and there are no\nforecasts associated with the job, attempts to delete all forecasts\nreturn an error.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_delete_forecast_response = types_acknowledged_response_base;

export const ml_forecast_request = z.object({
    body: z.object({
        duration: types_duration.optional(),
        expires_in: types_duration.optional(),
        max_model_memory: z.string().describe('Refer to the description for the `max_model_memory` query parameter.').optional().default('20mb')
    }).optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        duration: types_duration.optional(),
        expires_in: types_duration.optional(),
        max_model_memory: z.string().describe('The maximum memory the forecast can use. If the forecast needs to use\nmore than the provided amount, it will spool to disk. Default is 20mb,\nmaximum is 500mb and minimum is 1mb. If set to 40% or more of the jobs\nconfigured memory limit, it is automatically reduced to below that\namount.').optional()
    }).optional()
});

export const ml_forecast_response = z.object({
    acknowledged: z.boolean(),
    forecast_id: types_id
});

export const ml_delete_forecast1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        job_id: types_id,
        forecast_id: types_id
    }),
    query: z.object({
        allow_no_forecasts: z.boolean().describe('Specifies whether an error occurs when there are no forecasts. In\nparticular, if this parameter is set to `false` and there are no\nforecasts associated with the job, attempts to delete all forecasts\nreturn an error.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_delete_forecast1_response = types_acknowledged_response_base;

export const ml_delete_job_request = z.object({
    body: z.never().optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        force: z.boolean().describe('Use to forcefully delete an opened job; this method is quicker than\nclosing and deleting the job.').optional(),
        delete_user_annotations: z.boolean().describe('Specifies whether annotations that have been added by the\nuser should be deleted along with any auto-generated annotations when the job is\nreset.').optional(),
        wait_for_completion: z.boolean().describe('Specifies whether the request should return immediately or wait until the\njob deletion completes.').optional()
    }).optional()
});

export const ml_delete_job_response = types_acknowledged_response_base;

export const ml_delete_model_snapshot_request = z.object({
    body: z.never().optional(),
    path: z.object({
        job_id: types_id,
        snapshot_id: types_id
    }),
    query: z.never().optional()
});

export const ml_delete_model_snapshot_response = types_acknowledged_response_base;

export const ml_get_model_snapshots_request = z.object({
    body: ml_get_model_snapshots.optional(),
    path: z.object({
        job_id: types_id,
        snapshot_id: types_id
    }),
    query: z.object({
        desc: z.boolean().describe('If true, the results are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        from: z.number().describe('Skips the specified number of snapshots.').optional(),
        size: z.number().describe('Specifies the maximum number of snapshots to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_model_snapshots_response = z.object({
    count: z.number(),
    model_snapshots: z.array(ml_types_model_snapshot)
});

export const ml_get_model_snapshots1_request = z.object({
    body: ml_get_model_snapshots.optional(),
    path: z.object({
        job_id: types_id,
        snapshot_id: types_id
    }),
    query: z.object({
        desc: z.boolean().describe('If true, the results are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        from: z.number().describe('Skips the specified number of snapshots.').optional(),
        size: z.number().describe('Specifies the maximum number of snapshots to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_model_snapshots1_response = z.object({
    count: z.number(),
    model_snapshots: z.array(ml_types_model_snapshot)
});

export const ml_delete_trained_model_request = z.object({
    body: z.never().optional(),
    path: z.object({
        model_id: types_id
    }),
    query: z.object({
        force: z.boolean().describe('Forcefully deletes a trained model that is referenced by ingest pipelines or has a started deployment.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_delete_trained_model_response = types_acknowledged_response_base;

export const ml_delete_trained_model_alias_request = z.object({
    body: z.never().optional(),
    path: z.object({
        model_id: types_id,
        model_alias: types_name
    }),
    query: z.never().optional()
});

export const ml_delete_trained_model_alias_response = types_acknowledged_response_base;

export const ml_put_trained_model_alias_request = z.object({
    body: z.never().optional(),
    path: z.object({
        model_id: types_id,
        model_alias: types_name
    }),
    query: z.object({
        reassign: z.boolean().describe('Specifies whether the alias gets reassigned to the specified trained\nmodel if it is already assigned to a different model. If the alias is\nalready assigned and this parameter is false, the API returns an error.').optional()
    }).optional()
});

export const ml_put_trained_model_alias_response = types_acknowledged_response_base;

export const ml_flush_job_request = z.object({
    body: z.object({
        advance_time: types_date_time.optional(),
        calc_interim: z.boolean().describe('Refer to the description for the `calc_interim` query parameter.').optional(),
        end: types_date_time.optional(),
        skip_time: types_date_time.optional(),
        start: types_date_time.optional()
    }).optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        advance_time: types_date_time.optional(),
        calc_interim: z.boolean().describe('If true, calculates the interim results for the most recent bucket or all\nbuckets within the latency period.').optional(),
        end: types_date_time.optional(),
        skip_time: types_date_time.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_flush_job_response = z.object({
    flushed: z.boolean(),
    last_finalized_bucket_end: z.number().describe('Provides the timestamp (in milliseconds since the epoch) of the end of\nthe last bucket that was processed.').optional()
});

export const ml_get_buckets_request = z.object({
    body: ml_get_buckets.optional(),
    path: z.object({
        job_id: types_id,
        timestamp: types_date_time
    }),
    query: z.object({
        anomaly_score: z.number().describe('Returns buckets with anomaly scores greater or equal than this value.').optional(),
        desc: z.boolean().describe('If `true`, the buckets are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        exclude_interim: z.boolean().describe('If `true`, the output excludes interim results.').optional(),
        expand: z.boolean().describe('If true, the output includes anomaly records.').optional(),
        from: z.number().describe('Skips the specified number of buckets.').optional(),
        size: z.number().describe('Specifies the maximum number of buckets to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_buckets_response = z.object({
    buckets: z.array(ml_types_bucket_summary),
    count: z.number()
});

export const ml_get_buckets1_request = z.object({
    body: ml_get_buckets.optional(),
    path: z.object({
        job_id: types_id,
        timestamp: types_date_time
    }),
    query: z.object({
        anomaly_score: z.number().describe('Returns buckets with anomaly scores greater or equal than this value.').optional(),
        desc: z.boolean().describe('If `true`, the buckets are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        exclude_interim: z.boolean().describe('If `true`, the output excludes interim results.').optional(),
        expand: z.boolean().describe('If true, the output includes anomaly records.').optional(),
        from: z.number().describe('Skips the specified number of buckets.').optional(),
        size: z.number().describe('Specifies the maximum number of buckets to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_buckets1_response = z.object({
    buckets: z.array(ml_types_bucket_summary),
    count: z.number()
});

export const ml_get_buckets2_request = z.object({
    body: ml_get_buckets.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        anomaly_score: z.number().describe('Returns buckets with anomaly scores greater or equal than this value.').optional(),
        desc: z.boolean().describe('If `true`, the buckets are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        exclude_interim: z.boolean().describe('If `true`, the output excludes interim results.').optional(),
        expand: z.boolean().describe('If true, the output includes anomaly records.').optional(),
        from: z.number().describe('Skips the specified number of buckets.').optional(),
        size: z.number().describe('Specifies the maximum number of buckets to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_buckets2_response = z.object({
    buckets: z.array(ml_types_bucket_summary),
    count: z.number()
});

export const ml_get_buckets3_request = z.object({
    body: ml_get_buckets.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        anomaly_score: z.number().describe('Returns buckets with anomaly scores greater or equal than this value.').optional(),
        desc: z.boolean().describe('If `true`, the buckets are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        exclude_interim: z.boolean().describe('If `true`, the output excludes interim results.').optional(),
        expand: z.boolean().describe('If true, the output includes anomaly records.').optional(),
        from: z.number().describe('Skips the specified number of buckets.').optional(),
        size: z.number().describe('Specifies the maximum number of buckets to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_buckets3_response = z.object({
    buckets: z.array(ml_types_bucket_summary),
    count: z.number()
});

export const ml_get_calendar_events_request = z.object({
    body: z.never().optional(),
    path: z.object({
        calendar_id: types_id
    }),
    query: z.object({
        end: types_date_time.optional(),
        from: z.number().describe('Skips the specified number of events.').optional(),
        job_id: types_id.optional(),
        size: z.number().describe('Specifies the maximum number of events to obtain.').optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_calendar_events_response = z.object({
    count: z.number(),
    events: z.array(ml_types_calendar_event)
});

export const ml_post_calendar_events_request = z.object({
    body: z.object({
        events: z.array(ml_types_calendar_event).describe('A list of one of more scheduled events. The events start and end times can be specified as integer milliseconds since the epoch or as a string in ISO 8601 format.')
    }),
    path: z.object({
        calendar_id: types_id
    }),
    query: z.never().optional()
});

export const ml_post_calendar_events_response = z.object({
    events: z.array(ml_types_calendar_event)
});

export const ml_get_calendars_request = z.object({
    body: ml_get_calendars.optional(),
    path: z.never().optional(),
    query: z.object({
        from: z.number().describe('Skips the specified number of calendars. This parameter is supported only when you omit the calendar identifier.').optional(),
        size: z.number().describe('Specifies the maximum number of calendars to obtain. This parameter is supported only when you omit the calendar identifier.').optional()
    }).optional()
});

export const ml_get_calendars_response = z.object({
    calendars: z.array(ml_get_calendars_calendar),
    count: z.number()
});

export const ml_get_calendars1_request = z.object({
    body: ml_get_calendars.optional(),
    path: z.never().optional(),
    query: z.object({
        from: z.number().describe('Skips the specified number of calendars. This parameter is supported only when you omit the calendar identifier.').optional(),
        size: z.number().describe('Specifies the maximum number of calendars to obtain. This parameter is supported only when you omit the calendar identifier.').optional()
    }).optional()
});

export const ml_get_calendars1_response = z.object({
    calendars: z.array(ml_get_calendars_calendar),
    count: z.number()
});

export const ml_get_categories_request = z.object({
    body: ml_get_categories.optional(),
    path: z.object({
        job_id: types_id,
        category_id: types_category_id
    }),
    query: z.object({
        from: z.number().describe('Skips the specified number of categories.').optional(),
        partition_field_value: z.string().describe('Only return categories for the specified partition.').optional(),
        size: z.number().describe('Specifies the maximum number of categories to obtain.').optional()
    }).optional()
});

export const ml_get_categories_response = z.object({
    categories: z.array(ml_types_category),
    count: z.number()
});

export const ml_get_categories1_request = z.object({
    body: ml_get_categories.optional(),
    path: z.object({
        job_id: types_id,
        category_id: types_category_id
    }),
    query: z.object({
        from: z.number().describe('Skips the specified number of categories.').optional(),
        partition_field_value: z.string().describe('Only return categories for the specified partition.').optional(),
        size: z.number().describe('Specifies the maximum number of categories to obtain.').optional()
    }).optional()
});

export const ml_get_categories1_response = z.object({
    categories: z.array(ml_types_category),
    count: z.number()
});

export const ml_get_categories2_request = z.object({
    body: ml_get_categories.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        from: z.number().describe('Skips the specified number of categories.').optional(),
        partition_field_value: z.string().describe('Only return categories for the specified partition.').optional(),
        size: z.number().describe('Specifies the maximum number of categories to obtain.').optional()
    }).optional()
});

export const ml_get_categories2_response = z.object({
    categories: z.array(ml_types_category),
    count: z.number()
});

export const ml_get_categories3_request = z.object({
    body: ml_get_categories.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        from: z.number().describe('Skips the specified number of categories.').optional(),
        partition_field_value: z.string().describe('Only return categories for the specified partition.').optional(),
        size: z.number().describe('Specifies the maximum number of categories to obtain.').optional()
    }).optional()
});

export const ml_get_categories3_response = z.object({
    categories: z.array(ml_types_category),
    count: z.number()
});

export const ml_get_data_frame_analytics_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value returns an empty data_frame_analytics array when there\nare no matches and the subset of results when there are partial matches.\nIf this parameter is `false`, the request returns a 404 status code when\nthere are no matches or only partial matches.').optional(),
        from: z.number().describe('Skips the specified number of data frame analytics jobs.').optional(),
        size: z.number().describe('Specifies the maximum number of data frame analytics jobs to obtain.').optional(),
        verbose: z.boolean().describe('Defines whether the stats response should be verbose.').optional()
    }).optional()
});

export const ml_get_data_frame_analytics_stats_response = z.object({
    count: z.number(),
    data_frame_analytics: z.array(ml_types_dataframe_analytics).describe('An array of objects that contain usage information for data frame analytics jobs, which are sorted by the id value in ascending order.')
});

export const ml_get_data_frame_analytics_stats1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value returns an empty data_frame_analytics array when there\nare no matches and the subset of results when there are partial matches.\nIf this parameter is `false`, the request returns a 404 status code when\nthere are no matches or only partial matches.').optional(),
        from: z.number().describe('Skips the specified number of data frame analytics jobs.').optional(),
        size: z.number().describe('Specifies the maximum number of data frame analytics jobs to obtain.').optional(),
        verbose: z.boolean().describe('Defines whether the stats response should be verbose.').optional()
    }).optional()
});

export const ml_get_data_frame_analytics_stats1_response = z.object({
    count: z.number(),
    data_frame_analytics: z.array(ml_types_dataframe_analytics).describe('An array of objects that contain usage information for data frame analytics jobs, which are sorted by the id value in ascending order.')
});

export const ml_get_datafeed_stats_request = z.object({
    body: z.never().optional(),
    path: z.object({
        datafeed_id: types_ids
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no datafeeds that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `datafeeds` array\nwhen there are no matches and the subset of results when there are\npartial matches. If this parameter is `false`, the request returns a\n`404` status code when there are no matches or only partial matches.').optional()
    }).optional()
});

export const ml_get_datafeed_stats_response = z.object({
    count: z.number(),
    datafeeds: z.array(ml_types_datafeed_stats)
});

export const ml_get_datafeed_stats1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no datafeeds that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `datafeeds` array\nwhen there are no matches and the subset of results when there are\npartial matches. If this parameter is `false`, the request returns a\n`404` status code when there are no matches or only partial matches.').optional()
    }).optional()
});

export const ml_get_datafeed_stats1_response = z.object({
    count: z.number(),
    datafeeds: z.array(ml_types_datafeed_stats)
});

export const ml_get_filters_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        from: z.number().describe('Skips the specified number of filters.').optional(),
        size: z.number().describe('Specifies the maximum number of filters to obtain.').optional()
    }).optional()
});

export const ml_get_filters_response = z.object({
    count: z.number(),
    filters: z.array(ml_types_filter)
});

export const ml_get_influencers_request = z.object({
    body: ml_get_influencers.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        desc: z.boolean().describe('If true, the results are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        exclude_interim: z.boolean().describe('If true, the output excludes interim results. By default, interim results\nare included.').optional(),
        influencer_score: z.number().describe('Returns influencers with anomaly scores greater than or equal to this\nvalue.').optional(),
        from: z.number().describe('Skips the specified number of influencers.').optional(),
        size: z.number().describe('Specifies the maximum number of influencers to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_influencers_response = z.object({
    count: z.number(),
    influencers: z.array(ml_types_influencer).describe('Array of influencer objects')
});

export const ml_get_influencers1_request = z.object({
    body: ml_get_influencers.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        desc: z.boolean().describe('If true, the results are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        exclude_interim: z.boolean().describe('If true, the output excludes interim results. By default, interim results\nare included.').optional(),
        influencer_score: z.number().describe('Returns influencers with anomaly scores greater than or equal to this\nvalue.').optional(),
        from: z.number().describe('Skips the specified number of influencers.').optional(),
        size: z.number().describe('Specifies the maximum number of influencers to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_influencers1_response = z.object({
    count: z.number(),
    influencers: z.array(ml_types_influencer).describe('Array of influencer objects')
});

export const ml_get_job_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty `jobs` array when\nthere are no matches and the subset of results when there are partial\nmatches. If `false`, the API returns a `404` status\ncode when there are no matches or only partial matches.').optional()
    }).optional()
});

export const ml_get_job_stats_response = z.object({
    count: z.number(),
    jobs: z.array(ml_types_job_stats)
});

export const ml_get_job_stats1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty `jobs` array when\nthere are no matches and the subset of results when there are partial\nmatches. If `false`, the API returns a `404` status\ncode when there are no matches or only partial matches.').optional()
    }).optional()
});

export const ml_get_job_stats1_response = z.object({
    count: z.number(),
    jobs: z.array(ml_types_job_stats)
});

export const ml_get_memory_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_get_memory_stats_response = z.object({
    _nodes: types_node_statistics,
    cluster_name: types_name,
    nodes: z.record(ml_get_memory_stats_memory)
});

export const ml_get_memory_stats1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_id
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_get_memory_stats1_response = z.object({
    _nodes: types_node_statistics,
    cluster_name: types_name,
    nodes: z.record(ml_get_memory_stats_memory)
});

export const ml_get_model_snapshot_upgrade_stats_request = z.object({
    body: z.never().optional(),
    path: z.object({
        job_id: types_id,
        snapshot_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n -  Contains wildcard expressions and there are no jobs that match.\n -  Contains the _all string or no identifiers and there are no matches.\n -  Contains wildcard expressions and there are only partial matches.\n\nThe default value is true, which returns an empty jobs array when there are no matches and the subset of results\nwhen there are partial matches. If this parameter is false, the request returns a 404 status code when there are\nno matches or only partial matches.').optional()
    }).optional()
});

export const ml_get_model_snapshot_upgrade_stats_response = z.object({
    count: z.number(),
    model_snapshot_upgrades: z.array(ml_types_model_snapshot_upgrade)
});

export const ml_get_model_snapshots2_request = z.object({
    body: ml_get_model_snapshots.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        desc: z.boolean().describe('If true, the results are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        from: z.number().describe('Skips the specified number of snapshots.').optional(),
        size: z.number().describe('Specifies the maximum number of snapshots to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_model_snapshots2_response = z.object({
    count: z.number(),
    model_snapshots: z.array(ml_types_model_snapshot)
});

export const ml_get_model_snapshots3_request = z.object({
    body: ml_get_model_snapshots.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        desc: z.boolean().describe('If true, the results are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        from: z.number().describe('Skips the specified number of snapshots.').optional(),
        size: z.number().describe('Specifies the maximum number of snapshots to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_model_snapshots3_response = z.object({
    count: z.number(),
    model_snapshots: z.array(ml_types_model_snapshot)
});

export const ml_get_overall_buckets_request = z.object({
    body: ml_get_overall_buckets.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the request returns an empty `jobs` array when there are no\nmatches and the subset of results when there are partial matches. If this\nparameter is `false`, the request returns a `404` status code when there\nare no matches or only partial matches.').optional(),
        bucket_span: types_duration.optional(),
        end: types_date_time.optional(),
        exclude_interim: z.boolean().describe('If `true`, the output excludes interim results.').optional(),
        overall_score: z.number().describe('Returns overall buckets with overall scores greater than or equal to this\nvalue.').optional(),
        start: types_date_time.optional(),
        top_n: z.number().describe('The number of top anomaly detection job bucket scores to be used in the\n`overall_score` calculation.').optional()
    }).optional()
});

export const ml_get_overall_buckets_response = z.object({
    count: z.number(),
    overall_buckets: z.array(ml_types_overall_bucket).describe('Array of overall bucket objects')
});

export const ml_get_overall_buckets1_request = z.object({
    body: ml_get_overall_buckets.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the request returns an empty `jobs` array when there are no\nmatches and the subset of results when there are partial matches. If this\nparameter is `false`, the request returns a `404` status code when there\nare no matches or only partial matches.').optional(),
        bucket_span: types_duration.optional(),
        end: types_date_time.optional(),
        exclude_interim: z.boolean().describe('If `true`, the output excludes interim results.').optional(),
        overall_score: z.number().describe('Returns overall buckets with overall scores greater than or equal to this\nvalue.').optional(),
        start: types_date_time.optional(),
        top_n: z.number().describe('The number of top anomaly detection job bucket scores to be used in the\n`overall_score` calculation.').optional()
    }).optional()
});

export const ml_get_overall_buckets1_response = z.object({
    count: z.number(),
    overall_buckets: z.array(ml_types_overall_bucket).describe('Array of overall bucket objects')
});

export const ml_get_records_request = z.object({
    body: ml_get_records.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        desc: z.boolean().describe('If true, the results are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        exclude_interim: z.boolean().describe('If `true`, the output excludes interim results.').optional(),
        from: z.number().describe('Skips the specified number of records.').optional(),
        record_score: z.number().describe('Returns records with anomaly scores greater or equal than this value.').optional(),
        size: z.number().describe('Specifies the maximum number of records to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_records_response = z.object({
    count: z.number(),
    records: z.array(ml_types_anomaly)
});

export const ml_get_records1_request = z.object({
    body: ml_get_records.optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        desc: z.boolean().describe('If true, the results are sorted in descending order.').optional(),
        end: types_date_time.optional(),
        exclude_interim: z.boolean().describe('If `true`, the output excludes interim results.').optional(),
        from: z.number().describe('Skips the specified number of records.').optional(),
        record_score: z.number().describe('Returns records with anomaly scores greater or equal than this value.').optional(),
        size: z.number().describe('Specifies the maximum number of records to obtain.').optional(),
        sort: types_field.optional(),
        start: types_date_time.optional()
    }).optional()
});

export const ml_get_records1_response = z.object({
    count: z.number(),
    records: z.array(ml_types_anomaly)
});

export const ml_get_trained_models_stats_request = z.object({
    body: z.never().optional(),
    path: z.object({
        model_id: types_ids
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n- Contains wildcard expressions and there are no models that match.\n- Contains the _all string or no identifiers and there are no matches.\n- Contains wildcard expressions and there are only partial matches.\n\nIf true, it returns an empty array when there are no matches and the\nsubset of results when there are partial matches.').optional(),
        from: z.number().describe('Skips the specified number of models.').optional(),
        size: z.number().describe('Specifies the maximum number of models to obtain.').optional()
    }).optional()
});

export const ml_get_trained_models_stats_response = z.object({
    count: z.number().describe('The total number of trained model statistics that matched the requested ID patterns. Could be higher than the number of items in the trained_model_stats array as the size of the array is restricted by the supplied size parameter.'),
    trained_model_stats: z.array(ml_types_trained_model_stats).describe('An array of trained model statistics, which are sorted by the model_id value in ascending order.')
});

export const ml_get_trained_models_stats1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n- Contains wildcard expressions and there are no models that match.\n- Contains the _all string or no identifiers and there are no matches.\n- Contains wildcard expressions and there are only partial matches.\n\nIf true, it returns an empty array when there are no matches and the\nsubset of results when there are partial matches.').optional(),
        from: z.number().describe('Skips the specified number of models.').optional(),
        size: z.number().describe('Specifies the maximum number of models to obtain.').optional()
    }).optional()
});

export const ml_get_trained_models_stats1_response = z.object({
    count: z.number().describe('The total number of trained model statistics that matched the requested ID patterns. Could be higher than the number of items in the trained_model_stats array as the size of the array is restricted by the supplied size parameter.'),
    trained_model_stats: z.array(ml_types_trained_model_stats).describe('An array of trained model statistics, which are sorted by the model_id value in ascending order.')
});

export const ml_infer_trained_model_request = z.object({
    body: z.object({
        docs: z.array(z.record(z.record(z.unknown()))).describe('An array of objects to pass to the model for inference. The objects should contain a fields matching your\nconfigured trained model input. Typically, for NLP models, the field name is `text_field`.\nCurrently, for NLP models, only a single value is allowed.'),
        inference_config: ml_types_inference_config_update_container.optional()
    }),
    path: z.object({
        model_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const ml_infer_trained_model_response = z.object({
    inference_results: z.array(ml_types_inference_response_result)
});

export const ml_open_job_request = z.object({
    body: z.object({
        timeout: types_duration.optional()
    }).optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const ml_open_job_response = z.object({
    opened: z.boolean(),
    node: types_node_id
});

export const ml_post_data_request = z.object({
    body: z.array(z.record(z.unknown())),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        reset_end: types_date_time.optional(),
        reset_start: types_date_time.optional()
    }).optional()
});

export const ml_post_data_response = z.object({
    job_id: types_id,
    processed_record_count: z.number(),
    processed_field_count: z.number(),
    input_bytes: z.number(),
    input_field_count: z.number(),
    invalid_date_count: z.number(),
    missing_field_count: z.number(),
    out_of_order_timestamp_count: z.number(),
    empty_bucket_count: z.number(),
    sparse_bucket_count: z.number(),
    bucket_count: z.number(),
    earliest_record_timestamp: types_epoch_time_unit_millis.optional(),
    latest_record_timestamp: types_epoch_time_unit_millis.optional(),
    last_data_time: types_epoch_time_unit_millis.optional(),
    latest_empty_bucket_timestamp: types_epoch_time_unit_millis.optional(),
    latest_sparse_bucket_timestamp: types_epoch_time_unit_millis.optional(),
    input_record_count: z.number(),
    log_time: types_epoch_time_unit_millis.optional()
});

export const ml_put_trained_model_definition_part_request = z.object({
    body: z.object({
        definition: z.string().describe('The definition part for the model. Must be a base64 encoded string.'),
        total_definition_length: z.number().describe('The total uncompressed definition length in bytes. Not base64 encoded.'),
        total_parts: z.number().describe('The total number of parts that will be uploaded. Must be greater than 0.')
    }),
    path: z.object({
        model_id: types_id,
        part: z.number().describe('The definition part number. When the definition is loaded for inference the definition parts are streamed in the\norder of their part number. The first part must be `0` and the final part must be `total_parts - 1`.')
    }),
    query: z.never().optional()
});

export const ml_put_trained_model_definition_part_response = types_acknowledged_response_base;

export const ml_put_trained_model_vocabulary_request = z.object({
    body: z.object({
        vocabulary: z.array(z.string()).describe('The model vocabulary, which must not be empty.'),
        merges: z.array(z.string()).describe('The optional model merges if required by the tokenizer.').optional(),
        scores: z.array(z.number()).describe('The optional vocabulary value scores if required by the tokenizer.').optional()
    }),
    path: z.object({
        model_id: types_id
    }),
    query: z.never().optional()
});

export const ml_put_trained_model_vocabulary_response = types_acknowledged_response_base;

export const ml_reset_job_request = z.object({
    body: z.never().optional(),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        wait_for_completion: z.boolean().describe('Should this request wait until the operation has completed before\nreturning.').optional(),
        delete_user_annotations: z.boolean().describe('Specifies whether annotations that have been added by the\nuser should be deleted along with any auto-generated annotations when the job is\nreset.').optional()
    }).optional()
});

export const ml_reset_job_response = types_acknowledged_response_base;

export const ml_revert_model_snapshot_request = z.object({
    body: z.object({
        delete_intervening_results: z.boolean().describe('Refer to the description for the `delete_intervening_results` query parameter.').optional().default(false)
    }).optional(),
    path: z.object({
        job_id: types_id,
        snapshot_id: types_id
    }),
    query: z.object({
        delete_intervening_results: z.boolean().describe('If true, deletes the results in the time period between the latest\nresults and the time of the reverted snapshot. It also resets the model\nto accept records for this time period. If you choose not to delete\nintervening results when reverting a snapshot, the job will not accept\ninput data that is older than the current time. If you want to resend\ndata, then delete the intervening results.').optional()
    }).optional()
});

export const ml_revert_model_snapshot_response = z.object({
    model: ml_types_model_snapshot
});

export const ml_set_upgrade_mode_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        enabled: z.boolean().describe('When `true`, it enables `upgrade_mode` which temporarily halts all job\nand datafeed tasks and prohibits new job and datafeed tasks from\nstarting.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_set_upgrade_mode_response = types_acknowledged_response_base;

export const ml_start_data_frame_analytics_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const ml_start_data_frame_analytics_response = z.object({
    acknowledged: z.boolean(),
    node: types_node_id
});

export const ml_start_datafeed_request = z.object({
    body: z.object({
        end: types_date_time.optional(),
        start: types_date_time.optional(),
        timeout: types_duration.optional()
    }).optional(),
    path: z.object({
        datafeed_id: types_id
    }),
    query: z.object({
        end: types_date_time.optional(),
        start: types_date_time.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_start_datafeed_response = z.object({
    node: types_node_ids,
    started: z.boolean().describe('For a successful response, this value is always `true`. On failure, an exception is returned instead.')
});

export const ml_start_trained_model_deployment_request = z.object({
    body: z.object({
        adaptive_allocations: ml_types_adaptive_allocations_settings.optional()
    }).optional(),
    path: z.object({
        model_id: types_id
    }),
    query: z.object({
        cache_size: types_byte_size.optional(),
        deployment_id: z.string().describe('A unique identifier for the deployment of the model.').optional(),
        number_of_allocations: z.number().describe('The number of model allocations on each node where the model is deployed.\nAll allocations on a node share the same copy of the model in memory but use\na separate set of threads to evaluate the model.\nIncreasing this value generally increases the throughput.\nIf this setting is greater than the number of hardware threads\nit will automatically be changed to a value less than the number of hardware threads.\nIf adaptive_allocations is enabled, do not set this value, because its automatically set.').optional(),
        priority: ml_types_training_priority.optional(),
        queue_capacity: z.number().describe('Specifies the number of inference requests that are allowed in the queue. After the number of requests exceeds\nthis value, new requests are rejected with a 429 error.').optional(),
        threads_per_allocation: z.number().describe('Sets the number of threads used by each model allocation during inference. This generally increases\nthe inference speed. The inference process is a compute-bound process; any number\ngreater than the number of available hardware threads on the machine does not increase the\ninference speed. If this setting is greater than the number of hardware threads\nit will automatically be changed to a value less than the number of hardware threads.').optional(),
        timeout: types_duration.optional(),
        wait_for: ml_types_deployment_allocation_state.optional()
    }).optional()
});

export const ml_start_trained_model_deployment_response = z.object({
    assignment: ml_types_trained_model_assignment
});

export const ml_stop_data_frame_analytics_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is true, which returns an empty data_frame_analytics\narray when there are no matches and the subset of results when there are\npartial matches. If this parameter is false, the request returns a 404\nstatus code when there are no matches or only partial matches.').optional(),
        force: z.boolean().describe('If true, the data frame analytics job is stopped forcefully.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_stop_data_frame_analytics_response = z.object({
    stopped: z.boolean()
});

export const ml_stop_datafeed_request = z.object({
    body: z.object({
        allow_no_match: z.boolean().describe('Refer to the description for the `allow_no_match` query parameter.').optional().default(true),
        force: z.boolean().describe('Refer to the description for the `force` query parameter.').optional().default(false),
        timeout: types_duration.optional()
    }).optional(),
    path: z.object({
        datafeed_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no datafeeds that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty datafeeds array when there are no matches and the subset of results when\nthere are partial matches. If `false`, the API returns a 404 status code when there are no matches or only\npartial matches.').optional(),
        force: z.boolean().describe('If `true`, the datafeed is stopped forcefully.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_stop_datafeed_response = z.object({
    stopped: z.boolean()
});

export const ml_stop_trained_model_deployment_request = z.object({
    body: z.never().optional(),
    path: z.object({
        model_id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request: contains wildcard expressions and there are no deployments that match;\ncontains the  `_all` string or no identifiers and there are no matches; or contains wildcard expressions and\nthere are only partial matches. By default, it returns an empty array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.').optional(),
        force: z.boolean().describe('Forcefully stops the deployment, even if it is used by ingest pipelines. You can\'t use these pipelines until you\nrestart the model deployment.').optional()
    }).optional()
});

export const ml_stop_trained_model_deployment_response = z.object({
    stopped: z.boolean()
});

export const ml_update_filter_request = z.object({
    body: z.object({
        add_items: z.array(z.string()).describe('The items to add to the filter.').optional(),
        description: z.string().describe('A description for the filter.').optional(),
        remove_items: z.array(z.string()).describe('The items to remove from the filter.').optional()
    }),
    path: z.object({
        filter_id: types_id
    }),
    query: z.never().optional()
});

export const ml_update_filter_response = z.object({
    description: z.string(),
    filter_id: types_id,
    items: z.array(z.string())
});

export const ml_update_model_snapshot_request = z.object({
    body: z.object({
        description: z.string().describe('A description of the model snapshot.').optional(),
        retain: z.boolean().describe('If `true`, this snapshot will not be deleted during automatic cleanup of\nsnapshots older than `model_snapshot_retention_days`. However, this\nsnapshot will be deleted when the job is deleted.').optional().default(false)
    }),
    path: z.object({
        job_id: types_id,
        snapshot_id: types_id
    }),
    query: z.never().optional()
});

export const ml_update_model_snapshot_response = z.object({
    acknowledged: z.boolean(),
    model: ml_types_model_snapshot
});

export const ml_update_trained_model_deployment_request = z.object({
    body: z.object({
        number_of_allocations: z.number().describe('The number of model allocations on each node where the model is deployed.\nAll allocations on a node share the same copy of the model in memory but use\na separate set of threads to evaluate the model.\nIncreasing this value generally increases the throughput.\nIf this setting is greater than the number of hardware threads\nit will automatically be changed to a value less than the number of hardware threads.\nIf adaptive_allocations is enabled, do not set this value, because its automatically set.').optional().default(1),
        adaptive_allocations: ml_types_adaptive_allocations_settings.optional()
    }).optional(),
    path: z.object({
        model_id: types_id
    }),
    query: z.object({
        number_of_allocations: z.number().describe('The number of model allocations on each node where the model is deployed.\nAll allocations on a node share the same copy of the model in memory but use\na separate set of threads to evaluate the model.\nIncreasing this value generally increases the throughput.\nIf this setting is greater than the number of hardware threads\nit will automatically be changed to a value less than the number of hardware threads.').optional()
    }).optional()
});

export const ml_update_trained_model_deployment_response = z.object({
    assignment: ml_types_trained_model_assignment
});

export const ml_upgrade_job_snapshot_request = z.object({
    body: z.never().optional(),
    path: z.object({
        job_id: types_id,
        snapshot_id: types_id
    }),
    query: z.object({
        wait_for_completion: z.boolean().describe('When true, the API wont respond until the upgrade is complete.\nOtherwise, it responds as soon as the upgrade task is assigned to a node.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const ml_upgrade_job_snapshot_response = z.object({
    node: types_node_id,
    completed: z.boolean().describe('When true, this means the task is complete. When false, it is still running.')
});

export const mtermvectors_request = z.object({
    body: mtermvectors.optional(),
    path: z.never().optional(),
    query: z.object({
        ids: z.array(types_id).describe('A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body').optional(),
        fields: types_fields.optional(),
        field_statistics: z.boolean().describe('If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.').optional(),
        offsets: z.boolean().describe('If `true`, the response includes term offsets.').optional(),
        payloads: z.boolean().describe('If `true`, the response includes term payloads.').optional(),
        positions: z.boolean().describe('If `true`, the response includes term positions.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        realtime: z.boolean().describe('If true, the request is real-time as opposed to near-real-time.').optional(),
        routing: types_routing.optional(),
        term_statistics: z.boolean().describe('If true, the response includes term frequency and document frequency.').optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const mtermvectors_response = z.object({
    docs: z.array(global_mtermvectors_term_vectors_result)
});

export const mtermvectors1_request = z.object({
    body: mtermvectors.optional(),
    path: z.never().optional(),
    query: z.object({
        ids: z.array(types_id).describe('A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body').optional(),
        fields: types_fields.optional(),
        field_statistics: z.boolean().describe('If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.').optional(),
        offsets: z.boolean().describe('If `true`, the response includes term offsets.').optional(),
        payloads: z.boolean().describe('If `true`, the response includes term payloads.').optional(),
        positions: z.boolean().describe('If `true`, the response includes term positions.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        realtime: z.boolean().describe('If true, the request is real-time as opposed to near-real-time.').optional(),
        routing: types_routing.optional(),
        term_statistics: z.boolean().describe('If true, the response includes term frequency and document frequency.').optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const mtermvectors1_response = z.object({
    docs: z.array(global_mtermvectors_term_vectors_result)
});

export const mtermvectors2_request = z.object({
    body: mtermvectors.optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        ids: z.array(types_id).describe('A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body').optional(),
        fields: types_fields.optional(),
        field_statistics: z.boolean().describe('If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.').optional(),
        offsets: z.boolean().describe('If `true`, the response includes term offsets.').optional(),
        payloads: z.boolean().describe('If `true`, the response includes term payloads.').optional(),
        positions: z.boolean().describe('If `true`, the response includes term positions.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        realtime: z.boolean().describe('If true, the request is real-time as opposed to near-real-time.').optional(),
        routing: types_routing.optional(),
        term_statistics: z.boolean().describe('If true, the response includes term frequency and document frequency.').optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const mtermvectors2_response = z.object({
    docs: z.array(global_mtermvectors_term_vectors_result)
});

export const mtermvectors3_request = z.object({
    body: mtermvectors.optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        ids: z.array(types_id).describe('A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body').optional(),
        fields: types_fields.optional(),
        field_statistics: z.boolean().describe('If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.').optional(),
        offsets: z.boolean().describe('If `true`, the response includes term offsets.').optional(),
        payloads: z.boolean().describe('If `true`, the response includes term payloads.').optional(),
        positions: z.boolean().describe('If `true`, the response includes term positions.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        realtime: z.boolean().describe('If true, the request is real-time as opposed to near-real-time.').optional(),
        routing: types_routing.optional(),
        term_statistics: z.boolean().describe('If true, the response includes term frequency and document frequency.').optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const mtermvectors3_response = z.object({
    docs: z.array(global_mtermvectors_term_vectors_result)
});

export const nodes_clear_repositories_metering_archive_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids,
        max_archive_version: z.number().describe('Specifies the maximum `archive_version` to be cleared from the archive.')
    }),
    query: z.never().optional()
});

export const nodes_clear_repositories_metering_archive_response = nodes_clear_repositories_metering_archive_response_base;

export const nodes_get_repositories_metering_info_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids
    }),
    query: z.never().optional()
});

export const nodes_get_repositories_metering_info_response = nodes_get_repositories_metering_info_response_base;

export const nodes_hot_threads_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        ignore_idle_threads: z.boolean().describe('If true, known idle threads (e.g. waiting in a socket select, or to get\na task from an empty queue) are filtered out.').optional(),
        interval: types_duration.optional(),
        snapshots: z.number().describe('Number of samples of thread stacktrace.').optional(),
        threads: z.number().describe('Specifies the number of hot threads to provide information for.').optional(),
        timeout: types_duration.optional(),
        type: types_thread_type.optional(),
        sort: types_thread_type.optional()
    }).optional()
});

export const nodes_hot_threads_response = z.record(z.unknown());

export const nodes_hot_threads1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids
    }),
    query: z.object({
        ignore_idle_threads: z.boolean().describe('If true, known idle threads (e.g. waiting in a socket select, or to get\na task from an empty queue) are filtered out.').optional(),
        interval: types_duration.optional(),
        snapshots: z.number().describe('Number of samples of thread stacktrace.').optional(),
        threads: z.number().describe('Specifies the number of hot threads to provide information for.').optional(),
        timeout: types_duration.optional(),
        type: types_thread_type.optional(),
        sort: types_thread_type.optional()
    }).optional()
});

export const nodes_hot_threads1_response = z.record(z.unknown());

export const nodes_info_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        flat_settings: z.boolean().describe('If true, returns settings in flat format.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const nodes_info_response = nodes_info_response_base;

export const nodes_info1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids
    }),
    query: z.object({
        flat_settings: z.boolean().describe('If true, returns settings in flat format.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const nodes_info1_response = nodes_info_response_base;

export const nodes_info2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        metric: nodes_info_nodes_info_metrics
    }),
    query: z.object({
        flat_settings: z.boolean().describe('If true, returns settings in flat format.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const nodes_info2_response = nodes_info_response_base;

export const nodes_info3_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids,
        metric: nodes_info_nodes_info_metrics
    }),
    query: z.object({
        flat_settings: z.boolean().describe('If true, returns settings in flat format.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const nodes_info3_response = nodes_info_response_base;

export const nodes_reload_secure_settings_request = z.object({
    body: nodes_reload_secure_settings.optional(),
    path: z.never().optional(),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const nodes_reload_secure_settings_response = nodes_reload_secure_settings_response_base;

export const nodes_reload_secure_settings1_request = z.object({
    body: nodes_reload_secure_settings.optional(),
    path: z.object({
        node_id: types_node_ids
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const nodes_reload_secure_settings1_response = nodes_reload_secure_settings_response_base;

export const nodes_usage_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const nodes_usage_response = nodes_usage_response_base;

export const nodes_usage1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const nodes_usage1_response = nodes_usage_response_base;

export const nodes_usage2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        metric: nodes_usage_nodes_usage_metrics
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const nodes_usage2_response = nodes_usage_response_base;

export const nodes_usage3_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids,
        metric: nodes_usage_nodes_usage_metrics
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const nodes_usage3_response = nodes_usage_response_base;

export const query_rules_delete_rule_request = z.object({
    body: z.never().optional(),
    path: z.object({
        ruleset_id: types_id,
        rule_id: types_id
    }),
    query: z.never().optional()
});

export const query_rules_delete_rule_response = types_acknowledged_response_base;

export const query_rules_get_rule_request = z.object({
    body: z.never().optional(),
    path: z.object({
        ruleset_id: types_id,
        rule_id: types_id
    }),
    query: z.never().optional()
});

export const query_rules_get_rule_response = query_rules_types_query_rule;

export const query_rules_put_rule_request = z.object({
    body: z.object({
        type: query_rules_types_query_rule_type,
        criteria: z.union([
            query_rules_types_query_rule_criteria,
            z.array(query_rules_types_query_rule_criteria)
        ]),
        actions: query_rules_types_query_rule_actions,
        priority: z.number().optional()
    }),
    path: z.object({
        ruleset_id: types_id,
        rule_id: types_id
    }),
    query: z.never().optional()
});

export const query_rules_put_rule_response = z.object({
    result: types_result
});

export const query_rules_delete_ruleset_request = z.object({
    body: z.never().optional(),
    path: z.object({
        ruleset_id: types_id
    }),
    query: z.never().optional()
});

export const query_rules_delete_ruleset_response = types_acknowledged_response_base;

export const query_rules_get_ruleset_request = z.object({
    body: z.never().optional(),
    path: z.object({
        ruleset_id: types_id
    }),
    query: z.never().optional()
});

export const query_rules_get_ruleset_response = query_rules_types_query_ruleset;

export const query_rules_put_ruleset_request = z.object({
    body: z.object({
        rules: z.union([
            query_rules_types_query_rule,
            z.array(query_rules_types_query_rule)
        ])
    }),
    path: z.object({
        ruleset_id: types_id
    }),
    query: z.never().optional()
});

export const query_rules_put_ruleset_response = z.object({
    result: types_result
});

export const query_rules_list_rulesets_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        from: z.number().describe('The offset from the first result to fetch.').optional(),
        size: z.number().describe('The maximum number of results to retrieve.').optional()
    }).optional()
});

export const query_rules_list_rulesets_response = z.object({
    count: z.number(),
    results: z.array(query_rules_list_rulesets_query_ruleset_list_item)
});

export const query_rules_test_request = z.object({
    body: z.object({
        match_criteria: z.record(z.record(z.unknown())).describe('The match criteria to apply to rules in the given query ruleset.\nMatch criteria should match the keys defined in the `criteria.metadata` field of the rule.')
    }),
    path: z.object({
        ruleset_id: types_id
    }),
    query: z.never().optional()
});

export const query_rules_test_response = z.object({
    total_matched_rules: z.number(),
    matched_rules: z.array(query_rules_test_query_ruleset_matched_rule)
});

export const reindex_rethrottle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        task_id: types_id
    }),
    query: z.object({
        requests_per_second: z.number().describe('The throttle for this request in sub-requests per second.\nIt can be either `-1` to turn off throttling or any decimal number like `1.7` or `12` to throttle to that level.').optional()
    }).optional()
});

export const reindex_rethrottle_response = z.object({
    nodes: z.record(global_reindex_rethrottle_reindex_node)
});

export const rollup_delete_job_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const rollup_delete_job_response = z.object({
    acknowledged: z.boolean(),
    task_failures: z.array(types_task_failure).optional()
});

export const rollup_get_jobs_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const rollup_get_jobs_response = z.object({
    jobs: z.array(rollup_get_jobs_rollup_job)
});

export const rollup_put_job_request = z.object({
    body: z.object({
        cron: z.string().describe('A cron string which defines the intervals when the rollup job should be executed. When the interval\ntriggers, the indexer attempts to rollup the data in the index pattern. The cron pattern is unrelated\nto the time interval of the data being rolled up. For example, you may wish to create hourly rollups\nof your document but to only run the indexer on a daily basis at midnight, as defined by the cron. The\ncron pattern is defined just like a Watcher cron schedule.'),
        groups: rollup_types_groupings,
        index_pattern: z.string().describe('The index or index pattern to roll up. Supports wildcard-style patterns (`logstash-*`). The job attempts to\nrollup the entire index or index-pattern.'),
        metrics: z.array(rollup_types_field_metric).describe('Defines the metrics to collect for each grouping tuple. By default, only the doc_counts are collected for each\ngroup. To make rollup useful, you will often add metrics like averages, mins, maxes, etc. Metrics are defined\non a per-field basis and for each field you configure which metric should be collected.').optional(),
        page_size: z.number().describe('The number of bucket results that are processed on each iteration of the rollup indexer. A larger value tends\nto execute faster, but requires more memory during processing. This value has no effect on how the data is\nrolled up; it is merely used for tweaking the speed or memory cost of the indexer.'),
        rollup_index: types_index_name,
        timeout: types_duration.optional(),
        headers: types_http_headers.optional()
    }),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const rollup_put_job_response = types_acknowledged_response_base;

export const rollup_get_jobs1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const rollup_get_jobs1_response = z.object({
    jobs: z.array(rollup_get_jobs_rollup_job)
});

export const rollup_get_rollup_caps_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const rollup_get_rollup_caps_response = z.record(rollup_get_rollup_caps_rollup_capabilities);

export const rollup_get_rollup_caps1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const rollup_get_rollup_caps1_response = z.record(rollup_get_rollup_caps_rollup_capabilities);

export const rollup_get_rollup_index_caps_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_ids
    }),
    query: z.never().optional()
});

export const rollup_get_rollup_index_caps_response = z.record(rollup_get_rollup_index_caps_index_capabilities);

export const rollup_start_job_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const rollup_start_job_response = z.object({
    started: z.boolean()
});

export const rollup_stop_job_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional(),
        wait_for_completion: z.boolean().describe('If set to `true`, causes the API to block until the indexer state completely stops.\nIf set to `false`, the API returns immediately and the indexer is stopped asynchronously in the background.').optional()
    }).optional()
});

export const rollup_stop_job_response = z.object({
    stopped: z.boolean()
});

export const search_application_delete_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.never().optional()
});

export const search_application_delete_response = types_acknowledged_response_base;

export const search_application_delete_behavioral_analytics_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.never().optional()
});

export const search_application_delete_behavioral_analytics_response = types_acknowledged_response_base;

export const search_application_get_behavioral_analytics1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: z.array(types_name).describe('A list of analytics collections to limit the returned information')
    }),
    query: z.never().optional()
});

export const search_application_get_behavioral_analytics1_response = z.record(search_application_types_analytics_collection);

export const search_application_put_behavioral_analytics_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.never().optional()
});

export const search_application_put_behavioral_analytics_response = search_application_put_behavioral_analytics_analytics_acknowledge_response_base;

export const search_application_get_behavioral_analytics_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const search_application_get_behavioral_analytics_response = z.record(search_application_types_analytics_collection);

export const search_application_post_behavioral_analytics_event_request = z.object({
    body: z.record(z.unknown()),
    path: z.object({
        collection_name: types_name,
        event_type: search_application_types_event_type
    }),
    query: z.object({
        debug: z.boolean().describe('Whether the response type has to include more details').optional()
    }).optional()
});

export const search_application_post_behavioral_analytics_event_response = z.object({
    accepted: z.boolean(),
    event: z.record(z.unknown()).optional()
});

export const search_application_render_query_request = z.object({
    body: z.object({
        params: z.record(z.record(z.unknown())).optional()
    }).optional(),
    path: z.object({
        name: types_name
    }),
    query: z.never().optional()
});

export const search_application_render_query_response = z.record(z.unknown());

export const searchable_snapshots_cache_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const searchable_snapshots_cache_stats_response = z.object({
    nodes: z.record(searchable_snapshots_cache_stats_node)
});

export const searchable_snapshots_cache_stats1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const searchable_snapshots_cache_stats1_response = z.object({
    nodes: z.record(searchable_snapshots_cache_stats_node)
});

export const searchable_snapshots_clear_cache_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional()
    }).optional()
});

export const searchable_snapshots_clear_cache_response = z.record(z.unknown());

export const searchable_snapshots_clear_cache1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional()
    }).optional()
});

export const searchable_snapshots_clear_cache1_response = z.record(z.unknown());

export const searchable_snapshots_mount_request = z.object({
    body: z.object({
        index: types_index_name,
        renamed_index: types_index_name.optional(),
        index_settings: z.record(z.record(z.unknown())).describe('The settings that should be added to the index when it is mounted.').optional(),
        ignore_index_settings: z.array(z.string()).describe('The names of settings that should be removed from the index when it is mounted.').optional()
    }),
    path: z.object({
        repository: types_name,
        snapshot: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        wait_for_completion: z.boolean().describe('If true, the request blocks until the operation is complete.').optional(),
        storage: z.string().describe('The mount option for the searchable snapshot index.').optional()
    }).optional()
});

export const searchable_snapshots_mount_response = z.object({
    snapshot: searchable_snapshots_mount_mounted_snapshot
});

export const searchable_snapshots_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        level: searchable_snapshots_types_stats_level.optional()
    }).optional()
});

export const searchable_snapshots_stats_response = z.object({
    stats: z.record(z.unknown()),
    total: z.record(z.unknown())
});

export const searchable_snapshots_stats1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        level: searchable_snapshots_types_stats_level.optional()
    }).optional()
});

export const searchable_snapshots_stats1_response = z.object({
    stats: z.record(z.unknown()),
    total: z.record(z.unknown())
});

export const security_activate_user_profile_request = z.object({
    body: z.object({
        access_token: z.string().describe('The user\'s Elasticsearch access token or JWT.\nBoth `access` and `id` JWT token types are supported and they depend on the underlying JWT realm configuration.\nIf you specify the `access_token` grant type, this parameter is required.\nIt is not valid with other grant types.').optional(),
        grant_type: security_types_grant_type,
        password: z.string().describe('The user\'s password.\nIf you specify the `password` grant type, this parameter is required.\nIt is not valid with other grant types.').optional(),
        username: z.string().describe('The username that identifies the user.\nIf you specify the `password` grant type, this parameter is required.\nIt is not valid with other grant types.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_activate_user_profile_response = security_types_user_profile_with_metadata;

export const security_authenticate_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_authenticate_response = z.object({
    api_key: security_authenticate_authenticate_api_key.optional(),
    authentication_realm: security_types_realm_info,
    email: z.union([
        z.string(),
        z.null()
    ]).optional(),
    full_name: z.union([
        types_name,
        z.string(),
        z.null()
    ]).optional(),
    lookup_realm: security_types_realm_info,
    metadata: types_metadata,
    roles: z.array(z.string()),
    username: types_username,
    enabled: z.boolean(),
    authentication_type: z.string(),
    token: security_authenticate_token.optional()
});

export const security_bulk_delete_role_request = z.object({
    body: z.object({
        names: z.array(z.string()).describe('An array of role names to delete')
    }),
    path: z.never().optional(),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_bulk_delete_role_response = z.object({
    deleted: z.array(z.string()).describe('Array of deleted roles').optional(),
    not_found: z.array(z.string()).describe('Array of roles that could not be found').optional(),
    errors: security_types_bulk_error.optional()
});

export const security_change_password1_request = z.object({
    body: security_change_password,
    path: z.object({
        username: types_username
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_change_password1_response = z.record(z.unknown());

export const security_change_password_request = z.object({
    body: security_change_password,
    path: z.object({
        username: types_username
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_change_password_response = z.record(z.unknown());

export const security_change_password3_request = z.object({
    body: security_change_password,
    path: z.never().optional(),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_change_password3_response = z.record(z.unknown());

export const security_change_password2_request = z.object({
    body: security_change_password,
    path: z.never().optional(),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_change_password2_response = z.record(z.unknown());

export const security_clear_api_key_cache_request = z.object({
    body: z.never().optional(),
    path: z.object({
        ids: types_ids
    }),
    query: z.never().optional()
});

export const security_clear_api_key_cache_response = z.object({
    _nodes: types_node_statistics,
    cluster_name: types_name,
    nodes: z.record(security_types_cluster_node)
});

export const security_clear_cached_privileges_request = z.object({
    body: z.never().optional(),
    path: z.object({
        application: types_names
    }),
    query: z.never().optional()
});

export const security_clear_cached_privileges_response = z.object({
    _nodes: types_node_statistics,
    cluster_name: types_name,
    nodes: z.record(security_types_cluster_node)
});

export const security_clear_cached_realms_request = z.object({
    body: z.never().optional(),
    path: z.object({
        realms: types_names
    }),
    query: z.object({
        usernames: z.array(z.string()).describe('A comma-separated list of the users to clear from the cache.\nIf you do not specify this parameter, the API evicts all users from the user cache.').optional()
    }).optional()
});

export const security_clear_cached_realms_response = z.object({
    _nodes: types_node_statistics,
    cluster_name: types_name,
    nodes: z.record(security_types_cluster_node)
});

export const security_clear_cached_roles_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.never().optional()
});

export const security_clear_cached_roles_response = z.object({
    _nodes: types_node_statistics,
    cluster_name: types_name,
    nodes: z.record(security_types_cluster_node)
});

export const security_clear_cached_service_tokens_request = z.object({
    body: z.never().optional(),
    path: z.object({
        namespace: types_namespace,
        service: types_service,
        name: types_names
    }),
    query: z.never().optional()
});

export const security_clear_cached_service_tokens_response = z.object({
    _nodes: types_node_statistics,
    cluster_name: types_name,
    nodes: z.record(security_types_cluster_node)
});

export const security_invalidate_api_key_request = z.object({
    body: z.object({
        id: types_id.optional(),
        ids: z.array(types_id).describe('A list of API key ids.\nThis parameter cannot be used with any of `name`, `realm_name`, or `username`.').optional(),
        name: types_name.optional(),
        owner: z.boolean().describe('Query API keys owned by the currently authenticated user.\nThe `realm_name` or `username` parameters cannot be specified when this parameter is set to `true` as they are assumed to be the currently authenticated ones.\n\nNOTE: At least one of `ids`, `name`, `username`, and `realm_name` must be specified if `owner` is `false`.').optional().default(false),
        realm_name: z.string().describe('The name of an authentication realm.\nThis parameter cannot be used with either `ids` or `name`, or when `owner` flag is set to `true`.').optional(),
        username: types_username.optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_invalidate_api_key_response = z.object({
    error_count: z.number().describe('The number of errors that were encountered when invalidating the API keys.'),
    error_details: z.array(types_error_cause).describe('Details about the errors.\nThis field is not present in the response when `error_count` is `0`.').optional(),
    invalidated_api_keys: z.array(z.string()).describe('The IDs of the API keys that were invalidated as part of this request.'),
    previously_invalidated_api_keys: z.array(z.string()).describe('The IDs of the API keys that were already invalidated.')
});

export const security_delete_service_token_request = z.object({
    body: z.never().optional(),
    path: z.object({
        namespace: types_namespace,
        service: types_service,
        name: types_name
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_delete_service_token_response = z.object({
    found: z.boolean().describe('If the service account token is successfully deleted, the request returns `{"found": true}`.\nOtherwise, the response will have status code 404 and `found` is set to `false`.')
});

export const security_create_service_token1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        namespace: types_namespace,
        service: types_service,
        name: types_name
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_create_service_token1_response = z.object({
    created: z.boolean(),
    token: security_create_service_token_token
});

export const security_create_service_token_request = z.object({
    body: z.never().optional(),
    path: z.object({
        namespace: types_namespace,
        service: types_service,
        name: types_name
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_create_service_token_response = z.object({
    created: z.boolean(),
    token: security_create_service_token_token
});

export const security_create_service_token2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        namespace: types_namespace,
        service: types_service
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_create_service_token2_response = z.object({
    created: z.boolean(),
    token: security_create_service_token_token
});

export const security_delegate_pki_request = z.object({
    body: z.object({
        x509_certificate_chain: z.array(z.string()).describe('The X509Certificate chain, which is represented as an ordered string array.\nEach string in the array is a base64-encoded (Section 4 of RFC4648 - not base64url-encoded) of the certificate\'s DER encoding.\n\nThe first element is the target certificate that contains the subject distinguished name that is requesting access.\nThis may be followed by additional certificates; each subsequent certificate is used to certify the previous one.')
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_delegate_pki_response = z.object({
    access_token: z.string().describe('An access token associated with the subject distinguished name of the client\'s certificate.'),
    expires_in: z.number().describe('The amount of time (in seconds) before the token expires.'),
    type: z.string().describe('The type of token.'),
    authentication: security_delegate_pki_authentication.optional()
});

export const security_delete_privileges_request = z.object({
    body: z.never().optional(),
    path: z.object({
        application: types_name,
        name: types_names
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_delete_privileges_response = z.record(z.record(security_delete_privileges_found_status));

export const security_get_privileges2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        application: types_name,
        name: types_names
    }),
    query: z.never().optional()
});

export const security_get_privileges2_response = z.record(z.record(security_put_privileges_actions));

export const security_delete_role_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_delete_role_response = z.object({
    found: z.boolean().describe('If the role is successfully deleted, `found` is `true`.\nOtherwise, `found` is `false`.')
});

export const security_delete_role_mapping_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_delete_role_mapping_response = z.object({
    found: z.boolean().describe('If the mapping is successfully deleted, `found` is `true`.\nOtherwise, `found` is `false`.')
});

export const security_delete_user_request = z.object({
    body: z.never().optional(),
    path: z.object({
        username: types_username
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_delete_user_response = z.object({
    found: z.boolean().describe('If the user is successfully deleted, the request returns `{"found": true}`.\nOtherwise, `found` is set to `false`.')
});

export const security_get_user_request = z.object({
    body: z.never().optional(),
    path: z.object({
        username: z.union([
            types_username,
            z.array(types_username)
        ])
    }),
    query: z.object({
        with_profile_uid: z.boolean().describe('Determines whether to retrieve the user profile UID, if it exists, for the users.').optional()
    }).optional()
});

export const security_get_user_response = z.record(security_types_user);

export const security_put_user1_request = z.object({
    body: security_put_user,
    path: z.object({
        username: types_username
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_put_user1_response = z.object({
    created: z.boolean().describe('A successful call returns a JSON structure that shows whether the user has been created or updated.\nWhen an existing user is updated, `created` is set to `false`.')
});

export const security_put_user_request = z.object({
    body: security_put_user,
    path: z.object({
        username: types_username
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_put_user_response = z.object({
    created: z.boolean().describe('A successful call returns a JSON structure that shows whether the user has been created or updated.\nWhen an existing user is updated, `created` is set to `false`.')
});

export const security_disable_user1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        username: types_username
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_disable_user1_response = z.record(z.unknown());

export const security_disable_user_request = z.object({
    body: z.never().optional(),
    path: z.object({
        username: types_username
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_disable_user_response = z.record(z.unknown());

export const security_disable_user_profile1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        uid: security_types_user_profile_id
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_disable_user_profile1_response = types_acknowledged_response_base;

export const security_disable_user_profile_request = z.object({
    body: z.never().optional(),
    path: z.object({
        uid: security_types_user_profile_id
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_disable_user_profile_response = types_acknowledged_response_base;

export const security_enable_user1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        username: types_username
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_enable_user1_response = z.record(z.unknown());

export const security_enable_user_request = z.object({
    body: z.never().optional(),
    path: z.object({
        username: types_username
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_enable_user_response = z.record(z.unknown());

export const security_enable_user_profile1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        uid: security_types_user_profile_id
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_enable_user_profile1_response = types_acknowledged_response_base;

export const security_enable_user_profile_request = z.object({
    body: z.never().optional(),
    path: z.object({
        uid: security_types_user_profile_id
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_enable_user_profile_response = types_acknowledged_response_base;

export const security_enroll_kibana_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_enroll_kibana_response = z.object({
    token: security_enroll_kibana_token,
    http_ca: z.string().describe('The CA certificate used to sign the node certificates that Elasticsearch uses for TLS on the HTTP layer.\nThe certificate is returned as a Base64 encoded string of the ASN.1 DER encoding of the certificate.')
});

export const security_enroll_node_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_enroll_node_response = z.object({
    http_ca_key: z.string().describe('The CA private key that can be used by the new node in order to sign its certificate for the HTTP layer, as a Base64 encoded string of the ASN.1 DER encoding of the key.'),
    http_ca_cert: z.string().describe('The CA certificate that can be used by the new node in order to sign its certificate for the HTTP layer, as a Base64 encoded string of the ASN.1 DER encoding of the certificate.'),
    transport_ca_cert: z.string().describe('The CA certificate that is used to sign the TLS certificate for the transport layer, as a Base64 encoded string of the ASN.1 DER encoding of the certificate.'),
    transport_key: z.string().describe('The private key that the node can use for TLS for its transport layer, as a Base64 encoded string of the ASN.1 DER encoding of the key.'),
    transport_cert: z.string().describe('The certificate that the node can use for TLS for its transport layer, as a Base64 encoded string of the ASN.1 DER encoding of the certificate.'),
    nodes_addresses: z.array(z.string()).describe('A list of transport addresses in the form of `host:port` for the nodes that are already members of the cluster.')
});

export const security_get_builtin_privileges_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_get_builtin_privileges_response = z.object({
    cluster: z.array(security_types_cluster_privilege).describe('The list of cluster privileges that are understood by this version of Elasticsearch.'),
    index: z.array(types_index_name).describe('The list of index privileges that are understood by this version of Elasticsearch.'),
    remote_cluster: z.array(security_types_remote_cluster_privilege).describe('The list of remote_cluster privileges that are understood by this version of Elasticsearch.')
});

export const security_get_privileges_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_get_privileges_response = z.record(z.record(security_put_privileges_actions));

export const security_put_privileges1_request = z.object({
    body: security_put_privileges,
    path: z.never().optional(),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_put_privileges1_response = z.record(z.record(security_types_created_status));

export const security_put_privileges_request = z.object({
    body: security_put_privileges,
    path: z.never().optional(),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_put_privileges_response = z.record(z.record(security_types_created_status));

export const security_get_privileges1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        application: types_name
    }),
    query: z.never().optional()
});

export const security_get_privileges1_response = z.record(z.record(security_put_privileges_actions));

export const security_get_service_credentials_request = z.object({
    body: z.never().optional(),
    path: z.object({
        namespace: types_namespace,
        service: types_name
    }),
    query: z.never().optional()
});

export const security_get_service_credentials_response = z.object({
    service_account: z.string(),
    count: z.number(),
    tokens: z.record(types_metadata),
    nodes_credentials: security_get_service_credentials_nodes_credentials
});

export const security_get_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_get_stats_response = z.object({
    nodes: z.record(security_types_node_security_stats).describe('A map of node IDs to security statistics for that node.')
});

export const security_invalidate_token_request = z.object({
    body: z.object({
        token: z.string().describe('An access token.\nThis parameter cannot be used if any of `refresh_token`, `realm_name`, or `username` are used.').optional(),
        refresh_token: z.string().describe('A refresh token.\nThis parameter cannot be used if any of `refresh_token`, `realm_name`, or `username` are used.').optional(),
        realm_name: types_name.optional(),
        username: types_username.optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_invalidate_token_response = z.object({
    error_count: z.number().describe('The number of errors that were encountered when invalidating the tokens.'),
    error_details: z.array(types_error_cause).describe('Details about the errors.\nThis field is not present in the response when `error_count` is `0`.').optional(),
    invalidated_tokens: z.number().describe('The number of the tokens that were invalidated as part of this request.'),
    previously_invalidated_tokens: z.number().describe('The number of tokens that were already invalidated.')
});

export const security_get_token_request = z.object({
    body: z.object({
        grant_type: security_get_token_access_token_grant_type.optional(),
        scope: z.string().describe('The scope of the token.\nCurrently tokens are only issued for a scope of FULL regardless of the value sent with the request.').optional(),
        password: types_password.optional(),
        kerberos_ticket: z.string().describe('The base64 encoded kerberos ticket.\nIf you specify the `_kerberos` grant type, this parameter is required.\nThis parameter is not valid with any other supported grant type.').optional(),
        refresh_token: z.string().describe('The string that was returned when you created the token, which enables you to extend its life.\nIf you specify the `refresh_token` grant type, this parameter is required.\nThis parameter is not valid with any other supported grant type.').optional(),
        username: types_username.optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_get_token_response = z.object({
    access_token: z.string(),
    expires_in: z.number(),
    scope: z.string().optional(),
    type: z.string(),
    refresh_token: z.string().optional(),
    kerberos_authentication_response_token: z.string().optional(),
    authentication: security_get_token_authenticated_user
});

export const security_get_user1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        with_profile_uid: z.boolean().describe('Determines whether to retrieve the user profile UID, if it exists, for the users.').optional()
    }).optional()
});

export const security_get_user1_response = z.record(security_types_user);

export const security_get_user_profile_request = z.object({
    body: z.never().optional(),
    path: z.object({
        uid: z.union([
            security_types_user_profile_id,
            z.array(security_types_user_profile_id)
        ])
    }),
    query: z.object({
        data: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const security_get_user_profile_response = z.object({
    profiles: z.array(security_types_user_profile_with_metadata).describe('A successful call returns the JSON representation of the user profile and its internal versioning numbers.\nThe API returns an empty object if no profile document is found for the provided `uid`.\nThe content of the data field is not returned by default to avoid deserializing a potential large payload.'),
    errors: security_get_user_profile_get_user_profile_errors.optional()
});

export const security_has_privileges_request = z.object({
    body: security_has_privileges,
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_has_privileges_response = z.object({
    application: security_has_privileges_applications_privileges,
    cluster: z.record(z.boolean()),
    has_all_requested: z.boolean(),
    index: z.record(security_has_privileges_privileges),
    username: types_username
});

export const security_has_privileges1_request = z.object({
    body: security_has_privileges,
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_has_privileges1_response = z.object({
    application: security_has_privileges_applications_privileges,
    cluster: z.record(z.boolean()),
    has_all_requested: z.boolean(),
    index: z.record(security_has_privileges_privileges),
    username: types_username
});

export const security_has_privileges2_request = z.object({
    body: security_has_privileges,
    path: z.object({
        user: types_name
    }),
    query: z.never().optional()
});

export const security_has_privileges2_response = z.object({
    application: security_has_privileges_applications_privileges,
    cluster: z.record(z.boolean()),
    has_all_requested: z.boolean(),
    index: z.record(security_has_privileges_privileges),
    username: types_username
});

export const security_has_privileges3_request = z.object({
    body: security_has_privileges,
    path: z.object({
        user: types_name
    }),
    query: z.never().optional()
});

export const security_has_privileges3_response = z.object({
    application: security_has_privileges_applications_privileges,
    cluster: z.record(z.boolean()),
    has_all_requested: z.boolean(),
    index: z.record(security_has_privileges_privileges),
    username: types_username
});

export const security_has_privileges_user_profile_request = z.object({
    body: security_has_privileges_user_profile,
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_has_privileges_user_profile_response = z.object({
    has_privilege_uids: z.array(security_types_user_profile_id).describe('The subset of the requested profile IDs of the users that\nhave all the requested privileges.'),
    errors: security_has_privileges_user_profile_has_privileges_user_profile_errors.optional()
});

export const security_has_privileges_user_profile1_request = z.object({
    body: security_has_privileges_user_profile,
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_has_privileges_user_profile1_response = z.object({
    has_privilege_uids: z.array(security_types_user_profile_id).describe('The subset of the requested profile IDs of the users that\nhave all the requested privileges.'),
    errors: security_has_privileges_user_profile_has_privileges_user_profile_errors.optional()
});

export const security_oidc_authenticate_request = z.object({
    body: z.object({
        nonce: z.string().describe('Associate a client session with an ID token and mitigate replay attacks.\nThis value needs to be the same as the one that was provided to the `/_security/oidc/prepare` API or the one that was generated by Elasticsearch and included in the response to that call.'),
        realm: z.string().describe('The name of the OpenID Connect realm.\nThis property is useful in cases where multiple realms are defined.').optional(),
        redirect_uri: z.string().describe('The URL to which the OpenID Connect Provider redirected the User Agent in response to an authentication request after a successful authentication.\nThis URL must be provided as-is (URL encoded), taken from the body of the response or as the value of a location header in the response from the OpenID Connect Provider.'),
        state: z.string().describe('Maintain state between the authentication request and the response.\nThis value needs to be the same as the one that was provided to the `/_security/oidc/prepare` API or the one that was generated by Elasticsearch and included in the response to that call.')
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_oidc_authenticate_response = z.object({
    access_token: z.string().describe('The Elasticsearch access token.'),
    expires_in: z.number().describe('The duration (in seconds) of the tokens.'),
    refresh_token: z.string().describe('The Elasticsearch refresh token.'),
    type: z.string().describe('The type of token.')
});

export const security_oidc_logout_request = z.object({
    body: z.object({
        token: z.string().describe('The access token to be invalidated.'),
        refresh_token: z.string().describe('The refresh token to be invalidated.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_oidc_logout_response = z.object({
    redirect: z.string().describe('A URI that points to the end session endpoint of the OpenID Connect Provider with all the parameters of the logout request as HTTP GET parameters.')
});

export const security_oidc_prepare_authentication_request = z.object({
    body: z.object({
        iss: z.string().describe('In the case of a third party initiated single sign on, this is the issuer identifier for the OP that the RP is to send the authentication request to.\nIt cannot be specified when *realm* is specified.\nOne of *realm* or *iss* is required.').optional(),
        login_hint: z.string().describe('In the case of a third party initiated single sign on, it is a string value that is included in the authentication request as the *login_hint* parameter.\nThis parameter is not valid when *realm* is specified.').optional(),
        nonce: z.string().describe('The value used to associate a client session with an ID token and to mitigate replay attacks.\nIf the caller of the API does not provide a value, Elasticsearch will generate one with sufficient entropy and return it in the response.').optional(),
        realm: z.string().describe('The name of the OpenID Connect realm in Elasticsearch the configuration of which should be used in order to generate the authentication request.\nIt cannot be specified when *iss* is specified.\nOne of *realm* or *iss* is required.').optional(),
        state: z.string().describe('The value used to maintain state between the authentication request and the response, typically used as a Cross-Site Request Forgery mitigation.\nIf the caller of the API does not provide a value, Elasticsearch will generate one with sufficient entropy and return it in the response.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_oidc_prepare_authentication_response = z.object({
    nonce: z.string(),
    realm: z.string(),
    redirect: z.string().describe('A URI that points to the authorization endpoint of the OpenID Connect Provider with all the parameters of the authentication request as HTTP GET parameters.'),
    state: z.string()
});

export const security_saml_authenticate_request = z.object({
    body: z.object({
        content: z.string().describe('The SAML response as it was sent by the user\'s browser, usually a Base64 encoded XML document.'),
        ids: types_ids,
        realm: z.string().describe('The name of the realm that should authenticate the SAML response. Useful in cases where many SAML realms are defined.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_saml_authenticate_response = z.object({
    access_token: z.string().describe('The access token that was generated by Elasticsearch.'),
    username: z.string().describe('The authenticated user\'s name.'),
    expires_in: z.number().describe('The amount of time (in seconds) left until the token expires.'),
    refresh_token: z.string().describe('The refresh token that was generated by Elasticsearch.'),
    realm: z.string().describe('The name of the realm where the user was authenticated.')
});

export const security_saml_complete_logout_request = z.object({
    body: z.object({
        realm: z.string().describe('The name of the SAML realm in Elasticsearch for which the configuration is used to verify the logout response.'),
        ids: types_ids,
        query_string: z.string().describe('If the SAML IdP sends the logout response with the HTTP-Redirect binding, this field must be set to the query string of the redirect URI.').optional(),
        content: z.string().describe('If the SAML IdP sends the logout response with the HTTP-Post binding, this field must be set to the value of the SAMLResponse form parameter from the logout response.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_saml_invalidate_request = z.object({
    body: z.object({
        acs: z.string().describe('The Assertion Consumer Service URL that matches the one of the SAML realm in Elasticsearch that should be used. You must specify either this parameter or the `realm` parameter.').optional(),
        query_string: z.string().describe('The query part of the URL that the user was redirected to by the SAML IdP to initiate the Single Logout.\nThis query should include a single parameter named `SAMLRequest` that contains a SAML logout request that is deflated and Base64 encoded.\nIf the SAML IdP has signed the logout request, the URL should include two extra parameters named `SigAlg` and `Signature` that contain the algorithm used for the signature and the signature value itself.\nIn order for Elasticsearch to be able to verify the IdP\'s signature, the value of the `query_string` field must be an exact match to the string provided by the browser.\nThe client application must not attempt to parse or process the string in any way.'),
        realm: z.string().describe('The name of the SAML realm in Elasticsearch the configuration. You must specify either this parameter or the `acs` parameter.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_saml_invalidate_response = z.object({
    invalidated: z.number().describe('The number of tokens that were invalidated as part of this logout.'),
    realm: z.string().describe('The realm name of the SAML realm in Elasticsearch that authenticated the user.'),
    redirect: z.string().describe('A SAML logout response as a parameter so that the user can be redirected back to the SAML IdP.')
});

export const security_saml_logout_request = z.object({
    body: z.object({
        token: z.string().describe('The access token that was returned as a response to calling the SAML authenticate API.\nAlternatively, the most recent token that was received after refreshing the original one by using a `refresh_token`.'),
        refresh_token: z.string().describe('The refresh token that was returned as a response to calling the SAML authenticate API.\nAlternatively, the most recent refresh token that was received after refreshing the original access token.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_saml_logout_response = z.object({
    redirect: z.string().describe('A URL that contains a SAML logout request as a parameter.\nYou can use this URL to be redirected back to the SAML IdP and to initiate Single Logout.')
});

export const security_saml_prepare_authentication_request = z.object({
    body: z.object({
        acs: z.string().describe('The Assertion Consumer Service URL that matches the one of the SAML realms in Elasticsearch.\nThe realm is used to generate the authentication request. You must specify either this parameter or the `realm` parameter.').optional(),
        realm: z.string().describe('The name of the SAML realm in Elasticsearch for which the configuration is used to generate the authentication request.\nYou must specify either this parameter or the `acs` parameter.').optional(),
        relay_state: z.string().describe('A string that will be included in the redirect URL that this API returns as the `RelayState` query parameter.\nIf the Authentication Request is signed, this value is used as part of the signature computation.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_saml_prepare_authentication_response = z.object({
    id: types_id,
    realm: z.string().describe('The name of the Elasticsearch realm that was used to construct the authentication request.'),
    redirect: z.string().describe('The URL to redirect the user to.')
});

export const security_saml_service_provider_metadata_request = z.object({
    body: z.never().optional(),
    path: z.object({
        realm_name: types_name
    }),
    query: z.never().optional()
});

export const security_saml_service_provider_metadata_response = z.object({
    metadata: z.string().describe('An XML string that contains a SAML Service Provider\'s metadata for the realm.')
});

export const security_suggest_user_profiles_request = z.object({
    body: security_suggest_user_profiles.optional(),
    path: z.never().optional(),
    query: z.object({
        data: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const security_suggest_user_profiles_response = z.object({
    total: security_suggest_user_profiles_total_user_profiles,
    took: z.number().describe('The number of milliseconds it took Elasticsearch to run the request.'),
    profiles: z.array(security_types_user_profile).describe('A list of profile documents, ordered by relevance, that match the search criteria.')
});

export const security_suggest_user_profiles1_request = z.object({
    body: security_suggest_user_profiles.optional(),
    path: z.never().optional(),
    query: z.object({
        data: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const security_suggest_user_profiles1_response = z.object({
    total: security_suggest_user_profiles_total_user_profiles,
    took: z.number().describe('The number of milliseconds it took Elasticsearch to run the request.'),
    profiles: z.array(security_types_user_profile).describe('A list of profile documents, ordered by relevance, that match the search criteria.')
});

export const security_update_user_profile_data1_request = z.object({
    body: security_update_user_profile_data,
    path: z.object({
        uid: security_types_user_profile_id
    }),
    query: z.object({
        if_seq_no: types_sequence_number.optional(),
        if_primary_term: z.number().describe('Only perform the operation if the document has this primary term.').optional(),
        refresh: types_refresh.optional()
    }).optional()
});

export const security_update_user_profile_data1_response = types_acknowledged_response_base;

export const security_update_user_profile_data_request = z.object({
    body: security_update_user_profile_data,
    path: z.object({
        uid: security_types_user_profile_id
    }),
    query: z.object({
        if_seq_no: types_sequence_number.optional(),
        if_primary_term: z.number().describe('Only perform the operation if the document has this primary term.').optional(),
        refresh: types_refresh.optional()
    }).optional()
});

export const security_update_user_profile_data_response = types_acknowledged_response_base;

export const slm_delete_lifecycle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        policy_id: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const slm_delete_lifecycle_response = types_acknowledged_response_base;

export const slm_get_lifecycle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        policy_id: types_names
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const slm_get_lifecycle_response = z.record(slm_types_snapshot_lifecycle);

export const slm_put_lifecycle_request = z.object({
    body: z.object({
        config: slm_types_configuration.optional(),
        name: types_name.optional(),
        repository: z.string().describe('Repository used to store snapshots created by this policy. This repository must exist prior to the policys creation. You can create a repository using the snapshot repository API.').optional(),
        retention: slm_types_retention.optional(),
        schedule: watcher_types_cron_expression.optional()
    }),
    path: z.object({
        policy_id: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const slm_put_lifecycle_response = types_acknowledged_response_base;

export const slm_execute_lifecycle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        policy_id: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const slm_execute_lifecycle_response = z.object({
    snapshot_name: types_name
});

export const slm_execute_retention_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const slm_execute_retention_response = types_acknowledged_response_base;

export const slm_get_lifecycle1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const slm_get_lifecycle1_response = z.record(slm_types_snapshot_lifecycle);

export const slm_get_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const slm_get_stats_response = z.object({
    retention_deletion_time: types_duration,
    retention_deletion_time_millis: types_duration_value_unit_millis,
    retention_failed: z.number(),
    retention_runs: z.number(),
    retention_timed_out: z.number(),
    total_snapshots_deleted: z.number(),
    total_snapshot_deletion_failures: z.number(),
    total_snapshots_failed: z.number(),
    total_snapshots_taken: z.number(),
    policy_stats: z.array(slm_types_snapshot_policy_stats)
});

export const slm_get_status_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const slm_get_status_response = z.object({
    operation_mode: types_lifecycle_operation_mode
});

export const slm_start_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const slm_start_response = types_acknowledged_response_base;

export const slm_stop_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const slm_stop_response = types_acknowledged_response_base;

export const snapshot_cleanup_repository_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const snapshot_cleanup_repository_response = z.object({
    results: snapshot_cleanup_repository_cleanup_repository_results
});

export const snapshot_clone_request = z.object({
    body: z.object({
        indices: z.string().describe('A comma-separated list of indices to include in the snapshot.\nMulti-target syntax is supported.')
    }),
    path: z.object({
        repository: types_name,
        snapshot: types_name,
        target_snapshot: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const snapshot_clone_response = types_acknowledged_response_base;

export const snapshot_delete_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_name,
        snapshot: types_names
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request returns a response when the matching snapshots are all deleted.\nIf `false`, the request returns a response as soon as the deletes are scheduled.').optional()
    }).optional()
});

export const snapshot_delete_response = types_acknowledged_response_base;

export const snapshot_get_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_name,
        snapshot: types_names
    }),
    query: z.object({
        after: z.string().describe('An offset identifier to start pagination from as returned by the next field in the response body.').optional(),
        from_sort_value: z.string().describe('The value of the current sort column at which to start retrieval.\nIt can be a string `snapshot-` or a repository name when sorting by snapshot or repository name.\nIt can be a millisecond time value or a number when sorting by `index-` or shard count.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error for any snapshots that are unavailable.').optional(),
        index_details: z.boolean().describe('If `true`, the response includes additional information about each index in the snapshot comprising the number of shards in the index, the total size of the index in bytes, and the maximum number of segments per shard in the index.\nThe default is `false`, meaning that this information is omitted.').optional(),
        index_names: z.boolean().describe('If `true`, the response includes the name of each index in each snapshot.').optional(),
        include_repository: z.boolean().describe('If `true`, the response includes the repository name in each snapshot.').optional(),
        master_timeout: types_duration.optional(),
        order: types_sort_order.optional(),
        offset: z.number().describe('Numeric offset to start pagination from based on the snapshots matching this request. Using a non-zero value for this parameter is mutually exclusive with using the after parameter. Defaults to 0.').optional(),
        size: z.number().describe('The maximum number of snapshots to return.\nThe default is 0, which means to return all that match the request without limit.').optional(),
        slm_policy_filter: types_name.optional(),
        sort: snapshot_types_snapshot_sort.optional(),
        state: z.union([
            snapshot_types_snapshot_state,
            z.array(snapshot_types_snapshot_state)
        ]).optional(),
        verbose: z.boolean().describe('If `true`, returns additional information about each snapshot such as the version of Elasticsearch which took the snapshot, the start and end times of the snapshot, and the number of shards snapshotted.\n\nNOTE: The parameters `size`, `order`, `after`, `from_sort_value`, `offset`, `slm_policy_filter`, and `sort` are not supported when you set `verbose=false` and the sort order for requests with `verbose=false` is undefined.').optional()
    }).optional()
});

export const snapshot_get_response = z.object({
    remaining: z.number().describe('The number of remaining snapshots that were not returned due to size limits and that can be fetched by additional requests using the `next` field value.'),
    total: z.number().describe('The total number of snapshots that match the request when ignoring the size limit or `after` query parameter.'),
    next: z.string().describe('If the request contained a size limit and there might be more results, a `next` field will be added to the response.\nIt can be used as the `after` query parameter to fetch additional results.').optional(),
    responses: z.array(snapshot_get_snapshot_response_item).optional(),
    snapshots: z.array(snapshot_types_snapshot_info).optional()
});

export const snapshot_create1_request = z.object({
    body: snapshot_create.optional(),
    path: z.object({
        repository: types_name,
        snapshot: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request returns a response when the snapshot is complete.\nIf `false`, the request returns a response when the snapshot initializes.').optional()
    }).optional()
});

export const snapshot_create1_response = z.object({
    accepted: z.boolean().describe('Equals `true` if the snapshot was accepted. Present when the request had `wait_for_completion` set to `false`').optional(),
    snapshot: snapshot_types_snapshot_info.optional()
});

export const snapshot_create_request = z.object({
    body: snapshot_create.optional(),
    path: z.object({
        repository: types_name,
        snapshot: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request returns a response when the snapshot is complete.\nIf `false`, the request returns a response when the snapshot initializes.').optional()
    }).optional()
});

export const snapshot_create_response = z.object({
    accepted: z.boolean().describe('Equals `true` if the snapshot was accepted. Present when the request had `wait_for_completion` set to `false`').optional(),
    snapshot: snapshot_types_snapshot_info.optional()
});

export const snapshot_delete_repository_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_names
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const snapshot_delete_repository_response = types_acknowledged_response_base;

export const snapshot_get_repository1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_names
    }),
    query: z.object({
        local: z.boolean().describe('If `true`, the request gets information from the local node only.\nIf `false`, the request gets information from the master node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const snapshot_get_repository1_response = z.record(snapshot_types_repository);

export const snapshot_create_repository1_request = z.object({
    body: snapshot_create_repository2,
    path: z.object({
        repository: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        verify: z.boolean().describe('If `true`, the request verifies the repository is functional on all master and data nodes in the cluster.\nIf `false`, this verification is skipped.\nYou can also perform this verification with the verify snapshot repository API.').optional()
    }).optional()
});

export const snapshot_create_repository1_response = types_acknowledged_response_base;

export const snapshot_create_repository_request = z.object({
    body: snapshot_create_repository2,
    path: z.object({
        repository: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        verify: z.boolean().describe('If `true`, the request verifies the repository is functional on all master and data nodes in the cluster.\nIf `false`, this verification is skipped.\nYou can also perform this verification with the verify snapshot repository API.').optional()
    }).optional()
});

export const snapshot_create_repository_response = types_acknowledged_response_base;

export const snapshot_get_repository_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        local: z.boolean().describe('If `true`, the request gets information from the local node only.\nIf `false`, the request gets information from the master node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const snapshot_get_repository_response = z.record(snapshot_types_repository);

export const snapshot_repository_analyze_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_name
    }),
    query: z.object({
        blob_count: z.number().describe('The total number of blobs to write to the repository during the test.\nFor realistic experiments, set this parameter to at least `2000`.').optional(),
        concurrency: z.number().describe('The number of operations to run concurrently during the test.\nFor realistic experiments, leave this parameter unset.').optional(),
        detailed: z.boolean().describe('Indicates whether to return detailed results, including timing information for every operation performed during the analysis.\nIf false, it returns only a summary of the analysis.').optional(),
        early_read_node_count: z.number().describe('The number of nodes on which to perform an early read operation while writing each blob.\nEarly read operations are only rarely performed.\nFor realistic experiments, leave this parameter unset.').optional(),
        max_blob_size: types_byte_size.optional(),
        max_total_data_size: types_byte_size.optional(),
        rare_action_probability: z.number().describe('The probability of performing a rare action such as an early read, an overwrite, or an aborted write on each blob.\nFor realistic experiments, leave this parameter unset.').optional(),
        rarely_abort_writes: z.boolean().describe('Indicates whether to rarely cancel writes before they complete.\nFor realistic experiments, leave this parameter unset.').optional(),
        read_node_count: z.number().describe('The number of nodes on which to read a blob after writing.\nFor realistic experiments, leave this parameter unset.').optional(),
        register_operation_count: z.number().describe('The minimum number of linearizable register operations to perform in total.\nFor realistic experiments, set this parameter to at least `100`.').optional(),
        seed: z.number().describe('The seed for the pseudo-random number generator used to generate the list of operations performed during the test.\nTo repeat the same set of operations in multiple experiments, use the same seed in each experiment.\nNote that the operations are performed concurrently so might not always happen in the same order on each run.\nFor realistic experiments, leave this parameter unset.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const snapshot_repository_analyze_response = z.object({
    blob_count: z.number().describe('The number of blobs written to the repository during the test.'),
    blob_path: z.string().describe('The path in the repository under which all the blobs were written during the test.'),
    concurrency: z.number().describe('The number of write operations performed concurrently during the test.'),
    coordinating_node: snapshot_repository_analyze_snapshot_node_info,
    delete_elapsed: types_duration,
    delete_elapsed_nanos: types_duration_value_unit_nanos,
    details: snapshot_repository_analyze_details_info,
    early_read_node_count: z.number().describe('The limit on the number of nodes on which early read operations were performed after writing each blob.'),
    issues_detected: z.array(z.string()).describe('A list of correctness issues detected, which is empty if the API succeeded.\nIt is included to emphasize that a successful response does not guarantee correct behaviour in future.'),
    listing_elapsed: types_duration,
    listing_elapsed_nanos: types_duration_value_unit_nanos,
    max_blob_size: types_byte_size,
    max_blob_size_bytes: z.number().describe('The limit, in bytes, on the size of a blob written during the test.'),
    max_total_data_size: types_byte_size,
    max_total_data_size_bytes: z.number().describe('The limit, in bytes, on the total size of all blob written during the test.'),
    rare_action_probability: z.number().describe('The probability of performing rare actions during the test.'),
    read_node_count: z.number().describe('The limit on the number of nodes on which read operations were performed after writing each blob.'),
    repository: z.string().describe('The name of the repository that was the subject of the analysis.'),
    seed: z.number().describe('The seed for the pseudo-random number generator used to generate the operations used during the test.'),
    summary: snapshot_repository_analyze_summary_info
});

export const snapshot_repository_verify_integrity_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_names
    }),
    query: z.object({
        blob_thread_pool_concurrency: z.number().describe('If `verify_blob_contents` is `true`, this parameter specifies how many blobs to verify at once.').optional(),
        index_snapshot_verification_concurrency: z.number().describe('The maximum number of index snapshots to verify concurrently within each index verification.').optional(),
        index_verification_concurrency: z.number().describe('The number of indices to verify concurrently.\nThe default behavior is to use the entire `snapshot_meta` thread pool.').optional(),
        max_bytes_per_sec: z.string().describe('If `verify_blob_contents` is `true`, this parameter specifies the maximum amount of data that Elasticsearch will read from the repository every second.').optional(),
        max_failed_shard_snapshots: z.number().describe('The number of shard snapshot failures to track during integrity verification, in order to avoid excessive resource usage.\nIf your repository contains more than this number of shard snapshot failures, the verification will fail.').optional(),
        meta_thread_pool_concurrency: z.number().describe('The maximum number of snapshot metadata operations to run concurrently.\nThe default behavior is to use at most half of the `snapshot_meta` thread pool at once.').optional(),
        snapshot_verification_concurrency: z.number().describe('The number of snapshots to verify concurrently.\nThe default behavior is to use at most half of the `snapshot_meta` thread pool at once.').optional(),
        verify_blob_contents: z.boolean().describe('Indicates whether to verify the checksum of every data blob in the repository.\nIf this feature is enabled, Elasticsearch will read the entire repository contents, which may be extremely slow and expensive.').optional()
    }).optional()
});

export const snapshot_repository_verify_integrity_response = z.record(z.unknown());

export const snapshot_status_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error for any snapshots that are unavailable.\nIf `true`, the request ignores snapshots that are unavailable, such as those that are corrupted or temporarily cannot be returned.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const snapshot_status_response = z.object({
    snapshots: z.array(snapshot_types_status)
});

export const snapshot_status1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_name
    }),
    query: z.object({
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error for any snapshots that are unavailable.\nIf `true`, the request ignores snapshots that are unavailable, such as those that are corrupted or temporarily cannot be returned.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const snapshot_status1_response = z.object({
    snapshots: z.array(snapshot_types_status)
});

export const snapshot_status2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_name,
        snapshot: types_names
    }),
    query: z.object({
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error for any snapshots that are unavailable.\nIf `true`, the request ignores snapshots that are unavailable, such as those that are corrupted or temporarily cannot be returned.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const snapshot_status2_response = z.object({
    snapshots: z.array(snapshot_types_status)
});

export const snapshot_verify_repository_request = z.object({
    body: z.never().optional(),
    path: z.object({
        repository: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const snapshot_verify_repository_response = z.object({
    nodes: z.record(snapshot_verify_repository_compact_node_info).describe('Information about the nodes connected to the snapshot repository.\nThe key is the ID of the node.')
});

export const sql_clear_cursor_request = z.object({
    body: z.object({
        cursor: z.string().describe('Cursor to clear.')
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const sql_clear_cursor_response = z.object({
    succeeded: z.boolean()
});

export const sql_delete_async_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const sql_delete_async_response = types_acknowledged_response_base;

export const sql_get_async_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        delimiter: z.string().describe('The separator for CSV results.\nThe API supports this parameter only for CSV responses.').optional(),
        format: z.string().describe('The format for the response.\nYou must specify a format using this parameter or the `Accept` HTTP header.\nIf you specify both, the API uses this parameter.').optional(),
        keep_alive: types_duration.optional(),
        wait_for_completion_timeout: types_duration.optional()
    }).optional()
});

export const sql_get_async_response = z.object({
    id: types_id,
    is_running: z.boolean().describe('If `true`, the search is still running.\nIf `false`, the search has finished.\nThis value is returned only for async and saved synchronous searches.\nFor CSV, TSV, and TXT responses, this value is returned in the `Async-partial` HTTP header.'),
    is_partial: z.boolean().describe('If `true`, the response does not contain complete search results.\nIf `is_partial` is `true` and `is_running` is `true`, the search is still running.\nIf `is_partial` is `true` but `is_running` is `false`, the results are partial due to a failure or timeout.\nThis value is returned only for async and saved synchronous searches.\nFor CSV, TSV, and TXT responses, this value is returned in the `Async-partial` HTTP header.'),
    columns: z.array(sql_types_column).describe('Column headings for the search results. Each object is a column.').optional(),
    cursor: z.string().describe('The cursor for the next set of paginated results.\nFor CSV, TSV, and TXT responses, this value is returned in the `Cursor` HTTP header.').optional(),
    rows: z.array(sql_types_row).describe('The values for the search results.')
});

export const sql_get_async_status_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const sql_get_async_status_response = z.object({
    expiration_time_in_millis: types_epoch_time_unit_millis,
    id: z.string().describe('The identifier for the search.'),
    is_running: z.boolean().describe('If `true`, the search is still running.\nIf `false`, the search has finished.'),
    is_partial: z.boolean().describe('If `true`, the response does not contain complete search results.\nIf `is_partial` is `true` and `is_running` is `true`, the search is still running.\nIf `is_partial` is `true` but `is_running` is `false`, the results are partial due to a failure or timeout.'),
    start_time_in_millis: types_epoch_time_unit_millis,
    completion_status: types_uint.optional()
});

export const ssl_certificates_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ssl_certificates_response = z.array(ssl_certificates_certificate_information);

export const synonyms_delete_synonym_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const synonyms_delete_synonym_response = types_acknowledged_response_base;

export const synonyms_get_synonym_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        from: z.number().describe('The starting offset for query rules to retrieve.').optional(),
        size: z.number().describe('The max number of query rules to retrieve.').optional()
    }).optional()
});

export const synonyms_get_synonym_response = z.object({
    count: z.number().describe('The total number of synonyms rules that the synonyms set contains.'),
    synonyms_set: z.array(synonyms_types_synonym_rule_read).describe('Synonym rule details.')
});

export const synonyms_put_synonym_request = z.object({
    body: z.object({
        synonyms_set: z.union([
            synonyms_types_synonym_rule,
            z.array(synonyms_types_synonym_rule)
        ])
    }),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        refresh: z.boolean().describe('If `true`, the request will refresh the analyzers with the new synonyms set and wait for the new synonyms to be available before returning.\nIf `false`, analyzers will not be reloaded with the new synonym set').optional()
    }).optional()
});

export const synonyms_put_synonym_response = z.object({
    result: types_result,
    reload_analyzers_details: indices_reload_search_analyzers_reload_result.optional()
});

export const synonyms_delete_synonym_rule_request = z.object({
    body: z.never().optional(),
    path: z.object({
        set_id: types_id,
        rule_id: types_id
    }),
    query: z.object({
        refresh: z.boolean().describe('If `true`, the request will refresh the analyzers with the deleted synonym rule and wait for the new synonyms to be available before returning.\nIf `false`, analyzers will not be reloaded with the deleted synonym rule').optional()
    }).optional()
});

export const synonyms_delete_synonym_rule_response = synonyms_types_synonyms_update_result;

export const synonyms_get_synonym_rule_request = z.object({
    body: z.never().optional(),
    path: z.object({
        set_id: types_id,
        rule_id: types_id
    }),
    query: z.never().optional()
});

export const synonyms_get_synonym_rule_response = synonyms_types_synonym_rule_read;

export const synonyms_put_synonym_rule_request = z.object({
    body: z.object({
        synonyms: synonyms_types_synonym_string
    }),
    path: z.object({
        set_id: types_id,
        rule_id: types_id
    }),
    query: z.object({
        refresh: z.boolean().describe('If `true`, the request will refresh the analyzers with the new synonym rule and wait for the new synonyms to be available before returning.\nIf `false`, analyzers will not be reloaded with the new synonym rule').optional()
    }).optional()
});

export const synonyms_put_synonym_rule_response = synonyms_types_synonyms_update_result;

export const synonyms_get_synonyms_sets_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        from: z.number().describe('The starting offset for synonyms sets to retrieve.').optional(),
        size: z.number().describe('The maximum number of synonyms sets to retrieve.').optional()
    }).optional()
});

export const synonyms_get_synonyms_sets_response = z.object({
    count: z.number().describe('The total number of synonyms sets defined.'),
    results: z.array(synonyms_get_synonyms_sets_synonyms_set_item).describe('The identifier and total number of defined synonym rules for each synonyms set.')
});

export const tasks_cancel_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        actions: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        nodes: z.array(z.string()).describe('A comma-separated list of node IDs or names that is used to limit the request.').optional(),
        parent_task_id: z.string().describe('A parent task ID that is used to limit the tasks.').optional(),
        wait_for_completion: z.boolean().describe('If true, the request blocks until all found tasks are complete.').optional()
    }).optional()
});

export const tasks_cancel_response = tasks_types_task_list_response_base;

export const tasks_cancel1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        task_id: types_task_id
    }),
    query: z.object({
        actions: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        nodes: z.array(z.string()).describe('A comma-separated list of node IDs or names that is used to limit the request.').optional(),
        parent_task_id: z.string().describe('A parent task ID that is used to limit the tasks.').optional(),
        wait_for_completion: z.boolean().describe('If true, the request blocks until all found tasks are complete.').optional()
    }).optional()
});

export const tasks_cancel1_response = tasks_types_task_list_response_base;

export const tasks_get_request = z.object({
    body: z.never().optional(),
    path: z.object({
        task_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request blocks until the task has completed.').optional()
    }).optional()
});

export const tasks_get_response = z.object({
    completed: z.boolean(),
    task: tasks_types_task_info,
    response: z.record(z.unknown()).optional(),
    error: types_error_cause.optional()
});

export const tasks_list_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        actions: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        detailed: z.boolean().describe('If `true`, the response includes detailed information about the running tasks.\nThis information is useful to distinguish tasks from each other but is more costly to run.').optional(),
        group_by: tasks_types_group_by.optional(),
        nodes: types_node_ids.optional(),
        parent_task_id: types_id.optional(),
        timeout: types_duration.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request blocks until the operation is complete.').optional()
    }).optional()
});

export const tasks_list_response = tasks_types_task_list_response_base;

export const termvectors_request = z.object({
    body: termvectors.optional(),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        fields: types_fields.optional(),
        field_statistics: z.boolean().describe('If `true`, the response includes:\n\n* The document count (how many documents contain this field).\n* The sum of document frequencies (the sum of document frequencies for all terms in this field).\n* The sum of total term frequencies (the sum of total term frequencies of each term in this field).').optional(),
        offsets: z.boolean().describe('If `true`, the response includes term offsets.').optional(),
        payloads: z.boolean().describe('If `true`, the response includes term payloads.').optional(),
        positions: z.boolean().describe('If `true`, the response includes term positions.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        realtime: z.boolean().describe('If true, the request is real-time as opposed to near-real-time.').optional(),
        routing: types_routing.optional(),
        term_statistics: z.boolean().describe('If `true`, the response includes:\n\n* The total term frequency (how often a term occurs in all documents).\n* The document frequency (the number of documents containing the current term).\n\nBy default these values are not returned since term statistics can have a serious performance impact.').optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const termvectors_response = z.object({
    found: z.boolean(),
    _id: types_id.optional(),
    _index: types_index_name,
    term_vectors: z.record(global_termvectors_term_vector).optional(),
    took: z.number(),
    _version: types_version_number
});

export const termvectors1_request = z.object({
    body: termvectors.optional(),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        fields: types_fields.optional(),
        field_statistics: z.boolean().describe('If `true`, the response includes:\n\n* The document count (how many documents contain this field).\n* The sum of document frequencies (the sum of document frequencies for all terms in this field).\n* The sum of total term frequencies (the sum of total term frequencies of each term in this field).').optional(),
        offsets: z.boolean().describe('If `true`, the response includes term offsets.').optional(),
        payloads: z.boolean().describe('If `true`, the response includes term payloads.').optional(),
        positions: z.boolean().describe('If `true`, the response includes term positions.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        realtime: z.boolean().describe('If true, the request is real-time as opposed to near-real-time.').optional(),
        routing: types_routing.optional(),
        term_statistics: z.boolean().describe('If `true`, the response includes:\n\n* The total term frequency (how often a term occurs in all documents).\n* The document frequency (the number of documents containing the current term).\n\nBy default these values are not returned since term statistics can have a serious performance impact.').optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const termvectors1_response = z.object({
    found: z.boolean(),
    _id: types_id.optional(),
    _index: types_index_name,
    term_vectors: z.record(global_termvectors_term_vector).optional(),
    took: z.number(),
    _version: types_version_number
});

export const termvectors2_request = z.object({
    body: termvectors.optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        fields: types_fields.optional(),
        field_statistics: z.boolean().describe('If `true`, the response includes:\n\n* The document count (how many documents contain this field).\n* The sum of document frequencies (the sum of document frequencies for all terms in this field).\n* The sum of total term frequencies (the sum of total term frequencies of each term in this field).').optional(),
        offsets: z.boolean().describe('If `true`, the response includes term offsets.').optional(),
        payloads: z.boolean().describe('If `true`, the response includes term payloads.').optional(),
        positions: z.boolean().describe('If `true`, the response includes term positions.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        realtime: z.boolean().describe('If true, the request is real-time as opposed to near-real-time.').optional(),
        routing: types_routing.optional(),
        term_statistics: z.boolean().describe('If `true`, the response includes:\n\n* The total term frequency (how often a term occurs in all documents).\n* The document frequency (the number of documents containing the current term).\n\nBy default these values are not returned since term statistics can have a serious performance impact.').optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const termvectors2_response = z.object({
    found: z.boolean(),
    _id: types_id.optional(),
    _index: types_index_name,
    term_vectors: z.record(global_termvectors_term_vector).optional(),
    took: z.number(),
    _version: types_version_number
});

export const termvectors3_request = z.object({
    body: termvectors.optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        fields: types_fields.optional(),
        field_statistics: z.boolean().describe('If `true`, the response includes:\n\n* The document count (how many documents contain this field).\n* The sum of document frequencies (the sum of document frequencies for all terms in this field).\n* The sum of total term frequencies (the sum of total term frequencies of each term in this field).').optional(),
        offsets: z.boolean().describe('If `true`, the response includes term offsets.').optional(),
        payloads: z.boolean().describe('If `true`, the response includes term payloads.').optional(),
        positions: z.boolean().describe('If `true`, the response includes term positions.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        realtime: z.boolean().describe('If true, the request is real-time as opposed to near-real-time.').optional(),
        routing: types_routing.optional(),
        term_statistics: z.boolean().describe('If `true`, the response includes:\n\n* The total term frequency (how often a term occurs in all documents).\n* The document frequency (the number of documents containing the current term).\n\nBy default these values are not returned since term statistics can have a serious performance impact.').optional(),
        version: types_version_number.optional(),
        version_type: types_version_type.optional()
    }).optional()
});

export const termvectors3_response = z.object({
    found: z.boolean(),
    _id: types_id.optional(),
    _index: types_index_name,
    term_vectors: z.record(global_termvectors_term_vector).optional(),
    took: z.number(),
    _version: types_version_number
});

export const text_structure_test_grok_pattern_request = z.object({
    body: text_structure_test_grok_pattern,
    path: z.never().optional(),
    query: z.object({
        ecs_compatibility: z.string().describe('The mode of compatibility with ECS compliant Grok patterns.\nUse this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern.\nValid values are `disabled` and `v1`.').optional()
    }).optional()
});

export const text_structure_test_grok_pattern_response = z.object({
    matches: z.array(text_structure_test_grok_pattern_matched_text)
});

export const text_structure_test_grok_pattern1_request = z.object({
    body: text_structure_test_grok_pattern,
    path: z.never().optional(),
    query: z.object({
        ecs_compatibility: z.string().describe('The mode of compatibility with ECS compliant Grok patterns.\nUse this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern.\nValid values are `disabled` and `v1`.').optional()
    }).optional()
});

export const text_structure_test_grok_pattern1_response = z.object({
    matches: z.array(text_structure_test_grok_pattern_matched_text)
});

export const transform_delete_transform_request = z.object({
    body: z.never().optional(),
    path: z.object({
        transform_id: types_id
    }),
    query: z.object({
        force: z.boolean().describe('If this value is false, the transform must be stopped before it can be deleted. If true, the transform is\ndeleted regardless of its current state.').optional(),
        delete_dest_index: z.boolean().describe('If this value is true, the destination index is deleted together with the transform. If false, the destination\nindex will not be deleted').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const transform_delete_transform_response = types_acknowledged_response_base;

export const transform_get_transform_stats_request = z.object({
    body: z.never().optional(),
    path: z.object({
        transform_id: types_names
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no transforms that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf this parameter is false, the request returns a 404 status code when\nthere are no matches or only partial matches.').optional(),
        from: z.number().describe('Skips the specified number of transforms.').optional(),
        size: z.number().describe('Specifies the maximum number of transforms to obtain.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const transform_get_transform_stats_response = z.object({
    count: z.number(),
    transforms: z.array(transform_get_transform_stats_transform_stats)
});

export const transform_reset_transform_request = z.object({
    body: z.never().optional(),
    path: z.object({
        transform_id: types_id
    }),
    query: z.object({
        force: z.boolean().describe('If this value is `true`, the transform is reset regardless of its current state. If it\'s `false`, the transform\nmust be stopped before it can be reset.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const transform_reset_transform_response = types_acknowledged_response_base;

export const transform_schedule_now_transform_request = z.object({
    body: z.never().optional(),
    path: z.object({
        transform_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const transform_schedule_now_transform_response = types_acknowledged_response_base;

export const transform_set_upgrade_mode_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        enabled: z.boolean().describe('When `true`, it enables `upgrade_mode` which temporarily halts all\ntransform tasks and prohibits new transform tasks from\nstarting.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const transform_set_upgrade_mode_response = types_acknowledged_response_base;

export const transform_start_transform_request = z.object({
    body: z.never().optional(),
    path: z.object({
        transform_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional(),
        from: z.string().describe('Restricts the set of transformed entities to those changed after this time. Relative times like now-30d are supported. Only applicable for continuous transforms.').optional()
    }).optional()
});

export const transform_start_transform_response = types_acknowledged_response_base;

export const transform_stop_transform_request = z.object({
    body: z.never().optional(),
    path: z.object({
        transform_id: types_name
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request: contains wildcard expressions and there are no transforms that match;\ncontains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there\nare only partial matches.\n\nIf it is true, the API returns a successful acknowledgement message when there are no matches. When there are\nonly partial matches, the API stops the appropriate transforms.\n\nIf it is false, the request returns a 404 status code when there are no matches or only partial matches.').optional(),
        force: z.boolean().describe('If it is true, the API forcefully stops the transforms.').optional(),
        timeout: types_duration.optional(),
        wait_for_checkpoint: z.boolean().describe('If it is true, the transform does not completely stop until the current checkpoint is completed. If it is false,\nthe transform stops as soon as possible.').optional(),
        wait_for_completion: z.boolean().describe('If it is true, the API blocks until the indexer state completely stops. If it is false, the API returns\nimmediately and the indexer is stopped asynchronously in the background.').optional()
    }).optional()
});

export const transform_stop_transform_response = types_acknowledged_response_base;

export const transform_upgrade_transforms_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        dry_run: z.boolean().describe('When true, the request checks for updates but does not run them.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const transform_upgrade_transforms_response = z.object({
    needs_update: z.number().describe('The number of transforms that need to be upgraded.'),
    no_action: z.number().describe('The number of transforms that dont require upgrading.'),
    updated: z.number().describe('The number of transforms that have been upgraded.')
});

export const update_by_query_rethrottle_request = z.object({
    body: z.never().optional(),
    path: z.object({
        task_id: types_id
    }),
    query: z.object({
        requests_per_second: z.number().describe('The throttle for this request in sub-requests per second.\nTo turn off throttling, set it to `-1`.').optional()
    }).optional()
});

export const update_by_query_rethrottle_response = z.object({
    nodes: z.record(global_update_by_query_rethrottle_update_by_query_rethrottle_node)
});

export const watcher_ack_watch1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        watch_id: types_name
    }),
    query: z.never().optional()
});

export const watcher_ack_watch1_response = z.object({
    status: watcher_types_watch_status
});

export const watcher_ack_watch_request = z.object({
    body: z.never().optional(),
    path: z.object({
        watch_id: types_name
    }),
    query: z.never().optional()
});

export const watcher_ack_watch_response = z.object({
    status: watcher_types_watch_status
});

export const watcher_ack_watch3_request = z.object({
    body: z.never().optional(),
    path: z.object({
        watch_id: types_name,
        action_id: types_names
    }),
    query: z.never().optional()
});

export const watcher_ack_watch3_response = z.object({
    status: watcher_types_watch_status
});

export const watcher_ack_watch2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        watch_id: types_name,
        action_id: types_names
    }),
    query: z.never().optional()
});

export const watcher_ack_watch2_response = z.object({
    status: watcher_types_watch_status
});

export const watcher_activate_watch1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        watch_id: types_name
    }),
    query: z.never().optional()
});

export const watcher_activate_watch1_response = z.object({
    status: watcher_types_activation_status
});

export const watcher_activate_watch_request = z.object({
    body: z.never().optional(),
    path: z.object({
        watch_id: types_name
    }),
    query: z.never().optional()
});

export const watcher_activate_watch_response = z.object({
    status: watcher_types_activation_status
});

export const watcher_deactivate_watch1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        watch_id: types_name
    }),
    query: z.never().optional()
});

export const watcher_deactivate_watch1_response = z.object({
    status: watcher_types_activation_status
});

export const watcher_deactivate_watch_request = z.object({
    body: z.never().optional(),
    path: z.object({
        watch_id: types_name
    }),
    query: z.never().optional()
});

export const watcher_deactivate_watch_response = z.object({
    status: watcher_types_activation_status
});

export const watcher_delete_watch_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_name
    }),
    query: z.never().optional()
});

export const watcher_delete_watch_response = z.object({
    found: z.boolean(),
    _id: types_id,
    _version: types_version_number
});

export const watcher_update_settings_request = z.object({
    body: z.object({
        'index.auto_expand_replicas': z.string().optional(),
        'index.number_of_replicas': z.number().optional()
    }),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const watcher_update_settings_response = z.object({
    acknowledged: z.boolean()
});

export const watcher_start_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const watcher_start_response = types_acknowledged_response_base;

export const watcher_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        emit_stacktraces: z.boolean().describe('Defines whether stack traces are generated for each watch that is running.').optional(),
        metric: z.union([
            watcher_stats_watcher_metric,
            z.array(watcher_stats_watcher_metric)
        ]).optional()
    }).optional()
});

export const watcher_stats_response = z.object({
    _nodes: types_node_statistics,
    cluster_name: types_name,
    manually_stopped: z.boolean(),
    stats: z.array(watcher_stats_watcher_node_stats)
});

export const watcher_stats1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        metric: z.union([
            watcher_stats_watcher_metric,
            z.array(watcher_stats_watcher_metric)
        ])
    }),
    query: z.object({
        emit_stacktraces: z.boolean().describe('Defines whether stack traces are generated for each watch that is running.').optional(),
        metric: z.union([
            watcher_stats_watcher_metric,
            z.array(watcher_stats_watcher_metric)
        ]).optional()
    }).optional()
});

export const watcher_stats1_response = z.object({
    _nodes: types_node_statistics,
    cluster_name: types_name,
    manually_stopped: z.boolean(),
    stats: z.array(watcher_stats_watcher_node_stats)
});

export const watcher_stop_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const watcher_stop_response = types_acknowledged_response_base;

export const xpack_info_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        categories: z.array(xpack_info_x_pack_category).describe('A comma-separated list of the information categories to include in the response.\nFor example, `build,license,features`.').optional(),
        accept_enterprise: z.boolean().describe('If this param is used it must be set to true').optional(),
        human: z.boolean().describe('Defines whether additional human-readable information is included in the response.\nIn particular, it adds descriptions and a tag line.').optional()
    }).optional()
});

export const xpack_info_response = z.object({
    build: xpack_info_build_information,
    features: xpack_info_features,
    license: xpack_info_minimal_license_information,
    tagline: z.string()
});

export const xpack_usage_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const xpack_usage_response = z.object({
    aggregate_metric: xpack_usage_base,
    analytics: xpack_usage_analytics,
    archive: xpack_usage_archive,
    watcher: xpack_usage_watcher,
    ccr: xpack_usage_ccr,
    data_frame: xpack_usage_base.optional(),
    data_science: xpack_usage_base.optional(),
    data_streams: xpack_usage_data_streams.optional(),
    data_tiers: xpack_usage_data_tiers,
    enrich: xpack_usage_base.optional(),
    eql: xpack_usage_eql,
    flattened: xpack_usage_flattened.optional(),
    graph: xpack_usage_base,
    health_api: xpack_usage_health_statistics.optional(),
    ilm: xpack_usage_ilm,
    logstash: xpack_usage_base,
    ml: xpack_usage_machine_learning,
    monitoring: xpack_usage_monitoring,
    rollup: xpack_usage_base,
    runtime_fields: xpack_usage_runtime_field_types.optional(),
    spatial: xpack_usage_base,
    searchable_snapshots: xpack_usage_searchable_snapshots,
    security: xpack_usage_security,
    slm: xpack_usage_slm,
    sql: xpack_usage_sql,
    transform: xpack_usage_base,
    vectors: xpack_usage_vector.optional(),
    voting_only: xpack_usage_base
});

export const async_search_get_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        keep_alive: types_duration.optional(),
        typed_keys: z.boolean().describe('Specify whether aggregation and suggester names should be prefixed by their respective types in the response').optional(),
        wait_for_completion_timeout: types_duration.optional()
    }).optional()
});

export const async_search_get_response = async_search_types_async_search_document_response_base;

export const async_search_submit_request = z.object({
    body: async_search_submit.optional(),
    path: z.never().optional(),
    query: z.object({
        wait_for_completion_timeout: types_duration.optional(),
        keep_alive: types_duration.optional(),
        keep_on_completion: z.boolean().describe('If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`.').optional(),
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        allow_partial_search_results: z.boolean().describe('Indicate if an error should be returned if there is a partial search failure or timeout').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string').optional(),
        analyze_wildcard: z.boolean().describe('Specify whether wildcard and prefix queries should be analyzed (default: false)').optional(),
        batched_reduce_size: z.number().describe('Affects how often partial results become available, which happens whenever shard results are reduced.\nA partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('The default value is the only supported value.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as default where no field prefix is given in the query string').optional(),
        docvalue_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('Specify whether to return detailed information about score computation as part of a hit').optional(),
        ignore_throttled: z.boolean().describe('Whether specified concrete, expanded or aliased indices should be ignored when throttled').optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional(),
        lenient: z.boolean().describe('Specify whether format-based query failures (such as providing text to a numeric field) should be ignored').optional(),
        max_concurrent_shard_requests: z.number().describe('The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests').optional(),
        preference: z.string().describe('Specify the node or shard the operation should be performed on (default: random)').optional(),
        request_cache: z.boolean().describe('Specify if request cache should be used for this request or not, defaults to true').optional(),
        routing: types_routing.optional(),
        search_type: types_search_type.optional(),
        stats: z.array(z.string()).describe('Specific \'tag\' of the request for logging and statistical purposes').optional(),
        stored_fields: types_fields.optional(),
        suggest_field: types_field.optional(),
        suggest_mode: types_suggest_mode.optional(),
        suggest_size: z.number().describe('How many suggestions to return in response').optional(),
        suggest_text: z.string().describe('The source text for which the suggestions should be returned.').optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.').optional(),
        timeout: types_duration.optional(),
        track_total_hits: global_search_types_track_hits.optional(),
        track_scores: z.boolean().describe('Whether to calculate and return scores even if they are not used for sorting').optional(),
        typed_keys: z.boolean().describe('Specify whether aggregation and suggester names should be prefixed by their respective types in the response').optional(),
        rest_total_hits_as_int: z.boolean().describe('Indicates whether hits.total should be rendered as an integer or an object in the rest search response').optional(),
        version: z.boolean().describe('Specify whether to return document version as part of a hit').optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        seq_no_primary_term: z.boolean().describe('Specify whether to return sequence number and primary term of the last modification of each hit').optional(),
        q: z.string().describe('Query in the Lucene query string syntax').optional(),
        size: z.number().describe('Number of hits to return (default: 10)').optional(),
        from: z.number().describe('Starting offset (default: 0)').optional(),
        sort: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const async_search_submit_response = async_search_types_async_search_document_response_base;

export const async_search_submit1_request = z.object({
    body: async_search_submit.optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        wait_for_completion_timeout: types_duration.optional(),
        keep_alive: types_duration.optional(),
        keep_on_completion: z.boolean().describe('If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`.').optional(),
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        allow_partial_search_results: z.boolean().describe('Indicate if an error should be returned if there is a partial search failure or timeout').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string').optional(),
        analyze_wildcard: z.boolean().describe('Specify whether wildcard and prefix queries should be analyzed (default: false)').optional(),
        batched_reduce_size: z.number().describe('Affects how often partial results become available, which happens whenever shard results are reduced.\nA partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('The default value is the only supported value.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as default where no field prefix is given in the query string').optional(),
        docvalue_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('Specify whether to return detailed information about score computation as part of a hit').optional(),
        ignore_throttled: z.boolean().describe('Whether specified concrete, expanded or aliased indices should be ignored when throttled').optional(),
        ignore_unavailable: z.boolean().describe('Whether specified concrete indices should be ignored when unavailable (missing or closed)').optional(),
        lenient: z.boolean().describe('Specify whether format-based query failures (such as providing text to a numeric field) should be ignored').optional(),
        max_concurrent_shard_requests: z.number().describe('The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests').optional(),
        preference: z.string().describe('Specify the node or shard the operation should be performed on (default: random)').optional(),
        request_cache: z.boolean().describe('Specify if request cache should be used for this request or not, defaults to true').optional(),
        routing: types_routing.optional(),
        search_type: types_search_type.optional(),
        stats: z.array(z.string()).describe('Specific \'tag\' of the request for logging and statistical purposes').optional(),
        stored_fields: types_fields.optional(),
        suggest_field: types_field.optional(),
        suggest_mode: types_suggest_mode.optional(),
        suggest_size: z.number().describe('How many suggestions to return in response').optional(),
        suggest_text: z.string().describe('The source text for which the suggestions should be returned.').optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.').optional(),
        timeout: types_duration.optional(),
        track_total_hits: global_search_types_track_hits.optional(),
        track_scores: z.boolean().describe('Whether to calculate and return scores even if they are not used for sorting').optional(),
        typed_keys: z.boolean().describe('Specify whether aggregation and suggester names should be prefixed by their respective types in the response').optional(),
        rest_total_hits_as_int: z.boolean().describe('Indicates whether hits.total should be rendered as an integer or an object in the rest search response').optional(),
        version: z.boolean().describe('Specify whether to return document version as part of a hit').optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        seq_no_primary_term: z.boolean().describe('Specify whether to return sequence number and primary term of the last modification of each hit').optional(),
        q: z.string().describe('Query in the Lucene query string syntax').optional(),
        size: z.number().describe('Number of hits to return (default: 10)').optional(),
        from: z.number().describe('Starting offset (default: 0)').optional(),
        sort: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const async_search_submit1_response = async_search_types_async_search_document_response_base;

export const bulk_request = z.object({
    body: bulk,
    path: z.never().optional(),
    query: z.object({
        include_source_on_error: z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.').optional(),
        list_executed_pipelines: z.boolean().describe('If `true`, the response will include the ingest pipelines that were run for each index or create.').optional(),
        pipeline: z.string().describe('The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.').optional(),
        refresh: types_refresh.optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        require_alias: z.boolean().describe('If `true`, the request\'s actions must target an index alias.').optional(),
        require_data_stream: z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).').optional()
    }).optional()
});

export const bulk_response = z.object({
    errors: z.boolean().describe('If `true`, one or more of the operations in the bulk request did not complete successfully.'),
    items: z.array(z.record(global_bulk_response_item)).describe('The result of each operation in the bulk request, in the order they were submitted.'),
    took: z.number().describe('The length of time, in milliseconds, it took to process the bulk request.'),
    ingest_took: z.number().optional()
});

export const bulk1_request = z.object({
    body: bulk,
    path: z.never().optional(),
    query: z.object({
        include_source_on_error: z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.').optional(),
        list_executed_pipelines: z.boolean().describe('If `true`, the response will include the ingest pipelines that were run for each index or create.').optional(),
        pipeline: z.string().describe('The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.').optional(),
        refresh: types_refresh.optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        require_alias: z.boolean().describe('If `true`, the request\'s actions must target an index alias.').optional(),
        require_data_stream: z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).').optional()
    }).optional()
});

export const bulk1_response = z.object({
    errors: z.boolean().describe('If `true`, one or more of the operations in the bulk request did not complete successfully.'),
    items: z.array(z.record(global_bulk_response_item)).describe('The result of each operation in the bulk request, in the order they were submitted.'),
    took: z.number().describe('The length of time, in milliseconds, it took to process the bulk request.'),
    ingest_took: z.number().optional()
});

export const bulk2_request = z.object({
    body: bulk,
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        include_source_on_error: z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.').optional(),
        list_executed_pipelines: z.boolean().describe('If `true`, the response will include the ingest pipelines that were run for each index or create.').optional(),
        pipeline: z.string().describe('The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.').optional(),
        refresh: types_refresh.optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        require_alias: z.boolean().describe('If `true`, the request\'s actions must target an index alias.').optional(),
        require_data_stream: z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).').optional()
    }).optional()
});

export const bulk2_response = z.object({
    errors: z.boolean().describe('If `true`, one or more of the operations in the bulk request did not complete successfully.'),
    items: z.array(z.record(global_bulk_response_item)).describe('The result of each operation in the bulk request, in the order they were submitted.'),
    took: z.number().describe('The length of time, in milliseconds, it took to process the bulk request.'),
    ingest_took: z.number().optional()
});

export const bulk3_request = z.object({
    body: bulk,
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        include_source_on_error: z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.').optional(),
        list_executed_pipelines: z.boolean().describe('If `true`, the response will include the ingest pipelines that were run for each index or create.').optional(),
        pipeline: z.string().describe('The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.').optional(),
        refresh: types_refresh.optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        require_alias: z.boolean().describe('If `true`, the request\'s actions must target an index alias.').optional(),
        require_data_stream: z.boolean().describe('If `true`, the request\'s actions must target a data stream (existing or to be created).').optional()
    }).optional()
});

export const bulk3_response = z.object({
    errors: z.boolean().describe('If `true`, one or more of the operations in the bulk request did not complete successfully.'),
    items: z.array(z.record(global_bulk_response_item)).describe('The result of each operation in the bulk request, in the order they were submitted.'),
    took: z.number().describe('The length of time, in milliseconds, it took to process the bulk request.'),
    ingest_took: z.number().optional()
});

export const ccr_follow_request = z.object({
    body: z.object({
        data_stream_name: z.string().describe('If the leader index is part of a data stream, the name to which the local data stream for the followed index should be renamed.').optional(),
        leader_index: types_index_name,
        max_outstanding_read_requests: z.number().describe('The maximum number of outstanding reads requests from the remote cluster.').optional(),
        max_outstanding_write_requests: z.number().describe('The maximum number of outstanding write requests on the follower.').optional(),
        max_read_request_operation_count: z.number().describe('The maximum number of operations to pull per read from the remote cluster.').optional(),
        max_read_request_size: types_byte_size.optional(),
        max_retry_delay: types_duration.optional(),
        max_write_buffer_count: z.number().describe('The maximum number of operations that can be queued for writing. When this limit is reached, reads from the remote cluster will be\ndeferred until the number of queued operations goes below the limit.').optional(),
        max_write_buffer_size: types_byte_size.optional(),
        max_write_request_operation_count: z.number().describe('The maximum number of operations per bulk write request executed on the follower.').optional(),
        max_write_request_size: types_byte_size.optional(),
        read_poll_timeout: types_duration.optional(),
        remote_cluster: z.string().describe('The remote cluster containing the leader index.'),
        settings: indices_types_index_settings.optional()
    }),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const ccr_follow_response = z.object({
    follow_index_created: z.boolean(),
    follow_index_shards_acked: z.boolean(),
    index_following_started: z.boolean()
});

export const scroll_request = z.object({
    body: scroll.optional(),
    path: z.never().optional(),
    query: z.object({
        scroll: types_duration.optional(),
        scroll_id: types_scroll_id.optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, the API responses hit.total property is returned as an integer. If false, the API responses hit.total property is returned as an object.').optional()
    }).optional()
});

export const scroll_response = global_search_response_body;

export const scroll1_request = z.object({
    body: scroll.optional(),
    path: z.never().optional(),
    query: z.object({
        scroll: types_duration.optional(),
        scroll_id: types_scroll_id.optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, the API responses hit.total property is returned as an integer. If false, the API responses hit.total property is returned as an object.').optional()
    }).optional()
});

export const scroll1_response = global_search_response_body;

export const scroll2_request = z.object({
    body: scroll.optional(),
    path: z.object({
        scroll_id: types_scroll_id
    }),
    query: z.object({
        scroll: types_duration.optional(),
        scroll_id: types_scroll_id.optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, the API responses hit.total property is returned as an integer. If false, the API responses hit.total property is returned as an object.').optional()
    }).optional()
});

export const scroll2_response = global_search_response_body;

export const scroll3_request = z.object({
    body: scroll.optional(),
    path: z.object({
        scroll_id: types_scroll_id
    }),
    query: z.object({
        scroll: types_duration.optional(),
        scroll_id: types_scroll_id.optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, the API responses hit.total property is returned as an integer. If false, the API responses hit.total property is returned as an object.').optional()
    }).optional()
});

export const scroll3_response = global_search_response_body;

export const cluster_get_component_template1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        settings_filter: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        include_defaults: z.boolean().describe('Return all default configurations for the component template (default: false)').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.\nIf `false`, information is retrieved from the master node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cluster_get_component_template1_response = z.object({
    component_templates: z.array(cluster_types_component_template)
});

export const cluster_put_component_template1_request = z.object({
    body: cluster_put_component_template,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        create: z.boolean().describe('If `true`, this request cannot replace or update existing component templates.').optional(),
        cause: z.string().describe('User defined reason for create the component template.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cluster_put_component_template1_response = types_acknowledged_response_base;

export const cluster_put_component_template_request = z.object({
    body: cluster_put_component_template,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        create: z.boolean().describe('If `true`, this request cannot replace or update existing component templates.').optional(),
        cause: z.string().describe('User defined reason for create the component template.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cluster_put_component_template_response = types_acknowledged_response_base;

export const cluster_get_component_template_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        settings_filter: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        include_defaults: z.boolean().describe('Return all default configurations for the component template (default: false)').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.\nIf `false`, information is retrieved from the master node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const cluster_get_component_template_response = z.object({
    component_templates: z.array(cluster_types_component_template)
});

export const count1_request = z.object({
    body: count.optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If `true`, concrete, expanded, or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        min_score: z.number().describe('The minimum `_score` value that documents must have to be included in the result.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nBy default, it is random.').optional(),
        routing: types_routing.optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.').optional(),
        q: z.string().describe('The query in Lucene query string syntax. This parameter cannot be used with a request body.').optional()
    }).optional()
});

export const count1_response = z.object({
    count: z.number(),
    _shards: types_shard_statistics
});

export const count_request = z.object({
    body: count.optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If `true`, concrete, expanded, or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        min_score: z.number().describe('The minimum `_score` value that documents must have to be included in the result.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nBy default, it is random.').optional(),
        routing: types_routing.optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.').optional(),
        q: z.string().describe('The query in Lucene query string syntax. This parameter cannot be used with a request body.').optional()
    }).optional()
});

export const count_response = z.object({
    count: z.number(),
    _shards: types_shard_statistics
});

export const count3_request = z.object({
    body: count.optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If `true`, concrete, expanded, or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        min_score: z.number().describe('The minimum `_score` value that documents must have to be included in the result.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nBy default, it is random.').optional(),
        routing: types_routing.optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.').optional(),
        q: z.string().describe('The query in Lucene query string syntax. This parameter cannot be used with a request body.').optional()
    }).optional()
});

export const count3_response = z.object({
    count: z.number(),
    _shards: types_shard_statistics
});

export const count2_request = z.object({
    body: count.optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If `true`, concrete, expanded, or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        min_score: z.number().describe('The minimum `_score` value that documents must have to be included in the result.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nBy default, it is random.').optional(),
        routing: types_routing.optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.').optional(),
        q: z.string().describe('The query in Lucene query string syntax. This parameter cannot be used with a request body.').optional()
    }).optional()
});

export const count2_response = z.object({
    count: z.number(),
    _shards: types_shard_statistics
});

export const delete_by_query_request = z.object({
    body: z.object({
        max_docs: z.number().describe('The maximum number of documents to delete.').optional(),
        query: types_query_dsl_query_container.optional(),
        slice: types_sliced_scroll.optional(),
        sort: types_sort.optional()
    }),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        analyzer: z.string().describe('Analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        conflicts: types_conflicts.optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        from: z.number().describe('Skips the specified number of documents.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        max_docs: z.number().describe('The maximum number of documents to process.\nDefaults to all documents.\nWhen set to a value less then or equal to `scroll_size`, a scroll will not be used to retrieve the results for the operation.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        refresh: z.boolean().describe('If `true`, Elasticsearch refreshes all shards involved in the delete by query after the request completes.\nThis is different than the delete API\'s `refresh` parameter, which causes just the shard that received the delete request to be refreshed.\nUnlike the delete API, it does not support `wait_for`.').optional(),
        request_cache: z.boolean().describe('If `true`, the request cache is used for this request.\nDefaults to the index-level setting.').optional(),
        requests_per_second: z.number().describe('The throttle for this request in sub-requests per second.').optional(),
        routing: types_routing.optional(),
        q: z.string().describe('A query in the Lucene query string syntax.').optional(),
        scroll: types_duration.optional(),
        scroll_size: z.number().describe('The size of the scroll request that powers the operation.').optional(),
        search_timeout: types_duration.optional(),
        search_type: types_search_type.optional(),
        slices: types_slices.optional(),
        sort: z.array(z.string()).describe('A comma-separated list of `<field>:<direction>` pairs.').optional(),
        stats: z.array(z.string()).describe('The specific `tag` of the request for logging and statistical purposes.').optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nUse with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.').optional(),
        timeout: types_duration.optional(),
        version: z.boolean().describe('If `true`, returns the document version as part of a hit.').optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request blocks until the operation is complete.\nIf `false`, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task. Elasticsearch creates a record of this task as a document at `.tasks/task/${taskId}`. When you are done with a task, you should delete the task document so Elasticsearch can reclaim the space.').optional()
    }).optional()
});

export const delete_by_query_response = z.object({
    batches: z.number().describe('The number of scroll responses pulled back by the delete by query.').optional(),
    deleted: z.number().describe('The number of documents that were successfully deleted.').optional(),
    failures: z.array(types_bulk_index_by_scroll_failure).describe('An array of failures if there were any unrecoverable errors during the process.\nIf this array is not empty, the request ended abnormally because of those failures.\nDelete by query is implemented using batches and any failures cause the entire process to end but all failures in the current batch are collected into the array.\nYou can use the `conflicts` option to prevent reindex from ending on version conflicts.').optional(),
    noops: z.number().describe('This field is always equal to zero for delete by query.\nIt exists only so that delete by query, update by query, and reindex APIs return responses with the same structure.').optional(),
    requests_per_second: z.number().describe('The number of requests per second effectively run during the delete by query.').optional(),
    retries: types_retries.optional(),
    slice_id: z.number().optional(),
    task: types_task_id.optional(),
    throttled: types_duration.optional(),
    throttled_millis: types_duration_value_unit_millis.optional(),
    throttled_until: types_duration.optional(),
    throttled_until_millis: types_duration_value_unit_millis.optional(),
    timed_out: z.boolean().describe('If `true`, some requests run during the delete by query operation timed out.').optional(),
    took: types_duration_value_unit_millis.optional(),
    total: z.number().describe('The number of documents that were successfully processed.').optional(),
    version_conflicts: z.number().describe('The number of version conflicts that the delete by query hit.').optional()
});

export const get_script_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const get_script_response = z.object({
    _id: types_id,
    found: z.boolean(),
    script: types_stored_script.optional()
});

export const put_script1_request = z.object({
    body: put_script,
    path: z.object({
        id: types_id
    }),
    query: z.object({
        context: types_name.optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const put_script1_response = types_acknowledged_response_base;

export const put_script_request = z.object({
    body: put_script,
    path: z.object({
        id: types_id
    }),
    query: z.object({
        context: types_name.optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const put_script_response = types_acknowledged_response_base;

export const enrich_get_policy_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const enrich_get_policy_response = z.object({
    policies: z.array(enrich_types_summary)
});

export const enrich_put_policy_request = z.object({
    body: z.object({
        geo_match: enrich_types_policy.optional(),
        match: enrich_types_policy.optional(),
        range: enrich_types_policy.optional()
    }),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const enrich_put_policy_response = types_acknowledged_response_base;

export const enrich_get_policy1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const enrich_get_policy1_response = z.object({
    policies: z.array(enrich_types_summary)
});

export const eql_search_request = z.object({
    body: eql_search,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        allow_partial_search_results: z.boolean().describe('If true, returns partial results if there are shard failures. If false, returns an error with no partial results.').optional(),
        allow_partial_sequence_results: z.boolean().describe('If true, sequence queries will return partial results in case of shard failures. If false, they will return no results at all.\nThis flag has effect only if allow_partial_search_results is true.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ccs_minimize_roundtrips: z.boolean().describe('Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        keep_alive: types_duration.optional(),
        keep_on_completion: z.boolean().describe('If true, the search and its results are stored on the cluster.').optional(),
        wait_for_completion_timeout: types_duration.optional()
    }).optional()
});

export const eql_search_response = eql_types_eql_search_response_base;

export const eql_search1_request = z.object({
    body: eql_search,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)').optional(),
        allow_partial_search_results: z.boolean().describe('If true, returns partial results if there are shard failures. If false, returns an error with no partial results.').optional(),
        allow_partial_sequence_results: z.boolean().describe('If true, sequence queries will return partial results in case of shard failures. If false, they will return no results at all.\nThis flag has effect only if allow_partial_search_results is true.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ccs_minimize_roundtrips: z.boolean().describe('Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        keep_alive: types_duration.optional(),
        keep_on_completion: z.boolean().describe('If true, the search and its results are stored on the cluster.').optional(),
        wait_for_completion_timeout: types_duration.optional()
    }).optional()
});

export const eql_search1_response = eql_types_eql_search_response_base;

export const esql_async_query_request = z.object({
    body: z.object({
        columnar: z.boolean().describe('By default, ES|QL returns results as rows. For example, FROM returns each individual document as one row. For the JSON, YAML, CBOR and smile formats, ES|QL can return the results in a columnar fashion where one row represents all the values of a certain column in the results.').optional(),
        filter: types_query_dsl_query_container.optional(),
        locale: z.string().optional(),
        params: z.array(types_field_value).describe('To avoid any attempts of hacking or code injection, extract the values in a separate list of parameters. Use question mark placeholders (?) in the query string for each of the parameters.').optional(),
        profile: z.boolean().describe('If provided and `true` the response will include an extra `profile` object\nwith information on how the query was executed. This information is for human debugging\nand its format can change at any time but it can give some insight into the performance\nof each part of the query.').optional(),
        query: z.string().describe('The ES|QL query API accepts an ES|QL query string in the query parameter, runs it, and returns the results.'),
        tables: z.record(z.record(esql_types_table_values_container)).describe('Tables to use with the LOOKUP operation. The top level key is the table\nname and the next level key is the column name.').optional(),
        include_ccs_metadata: z.boolean().describe('When set to `true` and performing a cross-cluster/cross-project query, the response will include an extra `_clusters`\nobject with information about the clusters that participated in the search along with info such as shards\ncount.').optional().default(false),
        include_execution_metadata: z.boolean().describe('When set to `true`, the response will include an extra `_clusters`\nobject with information about the clusters that participated in the search along with info such as shards\ncount.\nThis is similar to `include_ccs_metadata`, but it also returns metadata when the query is not CCS/CPS').optional().default(false),
        wait_for_completion_timeout: types_duration.optional(),
        keep_alive: types_duration.optional(),
        keep_on_completion: z.boolean().describe('Indicates whether the query and its results are stored in the cluster.\nIf false, the query and its results are stored in the cluster only if the request does not complete during the period set by the `wait_for_completion_timeout` parameter.').optional().default(false)
    }),
    path: z.never().optional(),
    query: z.object({
        allow_partial_results: z.boolean().describe('If `true`, partial results will be returned if there are shard failures, but the query can continue to execute on other clusters and shards.\nIf `false`, the query will fail if there are any failures.\n\nTo override the default behavior, you can set the `esql.query.allow_partial_results` cluster setting to `false`.').optional(),
        delimiter: z.string().describe('The character to use between values within a CSV row.\nIt is valid only for the CSV format.').optional(),
        drop_null_columns: z.boolean().describe('Indicates whether columns that are entirely `null` will be removed from the `columns` and `values` portion of the results.\nIf `true`, the response will include an extra section under the name `all_columns` which has the name of all the columns.').optional(),
        format: esql_types_esql_format.optional()
    }).optional()
});

export const esql_async_query_response = esql_types_async_esql_result;

export const esql_query_request = z.object({
    body: z.object({
        columnar: z.boolean().describe('By default, ES|QL returns results as rows. For example, FROM returns each individual document as one row. For the JSON, YAML, CBOR and smile formats, ES|QL can return the results in a columnar fashion where one row represents all the values of a certain column in the results.').optional(),
        filter: types_query_dsl_query_container.optional(),
        locale: z.string().optional(),
        params: z.array(esql_types_esql_param).describe('To avoid any attempts of hacking or code injection, extract the values in a separate list of parameters. Use question mark placeholders (?) in the query string for each of the parameters.').optional(),
        profile: z.boolean().describe('If provided and `true` the response will include an extra `profile` object\nwith information on how the query was executed. This information is for human debugging\nand its format can change at any time but it can give some insight into the performance\nof each part of the query.').optional(),
        query: z.string().describe('The ES|QL query API accepts an ES|QL query string in the query parameter, runs it, and returns the results.'),
        tables: z.record(z.record(esql_types_table_values_container)).describe('Tables to use with the LOOKUP operation. The top level key is the table\nname and the next level key is the column name.').optional(),
        include_ccs_metadata: z.boolean().describe('When set to `true` and performing a cross-cluster/cross-project query, the response will include an extra `_clusters`\nobject with information about the clusters that participated in the search along with info such as shards\ncount.').optional().default(false),
        include_execution_metadata: z.boolean().describe('When set to `true`, the response will include an extra `_clusters`\nobject with information about the clusters that participated in the search along with info such as shards\ncount.\nThis is similar to `include_ccs_metadata`, but it also returns metadata when the query is not CCS/CPS').optional().default(false)
    }),
    path: z.never().optional(),
    query: z.object({
        format: esql_types_esql_format.optional(),
        delimiter: z.string().describe('The character to use between values within a CSV row. Only valid for the CSV format.').optional(),
        drop_null_columns: z.boolean().describe('Should columns that are entirely `null` be removed from the `columns` and `values` portion of the results?\nDefaults to `false`. If `true` then the response will include an extra section under the name `all_columns` which has the name of all columns.').optional(),
        allow_partial_results: z.boolean().describe('If `true`, partial results will be returned if there are shard failures, but the query can continue to execute on other clusters and shards.\nIf `false`, the query will fail if there are any failures.\n\nTo override the default behavior, you can set the `esql.query.allow_partial_results` cluster setting to `false`.').optional()
    }).optional()
});

export const esql_query_response = esql_types_esql_result;

export const explain_request = z.object({
    body: explain.optional(),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        stored_fields: types_fields.optional(),
        q: z.string().describe('The query in the Lucene query string syntax.').optional()
    }).optional()
});

export const explain_response = z.object({
    _index: types_index_name,
    _id: types_id,
    matched: z.boolean(),
    explanation: global_explain_explanation_detail.optional(),
    get: types_inline_get.optional()
});

export const explain1_request = z.object({
    body: explain.optional(),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        routing: types_routing.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        stored_fields: types_fields.optional(),
        q: z.string().describe('The query in the Lucene query string syntax.').optional()
    }).optional()
});

export const explain1_response = z.object({
    _index: types_index_name,
    _id: types_id,
    matched: z.boolean(),
    explanation: global_explain_explanation_detail.optional(),
    get: types_inline_get.optional()
});

export const field_caps_request = z.object({
    body: field_caps.optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        fields: types_fields.optional(),
        ignore_unavailable: z.boolean().describe('If `true`, missing or closed indices are not included in the response.').optional(),
        include_unmapped: z.boolean().describe('If true, unmapped fields are included in the response.').optional(),
        filters: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        types: z.array(z.string()).describe('A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned.').optional(),
        include_empty_fields: z.boolean().describe('If false, empty fields are not included in the response.').optional()
    }).optional()
});

export const field_caps_response = z.object({
    indices: types_indices,
    fields: z.record(z.record(global_field_caps_field_capability))
});

export const field_caps1_request = z.object({
    body: field_caps.optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        fields: types_fields.optional(),
        ignore_unavailable: z.boolean().describe('If `true`, missing or closed indices are not included in the response.').optional(),
        include_unmapped: z.boolean().describe('If true, unmapped fields are included in the response.').optional(),
        filters: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        types: z.array(z.string()).describe('A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned.').optional(),
        include_empty_fields: z.boolean().describe('If false, empty fields are not included in the response.').optional()
    }).optional()
});

export const field_caps1_response = z.object({
    indices: types_indices,
    fields: z.record(z.record(global_field_caps_field_capability))
});

export const field_caps2_request = z.object({
    body: field_caps.optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        fields: types_fields.optional(),
        ignore_unavailable: z.boolean().describe('If `true`, missing or closed indices are not included in the response.').optional(),
        include_unmapped: z.boolean().describe('If true, unmapped fields are included in the response.').optional(),
        filters: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        types: z.array(z.string()).describe('A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned.').optional(),
        include_empty_fields: z.boolean().describe('If false, empty fields are not included in the response.').optional()
    }).optional()
});

export const field_caps2_response = z.object({
    indices: types_indices,
    fields: z.record(z.record(global_field_caps_field_capability))
});

export const field_caps3_request = z.object({
    body: field_caps.optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        fields: types_fields.optional(),
        ignore_unavailable: z.boolean().describe('If `true`, missing or closed indices are not included in the response.').optional(),
        include_unmapped: z.boolean().describe('If true, unmapped fields are included in the response.').optional(),
        filters: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        types: z.array(z.string()).describe('A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned.').optional(),
        include_empty_fields: z.boolean().describe('If false, empty fields are not included in the response.').optional()
    }).optional()
});

export const field_caps3_response = z.object({
    indices: types_indices,
    fields: z.record(z.record(global_field_caps_field_capability))
});

export const fleet_msearch_request = z.object({
    body: fleet_msearch,
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        max_concurrent_searches: z.number().describe('Maximum number of concurrent searches the multi search API can execute.').optional(),
        max_concurrent_shard_requests: z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.').optional(),
        pre_filter_shard_size: z.number().describe('Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.').optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.').optional(),
        typed_keys: z.boolean().describe('Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.').optional(),
        wait_for_checkpoints: z.array(fleet_types_checkpoint).describe('A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.').optional(),
        allow_partial_search_results: z.boolean().describe('If true, returns partial results if there are shard request timeouts or shard failures.\nIf false, returns an error with no partial results.\nDefaults to the configured cluster setting `search.default_allow_partial_results`, which is true by default.').optional()
    }).optional()
});

export const fleet_msearch_response = z.object({
    docs: z.array(global_msearch_response_item)
});

export const fleet_msearch1_request = z.object({
    body: fleet_msearch,
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        max_concurrent_searches: z.number().describe('Maximum number of concurrent searches the multi search API can execute.').optional(),
        max_concurrent_shard_requests: z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.').optional(),
        pre_filter_shard_size: z.number().describe('Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.').optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.').optional(),
        typed_keys: z.boolean().describe('Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.').optional(),
        wait_for_checkpoints: z.array(fleet_types_checkpoint).describe('A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.').optional(),
        allow_partial_search_results: z.boolean().describe('If true, returns partial results if there are shard request timeouts or shard failures.\nIf false, returns an error with no partial results.\nDefaults to the configured cluster setting `search.default_allow_partial_results`, which is true by default.').optional()
    }).optional()
});

export const fleet_msearch1_response = z.object({
    docs: z.array(global_msearch_response_item)
});

export const fleet_msearch2_request = z.object({
    body: fleet_msearch,
    path: z.object({
        index: z.union([
            types_index_name,
            types_index_alias
        ])
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        max_concurrent_searches: z.number().describe('Maximum number of concurrent searches the multi search API can execute.').optional(),
        max_concurrent_shard_requests: z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.').optional(),
        pre_filter_shard_size: z.number().describe('Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.').optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.').optional(),
        typed_keys: z.boolean().describe('Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.').optional(),
        wait_for_checkpoints: z.array(fleet_types_checkpoint).describe('A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.').optional(),
        allow_partial_search_results: z.boolean().describe('If true, returns partial results if there are shard request timeouts or shard failures.\nIf false, returns an error with no partial results.\nDefaults to the configured cluster setting `search.default_allow_partial_results`, which is true by default.').optional()
    }).optional()
});

export const fleet_msearch2_response = z.object({
    docs: z.array(global_msearch_response_item)
});

export const fleet_msearch3_request = z.object({
    body: fleet_msearch,
    path: z.object({
        index: z.union([
            types_index_name,
            types_index_alias
        ])
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        max_concurrent_searches: z.number().describe('Maximum number of concurrent searches the multi search API can execute.').optional(),
        max_concurrent_shard_requests: z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.').optional(),
        pre_filter_shard_size: z.number().describe('Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.').optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.').optional(),
        typed_keys: z.boolean().describe('Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.').optional(),
        wait_for_checkpoints: z.array(fleet_types_checkpoint).describe('A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.').optional(),
        allow_partial_search_results: z.boolean().describe('If true, returns partial results if there are shard request timeouts or shard failures.\nIf false, returns an error with no partial results.\nDefaults to the configured cluster setting `search.default_allow_partial_results`, which is true by default.').optional()
    }).optional()
});

export const fleet_msearch3_response = z.object({
    docs: z.array(global_msearch_response_item)
});

export const fleet_search_request = z.object({
    body: fleet_search,
    path: z.object({
        index: z.union([
            types_index_name,
            types_index_alias
        ])
    }),
    query: z.object({
        allow_no_indices: z.boolean().optional(),
        analyzer: z.string().optional(),
        analyze_wildcard: z.boolean().optional(),
        batched_reduce_size: z.number().optional(),
        ccs_minimize_roundtrips: z.boolean().optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().optional(),
        docvalue_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().optional(),
        ignore_throttled: z.boolean().optional(),
        ignore_unavailable: z.boolean().optional(),
        lenient: z.boolean().optional(),
        max_concurrent_shard_requests: z.number().optional(),
        preference: z.string().optional(),
        pre_filter_shard_size: z.number().optional(),
        request_cache: z.boolean().optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        search_type: types_search_type.optional(),
        stats: z.array(z.string()).optional(),
        stored_fields: types_fields.optional(),
        suggest_field: types_field.optional(),
        suggest_mode: types_suggest_mode.optional(),
        suggest_size: z.number().optional(),
        suggest_text: z.string().describe('The source text for which the suggestions should be returned.').optional(),
        terminate_after: z.number().optional(),
        timeout: types_duration.optional(),
        track_total_hits: global_search_types_track_hits.optional(),
        track_scores: z.boolean().optional(),
        typed_keys: z.boolean().optional(),
        rest_total_hits_as_int: z.boolean().optional(),
        version: z.boolean().optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        seq_no_primary_term: z.boolean().optional(),
        q: z.string().optional(),
        size: z.number().optional(),
        from: z.number().optional(),
        sort: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        wait_for_checkpoints: z.array(fleet_types_checkpoint).describe('A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.').optional(),
        allow_partial_search_results: z.boolean().describe('If true, returns partial results if there are shard request timeouts or shard failures.\nIf false, returns an error with no partial results.\nDefaults to the configured cluster setting `search.default_allow_partial_results`, which is true by default.').optional()
    }).optional()
});

export const fleet_search_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.record(types_aggregations_aggregate).optional(),
    _clusters: types_cluster_statistics.optional(),
    fields: z.record(z.record(z.unknown())).optional(),
    max_score: z.number().optional(),
    num_reduce_phases: z.number().optional(),
    profile: global_search_types_profile.optional(),
    pit_id: types_id.optional(),
    _scroll_id: types_scroll_id.optional(),
    suggest: z.record(z.array(global_search_types_suggest)).optional(),
    terminated_early: z.boolean().optional()
});

export const fleet_search1_request = z.object({
    body: fleet_search,
    path: z.object({
        index: z.union([
            types_index_name,
            types_index_alias
        ])
    }),
    query: z.object({
        allow_no_indices: z.boolean().optional(),
        analyzer: z.string().optional(),
        analyze_wildcard: z.boolean().optional(),
        batched_reduce_size: z.number().optional(),
        ccs_minimize_roundtrips: z.boolean().optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().optional(),
        docvalue_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().optional(),
        ignore_throttled: z.boolean().optional(),
        ignore_unavailable: z.boolean().optional(),
        lenient: z.boolean().optional(),
        max_concurrent_shard_requests: z.number().optional(),
        preference: z.string().optional(),
        pre_filter_shard_size: z.number().optional(),
        request_cache: z.boolean().optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        search_type: types_search_type.optional(),
        stats: z.array(z.string()).optional(),
        stored_fields: types_fields.optional(),
        suggest_field: types_field.optional(),
        suggest_mode: types_suggest_mode.optional(),
        suggest_size: z.number().optional(),
        suggest_text: z.string().describe('The source text for which the suggestions should be returned.').optional(),
        terminate_after: z.number().optional(),
        timeout: types_duration.optional(),
        track_total_hits: global_search_types_track_hits.optional(),
        track_scores: z.boolean().optional(),
        typed_keys: z.boolean().optional(),
        rest_total_hits_as_int: z.boolean().optional(),
        version: z.boolean().optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional(),
        seq_no_primary_term: z.boolean().optional(),
        q: z.string().optional(),
        size: z.number().optional(),
        from: z.number().optional(),
        sort: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        wait_for_checkpoints: z.array(fleet_types_checkpoint).describe('A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.').optional(),
        allow_partial_search_results: z.boolean().describe('If true, returns partial results if there are shard request timeouts or shard failures.\nIf false, returns an error with no partial results.\nDefaults to the configured cluster setting `search.default_allow_partial_results`, which is true by default.').optional()
    }).optional()
});

export const fleet_search1_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.record(types_aggregations_aggregate).optional(),
    _clusters: types_cluster_statistics.optional(),
    fields: z.record(z.record(z.unknown())).optional(),
    max_score: z.number().optional(),
    num_reduce_phases: z.number().optional(),
    profile: global_search_types_profile.optional(),
    pit_id: types_id.optional(),
    _scroll_id: types_scroll_id.optional(),
    suggest: z.record(z.array(global_search_types_suggest)).optional(),
    terminated_early: z.boolean().optional()
});

export const graph_explore_request = z.object({
    body: graph_explore,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        routing: types_routing.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const graph_explore_response = z.object({
    connections: z.array(graph_types_connection),
    failures: z.array(types_shard_failure),
    timed_out: z.boolean(),
    took: z.number(),
    vertices: z.array(graph_types_vertex)
});

export const graph_explore1_request = z.object({
    body: graph_explore,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        routing: types_routing.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const graph_explore1_response = z.object({
    connections: z.array(graph_types_connection),
    failures: z.array(types_shard_failure),
    timed_out: z.boolean(),
    took: z.number(),
    vertices: z.array(graph_types_vertex)
});

export const indices_analyze_request = z.object({
    body: indices_analyze,
    path: z.never().optional(),
    query: z.object({
        index: types_index_name.optional()
    }).optional()
});

export const indices_analyze_response = z.object({
    detail: indices_analyze_analyze_detail.optional(),
    tokens: z.array(indices_analyze_analyze_token).optional()
});

export const indices_analyze1_request = z.object({
    body: indices_analyze,
    path: z.never().optional(),
    query: z.object({
        index: types_index_name.optional()
    }).optional()
});

export const indices_analyze1_response = z.object({
    detail: indices_analyze_analyze_detail.optional(),
    tokens: z.array(indices_analyze_analyze_token).optional()
});

export const indices_analyze2_request = z.object({
    body: indices_analyze,
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        index: types_index_name.optional()
    }).optional()
});

export const indices_analyze2_response = z.object({
    detail: indices_analyze_analyze_detail.optional(),
    tokens: z.array(indices_analyze_analyze_token).optional()
});

export const indices_analyze3_request = z.object({
    body: indices_analyze,
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        index: types_index_name.optional()
    }).optional()
});

export const indices_analyze3_response = z.object({
    detail: indices_analyze_analyze_detail.optional(),
    tokens: z.array(indices_analyze_analyze_token).optional()
});

export const indices_clone1_request = z.object({
    body: indices_clone.optional(),
    path: z.object({
        index: types_index_name,
        target: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const indices_clone1_response = z.object({
    acknowledged: z.boolean(),
    index: types_index_name,
    shards_acknowledged: z.boolean()
});

export const indices_clone_request = z.object({
    body: indices_clone.optional(),
    path: z.object({
        index: types_index_name,
        target: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const indices_clone_response = z.object({
    acknowledged: z.boolean(),
    index: types_index_name,
    shards_acknowledged: z.boolean()
});

export const indices_get_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only\nmissing or closed indices. This behavior applies even if the request targets other open indices. For example,\na request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('If true, returns settings in flat format.').optional(),
        ignore_unavailable: z.boolean().describe('If false, requests that target a missing index return an error.').optional(),
        include_defaults: z.boolean().describe('If true, return all default settings in the response.').optional(),
        local: z.boolean().describe('If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.').optional(),
        master_timeout: types_duration.optional(),
        features: indices_get_features.optional()
    }).optional()
});

export const indices_get_response = z.record(indices_types_index_state);

export const indices_create_request = z.object({
    body: z.object({
        aliases: z.record(indices_types_alias).describe('Aliases for the index.').optional(),
        mappings: types_mapping_type_mapping.optional(),
        settings: indices_types_index_settings.optional()
    }).optional(),
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const indices_create_response = z.object({
    index: types_index_name,
    shards_acknowledged: z.boolean(),
    acknowledged: z.boolean()
});

export const indices_get_data_stream1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_data_stream_names
    }),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        include_defaults: z.boolean().describe('If true, returns all relevant default configurations for the index template.').optional(),
        master_timeout: types_duration.optional(),
        verbose: z.boolean().describe('Whether the maximum timestamp for each data stream should be calculated and returned.').optional()
    }).optional()
});

export const indices_get_data_stream1_response = z.object({
    data_streams: z.array(indices_types_data_stream)
});

export const indices_create_from1_request = z.object({
    body: indices_create_from.optional(),
    path: z.object({
        source: types_index_name,
        dest: types_index_name
    }),
    query: z.never().optional()
});

export const indices_create_from1_response = z.object({
    acknowledged: z.boolean(),
    index: types_index_name,
    shards_acknowledged: z.boolean()
});

export const indices_create_from_request = z.object({
    body: indices_create_from.optional(),
    path: z.object({
        source: types_index_name,
        dest: types_index_name
    }),
    query: z.never().optional()
});

export const indices_create_from_response = z.object({
    acknowledged: z.boolean(),
    index: types_index_name,
    shards_acknowledged: z.boolean()
});

export const indices_get_alias2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices,
        name: types_names
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_alias2_response = z.record(indices_get_alias_types_index_aliases);

export const indices_put_alias1_request = z.object({
    body: indices_put_alias.optional(),
    path: z.object({
        index: types_indices,
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_put_alias1_response = types_acknowledged_response_base;

export const indices_put_alias_request = z.object({
    body: indices_put_alias.optional(),
    path: z.object({
        index: types_indices,
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_put_alias_response = types_acknowledged_response_base;

export const indices_put_alias3_request = z.object({
    body: indices_put_alias.optional(),
    path: z.object({
        index: types_indices,
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_put_alias3_response = types_acknowledged_response_base;

export const indices_put_alias2_request = z.object({
    body: indices_put_alias.optional(),
    path: z.object({
        index: types_indices,
        name: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_put_alias2_response = types_acknowledged_response_base;

export const indices_get_index_template1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        local: z.boolean().describe('If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.').optional(),
        flat_settings: z.boolean().describe('If true, returns settings in flat format.').optional(),
        master_timeout: types_duration.optional(),
        include_defaults: z.boolean().describe('If true, returns all relevant default configurations for the index template.').optional()
    }).optional()
});

export const indices_get_index_template1_response = z.object({
    index_templates: z.array(indices_get_index_template_index_template_item)
});

export const indices_put_index_template1_request = z.object({
    body: indices_put_index_template,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        create: z.boolean().describe('If `true`, this request cannot replace or update existing index templates.').optional(),
        master_timeout: types_duration.optional(),
        cause: z.string().describe('User defined reason for creating/updating the index template').optional()
    }).optional()
});

export const indices_put_index_template1_response = types_acknowledged_response_base;

export const indices_put_index_template_request = z.object({
    body: indices_put_index_template,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        create: z.boolean().describe('If `true`, this request cannot replace or update existing index templates.').optional(),
        master_timeout: types_duration.optional(),
        cause: z.string().describe('User defined reason for creating/updating the index template').optional()
    }).optional()
});

export const indices_put_index_template_response = types_acknowledged_response_base;

export const indices_get_template1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_template1_response = z.record(indices_types_template_mapping);

export const indices_put_template1_request = z.object({
    body: indices_put_template,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        create: z.boolean().describe('If true, this request cannot replace or update existing index templates.').optional(),
        master_timeout: types_duration.optional(),
        order: z.number().describe('Order in which Elasticsearch applies this template if index\nmatches multiple templates.\n\nTemplates with lower \'order\' values are merged first. Templates with higher\n\'order\' values are merged later, overriding templates with lower values.').optional(),
        cause: z.string().describe('User defined reason for creating/updating the index template').optional()
    }).optional()
});

export const indices_put_template1_response = types_acknowledged_response_base;

export const indices_put_template_request = z.object({
    body: indices_put_template,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        create: z.boolean().describe('If true, this request cannot replace or update existing index templates.').optional(),
        master_timeout: types_duration.optional(),
        order: z.number().describe('Order in which Elasticsearch applies this template if index\nmatches multiple templates.\n\nTemplates with lower \'order\' values are merged first. Templates with higher\n\'order\' values are merged later, overriding templates with lower values.').optional(),
        cause: z.string().describe('User defined reason for creating/updating the index template').optional()
    }).optional()
});

export const indices_put_template_response = types_acknowledged_response_base;

export const indices_get_alias1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_alias1_response = z.record(indices_get_alias_types_index_aliases);

export const indices_get_alias_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_alias_response = z.record(indices_get_alias_types_index_aliases);

export const indices_get_alias3_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_alias3_response = z.record(indices_get_alias_types_index_aliases);

export const indices_get_data_stream_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        expand_wildcards: types_expand_wildcards.optional(),
        include_defaults: z.boolean().describe('If true, returns all relevant default configurations for the index template.').optional(),
        master_timeout: types_duration.optional(),
        verbose: z.boolean().describe('Whether the maximum timestamp for each data stream should be calculated and returned.').optional()
    }).optional()
});

export const indices_get_data_stream_response = z.object({
    data_streams: z.array(indices_types_data_stream)
});

export const indices_get_data_stream_mappings_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_indices
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_data_stream_mappings_response = z.object({
    data_streams: z.array(indices_get_data_stream_mappings_data_stream_mappings)
});

export const indices_put_data_stream_mappings_request = z.object({
    body: types_mapping_type_mapping,
    path: z.object({
        name: types_indices
    }),
    query: z.object({
        dry_run: z.boolean().describe('If `true`, the request does not actually change the mappings on any data streams. Instead, it\nsimulates changing the settings and reports back to the user what would have happened had these settings\nactually been applied.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_put_data_stream_mappings_response = z.object({
    data_streams: z.array(indices_put_data_stream_mappings_updated_data_stream_mappings)
});

export const indices_get_data_stream_settings_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_indices
    }),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_data_stream_settings_response = z.object({
    data_streams: z.array(indices_get_data_stream_settings_data_stream_settings)
});

export const indices_put_data_stream_settings_request = z.object({
    body: indices_types_index_settings,
    path: z.object({
        name: types_indices
    }),
    query: z.object({
        dry_run: z.boolean().describe('If `true`, the request does not actually change the settings on any data streams or indices. Instead, it\nsimulates changing the settings and reports back to the user what would have happened had these settings\nactually been applied.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_put_data_stream_settings_response = z.object({
    data_streams: z.array(indices_put_data_stream_settings_updated_data_stream_settings)
});

export const indices_get_field_mapping_request = z.object({
    body: z.never().optional(),
    path: z.object({
        fields: types_fields
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_defaults: z.boolean().describe('If `true`, return all default settings in the response.').optional()
    }).optional()
});

export const indices_get_field_mapping_response = z.record(indices_get_field_mapping_type_field_mappings);

export const indices_get_field_mapping1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices,
        fields: types_fields
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_defaults: z.boolean().describe('If `true`, return all default settings in the response.').optional()
    }).optional()
});

export const indices_get_field_mapping1_response = z.record(indices_get_field_mapping_type_field_mappings);

export const indices_get_index_template_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        local: z.boolean().describe('If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.').optional(),
        flat_settings: z.boolean().describe('If true, returns settings in flat format.').optional(),
        master_timeout: types_duration.optional(),
        include_defaults: z.boolean().describe('If true, returns all relevant default configurations for the index template.').optional()
    }).optional()
});

export const indices_get_index_template_response = z.object({
    index_templates: z.array(indices_get_index_template_index_template_item)
});

export const indices_get_mapping_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_mapping_response = z.record(indices_get_mapping_index_mapping_record);

export const indices_get_mapping1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_mapping1_response = z.record(indices_get_mapping_index_mapping_record);

export const indices_put_mapping1_request = z.object({
    body: indices_put_mapping,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        write_index_only: z.boolean().describe('If `true`, the mappings are applied only to the current write index for the target.').optional()
    }).optional()
});

export const indices_put_mapping1_response = types_indices_response_base;

export const indices_put_mapping_request = z.object({
    body: indices_put_mapping,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        write_index_only: z.boolean().describe('If `true`, the mappings are applied only to the current write index for the target.').optional()
    }).optional()
});

export const indices_put_mapping_response = types_indices_response_base;

export const indices_get_settings_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with foo but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_defaults: z.boolean().describe('If `true`, return all default settings in the response.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only. If\n`false`, information is retrieved from the master node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_settings_response = z.record(indices_types_index_state);

export const indices_put_settings_request = z.object({
    body: indices_put_settings,
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        ignore_unavailable: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        master_timeout: types_duration.optional(),
        preserve_existing: z.boolean().describe('If `true`, existing index settings remain unchanged.').optional(),
        reopen: z.boolean().describe('Whether to close and reopen the index to apply non-dynamic settings.\nIf set to `true` the indices to which the settings are being applied\nwill be closed temporarily and then reopened in order to apply the changes.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_put_settings_response = types_acknowledged_response_base;

export const indices_get_settings1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with foo but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_defaults: z.boolean().describe('If `true`, return all default settings in the response.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only. If\n`false`, information is retrieved from the master node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_settings1_response = z.record(indices_types_index_state);

export const indices_put_settings1_request = z.object({
    body: indices_put_settings,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        ignore_unavailable: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        master_timeout: types_duration.optional(),
        preserve_existing: z.boolean().describe('If `true`, existing index settings remain unchanged.').optional(),
        reopen: z.boolean().describe('Whether to close and reopen the index to apply non-dynamic settings.\nIf set to `true` the indices to which the settings are being applied\nwill be closed temporarily and then reopened in order to apply the changes.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_put_settings1_response = types_acknowledged_response_base;

export const indices_get_settings2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices,
        name: types_names
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with foo but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_defaults: z.boolean().describe('If `true`, return all default settings in the response.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only. If\n`false`, information is retrieved from the master node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_settings2_response = z.record(indices_types_index_state);

export const indices_get_settings3_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with foo but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_defaults: z.boolean().describe('If `true`, return all default settings in the response.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only. If\n`false`, information is retrieved from the master node.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_settings3_response = z.record(indices_types_index_state);

export const indices_get_template_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        flat_settings: z.boolean().describe('If `true`, returns settings in flat format.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.').optional(),
        master_timeout: types_duration.optional()
    }).optional()
});

export const indices_get_template_response = z.record(indices_types_template_mapping);

export const indices_rollover_request = z.object({
    body: indices_rollover.optional(),
    path: z.object({
        alias: types_index_alias
    }),
    query: z.object({
        dry_run: z.boolean().describe('If `true`, checks whether the current index satisfies the specified conditions but does not perform a rollover.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        lazy: z.boolean().describe('If set to true, the rollover action will only mark a data stream to signal that it needs to be rolled over at the next write.\nOnly allowed on data streams.').optional()
    }).optional()
});

export const indices_rollover_response = z.object({
    acknowledged: z.boolean(),
    conditions: z.record(z.boolean()),
    dry_run: z.boolean(),
    new_index: z.string(),
    old_index: z.string(),
    rolled_over: z.boolean(),
    shards_acknowledged: z.boolean()
});

export const indices_rollover1_request = z.object({
    body: indices_rollover.optional(),
    path: z.object({
        alias: types_index_alias,
        new_index: types_index_name
    }),
    query: z.object({
        dry_run: z.boolean().describe('If `true`, checks whether the current index satisfies the specified conditions but does not perform a rollover.').optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        lazy: z.boolean().describe('If set to true, the rollover action will only mark a data stream to signal that it needs to be rolled over at the next write.\nOnly allowed on data streams.').optional()
    }).optional()
});

export const indices_rollover1_response = z.object({
    acknowledged: z.boolean(),
    conditions: z.record(z.boolean()),
    dry_run: z.boolean(),
    new_index: z.string(),
    old_index: z.string(),
    rolled_over: z.boolean(),
    shards_acknowledged: z.boolean()
});

export const indices_shrink1_request = z.object({
    body: indices_shrink,
    path: z.object({
        index: types_index_name,
        target: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const indices_shrink1_response = z.object({
    acknowledged: z.boolean(),
    shards_acknowledged: z.boolean(),
    index: types_index_name
});

export const indices_shrink_request = z.object({
    body: indices_shrink,
    path: z.object({
        index: types_index_name,
        target: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const indices_shrink_response = z.object({
    acknowledged: z.boolean(),
    shards_acknowledged: z.boolean(),
    index: types_index_name
});

export const indices_simulate_index_template_request = z.object({
    body: indices_types_index_template.optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        create: z.boolean().describe('Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one').optional(),
        cause: z.string().describe('User defined reason for dry-run creating the new template for simulation purposes').optional(),
        master_timeout: types_duration.optional(),
        include_defaults: z.boolean().describe('If true, returns all relevant default configurations for the index template.').optional()
    }).optional()
});

export const indices_simulate_index_template_response = z.object({
    overlapping: z.array(indices_simulate_template_overlapping).optional(),
    template: indices_simulate_template_template
});

export const indices_simulate_template_request = z.object({
    body: indices_simulate_template.optional(),
    path: z.never().optional(),
    query: z.object({
        create: z.boolean().describe('If true, the template passed in the body is only used if no existing templates match the same index patterns. If false, the simulation uses the template with the highest priority. Note that the template is not permanently added or updated in either case; it is only used for the simulation.').optional(),
        cause: z.string().describe('User defined reason for dry-run creating the new template for simulation purposes').optional(),
        master_timeout: types_duration.optional(),
        include_defaults: z.boolean().describe('If true, returns all relevant default configurations for the index template.').optional()
    }).optional()
});

export const indices_simulate_template_response = z.object({
    overlapping: z.array(indices_simulate_template_overlapping).optional(),
    template: indices_simulate_template_template
});

export const indices_simulate_template1_request = z.object({
    body: indices_simulate_template.optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        create: z.boolean().describe('If true, the template passed in the body is only used if no existing templates match the same index patterns. If false, the simulation uses the template with the highest priority. Note that the template is not permanently added or updated in either case; it is only used for the simulation.').optional(),
        cause: z.string().describe('User defined reason for dry-run creating the new template for simulation purposes').optional(),
        master_timeout: types_duration.optional(),
        include_defaults: z.boolean().describe('If true, returns all relevant default configurations for the index template.').optional()
    }).optional()
});

export const indices_simulate_template1_response = z.object({
    overlapping: z.array(indices_simulate_template_overlapping).optional(),
    template: indices_simulate_template_template
});

export const indices_split1_request = z.object({
    body: indices_split,
    path: z.object({
        index: types_index_name,
        target: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const indices_split1_response = z.object({
    acknowledged: z.boolean(),
    shards_acknowledged: z.boolean(),
    index: types_index_name
});

export const indices_split_request = z.object({
    body: indices_split,
    path: z.object({
        index: types_index_name,
        target: types_index_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional()
    }).optional()
});

export const indices_split_response = z.object({
    acknowledged: z.boolean(),
    shards_acknowledged: z.boolean(),
    index: types_index_name
});

export const indices_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        completion_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        fielddata_fields: types_fields.optional(),
        fields: types_fields.optional(),
        forbid_closed_indices: z.boolean().describe('If true, statistics are not collected from closed indices.').optional(),
        groups: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        include_segment_file_sizes: z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).').optional(),
        include_unloaded_segments: z.boolean().describe('If true, the response includes information from segments that are not loaded into memory.').optional(),
        level: types_level.optional()
    }).optional()
});

export const indices_stats_response = z.object({
    indices: z.record(indices_stats_indices_stats).optional(),
    _shards: types_shard_statistics,
    _all: indices_stats_indices_stats
});

export const indices_stats1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        metric: types_common_stats_flags
    }),
    query: z.object({
        completion_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        fielddata_fields: types_fields.optional(),
        fields: types_fields.optional(),
        forbid_closed_indices: z.boolean().describe('If true, statistics are not collected from closed indices.').optional(),
        groups: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        include_segment_file_sizes: z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).').optional(),
        include_unloaded_segments: z.boolean().describe('If true, the response includes information from segments that are not loaded into memory.').optional(),
        level: types_level.optional()
    }).optional()
});

export const indices_stats1_response = z.object({
    indices: z.record(indices_stats_indices_stats).optional(),
    _shards: types_shard_statistics,
    _all: indices_stats_indices_stats
});

export const indices_stats2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        completion_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        fielddata_fields: types_fields.optional(),
        fields: types_fields.optional(),
        forbid_closed_indices: z.boolean().describe('If true, statistics are not collected from closed indices.').optional(),
        groups: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        include_segment_file_sizes: z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).').optional(),
        include_unloaded_segments: z.boolean().describe('If true, the response includes information from segments that are not loaded into memory.').optional(),
        level: types_level.optional()
    }).optional()
});

export const indices_stats2_response = z.object({
    indices: z.record(indices_stats_indices_stats).optional(),
    _shards: types_shard_statistics,
    _all: indices_stats_indices_stats
});

export const indices_stats3_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices,
        metric: types_common_stats_flags
    }),
    query: z.object({
        completion_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        fielddata_fields: types_fields.optional(),
        fields: types_fields.optional(),
        forbid_closed_indices: z.boolean().describe('If true, statistics are not collected from closed indices.').optional(),
        groups: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        include_segment_file_sizes: z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).').optional(),
        include_unloaded_segments: z.boolean().describe('If true, the response includes information from segments that are not loaded into memory.').optional(),
        level: types_level.optional()
    }).optional()
});

export const indices_stats3_response = z.object({
    indices: z.record(indices_stats_indices_stats).optional(),
    _shards: types_shard_statistics,
    _all: indices_stats_indices_stats
});

export const indices_update_aliases_request = z.object({
    body: z.object({
        actions: z.array(indices_update_aliases_action).describe('Actions to perform.').optional()
    }),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const indices_update_aliases_response = types_acknowledged_response_base;

export const indices_validate_query_request = z.object({
    body: indices_validate_query.optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        all_shards: z.boolean().describe('If `true`, the validation is executed on all shards instead of one random shard per index.').optional(),
        analyzer: z.string().describe('Analyzer to use for the query string.\nThis parameter can only be used when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('Field to use as default where no field prefix is given in the query string.\nThis parameter can only be used when the `q` query string parameter is specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the response returns detailed information if an error has occurred.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.').optional(),
        rewrite: z.boolean().describe('If `true`, returns a more detailed explanation showing the actual Lucene query that will be executed.').optional(),
        q: z.string().describe('Query in the Lucene query string syntax.').optional()
    }).optional()
});

export const indices_validate_query_response = z.object({
    explanations: z.array(indices_validate_query_indices_validation_explanation).optional(),
    _shards: types_shard_statistics.optional(),
    valid: z.boolean(),
    error: z.string().optional()
});

export const indices_validate_query1_request = z.object({
    body: indices_validate_query.optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        all_shards: z.boolean().describe('If `true`, the validation is executed on all shards instead of one random shard per index.').optional(),
        analyzer: z.string().describe('Analyzer to use for the query string.\nThis parameter can only be used when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('Field to use as default where no field prefix is given in the query string.\nThis parameter can only be used when the `q` query string parameter is specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the response returns detailed information if an error has occurred.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.').optional(),
        rewrite: z.boolean().describe('If `true`, returns a more detailed explanation showing the actual Lucene query that will be executed.').optional(),
        q: z.string().describe('Query in the Lucene query string syntax.').optional()
    }).optional()
});

export const indices_validate_query1_response = z.object({
    explanations: z.array(indices_validate_query_indices_validation_explanation).optional(),
    _shards: types_shard_statistics.optional(),
    valid: z.boolean(),
    error: z.string().optional()
});

export const indices_validate_query2_request = z.object({
    body: indices_validate_query.optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        all_shards: z.boolean().describe('If `true`, the validation is executed on all shards instead of one random shard per index.').optional(),
        analyzer: z.string().describe('Analyzer to use for the query string.\nThis parameter can only be used when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('Field to use as default where no field prefix is given in the query string.\nThis parameter can only be used when the `q` query string parameter is specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the response returns detailed information if an error has occurred.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.').optional(),
        rewrite: z.boolean().describe('If `true`, returns a more detailed explanation showing the actual Lucene query that will be executed.').optional(),
        q: z.string().describe('Query in the Lucene query string syntax.').optional()
    }).optional()
});

export const indices_validate_query2_response = z.object({
    explanations: z.array(indices_validate_query_indices_validation_explanation).optional(),
    _shards: types_shard_statistics.optional(),
    valid: z.boolean(),
    error: z.string().optional()
});

export const indices_validate_query3_request = z.object({
    body: indices_validate_query.optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.').optional(),
        all_shards: z.boolean().describe('If `true`, the validation is executed on all shards instead of one random shard per index.').optional(),
        analyzer: z.string().describe('Analyzer to use for the query string.\nThis parameter can only be used when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('Field to use as default where no field prefix is given in the query string.\nThis parameter can only be used when the `q` query string parameter is specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the response returns detailed information if an error has occurred.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.').optional(),
        rewrite: z.boolean().describe('If `true`, returns a more detailed explanation showing the actual Lucene query that will be executed.').optional(),
        q: z.string().describe('Query in the Lucene query string syntax.').optional()
    }).optional()
});

export const indices_validate_query3_response = z.object({
    explanations: z.array(indices_validate_query_indices_validation_explanation).optional(),
    _shards: types_shard_statistics.optional(),
    valid: z.boolean(),
    error: z.string().optional()
});

export const ingest_get_pipeline1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        summary: z.boolean().describe('Return pipelines without their definitions (default: false)').optional()
    }).optional()
});

export const ingest_get_pipeline1_response = z.record(ingest_types_pipeline);

export const ingest_put_pipeline_request = z.object({
    body: z.object({
        _meta: types_metadata.optional(),
        description: z.string().describe('Description of the ingest pipeline.').optional(),
        on_failure: z.array(ingest_types_processor_container).describe('Processors to run immediately after a processor failure. Each processor supports a processor-level `on_failure` value. If a processor without an `on_failure` value fails, Elasticsearch uses this pipeline-level parameter as a fallback. The processors in this parameter run sequentially in the order specified. Elasticsearch will not attempt to run the pipeline\'s remaining processors.').optional(),
        processors: z.array(ingest_types_processor_container).describe('Processors used to perform transformations on documents before indexing. Processors run sequentially in the order specified.').optional(),
        version: types_version_number.optional(),
        deprecated: z.boolean().describe('Marks this ingest pipeline as deprecated.\nWhen a deprecated ingest pipeline is referenced as the default or final pipeline when creating or updating a non-deprecated index template, Elasticsearch will emit a deprecation warning.').optional().default(false),
        field_access_pattern: ingest_types_field_access_pattern.optional()
    }),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional(),
        if_version: types_version_number.optional()
    }).optional()
});

export const ingest_put_pipeline_response = types_acknowledged_response_base;

export const ingest_get_pipeline_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        summary: z.boolean().describe('Return pipelines without their definitions (default: false)').optional()
    }).optional()
});

export const ingest_get_pipeline_response = z.record(ingest_types_pipeline);

export const ingest_simulate_request = z.object({
    body: ingest_simulate,
    path: z.never().optional(),
    query: z.object({
        verbose: z.boolean().describe('If `true`, the response includes output data for each processor in the executed pipeline.').optional()
    }).optional()
});

export const ingest_simulate_response = z.object({
    docs: z.array(ingest_types_simulate_document_result)
});

export const ingest_simulate1_request = z.object({
    body: ingest_simulate,
    path: z.never().optional(),
    query: z.object({
        verbose: z.boolean().describe('If `true`, the response includes output data for each processor in the executed pipeline.').optional()
    }).optional()
});

export const ingest_simulate1_response = z.object({
    docs: z.array(ingest_types_simulate_document_result)
});

export const ingest_simulate2_request = z.object({
    body: ingest_simulate,
    path: z.object({
        id: types_id
    }),
    query: z.object({
        verbose: z.boolean().describe('If `true`, the response includes output data for each processor in the executed pipeline.').optional()
    }).optional()
});

export const ingest_simulate2_response = z.object({
    docs: z.array(ingest_types_simulate_document_result)
});

export const ingest_simulate3_request = z.object({
    body: ingest_simulate,
    path: z.object({
        id: types_id
    }),
    query: z.object({
        verbose: z.boolean().describe('If `true`, the response includes output data for each processor in the executed pipeline.').optional()
    }).optional()
});

export const ingest_simulate3_response = z.object({
    docs: z.array(ingest_types_simulate_document_result)
});

export const ml_get_data_frame_analytics_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value returns an empty data_frame_analytics array when there\nare no matches and the subset of results when there are partial matches.\nIf this parameter is `false`, the request returns a 404 status code when\nthere are no matches or only partial matches.').optional(),
        from: z.number().describe('Skips the specified number of data frame analytics jobs.').optional(),
        size: z.number().describe('Specifies the maximum number of data frame analytics jobs to obtain.').optional(),
        exclude_generated: z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.').optional()
    }).optional()
});

export const ml_get_data_frame_analytics_response = z.object({
    count: z.number(),
    data_frame_analytics: z.array(ml_types_dataframe_analytics_summary).describe('An array of data frame analytics job resources, which are sorted by the id value in ascending order.')
});

export const ml_put_data_frame_analytics_request = z.object({
    body: z.object({
        allow_lazy_start: z.boolean().describe('Specifies whether this job can start when there is insufficient machine\nlearning node capacity for it to be immediately assigned to a node. If\nset to `false` and a machine learning node with capacity to run the job\ncannot be immediately found, the API returns an error. If set to `true`,\nthe API does not return an error; the job waits in the `starting` state\nuntil sufficient machine learning node capacity is available. This\nbehavior is also affected by the cluster-wide\n`xpack.ml.max_lazy_ml_nodes` setting.').optional().default(false),
        analysis: ml_types_dataframe_analysis_container,
        analyzed_fields: ml_types_dataframe_analysis_analyzed_fields.optional(),
        description: z.string().describe('A description of the job.').optional(),
        dest: ml_types_dataframe_analytics_destination,
        max_num_threads: z.number().describe('The maximum number of threads to be used by the analysis. Using more\nthreads may decrease the time necessary to complete the analysis at the\ncost of using more CPU. Note that the process may use additional threads\nfor operational functionality other than the analysis itself.').optional().default(1),
        _meta: types_metadata.optional(),
        model_memory_limit: z.string().describe('The approximate maximum amount of memory resources that are permitted for\nanalytical processing. If your `elasticsearch.yml` file contains an\n`xpack.ml.max_model_memory_limit` setting, an error occurs when you try\nto create data frame analytics jobs that have `model_memory_limit` values\ngreater than that setting.').optional().default('1gb'),
        source: ml_types_dataframe_analytics_source,
        headers: types_http_headers.optional(),
        version: types_version_string.optional()
    }),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const ml_put_data_frame_analytics_response = z.object({
    authorization: ml_types_dataframe_analytics_authorization.optional(),
    allow_lazy_start: z.boolean(),
    analysis: ml_types_dataframe_analysis_container,
    analyzed_fields: ml_types_dataframe_analysis_analyzed_fields.optional(),
    create_time: types_epoch_time_unit_millis,
    description: z.string().optional(),
    dest: ml_types_dataframe_analytics_destination,
    id: types_id,
    max_num_threads: z.number(),
    _meta: types_metadata.optional(),
    model_memory_limit: z.string(),
    source: ml_types_dataframe_analytics_source,
    version: types_version_string
});

export const ml_get_datafeeds_request = z.object({
    body: z.never().optional(),
    path: z.object({
        datafeed_id: types_ids
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no datafeeds that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `datafeeds` array\nwhen there are no matches and the subset of results when there are\npartial matches. If this parameter is `false`, the request returns a\n`404` status code when there are no matches or only partial matches.').optional(),
        exclude_generated: z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.').optional()
    }).optional()
});

export const ml_get_datafeeds_response = z.object({
    count: z.number(),
    datafeeds: z.array(ml_types_datafeed)
});

export const ml_put_datafeed_request = z.object({
    body: z.object({
        aggregations: z.record(types_aggregations_aggregation_container).describe('If set, the datafeed performs aggregation searches.\nSupport for aggregations is limited and should be used only with low cardinality data.').optional(),
        chunking_config: ml_types_chunking_config.optional(),
        delayed_data_check_config: ml_types_delayed_data_check_config.optional(),
        frequency: types_duration.optional(),
        indices: types_indices.optional(),
        indices_options: types_indices_options.optional(),
        job_id: types_id.optional(),
        max_empty_searches: z.number().describe('If a real-time datafeed has never seen any data (including during any initial training period), it automatically\nstops and closes the associated job after this many real-time searches return no documents. In other words,\nit stops after `frequency` times `max_empty_searches` of real-time operation. If not set, a datafeed with no\nend time that sees no data remains started until it is explicitly stopped. By default, it is not set.').optional(),
        query: types_query_dsl_query_container.optional(),
        query_delay: types_duration.optional(),
        runtime_mappings: types_mapping_runtime_fields.optional(),
        script_fields: z.record(types_script_field).describe('Specifies scripts that evaluate custom expressions and returns script fields to the datafeed.\nThe detector configuration objects in a job can contain functions that use these script fields.').optional(),
        scroll_size: z.number().describe('The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations.\nThe maximum value is the value of `index.max_result_window`, which is 10,000 by default.').optional().default(1000),
        headers: types_http_headers.optional()
    }),
    path: z.object({
        datafeed_id: types_id
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If true, wildcard indices expressions that resolve into no concrete indices are ignored. This includes the `_all`\nstring or when no indices are specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded, or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, unavailable indices (missing or closed) are ignored.').optional()
    }).optional()
});

export const ml_put_datafeed_response = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).optional(),
    authorization: ml_types_datafeed_authorization.optional(),
    chunking_config: ml_types_chunking_config,
    delayed_data_check_config: ml_types_delayed_data_check_config.optional(),
    datafeed_id: types_id,
    frequency: types_duration.optional(),
    indices: z.array(z.string()),
    job_id: types_id,
    indices_options: types_indices_options.optional(),
    max_empty_searches: z.number().optional(),
    query: types_query_dsl_query_container,
    query_delay: types_duration,
    runtime_mappings: types_mapping_runtime_fields.optional(),
    script_fields: z.record(types_script_field).optional(),
    scroll_size: z.number()
});

export const ml_get_jobs_request = z.object({
    body: z.never().optional(),
    path: z.object({
        job_id: types_ids
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `jobs` array when\nthere are no matches and the subset of results when there are partial\nmatches. If this parameter is `false`, the request returns a `404` status\ncode when there are no matches or only partial matches.').optional(),
        exclude_generated: z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.').optional()
    }).optional()
});

export const ml_get_jobs_response = z.object({
    count: z.number(),
    jobs: z.array(ml_types_job)
});

export const ml_put_job_request = z.object({
    body: z.object({
        allow_lazy_open: z.boolean().describe('Advanced configuration option. Specifies whether this job can open when there is insufficient machine learning node capacity for it to be immediately assigned to a node. By default, if a machine learning node with capacity to run the job cannot immediately be found, the open anomaly detection jobs API returns an error. However, this is also subject to the cluster-wide `xpack.ml.max_lazy_ml_nodes` setting. If this option is set to true, the open anomaly detection jobs API does not return an error and the job waits in the opening state until sufficient machine learning node capacity is available.').optional().default(false),
        analysis_config: ml_types_analysis_config,
        analysis_limits: ml_types_analysis_limits.optional(),
        background_persist_interval: types_duration.optional(),
        custom_settings: ml_types_custom_settings.optional(),
        daily_model_snapshot_retention_after_days: z.number().describe('Advanced configuration option, which affects the automatic removal of old model snapshots for this job. It specifies a period of time (in days) after which only the first snapshot per day is retained. This period is relative to the timestamp of the most recent snapshot for this job. Valid values range from 0 to `model_snapshot_retention_days`.').optional().default(1),
        data_description: ml_types_data_description,
        datafeed_config: ml_types_datafeed_config.optional(),
        description: z.string().describe('A description of the job.').optional(),
        job_id: types_id.optional(),
        groups: z.array(z.string()).describe('A list of job groups. A job can belong to no groups or many.').optional(),
        model_plot_config: ml_types_model_plot_config.optional(),
        model_snapshot_retention_days: z.number().describe('Advanced configuration option, which affects the automatic removal of old model snapshots for this job. It specifies the maximum period of time (in days) that snapshots are retained. This period is relative to the timestamp of the most recent snapshot for this job. By default, snapshots ten days older than the newest snapshot are deleted.').optional().default(10),
        renormalization_window_days: z.number().describe('Advanced configuration option. The period over which adjustments to the score are applied, as new data is seen. The default value is the longer of 30 days or 100 bucket spans.').optional(),
        results_index_name: types_index_name.optional(),
        results_retention_days: z.number().describe('Advanced configuration option. The period of time (in days) that results are retained. Age is calculated relative to the timestamp of the latest bucket result. If this property has a non-null value, once per day at 00:30 (server time), results that are the specified number of days older than the latest bucket result are deleted from Elasticsearch. The default value is null, which means all results are retained. Annotations generated by the system also count as results for retention purposes; they are deleted after the same number of days as results. Annotations added by users are retained forever.').optional()
    }),
    path: z.object({
        job_id: types_id
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `true`, wildcard indices expressions that resolve into no concrete indices are ignored. This includes the\n`_all` string or when no indices are specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If `true`, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If `true`, unavailable indices (missing or closed) are ignored.').optional()
    }).optional()
});

export const ml_put_job_response = z.object({
    allow_lazy_open: z.boolean(),
    analysis_config: ml_types_analysis_config_read,
    analysis_limits: ml_types_analysis_limits,
    background_persist_interval: types_duration.optional(),
    create_time: types_date_time,
    custom_settings: ml_types_custom_settings.optional(),
    daily_model_snapshot_retention_after_days: z.number(),
    data_description: ml_types_data_description,
    datafeed_config: ml_types_datafeed.optional(),
    description: z.string().optional(),
    groups: z.array(z.string()).optional(),
    job_id: types_id,
    job_type: z.string(),
    job_version: z.string(),
    model_plot_config: ml_types_model_plot_config.optional(),
    model_snapshot_id: types_id.optional(),
    model_snapshot_retention_days: z.number(),
    renormalization_window_days: z.number().optional(),
    results_index_name: z.string(),
    results_retention_days: z.number().optional()
});

export const ml_get_trained_models_request = z.object({
    body: z.never().optional(),
    path: z.object({
        model_id: types_ids
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n- Contains wildcard expressions and there are no models that match.\n- Contains the _all string or no identifiers and there are no matches.\n- Contains wildcard expressions and there are only partial matches.\n\nIf true, it returns an empty array when there are no matches and the\nsubset of results when there are partial matches.').optional(),
        decompress_definition: z.boolean().describe('Specifies whether the included model definition should be returned as a\nJSON map (true) or in a custom compressed format (false).').optional(),
        exclude_generated: z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.').optional(),
        from: z.number().describe('Skips the specified number of models.').optional(),
        include: ml_types_include.optional(),
        size: z.number().describe('Specifies the maximum number of models to obtain.').optional(),
        tags: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const ml_get_trained_models_response = z.object({
    count: z.number(),
    trained_model_configs: z.array(ml_types_trained_model_config).describe('An array of trained model resources, which are sorted by the model_id value in ascending order.')
});

export const ml_put_trained_model_request = z.object({
    body: z.object({
        compressed_definition: z.string().describe('The compressed (GZipped and Base64 encoded) inference definition of the\nmodel. If compressed_definition is specified, then definition cannot be\nspecified.').optional(),
        definition: ml_put_trained_model_definition.optional(),
        description: z.string().describe('A human-readable description of the inference trained model.').optional(),
        inference_config: ml_types_inference_config_create_container.optional(),
        input: ml_put_trained_model_input.optional(),
        metadata: z.record(z.unknown()).describe('An object map that contains metadata about the model.').optional(),
        model_type: ml_types_trained_model_type.optional(),
        model_size_bytes: z.number().describe('The estimated memory usage in bytes to keep the trained model in memory.\nThis property is supported only if defer_definition_decompression is true\nor the model definition is not supplied.').optional(),
        platform_architecture: z.string().describe('The platform architecture (if applicable) of the trained mode. If the model\nonly works on one platform, because it is heavily optimized for a particular\nprocessor architecture and OS combination, then this field specifies which.\nThe format of the string must match the platform identifiers used by Elasticsearch,\nso one of, `linux-x86_64`, `linux-aarch64`, `darwin-x86_64`, `darwin-aarch64`,\nor `windows-x86_64`. For portable models (those that work independent of processor\narchitecture or OS features), leave this field unset.').optional(),
        tags: z.array(z.string()).describe('An array of tags to organize the model.').optional(),
        prefix_strings: ml_types_trained_model_prefix_strings.optional()
    }),
    path: z.object({
        model_id: types_id
    }),
    query: z.object({
        defer_definition_decompression: z.boolean().describe('If set to `true` and a `compressed_definition` is provided,\nthe request defers definition decompression and skips relevant\nvalidations.').optional(),
        wait_for_completion: z.boolean().describe('Whether to wait for all child operations (e.g. model download)\nto complete.').optional()
    }).optional()
});

export const ml_put_trained_model_response = ml_types_trained_model_config;

export const ml_estimate_model_memory_request = z.object({
    body: z.object({
        analysis_config: ml_types_analysis_config.optional(),
        max_bucket_cardinality: z.record(z.number()).describe('Estimates of the highest cardinality in a single bucket that is observed\nfor influencer fields over the time period that the job analyzes data.\nTo produce a good answer, values must be provided for all influencer\nfields. Providing values for fields that are not listed as `influencers`\nhas no effect on the estimation.').optional(),
        overall_cardinality: z.record(z.number()).describe('Estimates of the cardinality that is observed for fields over the whole\ntime period that the job analyzes data. To produce a good answer, values\nmust be provided for fields referenced in the `by_field_name`,\n`over_field_name` and `partition_field_name` of any detectors. Providing\nvalues for other fields has no effect on the estimation. It can be\nomitted from the request if no detectors have a `by_field_name`,\n`over_field_name` or `partition_field_name`.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ml_estimate_model_memory_response = z.object({
    model_memory_estimate: z.string()
});

export const ml_evaluate_data_frame_request = z.object({
    body: z.object({
        evaluation: ml_types_dataframe_evaluation_container,
        index: types_index_name,
        query: types_query_dsl_query_container.optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ml_evaluate_data_frame_response = z.object({
    classification: ml_evaluate_data_frame_dataframe_classification_summary.optional(),
    outlier_detection: ml_evaluate_data_frame_dataframe_outlier_detection_summary.optional(),
    regression: ml_evaluate_data_frame_dataframe_regression_summary.optional()
});

export const ml_explain_data_frame_analytics_request = z.object({
    body: ml_explain_data_frame_analytics.optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ml_explain_data_frame_analytics_response = z.object({
    field_selection: z.array(ml_types_dataframe_analytics_field_selection).describe('An array of objects that explain selection for each field, sorted by the field names.'),
    memory_estimation: ml_types_dataframe_analytics_memory_estimation
});

export const ml_explain_data_frame_analytics1_request = z.object({
    body: ml_explain_data_frame_analytics.optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ml_explain_data_frame_analytics1_response = z.object({
    field_selection: z.array(ml_types_dataframe_analytics_field_selection).describe('An array of objects that explain selection for each field, sorted by the field names.'),
    memory_estimation: ml_types_dataframe_analytics_memory_estimation
});

export const ml_explain_data_frame_analytics2_request = z.object({
    body: ml_explain_data_frame_analytics.optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const ml_explain_data_frame_analytics2_response = z.object({
    field_selection: z.array(ml_types_dataframe_analytics_field_selection).describe('An array of objects that explain selection for each field, sorted by the field names.'),
    memory_estimation: ml_types_dataframe_analytics_memory_estimation
});

export const ml_explain_data_frame_analytics3_request = z.object({
    body: ml_explain_data_frame_analytics.optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const ml_explain_data_frame_analytics3_response = z.object({
    field_selection: z.array(ml_types_dataframe_analytics_field_selection).describe('An array of objects that explain selection for each field, sorted by the field names.'),
    memory_estimation: ml_types_dataframe_analytics_memory_estimation
});

export const ml_get_data_frame_analytics1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value returns an empty data_frame_analytics array when there\nare no matches and the subset of results when there are partial matches.\nIf this parameter is `false`, the request returns a 404 status code when\nthere are no matches or only partial matches.').optional(),
        from: z.number().describe('Skips the specified number of data frame analytics jobs.').optional(),
        size: z.number().describe('Specifies the maximum number of data frame analytics jobs to obtain.').optional(),
        exclude_generated: z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.').optional()
    }).optional()
});

export const ml_get_data_frame_analytics1_response = z.object({
    count: z.number(),
    data_frame_analytics: z.array(ml_types_dataframe_analytics_summary).describe('An array of data frame analytics job resources, which are sorted by the id value in ascending order.')
});

export const ml_get_datafeeds1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no datafeeds that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `datafeeds` array\nwhen there are no matches and the subset of results when there are\npartial matches. If this parameter is `false`, the request returns a\n`404` status code when there are no matches or only partial matches.').optional(),
        exclude_generated: z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.').optional()
    }).optional()
});

export const ml_get_datafeeds1_response = z.object({
    count: z.number(),
    datafeeds: z.array(ml_types_datafeed)
});

export const ml_get_jobs1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `jobs` array when\nthere are no matches and the subset of results when there are partial\nmatches. If this parameter is `false`, the request returns a `404` status\ncode when there are no matches or only partial matches.').optional(),
        exclude_generated: z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.').optional()
    }).optional()
});

export const ml_get_jobs1_response = z.object({
    count: z.number(),
    jobs: z.array(ml_types_job)
});

export const ml_get_trained_models1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n- Contains wildcard expressions and there are no models that match.\n- Contains the _all string or no identifiers and there are no matches.\n- Contains wildcard expressions and there are only partial matches.\n\nIf true, it returns an empty array when there are no matches and the\nsubset of results when there are partial matches.').optional(),
        decompress_definition: z.boolean().describe('Specifies whether the included model definition should be returned as a\nJSON map (true) or in a custom compressed format (false).').optional(),
        exclude_generated: z.boolean().describe('Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.').optional(),
        from: z.number().describe('Skips the specified number of models.').optional(),
        include: ml_types_include.optional(),
        size: z.number().describe('Specifies the maximum number of models to obtain.').optional(),
        tags: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const ml_get_trained_models1_response = z.object({
    count: z.number(),
    trained_model_configs: z.array(ml_types_trained_model_config).describe('An array of trained model resources, which are sorted by the model_id value in ascending order.')
});

export const ml_info_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ml_info_response = z.object({
    defaults: ml_info_defaults,
    limits: ml_info_limits,
    upgrade_mode: z.boolean(),
    native_code: ml_info_native_code
});

export const ml_preview_data_frame_analytics_request = z.object({
    body: ml_preview_data_frame_analytics.optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ml_preview_data_frame_analytics_response = z.object({
    feature_values: z.array(z.record(z.string())).describe('An array of objects that contain feature name and value pairs. The features have been processed and indicate what will be sent to the model for training.')
});

export const ml_preview_data_frame_analytics1_request = z.object({
    body: ml_preview_data_frame_analytics.optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const ml_preview_data_frame_analytics1_response = z.object({
    feature_values: z.array(z.record(z.string())).describe('An array of objects that contain feature name and value pairs. The features have been processed and indicate what will be sent to the model for training.')
});

export const ml_preview_data_frame_analytics2_request = z.object({
    body: ml_preview_data_frame_analytics.optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const ml_preview_data_frame_analytics2_response = z.object({
    feature_values: z.array(z.record(z.string())).describe('An array of objects that contain feature name and value pairs. The features have been processed and indicate what will be sent to the model for training.')
});

export const ml_preview_data_frame_analytics3_request = z.object({
    body: ml_preview_data_frame_analytics.optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const ml_preview_data_frame_analytics3_response = z.object({
    feature_values: z.array(z.record(z.string())).describe('An array of objects that contain feature name and value pairs. The features have been processed and indicate what will be sent to the model for training.')
});

export const ml_preview_datafeed_request = z.object({
    body: ml_preview_datafeed.optional(),
    path: z.object({
        datafeed_id: types_id
    }),
    query: z.object({
        start: types_date_time.optional(),
        end: types_date_time.optional()
    }).optional()
});

export const ml_preview_datafeed_response = z.array(z.record(z.unknown()));

export const ml_preview_datafeed1_request = z.object({
    body: ml_preview_datafeed.optional(),
    path: z.object({
        datafeed_id: types_id
    }),
    query: z.object({
        start: types_date_time.optional(),
        end: types_date_time.optional()
    }).optional()
});

export const ml_preview_datafeed1_response = z.array(z.record(z.unknown()));

export const ml_preview_datafeed2_request = z.object({
    body: ml_preview_datafeed.optional(),
    path: z.never().optional(),
    query: z.object({
        start: types_date_time.optional(),
        end: types_date_time.optional()
    }).optional()
});

export const ml_preview_datafeed2_response = z.array(z.record(z.unknown()));

export const ml_preview_datafeed3_request = z.object({
    body: ml_preview_datafeed.optional(),
    path: z.never().optional(),
    query: z.object({
        start: types_date_time.optional(),
        end: types_date_time.optional()
    }).optional()
});

export const ml_preview_datafeed3_response = z.array(z.record(z.unknown()));

export const ml_update_data_frame_analytics_request = z.object({
    body: z.object({
        description: z.string().describe('A description of the job.').optional(),
        model_memory_limit: z.string().describe('The approximate maximum amount of memory resources that are permitted for\nanalytical processing. If your `elasticsearch.yml` file contains an\n`xpack.ml.max_model_memory_limit` setting, an error occurs when you try\nto create data frame analytics jobs that have `model_memory_limit` values\ngreater than that setting.').optional().default('1gb'),
        max_num_threads: z.number().describe('The maximum number of threads to be used by the analysis. Using more\nthreads may decrease the time necessary to complete the analysis at the\ncost of using more CPU. Note that the process may use additional threads\nfor operational functionality other than the analysis itself.').optional().default(1),
        allow_lazy_start: z.boolean().describe('Specifies whether this job can start when there is insufficient machine\nlearning node capacity for it to be immediately assigned to a node.').optional().default(false)
    }),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const ml_update_data_frame_analytics_response = z.object({
    authorization: ml_types_dataframe_analytics_authorization.optional(),
    allow_lazy_start: z.boolean(),
    analysis: ml_types_dataframe_analysis_container,
    analyzed_fields: ml_types_dataframe_analysis_analyzed_fields.optional(),
    create_time: z.number(),
    description: z.string().optional(),
    dest: ml_types_dataframe_analytics_destination,
    id: types_id,
    max_num_threads: z.number(),
    model_memory_limit: z.string(),
    source: ml_types_dataframe_analytics_source,
    version: types_version_string
});

export const ml_update_datafeed_request = z.object({
    body: z.object({
        aggregations: z.record(types_aggregations_aggregation_container).describe('If set, the datafeed performs aggregation searches. Support for aggregations is limited and should be used only\nwith low cardinality data.').optional(),
        chunking_config: ml_types_chunking_config.optional(),
        delayed_data_check_config: ml_types_delayed_data_check_config.optional(),
        frequency: types_duration.optional(),
        indices: z.array(z.string()).describe('An array of index names. Wildcards are supported. If any of the indices are in remote clusters, the machine\nlearning nodes must have the `remote_cluster_client` role.').optional(),
        indices_options: types_indices_options.optional(),
        job_id: types_id.optional(),
        max_empty_searches: z.number().describe('If a real-time datafeed has never seen any data (including during any initial training period), it automatically\nstops and closes the associated job after this many real-time searches return no documents. In other words,\nit stops after `frequency` times `max_empty_searches` of real-time operation. If not set, a datafeed with no\nend time that sees no data remains started until it is explicitly stopped. By default, it is not set.').optional(),
        query: types_query_dsl_query_container.optional(),
        query_delay: types_duration.optional(),
        runtime_mappings: types_mapping_runtime_fields.optional(),
        script_fields: z.record(types_script_field).describe('Specifies scripts that evaluate custom expressions and returns script fields to the datafeed.\nThe detector configuration objects in a job can contain functions that use these script fields.').optional(),
        scroll_size: z.number().describe('The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations.\nThe maximum value is the value of `index.max_result_window`.').optional().default(1000)
    }),
    path: z.object({
        datafeed_id: types_id
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `true`, wildcard indices expressions that resolve into no concrete indices are ignored. This includes the\n`_all` string or when no indices are specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If `true`, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If `true`, unavailable indices (missing or closed) are ignored.').optional()
    }).optional()
});

export const ml_update_datafeed_response = z.object({
    authorization: ml_types_datafeed_authorization.optional(),
    aggregations: z.record(types_aggregations_aggregation_container).optional(),
    chunking_config: ml_types_chunking_config,
    delayed_data_check_config: ml_types_delayed_data_check_config.optional(),
    datafeed_id: types_id,
    frequency: types_duration.optional(),
    indices: z.array(z.string()),
    indices_options: types_indices_options.optional(),
    job_id: types_id,
    max_empty_searches: z.number().optional(),
    query: types_query_dsl_query_container,
    query_delay: types_duration,
    runtime_mappings: types_mapping_runtime_fields.optional(),
    script_fields: z.record(types_script_field).optional(),
    scroll_size: z.number()
});

export const ml_update_job_request = z.object({
    body: z.object({
        allow_lazy_open: z.boolean().describe('Advanced configuration option. Specifies whether this job can open when\nthere is insufficient machine learning node capacity for it to be\nimmediately assigned to a node. If `false` and a machine learning node\nwith capacity to run the job cannot immediately be found, the open\nanomaly detection jobs API returns an error. However, this is also\nsubject to the cluster-wide `xpack.ml.max_lazy_ml_nodes` setting. If this\noption is set to `true`, the open anomaly detection jobs API does not\nreturn an error and the job waits in the opening state until sufficient\nmachine learning node capacity is available.').optional().default(false),
        analysis_limits: ml_types_analysis_memory_limit.optional(),
        background_persist_interval: types_duration.optional(),
        custom_settings: z.record(z.record(z.unknown())).describe('Advanced configuration option. Contains custom meta data about the job.\nFor example, it can contain custom URL information as shown in Adding\ncustom URLs to machine learning results.').optional(),
        categorization_filters: z.array(z.string()).optional(),
        description: z.string().describe('A description of the job.').optional(),
        model_plot_config: ml_types_model_plot_config.optional(),
        model_prune_window: types_duration.optional(),
        daily_model_snapshot_retention_after_days: z.number().describe('Advanced configuration option, which affects the automatic removal of old\nmodel snapshots for this job. It specifies a period of time (in days)\nafter which only the first snapshot per day is retained. This period is\nrelative to the timestamp of the most recent snapshot for this job. Valid\nvalues range from 0 to `model_snapshot_retention_days`. For jobs created\nbefore version 7.8.0, the default value matches\n`model_snapshot_retention_days`.').optional().default(1),
        model_snapshot_retention_days: z.number().describe('Advanced configuration option, which affects the automatic removal of old\nmodel snapshots for this job. It specifies the maximum period of time (in\ndays) that snapshots are retained. This period is relative to the\ntimestamp of the most recent snapshot for this job.').optional().default(10),
        renormalization_window_days: z.number().describe('Advanced configuration option. The period over which adjustments to the\nscore are applied, as new data is seen.').optional(),
        results_retention_days: z.number().describe('Advanced configuration option. The period of time (in days) that results\nare retained. Age is calculated relative to the timestamp of the latest\nbucket result. If this property has a non-null value, once per day at\n00:30 (server time), results that are the specified number of days older\nthan the latest bucket result are deleted from Elasticsearch. The default\nvalue is null, which means all results are retained.').optional(),
        groups: z.array(z.string()).describe('A list of job groups. A job can belong to no groups or many.').optional(),
        detectors: z.array(ml_types_detector_update).describe('An array of detector update objects.').optional(),
        per_partition_categorization: ml_types_per_partition_categorization.optional()
    }),
    path: z.object({
        job_id: types_id
    }),
    query: z.never().optional()
});

export const ml_update_job_response = z.object({
    allow_lazy_open: z.boolean(),
    analysis_config: ml_types_analysis_config_read,
    analysis_limits: ml_types_analysis_limits,
    background_persist_interval: types_duration.optional(),
    create_time: types_epoch_time_unit_millis,
    finished_time: types_epoch_time_unit_millis.optional(),
    custom_settings: z.record(z.string()).optional(),
    daily_model_snapshot_retention_after_days: z.number(),
    data_description: ml_types_data_description,
    datafeed_config: ml_types_datafeed.optional(),
    description: z.string().optional(),
    groups: z.array(z.string()).optional(),
    job_id: types_id,
    job_type: z.string(),
    job_version: types_version_string,
    model_plot_config: ml_types_model_plot_config.optional(),
    model_snapshot_id: types_id.optional(),
    model_snapshot_retention_days: z.number(),
    renormalization_window_days: z.number().optional(),
    results_index_name: types_index_name,
    results_retention_days: z.number().optional()
});

export const msearch_request = z.object({
    body: msearch,
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        include_named_queries_score: z.boolean().describe('Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.').optional(),
        index: types_indices.optional(),
        max_concurrent_searches: z.number().describe('Maximum number of concurrent searches the multi search API can execute.\nDefaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`.').optional(),
        max_concurrent_shard_requests: z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.').optional(),
        pre_filter_shard_size: z.number().describe('Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.').optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.').optional(),
        routing: types_routing.optional(),
        search_type: types_search_type.optional(),
        typed_keys: z.boolean().describe('Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.').optional()
    }).optional()
});

export const msearch_response = global_msearch_multi_search_result;

export const msearch1_request = z.object({
    body: msearch,
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        include_named_queries_score: z.boolean().describe('Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.').optional(),
        index: types_indices.optional(),
        max_concurrent_searches: z.number().describe('Maximum number of concurrent searches the multi search API can execute.\nDefaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`.').optional(),
        max_concurrent_shard_requests: z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.').optional(),
        pre_filter_shard_size: z.number().describe('Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.').optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.').optional(),
        routing: types_routing.optional(),
        search_type: types_search_type.optional(),
        typed_keys: z.boolean().describe('Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.').optional()
    }).optional()
});

export const msearch1_response = global_msearch_multi_search_result;

export const msearch2_request = z.object({
    body: msearch,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        include_named_queries_score: z.boolean().describe('Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.').optional(),
        index: types_indices.optional(),
        max_concurrent_searches: z.number().describe('Maximum number of concurrent searches the multi search API can execute.\nDefaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`.').optional(),
        max_concurrent_shard_requests: z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.').optional(),
        pre_filter_shard_size: z.number().describe('Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.').optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.').optional(),
        routing: types_routing.optional(),
        search_type: types_search_type.optional(),
        typed_keys: z.boolean().describe('Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.').optional()
    }).optional()
});

export const msearch2_response = global_msearch_multi_search_result;

export const msearch3_request = z.object({
    body: msearch,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_throttled: z.boolean().describe('If true, concrete, expanded or aliased indices are ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If true, missing or closed indices are not included in the response.').optional(),
        include_named_queries_score: z.boolean().describe('Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.').optional(),
        index: types_indices.optional(),
        max_concurrent_searches: z.number().describe('Maximum number of concurrent searches the multi search API can execute.\nDefaults to `max(1, (# of data nodes * min(search thread pool size, 10)))`.').optional(),
        max_concurrent_shard_requests: z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.').optional(),
        pre_filter_shard_size: z.number().describe('Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.').optional(),
        rest_total_hits_as_int: z.boolean().describe('If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.').optional(),
        routing: types_routing.optional(),
        search_type: types_search_type.optional(),
        typed_keys: z.boolean().describe('Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.').optional()
    }).optional()
});

export const msearch3_response = global_msearch_multi_search_result;

export const msearch_template_request = z.object({
    body: msearch_template,
    path: z.never().optional(),
    query: z.object({
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips are minimized for cross-cluster search requests.').optional(),
        max_concurrent_searches: z.number().describe('The maximum number of concurrent searches the API can run.').optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object.').optional(),
        typed_keys: z.boolean().describe('If `true`, the response prefixes aggregation and suggester names with their respective types.').optional()
    }).optional()
});

export const msearch_template_response = global_msearch_multi_search_result;

export const msearch_template1_request = z.object({
    body: msearch_template,
    path: z.never().optional(),
    query: z.object({
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips are minimized for cross-cluster search requests.').optional(),
        max_concurrent_searches: z.number().describe('The maximum number of concurrent searches the API can run.').optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object.').optional(),
        typed_keys: z.boolean().describe('If `true`, the response prefixes aggregation and suggester names with their respective types.').optional()
    }).optional()
});

export const msearch_template1_response = global_msearch_multi_search_result;

export const msearch_template2_request = z.object({
    body: msearch_template,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips are minimized for cross-cluster search requests.').optional(),
        max_concurrent_searches: z.number().describe('The maximum number of concurrent searches the API can run.').optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object.').optional(),
        typed_keys: z.boolean().describe('If `true`, the response prefixes aggregation and suggester names with their respective types.').optional()
    }).optional()
});

export const msearch_template2_response = global_msearch_multi_search_result;

export const msearch_template3_request = z.object({
    body: msearch_template,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips are minimized for cross-cluster search requests.').optional(),
        max_concurrent_searches: z.number().describe('The maximum number of concurrent searches the API can run.').optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object.').optional(),
        typed_keys: z.boolean().describe('If `true`, the response prefixes aggregation and suggester names with their respective types.').optional()
    }).optional()
});

export const msearch_template3_response = global_msearch_multi_search_result;

export const nodes_stats_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        completion_fields: types_fields.optional(),
        fielddata_fields: types_fields.optional(),
        fields: types_fields.optional(),
        groups: z.boolean().describe('Comma-separated list of search groups to include in the search statistics.').optional(),
        include_segment_file_sizes: z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).').optional(),
        level: types_node_stats_level.optional(),
        timeout: types_duration.optional(),
        types: z.array(z.string()).describe('A comma-separated list of document types for the indexing index metric.').optional(),
        include_unloaded_segments: z.boolean().describe('If `true`, the response includes information from segments that are not loaded into memory.').optional()
    }).optional()
});

export const nodes_stats_response = nodes_stats_response_base;

export const nodes_stats1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids
    }),
    query: z.object({
        completion_fields: types_fields.optional(),
        fielddata_fields: types_fields.optional(),
        fields: types_fields.optional(),
        groups: z.boolean().describe('Comma-separated list of search groups to include in the search statistics.').optional(),
        include_segment_file_sizes: z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).').optional(),
        level: types_node_stats_level.optional(),
        timeout: types_duration.optional(),
        types: z.array(z.string()).describe('A comma-separated list of document types for the indexing index metric.').optional(),
        include_unloaded_segments: z.boolean().describe('If `true`, the response includes information from segments that are not loaded into memory.').optional()
    }).optional()
});

export const nodes_stats1_response = nodes_stats_response_base;

export const nodes_stats2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        metric: nodes_stats_node_stats_metrics
    }),
    query: z.object({
        completion_fields: types_fields.optional(),
        fielddata_fields: types_fields.optional(),
        fields: types_fields.optional(),
        groups: z.boolean().describe('Comma-separated list of search groups to include in the search statistics.').optional(),
        include_segment_file_sizes: z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).').optional(),
        level: types_node_stats_level.optional(),
        timeout: types_duration.optional(),
        types: z.array(z.string()).describe('A comma-separated list of document types for the indexing index metric.').optional(),
        include_unloaded_segments: z.boolean().describe('If `true`, the response includes information from segments that are not loaded into memory.').optional()
    }).optional()
});

export const nodes_stats2_response = nodes_stats_response_base;

export const nodes_stats3_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids,
        metric: nodes_stats_node_stats_metrics
    }),
    query: z.object({
        completion_fields: types_fields.optional(),
        fielddata_fields: types_fields.optional(),
        fields: types_fields.optional(),
        groups: z.boolean().describe('Comma-separated list of search groups to include in the search statistics.').optional(),
        include_segment_file_sizes: z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).').optional(),
        level: types_node_stats_level.optional(),
        timeout: types_duration.optional(),
        types: z.array(z.string()).describe('A comma-separated list of document types for the indexing index metric.').optional(),
        include_unloaded_segments: z.boolean().describe('If `true`, the response includes information from segments that are not loaded into memory.').optional()
    }).optional()
});

export const nodes_stats3_response = nodes_stats_response_base;

export const nodes_stats4_request = z.object({
    body: z.never().optional(),
    path: z.object({
        metric: nodes_stats_node_stats_metrics,
        index_metric: types_common_stats_flags
    }),
    query: z.object({
        completion_fields: types_fields.optional(),
        fielddata_fields: types_fields.optional(),
        fields: types_fields.optional(),
        groups: z.boolean().describe('Comma-separated list of search groups to include in the search statistics.').optional(),
        include_segment_file_sizes: z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).').optional(),
        level: types_node_stats_level.optional(),
        timeout: types_duration.optional(),
        types: z.array(z.string()).describe('A comma-separated list of document types for the indexing index metric.').optional(),
        include_unloaded_segments: z.boolean().describe('If `true`, the response includes information from segments that are not loaded into memory.').optional()
    }).optional()
});

export const nodes_stats4_response = nodes_stats_response_base;

export const nodes_stats5_request = z.object({
    body: z.never().optional(),
    path: z.object({
        node_id: types_node_ids,
        metric: nodes_stats_node_stats_metrics,
        index_metric: types_common_stats_flags
    }),
    query: z.object({
        completion_fields: types_fields.optional(),
        fielddata_fields: types_fields.optional(),
        fields: types_fields.optional(),
        groups: z.boolean().describe('Comma-separated list of search groups to include in the search statistics.').optional(),
        include_segment_file_sizes: z.boolean().describe('If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).').optional(),
        level: types_node_stats_level.optional(),
        timeout: types_duration.optional(),
        types: z.array(z.string()).describe('A comma-separated list of document types for the indexing index metric.').optional(),
        include_unloaded_segments: z.boolean().describe('If `true`, the response includes information from segments that are not loaded into memory.').optional()
    }).optional()
});

export const nodes_stats5_response = nodes_stats_response_base;

export const open_point_in_time_request = z.object({
    body: z.object({
        index_filter: types_query_dsl_query_container.optional()
    }).optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        keep_alive: types_duration,
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nBy default, it is random.').optional(),
        routing: types_routing.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        allow_partial_search_results: z.boolean().describe('Indicates whether the point in time tolerates unavailable shards or shard failures when initially creating the PIT.\nIf `false`, creating a point in time request when a shard is missing or unavailable will throw an exception.\nIf `true`, the point in time will contain all the shards that are available at the time of the request.').optional(),
        max_concurrent_shard_requests: z.number().describe('Maximum number of concurrent shard requests that each sub-search request executes per node.').optional()
    })
});

export const open_point_in_time_response = z.object({
    _shards: types_shard_statistics,
    id: types_id
});

export const put_script3_request = z.object({
    body: put_script,
    path: z.object({
        id: types_id,
        context: types_name
    }),
    query: z.object({
        context: types_name.optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const put_script3_response = types_acknowledged_response_base;

export const put_script2_request = z.object({
    body: put_script,
    path: z.object({
        id: types_id,
        context: types_name
    }),
    query: z.object({
        context: types_name.optional(),
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const put_script2_response = types_acknowledged_response_base;

export const rank_eval_request = z.object({
    body: rank_eval,
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `true`, missing or closed indices are not included in the response.').optional(),
        search_type: z.string().describe('Search operation type').optional()
    }).optional()
});

export const rank_eval_response = z.object({
    metric_score: z.number().describe('The overall evaluation quality calculated by the defined metric'),
    details: z.record(global_rank_eval_rank_eval_metric_detail).describe('The details section contains one entry for every query in the original requests section, keyed by the search request id'),
    failures: z.record(z.record(z.unknown()))
});

export const rank_eval1_request = z.object({
    body: rank_eval,
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `true`, missing or closed indices are not included in the response.').optional(),
        search_type: z.string().describe('Search operation type').optional()
    }).optional()
});

export const rank_eval1_response = z.object({
    metric_score: z.number().describe('The overall evaluation quality calculated by the defined metric'),
    details: z.record(global_rank_eval_rank_eval_metric_detail).describe('The details section contains one entry for every query in the original requests section, keyed by the search request id'),
    failures: z.record(z.record(z.unknown()))
});

export const rank_eval2_request = z.object({
    body: rank_eval,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `true`, missing or closed indices are not included in the response.').optional(),
        search_type: z.string().describe('Search operation type').optional()
    }).optional()
});

export const rank_eval2_response = z.object({
    metric_score: z.number().describe('The overall evaluation quality calculated by the defined metric'),
    details: z.record(global_rank_eval_rank_eval_metric_detail).describe('The details section contains one entry for every query in the original requests section, keyed by the search request id'),
    failures: z.record(z.record(z.unknown()))
});

export const rank_eval3_request = z.object({
    body: rank_eval,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `true`, missing or closed indices are not included in the response.').optional(),
        search_type: z.string().describe('Search operation type').optional()
    }).optional()
});

export const rank_eval3_response = z.object({
    metric_score: z.number().describe('The overall evaluation quality calculated by the defined metric'),
    details: z.record(global_rank_eval_rank_eval_metric_detail).describe('The details section contains one entry for every query in the original requests section, keyed by the search request id'),
    failures: z.record(z.record(z.unknown()))
});

export const reindex_request = z.object({
    body: z.object({
        conflicts: types_conflicts.optional(),
        dest: global_reindex_destination,
        max_docs: z.number().describe('The maximum number of documents to reindex.\nBy default, all documents are reindexed.\nIf it is a value less then or equal to `scroll_size`, a scroll will not be used to retrieve the results for the operation.\n\nIf `conflicts` is set to `proceed`, the reindex operation could attempt to reindex more documents from the source than `max_docs` until it has successfully indexed `max_docs` documents into the target or it has gone through every document in the source query.').optional(),
        script: types_script.optional(),
        source: global_reindex_source
    }),
    path: z.never().optional(),
    query: z.object({
        refresh: z.boolean().describe('If `true`, the request refreshes affected shards to make this operation visible to search.').optional(),
        requests_per_second: z.number().describe('The throttle for this request in sub-requests per second.\nBy default, there is no throttle.').optional(),
        scroll: types_duration.optional(),
        slices: types_slices.optional(),
        max_docs: z.number().describe('The maximum number of documents to reindex.\nBy default, all documents are reindexed.\nIf it is a value less then or equal to `scroll_size`, a scroll will not be used to retrieve the results for the operation.\n\nIf `conflicts` is set to `proceed`, the reindex operation could attempt to reindex more documents from the source than `max_docs` until it has successfully indexed `max_docs` documents into the target or it has gone through every document in the source query.').optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request blocks until the operation is complete.').optional(),
        require_alias: z.boolean().describe('If `true`, the destination must be an index alias.').optional()
    }).optional()
});

export const reindex_response = z.object({
    batches: z.number().describe('The number of scroll responses that were pulled back by the reindex.').optional(),
    created: z.number().describe('The number of documents that were successfully created.').optional(),
    deleted: z.number().describe('The number of documents that were successfully deleted.').optional(),
    failures: z.array(types_bulk_index_by_scroll_failure).describe('If there were any unrecoverable errors during the process, it is an array of those failures.\nIf this array is not empty, the request ended because of those failures.\nReindex is implemented using batches and any failure causes the entire process to end but all failures in the current batch are collected into the array.\nYou can use the `conflicts` option to prevent the reindex from ending on version conflicts.').optional(),
    noops: z.number().describe('The number of documents that were ignored because the script used for the reindex returned a `noop` value for `ctx.op`.').optional(),
    retries: types_retries.optional(),
    requests_per_second: z.number().describe('The number of requests per second effectively run during the reindex.').optional(),
    slice_id: z.number().optional(),
    task: types_task_id.optional(),
    throttled_millis: types_epoch_time_unit_millis.optional(),
    throttled_until_millis: types_epoch_time_unit_millis.optional(),
    timed_out: z.boolean().describe('If any of the requests that ran during the reindex timed out, it is `true`.').optional(),
    took: types_duration_value_unit_millis.optional(),
    total: z.number().describe('The number of documents that were successfully processed.').optional(),
    updated: z.number().describe('The number of documents that were successfully updated.\nThat is to say, a document with the same ID already existed before the reindex updated it.').optional(),
    version_conflicts: z.number().describe('The number of version conflicts that occurred.').optional()
});

export const render_search_template_request = z.object({
    body: render_search_template,
    path: z.never().optional(),
    query: z.never().optional()
});

export const render_search_template_response = z.object({
    template_output: z.record(z.record(z.unknown()))
});

export const render_search_template1_request = z.object({
    body: render_search_template,
    path: z.never().optional(),
    query: z.never().optional()
});

export const render_search_template1_response = z.object({
    template_output: z.record(z.record(z.unknown()))
});

export const render_search_template2_request = z.object({
    body: render_search_template,
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const render_search_template2_response = z.object({
    template_output: z.record(z.record(z.unknown()))
});

export const render_search_template3_request = z.object({
    body: render_search_template,
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const render_search_template3_response = z.object({
    template_output: z.record(z.record(z.unknown()))
});

export const rollup_rollup_search_request = z.object({
    body: rollup_rollup_search,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        rest_total_hits_as_int: z.boolean().describe('Indicates whether hits.total should be rendered as an integer or an object in the rest search response').optional(),
        typed_keys: z.boolean().describe('Specify whether aggregation and suggester names should be prefixed by their respective types in the response').optional()
    }).optional()
});

export const rollup_rollup_search_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    terminated_early: z.boolean().optional(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.record(types_aggregations_aggregate).optional()
});

export const rollup_rollup_search1_request = z.object({
    body: rollup_rollup_search,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        rest_total_hits_as_int: z.boolean().describe('Indicates whether hits.total should be rendered as an integer or an object in the rest search response').optional(),
        typed_keys: z.boolean().describe('Specify whether aggregation and suggester names should be prefixed by their respective types in the response').optional()
    }).optional()
});

export const rollup_rollup_search1_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    terminated_early: z.boolean().optional(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.record(types_aggregations_aggregate).optional()
});

export const scripts_painless_execute_request = z.object({
    body: scripts_painless_execute,
    path: z.never().optional(),
    query: z.never().optional()
});

export const scripts_painless_execute_response = z.object({
    result: z.record(z.unknown())
});

export const scripts_painless_execute1_request = z.object({
    body: scripts_painless_execute,
    path: z.never().optional(),
    query: z.never().optional()
});

export const scripts_painless_execute1_response = z.object({
    result: z.record(z.unknown())
});

export const search_request = z.object({
    body: search.optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        allow_partial_search_results: z.boolean().describe('If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        batched_reduce_size: z.number().describe('The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        docvalue_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the request returns detailed information about score computation as part of a hit.').optional(),
        ignore_throttled: z.boolean().describe('If `true`, concrete, expanded or aliased indices will be ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_named_queries_score: z.boolean().describe('If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        max_concurrent_shard_requests: z.number().describe('The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.').optional(),
        preference: z.string().describe('The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.').optional(),
        pre_filter_shard_size: z.number().describe('A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.').optional(),
        request_cache: z.boolean().describe('If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.').optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        search_type: types_search_type.optional(),
        stats: z.array(z.string()).describe('Specific `tag` of the request for logging and statistical purposes.').optional(),
        stored_fields: types_fields.optional(),
        suggest_field: types_field.optional(),
        suggest_mode: types_suggest_mode.optional(),
        suggest_size: z.number().describe('The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.').optional(),
        suggest_text: z.string().describe('The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.').optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.').optional(),
        timeout: types_duration.optional(),
        track_total_hits: global_search_types_track_hits.optional(),
        track_scores: z.boolean().describe('If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.').optional(),
        typed_keys: z.boolean().describe('If `true`, aggregation and suggester names are be prefixed by their respective types in the response.').optional(),
        rest_total_hits_as_int: z.boolean().describe('Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.').optional(),
        version: z.boolean().describe('If `true`, the request returns the document version as part of a hit.').optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_exclude_vectors: z.boolean().describe('Whether vectors should be excluded from _source').optional(),
        _source_includes: types_fields.optional(),
        seq_no_primary_term: z.boolean().describe('If `true`, the request returns the sequence number and primary term of the last modification of each hit.').optional(),
        q: z.string().describe('A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.').optional(),
        size: z.number().describe('The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional(),
        from: z.number().describe('The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional(),
        sort: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const search_response = global_search_response_body;

export const search1_request = z.object({
    body: search.optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        allow_partial_search_results: z.boolean().describe('If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        batched_reduce_size: z.number().describe('The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        docvalue_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the request returns detailed information about score computation as part of a hit.').optional(),
        ignore_throttled: z.boolean().describe('If `true`, concrete, expanded or aliased indices will be ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_named_queries_score: z.boolean().describe('If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        max_concurrent_shard_requests: z.number().describe('The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.').optional(),
        preference: z.string().describe('The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.').optional(),
        pre_filter_shard_size: z.number().describe('A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.').optional(),
        request_cache: z.boolean().describe('If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.').optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        search_type: types_search_type.optional(),
        stats: z.array(z.string()).describe('Specific `tag` of the request for logging and statistical purposes.').optional(),
        stored_fields: types_fields.optional(),
        suggest_field: types_field.optional(),
        suggest_mode: types_suggest_mode.optional(),
        suggest_size: z.number().describe('The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.').optional(),
        suggest_text: z.string().describe('The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.').optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.').optional(),
        timeout: types_duration.optional(),
        track_total_hits: global_search_types_track_hits.optional(),
        track_scores: z.boolean().describe('If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.').optional(),
        typed_keys: z.boolean().describe('If `true`, aggregation and suggester names are be prefixed by their respective types in the response.').optional(),
        rest_total_hits_as_int: z.boolean().describe('Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.').optional(),
        version: z.boolean().describe('If `true`, the request returns the document version as part of a hit.').optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_exclude_vectors: z.boolean().describe('Whether vectors should be excluded from _source').optional(),
        _source_includes: types_fields.optional(),
        seq_no_primary_term: z.boolean().describe('If `true`, the request returns the sequence number and primary term of the last modification of each hit.').optional(),
        q: z.string().describe('A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.').optional(),
        size: z.number().describe('The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional(),
        from: z.number().describe('The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional(),
        sort: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const search1_response = global_search_response_body;

export const search2_request = z.object({
    body: search.optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        allow_partial_search_results: z.boolean().describe('If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        batched_reduce_size: z.number().describe('The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        docvalue_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the request returns detailed information about score computation as part of a hit.').optional(),
        ignore_throttled: z.boolean().describe('If `true`, concrete, expanded or aliased indices will be ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_named_queries_score: z.boolean().describe('If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        max_concurrent_shard_requests: z.number().describe('The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.').optional(),
        preference: z.string().describe('The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.').optional(),
        pre_filter_shard_size: z.number().describe('A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.').optional(),
        request_cache: z.boolean().describe('If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.').optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        search_type: types_search_type.optional(),
        stats: z.array(z.string()).describe('Specific `tag` of the request for logging and statistical purposes.').optional(),
        stored_fields: types_fields.optional(),
        suggest_field: types_field.optional(),
        suggest_mode: types_suggest_mode.optional(),
        suggest_size: z.number().describe('The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.').optional(),
        suggest_text: z.string().describe('The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.').optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.').optional(),
        timeout: types_duration.optional(),
        track_total_hits: global_search_types_track_hits.optional(),
        track_scores: z.boolean().describe('If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.').optional(),
        typed_keys: z.boolean().describe('If `true`, aggregation and suggester names are be prefixed by their respective types in the response.').optional(),
        rest_total_hits_as_int: z.boolean().describe('Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.').optional(),
        version: z.boolean().describe('If `true`, the request returns the document version as part of a hit.').optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_exclude_vectors: z.boolean().describe('Whether vectors should be excluded from _source').optional(),
        _source_includes: types_fields.optional(),
        seq_no_primary_term: z.boolean().describe('If `true`, the request returns the sequence number and primary term of the last modification of each hit.').optional(),
        q: z.string().describe('A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.').optional(),
        size: z.number().describe('The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional(),
        from: z.number().describe('The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional(),
        sort: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const search2_response = global_search_response_body;

export const search3_request = z.object({
    body: search.optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        allow_partial_search_results: z.boolean().describe('If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        batched_reduce_size: z.number().describe('The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.').optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        docvalue_fields: types_fields.optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the request returns detailed information about score computation as part of a hit.').optional(),
        ignore_throttled: z.boolean().describe('If `true`, concrete, expanded or aliased indices will be ignored when frozen.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        include_named_queries_score: z.boolean().describe('If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        max_concurrent_shard_requests: z.number().describe('The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.').optional(),
        preference: z.string().describe('The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness.\nValid values are:\n\n* `_only_local` to run the search only on shards on the local node.\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method.\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method.\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs. If not, select shards using the default method.\n* `_shards:<shard>,<shard>` to run the search only on the specified shards. You can combine this value with other `preference` values. However, the `_shards` value must come first. For example: `_shards:2,3|_local`.\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.').optional(),
        pre_filter_shard_size: z.number().describe('A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.').optional(),
        request_cache: z.boolean().describe('If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.').optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        search_type: types_search_type.optional(),
        stats: z.array(z.string()).describe('Specific `tag` of the request for logging and statistical purposes.').optional(),
        stored_fields: types_fields.optional(),
        suggest_field: types_field.optional(),
        suggest_mode: types_suggest_mode.optional(),
        suggest_size: z.number().describe('The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.').optional(),
        suggest_text: z.string().describe('The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.').optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.').optional(),
        timeout: types_duration.optional(),
        track_total_hits: global_search_types_track_hits.optional(),
        track_scores: z.boolean().describe('If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.').optional(),
        typed_keys: z.boolean().describe('If `true`, aggregation and suggester names are be prefixed by their respective types in the response.').optional(),
        rest_total_hits_as_int: z.boolean().describe('Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.').optional(),
        version: z.boolean().describe('If `true`, the request returns the document version as part of a hit.').optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_exclude_vectors: z.boolean().describe('Whether vectors should be excluded from _source').optional(),
        _source_includes: types_fields.optional(),
        seq_no_primary_term: z.boolean().describe('If `true`, the request returns the sequence number and primary term of the last modification of each hit.').optional(),
        q: z.string().describe('A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.').optional(),
        size: z.number().describe('The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional(),
        from: z.number().describe('The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.').optional(),
        sort: z.union([
            z.string(),
            z.array(z.string())
        ]).optional()
    }).optional()
});

export const search3_response = global_search_response_body;

export const search_application_get_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_name
    }),
    query: z.never().optional()
});

export const search_application_get_response = search_application_types_search_application;

export const search_application_put_request = z.object({
    body: search_application_types_search_application_parameters,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        create: z.boolean().describe('If `true`, this request cannot replace or update existing Search Applications.').optional()
    }).optional()
});

export const search_application_put_response = z.object({
    result: types_result
});

export const search_application_list_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        q: z.string().describe('Query in the Lucene query string syntax.').optional(),
        from: z.number().describe('Starting offset.').optional(),
        size: z.number().describe('Specifies a max number of results to get.').optional()
    }).optional()
});

export const search_application_list_response = z.object({
    count: z.number(),
    results: z.array(search_application_types_search_application)
});

export const search_application_search_request = z.object({
    body: search_application_search.optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        typed_keys: z.boolean().describe('Determines whether aggregation names are prefixed by their respective types in the response.').optional()
    }).optional()
});

export const search_application_search_response = global_search_response_body;

export const search_application_search1_request = z.object({
    body: search_application_search.optional(),
    path: z.object({
        name: types_name
    }),
    query: z.object({
        typed_keys: z.boolean().describe('Determines whether aggregation names are prefixed by their respective types in the response.').optional()
    }).optional()
});

export const search_application_search1_response = global_search_response_body;

export const search_mvt1_request = z.object({
    body: search_mvt.optional(),
    path: z.object({
        index: types_indices,
        field: types_field,
        zoom: global_search_mvt_types_zoom_level,
        x: global_search_mvt_types_coordinate,
        y: global_search_mvt_types_coordinate
    }),
    query: z.object({
        exact_bounds: z.boolean().describe('If `false`, the meta layer\'s feature is the bounding box of the tile.\nIf true, the meta layer\'s feature is a bounding box resulting from a\ngeo_bounds aggregation. The aggregation runs on <field> values that intersect\nthe <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting\nbounding box may be larger than the vector tile.').optional(),
        extent: z.number().describe('The size, in pixels, of a side of the tile. Vector tiles are square with equal sides.').optional(),
        grid_agg: global_search_mvt_types_grid_aggregation_type.optional(),
        grid_precision: z.number().describe('Additional zoom levels available through the aggs layer. For example, if <zoom> is 7\nand grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndon\'t include the aggs layer.').optional(),
        grid_type: global_search_mvt_types_grid_type.optional(),
        size: z.number().describe('Maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results don\'t include the hits layer.').optional(),
        track_total_hits: global_search_types_track_hits.optional(),
        with_labels: z.boolean().describe('If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.\n\n* `Point` and `MultiPoint` features will have one of the points selected.\n* `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.\n* `LineString` features will likewise provide a roughly central point selected from the triangle-tree.\n* The aggregation results will provide one central point for each aggregation bucket.\n\nAll attributes from the original features will also be copied to the new label features.\nIn addition, the new features will be distinguishable using the tag `_mvt_label_position`.').optional()
    }).optional()
});

export const search_mvt1_response = types_mapbox_vector_tiles;

export const search_mvt_request = z.object({
    body: search_mvt.optional(),
    path: z.object({
        index: types_indices,
        field: types_field,
        zoom: global_search_mvt_types_zoom_level,
        x: global_search_mvt_types_coordinate,
        y: global_search_mvt_types_coordinate
    }),
    query: z.object({
        exact_bounds: z.boolean().describe('If `false`, the meta layer\'s feature is the bounding box of the tile.\nIf true, the meta layer\'s feature is a bounding box resulting from a\ngeo_bounds aggregation. The aggregation runs on <field> values that intersect\nthe <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting\nbounding box may be larger than the vector tile.').optional(),
        extent: z.number().describe('The size, in pixels, of a side of the tile. Vector tiles are square with equal sides.').optional(),
        grid_agg: global_search_mvt_types_grid_aggregation_type.optional(),
        grid_precision: z.number().describe('Additional zoom levels available through the aggs layer. For example, if <zoom> is 7\nand grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndon\'t include the aggs layer.').optional(),
        grid_type: global_search_mvt_types_grid_type.optional(),
        size: z.number().describe('Maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results don\'t include the hits layer.').optional(),
        track_total_hits: global_search_types_track_hits.optional(),
        with_labels: z.boolean().describe('If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.\n\n* `Point` and `MultiPoint` features will have one of the points selected.\n* `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.\n* `LineString` features will likewise provide a roughly central point selected from the triangle-tree.\n* The aggregation results will provide one central point for each aggregation bucket.\n\nAll attributes from the original features will also be copied to the new label features.\nIn addition, the new features will be distinguishable using the tag `_mvt_label_position`.').optional()
    }).optional()
});

export const search_mvt_response = types_mapbox_vector_tiles;

export const search_shards_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.').optional(),
        master_timeout: types_duration.optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        routing: types_routing.optional()
    }).optional()
});

export const search_shards_response = z.object({
    nodes: z.record(global_search_shards_search_shards_node_attributes),
    shards: z.array(z.array(types_node_shard)),
    indices: z.record(global_search_shards_shard_store_index)
});

export const search_shards1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.').optional(),
        master_timeout: types_duration.optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        routing: types_routing.optional()
    }).optional()
});

export const search_shards1_response = z.object({
    nodes: z.record(global_search_shards_search_shards_node_attributes),
    shards: z.array(z.array(types_node_shard)),
    indices: z.record(global_search_shards_shard_store_index)
});

export const search_shards2_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.').optional(),
        master_timeout: types_duration.optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        routing: types_routing.optional()
    }).optional()
});

export const search_shards2_response = z.object({
    nodes: z.record(global_search_shards_search_shards_node_attributes),
    shards: z.array(z.array(types_node_shard)),
    indices: z.record(global_search_shards_shard_store_index)
});

export const search_shards3_request = z.object({
    body: z.never().optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        local: z.boolean().describe('If `true`, the request retrieves information from the local node only.').optional(),
        master_timeout: types_duration.optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        routing: types_routing.optional()
    }).optional()
});

export const search_shards3_response = z.object({
    nodes: z.record(global_search_shards_search_shards_node_attributes),
    shards: z.array(z.array(types_node_shard)),
    indices: z.record(global_search_shards_shard_store_index)
});

export const search_template_request = z.object({
    body: search_template,
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the response includes additional details about score computation as part of a hit.').optional(),
        ignore_throttled: z.boolean().describe('If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        profile: z.boolean().describe('If `true`, the query execution is profiled.').optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object.').optional(),
        typed_keys: z.boolean().describe('If `true`, the response prefixes aggregation and suggester names with their respective types.').optional()
    }).optional()
});

export const search_template_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.record(types_aggregations_aggregate).optional(),
    _clusters: types_cluster_statistics.optional(),
    fields: z.record(z.record(z.unknown())).optional(),
    max_score: z.number().optional(),
    num_reduce_phases: z.number().optional(),
    profile: global_search_types_profile.optional(),
    pit_id: types_id.optional(),
    _scroll_id: types_scroll_id.optional(),
    suggest: z.record(z.array(global_search_types_suggest)).optional(),
    terminated_early: z.boolean().optional()
});

export const search_template1_request = z.object({
    body: search_template,
    path: z.never().optional(),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the response includes additional details about score computation as part of a hit.').optional(),
        ignore_throttled: z.boolean().describe('If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        profile: z.boolean().describe('If `true`, the query execution is profiled.').optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object.').optional(),
        typed_keys: z.boolean().describe('If `true`, the response prefixes aggregation and suggester names with their respective types.').optional()
    }).optional()
});

export const search_template1_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.record(types_aggregations_aggregate).optional(),
    _clusters: types_cluster_statistics.optional(),
    fields: z.record(z.record(z.unknown())).optional(),
    max_score: z.number().optional(),
    num_reduce_phases: z.number().optional(),
    profile: global_search_types_profile.optional(),
    pit_id: types_id.optional(),
    _scroll_id: types_scroll_id.optional(),
    suggest: z.record(z.array(global_search_types_suggest)).optional(),
    terminated_early: z.boolean().optional()
});

export const search_template2_request = z.object({
    body: search_template,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the response includes additional details about score computation as part of a hit.').optional(),
        ignore_throttled: z.boolean().describe('If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        profile: z.boolean().describe('If `true`, the query execution is profiled.').optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object.').optional(),
        typed_keys: z.boolean().describe('If `true`, the response prefixes aggregation and suggester names with their respective types.').optional()
    }).optional()
});

export const search_template2_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.record(types_aggregations_aggregate).optional(),
    _clusters: types_cluster_statistics.optional(),
    fields: z.record(z.record(z.unknown())).optional(),
    max_score: z.number().optional(),
    num_reduce_phases: z.number().optional(),
    profile: global_search_types_profile.optional(),
    pit_id: types_id.optional(),
    _scroll_id: types_scroll_id.optional(),
    suggest: z.record(z.array(global_search_types_suggest)).optional(),
    terminated_early: z.boolean().optional()
});

export const search_template3_request = z.object({
    body: search_template,
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        ccs_minimize_roundtrips: z.boolean().describe('If `true`, network round-trips are minimized for cross-cluster search requests.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        explain: z.boolean().describe('If `true`, the response includes additional details about score computation as part of a hit.').optional(),
        ignore_throttled: z.boolean().describe('If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        profile: z.boolean().describe('If `true`, the query execution is profiled.').optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        search_type: types_search_type.optional(),
        rest_total_hits_as_int: z.boolean().describe('If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object.').optional(),
        typed_keys: z.boolean().describe('If `true`, the response prefixes aggregation and suggester names with their respective types.').optional()
    }).optional()
});

export const search_template3_response = z.object({
    took: z.number(),
    timed_out: z.boolean(),
    _shards: types_shard_statistics,
    hits: global_search_types_hits_metadata,
    aggregations: z.record(types_aggregations_aggregate).optional(),
    _clusters: types_cluster_statistics.optional(),
    fields: z.record(z.record(z.unknown())).optional(),
    max_score: z.number().optional(),
    num_reduce_phases: z.number().optional(),
    profile: global_search_types_profile.optional(),
    pit_id: types_id.optional(),
    _scroll_id: types_scroll_id.optional(),
    suggest: z.record(z.array(global_search_types_suggest)).optional(),
    terminated_early: z.boolean().optional()
});

export const security_get_role1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_get_role1_response = z.record(security_get_role_role);

export const security_bulk_put_role_request = z.object({
    body: z.object({
        roles: z.record(security_types_role_descriptor).describe('A dictionary of role name to RoleDescriptor objects to add or update')
    }),
    path: z.never().optional(),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_bulk_put_role_response = z.object({
    created: z.array(z.string()).describe('Array of created roles').optional(),
    updated: z.array(z.string()).describe('Array of updated roles').optional(),
    noop: z.array(z.string()).describe('Array of role names without any changes').optional(),
    errors: security_types_bulk_error.optional()
});

export const security_bulk_update_api_keys_request = z.object({
    body: z.object({
        expiration: types_duration.optional(),
        ids: z.union([
            z.string(),
            z.array(z.string())
        ]),
        metadata: types_metadata.optional(),
        role_descriptors: z.record(security_types_role_descriptor).describe('The role descriptors to assign to the API keys.\nAn API key\'s effective permissions are an intersection of its assigned privileges and the point-in-time snapshot of permissions of the owner user.\nYou can assign new privileges by specifying them in this parameter.\nTo remove assigned privileges, supply the `role_descriptors` parameter as an empty object `{}`.\nIf an API key has no assigned privileges, it inherits the owner user\'s full permissions.\nThe snapshot of the owner\'s permissions is always updated, whether you supply the `role_descriptors` parameter.\nThe structure of a role descriptor is the same as the request for the create API keys API.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_bulk_update_api_keys_response = z.object({
    errors: security_types_bulk_error.optional(),
    noops: z.array(z.string()),
    updated: z.array(z.string())
});

export const security_get_api_key_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        id: types_id.optional(),
        name: types_name.optional(),
        owner: z.boolean().describe('A boolean flag that can be used to query API keys owned by the currently authenticated user.\nThe `realm_name` or `username` parameters cannot be specified when this parameter is set to `true` as they are assumed to be the currently authenticated ones.').optional(),
        realm_name: types_name.optional(),
        username: types_username.optional(),
        with_limited_by: z.boolean().describe('Return the snapshot of the owner user\'s role descriptors\nassociated with the API key. An API key\'s actual\npermission is the intersection of its assigned role\ndescriptors and the owner user\'s role descriptors.').optional(),
        active_only: z.boolean().describe('A boolean flag that can be used to query API keys that are currently active. An API key is considered active if it is neither invalidated, nor expired at query time. You can specify this together with other parameters such as `owner` or `name`. If `active_only` is false, the response will include both active and inactive (expired or invalidated) keys.').optional(),
        with_profile_uid: z.boolean().describe('Determines whether to also retrieve the profile uid, for the API key owner principal, if it exists.').optional()
    }).optional()
});

export const security_get_api_key_response = z.object({
    api_keys: z.array(security_types_api_key)
});

export const security_create_api_key1_request = z.object({
    body: security_create_api_key,
    path: z.never().optional(),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_create_api_key1_response = z.object({
    api_key: z.string().describe('Generated API key.'),
    expiration: z.number().describe('Expiration in milliseconds for the API key.').optional(),
    id: types_id,
    name: types_name,
    encoded: z.string().describe('API key credentials which is the base64-encoding of\nthe UTF-8 representation of `id` and `api_key` joined\nby a colon (`:`).')
});

export const security_create_api_key_request = z.object({
    body: security_create_api_key,
    path: z.never().optional(),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_create_api_key_response = z.object({
    api_key: z.string().describe('Generated API key.'),
    expiration: z.number().describe('Expiration in milliseconds for the API key.').optional(),
    id: types_id,
    name: types_name,
    encoded: z.string().describe('API key credentials which is the base64-encoding of\nthe UTF-8 representation of `id` and `api_key` joined\nby a colon (`:`).')
});

export const security_create_cross_cluster_api_key_request = z.object({
    body: z.object({
        access: security_types_access,
        expiration: types_duration.optional(),
        metadata: types_metadata.optional(),
        name: types_name,
        certificate_identity: z.string().describe('The certificate identity to associate with this API key.\nThis field is used to restrict the API key to connections authenticated by a specific TLS certificate.\nThe value should match the certificate\'s distinguished name (DN) pattern.').optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_create_cross_cluster_api_key_response = z.object({
    api_key: z.string().describe('Generated API key.'),
    expiration: types_duration_value_unit_millis.optional(),
    id: types_id,
    name: types_name,
    encoded: z.string().describe('API key credentials which is the base64-encoding of\nthe UTF-8 representation of `id` and `api_key` joined\nby a colon (`:`).')
});

export const security_get_role_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.never().optional()
});

export const security_get_role_response = z.record(security_get_role_role);

export const security_put_role1_request = z.object({
    body: security_put_role,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_put_role1_response = z.object({
    role: security_types_created_status
});

export const security_put_role_request = z.object({
    body: security_put_role,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_put_role_response = z.object({
    role: security_types_created_status
});

export const security_get_role_mapping_request = z.object({
    body: z.never().optional(),
    path: z.object({
        name: types_names
    }),
    query: z.never().optional()
});

export const security_get_role_mapping_response = z.record(security_types_role_mapping);

export const security_put_role_mapping1_request = z.object({
    body: security_put_role_mapping,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_put_role_mapping1_response = z.object({
    created: z.boolean().optional(),
    role_mapping: security_types_created_status
});

export const security_put_role_mapping_request = z.object({
    body: security_put_role_mapping,
    path: z.object({
        name: types_name
    }),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_put_role_mapping_response = z.object({
    created: z.boolean().optional(),
    role_mapping: security_types_created_status
});

export const security_get_role_mapping1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_get_role_mapping1_response = z.record(security_types_role_mapping);

export const security_get_service_accounts_request = z.object({
    body: z.never().optional(),
    path: z.object({
        namespace: types_namespace,
        service: types_service
    }),
    query: z.never().optional()
});

export const security_get_service_accounts_response = z.record(security_get_service_accounts_role_descriptor_wrapper);

export const security_get_service_accounts1_request = z.object({
    body: z.never().optional(),
    path: z.object({
        namespace: types_namespace
    }),
    query: z.never().optional()
});

export const security_get_service_accounts1_response = z.record(security_get_service_accounts_role_descriptor_wrapper);

export const security_get_service_accounts2_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_get_service_accounts2_response = z.record(security_get_service_accounts_role_descriptor_wrapper);

export const security_get_settings_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const security_get_settings_response = z.object({
    security: security_types_security_settings,
    'security-profile': security_types_security_settings,
    'security-tokens': security_types_security_settings
});

export const security_update_settings_request = z.object({
    body: z.object({
        security: security_types_security_settings.optional(),
        'security-profile': security_types_security_settings.optional(),
        'security-tokens': security_types_security_settings.optional()
    }),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const security_update_settings_response = z.object({
    acknowledged: z.boolean()
});

export const security_get_user_privileges_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_get_user_privileges_response = z.object({
    applications: z.array(security_types_application_privileges),
    cluster: z.array(z.string()),
    remote_cluster: z.array(security_types_remote_cluster_privileges).optional(),
    global: z.array(security_types_global_privilege),
    indices: z.array(security_types_user_indices_privileges),
    remote_indices: z.array(security_types_remote_user_indices_privileges).optional(),
    run_as: z.array(z.string())
});

export const security_grant_api_key_request = z.object({
    body: z.object({
        api_key: security_grant_api_key_grant_api_key,
        grant_type: security_grant_api_key_api_key_grant_type,
        access_token: z.string().describe('The user\'s access token.\nIf you specify the `access_token` grant type, this parameter is required.\nIt is not valid with other grant types.').optional(),
        username: types_username.optional(),
        password: types_password.optional(),
        run_as: types_username.optional()
    }),
    path: z.never().optional(),
    query: z.object({
        refresh: types_refresh.optional()
    }).optional()
});

export const security_grant_api_key_response = z.object({
    api_key: z.string(),
    id: types_id,
    name: types_name,
    expiration: types_epoch_time_unit_millis.optional(),
    encoded: z.string()
});

export const security_query_api_keys_request = z.object({
    body: security_query_api_keys.optional(),
    path: z.never().optional(),
    query: z.object({
        with_limited_by: z.boolean().describe('Return the snapshot of the owner user\'s role descriptors associated with the API key.\nAn API key\'s actual permission is the intersection of its assigned role descriptors and the owner user\'s role descriptors (effectively limited by it).\nAn API key cannot retrieve any API keys limited-by role descriptors (including itself) unless it has `manage_api_key` or higher privileges.').optional(),
        with_profile_uid: z.boolean().describe('Determines whether to also retrieve the profile UID for the API key owner principal.\nIf it exists, the profile UID is returned under the `profile_uid` response field for each API key.').optional(),
        typed_keys: z.boolean().describe('Determines whether aggregation names are prefixed by their respective types in the response.').optional()
    }).optional()
});

export const security_query_api_keys_response = z.object({
    total: z.number().describe('The total number of API keys found.'),
    count: z.number().describe('The number of API keys returned in the response.'),
    api_keys: z.array(security_types_api_key).describe('A list of API key information.'),
    aggregations: z.record(security_query_api_keys_api_key_aggregate).describe('The aggregations result, if requested.').optional()
});

export const security_query_api_keys1_request = z.object({
    body: security_query_api_keys.optional(),
    path: z.never().optional(),
    query: z.object({
        with_limited_by: z.boolean().describe('Return the snapshot of the owner user\'s role descriptors associated with the API key.\nAn API key\'s actual permission is the intersection of its assigned role descriptors and the owner user\'s role descriptors (effectively limited by it).\nAn API key cannot retrieve any API keys limited-by role descriptors (including itself) unless it has `manage_api_key` or higher privileges.').optional(),
        with_profile_uid: z.boolean().describe('Determines whether to also retrieve the profile UID for the API key owner principal.\nIf it exists, the profile UID is returned under the `profile_uid` response field for each API key.').optional(),
        typed_keys: z.boolean().describe('Determines whether aggregation names are prefixed by their respective types in the response.').optional()
    }).optional()
});

export const security_query_api_keys1_response = z.object({
    total: z.number().describe('The total number of API keys found.'),
    count: z.number().describe('The number of API keys returned in the response.'),
    api_keys: z.array(security_types_api_key).describe('A list of API key information.'),
    aggregations: z.record(security_query_api_keys_api_key_aggregate).describe('The aggregations result, if requested.').optional()
});

export const security_query_role_request = z.object({
    body: security_query_role.optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_query_role_response = z.object({
    total: z.number().describe('The total number of roles found.'),
    count: z.number().describe('The number of roles returned in the response.'),
    roles: z.array(security_query_role_query_role).describe('A list of roles that match the query.\nThe returned role format is an extension of the role definition format.\nIt adds the `transient_metadata.enabled` and the `_sort` fields.\n`transient_metadata.enabled` is set to `false` in case the role is automatically disabled, for example when the role grants privileges that are not allowed by the installed license.\n`_sort` is present when the search query sorts on some field.\nIt contains the array of values that have been used for sorting.')
});

export const security_query_role1_request = z.object({
    body: security_query_role.optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const security_query_role1_response = z.object({
    total: z.number().describe('The total number of roles found.'),
    count: z.number().describe('The number of roles returned in the response.'),
    roles: z.array(security_query_role_query_role).describe('A list of roles that match the query.\nThe returned role format is an extension of the role definition format.\nIt adds the `transient_metadata.enabled` and the `_sort` fields.\n`transient_metadata.enabled` is set to `false` in case the role is automatically disabled, for example when the role grants privileges that are not allowed by the installed license.\n`_sort` is present when the search query sorts on some field.\nIt contains the array of values that have been used for sorting.')
});

export const security_query_user_request = z.object({
    body: security_query_user.optional(),
    path: z.never().optional(),
    query: z.object({
        with_profile_uid: z.boolean().describe('Determines whether to retrieve the user profile UID, if it exists, for the users.').optional()
    }).optional()
});

export const security_query_user_response = z.object({
    total: z.number().describe('The total number of users found.'),
    count: z.number().describe('The number of users returned in the response.'),
    users: z.array(security_query_user_query_user).describe('A list of users that match the query.')
});

export const security_query_user1_request = z.object({
    body: security_query_user.optional(),
    path: z.never().optional(),
    query: z.object({
        with_profile_uid: z.boolean().describe('Determines whether to retrieve the user profile UID, if it exists, for the users.').optional()
    }).optional()
});

export const security_query_user1_response = z.object({
    total: z.number().describe('The total number of users found.'),
    count: z.number().describe('The number of users returned in the response.'),
    users: z.array(security_query_user_query_user).describe('A list of users that match the query.')
});

export const security_update_api_key_request = z.object({
    body: z.object({
        role_descriptors: z.record(security_types_role_descriptor).describe('The role descriptors to assign to this API key.\nThe API key\'s effective permissions are an intersection of its assigned privileges and the point in time snapshot of permissions of the owner user.\nYou can assign new privileges by specifying them in this parameter.\nTo remove assigned privileges, you can supply an empty `role_descriptors` parameter, that is to say, an empty object `{}`.\nIf an API key has no assigned privileges, it inherits the owner user\'s full permissions.\nThe snapshot of the owner\'s permissions is always updated, whether you supply the `role_descriptors` parameter or not.\nThe structure of a role descriptor is the same as the request for the create API keys API.').optional(),
        metadata: types_metadata.optional(),
        expiration: types_duration.optional()
    }).optional(),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const security_update_api_key_response = z.object({
    updated: z.boolean().describe('If `true`, the API key was updated.\nIf `false`, the API key didn\'t change because no change was detected.')
});

export const security_update_cross_cluster_api_key_request = z.object({
    body: z.object({
        access: security_types_access,
        expiration: types_duration.optional(),
        metadata: types_metadata.optional(),
        certificate_identity: z.string().describe('The certificate identity to associate with this API key.\nThis field is used to restrict the API key to connections authenticated by a specific TLS certificate.\nThe value should match the certificate\'s distinguished name (DN) pattern.\nWhen specified, this fully replaces any previously assigned certificate identity.\nTo clear an existing certificate identity, explicitly set this field to `null`.\nWhen omitted, the existing certificate identity remains unchanged.').optional()
    }),
    path: z.object({
        id: types_id
    }),
    query: z.never().optional()
});

export const security_update_cross_cluster_api_key_response = z.object({
    updated: z.boolean().describe('If `true`, the API key was updated.\nIf `false`, the API key didnt change because no change was detected.')
});

export const simulate_ingest_request = z.object({
    body: simulate_ingest,
    path: z.never().optional(),
    query: z.object({
        pipeline: types_pipeline_name.optional(),
        merge_type: simulate_ingest_merge_type.optional()
    }).optional()
});

export const simulate_ingest_response = z.object({
    docs: z.array(simulate_ingest_simulate_ingest_document_result)
});

export const simulate_ingest1_request = z.object({
    body: simulate_ingest,
    path: z.never().optional(),
    query: z.object({
        pipeline: types_pipeline_name.optional(),
        merge_type: simulate_ingest_merge_type.optional()
    }).optional()
});

export const simulate_ingest1_response = z.object({
    docs: z.array(simulate_ingest_simulate_ingest_document_result)
});

export const simulate_ingest2_request = z.object({
    body: simulate_ingest,
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        pipeline: types_pipeline_name.optional(),
        merge_type: simulate_ingest_merge_type.optional()
    }).optional()
});

export const simulate_ingest2_response = z.object({
    docs: z.array(simulate_ingest_simulate_ingest_document_result)
});

export const simulate_ingest3_request = z.object({
    body: simulate_ingest,
    path: z.object({
        index: types_index_name
    }),
    query: z.object({
        pipeline: types_pipeline_name.optional(),
        merge_type: simulate_ingest_merge_type.optional()
    }).optional()
});

export const simulate_ingest3_response = z.object({
    docs: z.array(simulate_ingest_simulate_ingest_document_result)
});

export const snapshot_restore_request = z.object({
    body: z.object({
        feature_states: z.array(z.string()).describe('The feature states to restore.\nIf `include_global_state` is `true`, the request restores all feature states in the snapshot by default.\nIf `include_global_state` is `false`, the request restores no feature states by default.\nNote that specifying an empty array will result in the default behavior.\nTo restore no feature states, regardless of the `include_global_state` value, specify an array containing only the value `none` (`["none"]`).').optional(),
        ignore_index_settings: z.array(z.string()).describe('The index settings to not restore from the snapshot.\nYou can\'t use this option to ignore `index.number_of_shards`.\n\nFor data streams, this option applies only to restored backing indices.\nNew backing indices are configured using the data stream\'s matching index template.').optional(),
        ignore_unavailable: z.boolean().describe('If `true`, the request ignores any index or data stream in indices that\'s missing from the snapshot.\nIf `false`, the request returns an error for any missing index or data stream.').optional().default(false),
        include_aliases: z.boolean().describe('If `true`, the request restores aliases for any restored data streams and indices.\nIf `false`, the request doesnt restore aliases.').optional().default(true),
        include_global_state: z.boolean().describe('If `true`, restore the cluster state. The cluster state includes:\n\n* Persistent cluster settings\n* Index templates\n* Legacy index templates\n* Ingest pipelines\n* Index lifecycle management (ILM) policies\n* Stored scripts\n* For snapshots taken after 7.12.0, feature states\n\nIf `include_global_state` is `true`, the restore operation merges the legacy index templates in your cluster with the templates contained in the snapshot, replacing any existing ones whose name matches one in the snapshot.\nIt completely removes all persistent settings, non-legacy index templates, ingest pipelines, and ILM lifecycle policies that exist in your cluster and replaces them with the corresponding items from the snapshot.\n\nUse the `feature_states` parameter to configure how feature states are restored.\n\nIf `include_global_state` is `true` and a snapshot was created without a global state then the restore request will fail.').optional().default(false),
        index_settings: indices_types_index_settings.optional(),
        indices: types_indices.optional(),
        partial: z.boolean().describe('If `false`, the entire restore operation will fail if one or more indices included in the snapshot do not have all primary shards available.\n\nIf true, it allows restoring a partial snapshot of indices with unavailable shards.\nOnly shards that were successfully included in the snapshot will be restored.\nAll missing shards will be recreated as empty.').optional().default(false),
        rename_pattern: z.string().describe('A rename pattern to apply to restored data streams and indices.\nData streams and indices matching the rename pattern will be renamed according to `rename_replacement`.\n\nThe rename pattern is applied as defined by the regular expression that supports referencing the original text, according to the `appendReplacement` logic.').optional(),
        rename_replacement: z.string().describe('The rename replacement string that is used with the `rename_pattern`.').optional()
    }).optional(),
    path: z.object({
        repository: types_name,
        snapshot: types_name
    }),
    query: z.object({
        master_timeout: types_duration.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request returns a response when the restore operation completes.\nThe operation is complete when it finishes all attempts to recover primary shards for restored indices.\nThis applies even if one or more of the recovery attempts fail.\n\nIf `false`, the request returns a response when the restore operation initializes.').optional()
    }).optional()
});

export const snapshot_restore_response = z.object({
    accepted: z.boolean().optional(),
    snapshot: snapshot_restore_snapshot_restore.optional()
});

export const sql_query1_request = z.object({
    body: sql_query,
    path: z.never().optional(),
    query: z.object({
        format: sql_query_sql_format.optional()
    }).optional()
});

export const sql_query1_response = z.object({
    columns: z.array(sql_types_column).describe('Column headings for the search results. Each object is a column.').optional(),
    cursor: z.string().describe('The cursor for the next set of paginated results.\nFor CSV, TSV, and TXT responses, this value is returned in the `Cursor` HTTP header.').optional(),
    id: types_id.optional(),
    is_running: z.boolean().describe('If `true`, the search is still running.\nIf `false`, the search has finished.\nThis value is returned only for async and saved synchronous searches.\nFor CSV, TSV, and TXT responses, this value is returned in the `Async-partial` HTTP header.').optional(),
    is_partial: z.boolean().describe('If `true`, the response does not contain complete search results.\nIf `is_partial` is `true` and `is_running` is `true`, the search is still running.\nIf `is_partial` is `true` but `is_running` is `false`, the results are partial due to a failure or timeout.\nThis value is returned only for async and saved synchronous searches.\nFor CSV, TSV, and TXT responses, this value is returned in the `Async-partial` HTTP header.').optional(),
    rows: z.array(sql_types_row).describe('The values for the search results.')
});

export const sql_query_request = z.object({
    body: sql_query,
    path: z.never().optional(),
    query: z.object({
        format: sql_query_sql_format.optional()
    }).optional()
});

export const sql_query_response = z.object({
    columns: z.array(sql_types_column).describe('Column headings for the search results. Each object is a column.').optional(),
    cursor: z.string().describe('The cursor for the next set of paginated results.\nFor CSV, TSV, and TXT responses, this value is returned in the `Cursor` HTTP header.').optional(),
    id: types_id.optional(),
    is_running: z.boolean().describe('If `true`, the search is still running.\nIf `false`, the search has finished.\nThis value is returned only for async and saved synchronous searches.\nFor CSV, TSV, and TXT responses, this value is returned in the `Async-partial` HTTP header.').optional(),
    is_partial: z.boolean().describe('If `true`, the response does not contain complete search results.\nIf `is_partial` is `true` and `is_running` is `true`, the search is still running.\nIf `is_partial` is `true` but `is_running` is `false`, the results are partial due to a failure or timeout.\nThis value is returned only for async and saved synchronous searches.\nFor CSV, TSV, and TXT responses, this value is returned in the `Async-partial` HTTP header.').optional(),
    rows: z.array(sql_types_row).describe('The values for the search results.')
});

export const sql_translate1_request = z.object({
    body: sql_translate,
    path: z.never().optional(),
    query: z.never().optional()
});

export const sql_translate1_response = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).optional(),
    size: z.number().optional(),
    _source: global_search_types_source_config.optional(),
    fields: z.array(types_query_dsl_field_and_format).optional(),
    query: types_query_dsl_query_container.optional(),
    sort: types_sort.optional(),
    track_total_hits: global_search_types_track_hits.optional()
});

export const sql_translate_request = z.object({
    body: sql_translate,
    path: z.never().optional(),
    query: z.never().optional()
});

export const sql_translate_response = z.object({
    aggregations: z.record(types_aggregations_aggregation_container).optional(),
    size: z.number().optional(),
    _source: global_search_types_source_config.optional(),
    fields: z.array(types_query_dsl_field_and_format).optional(),
    query: types_query_dsl_query_container.optional(),
    sort: types_sort.optional(),
    track_total_hits: global_search_types_track_hits.optional()
});

export const terms_enum_request = z.object({
    body: terms_enum,
    path: z.object({
        index: types_indices
    }),
    query: z.never().optional()
});

export const terms_enum_response = z.object({
    _shards: types_shard_statistics,
    terms: z.array(z.string()),
    complete: z.boolean().describe('If `false`, the returned terms set may be incomplete and should be treated as approximate.\nThis can occur due to a few reasons, such as a request timeout or a node error.')
});

export const terms_enum1_request = z.object({
    body: terms_enum,
    path: z.object({
        index: types_indices
    }),
    query: z.never().optional()
});

export const terms_enum1_response = z.object({
    _shards: types_shard_statistics,
    terms: z.array(z.string()),
    complete: z.boolean().describe('If `false`, the returned terms set may be incomplete and should be treated as approximate.\nThis can occur due to a few reasons, such as a request timeout or a node error.')
});

export const text_structure_find_field_structure_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        column_names: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        delimiter: z.string().describe('If you have set `format` to `delimited`, you can specify the character used to delimit the values in each row.\nOnly a single character is supported; the delimiter cannot have multiple characters.\nBy default, the API considers the following possibilities: comma, tab, semi-colon, and pipe (`|`).\nIn this default scenario, all rows must have the same number of fields for the delimited format to be detected.\nIf you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row.').optional(),
        documents_to_sample: types_uint.optional(),
        ecs_compatibility: text_structure_types_ecs_compatibility_type.optional(),
        explain: z.boolean().describe('If `true`, the response includes a field named `explanation`, which is an array of strings that indicate how the structure finder produced its result.').optional(),
        field: types_field,
        format: text_structure_types_format_type.optional(),
        grok_pattern: types_grok_pattern.optional(),
        index: types_index_name,
        quote: z.string().describe('If the format is `delimited`, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character.\nOnly a single character is supported.\nIf this parameter is not specified, the default value is a double quote (`"`).\nIf your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample.').optional(),
        should_trim_fields: z.boolean().describe('If the format is `delimited`, you can specify whether values between delimiters should have whitespace trimmed from them.\nIf this parameter is not specified and the delimiter is pipe (`|`), the default value is true.\nOtherwise, the default value is `false`.').optional(),
        timeout: types_duration.optional(),
        timestamp_field: types_field.optional(),
        timestamp_format: z.string().describe('The Java time format of the timestamp field in the text.\nOnly a subset of Java time format letter groups are supported:\n\n* `a`\n* `d`\n* `dd`\n* `EEE`\n* `EEEE`\n* `H`\n* `HH`\n* `h`\n* `M`\n* `MM`\n* `MMM`\n* `MMMM`\n* `mm`\n* `ss`\n* `XX`\n* `XXX`\n* `yy`\n* `yyyy`\n* `zzz`\n\nAdditionally `S` letter groups (fractional seconds) of length one to nine are supported providing they occur after `ss` and are separated from the `ss` by a period (`.`), comma (`,`), or colon (`:`).\nSpacing and punctuation is also permitted with the exception a question mark (`?`), newline, and carriage return, together with literal text enclosed in single quotes.\nFor example, `MM/dd HH.mm.ss,SSSSSS \'in\' yyyy` is a valid override format.\n\nOne valuable use case for this parameter is when the format is semi-structured text, there are multiple timestamp formats in the text, and you know which format corresponds to the primary timestamp, but you do not want to specify the full `grok_pattern`.\nAnother is when the timestamp format is one that the structure finder does not consider by default.\n\nIf this parameter is not specified, the structure finder chooses the best format from a built-in set.\n\nIf the special value `null` is specified, the structure finder will not look for a primary timestamp in the text.\nWhen the format is semi-structured text, this will result in the structure finder treating the text as single-line messages.').optional()
    })
});

export const text_structure_find_field_structure_response = z.object({
    charset: z.string(),
    ecs_compatibility: text_structure_types_ecs_compatibility_type.optional(),
    field_stats: z.record(text_structure_types_field_stat),
    format: text_structure_types_format_type,
    grok_pattern: types_grok_pattern.optional(),
    java_timestamp_formats: z.array(z.string()).optional(),
    joda_timestamp_formats: z.array(z.string()).optional(),
    ingest_pipeline: ingest_types_pipeline_config,
    mappings: types_mapping_type_mapping,
    multiline_start_pattern: z.string().optional(),
    need_client_timezone: z.boolean(),
    num_lines_analyzed: z.number(),
    num_messages_analyzed: z.number(),
    sample_start: z.string(),
    timestamp_field: types_field.optional()
});

export const text_structure_find_message_structure_request = z.object({
    body: text_structure_find_message_structure,
    path: z.never().optional(),
    query: z.object({
        column_names: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        delimiter: z.string().describe('If you the format is `delimited`, you can specify the character used to delimit the values in each row.\nOnly a single character is supported; the delimiter cannot have multiple characters.\nBy default, the API considers the following possibilities: comma, tab, semi-colon, and pipe (`|`).\nIn this default scenario, all rows must have the same number of fields for the delimited format to be detected.\nIf you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row.').optional(),
        ecs_compatibility: text_structure_types_ecs_compatibility_type.optional(),
        explain: z.boolean().describe('If this parameter is set to true, the response includes a field named `explanation`, which is an array of strings that indicate how the structure finder produced its result.').optional(),
        format: text_structure_types_format_type.optional(),
        grok_pattern: types_grok_pattern.optional(),
        quote: z.string().describe('If the format is `delimited`, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character.\nOnly a single character is supported.\nIf this parameter is not specified, the default value is a double quote (`"`).\nIf your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample.').optional(),
        should_trim_fields: z.boolean().describe('If the format is `delimited`, you can specify whether values between delimiters should have whitespace trimmed from them.\nIf this parameter is not specified and the delimiter is pipe (`|`), the default value is true.\nOtherwise, the default value is `false`.').optional(),
        timeout: types_duration.optional(),
        timestamp_field: types_field.optional(),
        timestamp_format: z.string().describe('The Java time format of the timestamp field in the text.\nOnly a subset of Java time format letter groups are supported:\n\n* `a`\n* `d`\n* `dd`\n* `EEE`\n* `EEEE`\n* `H`\n* `HH`\n* `h`\n* `M`\n* `MM`\n* `MMM`\n* `MMMM`\n* `mm`\n* `ss`\n* `XX`\n* `XXX`\n* `yy`\n* `yyyy`\n* `zzz`\n\nAdditionally `S` letter groups (fractional seconds) of length one to nine are supported providing they occur after `ss` and are separated from the `ss` by a period (`.`), comma (`,`), or colon (`:`).\nSpacing and punctuation is also permitted with the exception a question mark (`?`), newline, and carriage return, together with literal text enclosed in single quotes.\nFor example, `MM/dd HH.mm.ss,SSSSSS \'in\' yyyy` is a valid override format.\n\nOne valuable use case for this parameter is when the format is semi-structured text, there are multiple timestamp formats in the text, and you know which format corresponds to the primary timestamp, but you do not want to specify the full `grok_pattern`.\nAnother is when the timestamp format is one that the structure finder does not consider by default.\n\nIf this parameter is not specified, the structure finder chooses the best format from a built-in set.\n\nIf the special value `null` is specified, the structure finder will not look for a primary timestamp in the text.\nWhen the format is semi-structured text, this will result in the structure finder treating the text as single-line messages.').optional()
    }).optional()
});

export const text_structure_find_message_structure_response = z.object({
    charset: z.string(),
    ecs_compatibility: text_structure_types_ecs_compatibility_type.optional(),
    field_stats: z.record(text_structure_types_field_stat),
    format: text_structure_types_format_type,
    grok_pattern: types_grok_pattern.optional(),
    java_timestamp_formats: z.array(z.string()).optional(),
    joda_timestamp_formats: z.array(z.string()).optional(),
    ingest_pipeline: ingest_types_pipeline_config,
    mappings: types_mapping_type_mapping,
    multiline_start_pattern: z.string().optional(),
    need_client_timezone: z.boolean(),
    num_lines_analyzed: z.number(),
    num_messages_analyzed: z.number(),
    sample_start: z.string(),
    timestamp_field: types_field.optional()
});

export const text_structure_find_message_structure1_request = z.object({
    body: text_structure_find_message_structure,
    path: z.never().optional(),
    query: z.object({
        column_names: z.union([
            z.string(),
            z.array(z.string())
        ]).optional(),
        delimiter: z.string().describe('If you the format is `delimited`, you can specify the character used to delimit the values in each row.\nOnly a single character is supported; the delimiter cannot have multiple characters.\nBy default, the API considers the following possibilities: comma, tab, semi-colon, and pipe (`|`).\nIn this default scenario, all rows must have the same number of fields for the delimited format to be detected.\nIf you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row.').optional(),
        ecs_compatibility: text_structure_types_ecs_compatibility_type.optional(),
        explain: z.boolean().describe('If this parameter is set to true, the response includes a field named `explanation`, which is an array of strings that indicate how the structure finder produced its result.').optional(),
        format: text_structure_types_format_type.optional(),
        grok_pattern: types_grok_pattern.optional(),
        quote: z.string().describe('If the format is `delimited`, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character.\nOnly a single character is supported.\nIf this parameter is not specified, the default value is a double quote (`"`).\nIf your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample.').optional(),
        should_trim_fields: z.boolean().describe('If the format is `delimited`, you can specify whether values between delimiters should have whitespace trimmed from them.\nIf this parameter is not specified and the delimiter is pipe (`|`), the default value is true.\nOtherwise, the default value is `false`.').optional(),
        timeout: types_duration.optional(),
        timestamp_field: types_field.optional(),
        timestamp_format: z.string().describe('The Java time format of the timestamp field in the text.\nOnly a subset of Java time format letter groups are supported:\n\n* `a`\n* `d`\n* `dd`\n* `EEE`\n* `EEEE`\n* `H`\n* `HH`\n* `h`\n* `M`\n* `MM`\n* `MMM`\n* `MMMM`\n* `mm`\n* `ss`\n* `XX`\n* `XXX`\n* `yy`\n* `yyyy`\n* `zzz`\n\nAdditionally `S` letter groups (fractional seconds) of length one to nine are supported providing they occur after `ss` and are separated from the `ss` by a period (`.`), comma (`,`), or colon (`:`).\nSpacing and punctuation is also permitted with the exception a question mark (`?`), newline, and carriage return, together with literal text enclosed in single quotes.\nFor example, `MM/dd HH.mm.ss,SSSSSS \'in\' yyyy` is a valid override format.\n\nOne valuable use case for this parameter is when the format is semi-structured text, there are multiple timestamp formats in the text, and you know which format corresponds to the primary timestamp, but you do not want to specify the full `grok_pattern`.\nAnother is when the timestamp format is one that the structure finder does not consider by default.\n\nIf this parameter is not specified, the structure finder chooses the best format from a built-in set.\n\nIf the special value `null` is specified, the structure finder will not look for a primary timestamp in the text.\nWhen the format is semi-structured text, this will result in the structure finder treating the text as single-line messages.').optional()
    }).optional()
});

export const text_structure_find_message_structure1_response = z.object({
    charset: z.string(),
    ecs_compatibility: text_structure_types_ecs_compatibility_type.optional(),
    field_stats: z.record(text_structure_types_field_stat),
    format: text_structure_types_format_type,
    grok_pattern: types_grok_pattern.optional(),
    java_timestamp_formats: z.array(z.string()).optional(),
    joda_timestamp_formats: z.array(z.string()).optional(),
    ingest_pipeline: ingest_types_pipeline_config,
    mappings: types_mapping_type_mapping,
    multiline_start_pattern: z.string().optional(),
    need_client_timezone: z.boolean(),
    num_lines_analyzed: z.number(),
    num_messages_analyzed: z.number(),
    sample_start: z.string(),
    timestamp_field: types_field.optional()
});

export const text_structure_find_structure_request = z.object({
    body: z.array(z.record(z.unknown())),
    path: z.never().optional(),
    query: z.object({
        charset: z.string().describe('The text\'s character set.\nIt must be a character set that is supported by the JVM that Elasticsearch uses.\nFor example, `UTF-8`, `UTF-16LE`, `windows-1252`, or `EUC-JP`.\nIf this parameter is not specified, the structure finder chooses an appropriate character set.').optional(),
        column_names: z.string().describe('If you have set format to `delimited`, you can specify the column names in a comma-separated list.\nIf this parameter is not specified, the structure finder uses the column names from the header row of the text.\nIf the text does not have a header role, columns are named "column1", "column2", "column3", for example.').optional(),
        delimiter: z.string().describe('If you have set `format` to `delimited`, you can specify the character used to delimit the values in each row.\nOnly a single character is supported; the delimiter cannot have multiple characters.\nBy default, the API considers the following possibilities: comma, tab, semi-colon, and pipe (`|`).\nIn this default scenario, all rows must have the same number of fields for the delimited format to be detected.\nIf you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row.').optional(),
        ecs_compatibility: z.string().describe('The mode of compatibility with ECS compliant Grok patterns.\nUse this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern.\nValid values are `disabled` and `v1`.\nThis setting primarily has an impact when a whole message Grok pattern such as `%{CATALINALOG}` matches the input.\nIf the structure finder identifies a common structure but has no idea of meaning then generic field names such as `path`, `ipaddress`, `field1`, and `field2` are used in the `grok_pattern` output, with the intention that a user who knows the meanings rename these fields before using it.').optional(),
        explain: z.boolean().describe('If this parameter is set to `true`, the response includes a field named explanation, which is an array of strings that indicate how the structure finder produced its result.\nIf the structure finder produces unexpected results for some text, use this query parameter to help you determine why the returned structure was chosen.').optional(),
        format: z.string().describe('The high level structure of the text.\nValid values are `ndjson`, `xml`, `delimited`, and `semi_structured_text`.\nBy default, the API chooses the format.\nIn this default scenario, all rows must have the same number of fields for a delimited format to be detected.\nIf the format is set to `delimited` and the delimiter is not set, however, the API tolerates up to 5% of rows that have a different number of columns than the first row.').optional(),
        grok_pattern: types_grok_pattern.optional(),
        has_header_row: z.boolean().describe('If you have set `format` to `delimited`, you can use this parameter to indicate whether the column names are in the first row of the text.\nIf this parameter is not specified, the structure finder guesses based on the similarity of the first row of the text to other rows.').optional(),
        line_merge_size_limit: types_uint.optional(),
        lines_to_sample: types_uint.optional(),
        quote: z.string().describe('If you have set `format` to `delimited`, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character.\nOnly a single character is supported.\nIf this parameter is not specified, the default value is a double quote (`"`).\nIf your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample.').optional(),
        should_trim_fields: z.boolean().describe('If you have set `format` to `delimited`, you can specify whether values between delimiters should have whitespace trimmed from them.\nIf this parameter is not specified and the delimiter is pipe (`|`), the default value is `true`.\nOtherwise, the default value is `false`.').optional(),
        timeout: types_duration.optional(),
        timestamp_field: types_field.optional(),
        timestamp_format: z.string().describe('The Java time format of the timestamp field in the text.\n\nOnly a subset of Java time format letter groups are supported:\n\n* `a`\n* `d`\n* `dd`\n* `EEE`\n* `EEEE`\n* `H`\n* `HH`\n* `h`\n* `M`\n* `MM`\n* `MMM`\n* `MMMM`\n* `mm`\n* `ss`\n* `XX`\n* `XXX`\n* `yy`\n* `yyyy`\n* `zzz`\n\nAdditionally `S` letter groups (fractional seconds) of length one to nine are supported providing they occur after `ss` and separated from the `ss` by a `.`, `,` or `:`.\nSpacing and punctuation is also permitted with the exception of `?`, newline and carriage return, together with literal text enclosed in single quotes.\nFor example, `MM/dd HH.mm.ss,SSSSSS \'in\' yyyy` is a valid override format.\n\nOne valuable use case for this parameter is when the format is semi-structured text, there are multiple timestamp formats in the text, and you know which format corresponds to the primary timestamp, but you do not want to specify the full `grok_pattern`.\nAnother is when the timestamp format is one that the structure finder does not consider by default.\n\nIf this parameter is not specified, the structure finder chooses the best format from a built-in set.\n\nIf the special value `null` is specified the structure finder will not look for a primary timestamp in the text.\nWhen the format is semi-structured text this will result in the structure finder treating the text as single-line messages.').optional()
    }).optional()
});

export const text_structure_find_structure_response = z.object({
    charset: z.string().describe('The character encoding used to parse the text.'),
    has_header_row: z.boolean().optional(),
    has_byte_order_marker: z.boolean().describe('For UTF character encodings, it indicates whether the text begins with a byte order marker.'),
    format: z.string().describe('Valid values include `ndjson`, `xml`, `delimited`, and `semi_structured_text`.'),
    field_stats: z.record(text_structure_types_field_stat).describe('The most common values of each field, plus basic numeric statistics for the numeric `page_count` field.\nThis information may provide clues that the data needs to be cleaned or transformed prior to use by other Elastic Stack functionality.'),
    sample_start: z.string().describe('The first two messages in the text verbatim.\nThis may help diagnose parse errors or accidental uploads of the wrong text.'),
    num_messages_analyzed: z.number().describe('The number of distinct messages the lines contained.\nFor NDJSON, this value is the same as `num_lines_analyzed`.\nFor other text formats, messages can span several lines.'),
    mappings: types_mapping_type_mapping,
    quote: z.string().optional(),
    delimiter: z.string().optional(),
    need_client_timezone: z.boolean().describe('If a timestamp format is detected that does not include a timezone, `need_client_timezone` is `true`.\nThe server that parses the text must therefore be told the correct timezone by the client.'),
    num_lines_analyzed: z.number().describe('The number of lines of the text that were analyzed.'),
    column_names: z.array(z.string()).describe('If `format` is `delimited`, the `column_names` field lists the column names in the order they appear in the sample.').optional(),
    explanation: z.array(z.string()).optional(),
    grok_pattern: types_grok_pattern.optional(),
    multiline_start_pattern: z.string().optional(),
    exclude_lines_pattern: z.string().optional(),
    java_timestamp_formats: z.array(z.string()).describe('The Java time formats recognized in the time fields.\nElasticsearch mappings and ingest pipelines use this format.').optional(),
    joda_timestamp_formats: z.array(z.string()).describe('Information that is used to tell Logstash how to parse timestamps.').optional(),
    timestamp_field: types_field.optional(),
    should_trim_fields: z.boolean().optional(),
    ingest_pipeline: ingest_types_pipeline_config
});

export const transform_get_transform_request = z.object({
    body: z.never().optional(),
    path: z.object({
        transform_id: types_names
    }),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no transforms that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf this parameter is false, the request returns a 404 status code when\nthere are no matches or only partial matches.').optional(),
        from: z.number().describe('Skips the specified number of transforms.').optional(),
        size: z.number().describe('Specifies the maximum number of transforms to obtain.').optional(),
        exclude_generated: z.boolean().describe('Excludes fields that were automatically added when creating the\ntransform. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.').optional()
    }).optional()
});

export const transform_get_transform_response = z.object({
    count: z.number(),
    transforms: z.array(transform_get_transform_transform_summary)
});

export const transform_put_transform_request = z.object({
    body: z.object({
        dest: transform_types_destination,
        description: z.string().describe('Free text description of the transform.').optional(),
        frequency: types_duration.optional(),
        latest: transform_types_latest.optional(),
        _meta: types_metadata.optional(),
        pivot: transform_types_pivot.optional(),
        retention_policy: transform_types_retention_policy_container.optional(),
        settings: transform_types_settings.optional(),
        source: transform_types_source,
        sync: transform_types_sync_container.optional()
    }),
    path: z.object({
        transform_id: types_id
    }),
    query: z.object({
        defer_validation: z.boolean().describe('When the transform is created, a series of validations occur to ensure its success. For example, there is a\ncheck for the existence of the source indices and a check that the destination index is not part of the source\nindex pattern. You can use this parameter to skip the checks, for example when the source index does not exist\nuntil after the transform is created. The validations are always run when you start the transform, however, with\nthe exception of privilege checks.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const transform_put_transform_response = types_acknowledged_response_base;

export const transform_get_transform1_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        allow_no_match: z.boolean().describe('Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no transforms that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf this parameter is false, the request returns a 404 status code when\nthere are no matches or only partial matches.').optional(),
        from: z.number().describe('Skips the specified number of transforms.').optional(),
        size: z.number().describe('Specifies the maximum number of transforms to obtain.').optional(),
        exclude_generated: z.boolean().describe('Excludes fields that were automatically added when creating the\ntransform. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.').optional()
    }).optional()
});

export const transform_get_transform1_response = z.object({
    count: z.number(),
    transforms: z.array(transform_get_transform_transform_summary)
});

export const transform_preview_transform_request = z.object({
    body: transform_preview_transform.optional(),
    path: z.object({
        transform_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const transform_preview_transform_response = z.object({
    generated_dest_index: indices_types_index_state,
    preview: z.array(z.record(z.unknown()))
});

export const transform_preview_transform1_request = z.object({
    body: transform_preview_transform.optional(),
    path: z.object({
        transform_id: types_id
    }),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const transform_preview_transform1_response = z.object({
    generated_dest_index: indices_types_index_state,
    preview: z.array(z.record(z.unknown()))
});

export const transform_preview_transform2_request = z.object({
    body: transform_preview_transform.optional(),
    path: z.never().optional(),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const transform_preview_transform2_response = z.object({
    generated_dest_index: indices_types_index_state,
    preview: z.array(z.record(z.unknown()))
});

export const transform_preview_transform3_request = z.object({
    body: transform_preview_transform.optional(),
    path: z.never().optional(),
    query: z.object({
        timeout: types_duration.optional()
    }).optional()
});

export const transform_preview_transform3_response = z.object({
    generated_dest_index: indices_types_index_state,
    preview: z.array(z.record(z.unknown()))
});

export const transform_update_transform_request = z.object({
    body: z.object({
        dest: transform_types_destination.optional(),
        description: z.string().describe('Free text description of the transform.').optional(),
        frequency: types_duration.optional(),
        _meta: types_metadata.optional(),
        source: transform_types_source.optional(),
        settings: transform_types_settings.optional(),
        sync: transform_types_sync_container.optional(),
        retention_policy: z.union([
            transform_types_retention_policy_container,
            z.string(),
            z.null()
        ]).optional()
    }),
    path: z.object({
        transform_id: types_id
    }),
    query: z.object({
        defer_validation: z.boolean().describe('When true, deferrable validations are not run. This behavior may be\ndesired if the source index does not exist until after the transform is\ncreated.').optional(),
        timeout: types_duration.optional()
    }).optional()
});

export const transform_update_transform_response = z.object({
    authorization: ml_types_transform_authorization.optional(),
    create_time: z.number(),
    description: z.string(),
    dest: global_reindex_destination,
    frequency: types_duration.optional(),
    id: types_id,
    latest: transform_types_latest.optional(),
    pivot: transform_types_pivot.optional(),
    retention_policy: transform_types_retention_policy_container.optional(),
    settings: transform_types_settings,
    source: global_reindex_source,
    sync: transform_types_sync_container.optional(),
    version: types_version_string,
    _meta: types_metadata.optional()
});

export const update_request = z.object({
    body: z.object({
        detect_noop: z.boolean().describe('If `true`, the `result` in the response is set to `noop` (no operation) when there are no changes to the document.').optional().default(true),
        doc: z.record(z.unknown()).describe('A partial update to an existing document.\nIf both `doc` and `script` are specified, `doc` is ignored.').optional(),
        doc_as_upsert: z.boolean().describe('If `true`, use the contents of \'doc\' as the value of \'upsert\'.\nNOTE: Using ingest pipelines with `doc_as_upsert` is not supported.').optional().default(false),
        script: types_script.optional(),
        scripted_upsert: z.boolean().describe('If `true`, run the script whether or not the document exists.').optional().default(false),
        _source: global_search_types_source_config.optional(),
        upsert: z.record(z.unknown()).describe('If the document does not already exist, the contents of \'upsert\' are inserted as a new document.\nIf the document exists, the \'script\' is run.').optional()
    }),
    path: z.object({
        index: types_index_name,
        id: types_id
    }),
    query: z.object({
        if_primary_term: z.number().describe('Only perform the operation if the document has this primary term.').optional(),
        if_seq_no: types_sequence_number.optional(),
        include_source_on_error: z.boolean().describe('True or false if to include the document source in the error message in case of parsing errors.').optional(),
        lang: z.string().describe('The script language.').optional(),
        refresh: types_refresh.optional(),
        require_alias: z.boolean().describe('If `true`, the destination must be an index alias.').optional(),
        retry_on_conflict: z.number().describe('The number of times the operation should be retried when a conflict occurs.').optional(),
        routing: types_routing.optional(),
        timeout: types_duration.optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        _source: global_search_types_source_config_param.optional(),
        _source_excludes: types_fields.optional(),
        _source_includes: types_fields.optional()
    }).optional()
});

export const update_response = global_update_update_write_response_base;

export const update_by_query_request = z.object({
    body: z.object({
        max_docs: z.number().describe('The maximum number of documents to update.').optional(),
        query: types_query_dsl_query_container.optional(),
        script: types_script.optional(),
        slice: types_sliced_scroll.optional(),
        conflicts: types_conflicts.optional()
    }).optional(),
    path: z.object({
        index: types_indices
    }),
    query: z.object({
        allow_no_indices: z.boolean().describe('If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.').optional(),
        analyzer: z.string().describe('The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        analyze_wildcard: z.boolean().describe('If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        conflicts: types_conflicts.optional(),
        default_operator: types_query_dsl_operator.optional(),
        df: z.string().describe('The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        expand_wildcards: types_expand_wildcards.optional(),
        from: z.number().describe('Skips the specified number of documents.').optional(),
        ignore_unavailable: z.boolean().describe('If `false`, the request returns an error if it targets a missing or closed index.').optional(),
        lenient: z.boolean().describe('If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.').optional(),
        max_docs: z.number().describe('The maximum number of documents to process.\nIt defaults to all documents.\nWhen set to a value less then or equal to `scroll_size` then a scroll will not be used to retrieve the results for the operation.').optional(),
        pipeline: z.string().describe('The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.').optional(),
        preference: z.string().describe('The node or shard the operation should be performed on.\nIt is random by default.').optional(),
        q: z.string().describe('A query in the Lucene query string syntax.').optional(),
        refresh: z.boolean().describe('If `true`, Elasticsearch refreshes affected shards to make the operation visible to search after the request completes.\nThis is different than the update API\'s `refresh` parameter, which causes just the shard that received the request to be refreshed.').optional(),
        request_cache: z.boolean().describe('If `true`, the request cache is used for this request.\nIt defaults to the index-level setting.').optional(),
        requests_per_second: z.number().describe('The throttle for this request in sub-requests per second.').optional(),
        routing: types_routing.optional(),
        scroll: types_duration.optional(),
        scroll_size: z.number().describe('The size of the scroll request that powers the operation.').optional(),
        search_timeout: types_duration.optional(),
        search_type: types_search_type.optional(),
        slices: types_slices.optional(),
        sort: z.array(z.string()).describe('A comma-separated list of <field>:<direction> pairs.').optional(),
        stats: z.array(z.string()).describe('The specific `tag` of the request for logging and statistical purposes.').optional(),
        terminate_after: z.number().describe('The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.').optional(),
        timeout: types_duration.optional(),
        version: z.boolean().describe('If `true`, returns the document version as part of a hit.').optional(),
        version_type: z.boolean().describe('Should the document increment the version number (internal) on hit or not (reindex)').optional(),
        wait_for_active_shards: types_wait_for_active_shards.optional(),
        wait_for_completion: z.boolean().describe('If `true`, the request blocks until the operation is complete.\nIf `false`, Elasticsearch performs some preflight checks, launches the request, and returns a task ID that you can use to cancel or get the status of the task.\nElasticsearch creates a record of this task as a document at `.tasks/task/${taskId}`.').optional()
    }).optional()
});

export const update_by_query_response = z.object({
    batches: z.number().describe('The number of scroll responses pulled back by the update by query.').optional(),
    failures: z.array(types_bulk_index_by_scroll_failure).describe('Array of failures if there were any unrecoverable errors during the process.\nIf this is non-empty then the request ended because of those failures.\nUpdate by query is implemented using batches.\nAny failure causes the entire process to end, but all failures in the current batch are collected into the array.\nYou can use the `conflicts` option to prevent reindex from ending when version conflicts occur.').optional(),
    noops: z.number().describe('The number of documents that were ignored because the script used for the update by query returned a noop value for `ctx.op`.').optional(),
    deleted: z.number().describe('The number of documents that were successfully deleted.').optional(),
    requests_per_second: z.number().describe('The number of requests per second effectively run during the update by query.').optional(),
    retries: types_retries.optional(),
    task: types_task_id.optional(),
    timed_out: z.boolean().describe('If true, some requests timed out during the update by query.').optional(),
    took: types_duration_value_unit_millis.optional(),
    total: z.number().describe('The number of documents that were successfully processed.').optional(),
    updated: z.number().describe('The number of documents that were successfully updated.').optional(),
    version_conflicts: z.number().describe('The number of version conflicts that the update by query hit.').optional(),
    throttled: types_duration.optional(),
    throttled_millis: types_duration_value_unit_millis.optional(),
    throttled_until: types_duration.optional(),
    throttled_until_millis: types_duration_value_unit_millis.optional()
});

export const watcher_get_watch_request = z.object({
    body: z.never().optional(),
    path: z.object({
        id: types_name
    }),
    query: z.never().optional()
});

export const watcher_get_watch_response = z.object({
    found: z.boolean(),
    _id: types_id,
    status: watcher_types_watch_status.optional(),
    watch: watcher_types_watch.optional(),
    _primary_term: z.number().optional(),
    _seq_no: types_sequence_number.optional(),
    _version: types_version_number.optional()
});

export const watcher_put_watch1_request = z.object({
    body: watcher_put_watch,
    path: z.object({
        id: types_id
    }),
    query: z.object({
        active: z.boolean().describe('The initial state of the watch.\nThe default value is `true`, which means the watch is active by default.').optional(),
        if_primary_term: z.number().describe('only update the watch if the last operation that has changed the watch has the specified primary term').optional(),
        if_seq_no: types_sequence_number.optional(),
        version: types_version_number.optional()
    }).optional()
});

export const watcher_put_watch1_response = z.object({
    created: z.boolean(),
    _id: types_id,
    _primary_term: z.number(),
    _seq_no: types_sequence_number,
    _version: types_version_number
});

export const watcher_put_watch_request = z.object({
    body: watcher_put_watch,
    path: z.object({
        id: types_id
    }),
    query: z.object({
        active: z.boolean().describe('The initial state of the watch.\nThe default value is `true`, which means the watch is active by default.').optional(),
        if_primary_term: z.number().describe('only update the watch if the last operation that has changed the watch has the specified primary term').optional(),
        if_seq_no: types_sequence_number.optional(),
        version: types_version_number.optional()
    }).optional()
});

export const watcher_put_watch_response = z.object({
    created: z.boolean(),
    _id: types_id,
    _primary_term: z.number(),
    _seq_no: types_sequence_number,
    _version: types_version_number
});

export const watcher_execute_watch1_request = z.object({
    body: watcher_execute_watch.optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        debug: z.boolean().describe('Defines whether the watch runs in debug mode.').optional()
    }).optional()
});

export const watcher_execute_watch1_response = z.object({
    _id: types_id,
    watch_record: watcher_execute_watch_watch_record
});

export const watcher_execute_watch_request = z.object({
    body: watcher_execute_watch.optional(),
    path: z.object({
        id: types_id
    }),
    query: z.object({
        debug: z.boolean().describe('Defines whether the watch runs in debug mode.').optional()
    }).optional()
});

export const watcher_execute_watch_response = z.object({
    _id: types_id,
    watch_record: watcher_execute_watch_watch_record
});

export const watcher_execute_watch3_request = z.object({
    body: watcher_execute_watch.optional(),
    path: z.never().optional(),
    query: z.object({
        debug: z.boolean().describe('Defines whether the watch runs in debug mode.').optional()
    }).optional()
});

export const watcher_execute_watch3_response = z.object({
    _id: types_id,
    watch_record: watcher_execute_watch_watch_record
});

export const watcher_execute_watch2_request = z.object({
    body: watcher_execute_watch.optional(),
    path: z.never().optional(),
    query: z.object({
        debug: z.boolean().describe('Defines whether the watch runs in debug mode.').optional()
    }).optional()
});

export const watcher_execute_watch2_response = z.object({
    _id: types_id,
    watch_record: watcher_execute_watch_watch_record
});

export const watcher_get_settings_request = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        master_timeout: types_duration.optional()
    }).optional()
});

export const watcher_get_settings_response = z.object({
    index: indices_types_index_settings
});

export const watcher_query_watches_request = z.object({
    body: watcher_query_watches.optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const watcher_query_watches_response = z.object({
    count: z.number().describe('The total number of watches found.'),
    watches: z.array(watcher_types_query_watch).describe('A list of watches based on the `from`, `size`, or `search_after` request body parameters.')
});

export const watcher_query_watches1_request = z.object({
    body: watcher_query_watches.optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

export const watcher_query_watches1_response = z.object({
    count: z.number().describe('The total number of watches found.'),
    watches: z.array(watcher_types_query_watch).describe('A list of watches based on the `from`, `size`, or `search_after` request body parameters.')
});
