/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import Path from 'path';

import { asyncForEachWithLimit } from '@kbn/std';
import type { ImportResolver } from '@kbn/import-resolver';

import { readFile, readFileSync } from './fs';
import { getImportRequests } from './get_import_requests';

function isObj(v: any): v is Record<string, unknown> {
  return typeof v === 'object' && v !== null;
}

function getPeerDeps(thisNodeModule: string) {
  const pkgPath = require.resolve(`${thisNodeModule}/package.json`);
  const pkg = JSON.parse(readFileSync(pkgPath));

  if (isObj(pkg) && isObj(pkg.peerDependencies)) {
    return Object.keys(pkg.peerDependencies);
  } else {
    return [];
  }
}

interface Options {
  resolver: ImportResolver;
  entryPaths: string[];
  findUsedPeers: boolean;
  // if we are finding used modules in a node_module, this must be the name of the node_module
  // we should treat as "this module" rather than "another node module"
  thisNodeModule?: string;
}

/**
 * Parse a list of entry paths and find the node_modules which are required by them. If the
 * entry path requires/imports a non-node_module then that file is scanned too, deeply, until
 * all referenced files are scanned.
 *
 * Optionally, we can find the used peers of the used node_modules. This will keep track of all
 * the paths we use to enter a node_module and then traverse from those points, finding the
 * used modules and comparing those to the `peerDependencies` listed in the node_module's package.json
 * file. If a used dependeny is in the `peerDependencies` and is used by the node_module it will
 * be included in the results.
 *
 * This was implemented mostly for `@emotion/react` which is used by @elastic/eui but only listed
 * as a peerDependency. If we didn't keep it in the Kibana package.json then the package would not
 * be installed and cause an error on startup because `@emotion/react` can't be found. We used to
 * solve this by scanning the node_modules directory for all the packages which are used but that
 * was much slower and lead to extra entries in package.json.
 */
export async function findUsedNodeModules(options: Options) {
  const queue = new Set<string>(options.entryPaths);
  const results = new Set<string>();

  const entryPathsIntoNodeModules = new Map<string, Set<string>>();

  for (const path of queue) {
    if (Path.extname(path) !== '.js') {
      continue;
    }

    const dirname = Path.dirname(path);
    const code = await readFile(path);
    const reqs = getImportRequests(code);

    for (const req of reqs) {
      // resolve the request to it's actual file on dist
      const result = options.resolver.resolve(req, dirname);

      // ignore non-file resolution results, these represent files which aren't on
      // the file-system yet (like during the build) built-ins, explicitily ignored
      // files, and @types only imports
      if (result?.type !== 'file') {
        continue;
      }

      // if the result points to a node_module (or another node_module)...
      if (result.nodeModule && result.nodeModule !== options.thisNodeModule) {
        // add it to the results
        results.add(result.nodeModule);

        // record this absolute path as an entry path into the node module from our entries, if we
        // need to scan this node_module for used deps we need to know how we access it.
        const nmEntries = entryPathsIntoNodeModules.get(result.nodeModule);
        if (!nmEntries) {
          entryPathsIntoNodeModules.set(result.nodeModule, new Set([result.absolute]));
        } else {
          nmEntries.add(result.absolute);
        }
      }

      // no need to scan node_modules unless they're bazel packages
      if (
        !result.nodeModule ||
        result.nodeModule === options.thisNodeModule ||
        options.resolver.isBazelPackage(result.nodeModule)
      ) {
        queue.add(result.absolute);
      }
    }
  }

  if (options.findUsedPeers) {
    await asyncForEachWithLimit(results, 10, async (dep) => {
      const entryPaths = entryPathsIntoNodeModules.get(dep);
      if (!entryPaths?.size) {
        return;
      }

      const peerDeps = getPeerDeps(dep);
      if (!peerDeps.length) {
        return;
      }

      const usedInside = await findUsedNodeModules({
        resolver: options.resolver,
        entryPaths: Array.from(entryPaths),
        findUsedPeers: false,
        thisNodeModule: dep,
      });

      for (const peer of peerDeps) {
        if (usedInside.includes(peer)) {
          results.add(peer);
        }
      }
    });
  }

  return Array.from(results).sort((a, b) => a.localeCompare(b));
}
