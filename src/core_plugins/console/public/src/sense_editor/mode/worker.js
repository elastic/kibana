exports.id = 'sense_editor/mode/worker';
exports.src = '(function(window) {\n  function resolveModuleId(id, paths) {\n    for (var testPath = id, tail = \'\'; testPath; ) {\n      var alias = paths[testPath];\n      if (\'string\' == typeof alias) return alias + tail;\n      if (alias)\n        return (\n          alias.location.replace(/\\/*$/, \'/\') +\n          (tail || alias.main || alias.name)\n        );\n      if (alias === !1) return \'\';\n      var i = testPath.lastIndexOf(\'/\');\n      if (-1 === i) break;\n      (tail = testPath.substr(i) + tail), (testPath = testPath.slice(0, i));\n    }\n    return id;\n  }\n  if (\n    !(\n      (void 0 !== window.window \&\& window.document) ||\n      (window.acequire \&\& window.define)\n    )\n  ) {\n    window.console ||\n      ((window.console = function() {\n        var msgs = Array.prototype.slice.call(arguments, 0);\n        postMessage({ type: \'log\', data: msgs });\n      }),\n      (window.console.error = window.console.warn = window.console.log = window.console.trace =\n        window.console)),\n      (window.window = window),\n      (window.ace = window),\n      (window.onerror = function(message, file, line, col, err) {\n        postMessage({\n          type: \'error\',\n          data: {\n            message: message,\n            data: err.data,\n            file: file,\n            line: line,\n            col: col,\n            stack: err.stack,\n          },\n        });\n      }),\n      (window.normalizeModule = function(parentId, moduleName) {\n        if (-1 !== moduleName.indexOf(\'!\')) {\n          var chunks = moduleName.split(\'!\');\n          return (\n            window.normalizeModule(parentId, chunks[0]) +\n            \'!\' +\n            window.normalizeModule(parentId, chunks[1])\n          );\n        }\n        if (\'.\' == moduleName.charAt(0)) {\n          var base = parentId\n            .split(\'/\')\n            .slice(0, -1)\n            .join(\'/\');\n          for (\n            moduleName = (base ? base + \'/\' : \'\') + moduleName;\n            -1 !== moduleName.indexOf(\'.\') \&\& previous != moduleName;\n\n          ) {\n            var previous = moduleName;\n            moduleName = moduleName\n              .replace(/^\\.\\//, \'\')\n              .replace(/\\/\\.\\//, \'/\')\n              .replace(/[^\\/]+\\/\\.\\.\\//, \'\');\n          }\n        }\n        return moduleName;\n      }),\n      (window.acequire = function acequire(parentId, id) {\n        if ((id || ((id = parentId), (parentId = null)), !id.charAt))\n          throw Error(\n            \'worker.js acequire() accepts only (parentId, id) as arguments\'\n          );\n        id = window.normalizeModule(parentId, id);\n        var module = window.acequire.modules[id];\n        if (module)\n          return (\n            module.initialized ||\n              ((module.initialized = !0),\n              (module.exports = module.factory().exports)),\n            module.exports\n          );\n        if (!window.acequire.tlns) return console.log(\'unable to load \' + id);\n        var path = resolveModuleId(id, window.acequire.tlns);\n        return (\n          \'.js\' != path.slice(-3) \&\& (path += \'.js\'),\n          (window.acequire.id = id),\n          (window.acequire.modules[id] = {}),\n          importScripts(path),\n          window.acequire(parentId, id)\n        );\n      }),\n      (window.acequire.modules = {}),\n      (window.acequire.tlns = {}),\n      (window.define = function(id, deps, factory) {\n        if (\n          (2 == arguments.length\n            ? ((factory = deps),\n              \'string\' != typeof id \&\& ((deps = id), (id = window.acequire.id)))\n            : 1 == arguments.length \&\&\n              ((factory = id), (deps = []), (id = window.acequire.id)),\n          \'function\' != typeof factory)\n        )\n          return (\n            (window.acequire.modules[id] = {\n              exports: factory,\n              initialized: !0,\n            }),\n            void 0\n          );\n        deps.length || (deps = [\'require\', \'exports\', \'module\']);\n        var req = function(childId) {\n          return window.acequire(id, childId);\n        };\n        window.acequire.modules[id] = {\n          exports: {},\n          factory: function() {\n            var module = this,\n              returnExports = factory.apply(\n                this,\n                deps.map(function(dep) {\n                  switch (dep) {\n                    case \'require\':\n                      return req;\n                    case \'exports\':\n                      return module.exports;\n                    case \'module\':\n                      return module;\n                    default:\n                      return req(dep);\n                  }\n                })\n              );\n            return returnExports \&\& (module.exports = returnExports), module;\n          },\n        };\n      }),\n      (window.define.amd = {}),\n      (acequire.tlns = {}),\n      (window.initBaseUrls = function(topLevelNamespaces) {\n        for (var i in topLevelNamespaces)\n          acequire.tlns[i] = topLevelNamespaces[i];\n      }),\n      (window.initSender = function() {\n        var EventEmitter = window.acequire(\'ace/lib/event_emitter\')\n            .EventEmitter,\n          oop = window.acequire(\'ace/lib/oop\'),\n          Sender = function() {};\n        return (\n          function() {\n            oop.implement(this, EventEmitter),\n              (this.callback = function(data, callbackId) {\n                postMessage({ type: \'call\', id: callbackId, data: data });\n              }),\n              (this.emit = function(name, data) {\n                postMessage({ type: \'event\', name: name, data: data });\n              });\n          }.call(Sender.prototype),\n          new Sender()\n        );\n      });\n    var main = (window.main = null),\n      sender = (window.sender = null);\n    window.onmessage = function(e) {\n      var msg = e.data;\n      if (msg.event \&\& sender) sender._signal(msg.event, msg.data);\n      else if (msg.command)\n        if (main[msg.command]) main[msg.command].apply(main, msg.args);\n        else {\n          if (!window[msg.command])\n            throw Error(\'Unknown command:\' + msg.command);\n          window[msg.command].apply(window, msg.args);\n        }\n      else if (msg.init) {\n        window.initBaseUrls(msg.tlns),\n          acequire(\'ace/lib/es5-shim\'),\n          (sender = window.sender = window.initSender());\n        var clazz = acequire(msg.module)[msg.classname];\n        main = window.main = new clazz(sender);\n      }\n    };\n  }\n})(this),\n  ace.define(\'ace/lib/oop\', [\'require\', \'exports\', \'module\'], function(\n    acequire,\n    exports\n  ) {\n    \'use strict\';\n    (exports.inherits = function(ctor, superCtor) {\n      (ctor.super_ = superCtor),\n        (ctor.prototype = Object.create(superCtor.prototype, {\n          constructor: {\n            value: ctor,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0,\n          },\n        }));\n    }),\n      (exports.mixin = function(obj, mixin) {\n        for (var key in mixin) obj[key] = mixin[key];\n        return obj;\n      }),\n      (exports.implement = function(proto, mixin) {\n        exports.mixin(proto, mixin);\n      });\n  }),\n  ace.define(\'ace/range\', [\'require\', \'exports\', \'module\'], function(\n    acequire,\n    exports\n  ) {\n    \'use strict\';\n    var comparePoints = function(p1, p2) {\n        return p1.row - p2.row || p1.column - p2.column;\n      },\n      Range = function(startRow, startColumn, endRow, endColumn) {\n        (this.start = { row: startRow, column: startColumn }),\n          (this.end = { row: endRow, column: endColumn });\n      };\n    (function() {\n      (this.isEqual = function(range) {\n        return (\n          this.start.row === range.start.row \&\&\n          this.end.row === range.end.row \&\&\n          this.start.column === range.start.column \&\&\n          this.end.column === range.end.column\n        );\n      }),\n        (this.toString = function() {\n          return (\n            \'Range: [\' +\n            this.start.row +\n            \'/\' +\n            this.start.column +\n            \'] -> [\' +\n            this.end.row +\n            \'/\' +\n            this.end.column +\n            \']\'\n          );\n        }),\n        (this.contains = function(row, column) {\n          return 0 == this.compare(row, column);\n        }),\n        (this.compareRange = function(range) {\n          var cmp,\n            end = range.end,\n            start = range.start;\n          return (\n            (cmp = this.compare(end.row, end.column)),\n            1 == cmp\n              ? ((cmp = this.compare(start.row, start.column)),\n                1 == cmp ? 2 : 0 == cmp ? 1 : 0)\n              : -1 == cmp\n                ? -2\n                : ((cmp = this.compare(start.row, start.column)),\n                  -1 == cmp ? -1 : 1 == cmp ? 42 : 0)\n          );\n        }),\n        (this.comparePoint = function(p) {\n          return this.compare(p.row, p.column);\n        }),\n        (this.containsRange = function(range) {\n          return (\n            0 == this.comparePoint(range.start) \&\&\n            0 == this.comparePoint(range.end)\n          );\n        }),\n        (this.intersects = function(range) {\n          var cmp = this.compareRange(range);\n          return -1 == cmp || 0 == cmp || 1 == cmp;\n        }),\n        (this.isEnd = function(row, column) {\n          return this.end.row == row \&\& this.end.column == column;\n        }),\n        (this.isStart = function(row, column) {\n          return this.start.row == row \&\& this.start.column == column;\n        }),\n        (this.setStart = function(row, column) {\n          \'object\' == typeof row\n            ? ((this.start.column = row.column), (this.start.row = row.row))\n            : ((this.start.row = row), (this.start.column = column));\n        }),\n        (this.setEnd = function(row, column) {\n          \'object\' == typeof row\n            ? ((this.end.column = row.column), (this.end.row = row.row))\n            : ((this.end.row = row), (this.end.column = column));\n        }),\n        (this.inside = function(row, column) {\n          return 0 == this.compare(row, column)\n            ? this.isEnd(row, column) || this.isStart(row, column)\n              ? !1\n              : !0\n            : !1;\n        }),\n        (this.insideStart = function(row, column) {\n          return 0 == this.compare(row, column)\n            ? this.isEnd(row, column)\n              ? !1\n              : !0\n            : !1;\n        }),\n        (this.insideEnd = function(row, column) {\n          return 0 == this.compare(row, column)\n            ? this.isStart(row, column)\n              ? !1\n              : !0\n            : !1;\n        }),\n        (this.compare = function(row, column) {\n          return this.isMultiLine() || row !== this.start.row\n            ? this.start.row > row\n              ? -1\n              : row > this.end.row\n                ? 1\n                : this.start.row === row\n                  ? column >= this.start.column\n                    ? 0\n                    : -1\n                  : this.end.row === row\n                    ? this.end.column >= column\n                      ? 0\n                      : 1\n                    : 0\n            : this.start.column > column\n              ? -1\n              : column > this.end.column\n                ? 1\n                : 0;\n        }),\n        (this.compareStart = function(row, column) {\n          return this.start.row == row \&\& this.start.column == column\n            ? -1\n            : this.compare(row, column);\n        }),\n        (this.compareEnd = function(row, column) {\n          return this.end.row == row \&\& this.end.column == column\n            ? 1\n            : this.compare(row, column);\n        }),\n        (this.compareInside = function(row, column) {\n          return this.end.row == row \&\& this.end.column == column\n            ? 1\n            : this.start.row == row \&\& this.start.column == column\n              ? -1\n              : this.compare(row, column);\n        }),\n        (this.clipRows = function(firstRow, lastRow) {\n          if (this.end.row > lastRow) var end = { row: lastRow + 1, column: 0 };\n          else if (firstRow > this.end.row)\n            var end = { row: firstRow, column: 0 };\n          if (this.start.row > lastRow)\n            var start = { row: lastRow + 1, column: 0 };\n          else if (firstRow > this.start.row)\n            var start = { row: firstRow, column: 0 };\n          return Range.fromPoints(start || this.start, end || this.end);\n        }),\n        (this.extend = function(row, column) {\n          var cmp = this.compare(row, column);\n          if (0 == cmp) return this;\n          if (-1 == cmp) var start = { row: row, column: column };\n          else var end = { row: row, column: column };\n          return Range.fromPoints(start || this.start, end || this.end);\n        }),\n        (this.isEmpty = function() {\n          return (\n            this.start.row === this.end.row \&\&\n            this.start.column === this.end.column\n          );\n        }),\n        (this.isMultiLine = function() {\n          return this.start.row !== this.end.row;\n        }),\n        (this.clone = function() {\n          return Range.fromPoints(this.start, this.end);\n        }),\n        (this.collapseRows = function() {\n          return 0 == this.end.column\n            ? new Range(\n                this.start.row,\n                0,\n                Math.max(this.start.row, this.end.row - 1),\n                0\n              )\n            : new Range(this.start.row, 0, this.end.row, 0);\n        }),\n        (this.toScreenRange = function(session) {\n          var screenPosStart = session.documentToScreenPosition(this.start),\n            screenPosEnd = session.documentToScreenPosition(this.end);\n          return new Range(\n            screenPosStart.row,\n            screenPosStart.column,\n            screenPosEnd.row,\n            screenPosEnd.column\n          );\n        }),\n        (this.moveBy = function(row, column) {\n          (this.start.row += row),\n            (this.start.column += column),\n            (this.end.row += row),\n            (this.end.column += column);\n        });\n    }.call(Range.prototype),\n      (Range.fromPoints = function(start, end) {\n        return new Range(start.row, start.column, end.row, end.column);\n      }),\n      (Range.comparePoints = comparePoints),\n      (Range.comparePoints = function(p1, p2) {\n        return p1.row - p2.row || p1.column - p2.column;\n      }),\n      (exports.Range = Range));\n  }),\n  ace.define(\'ace/apply_delta\', [\'require\', \'exports\', \'module\'], function(\n    acequire,\n    exports\n  ) {\n    \'use strict\';\n    exports.applyDelta = function(docLines, delta) {\n      var row = delta.start.row,\n        startColumn = delta.start.column,\n        line = docLines[row] || \'\';\n      switch (delta.action) {\n        case \'insert\':\n          var lines = delta.lines;\n          if (1 === lines.length)\n            docLines[row] =\n              line.substring(0, startColumn) +\n              delta.lines[0] +\n              line.substring(startColumn);\n          else {\n            var args = [row, 1].concat(delta.lines);\n            docLines.splice.apply(docLines, args),\n              (docLines[row] = line.substring(0, startColumn) + docLines[row]),\n              (docLines[row + delta.lines.length - 1] += line.substring(\n                startColumn\n              ));\n          }\n          break;\n        case \'remove\':\n          var endColumn = delta.end.column,\n            endRow = delta.end.row;\n          row === endRow\n            ? (docLines[row] =\n                line.substring(0, startColumn) + line.substring(endColumn))\n            : docLines.splice(\n                row,\n                endRow - row + 1,\n                line.substring(0, startColumn) +\n                  docLines[endRow].substring(endColumn)\n              );\n      }\n    };\n  }),\n  ace.define(\n    \'ace/lib/event_emitter\',\n    [\'require\', \'exports\', \'module\'],\n    function(acequire, exports) {\n      \'use strict\';\n      var EventEmitter = {},\n        stopPropagation = function() {\n          this.propagationStopped = !0;\n        },\n        preventDefault = function() {\n          this.defaultPrevented = !0;\n        };\n      (EventEmitter._emit = EventEmitter._dispatchEvent = function(\n        eventName,\n        e\n      ) {\n        this._eventRegistry || (this._eventRegistry = {}),\n          this._defaultHandlers || (this._defaultHandlers = {});\n        var listeners = this._eventRegistry[eventName] || [],\n          defaultHandler = this._defaultHandlers[eventName];\n        if (listeners.length || defaultHandler) {\n          (\'object\' == typeof e \&\& e) || (e = {}),\n            e.type || (e.type = eventName),\n            e.stopPropagation || (e.stopPropagation = stopPropagation),\n            e.preventDefault || (e.preventDefault = preventDefault),\n            (listeners = listeners.slice());\n          for (\n            var i = 0;\n            listeners.length > i \&\&\n            (listeners[i](e, this), !e.propagationStopped);\n            i++\n          );\n          return defaultHandler \&\& !e.defaultPrevented\n            ? defaultHandler(e, this)\n            : void 0;\n        }\n      }),\n        (EventEmitter._signal = function(eventName, e) {\n          var listeners = (this._eventRegistry || {})[eventName];\n          if (listeners) {\n            listeners = listeners.slice();\n            for (var i = 0; listeners.length > i; i++) listeners[i](e, this);\n          }\n        }),\n        (EventEmitter.once = function(eventName, callback) {\n          var _self = this;\n          callback \&\&\n            this.addEventListener(eventName, function newCallback() {\n              _self.removeEventListener(eventName, newCallback),\n                callback.apply(null, arguments);\n            });\n        }),\n        (EventEmitter.setDefaultHandler = function(eventName, callback) {\n          var handlers = this._defaultHandlers;\n          if (\n            (handlers ||\n              (handlers = this._defaultHandlers = { _disabled_: {} }),\n            handlers[eventName])\n          ) {\n            var old = handlers[eventName],\n              disabled = handlers._disabled_[eventName];\n            disabled || (handlers._disabled_[eventName] = disabled = []),\n              disabled.push(old);\n            var i = disabled.indexOf(callback);\n            -1 != i \&\& disabled.splice(i, 1);\n          }\n          handlers[eventName] = callback;\n        }),\n        (EventEmitter.removeDefaultHandler = function(eventName, callback) {\n          var handlers = this._defaultHandlers;\n          if (handlers) {\n            var disabled = handlers._disabled_[eventName];\n            if (handlers[eventName] == callback)\n              handlers[eventName],\n                disabled \&\& this.setDefaultHandler(eventName, disabled.pop());\n            else if (disabled) {\n              var i = disabled.indexOf(callback);\n              -1 != i \&\& disabled.splice(i, 1);\n            }\n          }\n        }),\n        (EventEmitter.on = EventEmitter.addEventListener = function(\n          eventName,\n          callback,\n          capturing\n        ) {\n          this._eventRegistry = this._eventRegistry || {};\n          var listeners = this._eventRegistry[eventName];\n          return (\n            listeners || (listeners = this._eventRegistry[eventName] = []),\n            -1 == listeners.indexOf(callback) \&\&\n              listeners[capturing ? \'unshift\' : \'push\'](callback),\n            callback\n          );\n        }),\n        (EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(\n          eventName,\n          callback\n        ) {\n          this._eventRegistry = this._eventRegistry || {};\n          var listeners = this._eventRegistry[eventName];\n          if (listeners) {\n            var index = listeners.indexOf(callback);\n            -1 !== index \&\& listeners.splice(index, 1);\n          }\n        }),\n        (EventEmitter.removeAllListeners = function(eventName) {\n          this._eventRegistry \&\& (this._eventRegistry[eventName] = []);\n        }),\n        (exports.EventEmitter = EventEmitter);\n    }\n  ),\n  ace.define(\n    \'ace/anchor\',\n    [\'require\', \'exports\', \'module\', \'ace/lib/oop\', \'ace/lib/event_emitter\'],\n    function(acequire, exports) {\n      \'use strict\';\n      var oop = acequire(\'./lib/oop\'),\n        EventEmitter = acequire(\'./lib/event_emitter\').EventEmitter,\n        Anchor = (exports.Anchor = function(doc, row, column) {\n          (this.$onChange = this.onChange.bind(this)),\n            this.attach(doc),\n            column === void 0\n              ? this.setPosition(row.row, row.column)\n              : this.setPosition(row, column);\n        });\n      (function() {\n        function $pointsInOrder(point1, point2, equalPointsInOrder) {\n          var bColIsAfter = equalPointsInOrder\n            ? point1.column <= point2.column\n            : point1.column < point2.column;\n          return (\n            point1.row < point2.row || (point1.row == point2.row \&\& bColIsAfter)\n          );\n        }\n        function $getTransformedPoint(delta, point, moveIfEqual) {\n          var deltaIsInsert = \'insert\' == delta.action,\n            deltaRowShift =\n              (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row),\n            deltaColShift =\n              (deltaIsInsert ? 1 : -1) *\n              (delta.end.column - delta.start.column),\n            deltaStart = delta.start,\n            deltaEnd = deltaIsInsert ? deltaStart : delta.end;\n          return $pointsInOrder(point, deltaStart, moveIfEqual)\n            ? { row: point.row, column: point.column }\n            : $pointsInOrder(deltaEnd, point, !moveIfEqual)\n              ? {\n                  row: point.row + deltaRowShift,\n                  column:\n                    point.column +\n                    (point.row == deltaEnd.row ? deltaColShift : 0),\n                }\n              : { row: deltaStart.row, column: deltaStart.column };\n        }\n        oop.implement(this, EventEmitter),\n          (this.getPosition = function() {\n            return this.$clipPositionToDocument(this.row, this.column);\n          }),\n          (this.getDocument = function() {\n            return this.document;\n          }),\n          (this.$insertRight = !1),\n          (this.onChange = function(delta) {\n            if (\n              !(\n                (delta.start.row == delta.end.row \&\&\n                  delta.start.row != this.row) ||\n                delta.start.row > this.row\n              )\n            ) {\n              var point = $getTransformedPoint(\n                delta,\n                { row: this.row, column: this.column },\n                this.$insertRight\n              );\n              this.setPosition(point.row, point.column, !0);\n            }\n          }),\n          (this.setPosition = function(row, column, noClip) {\n            var pos;\n            if (\n              ((pos = noClip\n                ? { row: row, column: column }\n                : this.$clipPositionToDocument(row, column)),\n              this.row != pos.row || this.column != pos.column)\n            ) {\n              var old = { row: this.row, column: this.column };\n              (this.row = pos.row),\n                (this.column = pos.column),\n                this._signal(\'change\', { old: old, value: pos });\n            }\n          }),\n          (this.detach = function() {\n            this.document.removeEventListener(\'change\', this.$onChange);\n          }),\n          (this.attach = function(doc) {\n            (this.document = doc || this.document),\n              this.document.on(\'change\', this.$onChange);\n          }),\n          (this.$clipPositionToDocument = function(row, column) {\n            var pos = {};\n            return (\n              row >= this.document.getLength()\n                ? ((pos.row = Math.max(0, this.document.getLength() - 1)),\n                  (pos.column = this.document.getLine(pos.row).length))\n                : 0 > row\n                  ? ((pos.row = 0), (pos.column = 0))\n                  : ((pos.row = row),\n                    (pos.column = Math.min(\n                      this.document.getLine(pos.row).length,\n                      Math.max(0, column)\n                    ))),\n              0 > column \&\& (pos.column = 0),\n              pos\n            );\n          });\n      }.call(Anchor.prototype));\n    }\n  ),\n  ace.define(\n    \'ace/document\',\n    [\n      \'require\',\n      \'exports\',\n      \'module\',\n      \'ace/lib/oop\',\n      \'ace/apply_delta\',\n      \'ace/lib/event_emitter\',\n      \'ace/range\',\n      \'ace/anchor\',\n    ],\n    function(acequire, exports) {\n      \'use strict\';\n      var oop = acequire(\'./lib/oop\'),\n        applyDelta = acequire(\'./apply_delta\').applyDelta,\n        EventEmitter = acequire(\'./lib/event_emitter\').EventEmitter,\n        Range = acequire(\'./range\').Range,\n        Anchor = acequire(\'./anchor\').Anchor,\n        Document = function(textOrLines) {\n          (this.$lines = [\'\']),\n            0 === textOrLines.length\n              ? (this.$lines = [\'\'])\n              : Array.isArray(textOrLines)\n                ? this.insertMergedLines({ row: 0, column: 0 }, textOrLines)\n                : this.insert({ row: 0, column: 0 }, textOrLines);\n        };\n      (function() {\n        oop.implement(this, EventEmitter),\n          (this.setValue = function(text) {\n            var len = this.getLength() - 1;\n            this.remove(new Range(0, 0, len, this.getLine(len).length)),\n              this.insert({ row: 0, column: 0 }, text);\n          }),\n          (this.getValue = function() {\n            return this.getAllLines().join(this.getNewLineCharacter());\n          }),\n          (this.createAnchor = function(row, column) {\n            return new Anchor(this, row, column);\n          }),\n          (this.$split =\n            0 === \'aaa\'.split(/a/).length\n              ? function(text) {\n                  return text.replace(/\\r\\n|\\r/g, \'\\n\').split(\'\\n\');\n                }\n              : function(text) {\n                  return text.split(/\\r\\n|\\r|\\n/);\n                }),\n          (this.$detectNewLine = function(text) {\n            var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n            (this.$autoNewLine = match ? match[1] : \'\\n\'),\n              this._signal(\'changeNewLineMode\');\n          }),\n          (this.getNewLineCharacter = function() {\n            switch (this.$newLineMode) {\n              case \'windows\':\n                return \'\\r\\n\';\n              case \'unix\':\n                return \'\\n\';\n              default:\n                return this.$autoNewLine || \'\\n\';\n            }\n          }),\n          (this.$autoNewLine = \'\'),\n          (this.$newLineMode = \'auto\'),\n          (this.setNewLineMode = function(newLineMode) {\n            this.$newLineMode !== newLineMode \&\&\n              ((this.$newLineMode = newLineMode),\n              this._signal(\'changeNewLineMode\'));\n          }),\n          (this.getNewLineMode = function() {\n            return this.$newLineMode;\n          }),\n          (this.isNewLine = function(text) {\n            return \'\\r\\n\' == text || \'\\r\' == text || \'\\n\' == text;\n          }),\n          (this.getLine = function(row) {\n            return this.$lines[row] || \'\';\n          }),\n          (this.getLines = function(firstRow, lastRow) {\n            return this.$lines.slice(firstRow, lastRow + 1);\n          }),\n          (this.getAllLines = function() {\n            return this.getLines(0, this.getLength());\n          }),\n          (this.getLength = function() {\n            return this.$lines.length;\n          }),\n          (this.getTextRange = function(range) {\n            return this.getLinesForRange(range).join(\n              this.getNewLineCharacter()\n            );\n          }),\n          (this.getLinesForRange = function(range) {\n            var lines;\n            if (range.start.row === range.end.row)\n              lines = [\n                this.getLine(range.start.row).substring(\n                  range.start.column,\n                  range.end.column\n                ),\n              ];\n            else {\n              (lines = this.getLines(range.start.row, range.end.row)),\n                (lines[0] = (lines[0] || \'\').substring(range.start.column));\n              var l = lines.length - 1;\n              range.end.row - range.start.row == l \&\&\n                (lines[l] = lines[l].substring(0, range.end.column));\n            }\n            return lines;\n          }),\n          (this.insertLines = function(row, lines) {\n            return (\n              console.warn(\n                \'Use of document.insertLines is deprecated. Use the insertFullLines method instead.\'\n              ),\n              this.insertFullLines(row, lines)\n            );\n          }),\n          (this.removeLines = function(firstRow, lastRow) {\n            return (\n              console.warn(\n                \'Use of document.removeLines is deprecated. Use the removeFullLines method instead.\'\n              ),\n              this.removeFullLines(firstRow, lastRow)\n            );\n          }),\n          (this.insertNewLine = function(position) {\n            return (\n              console.warn(\n                \"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, [\'\', \'\']) instead.\"\n              ),\n              this.insertMergedLines(position, [\'\', \'\'])\n            );\n          }),\n          (this.insert = function(position, text) {\n            return (\n              1 >= this.getLength() \&\& this.$detectNewLine(text),\n              this.insertMergedLines(position, this.$split(text))\n            );\n          }),\n          (this.insertInLine = function(position, text) {\n            var start = this.clippedPos(position.row, position.column),\n              end = this.pos(position.row, position.column + text.length);\n            return (\n              this.applyDelta(\n                { start: start, end: end, action: \'insert\', lines: [text] },\n                !0\n              ),\n              this.clonePos(end)\n            );\n          }),\n          (this.clippedPos = function(row, column) {\n            var length = this.getLength();\n            void 0 === row\n              ? (row = length)\n              : 0 > row\n                ? (row = 0)\n                : row >= length \&\& ((row = length - 1), (column = void 0));\n            var line = this.getLine(row);\n            return (\n              void 0 == column \&\& (column = line.length),\n              (column = Math.min(Math.max(column, 0), line.length)),\n              { row: row, column: column }\n            );\n          }),\n          (this.clonePos = function(pos) {\n            return { row: pos.row, column: pos.column };\n          }),\n          (this.pos = function(row, column) {\n            return { row: row, column: column };\n          }),\n          (this.$clipPosition = function(position) {\n            var length = this.getLength();\n            return (\n              position.row >= length\n                ? ((position.row = Math.max(0, length - 1)),\n                  (position.column = this.getLine(length - 1).length))\n                : ((position.row = Math.max(0, position.row)),\n                  (position.column = Math.min(\n                    Math.max(position.column, 0),\n                    this.getLine(position.row).length\n                  ))),\n              position\n            );\n          }),\n          (this.insertFullLines = function(row, lines) {\n            row = Math.min(Math.max(row, 0), this.getLength());\n            var column = 0;\n            this.getLength() > row\n              ? ((lines = lines.concat([\'\'])), (column = 0))\n              : ((lines = [\'\'].concat(lines)),\n                row--,\n                (column = this.$lines[row].length)),\n              this.insertMergedLines({ row: row, column: column }, lines);\n          }),\n          (this.insertMergedLines = function(position, lines) {\n            var start = this.clippedPos(position.row, position.column),\n              end = {\n                row: start.row + lines.length - 1,\n                column:\n                  (1 == lines.length ? start.column : 0) +\n                  lines[lines.length - 1].length,\n              };\n            return (\n              this.applyDelta({\n                start: start,\n                end: end,\n                action: \'insert\',\n                lines: lines,\n              }),\n              this.clonePos(end)\n            );\n          }),\n          (this.remove = function(range) {\n            var start = this.clippedPos(range.start.row, range.start.column),\n              end = this.clippedPos(range.end.row, range.end.column);\n            return (\n              this.applyDelta({\n                start: start,\n                end: end,\n                action: \'remove\',\n                lines: this.getLinesForRange({ start: start, end: end }),\n              }),\n              this.clonePos(start)\n            );\n          }),\n          (this.removeInLine = function(row, startColumn, endColumn) {\n            var start = this.clippedPos(row, startColumn),\n              end = this.clippedPos(row, endColumn);\n            return (\n              this.applyDelta(\n                {\n                  start: start,\n                  end: end,\n                  action: \'remove\',\n                  lines: this.getLinesForRange({ start: start, end: end }),\n                },\n                !0\n              ),\n              this.clonePos(start)\n            );\n          }),\n          (this.removeFullLines = function(firstRow, lastRow) {\n            (firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1)),\n              (lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1));\n            var deleteFirstNewLine =\n                lastRow == this.getLength() - 1 \&\& firstRow > 0,\n              deleteLastNewLine = this.getLength() - 1 > lastRow,\n              startRow = deleteFirstNewLine ? firstRow - 1 : firstRow,\n              startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0,\n              endRow = deleteLastNewLine ? lastRow + 1 : lastRow,\n              endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length,\n              range = new Range(startRow, startCol, endRow, endCol),\n              deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n            return (\n              this.applyDelta({\n                start: range.start,\n                end: range.end,\n                action: \'remove\',\n                lines: this.getLinesForRange(range),\n              }),\n              deletedLines\n            );\n          }),\n          (this.removeNewLine = function(row) {\n            this.getLength() - 1 > row \&\&\n              row >= 0 \&\&\n              this.applyDelta({\n                start: this.pos(row, this.getLine(row).length),\n                end: this.pos(row + 1, 0),\n                action: \'remove\',\n                lines: [\'\', \'\'],\n              });\n          }),\n          (this.replace = function(range, text) {\n            if (\n              (range instanceof Range ||\n                (range = Range.fromPoints(range.start, range.end)),\n              0 === text.length \&\& range.isEmpty())\n            )\n              return range.start;\n            if (text == this.getTextRange(range)) return range.end;\n            this.remove(range);\n            var end;\n            return (end = text ? this.insert(range.start, text) : range.start);\n          }),\n          (this.applyDeltas = function(deltas) {\n            for (var i = 0; deltas.length > i; i++) this.applyDelta(deltas[i]);\n          }),\n          (this.revertDeltas = function(deltas) {\n            for (var i = deltas.length - 1; i >= 0; i--)\n              this.revertDelta(deltas[i]);\n          }),\n          (this.applyDelta = function(delta, doNotValidate) {\n            var isInsert = \'insert\' == delta.action;\n            (isInsert\n              ? 1 >= delta.lines.length \&\& !delta.lines[0]\n              : !Range.comparePoints(delta.start, delta.end)) ||\n              (isInsert \&\&\n                delta.lines.length > 2e4 \&\&\n                this.$splitAndapplyLargeDelta(delta, 2e4),\n              applyDelta(this.$lines, delta, doNotValidate),\n              this._signal(\'change\', delta));\n          }),\n          (this.$splitAndapplyLargeDelta = function(delta, MAX) {\n            for (\n              var lines = delta.lines,\n                l = lines.length,\n                row = delta.start.row,\n                column = delta.start.column,\n                from = 0,\n                to = 0;\n              ;\n\n            ) {\n              (from = to), (to += MAX - 1);\n              var chunk = lines.slice(from, to);\n              if (to > l) {\n                (delta.lines = chunk),\n                  (delta.start.row = row + from),\n                  (delta.start.column = column);\n                break;\n              }\n              chunk.push(\'\'),\n                this.applyDelta(\n                  {\n                    start: this.pos(row + from, column),\n                    end: this.pos(row + to, (column = 0)),\n                    action: delta.action,\n                    lines: chunk,\n                  },\n                  !0\n                );\n            }\n          }),\n          (this.revertDelta = function(delta) {\n            this.applyDelta({\n              start: this.clonePos(delta.start),\n              end: this.clonePos(delta.end),\n              action: \'insert\' == delta.action ? \'remove\' : \'insert\',\n              lines: delta.lines.slice(),\n            });\n          }),\n          (this.indexToPosition = function(index, startRow) {\n            for (\n              var lines = this.$lines || this.getAllLines(),\n                newlineLength = this.getNewLineCharacter().length,\n                i = startRow || 0,\n                l = lines.length;\n              l > i;\n              i++\n            )\n              if (((index -= lines[i].length + newlineLength), 0 > index))\n                return {\n                  row: i,\n                  column: index + lines[i].length + newlineLength,\n                };\n            return { row: l - 1, column: lines[l - 1].length };\n          }),\n          (this.positionToIndex = function(pos, startRow) {\n            for (\n              var lines = this.$lines || this.getAllLines(),\n                newlineLength = this.getNewLineCharacter().length,\n                index = 0,\n                row = Math.min(pos.row, lines.length),\n                i = startRow || 0;\n              row > i;\n              ++i\n            )\n              index += lines[i].length + newlineLength;\n            return index + pos.column;\n          });\n      }.call(Document.prototype),\n        (exports.Document = Document));\n    }\n  ),\n  ace.define(\'ace/lib/lang\', [\'require\', \'exports\', \'module\'], function(\n    acequire,\n    exports\n  ) {\n    \'use strict\';\n    (exports.last = function(a) {\n      return a[a.length - 1];\n    }),\n      (exports.stringReverse = function(string) {\n        return string\n          .split(\'\')\n          .reverse()\n          .join(\'\');\n      }),\n      (exports.stringRepeat = function(string, count) {\n        for (var result = \'\'; count > 0; )\n          1 \& count \&\& (result += string), (count >>= 1) \&\& (string += string);\n        return result;\n      });\n    var trimBeginRegexp = /^\\s\\s*/,\n      trimEndRegexp = /\\s\\s*$/;\n    (exports.stringTrimLeft = function(string) {\n      return string.replace(trimBeginRegexp, \'\');\n    }),\n      (exports.stringTrimRight = function(string) {\n        return string.replace(trimEndRegexp, \'\');\n      }),\n      (exports.copyObject = function(obj) {\n        var copy = {};\n        for (var key in obj) copy[key] = obj[key];\n        return copy;\n      }),\n      (exports.copyArray = function(array) {\n        for (var copy = [], i = 0, l = array.length; l > i; i++)\n          copy[i] =\n            array[i] \&\& \'object\' == typeof array[i]\n              ? this.copyObject(array[i])\n              : array[i];\n        return copy;\n      }),\n      (exports.deepCopy = function deepCopy(obj) {\n        if (\'object\' != typeof obj || !obj) return obj;\n        var copy;\n        if (Array.isArray(obj)) {\n          copy = [];\n          for (var key = 0; obj.length > key; key++)\n            copy[key] = deepCopy(obj[key]);\n          return copy;\n        }\n        if (\'[object Object]\' !== Object.prototype.toString.call(obj))\n          return obj;\n        copy = {};\n        for (var key in obj) copy[key] = deepCopy(obj[key]);\n        return copy;\n      }),\n      (exports.arrayToMap = function(arr) {\n        for (var map = {}, i = 0; arr.length > i; i++) map[arr[i]] = 1;\n        return map;\n      }),\n      (exports.createMap = function(props) {\n        var map = Object.create(null);\n        for (var i in props) map[i] = props[i];\n        return map;\n      }),\n      (exports.arrayRemove = function(array, value) {\n        for (var i = 0; array.length >= i; i++)\n          value === array[i] \&\& array.splice(i, 1);\n      }),\n      (exports.escapeRegExp = function(str) {\n        return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, \'\\\\$1\');\n      }),\n      (exports.escapeHTML = function(str) {\n        return str\n          .replace(/\&/g, \'\&#38;\')\n          .replace(/\"/g, \'\&#34;\')\n          .replace(/\'/g, \'\&#39;\')\n          .replace(/</g, \'\&#60;\');\n      }),\n      (exports.getMatchOffsets = function(string, regExp) {\n        var matches = [];\n        return (\n          string.replace(regExp, function(str) {\n            matches.push({\n              offset: arguments[arguments.length - 2],\n              length: str.length,\n            });\n          }),\n          matches\n        );\n      }),\n      (exports.deferredCall = function(fcn) {\n        var timer = null,\n          callback = function() {\n            (timer = null), fcn();\n          },\n          deferred = function(timeout) {\n            return (\n              deferred.cancel(),\n              (timer = setTimeout(callback, timeout || 0)),\n              deferred\n            );\n          };\n        return (\n          (deferred.schedule = deferred),\n          (deferred.call = function() {\n            return this.cancel(), fcn(), deferred;\n          }),\n          (deferred.cancel = function() {\n            return clearTimeout(timer), (timer = null), deferred;\n          }),\n          (deferred.isPending = function() {\n            return timer;\n          }),\n          deferred\n        );\n      }),\n      (exports.delayedCall = function(fcn, defaultTimeout) {\n        var timer = null,\n          callback = function() {\n            (timer = null), fcn();\n          },\n          _self = function(timeout) {\n            null == timer \&\&\n              (timer = setTimeout(callback, timeout || defaultTimeout));\n          };\n        return (\n          (_self.delay = function(timeout) {\n            timer \&\& clearTimeout(timer),\n              (timer = setTimeout(callback, timeout || defaultTimeout));\n          }),\n          (_self.schedule = _self),\n          (_self.call = function() {\n            this.cancel(), fcn();\n          }),\n          (_self.cancel = function() {\n            timer \&\& clearTimeout(timer), (timer = null);\n          }),\n          (_self.isPending = function() {\n            return timer;\n          }),\n          _self\n        );\n      });\n  }),\n  ace.define(\n    \'ace/worker/mirror\',\n    [\n      \'require\',\n      \'exports\',\n      \'module\',\n      \'ace/range\',\n      \'ace/document\',\n      \'ace/lib/lang\',\n    ],\n    function(acequire, exports) {\n      \'use strict\';\n      acequire(\'../range\').Range;\n      var Document = acequire(\'../document\').Document,\n        lang = acequire(\'../lib/lang\'),\n        Mirror = (exports.Mirror = function(sender) {\n          this.sender = sender;\n          var doc = (this.doc = new Document(\'\')),\n            deferredUpdate = (this.deferredUpdate = lang.delayedCall(\n              this.onUpdate.bind(this)\n            )),\n            _self = this;\n          sender.on(\'change\', function(e) {\n            var data = e.data;\n            if (data[0].start) doc.applyDeltas(data);\n            else\n              for (var i = 0; data.length > i; i += 2) {\n                if (Array.isArray(data[i + 1]))\n                  var d = {\n                    action: \'insert\',\n                    start: data[i],\n                    lines: data[i + 1],\n                  };\n                else\n                  var d = {\n                    action: \'remove\',\n                    start: data[i],\n                    end: data[i + 1],\n                  };\n                doc.applyDelta(d, !0);\n              }\n            return _self.$timeout\n              ? deferredUpdate.schedule(_self.$timeout)\n              : (_self.onUpdate(), void 0);\n          });\n        });\n      (function() {\n        (this.$timeout = 500),\n          (this.setTimeout = function(timeout) {\n            this.$timeout = timeout;\n          }),\n          (this.setValue = function(value) {\n            this.doc.setValue(value),\n              this.deferredUpdate.schedule(this.$timeout);\n          }),\n          (this.getValue = function(callbackId) {\n            this.sender.callback(this.doc.getValue(), callbackId);\n          }),\n          (this.onUpdate = function() {}),\n          (this.isPending = function() {\n            return this.deferredUpdate.isPending();\n          });\n      }.call(Mirror.prototype));\n    }\n  ),\n  ace.define(\'ace/lib/es5-shim\', [\'require\', \'exports\', \'module\'], function() {\n    function Empty() {}\n    function doesDefinePropertyWork(object) {\n      try {\n        return (\n          Object.defineProperty(object, \'sentinel\', {}), \'sentinel\' in object\n        );\n      } catch (exception) {}\n    }\n    function toInteger(n) {\n      return (\n        (n = +n),\n        n !== n\n          ? (n = 0)\n          : 0 !== n \&\&\n            n !== 1 / 0 \&\&\n            n !== -(1 / 0) \&\&\n            (n = (n > 0 || -1) * Math.floor(Math.abs(n))),\n        n\n      );\n    }\n    Function.prototype.bind ||\n      (Function.prototype.bind = function(that) {\n        var target = this;\n        if (\'function\' != typeof target)\n          throw new TypeError(\n            \'Function.prototype.bind called on incompatible \' + target\n          );\n        var args = slice.call(arguments, 1),\n          bound = function() {\n            if (this instanceof bound) {\n              var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n              );\n              return Object(result) === result ? result : this;\n            }\n            return target.apply(that, args.concat(slice.call(arguments)));\n          };\n        return (\n          target.prototype \&\&\n            ((Empty.prototype = target.prototype),\n            (bound.prototype = new Empty()),\n            (Empty.prototype = null)),\n          bound\n        );\n      });\n    var defineGetter,\n      defineSetter,\n      lookupGetter,\n      lookupSetter,\n      supportsAccessors,\n      call = Function.prototype.call,\n      prototypeOfArray = Array.prototype,\n      prototypeOfObject = Object.prototype,\n      slice = prototypeOfArray.slice,\n      _toString = call.bind(prototypeOfObject.toString),\n      owns = call.bind(prototypeOfObject.hasOwnProperty);\n    if (\n      ((supportsAccessors = owns(prototypeOfObject, \'__defineGetter__\')) \&\&\n        ((defineGetter = call.bind(prototypeOfObject.__defineGetter__)),\n        (defineSetter = call.bind(prototypeOfObject.__defineSetter__)),\n        (lookupGetter = call.bind(prototypeOfObject.__lookupGetter__)),\n        (lookupSetter = call.bind(prototypeOfObject.__lookupSetter__))),\n      2 != [1, 2].splice(0).length)\n    )\n      if (\n        (function() {\n          function makeArray(l) {\n            var a = Array(l + 2);\n            return (a[0] = a[1] = 0), a;\n          }\n          var lengthBefore,\n            array = [];\n          return (\n            array.splice.apply(array, makeArray(20)),\n            array.splice.apply(array, makeArray(26)),\n            (lengthBefore = array.length),\n            array.splice(5, 0, \'XXX\'),\n            lengthBefore + 1 == array.length,\n            lengthBefore + 1 == array.length ? !0 : void 0\n          );\n        })()\n      ) {\n        var array_splice = Array.prototype.splice;\n        Array.prototype.splice = function(start, deleteCount) {\n          return arguments.length\n            ? array_splice.apply(\n                this,\n                [\n                  void 0 === start ? 0 : start,\n                  void 0 === deleteCount ? this.length - start : deleteCount,\n                ].concat(slice.call(arguments, 2))\n              )\n            : [];\n        };\n      } else\n        Array.prototype.splice = function(pos, removeCount) {\n          var length = this.length;\n          pos > 0\n            ? pos > length \&\& (pos = length)\n            : void 0 == pos\n              ? (pos = 0)\n              : 0 > pos \&\& (pos = Math.max(length + pos, 0)),\n            length > pos + removeCount || (removeCount = length - pos);\n          var removed = this.slice(pos, pos + removeCount),\n            insert = slice.call(arguments, 2),\n            add = insert.length;\n          if (pos === length) add \&\& this.push.apply(this, insert);\n          else {\n            var remove = Math.min(removeCount, length - pos),\n              tailOldPos = pos + remove,\n              tailNewPos = tailOldPos + add - remove,\n              tailCount = length - tailOldPos,\n              lengthAfterRemove = length - remove;\n            if (tailOldPos > tailNewPos)\n              for (var i = 0; tailCount > i; ++i)\n                this[tailNewPos + i] = this[tailOldPos + i];\n            else if (tailNewPos > tailOldPos)\n              for (i = tailCount; i--; )\n                this[tailNewPos + i] = this[tailOldPos + i];\n            if (add \&\& pos === lengthAfterRemove)\n              (this.length = lengthAfterRemove), this.push.apply(this, insert);\n            else\n              for (this.length = lengthAfterRemove + add, i = 0; add > i; ++i)\n                this[pos + i] = insert[i];\n          }\n          return removed;\n        };\n    Array.isArray ||\n      (Array.isArray = function(obj) {\n        return \'[object Array]\' == _toString(obj);\n      });\n    var boxedString = Object(\'a\'),\n      splitString = \'a\' != boxedString[0] || !(0 in boxedString);\n    if (\n      (Array.prototype.forEach ||\n        (Array.prototype.forEach = function(fun) {\n          var object = toObject(this),\n            self =\n              splitString \&\& \'[object String]\' == _toString(this)\n                ? this.split(\'\')\n                : object,\n            thisp = arguments[1],\n            i = -1,\n            length = self.length >>> 0;\n          if (\'[object Function]\' != _toString(fun)) throw new TypeError();\n          for (; length > ++i; )\n            i in self \&\& fun.call(thisp, self[i], i, object);\n        }),\n      Array.prototype.map ||\n        (Array.prototype.map = function(fun) {\n          var object = toObject(this),\n            self =\n              splitString \&\& \'[object String]\' == _toString(this)\n                ? this.split(\'\')\n                : object,\n            length = self.length >>> 0,\n            result = Array(length),\n            thisp = arguments[1];\n          if (\'[object Function]\' != _toString(fun))\n            throw new TypeError(fun + \' is not a function\');\n          for (var i = 0; length > i; i++)\n            i in self \&\& (result[i] = fun.call(thisp, self[i], i, object));\n          return result;\n        }),\n      Array.prototype.filter ||\n        (Array.prototype.filter = function(fun) {\n          var value,\n            object = toObject(this),\n            self =\n              splitString \&\& \'[object String]\' == _toString(this)\n                ? this.split(\'\')\n                : object,\n            length = self.length >>> 0,\n            result = [],\n            thisp = arguments[1];\n          if (\'[object Function]\' != _toString(fun))\n            throw new TypeError(fun + \' is not a function\');\n          for (var i = 0; length > i; i++)\n            i in self \&\&\n              ((value = self[i]),\n              fun.call(thisp, value, i, object) \&\& result.push(value));\n          return result;\n        }),\n      Array.prototype.every ||\n        (Array.prototype.every = function(fun) {\n          var object = toObject(this),\n            self =\n              splitString \&\& \'[object String]\' == _toString(this)\n                ? this.split(\'\')\n                : object,\n            length = self.length >>> 0,\n            thisp = arguments[1];\n          if (\'[object Function]\' != _toString(fun))\n            throw new TypeError(fun + \' is not a function\');\n          for (var i = 0; length > i; i++)\n            if (i in self \&\& !fun.call(thisp, self[i], i, object)) return !1;\n          return !0;\n        }),\n      Array.prototype.some ||\n        (Array.prototype.some = function(fun) {\n          var object = toObject(this),\n            self =\n              splitString \&\& \'[object String]\' == _toString(this)\n                ? this.split(\'\')\n                : object,\n            length = self.length >>> 0,\n            thisp = arguments[1];\n          if (\'[object Function]\' != _toString(fun))\n            throw new TypeError(fun + \' is not a function\');\n          for (var i = 0; length > i; i++)\n            if (i in self \&\& fun.call(thisp, self[i], i, object)) return !0;\n          return !1;\n        }),\n      Array.prototype.reduce ||\n        (Array.prototype.reduce = function(fun) {\n          var object = toObject(this),\n            self =\n              splitString \&\& \'[object String]\' == _toString(this)\n                ? this.split(\'\')\n                : object,\n            length = self.length >>> 0;\n          if (\'[object Function]\' != _toString(fun))\n            throw new TypeError(fun + \' is not a function\');\n          if (!length \&\& 1 == arguments.length)\n            throw new TypeError(\'reduce of empty array with no initial value\');\n          var result,\n            i = 0;\n          if (arguments.length >= 2) result = arguments[1];\n          else\n            for (;;) {\n              if (i in self) {\n                result = self[i++];\n                break;\n              }\n              if (++i >= length)\n                throw new TypeError(\n                  \'reduce of empty array with no initial value\'\n                );\n            }\n          for (; length > i; i++)\n            i in self \&\&\n              (result = fun.call(void 0, result, self[i], i, object));\n          return result;\n        }),\n      Array.prototype.reduceRight ||\n        (Array.prototype.reduceRight = function(fun) {\n          var object = toObject(this),\n            self =\n              splitString \&\& \'[object String]\' == _toString(this)\n                ? this.split(\'\')\n                : object,\n            length = self.length >>> 0;\n          if (\'[object Function]\' != _toString(fun))\n            throw new TypeError(fun + \' is not a function\');\n          if (!length \&\& 1 == arguments.length)\n            throw new TypeError(\n              \'reduceRight of empty array with no initial value\'\n            );\n          var result,\n            i = length - 1;\n          if (arguments.length >= 2) result = arguments[1];\n          else\n            for (;;) {\n              if (i in self) {\n                result = self[i--];\n                break;\n              }\n              if (0 > --i)\n                throw new TypeError(\n                  \'reduceRight of empty array with no initial value\'\n                );\n            }\n          do\n            i in this \&\&\n              (result = fun.call(void 0, result, self[i], i, object));\n          while (i--);\n          return result;\n        }),\n      (Array.prototype.indexOf \&\& -1 == [0, 1].indexOf(1, 2)) ||\n        (Array.prototype.indexOf = function(sought) {\n          var self =\n              splitString \&\& \'[object String]\' == _toString(this)\n                ? this.split(\'\')\n                : toObject(this),\n            length = self.length >>> 0;\n          if (!length) return -1;\n          var i = 0;\n          for (\n            arguments.length > 1 \&\& (i = toInteger(arguments[1])),\n              i = i >= 0 ? i : Math.max(0, length + i);\n            length > i;\n            i++\n          )\n            if (i in self \&\& self[i] === sought) return i;\n          return -1;\n        }),\n      (Array.prototype.lastIndexOf \&\& -1 == [0, 1].lastIndexOf(0, -3)) ||\n        (Array.prototype.lastIndexOf = function(sought) {\n          var self =\n              splitString \&\& \'[object String]\' == _toString(this)\n                ? this.split(\'\')\n                : toObject(this),\n            length = self.length >>> 0;\n          if (!length) return -1;\n          var i = length - 1;\n          for (\n            arguments.length > 1 \&\& (i = Math.min(i, toInteger(arguments[1]))),\n              i = i >= 0 ? i : length - Math.abs(i);\n            i >= 0;\n            i--\n          )\n            if (i in self \&\& sought === self[i]) return i;\n          return -1;\n        }),\n      Object.getPrototypeOf ||\n        (Object.getPrototypeOf = function(object) {\n          return (\n            object.__proto__ ||\n            (object.constructor\n              ? object.constructor.prototype\n              : prototypeOfObject)\n          );\n        }),\n      !Object.getOwnPropertyDescriptor)\n    ) {\n      var ERR_NON_OBJECT =\n        \'Object.getOwnPropertyDescriptor called on a non-object: \';\n      Object.getOwnPropertyDescriptor = function(object, property) {\n        if (\n          (\'object\' != typeof object \&\& \'function\' != typeof object) ||\n          null === object\n        )\n          throw new TypeError(ERR_NON_OBJECT + object);\n        if (owns(object, property)) {\n          var descriptor, getter, setter;\n          if (\n            ((descriptor = { enumerable: !0, configurable: !0 }),\n            supportsAccessors)\n          ) {\n            var prototype = object.__proto__;\n            object.__proto__ = prototypeOfObject;\n            var getter = lookupGetter(object, property),\n              setter = lookupSetter(object, property);\n            if (((object.__proto__ = prototype), getter || setter))\n              return (\n                getter \&\& (descriptor.get = getter),\n                setter \&\& (descriptor.set = setter),\n                descriptor\n              );\n          }\n          return (descriptor.value = object[property]), descriptor;\n        }\n      };\n    }\n    if (\n      (Object.getOwnPropertyNames ||\n        (Object.getOwnPropertyNames = function(object) {\n          return Object.keys(object);\n        }),\n      !Object.create)\n    ) {\n      var createEmpty;\n      (createEmpty =\n        null === Object.prototype.__proto__\n          ? function() {\n              return { __proto__: null };\n            }\n          : function() {\n              var empty = {};\n              for (var i in empty) empty[i] = null;\n              return (\n                (empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null),\n                empty\n              );\n            }),\n        (Object.create = function(prototype, properties) {\n          var object;\n          if (null === prototype) object = createEmpty();\n          else {\n            if (\'object\' != typeof prototype)\n              throw new TypeError(\n                \'typeof prototype[\' + typeof prototype + \"] != \'object\'\"\n              );\n            var Type = function() {};\n            (Type.prototype = prototype),\n              (object = new Type()),\n              (object.__proto__ = prototype);\n          }\n          return (\n            void 0 !== properties \&\&\n              Object.defineProperties(object, properties),\n            object\n          );\n        });\n    }\n    if (Object.defineProperty) {\n      var definePropertyWorksOnObject = doesDefinePropertyWork({}),\n        definePropertyWorksOnDom =\n          \'undefined\' == typeof document ||\n          doesDefinePropertyWork(document.createElement(\'div\'));\n      if (!definePropertyWorksOnObject || !definePropertyWorksOnDom)\n        var definePropertyFallback = Object.defineProperty;\n    }\n    if (!Object.defineProperty || definePropertyFallback) {\n      var ERR_NON_OBJECT_DESCRIPTOR =\n          \'Property description must be an object: \',\n        ERR_NON_OBJECT_TARGET = \'Object.defineProperty called on non-object: \',\n        ERR_ACCESSORS_NOT_SUPPORTED =\n          \'getters \& setters can not be defined on this javascript engine\';\n      Object.defineProperty = function(object, property, descriptor) {\n        if (\n          (\'object\' != typeof object \&\& \'function\' != typeof object) ||\n          null === object\n        )\n          throw new TypeError(ERR_NON_OBJECT_TARGET + object);\n        if (\n          (\'object\' != typeof descriptor \&\& \'function\' != typeof descriptor) ||\n          null === descriptor\n        )\n          throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);\n        if (definePropertyFallback)\n          try {\n            return definePropertyFallback.call(\n              Object,\n              object,\n              property,\n              descriptor\n            );\n          } catch (exception) {}\n        if (owns(descriptor, \'value\'))\n          if (\n            supportsAccessors \&\&\n            (lookupGetter(object, property) || lookupSetter(object, property))\n          ) {\n            var prototype = object.__proto__;\n            (object.__proto__ = prototypeOfObject),\n              delete object[property],\n              (object[property] = descriptor.value),\n              (object.__proto__ = prototype);\n          } else object[property] = descriptor.value;\n        else {\n          if (!supportsAccessors)\n            throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\n          owns(descriptor, \'get\') \&\&\n            defineGetter(object, property, descriptor.get),\n            owns(descriptor, \'set\') \&\&\n              defineSetter(object, property, descriptor.set);\n        }\n        return object;\n      };\n    }\n    Object.defineProperties ||\n      (Object.defineProperties = function(object, properties) {\n        for (var property in properties)\n          owns(properties, property) \&\&\n            Object.defineProperty(object, property, properties[property]);\n        return object;\n      }),\n      Object.seal ||\n        (Object.seal = function(object) {\n          return object;\n        }),\n      Object.freeze ||\n        (Object.freeze = function(object) {\n          return object;\n        });\n    try {\n      Object.freeze(function() {});\n    } catch (exception) {\n      Object.freeze = (function(freezeObject) {\n        return function(object) {\n          return \'function\' == typeof object ? object : freezeObject(object);\n        };\n      })(Object.freeze);\n    }\n    if (\n      (Object.preventExtensions ||\n        (Object.preventExtensions = function(object) {\n          return object;\n        }),\n      Object.isSealed ||\n        (Object.isSealed = function() {\n          return !1;\n        }),\n      Object.isFrozen ||\n        (Object.isFrozen = function() {\n          return !1;\n        }),\n      Object.isExtensible ||\n        (Object.isExtensible = function(object) {\n          if (Object(object) === object) throw new TypeError();\n          for (var name = \'\'; owns(object, name); ) name += \'?\';\n          object[name] = !0;\n          var returnValue = owns(object, name);\n          return delete object[name], returnValue;\n        }),\n      !Object.keys)\n    ) {\n      var hasDontEnumBug = !0,\n        dontEnums = [\n          \'toString\',\n          \'toLocaleString\',\n          \'valueOf\',\n          \'hasOwnProperty\',\n          \'isPrototypeOf\',\n          \'propertyIsEnumerable\',\n          \'constructor\',\n        ],\n        dontEnumsLength = dontEnums.length;\n      for (var key in { toString: null }) hasDontEnumBug = !1;\n      Object.keys = function(object) {\n        if (\n          (\'object\' != typeof object \&\& \'function\' != typeof object) ||\n          null === object\n        )\n          throw new TypeError(\'Object.keys called on a non-object\');\n        var keys = [];\n        for (var name in object) owns(object, name) \&\& keys.push(name);\n        if (hasDontEnumBug)\n          for (var i = 0, ii = dontEnumsLength; ii > i; i++) {\n            var dontEnum = dontEnums[i];\n            owns(object, dontEnum) \&\& keys.push(dontEnum);\n          }\n        return keys;\n      };\n    }\n    Date.now ||\n      (Date.now = function() {\n        return new Date().getTime();\n      });\n    var ws = \'\t\\n\v\\f\\r   ᠎             　\\u2028\\u2029﻿\';\n    if (!String.prototype.trim || ws.trim()) {\n      ws = \'[\' + ws + \']\';\n      var trimBeginRegexp = RegExp(\'^\' + ws + ws + \'*\'),\n        trimEndRegexp = RegExp(ws + ws + \'*$\');\n      String.prototype.trim = function() {\n        return (this + \'\')\n          .replace(trimBeginRegexp, \'\')\n          .replace(trimEndRegexp, \'\');\n      };\n    }\n    var toObject = function(o) {\n      if (null == o) throw new TypeError(\"can\'t convert \" + o + \' to object\');\n      return Object(o);\n    };\n  });\n  ace.define(\'sense_editor/mode/worker_parser\', [\'require\', \'exports\', \'module\' ], function () {\n\n\n    let at,     // The index of the current character\n      ch,     // The current character\n      annos, // annotations\n      escapee = {\n        \'\"\': \'\"\',\n        \'\\\\\': \'\\\\\',\n        \'/\': \'/\',\n        b: \'\\b\',\n        f: \'\\f\',\n        n: \'\\n\',\n        r: \'\\r\',\n        t: \'\\t\'\n      },\n      text,\n  \n      annotate = function (type, text) {\n        annos.push({ type: type, text: text, at: at });\n      },\n  \n      error = function (m) {\n  \n        throw {\n          name: \'SyntaxError\',\n          message: m,\n          at: at,\n          text: text\n        };\n      },\n  \n  \n      reset = function (newAt) {\n        ch = text.charAt(newAt);\n        at = newAt + 1;\n      },\n  \n      next = function (c) {\n  \n        if (c \&\& c !== ch) {\n          error(\'Expected \\\'\' + c + \'\\\' instead of \\\'\' + ch + \'\\\'\');\n        }\n  \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n      },\n  \n      nextUpTo = function (upTo, errorMessage) {\n        let currentAt = at,\n          i = text.indexOf(upTo, currentAt);\n        if (i < 0) {\n          error(errorMessage || \'Expected \\\'\' + upTo + \'\\\'\');\n        }\n        reset(i + upTo.length);\n        return text.substring(currentAt, i);\n      },\n  \n      peek = function (c) {\n        return text.substr(at, c.length) === c; // nocommit - double check\n      },\n  \n      number = function () {\n  \n        let number,\n          string = \'\';\n  \n        if (ch === \'-\') {\n          string = \'-\';\n          next(\'-\');\n        }\n        while (ch >= \'0\' \&\& ch <= \'9\') {\n          string += ch;\n          next();\n        }\n        if (ch === \'.\') {\n          string += \'.\';\n          while (next() \&\& ch >= \'0\' \&\& ch <= \'9\') {\n            string += ch;\n          }\n        }\n        if (ch === \'e\' || ch === \'E\') {\n          string += ch;\n          next();\n          if (ch === \'-\' || ch === \'+\') {\n            string += ch;\n            next();\n          }\n          while (ch >= \'0\' \&\& ch <= \'9\') {\n            string += ch;\n            next();\n          }\n        }\n        number = +string;\n        if (isNaN(number)) {\n          error(\'Bad number\');\n        } else {\n          return number;\n        }\n      },\n  \n      string = function () {\n  \n        let hex,\n          i,\n          string = \'\',\n          uffff;\n  \n        if (ch === \'\"\') {\n          if (peek(\'\"\"\')) {\n            // literal\n            next(\'\"\');\n            next(\'\"\');\n            return nextUpTo(\'\"\"\"\', \'failed to find closing \\\'\"\"\"\\\'\');\n          } else {\n            while (next()) {\n              if (ch === \'\"\') {\n                next();\n                return string;\n              } else if (ch === \'\\\\\') {\n                next();\n                if (ch === \'u\') {\n                  uffff = 0;\n                  for (i = 0; i < 4; i += 1) {\n                    hex = parseInt(next(), 16);\n                    if (!isFinite(hex)) {\n                      break;\n                    }\n                    uffff = uffff * 16 + hex;\n                  }\n                  string += String.fromCharCode(uffff);\n                } else if (typeof escapee[ch] === \'string\') {\n                  string += escapee[ch];\n                } else {\n                  break;\n                }\n              } else {\n                string += ch;\n              }\n            }\n          }\n        }\n        error(\'Bad string\');\n      },\n  \n      white = function () {\n  \n        while (ch \&\& ch <= \' \') {\n          next();\n        }\n      },\n  \n      strictWhite = function () {\n  \n        while (ch \&\& (ch == \' \' || ch == \'\\t\')) {\n          next();\n        }\n      },\n  \n      newLine = function () {\n        if (ch == \'\\n\') next();\n      },\n  \n      word = function () {\n  \n        switch (ch) {\n          case \'t\':\n            next(\'t\');\n            next(\'r\');\n            next(\'u\');\n            next(\'e\');\n            return true;\n          case \'f\':\n            next(\'f\');\n            next(\'a\');\n            next(\'l\');\n            next(\'s\');\n            next(\'e\');\n            return false;\n          case \'n\':\n            next(\'n\');\n            next(\'u\');\n            next(\'l\');\n            next(\'l\');\n            return null;\n        }\n        error(\'Unexpected \\\'\' + ch + \'\\\'\');\n      },\n  \n      // parses and returns the method\n      method = function () {\n        switch (ch) {\n          case \'G\':\n            next(\'G\');\n            next(\'E\');\n            next(\'T\');\n            return \'GET\';\n          case \'H\':\n            next(\'H\');\n            next(\'E\');\n            next(\'A\');\n            next(\'D\');\n            return \'HEAD\';\n          case \'D\':\n            next(\'D\');\n            next(\'E\');\n            next(\'L\');\n            next(\'E\');\n            next(\'T\');\n            next(\'E\');\n            return \'DELETE\';\n          case \'P\':\n            next(\'P\');\n            switch (ch) {\n              case \'U\':\n                next(\'U\');\n                next(\'T\');\n                return \'PUT\';\n              case \'O\':\n                next(\'O\');\n                next(\'S\');\n                next(\'T\');\n                return \'POST\';\n              default:\n                error(\'Unexpected \\\'\' + ch + \'\\\'\');\n            }\n            break;\n          default:\n            error(\'Expected one of GET/POST/PUT/DELETE/HEAD\');\n        }\n  \n      },\n  \n      value,  // Place holder for the value function.\n  \n      array = function () {\n  \n        const array = [];\n  \n        if (ch === \'[\') {\n          next(\'[\');\n          white();\n          if (ch === \']\') {\n            next(\']\');\n            return array;   // empty array\n          }\n          while (ch) {\n            array.push(value());\n            white();\n            if (ch === \']\') {\n              next(\']\');\n              return array;\n            }\n            next(\',\');\n            white();\n          }\n        }\n        error(\'Bad array\');\n      },\n  \n      object = function () {\n  \n        let key,\n          object = {};\n  \n        if (ch === \'{\') {\n          next(\'{\');\n          white();\n          if (ch === \'}\') {\n            next(\'}\');\n            return object;   // empty object\n          }\n          while (ch) {\n            key = string();\n            white();\n            next(\':\');\n            if (Object.hasOwnProperty.call(object, key)) {\n              error(\'Duplicate key \"\' + key + \'\"\');\n            }\n            object[key] = value();\n            white();\n            if (ch === \'}\') {\n              next(\'}\');\n              return object;\n            }\n            next(\',\');\n            white();\n          }\n        }\n        error(\'Bad object\');\n      };\n  \n    value = function () {\n  \n      white();\n      switch (ch) {\n        case \'{\':\n          return object();\n        case \'[\':\n          return array();\n        case \'\"\':\n          return string();\n        case \'-\':\n          return number();\n        default:\n          return ch >= \'0\' \&\& ch <= \'9\' ? number() : word();\n      }\n    };\n  \n    let url = function () {\n  \n        let url = \'\';\n        while (ch \&\& ch != \'\\n\') {\n          url += ch;\n          next();\n        }\n        if (url == \'\')\n        {error(\'Missing url\');}\n        return url;\n      },\n  \n      request = function () {\n        white();\n        method();\n        strictWhite();\n        url();\n        strictWhite(); // advance to one new line\n        newLine();\n        strictWhite();\n        if (ch == \'{\') {\n          object();\n        }\n        // multi doc request\n        strictWhite(); // advance to one new line\n        newLine();\n        strictWhite();\n        while (ch == \'{\') {\n          // another object\n          object();\n          strictWhite();\n          newLine();\n          strictWhite();\n        }\n  \n      },\n  \n      comment = function () {\n        while (ch == \'#\') {\n          while (ch \&\& ch !== \'\\n\') {\n            next();\n          }\n          white();\n        }\n      },\n  \n      multi_request = function () {\n        while (ch \&\& ch != \'\') {\n          white();\n          if (!ch) {\n            continue;\n          }\n          try {\n            comment();\n            white();\n            if (!ch) {\n              continue;\n            }\n            request();\n            white();\n          }\n          catch (e) {\n            annotate(\'error\', e.message);\n            // snap\n            const substring = text.substr(at);\n            const nextMatch = substring.search(/^POST|HEAD|GET|PUT|DELETE/m);\n            if (nextMatch < 1) return;\n            reset(at + nextMatch);\n          }\n        }\n      };\n  \n  \n    return function (source, reviver) {\n      let result;\n  \n      text = source;\n      at = 0;\n      annos = [];\n      next();\n      multi_request();\n      white();\n      if (ch) {\n        annotate(\'error\', \'Syntax error\');\n      }\n  \n      result = { \'annotations\': annos };\n  \n  \n      return typeof reviver === \'function\' ? (function walk(holder, key) {\n        let k, v, value = holder[key];\n        if (value \&\& typeof value === \'object\') {\n          for (k in value) {\n            if (Object.hasOwnProperty.call(value, k)) {\n              v = walk(value, k);\n              if (v !== undefined) {\n                value[k] = v;\n              } else {\n                delete value[k];\n              }\n            }\n          }\n        }\n        return reviver.call(holder, key, value);\n      }({ \'\': result }, \'\')) : result;\n    };\n  });\n  \n  \n  ace.define(\'sense_editor/mode/worker\', [\'require\', \'exports\', \'module\', \'ace/lib/oop\', \'ace/worker/mirror\',\n    \'sense_editor/mode/worker_parser\'], function (require, exports) {\n  \n  \n  \n    const oop = require(\'ace/lib/oop\');\n    const Mirror = require(\'ace/worker/mirror\').Mirror;\n    const parse = require(\'sense_editor/mode/worker_parser\');\n  \n    const SenseWorker = exports.SenseWorker = function (sender) {\n      console.log(\'SENSE\');\n      Mirror.call(this, sender);\n      this.setTimeout(200);\n    };\n  \n    oop.inherits(SenseWorker, Mirror);\n  \n    (function () {\n      this.id = \'senseWorker\';\n      this.onUpdate = function () {\n        console.log(\'called\');\n        const value = this.doc.getValue();\n        let pos, result;\n        try {\n          result = parse(value);\n        } catch (e) {\n          pos = this.charToDocumentPosition(e.at - 1);\n          this.sender.emit(\'error\', {\n            row: pos.row,\n            column: pos.column,\n            text: e.message,\n            type: \'error\'\n          });\n          return;\n        }\n        for (let i = 0; i < result.annotations.length; i++) {\n          pos = this.charToDocumentPosition(result.annotations[i].at - 1);\n          result.annotations[i].row = pos.row;\n          result.annotations[i].column = pos.column;\n  \n        }\n        this.sender.emit(\'ok\', result.annotations);\n      };\n  \n      this.charToDocumentPosition = function (charPos) {\n        let i = 0;\n        const len = this.doc.getLength();\n        const nl = this.doc.getNewLineCharacter().length;\n  \n        if (!len) {\n          return { row: 0, column: 0 };\n        }\n  \n        let lineStart = 0, line;\n        while (i < len) {\n          line = this.doc.getLine(i);\n          const lineLength = line.length + nl;\n          if (lineStart + lineLength > charPos)\n          {return {\n            row: i,\n            column: charPos - lineStart\n          };}\n  \n          lineStart += lineLength;\n          i += 1;\n        }\n  \n        return {\n          row: i - 1,\n          column: line.length\n        };\n      };\n  \n    }).call(SenseWorker.prototype);\n  \n  });\n';