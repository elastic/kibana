// Initialization block
{

  const { parseCursor, helpers: { nodeTypes } } = options;
  const buildFunctionNode = nodeTypes.function.buildNodeWithArgumentNodes;
  const buildLiteralNode = nodeTypes.literal.buildNode;
  const buildWildcardNode = nodeTypes.wildcard.buildNode;
  const buildNamedArgNode = nodeTypes.namedArg.buildNode;

  function trimLeft(string) {
    return string.replace(/^[\s\uFEFF\xA0]+/g, '');
  }

  function trimRight(string) {
    return string.replace(/[\s\uFEFF\xA0]+$/g, '');
  }
}

start
  = Space* query:OrQuery? Space* {
    if (query !== null) return query;
    return nodeTypes.function.buildNode('is', '*', '*');
  }

OrQuery
  = left:AndQuery Or right:OrQuery {
    const cursor = [left, right].find(node => node.type === 'cursor');
    if (cursor) return cursor;
    return buildFunctionNode('or', [left, right]);
  }
  / AndQuery

AndQuery
  = left:NotQuery And right:AndQuery {
    const cursor = [left, right].find(node => node.type === 'cursor');
    if (cursor) return cursor;
    return buildFunctionNode('and', [left, right]);
  }
  / NotQuery

NotQuery
  = Not query:SubQuery {
    if (query.type === 'cursor') return query;
    return buildFunctionNode('not', [query]);
  }
  / SubQuery

SubQuery
  = '(' Space* query:OrQuery Space* ')' { return query; }
  / Expression

Expression
  = FieldRangeExpression
  / FieldValueExpression
  / ValueExpression

FieldRangeExpression
  = field:Literal Space* operator:RangeOperator Space* value:(WordAtCursor / QuotedString / UnquotedLiteral) {
    if (value.type === 'cursor') {
      return {
        ...value,
        suggestionTypes: ['conjunction']
      };
    }
    const range = buildNamedArgNode(operator, value);
    return buildFunctionNode('range', [field, range]);
  }

FieldValueExpression
  = field:Literal Space* ':' Space* partial:ListOfValues {
    if (partial.type === 'cursor') {
      return {
        ...partial,
        fieldName: field.value,
        suggestionTypes: ['value', 'conjunction']
      };
    }
    return partial(field);
  }

ValueExpression
  = partial:Value {
    if (partial.type === 'cursor') {
      const fieldName = (partial.prefix + partial.suffix).trim();
      return {
        ...partial,
        fieldName,
        suggestionTypes: ['field', 'operator']
      };
    }
    const field = buildLiteralNode(null);
    return partial(field);
  }

ListOfValues
  = '(' Space* partial:OrListOfValues Space* ')' { return partial; }
  / Value

OrListOfValues
  = partialLeft:AndListOfValues Or partialRight:OrListOfValues {
    const cursor = [partialLeft, partialRight].find(node => node.type === 'cursor');
    if (cursor) {
      return {
        ...cursor,
        suggestionTypes: ['value']
      };
    }
    return (field) => buildFunctionNode('or', [partialLeft(field), partialRight(field)]);
  }
  / AndListOfValues

AndListOfValues
  = partialLeft:NotListOfValues And partialRight:AndListOfValues {
    const cursor = [partialLeft, partialRight].find(node => node.type === 'cursor');
    if (cursor) {
      return {
        ...cursor,
        suggestionTypes: ['value']
      };
    }
    return (field) => buildFunctionNode('and', [partialLeft(field), partialRight(field)]);
  }
  / NotListOfValues

NotListOfValues
  = Not partial:ListOfValues {
    if (partial.type === 'cursor') {
      return {
        ...list,
        suggestionTypes: ['value']
      };
    }
    return (field) => buildFunctionNode('not', [partial(field)]);
  }
  / ListOfValues

Value
  = WordAtCursor
  / value:QuotedString {
    const isPhrase = buildLiteralNode(true);
    return (field) => buildFunctionNode('is', [field, value, isPhrase]);
  }
  / value:WildcardString {
    const isPhrase = buildLiteralNode(false);
    return (field) => buildFunctionNode('is', [field, value, isPhrase]);
  }
  / value:UnquotedLiteral {
    const isPhrase = buildLiteralNode(false);
    return (field) => buildFunctionNode('is', [field, value, isPhrase]);
  }

Or
  = Space+ 'or'i Space+

And
  = Space+ 'and'i Space+

Not
  = 'not'i Space+

Literal
  = WordAtCursor / QuotedString / WildcardString / UnquotedLiteral

QuotedString
  = '"' chars:QuotedCharacter* '"' {
    return buildLiteralNode(chars.join(''));
  }

QuotedCharacter
  = !Cursor char:(EscapedDoubleQuote / [^"]) { return char; }

WildcardString
  = sequences:WildcardSequence+ {
    const compactedSequences = sequences.reduce((acc, arr, i) => {
      const compacted = arr.filter(value => value !== '');
      return [...acc, ...compacted];
    }, []);
    if (typeof compactedSequences[0] === 'string') {
      compactedSequences[0] = trimLeft(compactedSequences[0]);
    }
    const lastIndex = compactedSequences.length - 1;
    if (typeof compactedSequences[lastIndex] === 'string') {
      compactedSequences[lastIndex] = trimRight(compactedSequences[lastIndex]);
    }
    return buildWildcardNode(compactedSequences);
  }

WildcardSequence
  = left:UnquotedCharacter* '*' right:UnquotedCharacter* {
    return [left.join(''), nodeTypes.wildcard.wildcardSymbol, right.join('')];
  }

UnquotedLiteral
  = chars:UnquotedCharacter+ {
    const sequence = chars.join('').trim();
    if (sequence === 'null') return buildLiteralNode(null);
    if (sequence === 'true') return buildLiteralNode(true);
    if (sequence === 'false') return buildLiteralNode(false);
    const number = Number(sequence);
    const value = isNaN(number) ? sequence : number;
    return buildLiteralNode(value);
  }

UnquotedCharacter
  = EscapedSpecialCharacter
  / !Separator char:. { return char; }

EscapedSpecialCharacter
  = '\\' char:SpecialCharacter { return char; }

EscapedDoubleQuote
  = '\\' char:'"' { return char; }

Separator
  = Cursor / Keyword / SpecialCharacter

Keyword
  = Or / And / Not

SpecialCharacter
  = [\\():<>"*]

RangeOperator
  = '<=' { return 'lte'; }
  / '>=' { return 'gte'; }
  / '<' { return 'lt'; }
  / '>' { return 'gt'; }

Space
  = [\ \t\r\n]

WordAtCursor
  = '"' prefix:QuotedCharacter* cursor:Cursor suffix:QuotedCharacter* '"' {
    const { start, end } = location();
    return {
      ...cursor,
      prefix: prefix.join(''),
      suffix: suffix.join(''),
      start: start.offset,
      end: end.offset - 1
    };
  }
  / prefix:UnquotedCharacter* cursor:Cursor suffix:UnquotedCharacter* {
    const { start, end } = location();
    return {
      ...cursor,
      prefix: prefix.join(''),
      suffix: suffix.join(''),
      start: start.offset,
      end: end.offset - 1
    };
  }

Cursor
  = &{ return parseCursor; } '\0' {
    return { type: 'cursor' };
  }
