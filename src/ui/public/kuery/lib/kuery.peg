Query
  = head:Clause tail:(whitespace Clause)* {
    var result = [head], i;

    for (i = 0; i < tail.length; i++) {
      result.push(tail[i][1])
    }

    return {
      type: 'compound',
      negate: false,
      params: {
        children: result
      }
    };
  }
  / '' {
    return {
      type: 'compound',
      negate: false,
      params: {
        children: []
      }
    };
  }

Clause
  = operators:[-]* body:Term {
    if (operators[0] === '-') {
      body.negate = true;
    }
    else {
      body.negate = false;
    }
    return body;
  }

Term
  = field:literal ':' value:literal {

    return {
      type: 'match',
      params: {
        field: field,
        value: value,
      }
    };
  }
  / field:literal ':[' gt:literal ' to ' lt:literal ']' {
    return {
      type: 'range',
      params: {
        field: field,
        gt: gt,
        lt: lt
      }
    }
  }


 /* ----- Core types ----- */

literal "literal"
  =  '"' chars:dq_char* '"' { return chars.join(''); } // double quoted string
  / "'" chars:sq_char* "'" { return chars.join(''); } // single quoted string
  / 'true'  { return true; } // unquoted literals from here down
  / 'false' { return false; }
  / 'null'  { return null; }
  / string:[^\[\]()"',:=\ \t]+ { // this also matches numbers via Number()
   var result = string.join('');
   // Sort of hacky, but PEG doesn't have backtracking so
   // a number rule is hard to read, and performs worse
   if (isNaN(Number(result))) return result;
   return Number(result)
  }

whitespace
 = [\ \t\r\n]+

dq_char
  = "\\" sequence:('"' / "\\") { return sequence; }
  / [^"] // everything except "

sq_char
  = "\\" sequence:("'" / "\\") { return sequence; }
  / [^'] // everything except '

integer
 = digits:[0-9]+ {return parseInt(digits.join(''))}
