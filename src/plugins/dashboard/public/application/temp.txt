/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import React, { useEffect, useCallback, useState } from 'react';
import { History } from 'history';
import ReactDOM from 'react-dom';
import _ from 'lodash';

import { map } from 'rxjs/operators';
import { merge, Subscription } from 'rxjs';
import { EUI_MODAL_CANCEL_BUTTON } from '@elastic/eui';
import { getSavedObjectFinder, SavedObject } from '../../../saved_objects/public';
import { DashboardStateManager } from './dashboard_state_manager';
import {
  createKbnUrlStateStorage,
  removeQueryParam,
  withNotifyOnErrors,
} from '../../../kibana_utils/public';
import { DashboardAppServices, DashboardEmbedSettings, DashboardRedirect } from './types';
import { useKibana } from '../../../kibana_react/public';
import { DashboardSavedObject } from '../saved_dashboards';
import { migrateLegacyQuery } from './lib/migrate_legacy_query';
import {
  connectToQueryState,
  esFilters,
  IndexPattern,
  QueryState,
  syncQueryStateWithUrl,
} from '../../../data/public';
import {
  ContainerOutput,
  EmbeddableFactoryNotFoundError,
  EmbeddableInput,
  ErrorEmbeddable,
  isErrorEmbeddable,
  openAddPanelFlyout,
  ViewMode,
} from '../../../embeddable/public';
import { DASHBOARD_CONTAINER_TYPE } from '.';
import { DashboardTopNav } from './top_nav/dashboard_top_nav';
import {
  dashboard60Warning,
  dashboardBreadcrumb,
  getDashboardTitle,
  leaveConfirmStrings,
} from './dashboard_strings';
import type { TagDecoratedSavedObject } from '../../../saved_objects_tagging_oss/public';
import { DashboardEmptyScreen } from './empty_screen/dashboard_empty_screen';
import {
  getChangesFromAppStateForContainerState,
  getDashboardContainerInput,
  getFiltersSubscription,
  getInputSubscription,
  getOutputSubscription,
  getSearchSessionIdFromURL,
} from './dashboard_app_functions';
import { createSessionRestorationDataProvider } from './lib/session_restoration';
import { DashboardConstants, DashboardContainer, DashboardContainerInput } from '..';

export interface DashboardAppProps {
  history: History;
  savedDashboardId?: string;
  redirectTo: DashboardRedirect;
  embedSettings?: DashboardEmbedSettings;
}

// TS is picky with type guards, we can't just inline `() => false`
function defaultTaggingGuard(_obj: SavedObject): _obj is TagDecoratedSavedObject {
  return false;
}

/* NEW HOOKS */

const useDashboardStateManager = (
  savedDashboard: DashboardSavedObject | null,
  history: DashboardAppProps['history']
): [DashboardStateManager, () => void] | [null, null] => {
  const {
    data,
    core,
    uiSettings,
    usageCollection,
    initializerContext,
    dashboardCapabilities,
    savedObjectsTagging,
  } = useKibana<DashboardAppServices>().services;

  if (!savedDashboard) {
    return [null, null];
  }

  const hasTaggingCapabilities = savedObjectsTagging?.ui.hasTagDecoration || defaultTaggingGuard;
  const filterManager = data.query.filterManager;
  const timefilter = data.query.timefilter.timefilter;
  const queryStringManager = data.query.queryString;

  const kbnUrlStateStorage = createKbnUrlStateStorage({
    history,
    useHash: uiSettings.get('state:storeInSessionStorage'),
    ...withNotifyOnErrors(core.notifications.toasts),
  });

  const stateManager = new DashboardStateManager({
    hasTaggingCapabilities,
    hideWriteControls: dashboardCapabilities.hideWriteControls,
    kibanaVersion: initializerContext.env.packageInfo.version,
    savedDashboard,
    kbnUrlStateStorage,
    usageCollection,
    history,
  });

  // sync initial app filters from state to filterManager
  // if there is an existing similar global filter, then leave it as global
  filterManager.setAppFilters(_.cloneDeep(stateManager.appState.filters));
  queryStringManager.setQuery(migrateLegacyQuery(stateManager.appState.query));

  // setup syncing of app filters between appState and filterManager
  const stopSyncingAppFilters = connectToQueryState(
    data.query,
    {
      set: ({ filters, query }) => {
        stateManager.setFilters(filters || []);
        stateManager.setQuery(query || queryStringManager.getDefaultQuery());
      },
      get: () => ({
        filters: stateManager.appState.filters,
        query: stateManager.getQuery(),
      }),
      state$: stateManager.appState$.pipe(
        map((appState) => ({
          filters: appState.filters,
          query: queryStringManager.formatQuery(appState.query),
        }))
      ),
    },
    {
      filters: esFilters.FilterStateStore.APP_STATE,
      query: true,
    }
  );

  // Apply initial filters to Dashboard State Manager
  stateManager.applyFilters(
    stateManager.getQuery() || queryStringManager.getDefaultQuery(),
    filterManager.getFilters()
  );

  // The hash check is so we only update the time filter on dashboard open, not during
  // normal cross app navigation.
  if (stateManager.getIsTimeSavedWithDashboard()) {
    const initialGlobalStateInUrl = kbnUrlStateStorage.get<QueryState>('_g');
    if (!initialGlobalStateInUrl?.time) {
      stateManager.syncTimefilterWithDashboardTime(timefilter);
    }
    if (!initialGlobalStateInUrl?.refreshInterval) {
      stateManager.syncTimefilterWithDashboardRefreshInterval(timefilter);
    }
  }

  // starts syncing `_g` portion of url with query services
  // it is important to start this syncing after `dashboardStateManager.syncTimefilterWithDashboard(timefilter);` above is run,
  // otherwise it will case redundant browser history records
  const { stop: stopSyncingQueryServiceStateWithUrl } = syncQueryStateWithUrl(
    data.query,
    kbnUrlStateStorage
  );

  // starts syncing `_a` portion of url
  stateManager.startStateSyncing();

  data.search.session.setSearchSessionInfoProvider(
    createSessionRestorationDataProvider({
      data,
      getDashboardTitle: () =>
        getDashboardTitle(
          stateManager.getTitle(),
          stateManager.getViewMode(),
          stateManager.getIsDirty(data.query.timefilter.timefilter),
          stateManager.isNew()
        ),
      getDashboardId: () => savedDashboard?.id || '',
      getAppState: () => stateManager.getAppState(),
    })
  );

  const stop = () => {
    stopSyncingAppFilters();
    stopSyncingQueryServiceStateWithUrl();
  };

  return [stateManager, stop];
};

const useDashboardContainer = (
  dashboardStateManager: DashboardStateManager | null,
  history: DashboardAppProps['history'],
  embedSettings: DashboardAppProps['embedSettings']
) => {
  const {
    data,
    embeddable,
    scopedHistory,
    dashboardCapabilities,
  } = useKibana<DashboardAppServices>().services;
  const [dashboardContainer, setDashboardContainer] = useState<DashboardContainer | null>(null);

  useEffect(() => {
    if (!dashboardStateManager) {
      return;
    }

    const dashboardFactory = embeddable.getEmbeddableFactory<
      DashboardContainerInput,
      ContainerOutput,
      DashboardContainer
    >(DASHBOARD_CONTAINER_TYPE);
    if (!dashboardFactory) {
      throw new EmbeddableFactoryNotFoundError(
        'dashboard app requires dashboard embeddable factory'
      );
    }
    const searchSessionIdFromURL = getSearchSessionIdFromURL(history);
    if (searchSessionIdFromURL) {
      data.search.session.restore(searchSessionIdFromURL);
    }
    // get incoming embeddable from the state transfer service.
    const incomingEmbeddable = embeddable
      .getStateTransfer(scopedHistory())
      .getIncomingEmbeddablePackage();

    dashboardFactory
      .create(
        getDashboardContainerInput({
          searchSessionId: searchSessionIdFromURL ?? data.search.session.start(),
          isEmbeddedExternally: !!embedSettings,
          dashboardStateManager,
          dashboardCapabilities,
          incomingEmbeddable,
          query: data.query,
        })
      )
      .then((newContainer: DashboardContainer | ErrorEmbeddable | undefined) => {
        if (!newContainer || isErrorEmbeddable(newContainer)) {
          return;
        }

        // If the incoming embeddable is newly created, or doesn't exist in the current panels list, add it with `addNewEmbeddable`
        if (
          incomingEmbeddable &&
          (!incomingEmbeddable?.embeddableId ||
            (incomingEmbeddable.embeddableId &&
              !newContainer.getInput().panels[incomingEmbeddable.embeddableId]))
        ) {
          newContainer.addNewEmbeddable<EmbeddableInput>(
            incomingEmbeddable.type,
            incomingEmbeddable.input
          );
        }
        setDashboardContainer(newContainer);
      });
  }, [
    dashboardCapabilities,
    dashboardStateManager,
    data.query,
    data.search.session,
    embedSettings,
    embeddable,
    history,
    scopedHistory,
  ]);

  return dashboardContainer;
};

const useSavedDashboard = (
  savedDashboardId: DashboardAppProps['savedDashboardId'],
  history: DashboardAppProps['history'],
  embedSettings: DashboardAppProps['embedSettings']
): [DashboardSavedObject | null, DashboardContainer | null, DashboardStateManager | null] => {
  const { data, core, chrome, savedDashboards } = useKibana<DashboardAppServices>().services;

  const [savedDashboard, setSavedDashboard] = useState<DashboardSavedObject | null>(null);
  const [dashboardStateManager, stop] = useDashboardStateManager(savedDashboard, history);
  const dashboardContainer = useDashboardContainer(dashboardStateManager, history, embedSettings);

  useEffect(() => {
    (async function loadDashboard() {
      if (!savedDashboardId) {
        return;
      }

      if (savedDashboardId === 'create') {
        history.replace({
          ...history.location, // preserve query,
          pathname: DashboardConstants.CREATE_NEW_DASHBOARD_URL,
        });

        core.notifications.toasts.addWarning(dashboard60Warning);
        return;
      }

      await data.indexPatterns.ensureDefaultIndexPattern();
      try {
        const dashboard = (await savedDashboards.get(savedDashboardId)) as DashboardSavedObject;
        const { title, getFullPath } = dashboard;

        chrome.docTitle.change(title);
        chrome.recentlyAccessed.add(getFullPath(), title, savedDashboardId);
        setSavedDashboard(dashboard);
      } catch (error) {
        // E.g. a corrupt or deleted dashboard
        core.notifications.toasts.addDanger(error.message);
        history.push(DashboardConstants.LANDING_PAGE_PATH);
      }
    })();

    return () => {
      if (stop) {
        stop();
      }
      if (dashboardContainer) {
        dashboardContainer.destroy();
      }
      if (dashboardStateManager) {
        dashboardStateManager.destroy();
      }
    };
  }, [
    stop,
    dashboardContainer,
    dashboardStateManager,
    chrome.recentlyAccessed,
    data.indexPatterns,
    core.notifications,
    savedDashboardId,
    savedDashboards,
    chrome.docTitle,
    history,
  ]);

  return [savedDashboard, dashboardContainer, dashboardStateManager];
};

const useDashboardBreadcrumbs = (
  dashboardStateManager: DashboardStateManager | null,
  redirectTo: DashboardAppProps['redirectTo']
) => {
  const { data, core, chrome } = useKibana<DashboardAppServices>().services;
  const { timefilter } = data.query.timefilter;
  const { openConfirm } = core.overlays;

  // Sync breadcrumbs when Dashboard State Manager changes
  useEffect(() => {
    if (!dashboardStateManager) {
      return;
    }
    const {
      confirmButtonText,
      cancelButtonText,
      leaveTitle: title,
      leaveSubtitle,
    } = leaveConfirmStrings;

    chrome.setBreadcrumbs([
      {
        text: dashboardBreadcrumb,
        'data-test-subj': 'dashboardListingBreadcrumb',
        onClick: () => {
          if (dashboardStateManager.getIsDirty()) {
            openConfirm(leaveSubtitle, {
              confirmButtonText,
              cancelButtonText,
              defaultFocusedButton: EUI_MODAL_CANCEL_BUTTON,
              title,
            }).then((isConfirmed) => {
              if (isConfirmed) {
                redirectTo({ destination: 'listing' });
              }
            });
          } else {
            redirectTo({ destination: 'listing' });
          }
        },
      },
      {
        text: getDashboardTitle(
          dashboardStateManager.getTitle(),
          dashboardStateManager.getViewMode(),
          dashboardStateManager.getIsDirty(timefilter),
          dashboardStateManager.isNew()
        ),
      },
    ]);
  }, [dashboardStateManager, timefilter, openConfirm, redirectTo, chrome]);
};

/* END HOOKS */

export function DashboardApp({
  savedDashboardId,
  embedSettings,
  redirectTo,
  history,
}: DashboardAppProps) {
  const {
    data,
    core,
    onAppLeave,
    embeddable,
    uiSettings,
    indexPatterns: indexPatternsService,
    dashboardCapabilities,
  } = useKibana<DashboardAppServices>().services;

  const [indexPatterns, setIndexPatterns] = useState<IndexPattern[]>([]);
  const [savedDashboard, dashboardContainer, dashboardStateManager] = useSavedDashboard(
    savedDashboardId,
    history,
    embedSettings
  );
  useDashboardBreadcrumbs(dashboardStateManager, redirectTo);

  const [lastReloadTime, setLastReloadTime] = useState(0);

  const refreshDashboardContainer = useCallback(
    (lastReloadRequestTime?: number) => {
      if (!dashboardContainer || !dashboardStateManager) {
        return;
      }

      const changes = getChangesFromAppStateForContainerState({
        dashboardContainer,
        appStateDashboardInput: getDashboardContainerInput({
          dashboardStateManager,
          isEmbeddedExternally: Boolean(embedSettings),
          lastReloadRequestTime,
          dashboardCapabilities,
          query: data.query,
        }),
      });

      if (changes) {
        if (getSearchSessionIdFromURL(history)) {
          // going away from a background search results
          removeQueryParam(history, DashboardConstants.SEARCH_SESSION_ID, true);
        }

        dashboardContainer.updateInput({
          ...changes,
          searchSessionId: data.search.session.start(),
        });
      }
    },
    [
      history,
      data.query,
      embedSettings,
      data.search.session,
      dashboardCapabilities,
      dashboardContainer,
      dashboardStateManager,
    ]
  );

  const addFromLibrary = useCallback(() => {
    if (dashboardContainer && !isErrorEmbeddable(dashboardContainer)) {
      openAddPanelFlyout({
        embeddable: dashboardContainer,
        getAllFactories: embeddable.getEmbeddableFactories,
        getFactory: embeddable.getEmbeddableFactory,
        notifications: core.notifications,
        overlays: core.overlays,
        SavedObjectFinder: getSavedObjectFinder(core.savedObjects, uiSettings),
      });
    }
  }, [
    embeddable.getEmbeddableFactories,
    embeddable.getEmbeddableFactory,
    dashboardContainer,
    core.notifications,
    core.savedObjects,
    core.overlays,
    uiSettings,
  ]);

  const createNew = useCallback(async () => {
    const type = 'visualization';
    const factory = embeddable.getEmbeddableFactory(type);
    if (!factory) {
      throw new EmbeddableFactoryNotFoundError(type);
    }
    const explicitInput = await factory.getExplicitInput();
    if (dashboardContainer) {
      await dashboardContainer.addNewEmbeddable(type, explicitInput);
    }
  }, [dashboardContainer, embeddable]);

  const updateViewMode = useCallback(
    (newMode: ViewMode) => {
      if (dashboardStateManager) {
        dashboardStateManager.switchViewMode(newMode);
      }
    },
    [dashboardStateManager]
  );

  // Render Dashboard Container and manage subscriptions
  useEffect(() => {
    if (!dashboardStateManager || !dashboardContainer) {
      return;
    }

    const timeFilter = data.query.timefilter.timefilter;
    const subscriptions = new Subscription();

    subscriptions.add(
      getInputSubscription({
        dashboardContainer,
        dashboardStateManager,
        filterManager: data.query.filterManager,
      })
    );
    subscriptions.add(
      getOutputSubscription({
        dashboardContainer,
        indexPatterns: indexPatternsService,
        onUpdateIndexPatterns: (newIndexPatterns) => setIndexPatterns(newIndexPatterns),
      })
    );
    subscriptions.add(
      getFiltersSubscription({
        query: data.query,
        dashboardStateManager,
      })
    );
    subscriptions.add(
      merge(
        ...[timeFilter.getRefreshIntervalUpdate$(), timeFilter.getTimeUpdate$()]
      ).subscribe(() => refreshDashboardContainer())
    );
    subscriptions.add(
      data.search.session.onRefresh$.subscribe(() => {
        setLastReloadTime(() => new Date().getTime());
      })
    );
    dashboardStateManager.registerChangeListener(() => {
      // we aren't checking dirty state because there are changes the container needs to know about
      // that won't make the dashboard "dirty" - like a view mode change.
      refreshDashboardContainer();
    });

    const dashboardViewport = document.getElementById('dashboardViewport');

    dashboardContainer.renderEmptyScreen = () => {
      const isEditMode = dashboardContainer.getInput().viewMode !== ViewMode.VIEW;
      return (
        <DashboardEmptyScreen
          isReadonlyMode={dashboardContainer.getInput().dashboardCapabilities?.hideWriteControls}
          onLinkClick={isEditMode ? addFromLibrary : () => updateViewMode(ViewMode.EDIT)}
          onVisualizeClick={createNew}
          showLinkToVisualize={isEditMode}
          uiSettings={uiSettings}
          http={core.http}
        />
      );
    };
    if (dashboardViewport) {
      dashboardContainer.render(dashboardViewport);
    }

    return () => {
      if (dashboardViewport) {
        ReactDOM.unmountComponentAtNode(dashboardViewport);
      }
      subscriptions.unsubscribe();
    };
  }, [
    createNew,
    core.http,
    uiSettings,
    data.query,
    indexPatternsService,
    addFromLibrary,
    updateViewMode,
    data.search.session,
    dashboardContainer,
    refreshDashboardContainer,
    dashboardStateManager,
  ]);

  // Build onAppLeave when Dashboard State Manager changes
  useEffect(() => {
    if (!dashboardStateManager || !dashboardContainer) {
      return;
    }

    onAppLeave((actions) => {
      if (dashboardStateManager?.getIsDirty() && !dashboardContainer?.skipWarningOnAppLeave) {
        // TODO: Finish App leave handler with overrides when redirecting to an editor.
        // return actions.confirm(leaveConfirmStrings.leaveSubtitle, leaveConfirmStrings.leaveTitle);
      }
      return actions.default();
    });

    return () => {
      // reset on app leave handler so the listing page doesn't trigger a confirmation
      onAppLeave((actions) => actions.default());
    };
  }, [dashboardStateManager, dashboardContainer, onAppLeave]);

  // Refresh the dashboard container when lastReloadTime changes
  useEffect(() => {
    refreshDashboardContainer(lastReloadTime);
  }, [lastReloadTime, refreshDashboardContainer]);

  return (
    <div className="app-container dshAppContainer">
      {dashboardContainer && dashboardStateManager && savedDashboard && (
        <DashboardTopNav
          createNew={createNew}
          redirectTo={redirectTo}
          embedSettings={embedSettings}
          updateViewMode={updateViewMode}
          addFromLibrary={addFromLibrary}
          lastDashboardId={savedDashboardId}
          indexPatterns={indexPatterns}
          savedDashboard={savedDashboard}
          timefilter={data.query.timefilter.timefilter}
          dashboardContainer={dashboardContainer}
          dashboardStateManager={dashboardStateManager}
          onQuerySubmit={(_payload, isUpdate) => {
            if (isUpdate === false) {
              // The user can still request a reload in the query bar, even if the
              // query is the same, and in that case, we have to explicitly ask for
              // a reload, since no state changes will cause it.
              setLastReloadTime(() => new Date().getTime());
            }
          }}
        />
      )}
      <div id="dashboardViewport" />
    </div>
  );
}
