/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import * as t from 'io-ts';
import type { TelemetryRootSchema, TelemetrySchemaObject, TelemetrySchemaValue } from './types';
import { excess } from './excess';

function isOneOfCandidate(schemas: t.Mixed[]): schemas is [t.Mixed, t.Mixed] {
  return schemas.length === 2;
}

/**
 * Converts each telemetry schema value to the @kbn/config-schema equivalent
 * @param value
 */
function valueSchemaToConfigSchema(value: TelemetrySchemaValue): t.Type<any> {
  // We need to check the pass_through type on top of everything
  if ((value as { type: 'pass_through' }).type === 'pass_through') {
    return t.unknown;
  }

  if ('properties' in value) {
    const { DYNAMIC_KEY, ...properties } = value.properties;
    const schemas: t.Mixed[] = [objectSchemaToIoTs({ properties })];
    if (DYNAMIC_KEY) {
      schemas.push(t.record(t.string, valueSchemaToConfigSchema(DYNAMIC_KEY)));
    }
    return isOneOfCandidate(schemas) ? t.union(schemas) : schemas[0];
  } else {
    const valueType = value.type; // Copied in here because of TS reasons, it's not available in the `default` case
    switch (value.type) {
      case 'boolean':
        return t.boolean;
      case 'keyword':
      case 'text':
      case 'date':
        return t.string;
      case 'byte':
      case 'double':
      case 'float':
      case 'integer':
      case 'long':
      case 'short':
        // Some plugins return `null` when there is no number to report
        return t.union([t.number, t.null]);
      case 'array':
        if ('items' in value) {
          return t.array(valueSchemaToConfigSchema(value.items));
        }
        throw new Error(`Schema type must include the "items" declaration.`);
      default:
        throw new Error(`Unsupported schema type ${valueType}.`);
    }
  }
}

function entriesToObjectIoTs(
  entries: Array<[string, TelemetrySchemaValue]>
): { [key: string]: t.Type<unknown> } {
  return Object.fromEntries(
    entries.map(([key, value]) => {
      try {
        return [key, valueSchemaToConfigSchema(value)];
      } catch (err) {
        err.failedKey = [key, ...(err.failedKey || [])];
        throw err;
      }
    })
  );
}

function objectSchemaToIoTs(
  objectSchema: TelemetrySchemaObject
): t.Type<{ [key: string]: unknown }> {
  const objectEntries = Object.entries(objectSchema.properties);

  const requiredFields = objectEntries.filter(([key, { _meta }]) => _meta?.optional !== true);
  const optionalFields = objectEntries.filter(([key, { _meta }]) => _meta?.optional === true);

  return excess(
    t.intersection([
      t.interface(entriesToObjectIoTs(requiredFields)),
      t.partial(entriesToObjectIoTs(optionalFields)),
    ])
  );
}

/**
 * Converts the JSON generated from the Usage Collection schema to a @kbn/config-schema object
 * so it can be used for validation. All entries are considered optional.
 * @param telemetrySchema JSON generated by @kbn/telemetry-tools from the Usage Collection schemas
 */
export function convertSchemaToIoTs(
  telemetrySchema: TelemetryRootSchema
): t.Type<{ [key: string]: unknown }> {
  try {
    return objectSchemaToIoTs({ properties: telemetrySchema });
  } catch (err) {
    if (err.failedKey) {
      err.message = `Malformed schema for key [${err.failedKey.join('.')}]: ${err.message}`;
    }
    throw err;
  }
}
