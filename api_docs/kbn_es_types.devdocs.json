{
  "id": "@kbn/es-types",
  "client": {
    "classes": [],
    "functions": [],
    "interfaces": [],
    "enums": [],
    "misc": [],
    "objects": []
  },
  "server": {
    "classes": [],
    "functions": [],
    "interfaces": [],
    "enums": [],
    "misc": [],
    "objects": []
  },
  "common": {
    "classes": [],
    "functions": [],
    "interfaces": [
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.ESQLColumn",
        "type": "Interface",
        "tags": [],
        "label": "ESQLColumn",
        "description": [],
        "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
        "deprecated": false,
        "trackAdoption": false,
        "children": [
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLColumn.name",
            "type": "string",
            "tags": [],
            "label": "name",
            "description": [],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          },
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLColumn.type",
            "type": "string",
            "tags": [],
            "label": "type",
            "description": [],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          }
        ],
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.ESQLSearchParams",
        "type": "Interface",
        "tags": [],
        "label": "ESQLSearchParams",
        "description": [],
        "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
        "deprecated": false,
        "trackAdoption": false,
        "children": [
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchParams.query",
            "type": "string",
            "tags": [],
            "label": "query",
            "description": [],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          },
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchParams.filter",
            "type": "Unknown",
            "tags": [],
            "label": "filter",
            "description": [],
            "signature": [
              "unknown"
            ],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          },
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchParams.locale",
            "type": "string",
            "tags": [],
            "label": "locale",
            "description": [],
            "signature": [
              "string | undefined"
            ],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          },
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchParams.include_ccs_metadata",
            "type": "CompoundType",
            "tags": [],
            "label": "include_ccs_metadata",
            "description": [],
            "signature": [
              "boolean | undefined"
            ],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          },
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchParams.dropNullColumns",
            "type": "CompoundType",
            "tags": [],
            "label": "dropNullColumns",
            "description": [],
            "signature": [
              "boolean | undefined"
            ],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          },
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchParams.params",
            "type": "CompoundType",
            "tags": [],
            "label": "params",
            "description": [],
            "signature": [
              "ScalarValue",
              "[] | Record<string, string | number | Record<string, string | number> | undefined>[] | undefined"
            ],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          }
        ],
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.ESQLSearchResponse",
        "type": "Interface",
        "tags": [],
        "label": "ESQLSearchResponse",
        "description": [],
        "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
        "deprecated": false,
        "trackAdoption": false,
        "children": [
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchResponse.columns",
            "type": "Array",
            "tags": [],
            "label": "columns",
            "description": [],
            "signature": [
              {
                "pluginId": "@kbn/es-types",
                "scope": "common",
                "docId": "kibKbnEsTypesPluginApi",
                "section": "def-common.ESQLColumn",
                "text": "ESQLColumn"
              },
              "[]"
            ],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          },
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchResponse.all_columns",
            "type": "Array",
            "tags": [],
            "label": "all_columns",
            "description": [],
            "signature": [
              {
                "pluginId": "@kbn/es-types",
                "scope": "common",
                "docId": "kibKbnEsTypesPluginApi",
                "section": "def-common.ESQLColumn",
                "text": "ESQLColumn"
              },
              "[] | undefined"
            ],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          },
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchResponse.values",
            "type": "Array",
            "tags": [],
            "label": "values",
            "description": [],
            "signature": [
              {
                "pluginId": "@kbn/es-types",
                "scope": "common",
                "docId": "kibKbnEsTypesPluginApi",
                "section": "def-common.ESQLRow",
                "text": "ESQLRow"
              },
              "[]"
            ],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          },
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchResponse.took",
            "type": "number",
            "tags": [],
            "label": "took",
            "description": [],
            "signature": [
              "number | undefined"
            ],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          },
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESQLSearchResponse._clusters",
            "type": "Object",
            "tags": [],
            "label": "_clusters",
            "description": [],
            "signature": [
              "ClusterStatistics",
              " | undefined"
            ],
            "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
            "deprecated": false,
            "trackAdoption": false
          }
        ],
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.ESSearchOptions",
        "type": "Interface",
        "tags": [],
        "label": "ESSearchOptions",
        "description": [],
        "path": "src/platform/packages/shared/kbn-es-types/src/index.ts",
        "deprecated": false,
        "trackAdoption": false,
        "children": [
          {
            "parentPluginId": "@kbn/es-types",
            "id": "def-common.ESSearchOptions.restTotalHitsAsInt",
            "type": "boolean",
            "tags": [],
            "label": "restTotalHitsAsInt",
            "description": [],
            "path": "src/platform/packages/shared/kbn-es-types/src/index.ts",
            "deprecated": false,
            "trackAdoption": false
          }
        ],
        "initialIsOpen": false
      }
    ],
    "enums": [],
    "misc": [
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.AggregateOf",
        "type": "Type",
        "tags": [],
        "label": "AggregateOf",
        "description": [],
        "signature": [
          "Pick<Record<string, unknown> & { adjacency_matrix: { buckets: ({ key: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; auto_date_histogram: { interval: string; buckets: ({ key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; avg: { value: number | null; value_as_string?: string | undefined; }; avg_bucket: { value: number | null; }; boxplot: { min: number | null; max: number | null; q1: number | null; q2: number | null; q3: number | null; }; bucket_correlation: { value: number | null; }; bucket_count_ks_test: { less: number; greater: number; two_sided: number; }; bucket_script: { value: unknown; }; categorize_text: { buckets: ({ doc_count: number; key: string; regex: string; max_matching_length: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cardinality: { value: number; }; change_point: { bucket?: { key: string; } | undefined; type: Record<",
          "ChangePointType",
          ", { change_point?: number | undefined; r_value?: number | undefined; trend?: string | undefined; p_value?: number | undefined; }>; }; children: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; composite: { after_key: CompositeKeysOf<TAggregationContainer>; buckets: ({ doc_count: number; key: CompositeKeysOf<TAggregationContainer>; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cumulative_cardinality: { value: number; }; cumulative_sum: { value: number; }; date_histogram: MaybeKeyed<TAggregationContainer, { key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; date_range: MaybeKeyed<TAggregationContainer, Partial<{ from: string | number; from_as_string: string; }> & Partial<{ to: string | number; to_as_string: string; }> & { doc_count: number; key: string; }, string>; derivative: { value: number | null; } | undefined; extended_stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_of_squares_as_string: string; variance_population_as_string: string; variance_sampling_as_string: string; std_deviation_as_string: string; std_deviation_population_as_string: string; std_deviation_sampling_as_string: string; std_deviation_bounds_as_string: { upper: string; lower: string; upper_population: string; lower_population: string; upper_sampling: string; lower_sampling: string; }; }); extended_stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number | null; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; }; filter: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; filters: { buckets: TAggregationContainer extends { filters: { filters: any[]; }; } ? ({ doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[] : TAggregationContainer extends { filters: { filters: Record<string, any>; }; } ? { [key in keyof TAggregationContainer[\"filters\"][\"filters\"]]: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } & (TAggregationContainer extends { filters: { other_bucket_key: infer TOtherBucketKey; }; } ? Record<TOtherBucketKey & string, { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>> : unknown) & (TAggregationContainer extends { filters: { other_bucket: true; }; } ? { _other: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } : unknown) : unknown; }; geo_bounds: { top_left: { lat: number | null; lon: number | null; }; bottom_right: { lat: number | null; lon: number | null; }; }; geo_centroid: { count: number; location: { lat: number; lon: number; }; }; geo_distance: MaybeKeyed<TAggregationContainer, { from: number; to?: number | undefined; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; geo_hash: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; geotile_grid: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; global: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; histogram: MaybeKeyed<TAggregationContainer, { key: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; ip_range: MaybeKeyed<TAggregationContainer, { key: string; from?: string | undefined; to?: string | undefined; doc_count: number; }, TAggregationContainer extends { ip_range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; inference: { value: number; prediction_probability: number; prediction_score: number; }; max: { value: number | null; value_as_string?: string | undefined; }; max_bucket: { value: number | null; }; min: { value: number | null; value_as_string?: string | undefined; }; min_bucket: { value: number | null; }; median_absolute_deviation: { value: number | null; }; moving_avg: { value: number | null; } | undefined; moving_fn: { value: number | null; }; moving_percentiles: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null> | undefined; missing: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; multi_terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string[]; key_as_string: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; normalize: { value: number | null; value_as_string?: string | undefined; }; parent: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; percentiles: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentile_ranks: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentiles_bucket: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; range: MaybeKeyed<TAggregationContainer, { key: string; from?: number | undefined; from_as_string?: string | undefined; to?: number | undefined; to_as_string?: string | undefined; doc_count: number; }, TAggregationContainer extends { range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; rare_terms: ({ key: string | number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; rate: { value: number | null; }; reverse_nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; random_sampler: { seed: number; probability: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; sampler: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; scripted_metric: { value: unknown; }; serial_diff: { value: number | null; value_as_string?: string | undefined; }; significant_terms: { doc_count: number; bg_count: number; buckets: ({ key: string | number; score: number; doc_count: number; bg_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; significant_text: { doc_count: number; buckets: { key: string; doc_count: number; score: number; bg_count: number; }[]; }; stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_as_string: string; }); stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; }; string_stats: { count: number; min_length: number | null; max_length: number | null; avg_length: number | null; entropy: number | null; distribution: Record<string, number>; }; sum: { value: number | null; value_as_string?: string | undefined; }; sum_bucket: { value: number | null; }; terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string | number; key_as_string?: string | undefined; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; top_hits: { hits: { total: { value: number; relation: \"gte\" | \"eq\"; }; max_score: number | null; hits: TAggregationContainer extends { top_hits: ",
          "AggregationsTopHitsAggregation",
          "; } ? HitsOf<TAggregationContainer[\"top_hits\"], TDocument> : ",
          "SearchHitsMetadata",
          "<TDocument>; }; }; top_metrics: { top: { sort: string[] | number[]; metrics: Record<TopMetricKeysOf<TAggregationContainer>, string | number | null>; }[]; }; weighted_avg: { value: number | null; }; value_count: { value: number; }; }, Exclude<ValidAggregationKeysOf<TAggregationContainer>, \"aggs\" | \"aggregations\"> & string> extends readonly any[] ? (readonly any[] & Pick<Record<string, unknown> & { adjacency_matrix: { buckets: ({ key: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; auto_date_histogram: { interval: string; buckets: ({ key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; avg: { value: number | null; value_as_string?: string | undefined; }; avg_bucket: { value: number | null; }; boxplot: { min: number | null; max: number | null; q1: number | null; q2: number | null; q3: number | null; }; bucket_correlation: { value: number | null; }; bucket_count_ks_test: { less: number; greater: number; two_sided: number; }; bucket_script: { value: unknown; }; categorize_text: { buckets: ({ doc_count: number; key: string; regex: string; max_matching_length: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cardinality: { value: number; }; change_point: { bucket?: { key: string; } | undefined; type: Record<",
          "ChangePointType",
          ", { change_point?: number | undefined; r_value?: number | undefined; trend?: string | undefined; p_value?: number | undefined; }>; }; children: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; composite: { after_key: CompositeKeysOf<TAggregationContainer>; buckets: ({ doc_count: number; key: CompositeKeysOf<TAggregationContainer>; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cumulative_cardinality: { value: number; }; cumulative_sum: { value: number; }; date_histogram: MaybeKeyed<TAggregationContainer, { key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; date_range: MaybeKeyed<TAggregationContainer, Partial<{ from: string | number; from_as_string: string; }> & Partial<{ to: string | number; to_as_string: string; }> & { doc_count: number; key: string; }, string>; derivative: { value: number | null; } | undefined; extended_stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_of_squares_as_string: string; variance_population_as_string: string; variance_sampling_as_string: string; std_deviation_as_string: string; std_deviation_population_as_string: string; std_deviation_sampling_as_string: string; std_deviation_bounds_as_string: { upper: string; lower: string; upper_population: string; lower_population: string; upper_sampling: string; lower_sampling: string; }; }); extended_stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number | null; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; }; filter: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; filters: { buckets: TAggregationContainer extends { filters: { filters: any[]; }; } ? ({ doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[] : TAggregationContainer extends { filters: { filters: Record<string, any>; }; } ? { [key in keyof TAggregationContainer[\"filters\"][\"filters\"]]: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } & (TAggregationContainer extends { filters: { other_bucket_key: infer TOtherBucketKey; }; } ? Record<TOtherBucketKey & string, { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>> : unknown) & (TAggregationContainer extends { filters: { other_bucket: true; }; } ? { _other: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } : unknown) : unknown; }; geo_bounds: { top_left: { lat: number | null; lon: number | null; }; bottom_right: { lat: number | null; lon: number | null; }; }; geo_centroid: { count: number; location: { lat: number; lon: number; }; }; geo_distance: MaybeKeyed<TAggregationContainer, { from: number; to?: number | undefined; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; geo_hash: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; geotile_grid: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; global: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; histogram: MaybeKeyed<TAggregationContainer, { key: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; ip_range: MaybeKeyed<TAggregationContainer, { key: string; from?: string | undefined; to?: string | undefined; doc_count: number; }, TAggregationContainer extends { ip_range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; inference: { value: number; prediction_probability: number; prediction_score: number; }; max: { value: number | null; value_as_string?: string | undefined; }; max_bucket: { value: number | null; }; min: { value: number | null; value_as_string?: string | undefined; }; min_bucket: { value: number | null; }; median_absolute_deviation: { value: number | null; }; moving_avg: { value: number | null; } | undefined; moving_fn: { value: number | null; }; moving_percentiles: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null> | undefined; missing: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; multi_terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string[]; key_as_string: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; normalize: { value: number | null; value_as_string?: string | undefined; }; parent: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; percentiles: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentile_ranks: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentiles_bucket: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; range: MaybeKeyed<TAggregationContainer, { key: string; from?: number | undefined; from_as_string?: string | undefined; to?: number | undefined; to_as_string?: string | undefined; doc_count: number; }, TAggregationContainer extends { range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; rare_terms: ({ key: string | number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; rate: { value: number | null; }; reverse_nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; random_sampler: { seed: number; probability: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; sampler: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; scripted_metric: { value: unknown; }; serial_diff: { value: number | null; value_as_string?: string | undefined; }; significant_terms: { doc_count: number; bg_count: number; buckets: ({ key: string | number; score: number; doc_count: number; bg_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; significant_text: { doc_count: number; buckets: { key: string; doc_count: number; score: number; bg_count: number; }[]; }; stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_as_string: string; }); stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; }; string_stats: { count: number; min_length: number | null; max_length: number | null; avg_length: number | null; entropy: number | null; distribution: Record<string, number>; }; sum: { value: number | null; value_as_string?: string | undefined; }; sum_bucket: { value: number | null; }; terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string | number; key_as_string?: string | undefined; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; top_hits: { hits: { total: { value: number; relation: \"gte\" | \"eq\"; }; max_score: number | null; hits: TAggregationContainer extends { top_hits: ",
          "AggregationsTopHitsAggregation",
          "; } ? HitsOf<TAggregationContainer[\"top_hits\"], TDocument> : ",
          "SearchHitsMetadata",
          "<TDocument>; }; }; top_metrics: { top: { sort: string[] | number[]; metrics: Record<TopMetricKeysOf<TAggregationContainer>, string | number | null>; }[]; }; weighted_avg: { value: number | null; }; value_count: { value: number; }; }, Exclude<ValidAggregationKeysOf<TAggregationContainer>, \"aggs\" | \"aggregations\"> & string>)[number] : Pick<Record<string, unknown> & { adjacency_matrix: { buckets: ({ key: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; auto_date_histogram: { interval: string; buckets: ({ key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; avg: { value: number | null; value_as_string?: string | undefined; }; avg_bucket: { value: number | null; }; boxplot: { min: number | null; max: number | null; q1: number | null; q2: number | null; q3: number | null; }; bucket_correlation: { value: number | null; }; bucket_count_ks_test: { less: number; greater: number; two_sided: number; }; bucket_script: { value: unknown; }; categorize_text: { buckets: ({ doc_count: number; key: string; regex: string; max_matching_length: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cardinality: { value: number; }; change_point: { bucket?: { key: string; } | undefined; type: Record<",
          "ChangePointType",
          ", { change_point?: number | undefined; r_value?: number | undefined; trend?: string | undefined; p_value?: number | undefined; }>; }; children: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; composite: { after_key: CompositeKeysOf<TAggregationContainer>; buckets: ({ doc_count: number; key: CompositeKeysOf<TAggregationContainer>; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cumulative_cardinality: { value: number; }; cumulative_sum: { value: number; }; date_histogram: MaybeKeyed<TAggregationContainer, { key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; date_range: MaybeKeyed<TAggregationContainer, Partial<{ from: string | number; from_as_string: string; }> & Partial<{ to: string | number; to_as_string: string; }> & { doc_count: number; key: string; }, string>; derivative: { value: number | null; } | undefined; extended_stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_of_squares_as_string: string; variance_population_as_string: string; variance_sampling_as_string: string; std_deviation_as_string: string; std_deviation_population_as_string: string; std_deviation_sampling_as_string: string; std_deviation_bounds_as_string: { upper: string; lower: string; upper_population: string; lower_population: string; upper_sampling: string; lower_sampling: string; }; }); extended_stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number | null; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; }; filter: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; filters: { buckets: TAggregationContainer extends { filters: { filters: any[]; }; } ? ({ doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[] : TAggregationContainer extends { filters: { filters: Record<string, any>; }; } ? { [key in keyof TAggregationContainer[\"filters\"][\"filters\"]]: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } & (TAggregationContainer extends { filters: { other_bucket_key: infer TOtherBucketKey; }; } ? Record<TOtherBucketKey & string, { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>> : unknown) & (TAggregationContainer extends { filters: { other_bucket: true; }; } ? { _other: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } : unknown) : unknown; }; geo_bounds: { top_left: { lat: number | null; lon: number | null; }; bottom_right: { lat: number | null; lon: number | null; }; }; geo_centroid: { count: number; location: { lat: number; lon: number; }; }; geo_distance: MaybeKeyed<TAggregationContainer, { from: number; to?: number | undefined; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; geo_hash: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; geotile_grid: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; global: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; histogram: MaybeKeyed<TAggregationContainer, { key: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; ip_range: MaybeKeyed<TAggregationContainer, { key: string; from?: string | undefined; to?: string | undefined; doc_count: number; }, TAggregationContainer extends { ip_range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; inference: { value: number; prediction_probability: number; prediction_score: number; }; max: { value: number | null; value_as_string?: string | undefined; }; max_bucket: { value: number | null; }; min: { value: number | null; value_as_string?: string | undefined; }; min_bucket: { value: number | null; }; median_absolute_deviation: { value: number | null; }; moving_avg: { value: number | null; } | undefined; moving_fn: { value: number | null; }; moving_percentiles: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null> | undefined; missing: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; multi_terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string[]; key_as_string: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; normalize: { value: number | null; value_as_string?: string | undefined; }; parent: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; percentiles: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentile_ranks: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentiles_bucket: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; range: MaybeKeyed<TAggregationContainer, { key: string; from?: number | undefined; from_as_string?: string | undefined; to?: number | undefined; to_as_string?: string | undefined; doc_count: number; }, TAggregationContainer extends { range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; rare_terms: ({ key: string | number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; rate: { value: number | null; }; reverse_nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; random_sampler: { seed: number; probability: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; sampler: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; scripted_metric: { value: unknown; }; serial_diff: { value: number | null; value_as_string?: string | undefined; }; significant_terms: { doc_count: number; bg_count: number; buckets: ({ key: string | number; score: number; doc_count: number; bg_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; significant_text: { doc_count: number; buckets: { key: string; doc_count: number; score: number; bg_count: number; }[]; }; stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_as_string: string; }); stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; }; string_stats: { count: number; min_length: number | null; max_length: number | null; avg_length: number | null; entropy: number | null; distribution: Record<string, number>; }; sum: { value: number | null; value_as_string?: string | undefined; }; sum_bucket: { value: number | null; }; terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string | number; key_as_string?: string | undefined; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; top_hits: { hits: { total: { value: number; relation: \"gte\" | \"eq\"; }; max_score: number | null; hits: TAggregationContainer extends { top_hits: ",
          "AggregationsTopHitsAggregation",
          "; } ? HitsOf<TAggregationContainer[\"top_hits\"], TDocument> : ",
          "SearchHitsMetadata",
          "<TDocument>; }; }; top_metrics: { top: { sort: string[] | number[]; metrics: Record<TopMetricKeysOf<TAggregationContainer>, string | number | null>; }[]; }; weighted_avg: { value: number | null; }; value_count: { value: number; }; }, Exclude<ValidAggregationKeysOf<TAggregationContainer>, \"aggs\" | \"aggregations\"> & string> extends ArrayLike<any> ? (ArrayLike<any> & Pick<Record<string, unknown> & { adjacency_matrix: { buckets: ({ key: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; auto_date_histogram: { interval: string; buckets: ({ key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; avg: { value: number | null; value_as_string?: string | undefined; }; avg_bucket: { value: number | null; }; boxplot: { min: number | null; max: number | null; q1: number | null; q2: number | null; q3: number | null; }; bucket_correlation: { value: number | null; }; bucket_count_ks_test: { less: number; greater: number; two_sided: number; }; bucket_script: { value: unknown; }; categorize_text: { buckets: ({ doc_count: number; key: string; regex: string; max_matching_length: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cardinality: { value: number; }; change_point: { bucket?: { key: string; } | undefined; type: Record<",
          "ChangePointType",
          ", { change_point?: number | undefined; r_value?: number | undefined; trend?: string | undefined; p_value?: number | undefined; }>; }; children: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; composite: { after_key: CompositeKeysOf<TAggregationContainer>; buckets: ({ doc_count: number; key: CompositeKeysOf<TAggregationContainer>; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cumulative_cardinality: { value: number; }; cumulative_sum: { value: number; }; date_histogram: MaybeKeyed<TAggregationContainer, { key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; date_range: MaybeKeyed<TAggregationContainer, Partial<{ from: string | number; from_as_string: string; }> & Partial<{ to: string | number; to_as_string: string; }> & { doc_count: number; key: string; }, string>; derivative: { value: number | null; } | undefined; extended_stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_of_squares_as_string: string; variance_population_as_string: string; variance_sampling_as_string: string; std_deviation_as_string: string; std_deviation_population_as_string: string; std_deviation_sampling_as_string: string; std_deviation_bounds_as_string: { upper: string; lower: string; upper_population: string; lower_population: string; upper_sampling: string; lower_sampling: string; }; }); extended_stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number | null; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; }; filter: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; filters: { buckets: TAggregationContainer extends { filters: { filters: any[]; }; } ? ({ doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[] : TAggregationContainer extends { filters: { filters: Record<string, any>; }; } ? { [key in keyof TAggregationContainer[\"filters\"][\"filters\"]]: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } & (TAggregationContainer extends { filters: { other_bucket_key: infer TOtherBucketKey; }; } ? Record<TOtherBucketKey & string, { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>> : unknown) & (TAggregationContainer extends { filters: { other_bucket: true; }; } ? { _other: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } : unknown) : unknown; }; geo_bounds: { top_left: { lat: number | null; lon: number | null; }; bottom_right: { lat: number | null; lon: number | null; }; }; geo_centroid: { count: number; location: { lat: number; lon: number; }; }; geo_distance: MaybeKeyed<TAggregationContainer, { from: number; to?: number | undefined; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; geo_hash: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; geotile_grid: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; global: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; histogram: MaybeKeyed<TAggregationContainer, { key: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; ip_range: MaybeKeyed<TAggregationContainer, { key: string; from?: string | undefined; to?: string | undefined; doc_count: number; }, TAggregationContainer extends { ip_range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; inference: { value: number; prediction_probability: number; prediction_score: number; }; max: { value: number | null; value_as_string?: string | undefined; }; max_bucket: { value: number | null; }; min: { value: number | null; value_as_string?: string | undefined; }; min_bucket: { value: number | null; }; median_absolute_deviation: { value: number | null; }; moving_avg: { value: number | null; } | undefined; moving_fn: { value: number | null; }; moving_percentiles: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null> | undefined; missing: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; multi_terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string[]; key_as_string: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; normalize: { value: number | null; value_as_string?: string | undefined; }; parent: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; percentiles: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentile_ranks: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentiles_bucket: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; range: MaybeKeyed<TAggregationContainer, { key: string; from?: number | undefined; from_as_string?: string | undefined; to?: number | undefined; to_as_string?: string | undefined; doc_count: number; }, TAggregationContainer extends { range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; rare_terms: ({ key: string | number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; rate: { value: number | null; }; reverse_nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; random_sampler: { seed: number; probability: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; sampler: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; scripted_metric: { value: unknown; }; serial_diff: { value: number | null; value_as_string?: string | undefined; }; significant_terms: { doc_count: number; bg_count: number; buckets: ({ key: string | number; score: number; doc_count: number; bg_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; significant_text: { doc_count: number; buckets: { key: string; doc_count: number; score: number; bg_count: number; }[]; }; stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_as_string: string; }); stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; }; string_stats: { count: number; min_length: number | null; max_length: number | null; avg_length: number | null; entropy: number | null; distribution: Record<string, number>; }; sum: { value: number | null; value_as_string?: string | undefined; }; sum_bucket: { value: number | null; }; terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string | number; key_as_string?: string | undefined; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; top_hits: { hits: { total: { value: number; relation: \"gte\" | \"eq\"; }; max_score: number | null; hits: TAggregationContainer extends { top_hits: ",
          "AggregationsTopHitsAggregation",
          "; } ? HitsOf<TAggregationContainer[\"top_hits\"], TDocument> : ",
          "SearchHitsMetadata",
          "<TDocument>; }; }; top_metrics: { top: { sort: string[] | number[]; metrics: Record<TopMetricKeysOf<TAggregationContainer>, string | number | null>; }[]; }; weighted_avg: { value: number | null; }; value_count: { value: number; }; }, Exclude<ValidAggregationKeysOf<TAggregationContainer>, \"aggs\" | \"aggregations\"> & string>)[number] : Pick<Record<string, unknown> & { adjacency_matrix: { buckets: ({ key: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; auto_date_histogram: { interval: string; buckets: ({ key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; avg: { value: number | null; value_as_string?: string | undefined; }; avg_bucket: { value: number | null; }; boxplot: { min: number | null; max: number | null; q1: number | null; q2: number | null; q3: number | null; }; bucket_correlation: { value: number | null; }; bucket_count_ks_test: { less: number; greater: number; two_sided: number; }; bucket_script: { value: unknown; }; categorize_text: { buckets: ({ doc_count: number; key: string; regex: string; max_matching_length: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cardinality: { value: number; }; change_point: { bucket?: { key: string; } | undefined; type: Record<",
          "ChangePointType",
          ", { change_point?: number | undefined; r_value?: number | undefined; trend?: string | undefined; p_value?: number | undefined; }>; }; children: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; composite: { after_key: CompositeKeysOf<TAggregationContainer>; buckets: ({ doc_count: number; key: CompositeKeysOf<TAggregationContainer>; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cumulative_cardinality: { value: number; }; cumulative_sum: { value: number; }; date_histogram: MaybeKeyed<TAggregationContainer, { key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; date_range: MaybeKeyed<TAggregationContainer, Partial<{ from: string | number; from_as_string: string; }> & Partial<{ to: string | number; to_as_string: string; }> & { doc_count: number; key: string; }, string>; derivative: { value: number | null; } | undefined; extended_stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_of_squares_as_string: string; variance_population_as_string: string; variance_sampling_as_string: string; std_deviation_as_string: string; std_deviation_population_as_string: string; std_deviation_sampling_as_string: string; std_deviation_bounds_as_string: { upper: string; lower: string; upper_population: string; lower_population: string; upper_sampling: string; lower_sampling: string; }; }); extended_stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number | null; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; }; filter: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; filters: { buckets: TAggregationContainer extends { filters: { filters: any[]; }; } ? ({ doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[] : TAggregationContainer extends { filters: { filters: Record<string, any>; }; } ? { [key in keyof TAggregationContainer[\"filters\"][\"filters\"]]: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } & (TAggregationContainer extends { filters: { other_bucket_key: infer TOtherBucketKey; }; } ? Record<TOtherBucketKey & string, { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>> : unknown) & (TAggregationContainer extends { filters: { other_bucket: true; }; } ? { _other: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } : unknown) : unknown; }; geo_bounds: { top_left: { lat: number | null; lon: number | null; }; bottom_right: { lat: number | null; lon: number | null; }; }; geo_centroid: { count: number; location: { lat: number; lon: number; }; }; geo_distance: MaybeKeyed<TAggregationContainer, { from: number; to?: number | undefined; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; geo_hash: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; geotile_grid: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; global: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; histogram: MaybeKeyed<TAggregationContainer, { key: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; ip_range: MaybeKeyed<TAggregationContainer, { key: string; from?: string | undefined; to?: string | undefined; doc_count: number; }, TAggregationContainer extends { ip_range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; inference: { value: number; prediction_probability: number; prediction_score: number; }; max: { value: number | null; value_as_string?: string | undefined; }; max_bucket: { value: number | null; }; min: { value: number | null; value_as_string?: string | undefined; }; min_bucket: { value: number | null; }; median_absolute_deviation: { value: number | null; }; moving_avg: { value: number | null; } | undefined; moving_fn: { value: number | null; }; moving_percentiles: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null> | undefined; missing: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; multi_terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string[]; key_as_string: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; normalize: { value: number | null; value_as_string?: string | undefined; }; parent: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; percentiles: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentile_ranks: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentiles_bucket: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; range: MaybeKeyed<TAggregationContainer, { key: string; from?: number | undefined; from_as_string?: string | undefined; to?: number | undefined; to_as_string?: string | undefined; doc_count: number; }, TAggregationContainer extends { range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; rare_terms: ({ key: string | number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; rate: { value: number | null; }; reverse_nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; random_sampler: { seed: number; probability: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; sampler: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; scripted_metric: { value: unknown; }; serial_diff: { value: number | null; value_as_string?: string | undefined; }; significant_terms: { doc_count: number; bg_count: number; buckets: ({ key: string | number; score: number; doc_count: number; bg_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; significant_text: { doc_count: number; buckets: { key: string; doc_count: number; score: number; bg_count: number; }[]; }; stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_as_string: string; }); stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; }; string_stats: { count: number; min_length: number | null; max_length: number | null; avg_length: number | null; entropy: number | null; distribution: Record<string, number>; }; sum: { value: number | null; value_as_string?: string | undefined; }; sum_bucket: { value: number | null; }; terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string | number; key_as_string?: string | undefined; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; top_hits: { hits: { total: { value: number; relation: \"gte\" | \"eq\"; }; max_score: number | null; hits: TAggregationContainer extends { top_hits: ",
          "AggregationsTopHitsAggregation",
          "; } ? HitsOf<TAggregationContainer[\"top_hits\"], TDocument> : ",
          "SearchHitsMetadata",
          "<TDocument>; }; }; top_metrics: { top: { sort: string[] | number[]; metrics: Record<TopMetricKeysOf<TAggregationContainer>, string | number | null>; }[]; }; weighted_avg: { value: number | null; }; value_count: { value: number; }; }, Exclude<ValidAggregationKeysOf<TAggregationContainer>, \"aggs\" | \"aggregations\"> & string> extends object ? Pick<Record<string, unknown> & { adjacency_matrix: { buckets: ({ key: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; auto_date_histogram: { interval: string; buckets: ({ key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; avg: { value: number | null; value_as_string?: string | undefined; }; avg_bucket: { value: number | null; }; boxplot: { min: number | null; max: number | null; q1: number | null; q2: number | null; q3: number | null; }; bucket_correlation: { value: number | null; }; bucket_count_ks_test: { less: number; greater: number; two_sided: number; }; bucket_script: { value: unknown; }; categorize_text: { buckets: ({ doc_count: number; key: string; regex: string; max_matching_length: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cardinality: { value: number; }; change_point: { bucket?: { key: string; } | undefined; type: Record<",
          "ChangePointType",
          ", { change_point?: number | undefined; r_value?: number | undefined; trend?: string | undefined; p_value?: number | undefined; }>; }; children: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; composite: { after_key: CompositeKeysOf<TAggregationContainer>; buckets: ({ doc_count: number; key: CompositeKeysOf<TAggregationContainer>; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; cumulative_cardinality: { value: number; }; cumulative_sum: { value: number; }; date_histogram: MaybeKeyed<TAggregationContainer, { key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; date_range: MaybeKeyed<TAggregationContainer, Partial<{ from: string | number; from_as_string: string; }> & Partial<{ to: string | number; to_as_string: string; }> & { doc_count: number; key: string; }, string>; derivative: { value: number | null; } | undefined; extended_stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_of_squares_as_string: string; variance_population_as_string: string; variance_sampling_as_string: string; std_deviation_as_string: string; std_deviation_population_as_string: string; std_deviation_sampling_as_string: string; std_deviation_bounds_as_string: { upper: string; lower: string; upper_population: string; lower_population: string; upper_sampling: string; lower_sampling: string; }; }); extended_stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number | null; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; }; filter: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; filters: { buckets: TAggregationContainer extends { filters: { filters: any[]; }; } ? ({ doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[] : TAggregationContainer extends { filters: { filters: Record<string, any>; }; } ? { [key in keyof TAggregationContainer[\"filters\"][\"filters\"]]: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } & (TAggregationContainer extends { filters: { other_bucket_key: infer TOtherBucketKey; }; } ? Record<TOtherBucketKey & string, { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>> : unknown) & (TAggregationContainer extends { filters: { other_bucket: true; }; } ? { _other: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; } : unknown) : unknown; }; geo_bounds: { top_left: { lat: number | null; lon: number | null; }; bottom_right: { lat: number | null; lon: number | null; }; }; geo_centroid: { count: number; location: { lat: number; lon: number; }; }; geo_distance: MaybeKeyed<TAggregationContainer, { from: number; to?: number | undefined; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; geo_hash: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; geotile_grid: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; global: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; histogram: MaybeKeyed<TAggregationContainer, { key: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>, string>; ip_range: MaybeKeyed<TAggregationContainer, { key: string; from?: string | undefined; to?: string | undefined; doc_count: number; }, TAggregationContainer extends { ip_range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; inference: { value: number; prediction_probability: number; prediction_score: number; }; max: { value: number | null; value_as_string?: string | undefined; }; max_bucket: { value: number | null; }; min: { value: number | null; value_as_string?: string | undefined; }; min_bucket: { value: number | null; }; median_absolute_deviation: { value: number | null; }; moving_avg: { value: number | null; } | undefined; moving_fn: { value: number | null; }; moving_percentiles: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null> | undefined; missing: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; multi_terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string[]; key_as_string: string; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; normalize: { value: number | null; value_as_string?: string | undefined; }; parent: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; percentiles: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentile_ranks: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentiles_bucket: { values: TAggregationContainer extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; range: MaybeKeyed<TAggregationContainer, { key: string; from?: number | undefined; from_as_string?: string | undefined; to?: number | undefined; to_as_string?: string | undefined; doc_count: number; }, TAggregationContainer extends { range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; rare_terms: ({ key: string | number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; rate: { value: number | null; }; reverse_nested: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; random_sampler: { seed: number; probability: number; doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; sampler: { doc_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>; scripted_metric: { value: unknown; }; serial_diff: { value: number | null; value_as_string?: string | undefined; }; significant_terms: { doc_count: number; bg_count: number; buckets: ({ key: string | number; score: number; doc_count: number; bg_count: number; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; significant_text: { doc_count: number; buckets: { key: string; doc_count: number; score: number; bg_count: number; }[]; }; stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_as_string: string; }); stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; }; string_stats: { count: number; min_length: number | null; max_length: number | null; avg_length: number | null; entropy: number | null; distribution: Record<string, number>; }; sum: { value: number | null; value_as_string?: string | undefined; }; sum_bucket: { value: number | null; }; terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string | number; key_as_string?: string | undefined; } & SubAggregateOf<TAggregationContainer, TDocument>)[]; }; top_hits: { hits: { total: { value: number; relation: \"gte\" | \"eq\"; }; max_score: number | null; hits: TAggregationContainer extends { top_hits: ",
          "AggregationsTopHitsAggregation",
          "; } ? HitsOf<TAggregationContainer[\"top_hits\"], TDocument> : ",
          "SearchHitsMetadata",
          "<TDocument>; }; }; top_metrics: { top: { sort: string[] | number[]; metrics: Record<TopMetricKeysOf<TAggregationContainer>, string | number | null>; }[]; }; weighted_avg: { value: number | null; }; value_count: { value: number; }; }, Exclude<ValidAggregationKeysOf<TAggregationContainer>, \"aggs\" | \"aggregations\"> & string>[Exclude<ValidAggregationKeysOf<TAggregationContainer>, \"aggs\" | \"aggregations\"> & string] : never"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.AggregateOfMap",
        "type": "Type",
        "tags": [],
        "label": "AggregateOfMap",
        "description": [],
        "signature": [
          "{ [TAggregationName in keyof TAggregationMap]: Required<TAggregationMap>[TAggregationName] extends AggregationsAggregationContainer ? ",
          "ValuesType",
          "<Pick<Record<string, unknown> & { adjacency_matrix: { buckets: ({ key: string; doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>)[]; }; auto_date_histogram: { interval: string; buckets: ({ key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>)[]; }; avg: { value: number | null; value_as_string?: string | undefined; }; avg_bucket: { value: number | null; }; boxplot: { min: number | null; max: number | null; q1: number | null; q2: number | null; q3: number | null; }; bucket_correlation: { value: number | null; }; bucket_count_ks_test: { less: number; greater: number; two_sided: number; }; bucket_script: { value: unknown; }; categorize_text: { buckets: ({ doc_count: number; key: string; regex: string; max_matching_length: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>)[]; }; cardinality: { value: number; }; change_point: { bucket?: { key: string; } | undefined; type: Record<",
          "ChangePointType",
          ", { change_point?: number | undefined; r_value?: number | undefined; trend?: string | undefined; p_value?: number | undefined; }>; }; children: { doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>; composite: { after_key: CompositeKeysOf<Required<TAggregationMap>[TAggregationName]>; buckets: ({ doc_count: number; key: CompositeKeysOf<Required<TAggregationMap>[TAggregationName]>; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>)[]; }; cumulative_cardinality: { value: number; }; cumulative_sum: { value: number; }; date_histogram: MaybeKeyed<Required<TAggregationMap>[TAggregationName], { key: number; key_as_string: string; doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>, string>; date_range: MaybeKeyed<Required<TAggregationMap>[TAggregationName], Partial<{ from: string | number; from_as_string: string; }> & Partial<{ to: string | number; to_as_string: string; }> & { doc_count: number; key: string; }, string>; derivative: { value: number | null; } | undefined; extended_stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_of_squares_as_string: string; variance_population_as_string: string; variance_sampling_as_string: string; std_deviation_as_string: string; std_deviation_population_as_string: string; std_deviation_sampling_as_string: string; std_deviation_bounds_as_string: { upper: string; lower: string; upper_population: string; lower_population: string; upper_sampling: string; lower_sampling: string; }; }); extended_stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number | null; sum_of_squares: number | null; variance: number | null; variance_population: number | null; variance_sampling: number | null; std_deviation: number | null; std_deviation_population: number | null; std_deviation_sampling: number | null; std_deviation_bounds: { upper: number | null; lower: number | null; upper_population: number | null; lower_population: number | null; upper_sampling: number | null; lower_sampling: number | null; }; }; filter: { doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>; filters: { buckets: Required<TAggregationMap>[TAggregationName] extends { filters: { filters: any[]; }; } ? ({ doc_count: number; } & SubAggregateOf<{ filters: { filters: any[]; }; } & Required<TAggregationMap>[TAggregationName], TDocument>)[] : Required<TAggregationMap>[TAggregationName] extends { filters: { filters: Record<string, any>; }; } ? { [key in keyof ({ filters: { filters: Record<string, any>; }; } & Required<TAggregationMap>[TAggregationName])[\"filters\"][\"filters\"]]: { doc_count: number; } & SubAggregateOf<{ filters: { filters: Record<string, any>; }; } & Required<TAggregationMap>[TAggregationName], TDocument>; } & ({ filters: { filters: Record<string, any>; }; } & Required<TAggregationMap>[TAggregationName] extends { filters: { other_bucket_key: infer TOtherBucketKey; }; } ? Record<TOtherBucketKey & string, { doc_count: number; } & SubAggregateOf<{ filters: { other_bucket_key: TOtherBucketKey; }; } & { filters: { filters: Record<string, any>; }; } & Required<TAggregationMap>[TAggregationName], TDocument>> : unknown) & ({ filters: { filters: Record<string, any>; }; } & Required<TAggregationMap>[TAggregationName] extends { filters: { other_bucket: true; }; } ? { _other: { doc_count: number; } & SubAggregateOf<{ filters: { other_bucket: true; }; } & { filters: { filters: Record<string, any>; }; } & Required<TAggregationMap>[TAggregationName], TDocument>; } : unknown) : unknown; }; geo_bounds: { top_left: { lat: number | null; lon: number | null; }; bottom_right: { lat: number | null; lon: number | null; }; }; geo_centroid: { count: number; location: { lat: number; lon: number; }; }; geo_distance: MaybeKeyed<Required<TAggregationMap>[TAggregationName], { from: number; to?: number | undefined; doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>, string>; geo_hash: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>)[]; }; geotile_grid: { buckets: ({ doc_count: number; key: string; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>)[]; }; global: { doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>; histogram: MaybeKeyed<Required<TAggregationMap>[TAggregationName], { key: number; doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>, string>; ip_range: MaybeKeyed<Required<TAggregationMap>[TAggregationName], { key: string; from?: string | undefined; to?: string | undefined; doc_count: number; }, Required<TAggregationMap>[TAggregationName] extends { ip_range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; inference: { value: number; prediction_probability: number; prediction_score: number; }; max: { value: number | null; value_as_string?: string | undefined; }; max_bucket: { value: number | null; }; min: { value: number | null; value_as_string?: string | undefined; }; min_bucket: { value: number | null; }; median_absolute_deviation: { value: number | null; }; moving_avg: { value: number | null; } | undefined; moving_fn: { value: number | null; }; moving_percentiles: Required<TAggregationMap>[TAggregationName] extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null> | undefined; missing: { doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>; multi_terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string[]; key_as_string: string; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>)[]; }; nested: { doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>; normalize: { value: number | null; value_as_string?: string | undefined; }; parent: { doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>; percentiles: { values: Required<TAggregationMap>[TAggregationName] extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentile_ranks: { values: Required<TAggregationMap>[TAggregationName] extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; percentiles_bucket: { values: Required<TAggregationMap>[TAggregationName] extends Record<string, { keyed: false; }> ? { key: number; value: number | null; }[] : Record<string, number | null>; }; range: MaybeKeyed<Required<TAggregationMap>[TAggregationName], { key: string; from?: number | undefined; from_as_string?: string | undefined; to?: number | undefined; to_as_string?: string | undefined; doc_count: number; }, Required<TAggregationMap>[TAggregationName] extends { range: { ranges: (infer TRangeType)[]; }; } ? TRangeType extends { key: infer TKeys; } ? TKeys : string : string>; rare_terms: ({ key: string | number; doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>)[]; rate: { value: number | null; }; reverse_nested: { doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>; random_sampler: { seed: number; probability: number; doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>; sampler: { doc_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>; scripted_metric: { value: unknown; }; serial_diff: { value: number | null; value_as_string?: string | undefined; }; significant_terms: { doc_count: number; bg_count: number; buckets: ({ key: string | number; score: number; doc_count: number; bg_count: number; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>)[]; }; significant_text: { doc_count: number; buckets: { key: string; doc_count: number; score: number; bg_count: number; }[]; }; stats: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; } & ({} | { min_as_string: string; max_as_string: string; avg_as_string: string; sum_as_string: string; }); stats_bucket: { count: number; min: number | null; max: number | null; avg: number | null; sum: number; }; string_stats: { count: number; min_length: number | null; max_length: number | null; avg_length: number | null; entropy: number | null; distribution: Record<string, number>; }; sum: { value: number | null; value_as_string?: string | undefined; }; sum_bucket: { value: number | null; }; terms: { doc_count_error_upper_bound: number; sum_other_doc_count: number; buckets: ({ doc_count: number; key: string | number; key_as_string?: string | undefined; } & SubAggregateOf<Required<TAggregationMap>[TAggregationName], TDocument>)[]; }; top_hits: { hits: { total: { value: number; relation: \"gte\" | \"eq\"; }; max_score: number | null; hits: Required<TAggregationMap>[TAggregationName] extends { top_hits: ",
          "AggregationsTopHitsAggregation",
          "; } ? HitsOf<({ top_hits: ",
          "AggregationsTopHitsAggregation",
          "; } & Required<TAggregationMap>[TAggregationName])[\"top_hits\"], TDocument> : ",
          "SearchHitsMetadata",
          "<TDocument>; }; }; top_metrics: { top: { sort: string[] | number[]; metrics: Record<TopMetricKeysOf<Required<TAggregationMap>[TAggregationName]>, string | number | null>; }[]; }; weighted_avg: { value: number | null; }; value_count: { value: number; }; }, Exclude<ValidAggregationKeysOf<Required<TAggregationMap>[TAggregationName]>, \"aggs\" | \"aggregations\"> & string>> : never; }"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.AggregationOptionsByType",
        "type": "Type",
        "tags": [],
        "label": "AggregationOptionsByType",
        "description": [],
        "signature": [
          "{ aggregations: Record<string, ",
          "AggregationsAggregationContainer",
          ">; aggs: Record<string, ",
          "AggregationsAggregationContainer",
          ">; meta: ",
          "Metadata",
          "; adjacency_matrix: ",
          "AggregationsAdjacencyMatrixAggregation",
          "; auto_date_histogram: ",
          "AggregationsAutoDateHistogramAggregation",
          "; avg: ",
          "AggregationsAverageAggregation",
          "; avg_bucket: ",
          "AggregationsAverageBucketAggregation",
          "; boxplot: ",
          "AggregationsBoxplotAggregation",
          "; bucket_script: ",
          "AggregationsBucketScriptAggregation",
          "; bucket_selector: ",
          "AggregationsBucketSelectorAggregation",
          "; bucket_sort: ",
          "AggregationsBucketSortAggregation",
          "; bucket_count_ks_test: ",
          "AggregationsBucketKsAggregation",
          "; bucket_correlation: ",
          "AggregationsBucketCorrelationAggregation",
          "; cardinality: ",
          "AggregationsCardinalityAggregation",
          "; categorize_text: ",
          "AggregationsCategorizeTextAggregation",
          "; children: ",
          "AggregationsChildrenAggregation",
          "; composite: ",
          "AggregationsCompositeAggregation",
          "; cumulative_cardinality: ",
          "AggregationsCumulativeCardinalityAggregation",
          "; cumulative_sum: ",
          "AggregationsCumulativeSumAggregation",
          "; date_histogram: ",
          "AggregationsDateHistogramAggregation",
          "; date_range: ",
          "AggregationsDateRangeAggregation",
          "; derivative: ",
          "AggregationsDerivativeAggregation",
          "; diversified_sampler: ",
          "AggregationsDiversifiedSamplerAggregation",
          "; extended_stats: ",
          "AggregationsExtendedStatsAggregation",
          "; extended_stats_bucket: ",
          "AggregationsExtendedStatsBucketAggregation",
          "; frequent_item_sets: ",
          "AggregationsFrequentItemSetsAggregation",
          "; filter: ",
          "QueryDslQueryContainer",
          "; filters: ",
          "AggregationsFiltersAggregation",
          "; geo_bounds: ",
          "AggregationsGeoBoundsAggregation",
          "; geo_centroid: ",
          "AggregationsGeoCentroidAggregation",
          "; geo_distance: ",
          "AggregationsGeoDistanceAggregation",
          "; geohash_grid: ",
          "AggregationsGeoHashGridAggregation",
          "; geo_line: ",
          "AggregationsGeoLineAggregation",
          "; geotile_grid: ",
          "AggregationsGeoTileGridAggregation",
          "; geohex_grid: ",
          "AggregationsGeohexGridAggregation",
          "; global: ",
          "AggregationsGlobalAggregation",
          "; histogram: ",
          "AggregationsHistogramAggregation",
          "; ip_range: ",
          "AggregationsIpRangeAggregation",
          "; ip_prefix: ",
          "AggregationsIpPrefixAggregation",
          "; inference: ",
          "AggregationsInferenceAggregation",
          "; line: ",
          "AggregationsGeoLineAggregation",
          "; matrix_stats: ",
          "AggregationsMatrixStatsAggregation",
          "; max: ",
          "AggregationsMaxAggregation",
          "; max_bucket: ",
          "AggregationsMaxBucketAggregation",
          "; median_absolute_deviation: ",
          "AggregationsMedianAbsoluteDeviationAggregation",
          "; min: ",
          "AggregationsMinAggregation",
          "; min_bucket: ",
          "AggregationsMinBucketAggregation",
          "; missing: ",
          "AggregationsMissingAggregation",
          "; moving_avg: ",
          "AggregationsMovingAverageAggregation",
          "; moving_percentiles: ",
          "AggregationsMovingPercentilesAggregation",
          "; moving_fn: ",
          "AggregationsMovingFunctionAggregation",
          "; multi_terms: ",
          "AggregationsMultiTermsAggregation",
          "; nested: ",
          "AggregationsNestedAggregation",
          "; normalize: ",
          "AggregationsNormalizeAggregation",
          "; parent: ",
          "AggregationsParentAggregation",
          "; percentile_ranks: ",
          "AggregationsPercentileRanksAggregation",
          "; percentiles: ",
          "AggregationsPercentilesAggregation",
          "; percentiles_bucket: ",
          "AggregationsPercentilesBucketAggregation",
          "; range: ",
          "AggregationsRangeAggregation",
          "; rare_terms: ",
          "AggregationsRareTermsAggregation",
          "; rate: ",
          "AggregationsRateAggregation",
          "; reverse_nested: ",
          "AggregationsReverseNestedAggregation",
          "; random_sampler: ",
          "AggregationsRandomSamplerAggregation",
          "; sampler: ",
          "AggregationsSamplerAggregation",
          "; scripted_metric: ",
          "AggregationsScriptedMetricAggregation",
          "; serial_diff: ",
          "AggregationsSerialDifferencingAggregation",
          "; significant_terms: ",
          "AggregationsSignificantTermsAggregation",
          "; significant_text: ",
          "AggregationsSignificantTextAggregation",
          "; stats: ",
          "AggregationsStatsAggregation",
          "; stats_bucket: ",
          "AggregationsStatsBucketAggregation",
          "; string_stats: ",
          "AggregationsStringStatsAggregation",
          "; sum: ",
          "AggregationsSumAggregation",
          "; sum_bucket: ",
          "AggregationsSumBucketAggregation",
          "; terms: ",
          "AggregationsTermsAggregation",
          "; time_series: ",
          "AggregationsTimeSeriesAggregation",
          "; top_hits: ",
          "AggregationsTopHitsAggregation",
          "; t_test: ",
          "AggregationsTTestAggregation",
          "; top_metrics: ",
          "AggregationsTopMetricsAggregation",
          "; value_count: ",
          "AggregationsValueCountAggregation",
          "; weighted_avg: ",
          "AggregationsWeightedAverageAggregation",
          "; variable_width_histogram: ",
          "AggregationsVariableWidthHistogramAggregation",
          "; }"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/index.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.ESFilter",
        "type": "Type",
        "tags": [],
        "label": "ESFilter",
        "description": [],
        "signature": [
          "QueryDslQueryContainer"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/index.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.ESQLRow",
        "type": "Type",
        "tags": [],
        "label": "ESQLRow",
        "description": [],
        "signature": [
          "unknown[]"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.ESSearchRequest",
        "type": "Type",
        "tags": [],
        "label": "ESSearchRequest",
        "description": [],
        "signature": [
          "SearchRequest",
          " | ",
          "SearchRequest"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/index.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.ESSearchResponse",
        "type": "Type",
        "tags": [],
        "label": "ESSearchResponse",
        "description": [],
        "signature": [
          "Omit<",
          "SearchResponse",
          "<TDocument, Record<string, ",
          "AggregationsAggregate",
          ">>, \"aggregations\" | \"hits\"> & (TSearchRequest[\"body\"] extends TopLevelAggregationRequest ? WrapAggregationResponse<SubAggregateOf<TSearchRequest[\"body\"], TDocument>> : TSearchRequest extends TopLevelAggregationRequest ? WrapAggregationResponse<SubAggregateOf<TSearchRequest, TDocument>> : { aggregations?: unknown; }) & { hits: Omit<",
          "SearchHitsMetadata",
          "<TDocument>, \"total\" | \"hits\"> & (TOptions[\"restTotalHitsAsInt\"] extends true ? { total: number; } : { total: { value: number; relation: \"gte\" | \"eq\"; }; }) & { hits: HitsOf<TSearchRequest extends ",
          "SearchRequest",
          " ? TSearchRequest[\"body\"] : TSearchRequest, TDocument>; }; }"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/index.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.ESSourceOptions",
        "type": "Type",
        "tags": [],
        "label": "ESSourceOptions",
        "description": [],
        "signature": [
          "string | boolean | string[]"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/index.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.InferSearchResponseOf",
        "type": "Type",
        "tags": [],
        "label": "InferSearchResponseOf",
        "description": [],
        "signature": [
          "Omit<",
          "SearchResponse",
          "<TDocument, Record<string, ",
          "AggregationsAggregate",
          ">>, \"aggregations\" | \"hits\"> & (TSearchRequest[\"body\"] extends TopLevelAggregationRequest ? WrapAggregationResponse<SubAggregateOf<TSearchRequest[\"body\"], TDocument>> : TSearchRequest extends TopLevelAggregationRequest ? WrapAggregationResponse<SubAggregateOf<TSearchRequest, TDocument>> : { aggregations?: unknown; }) & { hits: Omit<",
          "SearchHitsMetadata",
          "<TDocument>, \"total\" | \"hits\"> & (TOptions[\"restTotalHitsAsInt\"] extends true ? { total: number; } : { total: { value: number; relation: \"gte\" | \"eq\"; }; }) & { hits: HitsOf<TSearchRequest extends ",
          "SearchRequest",
          " ? TSearchRequest[\"body\"] : TSearchRequest, TDocument>; }; }"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.MaybeReadonlyArray",
        "type": "Type",
        "tags": [],
        "label": "MaybeReadonlyArray",
        "description": [],
        "signature": [
          "T[] | readonly T[]"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/index.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.SearchField",
        "type": "Type",
        "tags": [],
        "label": "SearchField",
        "description": [],
        "signature": [
          "string | ",
          "QueryDslFieldAndFormat"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/index.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      },
      {
        "parentPluginId": "@kbn/es-types",
        "id": "def-common.SearchHit",
        "type": "Type",
        "tags": [],
        "label": "SearchHit",
        "description": [],
        "signature": [
          "Omit<",
          "SearchHit",
          "<unknown>, \"fields\" | \"_source\"> & (TSource extends false ? {} : { _source: TSource; }) & (TFields extends (string | ",
          "QueryDslFieldAndFormat",
          ")[] ? { fields: Partial<Record<ValueTypeOfField<TFields>, unknown[]>>; } : { fields?: Record<string, unknown[]> | undefined; }) & (TDocValueFields extends DocValueFields ? { fields: Partial<Record<ValueTypeOfField<TDocValueFields>, unknown[]>>; } : {})"
        ],
        "path": "src/platform/packages/shared/kbn-es-types/src/search.ts",
        "deprecated": false,
        "trackAdoption": false,
        "initialIsOpen": false
      }
    ],
    "objects": []
  }
}